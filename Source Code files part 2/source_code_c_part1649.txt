        // y[e5]=    132
          1248,         // y[e6]=    156
          1184,         // y[e7]=    148
          1888,         // y[e8]=    236
          1824,         // y[e9]=    228
          2016,         // y[ea]=    252
          1952,         // y[eb]=    244
          1632,         // y[ec]=    204
          1568,         // y[ed]=    196
          1760,         // y[ee]=    220
          1696,         // y[ef]=    212
           688,         // y[f0]=     86
           656,         // y[f1]=     82
           752,         // y[f2]=     94
           720,         // y[f3]=     90
           560,         // y[f4]=     70
           528,         // y[f5]=     66
           624,         // y[f6]=     78
           592,         // y[f7]=     74
           944,         // y[f8]=    118
           912,         // y[f9]=    114
          1008,         // y[fa]=    126
           976,         // y[fb]=    122
           816,         // y[fc]=    102
           784,         // y[fd]=     98
           880,         // y[fe]=    110
           848          // y[ff]=    106
    };

//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToPcmTable
//
//
//  Description:
//      this array maps u-law characters to 16-bit PCM
//
//  Arguments:
//      the index into the array is a u-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT UlawToPcmTable[256] =
    {
        -32124,         // y[00]=  -8031
        -31100,         // y[01]=  -7775
        -30076,         // y[02]=  -7519
        -29052,         // y[03]=  -7263
        -28028,         // y[04]=  -7007
        -27004,         // y[05]=  -6751
        -25980,         // y[06]=  -6495
        -24956,         // y[07]=  -6239
        -23932,         // y[08]=  -5983
        -22908,         // y[09]=  -5727
        -21884,         // y[0a]=  -5471
        -20860,         // y[0b]=  -5215
        -19836,         // y[0c]=  -4959
        -18812,         // y[0d]=  -4703
        -17788,         // y[0e]=  -4447
        -16764,         // y[0f]=  -4191
        -15996,         // y[10]=  -3999
        -15484,         // y[11]=  -3871
        -14972,         // y[12]=  -3743
        -14460,         // y[13]=  -3615
        -13948,         // y[14]=  -3487
        -13436,         // y[15]=  -3359
        -12924,         // y[16]=  -3231
        -12412,         // y[17]=  -3103
        -11900,         // y[18]=  -2975
        -11388,         // y[19]=  -2847
        -10876,         // y[1a]=  -2719
        -10364,         // y[1b]=  -2591
         -9852,         // y[1c]=  -2463
         -9340,         // y[1d]=  -2335
         -8828,         // y[1e]=  -2207
         -8316,         // y[1f]=  -2079
         -7932,         // y[20]=  -1983
         -7676,         // y[21]=  -1919
         -7420,         // y[22]=  -1855
         -7164,         // y[23]=  -1791
         -6908,         // y[24]=  -1727
         -6652,         // y[25]=  -1663
         -6396,         // y[26]=  -1599
         -6140,         // y[27]=  -1535
         -5884,         // y[28]=  -1471
         -5628,         // y[29]=  -1407
         -5372,         // y[2a]=  -1343
         -5116,         // y[2b]=  -1279
         -4860,         // y[2c]=  -1215
         -4604,         // y[2d]=  -1151
         -4348,         // y[2e]=  -1087
         -4092,         // y[2f]=  -1023
         -3900,         // y[30]=   -975
         -3772,         // y[31]=   -943
         -3644,         // y[32]=   -911
         -3516,         // y[33]=   -879
         -3388,         // y[34]=   -847
         -3260,         // y[35]=   -815
         -3132,         // y[36]=   -783
         -3004,         // y[37]=   -751
         -2876,         // y[38]=   -719
         -2748,         // y[39]=   -687
         -2620,         // y[3a]=   -655
         -2492,         // y[3b]=   -623
         -2364,         // y[3c]=   -591
         -2236,         // y[3d]=   -559
         -2108,         // y[3e]=   -527
         -1980,         // y[3f]=   -495
         -1884,         // y[40]=   -471
         -1820,         // y[41]=   -455
         -1756,         // y[42]=   -439
         -1692,         // y[43]=   -423
         -1628,         // y[44]=   -407
         -1564,         // y[45]=   -391
         -1500,         // y[46]=   -375
         -1436,         // y[47]=   -359
         -1372,         // y[48]=   -343
         -1308,         // y[49]=   -327
         -1244,         // y[4a]=   -311
         -1180,         // y[4b]=   -295
         -1116,         // y[4c]=   -279
         -1052,         // y[4d]=   -263
          -988,         // y[4e]=   -247
          -924,         // y[4f]=   -231
          -876,         // y[50]=   -219
          -844,         // y[51]=   -211
          -812,         // y[52]=   -203
          -780,         // y[53]=   -195
          -748,         // y[54]=   -187
          -716,         // y[55]=   -179
          -684,         // y[56]=   -171
          -652,         // y[57]=   -163
          -620,         // y[58]=   -155
          -588,         // y[59]=   -147
          -556,         // y[5a]=   -139
          -524,         // y[5b]=   -131
          -492,         // y[5c]=   -123
          -460,         // y[5d]=   -115
          -428,         // y[5e]=   -107
          -396,         // y[5f]=    -99
          -372,         // y[60]=    -93
          -356,         // y[61]=    -89
          -340,         // y[62]=    -85
          -324,         // y[63]=    -81
          -308,         // y[64]=    -77
          -292,         // y[65]=    -73
          -276,         // y[66]=    -69
          -260,         // y[67]=    -65
          -244,         // y[68]=    -61
          -228,         // y[69]=    -57
          -212,         // y[6a]=    -53
          -196,         // y[6b]=    -49
          -180,         // y[6c]=    -45
          -164,         // y[6d]=    -41
          -148,         // y[6e]=    -37
          -132,         // y[6f]=    -33
          -120,         // y[70]=    -30
          -112,         // y[71]=    -28
          -104,         // y[72]=    -26
           -96,         // y[73]=    -24
           -88,         // y[74]=    -22
           -80,         // y[75]=    -20
           -72,         // y[76]=    -18
           -64,         // y[77]=    -16
           -56,         // y[78]=    -14
           -48,         // y[79]=    -12
           -40,         // y[7a]=    -10
           -32,         // y[7b]=     -8
           -24,         // y[7c]=     -6
           -16,         // y[7d]=     -4
            -8,         // y[7e]=     -2
             0,         // y[7f]=      0
         32124,         // y[80]=   8031
         31100,         // y[81]=   7775
         30076,         // y[82]=   7519
         29052,         // y[83]=   7263
         28028,         // y[84]=   7007
         27004,         // y[85]=   6751
         25980,         // y[86]=   6495
         24956,         // y[87]=   6239
         23932,         // y[88]=   5983
         22908,         // y[89]=   5727
         21884,         // y[8a]=   5471
         20860,         // y[8b]=   5215
         19836,         // y[8c]=   4959
         18812,         // y[8d]=   4703
         17788,         // y[8e]=   4447
         16764,         // y[8f]=   4191
         15996,         // y[90]=   3999
         15484,         // y[91]=   3871
         14972,         // y[92]=   3743
         14460,         // y[93]=   3615
         13948,         // y[94]=   3487
         13436,         // y[95]=   3359
         12924,         // y[96]=   3231
         12412,         // y[97]=   3103
         11900,         // y[98]=   2975
         11388,         // y[99]=   2847
         10876,         // y[9a]=   2719
         10364,         // y[9b]=   2591
          9852,         // y[9c]=   2463
          9340,         // y[9d]=   2335
          8828,         // y[9e]=   2207
          8316,         // y[9f]=   2079
          7932,         // y[a0]=   1983
          7676,         // y[a1]=   1919
          7420,         // y[a2]=   1855
          7164,         // y[a3]=   1791
          6908,         // y[a4]=   1727
          6652,         // y[a5]=   1663
          6396,         // y[a6]=   1599
          6140,         // y[a7]=   1535
          5884,         // y[a8]=   1471
          5628,         // y[a9]=   1407
          5372,         // y[aa]=   1343
          5116,         // y[ab]=   1279
          4860,         // y[ac]=   1215
          4604,         // y[ad]=   1151
          4348,         // y[ae]=   1087
          4092,         // y[af]=   1023
          3900,         // y[b0]=    975
          3772,         // y[b1]=    943
          3644,         // y[b2]=    911
          3516,         // y[b3]=    879
          3388,         // y[b4]=    847
          3260,         // y[b5]=    815
          3132,         // y[b6]=    783
          3004,         // y[b7]=    751
          2876,         // y[b8]=    719
          2748,         // y[b9]=    687
          2620,         // y[ba]=    655
          2492,         // y[bb]=    623
          2364,         // y[bc]=    591
          2236,         // y[bd]=    559
          2108,         // y[be]=    527
          1980,         // y[bf]=    495
          1884,         // y[c0]=    471
          1820,         // y[c1]=    455
          1756,         // y[c2]=    439
          1692,         // y[c3]=    423
          1628,         // y[c4]=    407
          1564,         // y[c5]=    391
          1500,         // y[c6]=    375
          1436,         // y[c7]=    359
          1372,         // y[c8]=    343
          1308,         // y[c9]=    327
          1244,         // y[ca]=    311
          1180,         // y[cb]=    295
          1116,         // y[cc]=    279
          1052,         // y[cd]=    263
           988,         // y[ce]=    247
           924,         // y[cf]=    231
           876,         // y[d0]=    219
           844,         // y[d1]=    211
           812,         // y[d2]=    203
           780,         // y[d3]=    195
           748,         // y[d4]=    187
           716,         // y[d5]=    179
           684,         // y[d6]=    171
           652,         // y[d7]=    163
           620,         // y[d8]=    155
           588,         // y[d9]=    147
           556,         // y[da]=    139
           524,         // y[db]=    131
           492,         // y[dc]=    123
           460,         // y[dd]=    115
           428,         // y[de]=    107
           396,         // y[df]=     99
           372,         // y[e0]=     93
           356,         // y[e1]=     89
           340,         // y[e2]=     85
           324,         // y[e3]=     81
           308,         // y[e4]=     77
           292,         // y[e5]=     73
           276,         // y[e6]=     69
           260,         // y[e7]=     65
           244,         // y[e8]=     61
           228,         // y[e9]=     57
           212,         // y[ea]=     53
           196,         // y[eb]=     49
           180,         // y[ec]=     45
           164,         // y[ed]=     41
           148,         // y[ee]=     37
           132,         // y[ef]=     33
           120,         // y[f0]=     30
           112,         // y[f1]=     28
           104,         // y[f2]=     26
            96,         // y[f3]=     24
            88,         // y[f4]=     22
            80,         // y[f5]=     20
            72,         // y[f6]=     18
            64,         // y[f7]=     16
            56,         // y[f8]=     14
            48,         // y[f9]=     12
            40,         // y[fa]=     10
            32,         // y[fb]=      8
            24,         // y[fc]=      6
            16,         // y[fd]=      4
             8,         // y[fe]=      2
             0          // y[ff]=      0
    };







DWORD WINAPI
ConvertaLawto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)Context;

    PSHORT    RealDest=(PSHORT)Destination;

    LPBYTE    EndPoint=Source+SourceLength;


    while (Source < EndPoint) {

        *RealDest++= AdjustGain(
                         AlawToPcmTable[*Source++],
                         State->Gain
                         );

    }

    return SourceLength*2;

}


DWORD WINAPI
ConvertuLawto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)Context;

    PSHORT    RealDest=(PSHORT)Destination;

    LPBYTE    EndPoint=Source+SourceLength;


    while (Source < EndPoint) {

        *RealDest++= AdjustGain(
                         UlawToPcmTable[*Source++],
                         State->Gain
                         );

    }

    return SourceLength*2;

}






DWORD WINAPI
Convert16PCMtoaLaw(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)Context;

    PSHORT    RealSource=(PSHORT)Source;

    LPWORD    EndPoint=RealSource+SourceLength/2;

    SHORT     wSample;

    BYTE      alaw;

    while (RealSource < EndPoint) {

        //  Get a signed 16-bit PCM sample from the src buffer
        //

        wSample = AdjustGain(*RealSource++,State->Gain);

        //
        // We'll init our A-law value per the sign of the PCM sample.  A-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the A-law character bits.
        //
        if (wSample < 0) {

            alaw = 0x00;
            wSample = -wSample;

            if (wSample < 0) {

               wSample = 0x7FFF;
            }

        } else {

            alaw = 0x80;

        }

        // Now we test the PCM sample amplitude and create the A-law character.
        // Study the CCITT A-law for more detail.

        if (wSample >= 2048)
            // 2048 <= wSample < 32768
            {
            if (wSample >= 8192)
                // 8192 <= wSample < 32768
                {
                if (wSample >= 16384)
                    // 16384 <= wSample < 32768
                    {
                    alaw |= 0x70 | ((wSample >> 10) & 0x0F);
                    }

                else
                    // 8192 <= wSample < 16384
                    {
                    alaw |= 0x60 | ((wSample >> 9) & 0x0F);
                    }
                }
            else
                // 2048 <= wSample < 8192
                {

                if (wSample >= 4096)
                    // 4096 <= wSample < 8192
                    {
                    alaw |= 0x50 | ((wSample >> 8) & 0x0F);
                    }

                else
                    // 2048 <= wSample < 4096
                    {
                    alaw |= 0x40 | ((wSample >> 7) & 0x0F);
                    }
                }
            }
        else
            // 0 <= wSample < 2048
            {
            if (wSample >= 512)
                // 512 <= wSample < 2048
                {

                if (wSample >= 1024)
                    // 1024 <= wSample < 2048
                    {
                    alaw |= 0x30 | ((wSample >> 6) & 0x0F);
                    }

                else
                    // 512 <= wSample < 1024
                    {
                    alaw |= 0x20 | ((wSample >> 5) & 0x0F);
                    }
                }
            else
                    // 0 <= wSample < 512
                    {
                    alaw |= 0x00 | ((wSample >> 4) & 0x1F);
                    }
            }


        *Destination++=alaw ^ 0x55;      // Invert even bits

    }

    return SourceLength/2;

}

DWORD WINAPI
Convert16PCMtouLaw(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)Context;

    LPWORD    RealSource=(LPWORD)Source;

    LPWORD    EndPoint=RealSource+SourceLength/2;

    SHORT     wSample;

    BYTE      ulaw;

    while (RealSource < EndPoint) {

        //  Get a signed 16-bit PCM sample from the src buffer

        wSample = AdjustGain(*RealSource++,State->Gain);

        // We'll init our u-law value per the sign of the PCM sample.  u-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the u-law character bits.
        if (wSample < 0)
            {
            ulaw = 0x00;
            wSample = -wSample;
            if (wSample < 0) wSample = 0x7FFF;
            }
        else
            {
            ulaw = 0x80;
            }

        // For now, let's shift this 16-bit value
        //  so that it is within the range defined
        //  by CCITT u-law.
        wSample = wSample >> 2;

        // Now we test the PCM sample amplitude and create the u-law character.
        // Study the CCITT u-law for more details.
        if (wSample >= 8159)
            goto Gotulaw;
        if (wSample >= 4063)
            {
            ulaw |= 0x00 + 15-((wSample-4063)/256);
            goto Gotulaw;
            }
        if (wSample >= 2015)
            {
            ulaw |= 0x10 + 15-((wSample-2015)/128);
            goto Gotulaw;
            }
        if (wSample >= 991)
            {
            ulaw |= 0x20 + 15-((wSample-991)/64);
            goto Gotulaw;
            }
        if (wSample >= 479)
            {
            ulaw |= 0x30 + 15-((wSample-479)/32);
            goto Gotulaw;
            }
        if (wSample >= 223)
            {
            ulaw |= 0x40 + 15-((wSample-223)/16);
            goto Gotulaw;
            }
        if (wSample >= 95)
            {
            ulaw |= 0x50 + 15-((wSample-95)/8);
            goto Gotulaw;
            }
        if (wSample >= 31)
            {
            ulaw |= 0x60 + 15-((wSample-31)/4);
            goto Gotulaw;
            }
        ulaw |= 0x70 + 15-((wSample)/2);

Gotulaw:

        *Destination++=ulaw;

    }

    return SourceLength/2;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "SERWVDRV"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif

#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\init.c ===
//---------------------------------------------------------------------------
//
//  Module:   init.c
//
//  Description:
//     MSSB16 initialization routines
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//              4/21/94   BryanW      Added this comment block.
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/



#pragma warning (disable:4704)

#include "xfrmpriv.h"


//
// public data
// 

HMODULE     ghModule ;              // our module handle


BOOL APIENTRY
DllMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch(dwReason) {

        case DLL_PROCESS_ATTACH:


            break;

        case DLL_PROCESS_DETACH:


            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

        default:
              break;

    }

    return TRUE;

}



//--------------------------------------------------------------------------
//  
//  int LibMain
//  
//  Description:
//      Library initialization code
//  
//  Parameters:
//      HMODULE hModule
//         Module handle
//  
//      UINT uDataSeg
//         selector of data segment
//
//      UINT uHeapSize
//         Heap size as specified in .DEF
//  
//      LPSTR lpCmdLine
//         command line passed from kernel
//  
//  Return (int):
//      1 if successful
//  
//@@BEGIN_MSINTERNAL
//  History:   Date       Author      Comment
//              5/20/93   BryanW      
//@@END_MSINTERNAL
//  
//--------------------------------------------------------------------------

int FAR PASCAL LibMain
(
    HMODULE         hModule,
    UINT            uDataSeg,
    UINT            uHeapSize,
    LPSTR           lpCmdLine
)
{

    DbgInitialize(TRUE);
	DPF (1, "LibMain()");

    //
    //  save our module handle
    //

    ghModule = hModule;


    //
    //  succeed the load...
    //
    return (1) ;

} // LibMain()






//---------------------------------------------------------------------------
//  End of File: init.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\rwadpcm.h ===
//---------------------------------------------------------------------------
//
//  Module:   rwadpcm.h
//
//  Description:
//     Header file for Rockwell ADPCM
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//             8/31/95    MMaclin     Removed from driver.h
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1991 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#define RWADPCM_4BIT_SAMPLESTOBYTES(dwSamples) ((dwSamples)/2)
#define RWADPCM_4BIT_BYTESTOSAMPLES(dwBytes) ((dwBytes)*2)

#define RVF_SETSL 1
#define RVF_RETAIN_LSB 2
#define RVF_RETAIN_MSB 4

VOID PASCAL
RVComInit(
    UINT bps
    );

VOID PASCAL
RVDecomInit(
    int SetSLFlag, 
    UINT bps, 
    UINT (far PASCAL *SLCallBack)()
    );


DWORD PASCAL
RVDecom4bpsByteNew(
    BYTE Qdata0
    );



BYTE PASCAL
RVCom4bpsByteNew(
    DWORD Src
    );



VOID PASCAL
RWADPCMCom4bit(LPDWORD lpSrc, 
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );

VOID PASCAL
RWADPCMDecom4bit(LPSTR lpSrc, 
            DWORD dwSrcLen,
            LPDWORD lpDst,
            DWORD dwDstLen
            );
#if 0
VOID PASCAL
SRConvert7200to8000(LPINT lpSrc,
            DWORD dwSrcLen,
            LPINT lpDst,
            DWORD dwDstLen
            );

VOID PASCAL
SRConvert8000to7200(LPINT lpSrc,
            DWORD dwSrcLen,
            LPINT lpDst,
            DWORD dwDstLen
            );
#endif

VOID PASCAL
RWADPCMDecom4bitNoGain(LPSTR lpSrc,
            DWORD dwSrcLen,
            LPDWORD lpDst,
            DWORD dwDstLen
            );



//---------------------------------------------------------------------------
//  End of File: rwadpcm.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support.
//      All code compiles to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef _WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
    #define MessageBoxA         MessageBox
    #define TEXT(x)		(x)
    #define wsprintfA		wsprintf
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef _WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static char     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
		DebugBreak();
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\rockwell.c ===
//---------------------------------------------------------------------------
//
//  Module:   rockwell.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Brian Lieuallen
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1997	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

/*************************************************************************
 *************************************************************************
 ***                   Copyright (c) 1995-1996                         ***
 ***                 Rockwell Telecommunications                       ***
 ***               Digital Communications Division                     ***
 ***                     All rights reserved                           ***
 ***                                                                   ***
 ***              CONFIDENTIAL -- No Dissemination or                  ***
 ***             use without prior written permission                  ***
 ***                                                                   ***
 *************************************************************************
 *                                                                       *
 *    MODULE NAME:     MAIN.C                                            *
 *                                                                       *
 *    AUTHOR:          Stanislav Miller,                                 *
 *                     REDC, Moscow, Russia                              *
 *                                                                       *
 *    HISTORY:         Major Revision         Date             By        *
 *                     --------------       ----------   -------------   *
 *                     Created              06/27/1995   S.Miller        *
 *                     Completed            02/01/1996   S.Miller        *
 *                                                                       *
 *    DESCRIPTION:     This main module contains core functions          *
 *                     for Rockwells ADPCM codec algorithm.              *
 *                                                                       *
 *    NOTES:           Compiling:  Visual C++ v2.0                       *
 *                                                                       *
 *************************************************************************
 *************************************************************************/



#include "xfrmpriv.h"
#include <math.h>

//#include "Rockwell.h"

/* ----------------------- 16 Level case ----------------------------- */
const double Alp16[] = {
   0.2582, 0.5224, 0.7996, 1.099, 1.437, 1.844, 2.401};

const double Bet16[] = {
  -2.733, -2.069, -1.618, -1.256, -0.9424, -0.6568, -0.3881,
  -0.1284, 0.1284, 0.3881, 0.6568, 0.9424, 1.256, 1.618, 2.069, 2.733};

const double M16[] = {
  2.4, 2.0, 1.6, 1.2, 0.9, 0.9, 0.9, 0.9,
  0.9, 0.9, 0.9, 0.9, 1.2, 1.6, 2.0, 2.4};


const double fPow0_8[] = {      /* 0.8**i */
0.800000, 0.640000, 0.512000, 0.409600, 0.327680, 0.262144  
};

const double fMinusPow0_5[] = { /* -0.5**i */
-0.500000, -0.250000, -0.125000, -0.062500, -0.031250, -0.015625  
};


#pragma optimize("t",on)

// Description:
//    This procedure provide sign difference calculation between 'a' and 'b'
// Parameters:
//    a - double type valueb - double type value
// Return Value:
//     1.0 if signs 'a' and 'b' are the same;
//    -1.0 if signs 'a' and 'b' are different;
//
double _inline
XorSgn(
    double a,
    double b
)
{
    if (a*b >= 0.) {

       return 1;

    } else {

       return -1;
    }
}

// Description:
//    This procedure converts normalized float value to normalized
//    short int value
// Parameters:
//    a - normalized double type value
// Return Value:
//    Normalized short value, [-3276832767]
//
short _inline
SShort(
    double a
    )
{
    a *= 32768.0;

    if (a>32767.0) {

        a=32767.0;

    } else {

        if (a<-32768.0) {

            a=-32768.0;
        }
    }

    return (short)a;
}

// Description:
//    This procedure converts normalized short int value to 
//    normalized float value
// Parameters:
//    a - normalized short value, [-3276832767]
// Return Value:
//    Normalized double value
//
double
Double(
    short a
    )
{
  return ((double)a / 32768.);
}

//
//
//  encoder crap
//
//

// Description:
//    This procedure provides implementation of pre-emphasis 
//    filterthat adds gain to the higher frequency components
//    of the speech signal for encoder
// Parameters:
//    x - double value (incoming sample)
// Return Value:
//    double value (filtered sample)
//
double _inline
PreEmphasis(
    LPCOMPRESS_OBJECT  Compress,
    double x
    )
{
  double Y = x - .5*Compress->RW.X1;
  Compress->RW.X1 = x;
  return Y;
}



/* 4bits Quantizer */
// Description:
//    This procedure provides 4-bits quantization
// Parameters:
//    inp - double value (normalized input sample)
// Return Value:
//    double value (quantized sample)
double _inline
QuantStep4(
    CQDATA *QData,
    double inp
    )
{
  int i;
  double Sigma = M16[QData->CodedQout] * QData->Sigma1;
  double x = fabs(inp);

  if(Sigma > SigmaMAX16) Sigma = SigmaMAX16;
  else if(Sigma < SigmaMIN) Sigma = SigmaMIN;

  for(i=0; i<7; i++) if( x < Alp16[i]*Sigma ) break;
  QData->CodedQout = inp>=0. ? 8+i : 7-i;
  QData->Sigma1 = Sigma;

  return (QData->out = Bet16[QData->CodedQout] * Sigma);
}



// Description:
//    This procedure takes one incoming normalized float 
//    speech valueand saves encoding result to the output
//    bitstream via 'Pack' function;
// Parameters:
//    x - double value (incoming filtered sample)
// Return Value:
//    non-packed output Code Word
BYTE
encoder(
    LPCOMPRESS_OBJECT  Compress,
    double x
    )
{
    int i;
    double Xz, Xp, Xpz, d;


    //
    // This is a first step of encoding schema before quantization
    //
    for(Xz=0.,i=1; i<=6; i++) Xz += Compress->RW.q[i]*Compress->RW.b[i-1];
    for(Xp=0.,i=1; i<=2; i++) Xp += Compress->RW.y[i]*Compress->RW.a[i-1];

    Xpz = Xp+Xz;
    d = x - Xpz;

    //
    // This is a quantization step (QuantStep4, QuantStep3 or QuantStep2)
    // according to selected count bit per code word
    //
    Compress->RW.q[0] = QuantStep4(&Compress->RW.CQData,d);  // Invoking Quantization function via pointer
    Compress->RW.y[0] = Compress->RW.q[0]+Xpz;

    //
    // Updating the filters
    //
    for(i=1; i<=6; i++) Compress->RW.b[i-1] = 0.98*Compress->RW.b[i-1] + 0.006*XorSgn(Compress->RW.q[0],Compress->RW.q[i]);
    for(i=1; i<=2; i++) Compress->RW.a[i-1] = 0.98*Compress->RW.a[i-1] + 0.012*XorSgn(Compress->RW.q[0],Compress->RW.y[i]);

    //
    // shifting vectors
    //
    for(i=6; i>=1; i--) Compress->RW.q[i]=Compress->RW.q[i-1];
    for(i=2; i>=1; i--) Compress->RW.y[i]=Compress->RW.y[i-1];


    // Returning not packed code word
    //
    return (BYTE)Compress->RW.CQData.CodedQout;
}

//
//
//  decoder stuff
//
//


// Description:
//    This procedure provides implementation of de-emphasis filter
//    that adds gain to the higher frequency components of the speech
//    signal for decoder
// Parameters:
//    x - double value (decoded sample)
// Return Value:
//    double value (filtered sample)
double _inline
DeEmphasis(
    LPDECOMPRESS_OBJECT  Decompress,
    double x
)
{
  Decompress->RW.Y1 = x + .4*Decompress->RW.Y1;
  return Decompress->RW.Y1;
}


/* 4bits DeQuantizer */
// Description:
//    This procedure provides 4-bits dequantization
// Parameters:
//    inp - int value (Code Word)
// Return Value:
//    double value (dequantized sample)
//
double _inline
DeQuantStep4(
    CDQDATA    *DQData,
    int inp
    )  // oldCode == 8;
{
    double Sigma = M16[DQData->oldCode] * DQData->Sigma1;

    if (Sigma > SigmaMAX16) {

        Sigma = SigmaMAX16;

    } else {

        if (Sigma < SigmaMIN) {

            Sigma = SigmaMIN;
        }
    }

    DQData->oldCode = inp;
    DQData->Sigma1  = Sigma;

    return (DQData->out = Bet16[inp] * Sigma);
}



// Description:
//    This procedure takes one Code Word from incoming bitstream
//    and returns decoded speech sample as normalized double value
// Parameters:
//    xs - int value, Code Word
// Return Value:
//    double value (decoded speech sample)
//
double
decoderImm(
    LPDECOMPRESS_OBJECT  Decompress,
    int xs
)
{
    int i;
    double Xz, Xp, Xpz;
    double R;



    // This is a dequantization step (Adaptive Predictor)
    // (DeQuantStep4, DeQuantStep3 or DeQuantStep2)
    // according to selected count bit per code word
    //

    Decompress->RW.q0[0] = DeQuantStep4(&Decompress->RW.CDQData, xs);  // Invoking deQuantization function via pointer

    //
    // Updating the filters
    //
    for(Xz=0.,i=1; i<=6; i++) Xz += Decompress->RW.q0[i] * Decompress->RW.b0[i-1];
    for(Xp=0.,i=1; i<=2; i++) Xp += Decompress->RW.y0[i] * Decompress->RW.a0[i-1];
    Xpz = Xp+Xz;
    Decompress->RW.y0[0] = Decompress->RW.q0[0]+Xpz;

    //
    // If Postfilter selected...
    //
    if (Decompress->RW.PostFilter) {
        //
        // Postfilter 1
        //
        Decompress->RW.q1[0] = Decompress->RW.y0[0];
        for(Xz=0.,i=1; i<=6; i++) Xz += Decompress->RW.q1[i] * Decompress->RW.b1[i-1];
        for(Xp=0.,i=1; i<=2; i++) Xp += Decompress->RW.y1[i] * Decompress->RW.a1[i-1];
        Xpz = Xp+Xz;
        Decompress->RW.y1[0] = Decompress->RW.q1[0]+Xpz;

        //
        //  Postfilter 2
        //
        Decompress->RW.y2[0] = Decompress->RW.y1[0];
        for(Xz=0.,i=1; i<=6; i++) Xz += Decompress->RW.q2[i] * Decompress->RW.b2[i-1];
        for(Xp=0.,i=1; i<=2; i++) Xp += Decompress->RW.y2[i] * Decompress->RW.a2[i-1];
        Xpz = Xp+Xz;
        Decompress->RW.q2[0] = Decompress->RW.y2[0]+Xpz;

        R = Decompress->RW.q2[0];  /* saving the RESULT */

    } else {

        R = Decompress->RW.y0[0];
    }

    //
    //  Updating the filters
    //
    for (i=1; i<=6; i++) {

        Decompress->RW.b0[i-1] = 0.98*Decompress->RW.b0[i-1] + 0.006*XorSgn(Decompress->RW.q0[0], Decompress->RW.q0[i]);

        if ( Decompress->RW.PostFilter ) {

            Decompress->RW.b1[i-1] = fPow0_8[i-1]      * Decompress->RW.b0[i-1];
            Decompress->RW.b2[i-1] = fMinusPow0_5[i-1] * Decompress->RW.b0[i-1];
        }
    }

    for (i=1; i<=2; i++) {

        Decompress->RW.a0[i-1] = 0.98*Decompress->RW.a0[i-1] + 0.012*XorSgn(Decompress->RW.q0[0], Decompress->RW.y0[i]);

        if (Decompress->RW.PostFilter) {

            Decompress->RW.a1[i-1] = fPow0_8[i-1]      * Decompress->RW.a0[i-1];
            Decompress->RW.a2[i-1] = fMinusPow0_5[i-1] * Decompress->RW.a0[i-1];
        }
    }

    //
    // shifting vectors
    //
    for (i=6; i>=1; i--) {

        Decompress->RW.q0[i]=Decompress->RW.q0[i-1];

        if ( Decompress->RW.PostFilter ) {

            Decompress->RW.q1[i]=Decompress->RW.q1[i-1];
            Decompress->RW.q2[i]=Decompress->RW.q2[i-1];
        }
    }

    for (i=2; i>=1; i--) {

        Decompress->RW.y0[i]=Decompress->RW.y0[i-1];

        if ( Decompress->RW.PostFilter ) {

            Decompress->RW.y1[i]=Decompress->RW.y1[i-1];
            Decompress->RW.y2[i]=Decompress->RW.y2[i-1];
        }
    }

    //
    // returning decoded speech sample as double value
    //
    return R;
}







BYTE static
PCMto4bitADPCM(
    LPCOMPRESS_OBJECT   State,
    SHORT              InSample
    )

{

    BYTE     NewSample;

    double x  = Double(InSample);
    double Xp = PreEmphasis(State,x);

    NewSample=  encoder( State,Xp );


    return NewSample;

}

BYTE  static WINAPI
CompressPCM(
    LPCOMPRESS_OBJECT   State,
    SHORT               Sample1,
    SHORT               Sample2
    )

{
    BYTE   ReturnValue;

    ReturnValue =  PCMto4bitADPCM(State, AdjustGain(Sample1,State->Gain));

    ReturnValue |= PCMto4bitADPCM(State, AdjustGain(Sample2,State->Gain))<<4;


    return ReturnValue;


}




SHORT static
ADPCM4bittoPCM(
     LPDECOMPRESS_OBJECT  State,
     BYTE                Sample
     )

{


    double Y  = decoderImm(State,Sample);
    double Ye = DeEmphasis(State,Y);


    return (SHORT)SShort(Ye);

}



VOID  static WINAPI
DecompressADPCM(
    LPDECOMPRESS_OBJECT   State,
    BYTE               Sample,
    PSHORT                Destination
    )

{
    DWORD   ReturnValue;

    *Destination++ = AdjustGain(ADPCM4bittoPCM(State, (BYTE)(Sample & 0x0f)),State->Gain);

    *Destination++ = AdjustGain(ADPCM4bittoPCM(State, (BYTE)(Sample>>4)),State->Gain);

    return ;


}



DWORD  WINAPI
RockwellInInitNoGain(
    LPVOID  lpvObject,
    WORD   Gain
    )
{

    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;
    DWORD   i;

    if (Gain == 0) {

        Gain=0x0100;
    }

    State->Gain=Gain;



    State->RW.CDQData.oldCode = 8;
    State->RW.CDQData.Sigma1=SigmaMIN;
    State->RW.CDQData.out= 0.;

    State->RW.PostFilter=FALSE;

    State->RW.Y1 = 0.;

    //
    // Filter Z-buffers (zero initialized) for main decoder loop
    //
    for (i=0; i<2; i++) {

        State->RW.a0[i]=0.;
        State->RW.a1[i]=0.;
        State->RW.a2[i]=0.;

    }

    for (i=0; i<6; i++) {

        State->RW.b0[i]=0.;
        State->RW.b1[i]=0.;
        State->RW.b2[i]=0.;
    }

    for (i=0; i<3; i++) {

        State->RW.y0[i]=0.;
        State->RW.y1[i]=0.;
        State->RW.y2[i]=0.;
    }

    for (i=0; i<7; i++) {

        State->RW.q0[i]=0.;
        State->RW.q1[i]=0.;
        State->RW.q2[i]=0.;
    }


    return MMSYSERR_NOERROR;
}



DWORD  WINAPI
RockwellInInit(
    LPVOID  lpvObject,
    WORD   Gain
    )
{

    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;
    DWORD   i;

    if (Gain == 0) {

        Gain=0x0300;
    }

    State->Gain=Gain;



    State->RW.CDQData.oldCode = 8;
    State->RW.CDQData.Sigma1=SigmaMIN;
    State->RW.CDQData.out= 0.;

    State->RW.PostFilter=FALSE;

    State->RW.Y1 = 0.;

    //
    // Filter Z-buffers (zero initialized) for main decoder loop
    //
    for (i=0; i<2; i++) {

        State->RW.a0[i]=0.;
        State->RW.a1[i]=0.;
        State->RW.a2[i]=0.;

    }

    for (i=0; i<6; i++) {

        State->RW.b0[i]=0.;
        State->RW.b1[i]=0.;
        State->RW.b2[i]=0.;
    }

    for (i=0; i<3; i++) {

        State->RW.y0[i]=0.;
        State->RW.y1[i]=0.;
        State->RW.y2[i]=0.;
    }

    for (i=0; i<7; i++) {

        State->RW.q0[i]=0.;
        State->RW.q1[i]=0.;
        State->RW.q2[i]=0.;
    }


    return MMSYSERR_NOERROR;
}

VOID
WINAPI
In4Bit7200to8Bit8000GetBufferSizes(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
    )
{
    DWORD   Samples=dwBytes/2;

    *lpdwBufSizeA = 2*( ((Samples/10)*9) + ((Samples%10)*9/10) + 1 );
    *lpdwBufSizeB = (*lpdwBufSizeA ) / 4;
}

DWORD
WINAPI
In7200to8000RateConvert(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{
    return 2*SRConvertUp(
                 9,
                 10,
                 (short*)lpSrc,
                 dwSrcLen/2,
                 (short*)lpDest,
                 dwDestLen/2
                 );
}

DWORD WINAPI
RockwellInDecode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{

    PSHORT   EndPoint;

    DWORD    Samples=dwSrcLen * 2;

    PSHORT   Dest=(PSHORT)lpDest;

    EndPoint=Dest+Samples;

    while (Dest < EndPoint) {

        DecompressADPCM(
            lpvObject,
            *lpSrc++,
            Dest
            );

        Dest+=2;

    }

    return Samples*2;
}

DWORD  WINAPI
RockwellOutInit(
    LPVOID  lpvObject,
    WORD    Gain
    )
{


    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)lpvObject;

    DWORD i;

    if (Gain == 0) {

        Gain=0x0200;
    }

    State->Gain=Gain;


    State->RW.CQData.CodedQout = 8;
    State->RW.CQData.Sigma1=SigmaMIN;
    State->RW.CQData.out=0.;

    // Filter Z-buffers (zero initialized)

    State->RW.X1 = 0.;

    State->RW.a[0]=0.;
    State->RW.a[1]=0.;

    for (i=0; i<6; i++) {

        State->RW.b[i]=0.;
    }

    for (i=0; i<3; i++) {

        State->RW.y[i]=0.;
    }

    for (i=0; i<7; i++) {

        State->RW.q[i]=0.;
    }

    return MMSYSERR_NOERROR;
}

VOID
WINAPI
Out16bit8000to4bit7200GetBufferSizes(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
    )
{
    DWORD   SourceSamples=dwBytes/2;

    *lpdwBufSizeA =(((SourceSamples/10)*9)+((SourceSamples%10)*9/10))*2;

    *lpdwBufSizeB = *lpdwBufSizeA / 4;
}

DWORD
WINAPI
Out8000to7200RateConvert(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{

    return 2 * SRConvertDown(
        10,
        9,
        (short*)lpSrc,
        dwSrcLen/2,
        (short*)lpDest,
        dwDestLen/2
        );

}

DWORD WINAPI
RockwellOutEncode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{


    DWORD cbDest = dwSrcLen / 4;

    PSHORT  Source=(PSHORT)lpSrc;

    DWORD   Samples=dwSrcLen/2;

    LPBYTE  EndPoint=lpDest+Samples/2;

    SHORT   Sample1;
    SHORT   Sample2;

    while (lpDest < EndPoint) {

        Sample1=*Source++;
        Sample2=*Source++;

        *lpDest++=CompressPCM(
            lpvObject,
            Sample1,
            Sample2
            );

    }



    return Samples/2;
}

DWORD  WINAPI  RockwellGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 4) * 10) / 9;
}

DWORD  WINAPI GetRockwellInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = RockwellInInit;
    lpxiInput->lpfnGetPosition    = RockwellGetPosition;
    lpxiInput->lpfnGetBufferSizes = In4Bit7200to8Bit8000GetBufferSizes; //RockwellInGetBufferSizes;
    lpxiInput->lpfnTransformA     = In7200to8000RateConvert; //RockwellInRateConvert;
    lpxiInput->lpfnTransformB     = RockwellInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = RockwellOutInit;
    lpxiOutput->lpfnGetPosition    = RockwellGetPosition;
    lpxiOutput->lpfnGetBufferSizes = Out16bit8000to4bit7200GetBufferSizes; //RockwellOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Out8000to7200RateConvert; //RockwellOutRateConvert;
    lpxiOutput->lpfnTransformB     = RockwellOutEncode;

    return MMSYSERR_NOERROR;
}


DWORD  WINAPI GetRockwellInfoNoGain
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = RockwellInInitNoGain;
    lpxiInput->lpfnGetPosition    = RockwellGetPosition;
    lpxiInput->lpfnGetBufferSizes = In4Bit7200to8Bit8000GetBufferSizes; //RockwellInGetBufferSizes;
    lpxiInput->lpfnTransformA     = In7200to8000RateConvert; //RockwellInRateConvert;
    lpxiInput->lpfnTransformB     = RockwellInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = RockwellOutInit;
    lpxiOutput->lpfnGetPosition    = RockwellGetPosition;
    lpxiOutput->lpfnGetBufferSizes = Out16bit8000to4bit7200GetBufferSizes; //RockwellOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Out8000to7200RateConvert; //RockwellOutRateConvert;
    lpxiOutput->lpfnTransformB     = RockwellOutEncode;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\sierra.c ===
//---------------------------------------------------------------------------
//
//  Module:   wavein.c
//
//  Description:
//     Wave interface for MSSB16.DRV.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include "xfrmpriv.h"

//#include "cirrus.h"




DWORD WINAPI  SierraInInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{

    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0300; // no gain
    }

    State->Gain=Gain;

    return MMSYSERR_NOERROR;
}


DWORD WINAPI  SierraOutInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0200; // no gain
    }

    State->Gain=Gain;


    return MMSYSERR_NOERROR;
}





//
//
//  7200
//
//

VOID WINAPI  Sierra72InGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{

    DWORD   DestLength;
    DWORD   DestSamples;

    DestSamples=dwBytes/2;


    *lpdwBufSizeA = 2*( ((DestSamples/10)*9) + ((DestSamples%10)*9/10) + 1 );


    *lpdwBufSizeB = *lpdwBufSizeA/2;

}




VOID WINAPI  Sierra72OutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    DWORD   SourceLength=dwBytes/2;

    *lpdwBufSizeA =(((SourceLength/10)*9)+((SourceLength%10)*9/10))*2;
    *lpdwBufSizeB = *lpdwBufSizeA / 2;
}


DWORD WINAPI  Sierra72GetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 2) * 10) / 9;
}




DWORD WINAPI
RateConvert7200to8000(
    LPVOID    Object,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    return 2*SRConvertUp(
                 9,
                 10,
                 (short*)Source,
                 SourceLength/2,
                 (short*)Destination,
                 DestinationLength/2
                 );


}



DWORD WINAPI
RateConvert8000to7200(
    LPVOID    Object,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    return 2 * SRConvertDown(
        10,
        9,
        (short*)Source,
        SourceLength/2,
        (short*)Destination,
        DestinationLength/2
        );


}



DWORD WINAPI GetUnsignedPCMInfo7200
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = SierraInInit;
    lpxiInput->lpfnGetPosition    = Sierra72GetPosition;
    lpxiInput->lpfnGetBufferSizes = Sierra72InGetBufferSizes;
    lpxiInput->lpfnTransformA     = RateConvert7200to8000;
    lpxiInput->lpfnTransformB     = Convert8PCMto16PCM;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = SierraOutInit;
    lpxiOutput->lpfnGetPosition    = Sierra72GetPosition;
    lpxiOutput->lpfnGetBufferSizes = Sierra72OutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = RateConvert8000to7200;
    lpxiOutput->lpfnTransformB     = Convert16PCMto8PCM;

    return MMSYSERR_NOERROR;
}





DWORD WINAPI  PcmInInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }

    State->Gain=Gain;

    return MMSYSERR_NOERROR;
}

VOID WINAPI  PcmInGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = ((dwBytes/2));
    *lpdwBufSizeB = 0;
}


DWORD WINAPI  PcmOutInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)lpvObject;

    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }

    State->Gain=Gain;


    return MMSYSERR_NOERROR;
}

VOID WINAPI  PcmOutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = ((dwBytes/2));
    *lpdwBufSizeB = 0;
}


DWORD WINAPI  PcmGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return (dwBytes * 2);
}




DWORD WINAPI GetUnsignedPCM8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = PcmInInit;
    lpxiInput->lpfnGetPosition    = PcmGetPosition;
    lpxiInput->lpfnGetBufferSizes = PcmInGetBufferSizes;
    lpxiInput->lpfnTransformA     = Convert8PCMto16PCM;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = PcmOutInit;
    lpxiOutput->lpfnGetPosition    = PcmGetPosition;
    lpxiOutput->lpfnGetBufferSizes = PcmOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Convert16PCMto8PCM;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}






DWORD WINAPI GetaLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = PcmInInit;
    lpxiInput->lpfnGetPosition    = PcmGetPosition;
    lpxiInput->lpfnGetBufferSizes = PcmInGetBufferSizes;
    lpxiInput->lpfnTransformA     = ConvertaLawto16PCM;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = PcmOutInit;
    lpxiOutput->lpfnGetPosition    = PcmGetPosition;
    lpxiOutput->lpfnGetBufferSizes = PcmOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Convert16PCMtoaLaw;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}


DWORD WINAPI GetuLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = PcmInInit;
    lpxiInput->lpfnGetPosition    = PcmGetPosition;
    lpxiInput->lpfnGetBufferSizes = PcmInGetBufferSizes;
    lpxiInput->lpfnTransformA     = ConvertuLawto16PCM;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = PcmOutInit;
    lpxiOutput->lpfnGetPosition    = PcmGetPosition;
    lpxiOutput->lpfnGetBufferSizes = PcmOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Convert16PCMtouLaw;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\xfrmpriv.h ===
//---------------------------------------------------------------------------
//
//  Module:   xfrmpriv.h
//
//  Description:
//     Header file for global driver declarations
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//             8/31/95    MMacLin     Salvaged from driver.h
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1991 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include <windows.h>

#include <mmsystem.h>
#include <mmddk.h>


#include <string.h>

#define Not_VxD

#include "debug.h"
#include "umdmxfrm.h"
#include "rwadpcm.h"


//
// BCODE is a macro to define a R/O variable in the code segment
//



// some definitions to convert between samples and bytes
#define PCM_16BIT_BYTESTOSAMPLES(dwBytes) ((dwBytes)/2)
#define PCM_16BIT_SAMPLESTOBYTES(dwSamples) ((dwSamples)*2)

typedef unsigned int FAR *ULPINT;
typedef unsigned int NEAR *UNPINT;


//
// internal strings (in init.c):
//
//

#ifdef DEBUG
    extern char STR_PROLOGUE[];
    extern char STR_CRLF[];
    extern char STR_SPACE[];
#endif


// init.c:
#include "cirrus.h"


extern HMODULE      ghModule ;           // our module handle

LRESULT FAR PASCAL DrvInit
(
    VOID
);

// drvproc.c

extern DWORD FAR PASCAL  DriverProc
(
    DWORD dwDriverID,
    HANDLE hDriver,
    WORD wMessage,
    DWORD dwParam1,
    DWORD dwParam2
);


int FAR PASCAL LibMain
(
    HMODULE         hModule,
    UINT            uDataSeg,
    UINT            uHeapSize,
    LPSTR           lpCmdLine
) ;


extern DWORD FAR PASCAL  GetXformInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetRockwellInfo(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );


DWORD FAR PASCAL GetCirrusInfo(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );


DWORD FAR PASCAL GetThinkpad7200Info(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );


DWORD FAR PASCAL GetThinkpad8000Info(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );

DWORD FAR PASCAL GetSierraInfo(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
    );

DWORD FAR PASCAL GetSierraInfo7200
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetUnsignedPCMInfo7200
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetUnsignedPCM8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


DWORD FAR PASCAL GetRockwellInfoNoGain
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);

DWORD FAR PASCAL GetuLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);

DWORD FAR PASCAL GetaLaw8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
);


#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

VOID WINAPI
SRConvert8000to7200(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );


DWORD WINAPI
SRConvert7200to8000(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );


DWORD WINAPI
SRConvertDown(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );

DWORD WINAPI
SRConvertUp(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    );


DWORD WINAPI
CirrusOutEncode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    );

DWORD WINAPI
CirrusInDecode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    );




//---------------------------------------------------------------------------
//  End of File: xfrmpriv.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\umdmxfrm.c ===
//---------------------------------------------------------------------------
//
//  Module:   umdmxfrm.c
//
//  Description:
//     Header file for global driver declarations
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//             8/28/95    MMaclin     Created for UNIMODEM/V
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1991 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include "xfrmpriv.h"

#define NULL_ID         0
#define RWADPCM_ID      1
#define CIRRUS_ID       2
#define THINKPAD7200_ID 3
#define THINKPAD8000_ID 4
#define SIERRA4800_ID   5
#define SIERRA7200_ID   6
#define UNSIGNEDPCM7200 7
#define UNSIGNEDPCM8000 8
#define RWADPCM_NOGAIN_ID 9
#define MULAW8000_ID	10
#define ALAW8000_ID		11


static DWORD FAR PASCAL  NullInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    return MMSYSERR_NOERROR;
}

static DWORD FAR PASCAL  NullGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return dwBytes;
}

static VOID FAR PASCAL  NullGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD dwSamples,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = 0;
    *lpdwBufSizeB = 0;
}

static DWORD FAR PASCAL GetNullInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = 0;
    lpxiInput->lpfnInit           = NullInit;
    lpxiInput->lpfnGetPosition    = NullGetPosition;
    lpxiInput->lpfnGetBufferSizes = NullGetBufferSizes;
    lpxiInput->lpfnTransformA     = NULL;
    lpxiInput->lpfnTransformB     = NULL;

    lpxiOutput->wObjectSize = 0;
    lpxiOutput->lpfnInit           = NullInit;
    lpxiOutput->lpfnGetPosition    = NullGetPosition;
    lpxiOutput->lpfnGetBufferSizes = NullGetBufferSizes;
    lpxiOutput->lpfnTransformA     = NULL;
    lpxiOutput->lpfnTransformB     = NULL;

    return MMSYSERR_NOERROR;
}

DWORD FAR PASCAL  GetXformInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    switch (dwID)
    {
        case NULL_ID:
            return GetNullInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case RWADPCM_ID:
            return GetRockwellInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case CIRRUS_ID:
            return GetCirrusInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case THINKPAD7200_ID:
            return GetThinkpad7200Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case THINKPAD8000_ID:
            return GetThinkpad8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );
#if 0
        case SIERRA4800_ID:
            return GetSierraInfo(
                dwID,
                lpxiInput,
                lpxiOutput
                );


        case SIERRA7200_ID:
            return GetSierraInfo7200(
                dwID,
                lpxiInput,
                lpxiOutput
                );
#endif
        case UNSIGNEDPCM7200:
            return GetUnsignedPCMInfo7200(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case UNSIGNEDPCM8000:
            return GetUnsignedPCM8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );
        case RWADPCM_NOGAIN_ID:
            return GetRockwellInfoNoGain(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case MULAW8000_ID:
            return GetuLaw8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );

        case ALAW8000_ID:
            return GetaLaw8000Info(
                dwID,
                lpxiInput,
                lpxiOutput
                );


        default:
            return WAVERR_BADFORMAT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    openclos.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

extern DWORD  DebugFlags;

#define  DEBUG_FLAG_ERROR   (1 << 0)
#define  DEBUG_FLAG_INIT    (1 << 1)
#define  DEBUG_FLAG_TRACE   (1 << 2)

#ifdef ASSERT
#undef ASSERT
#endif // ASSERT



#if DBG

#define  D_ERROR(_z)   {if (DebugFlags & DEBUG_FLAG_ERROR) {_z}}

#define  D_INIT(_z)   {if (DebugFlags & DEBUG_FLAG_INIT) {_z}}

#define  D_TRACE(_z)  {if (DebugFlags & DEBUG_FLAG_TRACE) {_z}}

#define  D_ALWAYS(_z)  {{_z}}

#define  ASSERT(_x) { if(!(_x)){DbgPrint("UNIMDMAT: (%s) File: %s, Line: %d \n\r",#_x,__FILE__,__LINE__);DbgBreakPoint();}}

#else

#define  D_ERROR(_z)   {}

#define  D_INIT(_z)   {}

#define  D_TRACE(_z)  {}

#define  D_ALWAYS(_z)  {{_z}}

#define  ASSERT(_x) {}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\devchang.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:



Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#include <tspnotif.h>
#include <slot.h>


#include <dbt.h>

typedef struct _REMOVE_BLOCK {

    LIST_ENTRY        ListEntry;
    HANDLE            NotificationHandle;
    HANDLE            HandleToWatch;
    REMOVE_CALLBACK  *CallBack;
    PVOID             CallBackContext;

} REMOVE_BLOCK, *PREMOVE_BLOCK;



DWORD
CMP_WaitNoPendingInstallEvents (
    IN DWORD dwTimeout);


LRESULT FAR PASCAL WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)

  {
    HDC       hdc;
    RECT         rect;
    PAINTSTRUCT  ps;

    switch (message)
      {

        case WM_CREATE: {

            DEV_BROADCAST_DEVICEINTERFACE  DevClass;
            HDEVNOTIFY  NotificationHandle;


            D_INIT(DbgPrint("WM_CREATE\n");)

            CopyMemory(&DevClass.dbcc_classguid,&GUID_CLASS_MODEM,sizeof(DevClass.dbcc_classguid));

            DevClass.dbcc_name[0]=L'\0';

            DevClass.dbcc_size=sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            DevClass.dbcc_devicetype=DBT_DEVTYP_DEVICEINTERFACE;

            NotificationHandle=RegisterDeviceNotification(hwnd,&DevClass,DEVICE_NOTIFY_WINDOW_HANDLE);

            if (NotificationHandle == NULL) {

                D_TRACE(DbgPrint("Could not register device notification %d\n",GetLastError());)

            }

            SetWindowLongPtr(hwnd,GWLP_USERDATA,(LONG_PTR)NotificationHandle);

            return 0;
        }

        case WM_DEVICECHANGE: {

            PDEV_BROADCAST_HDR  BroadcastHeader=(PDEV_BROADCAST_HDR)lParam;
            DWORD               DeviceType;


            D_INIT(DbgPrint("DeviceChange\n");)

            if (BroadcastHeader == NULL) {

                return TRUE;
            }

            __try {

                DeviceType=BroadcastHeader->dbch_devicetype;

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                D_ERROR(DbgPrint("DeviceChange: fault accessing device type\n");)

                return TRUE;
            }


            switch ((UINT)wParam)
            {
                case DBT_CONFIGCHANGED:
                case DBT_CONFIGCHANGECANCELED:
                case DBT_QUERYCHANGECONFIG:
                case DBT_USERDEFINED:
                case DBT_DEVNODES_CHANGED:
                    // Do nothing; for these message, lParam is either NULL
                    // or not PDEV_BROADCAST_HDR
                    break;

                default:




                    if (DeviceType == DBT_DEVTYP_DEVICEINTERFACE) {

                        PDEV_BROADCAST_DEVICEINTERFACE lpdb = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

                        switch (wParam) {

                            case DBT_DEVICEARRIVAL:

                                D_TRACE(DbgPrint("DeviceChange-Arrival\n");)

                                __try {

                                    if (IsEqualGUID(&GUID_CLASS_MODEM,&lpdb->dbcc_classguid)) {
                                        //
                                        // At this point, the modem's installation might not
                                        // be finished yet (the modem class installer has already
                                        // called SetupDiInstallDevice, but the class installer still
                                        // has some things to do after this), so we better wait here for
                                        // the installation to finish.
                                        //
                                        CMP_WaitNoPendingInstallEvents (INFINITE);

                                        D_TRACE(DbgPrint("DeviceChange-Arrival interface change %ws\n",lpdb->dbcc_name);)

                                        UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
                                                           fTSPNOTIF_FLAG_CPL_REENUM,
                                                           0, NULL, TRUE);
                                    }

                                } __except (EXCEPTION_EXECUTE_HANDLER) {

                                    break;
                                }


                                break;

                            case DBT_DEVICEREMOVECOMPLETE:

                                __try {

                                    if (IsEqualGUID(&GUID_CLASS_MODEM,&lpdb->dbcc_classguid)) {

                                        D_TRACE(DbgPrint("DeviceChange-remove interface change %ws\n",lpdb->dbcc_name);)

                                        UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
                                                           fTSPNOTIF_FLAG_CPL_REENUM,
                                                           0, NULL, TRUE);
                                    }

                                } __except (EXCEPTION_EXECUTE_HANDLER) {

                                    break;
                                }


                                break;

                            default:

                                break;
                        }

                    } else {

                        if (DeviceType == DBT_DEVTYP_HANDLE) {

                            PDEV_BROADCAST_HANDLE    BroadcastHandle=(PDEV_BROADCAST_HANDLE) lParam;
                            REMOVE_CALLBACK  *CallBack=NULL;
                            PVOID             CallBackContext;
                            HANDLE            DeviceHandle;

                            __try {

                                DeviceHandle=BroadcastHandle->dbch_handle;

                            } __except (EXCEPTION_EXECUTE_HANDLER) {

                                D_ERROR(DbgPrint("DeviceChange-Handle-fault access handle\n");)

                                return TRUE;
                            }



                            switch (wParam) {

                                case DBT_DEVICEARRIVAL:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-Arrival\n");)

                                    break;

                                case DBT_DEVICEQUERYREMOVE:
                                case DBT_DEVICEREMOVECOMPLETE:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-query remove\n");)

                                    EnterCriticalSection(
                                        &DriverControl.Lock
                                        );

                                    {
                                        PLIST_ENTRY  Link=DriverControl.MonitorListHead.Flink;

                                        while (Link != &DriverControl.MonitorListHead) {

                                            PREMOVE_BLOCK   RemoveBlock=CONTAINING_RECORD(Link,REMOVE_BLOCK,ListEntry);

                                            if (RemoveBlock->HandleToWatch == DeviceHandle) {
                                                //
                                                //  found the handle it is for
                                                //
                                                D_TRACE(DbgPrint("DeviceChange-Handle-query remove- found block for handle\n");)

                                                CallBack=RemoveBlock->CallBack;
                                                CallBackContext=RemoveBlock->CallBackContext;

                                                break;
                                            }

                                            Link=Link->Flink;
                                        }
                                    }

                                    LeaveCriticalSection(
                                        &DriverControl.Lock
                                        );

                                    if (CallBack != NULL) {

                                        (*CallBack)(CallBackContext);
                                        Sleep(2000);
                                    }


                                    break;

                                case DBT_DEVICEQUERYREMOVEFAILED:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-query remove failed\n");)

                                    break;

                                case DBT_DEVICEREMOVEPENDING:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-remove pending\n");)

                                    break;


/*                                case DBT_DEVICEREMOVECOMPLETE:

                                    D_TRACE(DbgPrint("DeviceChange-Handle-remove complete\n");)

                                    break;
                                    */

                                default:

                                    break;

                            }
                        }
                    }
            }
            return TRUE;
        }

    case WM_POWERBROADCAST: {

        switch(wParam) {

            case PBT_APMSUSPEND:

                D_TRACE(DbgPrint("Power: SUSPEND, calls=%d\n",DriverControl.ActiveCalls);)

                if (DriverControl.ActiveCallsEvent != NULL) {

                    WaitForSingleObject(DriverControl.ActiveCallsEvent,15*1000);
                }

                D_TRACE(DbgPrint("Power: SUSPEND: after wait, calls=%d\n",DriverControl.ActiveCalls);)

                break;

            default:

                break;
        }

        return TRUE;
    }

	case WM_PAINT:

        hdc=BeginPaint(hwnd,&ps);
        GetClientRect (hwnd,&rect);

	    EndPaint(hwnd,&ps);
        return 0;

    case WM_CLOSE: {

        HDEVNOTIFY  NotificationHandle;

        D_INIT(DbgPrint("WM_CLOSE\n");)

        NotificationHandle=(HDEVNOTIFY)GetWindowLongPtr(hwnd,GWLP_USERDATA);

        if (NotificationHandle != NULL) {

            UnregisterDeviceNotification(NotificationHandle);
        }


        DestroyWindow(hwnd);
        return 0;
    }


	case WM_DESTROY:


        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProc(hwnd,message, wParam, lParam);
  }


TCHAR   szAppName[]=TEXT("ModemDeviceChange");
TCHAR   szClassName[]=TEXT("MdmDevChg");


LONG_PTR WINAPI
DllWinMain(
    HWND      ParentWindow,
    HINSTANCE hInstance,
    LPSTR     lpszCmdParam,
    int       nCmdShow
    )

{

    HWND      hwnd;
    MSG       msg;
    WNDCLASS  wndclass;
    HANDLE    MutexHandle;

    D_INIT(DbgPrint("DllWinMain\n");)

    wndclass.style        =  CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc  =  WndProc;
    wndclass.cbClsExtra   =  0;
    wndclass.cbWndExtra   =  0;
    wndclass.hInstance    =  hInstance;
    wndclass.hIcon        =  LoadIcon (NULL, IDI_APPLICATION);
    wndclass.hCursor      =  LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground=  GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName =  NULL;
    wndclass.lpszClassName=  szClassName;

    RegisterClass(&wndclass);



    hwnd = CreateWindow (szClassName,
                         szAppName,
                         WS_OVERLAPPEDWINDOW,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         NULL,
                         NULL,
                         hInstance,
                         NULL);

    DriverControl.MonitorWindowHandle=hwnd;

    SetEvent(DriverControl.ThreadStartEvent);

    if (hwnd != NULL) {

        while(TRUE)
        {
            DWORD dwResult;
            MSG mMessage;

            while(PeekMessage(&msg,NULL,0,0,PM_REMOVE))
            {
               TranslateMessage(&msg);
               DispatchMessage(&msg);
            }

            dwResult = MsgWaitForMultipleObjects(1, 
                    &DriverControl.ThreadFinishEvent, 
                    FALSE, INFINITE, QS_ALLINPUT);

            // The event was signalled therefore we quit
            
            if (dwResult == 0)
            {
                
                D_INIT(DbgPrint("DllWinMain: resetting event\n");)

                ResetEvent(DriverControl.ThreadFinishEvent);

                return 1;
            }
        }
    	
    }

    return 0;
}



VOID
MonitorWorkerThread(
    PVOID            Context
    )

{


    D_INIT(DbgPrint("UmMonitorThread:  starting\n");)

    DllWinMain(
        NULL,
        DriverControl.ModuleHandle,
        NULL,
        0
        );



    D_INIT(DbgPrint("UmMonitorThread:  Exitting\n");)

    ExitThread(0);

}


BOOL
StartMonitorThread(
    VOID
    )

{

    BOOL    bResult=TRUE;
    DWORD   ThreadId;

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.MonitorReferenceCount++;

    if (DriverControl.MonitorReferenceCount == 1) {
        //
        //  first one
        //
        DriverControl.ThreadStartEvent=CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (DriverControl.ThreadStartEvent != NULL) {
            //
            //  got start event
            //
            DriverControl.MonitorThreadHandle=CreateThread(
                NULL,                                  // attributes
                0,                                     // stack size
                (LPTHREAD_START_ROUTINE)MonitorWorkerThread,
                NULL,
                0,                                     // createion flag
                &ThreadId
                );

            if (DriverControl.MonitorThreadHandle != NULL) {
                //
                //  wait for the thread to start
                //
                WaitForSingleObject(
                    DriverControl.ThreadStartEvent,
                    INFINITE
                    );

            } else {
                //
                //  could not create thread
                //
                bResult=FALSE;

                DriverControl.MonitorReferenceCount--;

            }

            CloseHandle(DriverControl.ThreadStartEvent);

        } else {
            //
            //  could not create event
            //
            bResult=FALSE;

            DriverControl.MonitorReferenceCount--;

        }
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return bResult;

}

VOID
StopMonitorThread(
    VOID
    )

{


    EnterCriticalSection(
        &DriverControl.Lock
        );

    D_INIT(DbgPrint("StopMonitorThread count %d thread handle %d\n",DriverControl.MonitorReferenceCount,DriverControl.MonitorThreadHandle);)

    DriverControl.MonitorReferenceCount--;

    if (DriverControl.MonitorReferenceCount == 0) {

        if (DriverControl.MonitorThreadHandle != NULL) {

            BOOL    bResult;

            HDEVNOTIFY NotificationHandle;

            /*
            do {

                bResult=PostMessage(
                    DriverControl.MonitorWindowHandle,
                    WM_CLOSE,
                    0,
                    0
                    );

                if (!bResult) {
                    //
                    //  post message failed, Great. Probably out of memory
                    //  Sleep for a while and try again
                    //
                    Sleep(100);
                    }


            } while (!bResult);
            */


            NotificationHandle = (HDEVNOTIFY)
                GetWindowLongPtr(DriverControl.MonitorWindowHandle,
                        GWLP_USERDATA);

            if (NotificationHandle != NULL)
            {
                UnregisterDeviceNotification(NotificationHandle);
            }


            DestroyWindow(DriverControl.MonitorWindowHandle);

            SetEvent(DriverControl.ThreadFinishEvent);

            WaitForSingleObject(
                DriverControl.MonitorThreadHandle,
                INFINITE
                );

            CloseHandle(
                DriverControl.MonitorThreadHandle
                );

            ResetEvent(DriverControl.ThreadFinishEvent);

            DriverControl.MonitorWindowHandle=NULL;
            DriverControl.MonitorThreadHandle=NULL;

        }
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return;

}



PVOID
MonitorHandle(
    HANDLE    FileHandle,
    REMOVE_CALLBACK  *CallBack,
    PVOID     Context
    )

{
    BOOL                  bResult;
    DEV_BROADCAST_HANDLE  DevBroadcastHandle;
    HDEVNOTIFY            NotificationHandle;
    PREMOVE_BLOCK         RemoveBlock;

    RemoveBlock=ALLOCATE_MEMORY(sizeof(REMOVE_BLOCK));

    if (RemoveBlock == NULL) {

        return NULL;
    }

    RemoveBlock->HandleToWatch=FileHandle;
    RemoveBlock->CallBack=CallBack;
    RemoveBlock->CallBackContext=Context;

    bResult=StartMonitorThread();

    if (!bResult) {

        FREE_MEMORY(RemoveBlock);

        return NULL;
    }




    DevBroadcastHandle.dbch_size=sizeof(DEV_BROADCAST_HANDLE);
    DevBroadcastHandle.dbch_devicetype=DBT_DEVTYP_HANDLE;
    DevBroadcastHandle.dbch_handle=FileHandle;


    EnterCriticalSection(
        &DriverControl.Lock
        );



    RemoveBlock->NotificationHandle=RegisterDeviceNotification(
        DriverControl.MonitorWindowHandle,
        &DevBroadcastHandle,
        DEVICE_NOTIFY_WINDOW_HANDLE
        );

    if (RemoveBlock->NotificationHandle == NULL) {

        D_TRACE(DbgPrint("Could not register device notification %d\n",GetLastError());)

    } else {

        InsertHeadList(
            &DriverControl.MonitorListHead,
            &RemoveBlock->ListEntry
            );


    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    if (RemoveBlock->NotificationHandle == NULL) {
        //
        //  Failed
        //
        StopMonitorThread();

        FREE_MEMORY(RemoveBlock);

        return NULL;
    }

    return RemoveBlock;
}

VOID
StopMonitoringHandle(
    PVOID    Context
    )

{

    PREMOVE_BLOCK    RemoveBlock=(PREMOVE_BLOCK)Context;

    EnterCriticalSection(
        &DriverControl.Lock
        );

    RemoveEntryList(&RemoveBlock->ListEntry);

    LeaveCriticalSection(
        &DriverControl.Lock
        );

    UnregisterDeviceNotification(RemoveBlock->NotificationHandle);

    FREE_MEMORY(RemoveBlock);

    StopMonitorThread();

    return;
}


VOID
CallBeginning(
    VOID
    )

{

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.ActiveCalls++;

    D_TRACE(DbgPrint("CallBeginning: calls=%d",DriverControl.ActiveCalls);)

    if (DriverControl.ActiveCallsEvent != NULL) {

        ResetEvent(DriverControl.ActiveCallsEvent);
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );



    return;
}

VOID
CallEnding(
    VOID
    )

{

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.ActiveCalls--;

    D_TRACE(DbgPrint("CallEnding: calls=%d",DriverControl.ActiveCalls);)

    if (DriverControl.ActiveCalls == 0) {

        if (DriverControl.ActiveCallsEvent != NULL) {

            SetEvent(DriverControl.ActiveCallsEvent);
        }
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );



    return;
}



VOID
ResetCallCount(
    VOID
    )

{

    EnterCriticalSection(
        &DriverControl.Lock
        );


    DriverControl.ActiveCalls=0;

    if (DriverControl.ActiveCallsEvent != NULL) {

        SetEvent(DriverControl.ActiveCallsEvent);
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\internal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <windowsx.h>
#include <regstr.h>
#include <tapi.h>
#include <tspi.h>

#include <umdmmini.h>

#include <mcx.h>

#include <devioctl.h>

#include <initguid.h>
#include <guiddef.h>

#include <ntddmodm.h>
#include <ntddser.h>

#include "debug.h"

#include <uniplat.h>

#include <debugmem.h>



#define  DRIVER_CONTROL_SIG  (0x43444d55)  //UMDC

typedef struct _DRIVER_CONTROL {

    DWORD                  Signature;

    CRITICAL_SECTION       Lock;

    DWORD                  ReferenceCount;

    HANDLE                 ThreadHandle;

    HANDLE                 ThreadStopEvent;

    HANDLE                 ModuleHandle;

    //
    //  monitor thread values
    //
    HANDLE                 MonitorThreadHandle;
    HWND                   MonitorWindowHandle;
    HANDLE                 ThreadStartEvent;
    ULONG                  MonitorReferenceCount;
    LIST_ENTRY             MonitorListHead;
    HANDLE                 ThreadFinishEvent;


    //
    //                     Call monitoring for power management
    //
    DWORD                  ActiveCalls;
    HANDLE                 ActiveCallsEvent;


} DRIVER_CONTROL, *PDRIVER_CONTROL;




LONG WINAPI
StartModemDriver(
    PDRIVER_CONTROL  DriverControl
    );

LONG WINAPI
StopModemDriver(
    PDRIVER_CONTROL  DriverControl
    );




extern DRIVER_CONTROL   DriverControl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\func.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    func.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"



VOID
WINAPI
UnimodemBasepIoCompletion(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )

/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/

{

    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    DWORD dwErrorCode;
    DWORD dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;

    dwErrorCode = 0;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
        }
    else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (DWORD)IoStatusBlock->Information;
        }

    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE)ApcContext;
    lpOverlapped = (LPOVERLAPPED)CONTAINING_RECORD(IoStatusBlock,OVERLAPPED,Internal);

    (CompletionRoutine)(dwErrorCode,dwNumberOfBytesTransfered,lpOverlapped);

    Reserved;
}




BOOL WINAPI
UnimodemDeviceIoControlEx(
    HANDLE       hFile,             // handle to device of interest
    DWORD        dwIoControlCode,     // control code of operation to perform
    LPVOID       lpInBuffer,          // pointer to buffer to supply input data
    DWORD        nInBufferSize,       // size of input buffer
    LPVOID       lpOutBuffer,         // pointer to buffer to receive output data
    DWORD        nOutBufferSize,      // size of output buffer
    LPOVERLAPPED lpOverlapped,        // pointer to overlapped structure for asynchronous operation
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    NTSTATUS Status;

    if (ARGUMENT_PRESENT(lpOverlapped)) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtDeviceIoControlFile(
                     hFile,
                     NULL,
                     UnimodemBasepIoCompletion,
                     (PVOID)lpCompletionRoutine,
                     (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                     dwIoControlCode,
                     lpInBuffer,
                     nInBufferSize,
                     lpOutBuffer,
                     nOutBufferSize
                     );

        if ( NT_ERROR(Status) ) {
//            BaseSetLastNTError(Status);
            return FALSE;

        } else {

            return TRUE;
        }



    } else {

        return FALSE;
    }

}


BOOL
UnimodemReadFileEx(
    HANDLE    FileHandle,
    PVOID     Buffer,
    DWORD     BytesToRead,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    return ReadFileEx(
               FileHandle,
               Buffer,
               BytesToRead,
               Overlapped,
               lpCompletionRoutine
               );

}


BOOL WINAPI
UnimodemWriteFileEx(
    HANDLE    FileHandle,
    PVOID     Buffer,
    DWORD     BytesToWrite,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    return WriteFileEx(
               FileHandle,
               Buffer,
               BytesToWrite,
               Overlapped,
               lpCompletionRoutine
               );

}



BOOL WINAPI
UnimodemWaitCommEventEx(
    HANDLE     FileHandle,
    LPDWORD    lpEventMask,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

{

    return UnimodemDeviceIoControlEx(
        FileHandle,
        IOCTL_SERIAL_WAIT_ON_MASK,
        NULL,
        0,
        lpEventMask,
        sizeof(DWORD),
        Overlapped,
        lpCompletionRoutine
        );

}


VOID
AsyncProcessingHandler(
    ULONG_PTR              dwParam
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    LPOVERLAPPED_COMPLETION_ROUTINE  Handler;



    Handler=(LPOVERLAPPED_COMPLETION_ROUTINE)UmOverlapped->PrivateCompleteionHandler;

    UmOverlapped->PrivateCompleteionHandler=NULL;

    (*Handler)(
        0,
        0,
        &UmOverlapped->Overlapped
        );

    return;

}

BOOL WINAPI
UnimodemQueueUserAPC(
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )


{

    BOOL               bResult;

    PUM_OVER_STRUCT UmOverlapped=(PUM_OVER_STRUCT)Overlapped;


    UmOverlapped->PrivateCompleteionHandler=lpCompletionRoutine;


    bResult=QueueUserAPC(
        AsyncProcessingHandler,
        UmOverlapped->OverlappedPool,
        (ULONG_PTR)UmOverlapped
        );


    return bResult;

}





HANDLE WINAPI
CreateOverStructPool(
    HANDLE      PlatformHandle,
    DWORD       PoolSize
    )

{

    return DriverControl.ThreadHandle;

}


VOID WINAPI
DestroyOverStructPool(
    HANDLE      PoolHandle
    )

{

    return;

}



PUM_OVER_STRUCT WINAPI
AllocateOverStructEx(
    HANDLE      PoolHandle,
    DWORD       dwExtraBytes
    )

{
    PUM_OVER_STRUCT UmOverlapped;

    UmOverlapped=ALLOCATE_MEMORY(sizeof(UM_OVER_STRUCT)+dwExtraBytes);

    if (UmOverlapped != NULL) {

        UmOverlapped->OverlappedPool=PoolHandle;
    }

    return UmOverlapped;

}


VOID WINAPI
FreeOverStruct(
    PUM_OVER_STRUCT UmOverlapped
    )

{
#if DBG
    FillMemory(UmOverlapped,sizeof(UM_OVER_STRUCT),0x99);
#endif
    FREE_MEMORY(UmOverlapped);

    return;

}


VOID WINAPI
ReinitOverStruct(
    PUM_OVER_STRUCT UmOverlapped
    )

{

    HANDLE    PoolHandle=UmOverlapped->OverlappedPool;

    ZeroMemory(
        UmOverlapped,
        sizeof(UM_OVER_STRUCT)
        );

    UmOverlapped->OverlappedPool=PoolHandle;

    return;

}






LONG WINAPI
SyncDeviceIoControl(
    HANDLE    FileHandle,
    DWORD     IoctlCode,
    LPVOID    InputBuffer,
    DWORD     InputBufferLength,
    LPVOID    OutputBuffer,
    DWORD     OutputBufferLength,
    LPDWORD   BytesTransfered
    )


/*++

Routine Description:


Arguments:


Return Value:



--*/

{
    BOOL        bResult;
    LONG        lResult=ERROR_SUCCESS;
    OVERLAPPED  Overlapped;

    Overlapped.hEvent=CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL
        );

    if (Overlapped.hEvent == NULL) {

        return GetLastError();
    }

    bResult=DeviceIoControl(
        FileHandle,
        IoctlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength,
        NULL,
        &Overlapped
        );


    if (!bResult && GetLastError() != ERROR_IO_PENDING) {

        CloseHandle(Overlapped.hEvent);

        return GetLastError();
    }

    bResult=GetOverlappedResult(
        FileHandle,
        &Overlapped,
        BytesTransfered,
        TRUE
        );

    if (!bResult) {

        lResult=GetLastError();
    }

    CloseHandle(Overlapped.hEvent);

    return lResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


    The miniport driver is guarenteed that only one action command will
    be austanding at one time. If an action command is called, no more
    commands will be issued until the miniport indicates that it has
    complete processing of the current command.

    UmAbortCurrentCommand() may be called while a command is currently executing
    to infor the miniport that the TSP would like it to complete the current command
    so that it may issue some other command. The miniport may complete the as soon
    as is apropreate.

    The Overlapped callback and Timer callbacks are not synchronized by the TSP
    and may be called at anytime. It is the responsibily of the mini dirver to
    protect its data structures from re-entrancy issues.


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#include <tspnotif.h>
#include <slot.h>


#include <dbt.h>

#include <objbase.h>


DWORD  DebugFlags=0;//DEBUG_FLAG_INIT | DEBUG_FLAG_TRACE;




DRIVER_CONTROL   DriverControl;


BOOL APIENTRY
DllMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch(dwReason) {

        case DLL_PROCESS_ATTACH:

            __try {

                InitializeCriticalSection(
                    &DriverControl.Lock
                    );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                return FALSE;
            }


            DriverControl.ActiveCalls=0;
            DriverControl.ActiveCallsEvent=CreateEvent(
                NULL,
                TRUE,
                TRUE,
                NULL
                );

            DriverControl.ThreadFinishEvent=CreateEvent(
                    NULL,
                    TRUE,
                    FALSE,
                    NULL);

            ResetEvent(DriverControl.ThreadFinishEvent);

#if DBG
            {
                CONST static TCHAR  UnimodemRegPath[]=REGSTR_PATH_SETUP TEXT("\\Unimodem");

                LONG    lResult;
                HKEY    hKey;
                DWORD   Type;
                DWORD   Size;

                lResult=RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    UnimodemRegPath,
                    0,
                    KEY_READ,
                    &hKey
                    );


                if (lResult == ERROR_SUCCESS) {

                    Size = sizeof(DebugFlags);

                    RegQueryValueEx(
                        hKey,
                        TEXT("DebugFlags"),
                        NULL,
                        &Type,
                        (LPBYTE)&DebugFlags,
                        &Size
                        );

                    RegCloseKey(hKey);
                }
            }


#endif

            D_INIT(DbgPrint("ProcessAttach\n");)

            DisableThreadLibraryCalls(hDll);
            //
            //  initial global data
            //

            DriverControl.Signature=DRIVER_CONTROL_SIG;

            DriverControl.ReferenceCount=0;

            DriverControl.ModuleHandle=hDll;

            InitializeListHead(&DriverControl.MonitorListHead);

            DEBUG_MEMORY_PROCESS_ATTACH("UNIPLAT");

            break;

        case DLL_PROCESS_DETACH:

            D_INIT(DbgPrint("ProcessDeattach\n");)

            ASSERT(DriverControl.ReferenceCount == 0);
            //
            //  clean up
            //

            if (DriverControl.ActiveCallsEvent!= NULL) {

                CloseHandle(DriverControl.ActiveCallsEvent);
                DriverControl.ActiveCallsEvent=NULL;
            }

            if (DriverControl.ThreadFinishEvent!=NULL)
            {
                CloseHandle(DriverControl.ThreadFinishEvent);
                DriverControl.ThreadFinishEvent=NULL;
            }

            DeleteCriticalSection(
                &DriverControl.Lock
                );

            DEBUG_MEMORY_PROCESS_DETACH();

            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

        default:
              break;

    }

    return TRUE;

}


VOID
UmWorkerThread(
    PDRIVER_CONTROL   DriverControl
    )

{

    BOOL           bResult;
    DWORD          BytesTransfered;
    DWORD          CompletionKey;
    LPOVERLAPPED   OverLapped;
    DWORD          WaitResult=WAIT_IO_COMPLETION;

    PUM_OVER_STRUCT UmOverlapped;

    D_INIT(DbgPrint("UmWorkThread:  starting\n");)

    while (WaitResult != WAIT_OBJECT_0) {

        WaitResult=WaitForSingleObjectEx(
            DriverControl->ThreadStopEvent,
            INFINITE,
            TRUE
            );


    }

    D_INIT(DbgPrint("UmWorkThread:  Exitting\n");)

    ExitThread(0);

}



HANDLE WINAPI
UmPlatformInitialize(
    VOID
    )
/*++

Routine Description:

    This routine is called to initialize the modem driver.
    It maybe called multiple times. After the first call a reference count will simply
    be incremented. UmDeinitializeModemDriver() must be call and equal number of times.

Arguments:

    None

Return Value:

    returns a handle to Driver instance which is passed to UmOpenModem()
    or NULL for failure



--*/

{

    HANDLE    ReturnValue=&DriverControl;

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.ReferenceCount++;

    if ( DriverControl.ReferenceCount == 1) {
        //
        // First call, do init stuff
        //
        D_INIT(DbgPrint("UmPlatFormInitialize\n");)

//        InitializeTimerThread();

        DriverControl.ThreadStopEvent=CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

        if (DriverControl.ThreadStopEvent != NULL) {

            DWORD   ThreadId;

            DriverControl.ThreadHandle=CreateThread(
                NULL,                                  // attributes
                0,                                     // stack size
                (LPTHREAD_START_ROUTINE)UmWorkerThread,
                &DriverControl,
                0,                                     // createion flag
                &ThreadId
                );

            if (DriverControl.ThreadHandle != NULL) {

                //
                //  bump it up a little
                //
                SetThreadPriority(
                    DriverControl.ThreadHandle,
                    THREAD_PRIORITY_ABOVE_NORMAL
                    );

                ReturnValue=&DriverControl;

            } else {

                DriverControl.ReferenceCount--;

                ReturnValue=NULL;

            }

        } else {

            DriverControl.ReferenceCount--;

            ReturnValue=NULL;

        }

    }


    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return ReturnValue;

}





VOID WINAPI
UmPlatformDeinitialize(
    HANDLE    DriverInstanceHandle
    )
/*++

Routine Description:

    This routine is called to de-initialize the modem driver.

    Must be called the same number of time as UmInitializeModemDriver()

Arguments:

    DriverInstanceHandle - Handle returned by UmInitialmodemDriver

Return Value:

    None


--*/

{



    EnterCriticalSection(
        &DriverControl.Lock
        );

    ASSERT(DriverControl.ReferenceCount != 0);

    DriverControl.ReferenceCount--;

    if ( DriverControl.ReferenceCount == 0) {
        //
        // Last reference, free stuff
        //

        SetEvent(DriverControl.ThreadStopEvent);

        WaitForSingleObject(
            DriverControl.ThreadHandle,
            INFINITE
            );

        CloseHandle(
            DriverControl.ThreadHandle
            );

        CloseHandle(DriverControl.ThreadStopEvent);
    }

    LeaveCriticalSection(
        &DriverControl.Lock
        );



    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\system.c ===
#include "internal.h"

#define MY_BUFSIZE 32 // arbitrary. Use dynamic allocation

BOOL WINAPI WinntIsWorkstation ()
{
 HKEY hKey;
 TCHAR szProductType[MY_BUFSIZE];
 DWORD dwBufLen=MY_BUFSIZE;
 LONG bRet = FALSE;

    if (ERROR_SUCCESS ==
        RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                       0,
                       KEY_QUERY_VALUE,
                       &hKey))
    {
        if (ERROR_SUCCESS ==
            RegQueryValueEx (hKey,
                             TEXT("ProductType"),
                             NULL,
                             NULL,
                             (LPBYTE)szProductType,
                             &dwBufLen))
        {
            if (0 == lstrcmpi (TEXT("WINNT"), szProductType))
            {
                bRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\slot.c ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       SLOT.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  3/25/96     JosephJ             Created
//
//
//  Description: Implements the unimodem TSP notification mechanism:
//				 The lower level (notifXXXX) APIs
//
//****************************************************************************

#include "internal.h"

#include <slot.h>
#include <tspnotif.h>
#include <aclapi.h>
#include <objbase.h>

#define T(_str) TEXT(_str)

#ifdef CONSOLE
#define ASSERT(_c) \
	((_c) ? 0: DPRINTF2("Assertion failed in %s:%d\n", __FILE__, __LINE__))
#define DPRINTF(_fmt) 					printf(_fmt)
#define DPRINTF1(_fmt,_arg) 			printf(_fmt,_arg)
#define DPRINTF2(_fmt,_arg,_arg2) 		printf(_fmt,_arg,_arg2)
#define DPRINTF3(_fmt,_arg,_arg2,_arg3) printf(_fmt,_arg,_arg2,_arg3)
#endif // CONSOLE

#define fNOTIF_STATE_DEINIT 0
#define fNOTIF_STATE_INIT_SERVER 1
#define fNOTIF_STATE_INIT_CLIENT 2

#define IS_SERVER(_pnc) ((_pnc)->dwState==fNOTIF_STATE_INIT_SERVER)
#define IS_CLIENT(_pnc) ((_pnc)->dwState==fNOTIF_STATE_INIT_CLIENT)


// {9426020A-6D00-4a96-872D-EFBEEBFD7833}
static const GUID EventNamePrefix =
    { 0x9426020a, 0x6d00, 0x4a96, { 0x87, 0x2d, 0xef, 0xbe, 0xeb, 0xfd, 0x78, 0x33 } };

const  WCHAR   *EventNamePrefixString=L"{9426020A-6D00-4a96-872D-EFBEEBFD7833}";


// The following help define the fully-qualified mailslot and semaphore names.
#define dwNOTIFSTATE_SIG (0x53CB31A0L)
#define FULLNAME_TEMPLATE	T("\\\\.\\mailslot\\%08lx\\%s")

#define NOTIFICATION_TIMEOUT    10000   // 10 sesonds

// Keeps the state of a notification (either client or server).
// It is cast to a DWORD to form the handle returned by notifCreate()
typedef struct
{
	DWORD dwSig; // should be dwNOTIFSTATE_SIG when inited
    HANDLE hEvent;

	HANDLE hSlot;
	DWORD dwState;
	DWORD dwcbMax;
    CRITICAL_SECTION critSect;  // to protect pNotif
} NOTIFICATION_CHANNEL, *PNOTIFICATION_CHANNEL;


#define fTSPNOTIF_FLAGS_SET_EVENT  (1 << 0)

#pragma warning (disable : 4200)
typedef struct
{
	DWORD  dwSig;       // MUST be dwNFRAME_SIG
	DWORD  dwSize;      // Entire size of this structure
	DWORD  dwType;      // One of the TSPNOTIF_TYPE_ constants
	DWORD  dwFlags;     // Zero or more  fTSPNOTIF_FLAGS_ constants

                        // Event set by the TSP to let us know it's
                        //   done processing our notification
    GUID   EventName;
    BOOL   SignalEvent;

    PNOTIFICATION_CHANNEL  NotificationChannel;

    BYTE   notifData[];
} NOTIFICATION_HEADDER, *PNOTIFICATION_HEADDER;
#pragma warning (default : 4200)

HANDLE
CreateEventWithSecurity(
    LPTSTR                     EventName,
    PSID_IDENTIFIER_AUTHORITY  Sid,
    BYTE                       Rid,
    DWORD                      AccessRights
    );


PNOTIFICATION_CHANNEL inotif_getchannel (HNOTIFCHANNEL hc);

//****************************************************************************
// Function: Creates a notification channel -- called by the server.
//
// History:
//  3/25/98	EmanP   Created
//****************************************************************************/
HNOTIFCHANNEL notifCreateChannel (
	LPCTSTR lptszName,          // Name to associate with this object
	DWORD dwMaxSize,            // Max size of frames written/read
	DWORD dwMaxPending)         // Max number of notification frames allowed
                                // to be pending.
{
 PNOTIFICATION_CHANNEL pnc = NULL;
 HNOTIFCHANNEL hn = 0;
 DWORD dwErr = 0;
 TCHAR c, *pc;
 TCHAR rgtchTmp[MAX_NOTIFICATION_NAME_SIZE+23];
 SECURITY_ATTRIBUTES  sa;
 PSECURITY_DESCRIPTOR pSD = NULL;
 PSID pEveryoneSID = NULL;
 PACL pACL = NULL;
 EXPLICIT_ACCESS ea;
 SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;

	// Format of semaphore name is --.-mailslot-sig-name
	// Example: "--.-mailslot-8cb45651-unimodem"
	// To create the equivalent mailslot, we run through and change
	// all '-' to '\'s (if the name containts '-', they will get converted --
	// big deal.)
	if ((lstrlen(lptszName)+23)>(sizeof(rgtchTmp)/sizeof(TCHAR))) // 13(prefix)+ 9(sig-) +1(null)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		goto end;
	}

	pnc = ALLOCATE_MEMORY( sizeof(*pnc));
	if (!pnc)
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto end;
    }

    // Create security descriptor and 
    // initialize the security attributes;
    // this is neeeded because this code runs in
    // a service (tapisrv), and other processes will
    // not have access (by default).

	pSD = ALLOCATE_MEMORY( SECURITY_DESCRIPTOR_MIN_LENGTH);

	if (!pSD ||
        !InitializeSecurityDescriptor (pSD, SECURITY_DESCRIPTOR_REVISION))
    {
		dwErr = GetLastError();
        goto end;
    }

	// Set owner for the descriptor
	//
	if (!SetSecurityDescriptorOwner (pSD, NULL, FALSE))
	{
		dwErr = GetLastError();
		goto end;
	}

	// Set group for the descriptor
	//
	if (!SetSecurityDescriptorGroup (pSD, NULL, FALSE))
	{
		dwErr = GetLastError();
		goto end;
	}

	// Create a well-known SID for the Everyone group
	//
	if (!AllocateAndInitializeSid( &SIDAuthWorld, 1,
					SECURITY_WORLD_RID,
					0, 0, 0, 0, 0, 0, 0,
					&pEveryoneSID) )
	{
		dwErr = GetLastError();
		goto end;
	}

	// Initialize an EXPLICIT_ACCESS structure for an ACE
	//
	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | SYNCHRONIZE | READ_CONTROL;
	ea.grfAccessMode = SET_ACCESS;
	ea.grfInheritance = NO_INHERITANCE;
	ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea.Trustee.ptstrName = (LPTSTR) pEveryoneSID;

	if (SetEntriesInAcl(1, &ea, NULL, &pACL) != ERROR_SUCCESS)
	{
		dwErr = GetLastError();
		goto end;
	}

	if (!SetSecurityDescriptorDacl (pSD, TRUE, pACL, FALSE))
	{
		dwErr = GetLastError();
		goto end;
	}

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;


	wsprintf (rgtchTmp,
              FULLNAME_TEMPLATE,
			  (unsigned long) dwNOTIFSTATE_SIG,
			  lptszName);

	// CreateMailSlot  -- specify size, zero-delay
	pnc->hSlot = CreateMailslot (rgtchTmp, dwMaxSize, 0, &sa);
	if (!pnc->hSlot)
	{
		dwErr = GetLastError();
		goto end;
	}

	// Create event name
	for (pc = rgtchTmp; c=*pc; pc++)
    {
        if (T('\\') == c)
        {
            *pc = T('-');
        }
    }

	// Create event
	pnc->hEvent = CreateEvent (&sa, FALSE, FALSE, rgtchTmp);
	if (!pnc->hEvent)
    {
        dwErr = GetLastError ();
		CloseHandle (pnc->hSlot);
        pnc->hSlot = NULL;
        goto end;
    }

	// set state and maxsize
	pnc->dwState    = fNOTIF_STATE_INIT_SERVER;
	pnc->dwcbMax    = dwMaxSize;
	pnc->dwSig      = dwNOTIFSTATE_SIG;

	hn = (HNOTIFCHANNEL)pnc;

end:
	if (pEveryoneSID)
	{
		FreeSid(pEveryoneSID);
	}
	if (pACL)
	{
		LocalFree(pACL);
	}
	if (pSD) 
    {
        FREE_MEMORY(pSD);
    }

	if (0 == hn)
	{
		if (pnc)
        {
            FREE_MEMORY(pnc);
        }
		SetLastError(dwErr);
	}

	return hn;
}


//****************************************************************************
// Function: Openes a notification channel -- called by the client.
//
// History:
//  3/25/98	EmanP   Created
//****************************************************************************/
HNOTIFCHANNEL notifOpenChannel (
	LPCTSTR lptszName)   // Name to associate with this object
{
 PNOTIFICATION_CHANNEL pnc = NULL;
 HNOTIFCHANNEL hn = 0;
 DWORD dwErr = 0;
 TCHAR c, *pc;
 TCHAR rgtchTmp[MAX_NOTIFICATION_NAME_SIZE+23];

	// Format of semaphore name is --.-mailslot-sig-name
	// Example: "--.-mailslot-8cb45651-unimodem"
	// To create the equivalent mailslot, we run through and change
	// all '-' to '\'s (if the name containts '-', they will get converted --
	// big deal.)
	if ((lstrlen(lptszName)+23)>(sizeof(rgtchTmp)/sizeof(TCHAR))) // 13(prefix)+ 9(sig-) +1(null)
	{
		dwErr = ERROR_INVALID_PARAMETER;
		goto end;
	}

	pnc = ALLOCATE_MEMORY( sizeof(*pnc));
	if (!pnc)
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto end;
    }

	wsprintf (rgtchTmp,
              FULLNAME_TEMPLATE,
			  (unsigned long) dwNOTIFSTATE_SIG,
			  lptszName);

	// Open mailslot ...
	pnc->hSlot = CreateFile (rgtchTmp,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

	if (INVALID_HANDLE_VALUE == pnc->hSlot)
	{
        dwErr = GetLastError ();
		goto end;
	}

	// Create event name -- convert '\' to '-';
	for (pc = rgtchTmp; c=*pc; pc++)
    {
        if (T('\\') == c)
        {
            *pc = T('-');
        }
    }

	// OpenEvent
    pnc->hEvent = OpenEvent (EVENT_MODIFY_STATE, FALSE, rgtchTmp);
	if (!pnc->hEvent)
    {
		dwErr=GetLastError();
		CloseHandle (pnc->hSlot);
        pnc->hSlot = NULL;
 		goto end;
	}

	// set state and maxsize
	pnc->dwState    = fNOTIF_STATE_INIT_CLIENT;
	pnc->dwcbMax    = 0; // Apparently you can't get the max size of the mailslot.
	pnc->dwSig      = dwNOTIFSTATE_SIG;

	hn = (HNOTIFCHANNEL)pnc;

end:
	if (!hn)
	{
		if (pnc)
        {
            FREE_MEMORY(pnc);
        }
		SetLastError(dwErr);
	}

	return hn;
}


#ifdef UNICODE
HNOTIFCHANNEL notifCreateChannelA (
    LPCSTR lpszName,			// Name to associate with this object
    DWORD dwMaxSize,			// Max size of frames written/read
    DWORD dwMaxPending)         // Max number of notification frames allowed
                                // to be pending.  (Ignored if (!fServer))
{
 WCHAR wszName[128];

  // Do the conversion and call modemui.dll if it succeeds.
  if (MultiByteToWideChar (CP_ACP,
                           MB_PRECOMPOSED,
                           lpszName,
                           -1,
                           wszName,
                           sizeof(wszName)/sizeof(*wszName)))
  {
    return notifCreateChannelW (wszName,
                                dwMaxSize,
                                dwMaxPending);
  }
  else
  {
    return 0;
  }
}

HNOTIFCHANNEL notifOpenChannelA (
    LPCSTR lpszName)        // Name to associate with this object
{
 WCHAR wszName[128];

  // Do the conversion and call modemui.dll if it succeeds.
  if (MultiByteToWideChar (CP_ACP,
                           MB_PRECOMPOSED,
                           lpszName,
                           -1,
                           wszName,
                           sizeof(wszName)/sizeof(*wszName)))
  {
    return notifOpenChannelW (wszName);
  }
  else
  {
    return 0;
  }
}

#undef notifCreateChannel
#undef notifOpenChannel

HNOTIFCHANNEL notifCreateChannel (
	LPCTSTR lptszName,			// Name to associate with this object
	DWORD dwMaxSize,			// Max size of frames written/read
	DWORD dwMaxPending)         // Max number of notification frames allowed
                                // to be pending.  (Ignored if (!fServer))
{
    return notifCreateChannelW (lptszName,
                                dwMaxSize,
                                dwMaxPending);
}

HNOTIFCHANNEL notifOpenChannel (
	LPCTSTR lptszName)      // Name to associate with this object
{
    return notifOpenChannelW (lptszName);
}

#else // !UNICODE
    #error "non-Unicoded version Unimplemented"
#endif // !UNICODE

//****************************************************************************
// Function: Closes a notification channel
//
// History:
//  3/25/98 EmanP   Created
//****************************************************************************/
void notifCloseChannel (HNOTIFCHANNEL hChannel)
{
 PNOTIFICATION_CHANNEL pnc = inotif_getchannel (hChannel);

	if (pnc)
	{
        CloseHandle (pnc->hEvent);
		CloseHandle (pnc->hSlot);
		FREE_MEMORY(pnc);
	}
}


//****************************************************************************
// Function: Creates a new notification frame
//
// History:
//  3/25/98 EmanP   Created
//****************************************************************************/
HNOTIFFRAME
notifGetNewFrame (
    HNOTIFCHANNEL hChannel,         // Handle to notification channel
    DWORD  dwNotificationType,      // Type of this notification
    DWORD  dwNotificationFlags,     // Notification flags
    DWORD  dwBufferSize,            // How many bytes for the notification data
    PVOID *ppFrameBuffer)           // where to put the address of the data
{
    PNOTIFICATION_CHANNEL pnc;
    PNOTIFICATION_HEADDER pNotif;

    *ppFrameBuffer = NULL;

    pnc = inotif_getchannel (hChannel);

    if (NULL == pnc) {

        SetLastError (ERROR_INVALID_HANDLE);
        return NULL;
    }


    dwBufferSize += sizeof(NOTIFICATION_HEADDER);
    pNotif = ALLOCATE_MEMORY( dwBufferSize);
    if (NULL == pNotif) {

        SetLastError (ERROR_OUTOFMEMORY);
        return NULL;
    }

    pNotif->SignalEvent = FALSE;
    pNotif->dwSig       = dwNFRAME_SIG;
    pNotif->dwSize      = dwBufferSize;
    pNotif->dwType      = dwNotificationType;
    pNotif->dwFlags     = dwNotificationFlags;
    pNotif->NotificationChannel=pnc;

    if (sizeof(NOTIFICATION_HEADDER) < dwBufferSize) {

        *ppFrameBuffer = (PVOID)&pNotif->notifData;
    }

    return pNotif;
}



//****************************************************************************
// Function: Sends a notification frame.
//
// History:
//  3/25/98 EmanP   Created
//****************************************************************************/
BOOL
notifSendFrame (
    HNOTIFFRAME             hFrame,
    BOOL          bBlocking
    )
{
    PNOTIFICATION_HEADDER   pNotif=hFrame;
    PNOTIFICATION_CHANNEL pnc=pNotif->NotificationChannel;
    HANDLE hEvent = NULL;
    DWORD dwWritten, dwErr;
    BOOL bRet;


    if (bBlocking) {

        TCHAR    EventName[MAX_PATH];

        lstrcpy(EventName,EventNamePrefixString);
        lstrcat(EventName,TEXT("#"));

        CoCreateGuid(
            &pNotif->EventName
            );

        StringFromGUID2(
            &pNotif->EventName,
            &EventName[lstrlen(EventName)],
            MAX_PATH-(lstrlen(EventName)+1)
            );


        hEvent = CreateEvent(NULL, TRUE, FALSE, EventName);

        if (NULL == hEvent ) {

            FREE_MEMORY(pNotif);

            return FALSE;
        }

        pNotif->SignalEvent=TRUE;

    }

    bRet = WriteFile (pnc->hSlot,
                      pNotif,
                      pNotif->dwSize,
                      &dwWritten,
                      NULL);
    dwErr = GetLastError ();    // save it in case we failed

    FREE_MEMORY(pNotif);

    if (bRet)
    {
        bRet = SetEvent (pnc->hEvent);
        if (bRet && bBlocking)

        {
            ASSERT( WAIT_TIMEOUT != WaitForSingleObject (hEvent, NOTIFICATION_TIMEOUT));
        }
    }
    else
    {
        // restore the last error here
        SetLastError (dwErr);
    }

    if (NULL != hEvent)
    {
        CloseHandle (hEvent);
    }

    return bRet;
}



//****************************************************************************
// Function: monitors the channel in alertable mode.
//
// History:
//  3/25/96 EmanP   Created
//****************************************************************************/

#define MAX_FAILED_NOTIFICATIONS 5

DWORD notifMonitorChannel (
    HNOTIFCHANNEL hChannel,
    PNOTIFICATION_HANDLER pHandler,
    DWORD dwSize,
    PVOID pParam)
{
 PNOTIFICATION_CHANNEL pnc;
 DWORD dwMessageSize, dwRead, dwRet = NO_ERROR, dwFail = 0;
 BOOL bGoOn = TRUE;
 PNOTIFICATION_HEADDER pNotif;

    pnc = inotif_getchannel (hChannel);
    if (NULL == pnc)
    {
        return  ERROR_INVALID_HANDLE;
    }

    while (bGoOn &&
           MAX_FAILED_NOTIFICATIONS > dwFail)
    {
        // Let's put the thread in an alertable state,
        // while waiting for notifications.
        if (WAIT_OBJECT_0 == WaitForSingleObjectEx (pnc->hEvent, INFINITE, TRUE))
        {
            dwFail++;
            // we have some mail slot messages;
            // try to get and proces them.
            while (bGoOn)
            {
                // first, try to get info about the message(s).
                if (!GetMailslotInfo (pnc->hSlot, NULL, &dwMessageSize, NULL, NULL))
                {
                    // Could not get the mailslot info;
                    // get out or the inner loop.
                    break;
                }
                if (MAILSLOT_NO_MESSAGE == dwMessageSize)
                {
                    // We're done retrieving messages;
                    // get out.
                    break;
                }

                // let's allocate memory for the notification
                pNotif = ALLOCATE_MEMORY( dwMessageSize);
                if (NULL == pNotif)
                {
                    // couldn't allocate memory to read the message;
                    // get out, and maybe next time we'll be more lucky.
                    break;
                }

                // now let's read the notification
                // and validate it
                if (!ReadFile (pnc->hSlot, pNotif, dwMessageSize, &dwRead, NULL))
                {
                    // some error reading the mailslot;
                    // get out, and mayble next time we'll be more lucky
                    break;
                }

                dwFail = 0;         // Successful read, so reinitialize
                                    // the failure counter

                if (dwMessageSize == dwRead &&
                    dwNFRAME_SIG  == pNotif->dwSig &&
                    dwMessageSize == pNotif->dwSize)
                {
                    // we have a valid notification;
                    // time to inform our client.
                    bGoOn = pHandler (pNotif->dwType,
                                      pNotif->dwFlags,
                                      pNotif->dwSize - sizeof (NOTIFICATION_HEADDER),
                                      pNotif->notifData);

                    // now, let's check if someone isn't
                    // waiting for us to finish.
                    // if (pNotif->dwFlags & fTSPNOTIF_FLAGS_SET_EVENT)
                    if (pNotif->SignalEvent)
                    {
                        WCHAR    EventName[MAX_PATH];

                        HANDLE hProcess, hEvent;

                        lstrcpy(EventName,EventNamePrefixString);
                        lstrcat(EventName,TEXT("#"));

                        StringFromGUID2(
                            &pNotif->EventName,
                            &EventName[lstrlen(EventName)],
                            MAX_PATH-(lstrlen(EventName)+1)
                            );

                        hEvent=OpenEvent(
                            EVENT_MODIFY_STATE,
                            FALSE,
                            EventName
                            );

                        if (hEvent != NULL) {

                            SetEvent(hEvent);

                            CloseHandle(hEvent);
                        }
                    }
                }

                // At this point, we're done with
                // the notification - free it.
                FREE_MEMORY(pNotif);
                pNotif = NULL;

                // Now, let's give APC's a chance
                //
                if (WAIT_IO_COMPLETION == SleepEx (0, TRUE)) {
                    //
                    //  an apc completed, call the handler
                    //
                    // we returned because of some APC that
                    // was queued for this thread.
                    bGoOn = pHandler (TSPNOTIF_TYPE_CHANNEL,
                                      fTSPNOTIF_FLAG_CHANNEL_APC,
                                      dwSize,
                                      pParam);

                }
            }
        }
        else
        {
            // we returned because of some APC that
            // was queued for this thread.
            bGoOn = pHandler (TSPNOTIF_TYPE_CHANNEL,
                              fTSPNOTIF_FLAG_CHANNEL_APC,
                              dwSize,
                              pParam);
        }
    }

    if (MAX_FAILED_NOTIFICATIONS == dwFail)
    {
        dwRet = ERROR_GEN_FAILURE;
    }

    return dwRet;
}



//****************************************************************************
// Function: (internal) validates and converts a handle to a ptr to channel.
//
// History:
//  3/25/96	JosephJ	Created
//****************************************************************************/
PNOTIFICATION_CHANNEL inotif_getchannel (HNOTIFCHANNEL hc)
{
	if (hc)
	{
	 PNOTIFICATION_CHANNEL pnc = (PNOTIFICATION_CHANNEL)hc;
		if (dwNOTIFSTATE_SIG != pnc->dwSig)
		{
			ASSERT(FALSE);
			return NULL;
		}
		return pnc;
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\timer.c ===
//****************************************************************************
//
//  Module:     Unimdm
//  File:       timer.c
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//
//
//  Description:
//
//****************************************************************************

#include "internal.h"

#define USE_APC 1

//#include "timer.h"

typedef struct _UNIMODEM_TIMER {

    TIMER_CALLBACK           *CallbackProc;
    HANDLE                    Context1;
    HANDLE                    Context2;

    HANDLE                    TimerHandle;

} UNIMODEM_TIMER, *PUNIMODEM_TIMER;




VOID WINAPI
TimerApcRoutine(
    PUNIMODEM_TIMER    ThisTimer,
    DWORD              LowTime,
    DWORD              HighTime
    );







HANDLE WINAPI
CreateUnimodemTimer(
    PVOID        PoolHandle
    )

{

    PUNIMODEM_TIMER  TimerObject;

    TimerObject=ALLOCATE_MEMORY(sizeof(UNIMODEM_TIMER));

    if (TimerObject == NULL) {

        return NULL;
    }

    TimerObject->TimerHandle=CreateWaitableTimer(
        NULL,
        TRUE,
        NULL
        );

    if (TimerObject->TimerHandle == NULL) {

       FREE_MEMORY(TimerObject);

       return NULL;
    }


    TimerObject->CallbackProc=NULL;
    TimerObject->Context1=NULL;
    TimerObject->Context2=NULL;


    return (HANDLE)TimerObject;

}

VOID WINAPI
FreeUnimodemTimer(
    HANDLE                TimerHandle
    )

{
    PUNIMODEM_TIMER   TimerObject=(PUNIMODEM_TIMER) TimerHandle;

    ASSERT(TimerObject->CallbackProc == NULL);

    CloseHandle(TimerObject->TimerHandle);

    FREE_MEMORY(TimerObject);

    return;
}


VOID WINAPI
TimerApcRoutine(
    PUNIMODEM_TIMER    TimerObject,
    DWORD              LowTime,
    DWORD              HighTime
    )

{
    TIMER_CALLBACK      *CallbackProc;
    HANDLE              Context1;
    HANDLE              Context2;

    CallbackProc=TimerObject->CallbackProc;
    Context1=TimerObject->Context1;
    Context2=TimerObject->Context2;

    TimerObject->CallbackProc=NULL;


//    D_TRACE(McxDpf(888,"TimerThreadProc: Timer expired %08lx, time=%d",TimerObject,GetTickCount());)

    (*CallbackProc)(
        Context1,
        Context2
        );

    return;

}


VOID WINAPI
SetUnimodemTimer(
    HANDLE              TimerHandle,
    DWORD               Duration,
    TIMER_CALLBACK      CallbackFunc,
    HANDLE              Context1,
    HANDLE              Context2
    )

{

    PUNIMODEM_TIMER  TimerObject=(PUNIMODEM_TIMER) TimerHandle;

    LONGLONG       DueTime=Int32x32To64(Duration,-10000);

//    D_TRACE(McxDpf(888,"SetUnimodemTimer: %08lx, time=%d, %d",TimerHandle,GetTickCount(),Duration);)

    ASSERT(TimerObject->CallbackProc == NULL);

    TimerObject->CallbackProc=CallbackFunc;
    TimerObject->Context1=Context1;
    TimerObject->Context2=Context2;


    SetWaitableTimer(
        TimerObject->TimerHandle,
        (LARGE_INTEGER*)&DueTime,
        0,
        TimerApcRoutine,
        TimerObject,
        FALSE
        );

    return;

}


BOOL WINAPI
CancelUnimodemTimer(
    HANDLE                TimerHandle
    )

{

    PUNIMODEM_TIMER   TimerObject=(PUNIMODEM_TIMER) TimerHandle;

#if DBG
    TimerObject->CallbackProc=NULL;
#endif

    CancelWaitableTimer(
        TimerObject->TimerHandle
        );

    return TRUE;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\dllmain.c ===
#define WIN9x
#include <common.h>
#include <initguid.h>

DEFINE_GUID(GUID_DEVCLASS_MODEM,
 0x4d36e96dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );

LPGUID g_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;
HINSTANCE g_hDll = NULL;

BOOL
APIENTRY
DllMain(
	HINSTANCE hDll,
	DWORD dwReason,
	LPVOID lpReserved
	)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hDll);
            g_hDll = hDll;
            break;

        case DLL_PROCESS_DETACH:

            CLOSE_LOG

            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\common.h ===
#include <windows.h>
#include <regstr.h>
#include <objbase.h>
#include <cfgmgr32.h>
#include <setupapi.h>

#include <string.h>
#include <wtypes.h>
#include <malloc.h>

#include <bustype.h>

#include "log.h"

#define MAX_CLASS_NAME_LEN   32
#define MAX_PORTS 64
#define MAX_PORT_NAME_LENGTH 256

extern LPGUID g_pguidModem;
extern HINSTANCE g_hDll;

typedef struct
{
    CHAR szPortname[MAX_PORT_NAME_LENGTH];
    DWORD dwBaseAddress;
} Ports_t;

typedef struct
{
    DWORD dwPortCount;
    Ports_t PortAddress[MAX_PORTS];
} Ports;

VOID EnumeratePorts(Ports *p);
int port_findname(Ports p, DWORD dwBaseAddress, CHAR *name);
int port_findaddress(Ports p, DWORD *dwBaseAddress, CHAR *name);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\uniplat\tspnotif.c ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       TSPNOTIF.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  6/03/97     JosephJ             Created (extracted from ..\..\cpl\util.c)
//
//
//  Description: Implements UnimodemNotifyTSP
//
//****************************************************************************

#include "internal.h"
#include <slot.h>
#include <tspnotif.h>

// Functions: Notify the TSP -- general version.
//
// Return:    TRUE if successful
//            FALSE if failure (including if the tsp is not active)
//            GetLastError() returns the win32 failure code.
//  History:
//            3/24/96 JosephJ Created (copied from ..\new\slot\client.c)
//****************************************************************************

BOOL WINAPI UnimodemNotifyTSP (
    DWORD dwType,
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pData,
    BOOL  bBlocking)
{
    BOOL fRet=FALSE;
    HNOTIFCHANNEL hChannel;
    PVOID pTemp;
    HNOTIFFRAME   hFrame;

    hChannel = notifOpenChannel (SLOTNAME_UNIMODEM_NOTIFY_TSP);

    if (hChannel)
    {
        hFrame = notifGetNewFrame (hChannel, dwType, dwFlags, dwSize, &pTemp);

        if (hFrame != NULL) {

            if ((NULL != pData) && (0 != dwSize)) {

                CopyMemory (pTemp, pData, dwSize);
            }

            fRet = notifSendFrame (hFrame, bBlocking);
        }

        notifCloseChannel (hChannel);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\commport.c ===
#include "common.h"

GUID    SerialGuid = {0x4d36e978, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b,
    0xe1, 0x03, 0x18};

VOID
EnumeratePorts(Ports *p)
{
    HDEVINFO            hDevInfoSet;
    INT                 DevCount;
    SP_DEVINFO_DATA     DevInfoData;
    CONFIGRET           CmReturnCode, CmReturnCode2;
    LONG                RegReturnCode;
    LOG_CONF            LogConf;

    hDevInfoSet = INVALID_HANDLE_VALUE;
    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    p->dwPortCount = 0;

    do
    {
        //  Get a handle to the device information set for the port class

        hDevInfoSet = SetupDiGetClassDevs(&SerialGuid, NULL, NULL, DIGCF_PRESENT| DIGCF_PROFILE);

        if (hDevInfoSet == INVALID_HANDLE_VALUE)
        {
            LOG("modemigr: SetDiGetClassDevs failed: %x\n", GetLastError());
            break;
        }

        //  Run through each device in this class.

        for (DevCount = 0; /* NOTHING */; DevCount++)
        {
            LOG_CONF logConfig;
            RES_DES resDes;
            CONFIGRET cr;
            IO_RESOURCE ioResource;
            BOOL success;
            DWORD dwBase;
            HKEY hDeviceReg;
            DWORD dwPortNameSize;
            LONG lResult;

            if (!SetupDiEnumDeviceInfo(hDevInfoSet, DevCount, &DevInfoData))
            {
                //  No more devices.
                break;
            }

            hDeviceReg = SetupDiOpenDevRegKey(hDevInfoSet,
                    &DevInfoData,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DEV,
                    KEY_ALL_ACCESS);

            if (hDeviceReg != INVALID_HANDLE_VALUE)
            {

                if (CM_Get_First_Log_Conf(&logConfig,DevInfoData.DevInst,
                            BOOT_LOG_CONF) == CR_SUCCESS)
                {
                    if (CM_Get_Next_Res_Des(&resDes,logConfig,ResType_IO,
                                NULL,0) == CR_SUCCESS)
                    {
                        cr = CM_Get_Res_Des_Data(resDes,&ioResource,
                                sizeof(IO_RESOURCE),0);

                        CM_Free_Res_Des_Handle(resDes);

                        if (cr == CR_SUCCESS)
                        {
                            dwPortNameSize = MAX_PORT_NAME_LENGTH;

                            lResult = RegQueryValueEx(hDeviceReg,
                                    TEXT("Portname"),
                                    0,
                                    0,
                                    p->PortAddress[p->dwPortCount].szPortname,
                                    &dwPortNameSize);

                            if (lResult == ERROR_SUCCESS)
                            {
                                p->PortAddress[p->dwPortCount].dwBaseAddress = (DWORD)ioResource.IO_Header.IOD_Alloc_Base;
                                (p->dwPortCount)++;
                            }
                        }
                    }
                }

                RegCloseKey(hDeviceReg);
            }


        } // for (DevCount...)

        break;

    }
    while (FALSE);

    if (hDevInfoSet != INVALID_HANDLE_VALUE)
    {
        if (!SetupDiDestroyDeviceInfoList(hDevInfoSet))
        {
            LOG("modemmigr: SetupDiDestroyDeviceInfoList failed: %x\n",
                        GetLastError());
        }
    }
}


// Find com port name given an address

int port_findname(Ports p, DWORD dwBaseAddress, CHAR *name)
{
    DWORD i;

    name[0] = '\0';

    for(i=0;i<p.dwPortCount;i++)
    {
        if (p.PortAddress[i].dwBaseAddress
                == dwBaseAddress)
        {
            strcpy(name,p.PortAddress[i].szPortname);
            return 1;
        }
    }

    return 0;
}


// Find com port address given a name

int port_findaddress(Ports p, DWORD *dwBaseAddress, CHAR *name)
{
    DWORD i;

    *dwBaseAddress = 0;

    for(i=0;i<p.dwPortCount;i++)
    {
        if (!strcmp(name,p.PortAddress[i].szPortname))
        {
            *dwBaseAddress = p.PortAddress[i].dwBaseAddress;
            return 1;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\makefile.inc ===
$(O)\msg.mc: $(BASE_INC_PATH)\vendinfo.mc
    copy $** $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\log.c ===
#include "common.h"

#ifdef DO_LOG

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;
WCHAR g_szLogFileName[16];
WCHAR szBuffer[1024];
WCHAR g_szLogFileFullName[MAX_PATH];
BOOL bUnicode;

void StartLogA (LPCSTR szPath)
{
    bUnicode = FALSE;

    lstrcpyA ((LPSTR)g_szLogFileName, "\\Log9x.txt");
    lstrcpyA ((LPSTR)g_szLogFileFullName, szPath);
    lstrcatA ((LPSTR)g_szLogFileFullName, (LPSTR)g_szLogFileName);

    g_hLogFile = CreateFileA ((LPSTR)g_szLogFileFullName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        SetFilePointer (g_hLogFile, 0, NULL, FILE_END);
    }
}


void StartLogW (LPCWSTR szPath)
{
    bUnicode = TRUE;

    lstrcpyW (g_szLogFileName, L"\\LogNT.txt");
    lstrcpyW (g_szLogFileFullName, szPath);
    lstrcatW (g_szLogFileFullName, g_szLogFileName);

    g_hLogFile = CreateFileW (g_szLogFileFullName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        SetFilePointer (g_hLogFile, 0, NULL, FILE_END);
    }
}


void logA (LPSTR Format, ...)
{
 va_list arglist;
 DWORD dwWritten;

    va_start(arglist, Format);
    dwWritten = wvsprintfA ((LPSTR)szBuffer, Format, arglist);
    WriteFile (g_hLogFile, szBuffer, dwWritten, &dwWritten, NULL);
#ifdef DEBUG
    OutputDebugStringA ((LPSTR)szBuffer);
#endif //DEBUG
}



void logW (LPWSTR Format, ...)
{
 va_list arglist;
 DWORD dwWritten;

    va_start(arglist, Format);
    dwWritten = sizeof(WCHAR) * wvsprintfW (szBuffer, Format, arglist);
    WriteFile (g_hLogFile, szBuffer, dwWritten, &dwWritten, NULL);
#ifdef DEBUG
    OutputDebugStringW (szBuffer);
#endif //DEBUG
}


void CloseLogA ()
{
 char szDirectory[MAX_PATH];
 int iLength;

    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CloseHandle (g_hLogFile);

        iLength = GetWindowsDirectoryA (szDirectory, sizeof (szDirectory));
        if (3 > iLength)
        {
            // Most likely there's some error
            // and iLength is 0;
            // the smallest path would be something
            // like  C:\;
            return;
        }
        if (3 < iLength)
        {
            // this means that the path
            // will not end in a \, so
            // let's add it.
            szDirectory[iLength++] = '\\';
        }
        lstrcpyA (szDirectory+iLength, "MDMUPGLG");

        if (CreateDirectory (szDirectory, NULL) ||
            ERROR_ALREADY_EXISTS == GetLastError ())
        {
            iLength += 8;
        }

        lstrcpyA(szDirectory+iLength, (LPSTR)g_szLogFileName);
        CopyFileA ((LPSTR)g_szLogFileFullName, szDirectory, FALSE);
    }
}


void CloseLogW ()
{
 WCHAR szDirectory[MAX_PATH];
 int iLength;

    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CloseHandle (g_hLogFile);

        iLength = GetWindowsDirectoryW (szDirectory, sizeof (szDirectory) / sizeof(WCHAR));
        if (3 > iLength)
        {
            // Most likely there's some error
            // and iLength is 0;
            // the smallest path would be something
            // like  C:\;
            return;
        }
        if (3 < iLength)
        {
            // this means that the path
            // will not end in a \, so
            // let's add it.
            szDirectory[iLength++] = '\\';
        }
        lstrcpyW (szDirectory+iLength, L"MDMUPGLG");

        if (CreateDirectoryW (szDirectory, NULL) ||
            ERROR_ALREADY_EXISTS == GetLastError ())
        {
            iLength += 8;
        }

        lstrcpyW (szDirectory+iLength, g_szLogFileName);
        CopyFileW (g_szLogFileFullName, szDirectory, FALSE);
    }
}

#endif DO_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\log.h ===
#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif

#ifdef DEBUG
#define DO_LOG
#else
//#undef DO_LOG
#define DO_LOG
#endif //DEBUG

#ifdef DO_LOG
extern HANDLE g_hLogFile;
extern BOOL   bUnicode;

void StartLogA (LPCSTR szPath);
void StartLogW (LPCWSTR szPath);
void logA (LPSTR Format, ...);
void logW (LPWSTR Format, ...);
void CloseLogA ();
void CloseLogW ();

#define DECLARE(a,b) a b
#define SET(a) a =
#define ERR(a,b,c) \
    if (a != b) \
    c


#define CLOSE_LOG          \
    if (FALSE == bUnicode) \
    {                      \
        CloseLogA ();      \
    }                      \
    else                   \
    {                      \
        CloseLogW ();      \
    }


#ifdef WIN9x
#define LOG         logA
#define START_LOG   StartLogA
#define ELSE_LOG(x) \
    else            \
    {               \
        logA x;     \
    }

#else //NT
#define LOG         logA
#define START_LOG   StartLogW
#define ELSE_LOG(x) \
    else            \
    {               \
        logA x;     \
    }

#endif WIN9x

#else  //not DO_LOG
#pragma warning (disable:4002)

#define DECLARE(a,b)
#define SET(a)
#define ERR(a,b,c)
#define ELSE_LOG(x)
#define CLOSE_LOG
#define MSGBEEP(x)
#define MSG(x)
#define LOG()
#define START_LOG
#endif //DO_LOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\modem.h ===
#include <modemp.h>

#define MAX_DIST_RINGS  6
#define MAX_CODE_BUF    8

#define PROVIDER_FILE_NAME_LEN          14  // Provider's file name has the DOS
                                            // form (8.3)

typedef struct
{
    DWORD dwPattern;
    DWORD dwMediaType;
} DIST_RING, FAR * PDIST_RING;

typedef struct
{
    DWORD   cbSize;
    DWORD   dwFlags;

    DIST_RING   DistRing[MAX_DIST_RINGS];

    char    szActivationCode[MAX_CODE_BUF];
    char    szDeactivationCode[MAX_CODE_BUF];
} VOICEFEATURES;

typedef struct _MODEM
{
    //Global information
    DWORD dwMask;

    // Modem Identification
    DWORD dwBusType;        // Bus type (e.g. serenum, root)
    char szHardwareID[REGSTR_MAX_VALUE_LENGTH];
    char szPort[REGSTR_MAX_VALUE_LENGTH];   // Only for root devices
    REGDEVCAPS Properties;  // Modem's capabilities

    // Modem properties
    REGDEVSETTINGS devSettings;
    DCB  dcb;
    char szUserInit[REGSTR_MAX_VALUE_LENGTH];
    char bLogging;
    char Filler[3];

    DWORD dwBaseAddress;
} MODEM, *PMODEM;


typedef struct _TAPI_SERVICE_PROVIDER
{
    DWORD   dwProviderID;
    char    szProviderName[PROVIDER_FILE_NAME_LEN];
}TAPI_SERVICE_PROVIDER, *PTAPI_SERVICE_PROVIDER;


/*
    These are mandatory, no need
    for flags

#define MASK_BUS_TYPE       0x001
#define MASK_HARDWARE_ID    0x002
#define MASK_FRIENDLY_NAME  0x004
#define MASK_DEV_CAPS       0x008
#define MASK_DEV_SETTINGS   0x010
#define MASK_DCB            0x020
*/
#define MASK_PORT           0x001
#define MASK_USER_INIT      0x002
#define MASK_LOGGING        0x004


#define FLAG_INSTALL        0x10000000
#define FLAG_PROCESSED      0x80000000


#define REGKEY_PROVIDERS        "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers"
#define REGVAL_PROVIDERFILENAME "ProviderFileName"
#define REGVAL_PROVIDERID       "ProviderID"
#define TSP3216l                "TSP3216l.TSP"

#define REGVAL_NUMPROVIDERS             "NumProviders"
#define REGVAL_NEXTPROVIDERID           "NextProviderID"
#define REGVAL_PROVIDERFILENAME         "ProviderFileName"
#define REGVAL_PROVIDERID               "ProviderID"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\nt5.c ===
#define UNICODE
#include "common.h"
#include <setupapi.h>
#include <cfgmgr32.h>
#include <unimodem.h>

#include <objbase.h>
#include <initguid.h>
#include <devguid.h>

#include "modem.h"


//#define NUM_DEFAULT_PROVIDERS           (sizeof(ProviderList)/sizeof(ProviderList[0]))

#define DEFAULT_CALL_SETUP_FAIL_TIMEOUT     60          // seconds


WCHAR g_pszWorkingDir[MAX_PATH];

void MigrateTapiProviders (void);
static void ProcessModems (HDEVINFO, PMODEM, DWORD);
void InstallModems (HDEVINFO, PMODEM, DWORD);
void InstallModem (HDEVINFO, PMODEM);
DWORD PassOne (HDEVINFO, PMODEM, DWORD);
DWORD PassTwo (HDEVINFO, PMODEM, DWORD);
DWORD PassThree (HDEVINFO, PMODEM, DWORD);
static void ProcessModem (HDEVINFO, PSP_DEVINFO_DATA, PMODEM);
DWORD GetBusType (HDEVINFO, PSP_DEVINFO_DATA);

Ports g_ntports;

typedef void (*PCOUNTRYRUNONCE)();

LONG
CALLBACK
InitializeNT (
    IN LPCWSTR WorkingDirectory,
    IN LPCWSTR SourceDirectory,
       LPVOID  Reserved)
{
 int iLen;

    START_LOG(WorkingDirectory);
    LOG("InitializeNT\r\n");

    ZeroMemory (g_pszWorkingDir, sizeof(g_pszWorkingDir));
    lstrcpyW (g_pszWorkingDir, WorkingDirectory);
    iLen = lstrlen (g_pszWorkingDir);
    if (L'\\' != g_pszWorkingDir[iLen-1])
    {
        g_pszWorkingDir[iLen] = L'\\';
    }

    return ERROR_SUCCESS;
}



LONG
CALLBACK
MigrateUserNT (
    IN HINF    UnattendInfHandle,
    IN HKEY    UserRegHandle,
    IN LPCWSTR UserName,
       LPVOID  Reserved)
{
    LOG("MigrateUserNT\r\n");
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT (
    IN HINF    UnattendInfHandle,
       LPVOID  Reserved)
{
 HDEVINFO hdi;
 HANDLE   hFile;
 HANDLE   hMapping;
 WCHAR    szFile[MAX_PATH];
 PMODEM   pModem;
 DWORD    dwSize;
 TCHAR    szLib[MAX_PATH];
 PCOUNTRYRUNONCE pCountry;
 HINSTANCE hInst = NULL;

    LOG("Entering MigrateSystemNT\r\n");

    // Get Ports

    ZeroMemory(&g_ntports,sizeof(g_ntports));
    EnumeratePorts(&g_ntports);

    MigrateTapiProviders ();

    hdi = SetupDiGetClassDevs (g_pguidModem, NULL, NULL, DIGCF_PRESENT);
    if (INVALID_HANDLE_VALUE != hdi)
    {
        lstrcpyW (szFile, g_pszWorkingDir);
        lstrcatW (szFile, L"MM");
        hFile = CreateFileW (szFile,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            dwSize = GetFileSize (hFile, NULL);
            if (0xFFFFFFFF != dwSize)
            {
                LOG(" File size: %d, MODEM size: %d, Nr of entries: %d, odd bytes: %d\r\n",
                    dwSize, sizeof (MODEM), dwSize/sizeof(MODEM), dwSize%sizeof(MODEM));
                hMapping = CreateFileMapping (hFile,
                                              NULL,
                                              PAGE_READWRITE,
                                              0, 0,
                                              NULL);
                if (NULL != hMapping)
                {
                    pModem = (PMODEM)MapViewOfFileEx (hMapping,
                                                      FILE_MAP_ALL_ACCESS,
                                                      0, 0, 0,
                                                      NULL);
                    if (NULL != pModem)
                    {
                        ProcessModems (hdi, pModem, dwSize / sizeof (MODEM));
                        UnmapViewOfFile (pModem);
                    }
                    ELSE_LOG(("  MapViewOfFileEx failed: %#lx\r\n", GetLastError ()));

                    CloseHandle (hMapping);
                }
                ELSE_LOG(("  CreateFileMapping failed: %#lx\r\n", GetLastError ()));

                CloseHandle (hFile);

            }
            ELSE_LOG(("  GetFileSize failed: %#lx\r\n", GetLastError ()));
        }
        ELSE_LOG(("  CreateFile (%s) failed: %#lx\r\n", szFile, GetLastError ()));
        SetupDiDestroyDeviceInfoList (hdi);
    }
    ELSE_LOG(("  SetupDiGetClassDevs failed: %#lx\r\n", GetLastError ()));

    LOG("Exiting MigrateSystemNT\r\n");

    GetSystemDirectory(szLib,sizeof(szLib) / sizeof(TCHAR));
    lstrcat(szLib,TEXT("\\modemui.dll"));
    hInst = LoadLibrary(szLib);
    if (hInst != NULL)
    {
        pCountry = (PCOUNTRYRUNONCE)GetProcAddress(hInst,"CountryRunOnce");
        if (pCountry != NULL)
        {
            pCountry();
        }

        FreeLibrary(hInst);
    }

    return ERROR_SUCCESS;
}


void
ProcessModems (
    IN HDEVINFO hdi,
    IN PMODEM   pModem,
    IN DWORD    dwCount)
{
 DWORD dwRemaining = dwCount;

    LOG("Entering ProcessModems\r\n");

    InstallModems (hdi, pModem, dwCount);

    if (0 < dwRemaining)
    {
        dwRemaining = PassOne (hdi, pModem, dwCount);
    }

    if (0 < dwRemaining)
    {
        dwRemaining = PassTwo (hdi, pModem, dwCount);
    }

    if (0 < dwRemaining)
    {
        dwRemaining = PassThree (hdi, pModem, dwCount);
    }

    LOG("Exiting ProcessModems\r\n");
}


void InstallModems (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD i;
     DWORD dwBaseAddress;
     CHAR port[MAX_PORT_NAME_LENGTH];

    for (i = 0; i < dwCount; i++, pModem++)
    {
        if (pModem->dwMask & FLAG_INSTALL)
        {
            if (pModem->dwBaseAddress != 0)
            {
                if (port_findname(g_ntports, pModem->dwBaseAddress, port))
                {
                    lstrcpyA(pModem->szPort,port);
                }
            }

            InstallModem (hdi, pModem);
        }
    }
}


void ProcessModem (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pDevInfoData,
    IN PMODEM pModem)
{
 HKEY hkeyDrv;
 REGDEVCAPS regDevCaps;
 REGDEVSETTINGS regDevSettings;
 DWORD cbData;
 DECLARE(DWORD,dwRet);

    LOG("Entering ProcessModem\r\n");

    pModem->dwMask |= FLAG_PROCESSED;

    hkeyDrv = SetupDiOpenDevRegKey (hdi, pDevInfoData,
        DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ | KEY_WRITE);
    if (INVALID_HANDLE_VALUE != hkeyDrv)
    {
        SET(dwRet)
        RegSetValueExA (hkeyDrv, "UserInit", 0, REG_SZ, (LPBYTE)pModem->szUserInit,
                        lstrlenA (pModem->szUserInit)+1);
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (UserInit) failed: %#lx\r\n", dwRet)));

        if (0 != pModem->bLogging)
        {
         char szPath[MAX_PATH];
         int iLength;

            // Set the path of the modem log
            iLength = GetWindowsDirectoryA (szPath, MAX_PATH);
            if (3 > iLength)
            {
                pModem->bLogging = 0;
                goto _SkipLoggingPath;
            }
            if (3 < iLength)
            {
                // this means that the path
                // will not end in a \, so
                // let's add it.
                szPath[iLength++] = '\\';
            }
            lstrcpyA (szPath+iLength, "ModemLog_");
            iLength += 9;
            if (!SetupDiGetDeviceRegistryPropertyA (hdi, pDevInfoData, SPDRP_FRIENDLYNAME,
                  NULL, (PBYTE)(szPath+iLength), sizeof(szPath)-iLength-1, NULL))
            {
                pModem->bLogging = 0;
                goto _SkipLoggingPath;
            }
            lstrcatA (szPath,".txt");
            SET(dwRet)
            RegSetValueExA (hkeyDrv, "LoggingPath", 0, REG_SZ,
                            (LPBYTE)szPath, lstrlenA (szPath)+1);
            ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (LoggingPath) failed: %#lx\r\n", dwRet)));
        }

    _SkipLoggingPath:
        SET(dwRet)
        RegSetValueExA (hkeyDrv, "Logging", 0, REG_BINARY, (LPBYTE)&pModem->bLogging, sizeof(char));
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (Logging) failed: %#lx\r\n", dwRet)));

        SET(dwRet)
        RegSetValueExW (hkeyDrv, L"DCB", 0, REG_BINARY,
                        (LPBYTE)&pModem->dcb, sizeof (pModem->dcb));
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (DCB) failed: %#lx\r\n", dwRet)));

		// Get the new regDevCaps and regDevSettings so we can migrate intelligently
        cbData = sizeof (regDevCaps);
        dwRet = RegQueryValueExA (hkeyDrv,"Properties",NULL,NULL,(PBYTE)&regDevCaps,&cbData);
        if (ERROR_SUCCESS == dwRet)
        {
			cbData = sizeof (regDevSettings);
			dwRet = RegQueryValueExA (hkeyDrv,"Default",NULL,NULL,(PBYTE)&regDevSettings,&cbData);
			if (ERROR_SUCCESS == dwRet)
			{
				DWORD dwMigrateMask;

				// dwCallSetupFailTimer
				if (!(regDevCaps.dwCallSetupFailTimer && pModem->Properties.dwCallSetupFailTimer))
				{
					pModem->devSettings.dwCallSetupFailTimer = 	regDevSettings.dwCallSetupFailTimer;
				}

				// dwInactivityTimeout
				if (!(regDevCaps.dwInactivityTimeout && pModem->Properties.dwInactivityTimeout))
				{
					pModem->devSettings.dwInactivityTimeout = 	regDevSettings.dwInactivityTimeout;
				}

				// dwSpeakerVolume
				if (!(regDevCaps.dwSpeakerVolume & pModem->devSettings.dwSpeakerVolume))
				{
					pModem->devSettings.dwSpeakerVolume =   regDevSettings.dwSpeakerVolume;
				}

				// dwSpeakerMode
				if (!(regDevCaps.dwSpeakerMode & pModem->devSettings.dwSpeakerMode))
				{
					pModem->devSettings.dwSpeakerMode =   regDevSettings.dwSpeakerMode;
				}

				// dwPreferredModemOptions
				dwMigrateMask = regDevCaps.dwModemOptions & pModem->Properties.dwModemOptions;
				
				pModem->devSettings.dwPreferredModemOptions =
					(regDevSettings.dwPreferredModemOptions & ~dwMigrateMask) |
					(pModem->devSettings.dwPreferredModemOptions & dwMigrateMask);
			}
			ELSE_LOG(("  RegQueryValueExA (Default) failed: %#lx\r\n", dwRet));
        }
		ELSE_LOG(("  RegQueryValueExA (Properties) failed: %#lx\r\n", dwRet));

        SET(dwRet)
        RegSetValueExW (hkeyDrv, L"Default", 0, REG_BINARY,
                        (LPBYTE)&pModem->devSettings, sizeof (pModem->devSettings));
        ERR(dwRet, ERROR_SUCCESS, (LOG(" ResSetValue (Default) failed: %#lx\r\n", dwRet)));

        RegCloseKey (hkeyDrv);
    }
    ELSE_LOG(("  SetupDiOpenDevRegKey (DIREG_DRV) failed: %#lx\r\n", GetLastError ()));

    SetupDiDeleteDeviceInfo (hdi, pDevInfoData);

    LOG("Exiting ProcessModem\r\n");
}


DWORD PassOne (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD iIndex;
 SP_DEVINFO_DATA  devInfoData = {sizeof (devInfoData), 0};
 DWORD i, cbData;
 char szHardwareID[REGSTR_MAX_VALUE_LENGTH];
 char szPort[REGSTR_MAX_VALUE_LENGTH];
 HKEY hKeyDrv;
 PMODEM pMdmTmp;
 DWORD dwRemaining = dwCount;
 DWORD dwBusType, dwRet;

    // PASS 1: we're looking at the bus type,
    // hardware ID and port name
    LOG("Enumerating installed modems - Pass 1:\r\n");
    for (iIndex = 0;
         SetupDiEnumDeviceInfo (hdi, iIndex, &devInfoData);
         iIndex++)
    {
        // First, get the bus type
        dwBusType = GetBusType (hdi, &devInfoData);

        // Then, get the hardware ID
        if (!SetupDiGetDeviceRegistryPropertyA (hdi, &devInfoData, SPDRP_HARDWAREID,
                NULL, (PBYTE)szHardwareID, sizeof (szHardwareID), NULL))
        {
            LOG("  SetupDiGetDeviceRegistryProperty(SPDRP_HARDWAREID) failed: %#lx\r\n", GetLastError ());
            // If we couldn't get the hardware ID,
            // there's nothing to do with this modem.
            continue;
        }

        // Third, open the driver key and get the port name.
        if (BUS_TYPE_ROOT    == dwBusType ||
            BUS_TYPE_SERENUM == dwBusType)
        {
            hKeyDrv = SetupDiOpenDevRegKey (hdi, &devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
            if (INVALID_HANDLE_VALUE == hKeyDrv)
            {
                LOG("  SetupDiOpenDevRegKey failed: %#lx\r\n", GetLastError ());
                // If we couldn't open the driver key,
                // there's nothing to do with this modem.
                continue;
            }

            cbData = sizeof (szPort);
            szPort[0] = 0;
            dwRet = RegQueryValueExA (hKeyDrv,"AttachedTo",NULL,NULL,(PBYTE)szPort,&cbData);
            RegCloseKey (hKeyDrv);

            if (ERROR_SUCCESS != dwRet)
            {
                // We could not get the port
                LOG("  Could not read the port name: %#lx.\r\n", dwRet);
                continue;
            }
        }

        // Now, we have all the info needed to identify
        // the modem in phase 1.
        for (i = 0, pMdmTmp = pModem;
             i < dwCount;
             i++, pMdmTmp++)
        {
            if ( (0 == (pMdmTmp->dwMask & FLAG_PROCESSED))             &&   // Modem record has not been processed yet
                 (dwBusType == pMdmTmp->dwBusType)                     &&   // Same bus type
                 (0 == lstrcmpA (szHardwareID, pMdmTmp->szHardwareID)) &&   // Same hardware ID
                 ( (0 == (pMdmTmp->dwMask & MASK_PORT))     ||              // Same port
                   (0 == lstrcmpA (szPort, pMdmTmp->szPort))  ) )
            {
                ProcessModem (hdi, &devInfoData, pMdmTmp);
                dwRemaining--;
                iIndex--;   // Process modem will remove the current
                            // devinfo data from the set.
                break;
            }
        }
    }
    LOG("  SetupDiEnumDeviceInfo failed (%#lx) for index %d\r\n", GetLastError (), iIndex);

    return dwRemaining;
}


DWORD PassTwo (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD iIndex;
 SP_DEVINFO_DATA  devInfoData = {sizeof (devInfoData), 0};
 DWORD i;
 char szHardwareID[REGSTR_MAX_VALUE_LENGTH];
 PMODEM pMdmTmp;
 DWORD dwRemaining = dwCount;
 DWORD dwBusType;

    // PASS 2: we're looking at the bus type
    // and hardware ID only
    LOG("Enumerating installed modems - Pass 2:\r\n");
    for (iIndex = 0;
         SetupDiEnumDeviceInfo (hdi, iIndex, &devInfoData);
         iIndex++)
    {
        // First, get the bus type
        dwBusType = GetBusType (hdi, &devInfoData);

        // Then, get the hardware ID
        if (!SetupDiGetDeviceRegistryPropertyA (hdi, &devInfoData, SPDRP_HARDWAREID,
                NULL, (PBYTE)szHardwareID, sizeof (szHardwareID), NULL))
        {
            LOG("  SetupDiGetDeviceRegistryProperty(SPDRP_HARDWAREID) failed: %#lx\r\n", GetLastError ());
            // If we couldn't get the hardware ID,
            // there's nothing to do with this modem.
            continue;
        }

        // Now, we have all the info needed to identify
        // the modem in phase 2.
        for (i = 0, pMdmTmp = pModem;
             i < dwCount;
             i++, pMdmTmp++)
        {
            if ( (0 == (pMdmTmp->dwMask & FLAG_PROCESSED))             &&   // Modem record has not been processed yet
                 (dwBusType == pMdmTmp->dwBusType)                     &&   // Same bus type
                 (0 == lstrcmpA (szHardwareID, pMdmTmp->szHardwareID)) )    // Same hardware ID
            {
                ProcessModem (hdi, &devInfoData, pMdmTmp);
                dwRemaining--;
                iIndex--;   // Process modem will remove the current
                            // devinfo data from the set.
                break;
            }
        }
    }
    LOG("  SetupDiEnumDeviceInfo failed (%#lx) for index %d\r\n", GetLastError (), iIndex);

    return dwRemaining;
}


DWORD PassThree (HDEVINFO hdi, PMODEM pModem, DWORD dwCount)
{
 DWORD iIndex;
 SP_DEVINFO_DATA  devInfoData = {sizeof (devInfoData), 0};
 DWORD i, cbData;
 REGDEVCAPS regDevCaps;
 HKEY hKeyDrv;
 PMODEM pMdmTmp;
 DWORD dwRemaining = dwCount;
 DWORD dwBusType, dwRet;

    // PASS 3: we're looking at the bus type,
    // and REGDEVCAPS
    LOG("Enumerating installed modems - Pass 1:\r\n");
    for (iIndex = 0;
         SetupDiEnumDeviceInfo (hdi, iIndex, &devInfoData);
         iIndex++)
    {
        // First, get the bus type
        dwBusType = GetBusType (hdi, &devInfoData);

        // Then, open the driver key and get the REGDEVCAPS.
        hKeyDrv = SetupDiOpenDevRegKey (hdi, &devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
        if (INVALID_HANDLE_VALUE == hKeyDrv)
        {
            LOG("  SetupDiOpenDevRegKey failed: %#lx\r\n", GetLastError ());
            // If we couldn't open the driver key,
            // there's nothing to do with this modem.
            continue;
        }

        cbData = sizeof (regDevCaps);
        dwRet = RegQueryValueExA (hKeyDrv,"Properties",NULL,NULL,(PBYTE)&regDevCaps,&cbData);
        RegCloseKey (hKeyDrv);
        if (ERROR_SUCCESS != dwRet)
        {
            // We could not get the port
            LOG("  Could not read the REGDEVCAPS.\r\n");
            continue;
        }

        // Now, we have all the info needed to identify
        // the modem in phase 3.
        for (i = 0, pMdmTmp = pModem;
             i < dwCount;
             i++, pMdmTmp++)
        {
            if ( (0 == (pMdmTmp->dwMask & FLAG_PROCESSED))             &&   // Modem record has not been processed yet
                 (dwBusType == pMdmTmp->dwBusType)                     &&   // Same bus type
                 (0 == memcmp (&regDevCaps, &pMdmTmp->Properties, sizeof(REGDEVCAPS))) )    // Same REGDEVCAPS
            {
                ProcessModem (hdi, &devInfoData, pMdmTmp);
                dwRemaining--;
                iIndex--;   // Process modem will remove the current
                            // devinfo data from the set.
                break;
            }
        }
    }
    LOG("  SetupDiEnumDeviceInfo failed (%#lx) for index %d\r\n", GetLastError (), iIndex);

    return dwRemaining;
}


void InstallModem (HDEVINFO hDI, PMODEM pModem)
{
 SP_DEVINFO_DATA        devInfo = {sizeof(SP_DEVINFO_DATA),0};
 SP_DEVINSTALL_PARAMS   devInstParams = {sizeof(SP_DEVINSTALL_PARAMS), 0};
 SP_DRVINFO_DATA        drvDataEnum = {sizeof(SP_DRVINFO_DATA),0};
 SP_DRVINSTALL_PARAMS   drvParams = {sizeof(SP_DRVINSTALL_PARAMS),0};
 DWORD                  dwIndex = 0;
 UM_INSTALL_WIZARD      miw = {sizeof(UM_INSTALL_WIZARD), 0};
 SP_INSTALLWIZARD_DATA  iwd;
 BOOL                   bRet;

    LOG("Entering InstallModem\r\n");

    // First, create a Device Info Element
    if (!SetupDiCreateDeviceInfoW (hDI, L"MODEM", (LPGUID)&GUID_DEVCLASS_MODEM,
                                   NULL, NULL, DICD_GENERATE_ID, &devInfo))
    {
        LOG("SetupDiCreateDeviceInfo failed (%#lx).\r\n", GetLastError ());
        goto _Ret;
    }

    // Now, set the hardware ID property;
    // this is used by setup API to look for the
    // correct driver for the modem
    LOG("SetupDiSetDeviceRegistryProperty (%s)\n",pModem->szHardwareID);
    if (!SetupDiSetDeviceRegistryPropertyA (hDI, &devInfo, SPDRP_HARDWAREID,
                                            (PBYTE)pModem->szHardwareID,
                                            (lstrlenA(pModem->szHardwareID)+2)))
    {
        LOG("SetupDiSetDeviceRegistryProperty failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    // Tell Setup to only look for drivers
    // for our class
    if (!SetupDiGetDeviceInstallParams (hDI, &devInfo, &devInstParams))
    {
        LOG("SetupDiGetDeviceInstallParams failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }
    devInstParams.FlagsEx |= DI_FLAGSEX_USECLASSFORCOMPAT;
    devInstParams.Flags   |= DI_QUIETINSTALL;

    if (!SetupDiSetDeviceInstallParams (hDI, &devInfo, &devInstParams))
    {
        LOG("SetupDiSetDeviceInstallParams failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    // Now, build the driver list
    if (!SetupDiBuildDriverInfoList (hDI, &devInfo, SPDIT_COMPATDRIVER))
    {
        LOG("SetupDiBuildDriverInfoList failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    // Now, the driver list is built,
    // select the rank0 driver
    while (bRet =
           SetupDiEnumDriverInfo (hDI, &devInfo, SPDIT_COMPATDRIVER, dwIndex++, &drvDataEnum))
    {
        if (SetupDiGetDriverInstallParams (hDI, &devInfo, &drvDataEnum, &drvParams) &&
            0 == drvParams.Rank)
        {
            // Set the first Rank0 driver as the selected driver
            bRet = SetupDiSetSelectedDriver(hDI, &devInfo, &drvDataEnum);
            break;
        }
    }

    if (!bRet)
    {
        LOG("Could not select a driver!\r\n");
        goto _ErrRet;
    }

    // We selected the proper driver;
    // This to set up the installwizard structures
    miw.InstallParams.Flags = MIPF_DRIVER_SELECTED;
    if (0 ==
        MultiByteToWideChar (CP_ACP, 0, pModem->szPort, -1, miw.InstallParams.szPort, UM_MAX_BUF_SHORT))
    {
        LOG("MultiByteToWideChar failed (%#lx).\r\n", GetLastError ());
        goto _ErrRet;
    }

    ZeroMemory(&iwd, sizeof(iwd));
    iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
    iwd.hwndWizardDlg = NULL;
    iwd.PrivateData = (LPARAM)&miw;

   if (SetupDiSetClassInstallParams (hDI, &devInfo, (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
   {
      // Call the class installer to invoke the installation
      // wizard.
      if (SetupDiCallClassInstaller (DIF_INSTALLWIZARD, hDI, &devInfo))
      {
         // Success.  The wizard was invoked and finished.
         // Now cleanup.
         SetupDiCallClassInstaller (DIF_DESTROYWIZARDDATA, hDI, &devInfo);
         goto _Ret;
      }
      ELSE_LOG(("SetupDiCallClassInstaller failed (%#lx).\r\n", GetLastError ()));
   }
   ELSE_LOG(("SetupDiSetClassInstallParams failed (%#lx).\r\n", GetLastError ()));

_ErrRet:

    SetupDiDeleteDeviceInfo (hDI, &devInfo);

_Ret:
    LOG("Exiting InstallModem\r\n");
}


static HANDLE OpenProvidersFile (void)
{
 HANDLE hFile;
 WCHAR  szFile[MAX_PATH] = L"";

    lstrcpy (szFile, g_pszWorkingDir);
    lstrcat (szFile, L"TP");

    hFile = CreateFile (szFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

#ifdef DO_LOG
    if (INVALID_HANDLE_VALUE == hFile)
    {
        LOG(" Could not open %s: %#lx\r\n", szFile, GetLastError());
    }
#endif //DO_LOG

    return hFile;
}

void
MigrateTapiProviders (void)
{
 HANDLE hFile;
 DWORD dwNumProviders = 0;
 DWORD dwNextProviderID = 1;
 HKEY  hKeyProviders = INVALID_HANDLE_VALUE;
 DWORD cbData;
 char  szProviderFileName[24];  // Enough to hold "ProviderFileNameXXXXX\0"
 char  szProviderID[16];        // Enough to hold "ProviderIDxxxxx\0"
 char  *pProviderFileNameNumber, *pProviderIDNumber;
 TAPI_SERVICE_PROVIDER Provider;

    LOG("Entering MigrateTapiProviders\r\n");

    // First, try to open the Tapi file.
    hFile = OpenProvidersFile ();
    if (INVALID_HANDLE_VALUE == hFile)
    {
        goto _Return;
    }

    // Next, open the Providers key.
    if (ERROR_SUCCESS !=
        RegOpenKeyExA (HKEY_LOCAL_MACHINE, REGKEY_PROVIDERS, 0,
                       KEY_ALL_ACCESS, &hKeyProviders))
    {

        LOG("RegOpenKeyEx (providers...) failed!\r\n");
        goto _Return;
    }

    // Now, read the number of providers, and the next provider ID
    cbData = sizeof (dwNumProviders);
    if (ERROR_SUCCESS !=
        RegQueryValueExA (hKeyProviders, REGVAL_NUMPROVIDERS, NULL, NULL, (PVOID)&dwNumProviders, &cbData))
    {
        goto _Return;
    }
    LOG("There are %d providers\r\n", dwNumProviders);
    cbData = sizeof (dwNextProviderID);
    if (ERROR_SUCCESS !=
        RegQueryValueExA (hKeyProviders, REGVAL_NEXTPROVIDERID, NULL, NULL, (PVOID)&dwNextProviderID, &cbData))
    {
        goto _Return;
    }
    LOG("NextProviderID: %d\r\n", dwNextProviderID);

    // Initialize value names and pointers
    lstrcpyA (szProviderFileName, REGVAL_PROVIDERFILENAME);
    lstrcpyA (szProviderID, REGVAL_PROVIDERID);
    pProviderFileNameNumber = szProviderFileName + lstrlenA (szProviderFileName);
    pProviderIDNumber = szProviderID + lstrlenA (szProviderID);


    // Now, add all the providers again. We do this because the
    // IDs were REG_BINARY on win98 and have to be REG_DWORD on NT5.
    while (TRUE)
    {
        if (0 == ReadFile (hFile, (PVOID)&Provider, sizeof(Provider), &cbData, NULL) ||
            sizeof(Provider) != cbData)
        {
            // Some error reading the file or
            // (more likely), end of file.
            break;
        }
        LOG("Read %s, %d\r\n", Provider.szProviderName, Provider.dwProviderID);

        // We have a 32 bit provider from win98 - install it.
        wsprintfA (pProviderFileNameNumber, "%d", dwNumProviders);
        lstrcpyA (pProviderIDNumber, pProviderFileNameNumber);
        if (ERROR_SUCCESS ==
            RegSetValueExA (hKeyProviders, szProviderFileName, 0, REG_SZ,
                            (PBYTE)Provider.szProviderName,
                            lstrlenA(Provider.szProviderName)+1))
        {
            if (ERROR_SUCCESS ==
                RegSetValueExA (hKeyProviders, szProviderID, 0, REG_DWORD,
                               (PBYTE)&Provider.dwProviderID,
                               sizeof(Provider.dwProviderID)))
            {
                dwNumProviders++;
                if (Provider.dwProviderID >= dwNextProviderID)
                {
                    dwNextProviderID = Provider.dwProviderID+1;
                }
            }
            else
            {
                RegDeleteValueA (hKeyProviders, szProviderFileName);
            }
        }
    }

    // Finally, update NumProviders and NextProviderID.
    RegSetValueExA (hKeyProviders, REGVAL_NUMPROVIDERS, 0, REG_DWORD,
                    (PBYTE)&dwNumProviders, sizeof(dwNumProviders));
    RegSetValueExA (hKeyProviders, REGVAL_NEXTPROVIDERID, 0, REG_DWORD,
                    (PBYTE)&dwNextProviderID, sizeof(dwNextProviderID));

_Return:
    if (INVALID_HANDLE_VALUE != hKeyProviders)
    {
        RegCloseKey (hKeyProviders);
    }

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle (hFile);
    }

    LOG("Exiting MigrateTapiProviders\r\n");
}



#include <initguid.h>
#include <wdmguid.h>

DWORD GetBusType (
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData)
{
 DWORD dwRet = BUS_TYPE_OTHER;
 ULONG ulStatus, ulProblem = 0;

    if (CR_SUCCESS == CM_Get_DevInst_Status (&ulStatus, &ulProblem, pdevData->DevInst, 0) &&
        (ulStatus & DN_ROOT_ENUMERATED))
    {
        dwRet = BUS_TYPE_ROOT;
    }
    else
    {
     GUID guid;
        // either CM_Get_DevInst_Status failed, which means that the device
        // is plug & play and not present (i.e. plugged out),
        // or the device is not root-enumerated;
        // either way, it's a plug & play device.

        // If the next call fails, it means that the device is
        // BIOS / firmware enumerated; this is OK - we just return BUT_TYPE_OTHER
        if (SetupDiGetDeviceRegistryProperty (hdi, pdevData, SPDRP_BUSTYPEGUID, NULL,
                                              (PBYTE)&guid, sizeof(guid), NULL))
        {
         int i;
         struct
         {
             GUID const *pguid;
             DWORD dwBusType;
         } BusTypes[] = {{&GUID_BUS_TYPE_SERENUM, BUS_TYPE_SERENUM},
                         {&GUID_BUS_TYPE_PCMCIA, BUS_TYPE_PCMCIA},
                         {&GUID_BUS_TYPE_ISAPNP, BUS_TYPE_ISAPNP}};

            for (i = 0;
                 i < sizeof (BusTypes) / sizeof (BusTypes[0]);
                 i ++)
            {
                if (IsEqualGUID (BusTypes[i].pguid, &guid))
                {
                    dwRet = BusTypes[i].dwBusType;
                    break;
                }
            }
        }
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\w95migr\win95.c ===
#define WIN9x
#include "common.h"
#include "modem.h"
#include "msg.h"
#include <miglib.h>


#define MAX_REG_PATH     256
#define MAX_EXE_BUFFER  2048

#define BUS_TYPE_MODEMWAVE 0x80000000

#define PROVIDER_FILE_NAME_LEN          14  // Provider's file name has the DOS
                                            // form (8.3)

#define NULL_MODEM  "PNPC031"

typedef struct
{
    char CompanyName[256];
    char SupportNumber[256];
    char SupportUrl[256];
    char InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

typedef struct
{
    HKEY  hRegKey;
    HKEY  hkClass;
    char  szRegSubkey[MAX_REG_PATH];
    DWORD dwBusType;
    HANDLE h_File;
    MODEM modem;
} REG_DEVICE, *PREG_DEVICE;

typedef void (*PROCESS_MODEM)(PREG_DEVICE, DWORD);


VENDORINFO VendorInfo = {"", "", "", ""};

char g_pszProductID[]="Microsoft Unimodem";
char g_pszWorkingDir[MAX_PATH];
char g_pszSourceDir[MAX_PATH];
char g_pszUnattendFile[MAX_PATH];
char g_szExeBuffer[MAX_EXE_BUFFER];

int iNumModems = 0;

DWORD PnPIDTableCreate ();
void PnPIDTableDestroy (DWORD);
void EnumNextLevel(PREG_DEVICE, int, PROCESS_MODEM, DWORD);
static void ProcessModem (PREG_DEVICE, DWORD);
void WalkRegistry (PROCESS_MODEM, DWORD);
int  GetNumberOfModems (void);
void UpdateAnswerFileAndMigrateInf (
    char *szHardwareID,
    char *szCompatibleIDs,
    HKEY hKeyDrv,
    char *szEnumPath,
    DWORD dwPnPIDTable);
void DoTapiProviders (void);

Ports g_ports;



LONG
CALLBACK
QueryVersion (
    OUT LPCSTR *ppszProductID,
    OUT LPUINT  pDllVerion,
    OUT LPINT  *ppCodePageArray,
    OUT LPCSTR *ppszzExeNamesBuf,
    OUT PVENDORINFO *ppVendorInfo)
{
 OSVERSIONINFO Version;
 HMODULE hModule;

    hModule = GetModuleHandleA ("migrate.dll");
    if (NULL == hModule)
    {
        return GetLastError ();
    }

    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_COMPANY_NAME, 0,
                    VendorInfo.CompanyName, 256,
                    NULL);
    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_SUPPORT_NUMBER, 0,
                    VendorInfo.SupportNumber, 256,
                    NULL);
    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_SUPPORT_URL, 0,
                    VendorInfo.SupportUrl, 256,
                    NULL);
    FormatMessageA (FORMAT_MESSAGE_FROM_HMODULE,
                    hModule,
                    MSG_VI_INSTRUCTIONS, 0,
                    VendorInfo.InstructionsToUser, 1024,
                    NULL);

    *ppszProductID = g_pszProductID;
    *pDllVerion = 1;
    *ppCodePageArray = NULL;
    *ppszzExeNamesBuf = g_szExeBuffer;
    *ppVendorInfo = &VendorInfo;

    return ERROR_SUCCESS;
}



LONG
CALLBACK
Initialize9x (
    IN LPCSTR pszWorkingDirectory,
    IN LPCSTR pszSourceDirectory,
       LPVOID pvReserved)
{
 LONG lRet;
 DWORD dwWritten;
 int iLen;

    // Find com ports

    ZeroMemory(&g_ports, sizeof(g_ports));
    EnumeratePorts(&g_ports);

    ZeroMemory (g_pszWorkingDir, sizeof(g_pszWorkingDir));
    lstrcpyA (g_pszWorkingDir, pszWorkingDirectory);
    iLen = lstrlenA (g_pszWorkingDir);
    if ('\\' != g_pszWorkingDir[iLen-1])
    {
        g_pszWorkingDir[iLen] = '\\';
    }

    ZeroMemory (g_pszSourceDir, sizeof(g_pszSourceDir));
    lstrcpyA (g_pszSourceDir, pszSourceDirectory);
    iLen = lstrlenA (g_pszSourceDir);
    if ('\\' != g_pszSourceDir[iLen-1])
    {
        g_pszSourceDir[iLen] = '\\';
    }

    START_LOG(pszWorkingDirectory);
    LOG ("Initialize9x\r\n");
    LOG (" WorkingDirectory: %s\r\n", pszWorkingDirectory);
    LOG (" SourceDirectory: %s\r\n", pszSourceDirectory);

    iNumModems = GetNumberOfModems ();
    LOG(" Initialize9x found %d modems.\r\n", iNumModems);

    LOG("Exit Initialize9x\r\n");
    return ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateUser9x (
    IN HWND     ParentWnd,
    IN LPCSTR   UnattendFile,
    IN HKEY     UserRegKey,
    IN LPCSTR   UserName,
    LPVOID      Reserved)
{
    //
    // All our settings are system-wide
    //
    LOG("MigrateUser9x\r\n");
    return ERROR_NOT_INSTALLED;
}



LONG
CALLBACK
MigrateSystem9x (
    IN HWND     ParentWnd,
    IN LPCSTR   UnattendFile,
    LPVOID      Reserved)
{
 DWORD PnPIDTable;

    LOG("MigrateSystem9x\r\n");

    lstrcpyA (g_pszUnattendFile, UnattendFile);
    LOG("UnattendFile: %s.\r\n", UnattendFile);

    DoTapiProviders ();

    if (0 < iNumModems)
    {
        PnPIDTable = PnPIDTableCreate ();
        WalkRegistry (ProcessModem, PnPIDTable);
        PnPIDTableDestroy (PnPIDTable);
    }

    return ERROR_SUCCESS;
}



void EnumNextLevel (
    PREG_DEVICE pRegDevice,
    int         Level,
    PROCESS_MODEM pProcessModem,
    DWORD       dwParam)
{
 HKEY            hk = INVALID_HANDLE_VALUE;
 DWORD           rr;
 int             i;
 ULONG           cbData, StrLen;

    LOG("Enter EnumNextLevel - level is %d\r\n", Level);
    LOG("    %s\r\n", pRegDevice->szRegSubkey);
    if (0 == Level)
    {
        pProcessModem (pRegDevice, dwParam);
    }
    else
    {
        if (2 == Level)
        {
         char *p = pRegDevice->szRegSubkey + 5; // past ENUM\
            // Here we should get the info about the bus
            if (0 == lstrcmpiA (p, "MODEMWAVE"))
            {
                pRegDevice->dwBusType = BUS_TYPE_MODEMWAVE;
            }
            else if (0 == lstrcmpiA (p, "ROOT"))
            {
                pRegDevice->dwBusType = BUS_TYPE_ROOT;
            }
            else if (0 == lstrcmpiA (p, "ISAPNP"))
            {
                pRegDevice->dwBusType = BUS_TYPE_ISAPNP;
            }
            else if (0 == lstrcmpiA (p, "PCMCIA"))
            {
                pRegDevice->dwBusType = BUS_TYPE_PCMCIA;
            }
            else if (0 == lstrcmpiA (p, "SERENUM"))
            {
                pRegDevice->dwBusType = BUS_TYPE_SERENUM;
            }
            else if (0 == lstrcmpiA (p, "LPTENUM"))
            {
                pRegDevice->dwBusType = BUS_TYPE_LPTENUM;
            }
            else
            {
                pRegDevice->dwBusType = BUS_TYPE_OTHER;
            }
        }

        StrLen = lstrlenA (pRegDevice->szRegSubkey);
        rr = RegOpenKeyExA (pRegDevice->hRegKey,
                            pRegDevice->szRegSubkey,
                            0, KEY_ALL_ACCESS, &hk);
        for (i = 0; rr == ERROR_SUCCESS; i++)
        {
            pRegDevice->szRegSubkey[StrLen] = '\\';
            cbData = sizeof(pRegDevice->szRegSubkey) - StrLen - 1;
            rr = RegEnumKeyA (hk, i, (LPSTR)&(pRegDevice->szRegSubkey[StrLen+1]),
                              cbData);
            if (rr == ERROR_SUCCESS)
            {
                EnumNextLevel(pRegDevice, Level-1, pProcessModem, dwParam);
            }
        }

        if (INVALID_HANDLE_VALUE != hk)
        {
            RegCloseKey(hk);
        }

        pRegDevice->szRegSubkey[StrLen] = '\0';
    }
    LOG("    %s\r\n", pRegDevice->szRegSubkey);
    LOG("Exiting EnumNextLevel %d\r\n", Level);
}


void ProcessModem (PREG_DEVICE pDevice, DWORD dwPnPIDTable)
{
 HKEY  hk, hkDrv = INVALID_HANDLE_VALUE;
 char  szBuffer[REGSTR_MAX_VALUE_LENGTH];
 ULONG cbData;
 DWORD dwRet, dwWritten;
 BOOL  bVirtualDevNode = FALSE;
 HKEY  hkParentDevNode;
 char  szParentDevNode[REGSTR_MAX_VALUE_LENGTH];
 char  szTemp[1024];

    LOG("Entering ProcessModem\r\n");
    if (BUS_TYPE_MODEMWAVE == pDevice->dwBusType)
    {
        // If this is a modemwave device, all we need to do
        // is tell setup it needn't worry about it - we do this
        // by writing in migrate.inf that we handled this device.
        // We pass NULL for the first two parameters, so that the
        // next call doesn't also update unattend.txt.
        UpdateAnswerFileAndMigrateInf (NULL, NULL, NULL, pDevice->szRegSubkey, 0);
        return;
    }

    if (ERROR_SUCCESS ==
            (dwRet = RegOpenKeyExA (pDevice->hRegKey,
                                    pDevice->szRegSubkey,
                                    0, KEY_ALL_ACCESS, &hk)))
    {
        cbData = sizeof(szBuffer);
        if (ERROR_SUCCESS ==
                (dwRet = RegQueryValueExA (hk, "Class", NULL, NULL, szBuffer, &cbData)))
        {
            if (0 == lstrcmpiA (szBuffer, "Modem"))
            {
             DWORD dwType;
             char *p;

                LOG("Found a modem.\r\n");
                // We found a modem.
                // First, clear the the modem structure
                ZeroMemory (&pDevice->modem, sizeof (pDevice->modem));

                // Now let's store the info we'll use to
                // identify the modem on NT side.

                // First, the bus type
                pDevice->modem.dwBusType = pDevice->dwBusType;

                // Log the friendly name
                cbData = sizeof(pDevice->modem.szHardwareID);
                if (ERROR_SUCCESS == (
                    SET(dwRet)
                    RegQueryValueExA (hk, "FriendlyName", NULL, NULL,
                            pDevice->modem.szHardwareID, &cbData)))
                {
                    LOG("  FriendlyName: %s.\r\n", pDevice->modem.szHardwareID);
                }
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(FriendlyName) failed: %#lx\r\n", dwRet)));

                // Second, get the hardware ID.

				// Check to see if this is a CCPORT child device by looking for a
				// ParentDevNode key. If so, we will need to get the HardwareID from 
				// this parent devnode.

				cbData = sizeof(szBuffer);
				if (ERROR_SUCCESS ==
					(dwRet = RegQueryValueExA (hk, "ParentDevNode", NULL, NULL,
											   szBuffer, &cbData)))
				{
					LOG("  This is a ccport virtual DevNode.\r\n");

					lstrcpyA(szParentDevNode, "Enum\\");
					lstrcatA(szParentDevNode, szBuffer);

                    LOG("  ParentDevNode: %s.\r\n", szParentDevNode);

					if (ERROR_SUCCESS ==
							(dwRet = RegOpenKeyExA (HKEY_LOCAL_MACHINE,
													szParentDevNode,
													0, KEY_ALL_ACCESS, &hkParentDevNode)))
					{
						bVirtualDevNode = TRUE;
					}
					else
					{
						LOG("  RegOpenKeyEx(szParentDevNode) failed: %#lx\r\n", dwRet);
						goto _End;
					}
				}

				cbData = sizeof(pDevice->modem.szHardwareID);
				ZeroMemory (pDevice->modem.szHardwareID, cbData);

				if (bVirtualDevNode)
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hkParentDevNode, "HardwareID", NULL, NULL,
        								  pDevice->modem.szHardwareID, &cbData)))
					{
						LOG("  RegQueryValueEx(hkParentDevNode, szHardwareID) failed: %#lx\r\n", dwRet);
						goto _End;
					}
				}
				else
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hk, "HardwareID", NULL, NULL,
        								  pDevice->modem.szHardwareID, &cbData)))
					{
						LOG("  RegQueryValueEx(hk, szHardwareID) failed: %#lx\r\n", dwRet);
						goto _End;
					}
				}

                LOG("  Hardware ID: %s.\r\n", pDevice->modem.szHardwareID);
                // Now convert the ID from a string (with multiple IDs
                // separated by comma) to a multi_strings
                for (p = pDevice->modem.szHardwareID;
                     0 != *p;
                     p++)
                {
                    if (',' == *p)
                    {
                        *p = 0;
                    }
                }

                // If this is "Communications cable ..."
                // then mark this one for installation on NT5
                // (as it will not be picked up by PnP).
                /* if (0 == lstrcmpiA (pDevice->modem.szHardwareID, NULL_MODEM))
                {
                    pDevice->modem.dwMask |= FLAG_INSTALL;
                }
 */

                // If this is a legacy modem then mark this one for
                // installation as whistler no longer supports
                // legacy detection.

                if (lstrlen(pDevice->modem.szHardwareID) >= 8)
                {
                    lstrcpyA(szTemp,pDevice->modem.szHardwareID);
                    szTemp[8] = '\0';
                    if (0 == lstrcmpiA (szTemp, "UNIMODEM"))
                    {
                        LOG("  Found a legacy modem\n");

                        // Change to unknown modem

                        cbData = sizeof(pDevice->modem.szHardwareID);
                        ZeroMemory(pDevice->modem.szHardwareID, cbData);
                        lstrcpy(pDevice->modem.szHardwareID,"MDMUNK");

                        // Find port address

                        pDevice->modem.dwBaseAddress = 0;
                        if (!port_findaddress(g_ports,&(pDevice->modem.dwBaseAddress),pDevice->modem.szPort))
                        {
                            LOG("Can't find address");
                        }

                        pDevice->modem.dwMask |= FLAG_INSTALL;
                    }
                }

                // At this point, we need to open the
                // driver key.
                cbData = sizeof(szBuffer);
                if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hk, "Driver", NULL, &dwType, szBuffer, &cbData)))
                {
                    LOG("  RegQueryValueEx(Driver) failed: %#lx\r\n", dwRet);
                    goto _End;
                }

				LOG("  Driver: %s.\r\n", szBuffer);

                if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegOpenKeyExA (pDevice->hkClass, szBuffer,
                                   0, KEY_ALL_ACCESS, &hkDrv)))
                {
                    LOG("  Could not open driver's key (%s): %#lx\r\n", szBuffer, dwRet);
                    goto _End;
                }

                // Get the port name (if we have one)
                pDevice->modem.szPort[0] = '\0';
	            cbData = sizeof(pDevice->modem.szPort);

				if (bVirtualDevNode)
				{
					if (ERROR_SUCCESS == (
						SET(dwRet)
						RegQueryValueExA (hk, "AttachedTo", NULL, NULL,
        						pDevice->modem.szPort, &cbData)))
					{
						pDevice->modem.dwMask |= MASK_PORT;
					}
				}
				else
				{
					if (ERROR_SUCCESS == (
						SET(dwRet)
						RegQueryValueExA (hkDrv, "AttachedTo", NULL, NULL,
        						pDevice->modem.szPort, &cbData)))
					{
						pDevice->modem.dwMask |= MASK_PORT;
					}
				}
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(AttachedTo) failed: %#lx\r\n", dwRet)));

                // Finally, we can get the REGDEVCAPS.
	            cbData = sizeof(pDevice->modem.Properties);
		        if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hkDrv, "Properties", NULL, NULL,
        	                          (PBYTE)&pDevice->modem.Properties, &cbData)))
                {
                    LOG("  RegQueryValueEx(Default) failed: %#lx\r\n", dwRet);
                    goto _Exit;
                }


                // At this point, we have all the information
                // needed to identify the modem on NT5.
                // So let's get the modem's settings;
                // First, the REGDEVSETTINGS
	            cbData = sizeof(pDevice->modem.devSettings);
		        if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hkDrv, "Default", NULL, NULL,
        	                          (PBYTE)&pDevice->modem.devSettings, &cbData)))
                {
                    // Without the Defaults, there's no point in
                    // saving this modem.
                    LOG("  RegQueryValueEx(Default) failed: %#lx\r\n", dwRet);
                    goto _Exit;
                }

                // Next, let's get the DCB
	            cbData = sizeof(pDevice->modem.dcb);
		        if (ERROR_SUCCESS != (
                    SET(dwRet)
                    RegQueryValueExA (hkDrv, "DCB", NULL, NULL,
        	                          (PBYTE)&pDevice->modem.dcb, &cbData)))
                {
                    LOG("  RegQueryValueEx(DCB) failed: %#lx\r\n", dwRet);
                    goto _Exit;
                }


                // Now we have all the info that's
                // mandatory. Let's look at the optional
                // fields.

                // Get the user init string
                pDevice->modem.szUserInit[0] = '\0';
	            cbData = sizeof(pDevice->modem.szUserInit);
                if (ERROR_SUCCESS == (
                    SET(dwRet)
		            RegQueryValueExA (hkDrv, "UserInit", NULL, NULL,
        	                pDevice->modem.szUserInit, &cbData)))
                {
                    pDevice->modem.dwMask |= MASK_USER_INIT;
                }
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(UserInit) failed: %#lx\r\n", dwRet)));

                // Next, get the logging value
                pDevice->modem.bLogging = 0;
	            cbData = sizeof(pDevice->modem.bLogging);
                SET(dwRet)
		        RegQueryValueExA (hkDrv, "Logging", NULL, NULL,
        	            &pDevice->modem.bLogging, &cbData);
                ERR(dwRet, ERROR_SUCCESS, (LOG("  RegQueryValueEx(Logging) failed: %#lx\r\n", dwRet)));

                LOG("  %s, %s, %#lx, %d\r\n",
                    pDevice->modem.szHardwareID,
                    pDevice->modem.szUserInit,
                    pDevice->modem.dwMask,
                    (DWORD)pDevice->modem.bLogging);

                WriteFile (pDevice->h_File,
                           &pDevice->modem,
                           sizeof(pDevice->modem),
                           &dwWritten, NULL);

            _Exit:
                // Here we have the hardware id and the
                // driver key;
	            cbData = sizeof(szBuffer);
                ZeroMemory (szBuffer, cbData);

				if (bVirtualDevNode)
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hkParentDevNode, "CompatibleIDs", NULL, NULL, szBuffer, &cbData)))
					{
						LOG("  RegQueryValueEx(CompatibleIDs) failed: %#lx\r\n", dwRet);
					}
				}
				else
				{
					if (ERROR_SUCCESS != (
						SET(dwRet)
						RegQueryValueExA (hk, "CompatibleIDs", NULL, NULL, szBuffer, &cbData)))
					{
						LOG("  RegQueryValueEx(CompatibleIDs) failed: %#lx\r\n", dwRet);
					}
				}

                LOG("  Compatible IDs: %s.\r\n", szBuffer);
                // Now convert the ID from a string (with multiple IDs
                // separated by comma) to a multi_strings
                for (p = szBuffer; 0 != *p; p++)
                {
                    if (',' == *p)
                    {
                        *p = 0;
                    }
                }
                UpdateAnswerFileAndMigrateInf (pDevice->modem.szHardwareID,
                                               szBuffer,
                                               hkDrv,
                                               pDevice->szRegSubkey,
                                               dwPnPIDTable);
                RegCloseKey (hkDrv);
            }
            ELSE_LOG(("  Class not modem.\r\n"));

        _End:
            RegCloseKey(hk);

			if (bVirtualDevNode) RegCloseKey(hkParentDevNode);
        }
        ELSE_LOG(("  Could not read class: %#lx\r\n", dwRet));
    }
    ELSE_LOG(("  Could not open key %s: %#lx\r\n", pDevice->szRegSubkey, dwRet));
    LOG("Exiting ProcessModem\r\n.");
}


void WalkRegistry (PROCESS_MODEM pProcessModem, DWORD dwParam)
{
 REG_DEVICE regDevice = {HKEY_LOCAL_MACHINE,
                         INVALID_HANDLE_VALUE,
                         "Enum",
                         {0}};
 char szFile[MAX_PATH] = "";

    LOG ("WalkRegistry\r\n");

    if (ERROR_SUCCESS ==
            RegOpenKeyExA (HKEY_LOCAL_MACHINE,
                           "System\\CurrentControlSet\\Services\\Class",
                           0, KEY_ALL_ACCESS,
                           &regDevice.hkClass))
    {
        LOG(" Opened the class key successfully\r\n");
        lstrcpyA (szFile, g_pszWorkingDir);
        lstrcatA (szFile, "MM");

        regDevice.h_File = CreateFileA (szFile,
                                        GENERIC_READ | GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

        if (INVALID_HANDLE_VALUE != regDevice.h_File)
        {
            LOG(" Created the migration file successfully\r\n");
            EnumNextLevel (&regDevice, 3, pProcessModem, dwParam);
            RegCloseKey (regDevice.hkClass);
            CloseHandle (regDevice.h_File);
        }
        ELSE_LOG((" Could not create migration file: %#lx\r\n", GetLastError()));
    }

    LOG("Exit WalkRegistry\r\n");
}


int  GetNumberOfModems (void)
{
 int iRet = 0;
 HKEY hKey;

    if (ERROR_SUCCESS ==
        RegOpenKeyExA (HKEY_LOCAL_MACHINE,
                       "System\\CurrentControlSet\\Services\\Class\\Modem",
                       0,
                       KEY_ENUMERATE_SUB_KEYS,
                       &hKey))
    {
        if (ERROR_SUCCESS !=
            RegQueryInfoKey (hKey,
                             NULL, NULL, NULL,
                             &iRet,
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            LOG ("  Could not get the number of subkeys: %#lx\r\n", GetLastError());
        }

        RegCloseKey (hKey);
    }
    ELSE_LOG((" Could not open System\\CurrentControlSet\\Services\\Class\\Modem: %#lx\r\n", GetLastError()));

    return iRet;
}



void UpdateAnswerFileAndMigrateInf (
    char *szHardwareID,
    char *szCompatibleIDs,
    HKEY  hKeyDrv,
    char *szEnumPath,
    DWORD dwPnPIDTable)
{
 char szDirectory[MAX_PATH];
 char szInf[MAX_PATH];
 WIN32_FIND_DATA FindData;
 int iLengthDir, iLengthInf;
 HANDLE hFindFile;
 char *p;
 BOOL bRet;

    bRet = FALSE;

    // Only update the answer file if we have
    // a hardware ID
    if (NULL != szHardwareID &&
        0 != *szHardwareID)
    {
        // First, get the PortDriver;
        // if we can't read it, assume this is *NOT*
        // a controller-less modems, so go ahead and
        // copy the files (this will probably be a
        // legacy modem).
        iLengthDir = sizeof (szDirectory);
	    if (ERROR_SUCCESS ==
            RegQueryValueExA (hKeyDrv, "PortDriver", NULL, NULL,
        	                  (PBYTE)szDirectory, &iLengthDir))
        {
            if ((0 != lstrcmpiA (szDirectory, "serial.vxd")) &&
				(0 != lstrcmpiA (szDirectory, "wdmmdmld.vxd")))
            {
                // Looks like this modem is not controlled
                // by the system serial driver, so don't do
                // anything.
                return;
            }
        }

        // Is this modem supported in NT5?
        if (0 != dwPnPIDTable)
	{
		LOG("checking for hardware ids\n");
		for (p = szHardwareID; 0 != *p; p += lstrlenA(p)+1)
		{
			if ((bRet = IsPnpIdSupportedByNt (dwPnPIDTable, p)))
			{
				LOG(bRet?"PnPID (%s) was found.\r\n":"Modem %s not supported.\r\n", p);
				break;
			}
			// LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", bRet?p:szHardwareID);
			LOG(bRet?"PnPID (%s) was found.\r\n":"Modem %s not supported.\r\n", p);
		}
		if (!bRet)
		{
			LOG("checking for compat ids\n");
			for (p = szCompatibleIDs; 0 != *p; p += lstrlenA(p)+1)
			{
				if ((bRet = IsPnpIdSupportedByNt (dwPnPIDTable, p)))
				{
					LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", p);
					break;
				}
				// LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", bRet?p:szHardwareID);
				LOG(bRet?"PnPID %s was found.\r\n":"Modem %s not supported.\r\n", p);
			}
		}
	}
        ELSE_LOG(("PnPIDTable is NULL\r\n"));

        if (!bRet)
        {
            // Get the INF name.
            iLengthInf = sizeof (szInf);
	        if (ERROR_SUCCESS !=
                RegQueryValueExA (hKeyDrv, "InfPath", NULL, NULL,
        	                      (PBYTE)szInf, &iLengthInf))
            {
                // If we couldn't read the InfPath,
                // there's nothing we can do.
                return;
            }

            // So now, start looking for the INF.
            iLengthDir = GetWindowsDirectoryA (szDirectory, sizeof (szDirectory));
            if (3 > iLengthDir)
            {
                // Most likely there's some error
                // and iLength is 0;
                // the smallest path would be something
                // like  C:\;
                return;
            }
            if (3 < iLengthDir)
            {
                // this means that the path
                // will not end in a \, so
                // let's add it.
                szDirectory[iLengthDir++] = '\\';
            }

            // Now, append INF and the inf name
            if (sizeof(szDirectory) < iLengthDir + iLengthInf + 5)
            {
                // Not enough memory, just bail.
                return;
            }
            lstrcpyA (szDirectory+iLengthDir, "INF\\");
            iLengthDir += 4;
            lstrcpyA (szDirectory+iLengthDir, szInf);

            // Let's find the INF
            ZeroMemory (&FindData, sizeof(FindData));
            hFindFile = FindFirstFile (szDirectory, &FindData);
            if (INVALID_HANDLE_VALUE == hFindFile)
            {
                LOG("UpdateAnswerFile: could not find %s.\r\n", szDirectory);
                // We didn't find the file in the INF directory;
                // let's try INF\OTHER.
                if (sizeof(szDirectory) < iLengthDir + iLengthInf + 7)
                {
                    // Not enough memory, just bail.
                    return;
                }
                lstrcpyA (szDirectory+iLengthDir, "OTHER\\");
                iLengthDir += 6;
                lstrcpyA (szDirectory+iLengthDir, szInf);

                ZeroMemory (&FindData, sizeof(FindData));
                hFindFile = FindFirstFile (szDirectory, &FindData);

                if (INVALID_HANDLE_VALUE == hFindFile)
                {
                    LOG("UpdateAnswerFile: could not find %s.\r\n", szDirectory);
                    // couldn't find the INF file,
                    // so there's nothing to do.
                    return;
                }
                ELSE_LOG(("UpdateAnswerFile: found %s.\r\n", szDirectory));
            }
            ELSE_LOG(("UpdateAnswerFile: found %s.\r\n", szDirectory));

            FindClose (hFindFile);  // Don't need the handle any more.

            // If we get here, we have the path to an INF, somewhere under WINDOWS\INF.
            // We need to copy the file to the working dir.
            wsprintfA (szInf, "%s%s", g_pszWorkingDir, szDirectory+iLengthDir);
            LOG ("UpdateAnswerFile: copying %s to %s.\r\n", szDirectory, szInf);
            SET(bRet)
            CopyFile (szDirectory, szInf, TRUE);
            ERR(bRet, TRUE, (LOG("UpdateAnswerFile: CopyFile failed: %#lx\r\n", GetLastError ())));
            // At this point, we have a list of IDs (szHardwareID, separated by comma),
            // and the path to the INF for them.
            for (p = szHardwareID; 0 != *p; p += lstrlenA(p)+1)
            {
                LOG("UpdateAnswerFile: WritePrivateProfileString (%s=%s).\r\n", p, szInf);
                SET(bRet)
                WritePrivateProfileStringA ("DeviceDrivers",
                                            p,
                                            szInf,
                                            g_pszUnattendFile);
                ERR(bRet, TRUE, (LOG("UpdateAnswerFile: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));
            }
        }
    }

    // Now we can update migrate.inf
    wsprintfA (szDirectory, "%smigrate.inf", g_pszWorkingDir);
    wsprintfA (szInf, "HKLM\\%s", szEnumPath);
    LOG("UpdateAnswerFile: WritePrivateProfileString (%s=Registry) to %s.\r\n", szInf, szDirectory);
    SET(bRet)
    WritePrivateProfileStringA ("Handled",
                                szInf,
                                "Registry",
                                szDirectory);
    ERR(bRet, TRUE, (LOG("UpdateAnswerFile: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));
}


BOOL ReadString (HANDLE hFile, char *szBuffer, DWORD dwSize)
{
 BOOL bRet = FALSE;
 WORD wData;
 DWORD cbRead;

    if (ReadFile (hFile, &wData, sizeof(wData), &cbRead, NULL) &&
        sizeof(wData) == cbRead                                &&
        wData < dwSize)
    {
        if (0 < wData &&
            ReadFile (hFile, szBuffer, wData, &cbRead, NULL) &&
            wData == cbRead)
        {
            *(szBuffer+wData) = 0;
            bRet = TRUE;
        }
    }
    return bRet;
}


DWORD PnPIDTableCreate ()
{
 char szBuffer[MAX_PATH];
 char szSetup[]="\\setup\\";
 char szHwcomp[]="hwcomp.dat";
 char *p;
 DWORD dwTemp;

    InitializeMigLib ();

    // First, check for hwcomp.dat in %windir%\setup
    dwTemp = GetWindowsDirectoryA (szBuffer, sizeof(szBuffer)-sizeof(szSetup)-sizeof(szHwcomp));
    if (0 < dwTemp)
    {
     WIN32_FIND_DATAA findData;
     HANDLE hFindFile;

        p = szBuffer+dwTemp;
        lstrcpyA (p, szSetup);
        p += sizeof(szSetup)-1;
        lstrcpyA (p, szHwcomp);
        hFindFile = FindFirstFileA (szBuffer, &findData);
        if (INVALID_HANDLE_VALUE != hFindFile)
        {
            // We found hwcomp.dat in %windir%\setup.
            // Use it.
            FindClose (hFindFile);
            goto _OpenAndLoadHwCompDat;
        }
    }

    // Didn't find hwcomp.dat in %windir%\setup.
    // Use the one on the sources.
    lstrcpyA (szBuffer, g_pszSourceDir);
    lstrcatA (szBuffer, szHwcomp);

_OpenAndLoadHwCompDat:
    LOG("Trying to open %s.\r\n", szBuffer);
    dwTemp = OpenAndLoadHwCompDat (szBuffer);
    if (0 == dwTemp)
    {
        LOG("OpenAndLoadHwCompDat failed!\r\n");
    }

    return dwTemp;
}


void PnPIDTableDestroy (DWORD dwPnPIDTable)
{
    if (0 != dwPnPIDTable)
    {
        CloseHwCompDat (dwPnPIDTable);
    }
    TerminateMigLib ();
}


static HANDLE OpenProvidersFile (void)
{
 HANDLE hFile;
 char szFile[MAX_PATH] = "";

    lstrcpyA (szFile, g_pszWorkingDir);
    lstrcatA (szFile, "TP");

    hFile = CreateFileA (szFile,
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                         NULL);

#ifdef DO_LOG
    if (INVALID_HANDLE_VALUE == hFile)
    {
        LOG(" Could not create %s: %#lx\r\n", szFile, GetLastError());
    }
    else
    {
        LOG(" Created %s\r\n", szFile);
    }
#endif //DO_LOG

    return hFile;
}

void DoTapiProviders (void)
{
 HANDLE hFile;
 HKEY   hKeyProviders;
 DWORD  cbData;
 DWORD  dwProviderNr;
 DWORD  dwProviderID;
 char  szProviderFileName[24];  // Enough to hold "ProviderFileNameXXXXX\0"
 char  szProviderID[16];        // Enough to hold "ProviderIDxxxxx\0"
 char  szFileName[PROVIDER_FILE_NAME_LEN];
 char  *pProviderFileNameNumber, *pProviderIDNumber;
 TAPI_SERVICE_PROVIDER Provider;

 char szDirectory[MAX_PATH];
 DECLARE(BOOL,bRet);

    LOG("Entering DoTapiProviders\r\n");

    if (ERROR_SUCCESS !=
        RegCreateKeyExA (HKEY_LOCAL_MACHINE, REGKEY_PROVIDERS, 0, NULL, REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS, NULL, &hKeyProviders, &cbData))
    {
        goto _WriteInf;
    }

    hFile = OpenProvidersFile ();
    if (INVALID_HANDLE_VALUE == hFile)
    {
        RegCloseKey (hKeyProviders);
        goto _WriteInf;
    }

    // Initialize value names and pointers
    lstrcpyA (szProviderFileName, REGVAL_PROVIDERFILENAME);
    lstrcpyA (szProviderID, REGVAL_PROVIDERID);
    pProviderFileNameNumber = szProviderFileName + lstrlenA (szProviderFileName);
    pProviderIDNumber = szProviderID + lstrlenA (szProviderID);

    for (dwProviderNr = 0; TRUE; dwProviderNr++)
    {
        wsprintfA (pProviderFileNameNumber, "%d", dwProviderNr);
        lstrcpyA (pProviderIDNumber, pProviderFileNameNumber);

        cbData = sizeof (szFileName);
        if (ERROR_SUCCESS !=
            RegQueryValueExA (hKeyProviders, szProviderFileName, NULL, NULL, (PBYTE)szFileName, &cbData))
        {
            break;
        }

        if (0 == lstrcmpiA (szFileName, TSP3216l))
        {
            continue;
        }

        cbData = sizeof (dwProviderID);
        if (ERROR_SUCCESS !=
            RegQueryValueEx (hKeyProviders, szProviderID, NULL, NULL, (PBYTE)&dwProviderID, &cbData))
        {
            // This is not one of the default providers, and we
            // couldn't read it's provider ID. We must skip it.
            continue;
        }

        // We have a provider that was installed by the user on the previous NT installation.
        Provider.dwProviderID = dwProviderID;
        lstrcpyA (Provider.szProviderName, szFileName);
        LOG("Writing %s, %d\r\n", Provider.szProviderName, Provider.dwProviderID);
        WriteFile (hFile, (PVOID)&Provider, sizeof(Provider), &cbData, NULL);
    }

    RegCloseKey (hKeyProviders);
    CloseHandle (hFile);

_WriteInf:
    wsprintfA (szDirectory, "%smigrate.inf", g_pszWorkingDir);
    LOG("DoTapiStuff: WritePrivateProfileString (HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Provider4096=Registry) to %s.\r\n", szDirectory);
    SET(bRet)
    WritePrivateProfileStringA ("Handled",
                                "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Provider4096",
                                "Registry",
                                szDirectory);
    ERR(bRet, TRUE, (LOG("DoTapiStuff: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));

    LOG("DoTapiStuff: WritePrivateProfileString (HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers=Registry) to %s.\r\n", szDirectory);
    SET(bRet)
    WritePrivateProfileStringA ("Handled",
                                "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers",
                                "Registry",
                                szDirectory);
    ERR(bRet, TRUE, (LOG("DoTapiStuff: WritePrivateProfileString failed: %#lx\r\n", GetLastError ())));

    LOG("Exiting DoTapiProviders.\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncatlps.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L P S . C P P
//
//  Contents:   Class implementation for ATL-like property sheet page object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include "ncatlps.h"

CPropSheetPage::~CPropSheetPage ()
{
    // If we are attached to a window, DWL_USER contains a pointer to this.
    // Remove it since we are going away.
    //
    if (m_hWnd)
    {
        const CPropSheetPage* pps;
        pps = (CPropSheetPage *) ::GetWindowLongPtr(m_hWnd, DWLP_USER);
        if (pps)
        {
            AssertSz (pps == this, "Why isn't DWL_USER equal to 'this'?");
            ::SetWindowLongPtr(m_hWnd, DWLP_USER, NULL);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::CreatePage
//
//  Purpose:    Method to quickly create a property page.
//
//  Arguments:
//      unId    [in]    IDD of dialog resource ID
//      dwFlags [in]    Additional flags to use in the dwFlags field of the
//                      PROPSHEETPAGE struct.
//
//  Returns:    HPROPSHEETPAGE
//
//  Author:     shaunco   28 Feb 1997
//
//  Notes:
//
HPROPSHEETPAGE CPropSheetPage::CreatePage(UINT unId, DWORD dwFlags,
                                          PCTSTR pszHeaderTitle,
                                          PCTSTR pszHeaderSubTitle,
                                          PCTSTR pszTitle)
{
    Assert(unId);

    PROPSHEETPAGE   psp = {0};

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = dwFlags;
    psp.hInstance   = _Module.GetModuleInstance();
    psp.pszTemplate = MAKEINTRESOURCE(unId);
    psp.pfnDlgProc  = (DLGPROC)CPropSheetPage::DialogProc;
    psp.pfnCallback = static_cast<LPFNPSPCALLBACK>
            (CPropSheetPage::PropSheetPageProc);
    psp.lParam      = (LPARAM)this;

    psp.pszHeaderTitle = pszHeaderTitle;
    psp.pszHeaderSubTitle = pszHeaderSubTitle;

    psp.pszTitle = pszTitle;

    return ::CreatePropertySheetPage(&psp);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::DialogProc
//
//  Purpose:    Dialog proc for ATL property sheet pages.
//
//  Arguments:
//      hWnd   [in]
//      uMsg   [in]     See the ATL documentation.
//      wParam [in]
//      lParam [in]
//
//  Returns:    LRESULT
//
//  Author:     danielwe   28 Feb 1997
//
//  Notes:
//
LRESULT CALLBACK CPropSheetPage::DialogProc(HWND hWnd, UINT uMsg,
                                            WPARAM wParam, LPARAM lParam)
{
    LRESULT         lRes;
    PROPSHEETPAGE*  ppsp;
    CPropSheetPage* pps;
    BOOL            fRes = FALSE;

    if (uMsg == WM_INITDIALOG)
    {
        ppsp = (PROPSHEETPAGE *)lParam;
        pps = (CPropSheetPage *)ppsp->lParam;
        ::SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) pps);
        pps->Attach(hWnd);
    }
    else
    {
        pps = (CPropSheetPage *)::GetWindowLongPtr(hWnd, DWLP_USER);

        // Until we get WM_INITDIALOG, just return FALSE
        if (!pps)
            return FALSE;
    }

    if (pps->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lRes, 0))
    {
        switch (uMsg)
        {
        case WM_COMPAREITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_INITDIALOG:
        case WM_QUERYDRAGICON:
            return lRes;
            break;
        }

        ::SetWindowLongPtr(hWnd, DWLP_MSGRESULT, lRes);
        fRes = TRUE;
    }

    return fRes;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::PropSheetPageProc
//
//  Purpose:    PropSheetPageProc for ATL property sheet pages.
//
//  Arguments:
//      hWnd   [in]
//      uMsg   [in]     See Win32 documentation.
//      ppsp   [in]
//
//  Returns:    UINT
//
//  Author:     billbe   6 Jul 1997
//
//  Notes:
//
UINT CALLBACK CPropSheetPage::PropSheetPageProc(HWND hWnd, UINT uMsg,
                                                LPPROPSHEETPAGE ppsp)
{
    CPropSheetPage* pps;

    // The this pointer was stored in the structure's lParam
    pps = reinterpret_cast<CPropSheetPage *>(ppsp->lParam);

    // This has to be valid since the CreatePage member fcn sets it
    Assert(pps);

    UINT uRet = TRUE;

    // call the correct handler based on uMsg
    //
    if (PSPCB_CREATE == uMsg)
    {
        uRet = pps->UCreatePageCallbackHandler();
    }
    else if (PSPCB_RELEASE == uMsg)
    {
        pps->DestroyPageCallbackHandler();
    }
    else
    {
        AssertSz(FALSE, "Invalid or new message sent to call back!");
    }

    return (uRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\makefile.inc ===
TARGETPATH=obj

!if !defined(_UPNP_SSDP)
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
!ENDIF

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DENABLETRACE
!ENDIF

C_DEFINES=$(C_DEFINES) -DUSE_HEAP_ALLOC=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(PROJDIR)\inc\pch.h
PRECOMPILED_OPTION=/Yu /Fp$(O)\pch.pch
PRECOMPILED_TARGET=$(O)\pch.pch
PRECOMPILED_OBJ=$(O)\pch.obj

RCOPTIONS=-N
UMTYPE=windows
USE_STATIC_ATL=1
ATL_VER=30
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncbase.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C B A S E . C P P
//
//  Contents:   Basic common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncbase.h"
#include "ncdebug.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddRefObj
//
//  Purpose:    AddRef's the object pointed to by punk by calling
//              punk->AddRef();
//
//  Arguments:
//      punk [in]   Object to be AddRef'd. Can be NULL.
//
//  Returns:    Result of AddRef call.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Using this function to AddRef an object will reduce
//              our code size.
//
NOTHROW
ULONG
AddRefObj (
    IUnknown* punk)
{
    return (punk) ? punk->AddRef () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseObj
//
//  Purpose:    Releases the object pointed to by punk by calling
//              punk->Release();
//
//  Arguments:
//      punk [in]   Object to be released. Can be NULL.
//
//  Returns:    Result of Release call.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Using this function to release a (possibly NULL) object will
//              reduce our code size.
//
NOTHROW
ULONG
ReleaseObj (
    IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}

//+--------------------------------------------------------------------------
//
//  Function:   DwWin32ErrorFromHr
//
//  Purpose:    Converts the HRESULT to a Win32 error or SetupApi error.
//
//  Arguments:
//      hr [in] The HRESULT to convert
//
//  Returns:    Converted DWORD value.
//
//  Author:     billbe   22 Apr 1997
//
//  Notes:
//
NOTHROW
DWORD
DwWin32ErrorFromHr (
    HRESULT hr)
{
    DWORD dw = ERROR_SUCCESS;

    // All success codes convert to ERROR_SUCCESS so we only need to handle
    // failures.
    if (FAILED(hr))
    {
        DWORD dwFacility = HRESULT_FACILITY(hr);

        if (FACILITY_WIN32 == dwFacility)
        {
            dw = HRESULT_CODE(hr);
        }
        else if (FACILITY_ITF == dwFacility)
        {
            dw = ERROR_GEN_FAILURE;
        }
        else
        {
            // cannot convert it
            dw = hr;
        }
    }

    return dw;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFromLastWin32Error
//
//  Purpose:    Converts the GetLastError() Win32 call into a proper HRESULT.
//
//  Arguments:
//      (none)
//
//  Returns:    Converted HRESULT value.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      This is not inline as it actually generates quite a bit of
//              code.
//              If GetLastError returns an error that looks like a SetupApi
//              error, this function will convert the error to an HRESULT
//              with FACILITY_SETUP instead of FACILITY_WIN32
//
NOTHROW
HRESULT
HrFromLastWin32Error ()
{
    DWORD dwError = GetLastError();
    HRESULT hr;

    // This test is testing SetupApi errors only (this is
    // temporary because the new HRESULT_FROM_SETUPAPI macro will
    // do the entire conversion)
    if (dwError & (APPLICATION_ERROR_MASK | ERROR_SEVERITY_ERROR))
    {
        hr = HRESULT_FROM_SETUPAPI(dwError);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetProcAddress
//
//  Purpose:    Loads a libray and returns the address of a procedure within
//                  the library
//
//  Arguments:
//      hModule      [in] The handle to the library module instance
//      pszaFunction [in]  Function to retrieve
//      ppfn         [out] Address of szFunction
//
//  Returns:    S_OK if successful, Win32 converted error if failure.
//
//  Author:     billbe   10 June 1997
//
//  Notes:
//
HRESULT
HrGetProcAddress (
    HMODULE     hModule,
    PCSTR       pszaFunction,
    FARPROC*    ppfn)
{
    Assert(hModule);
    Assert(pszaFunction);
    Assert(ppfn);

    HRESULT hr = S_OK;
    *ppfn = GetProcAddress(hModule, pszaFunction);
    if (!*ppfn)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidError, "HrGetProcAddress failed: szFunction: %s",
                 pszaFunction);
    }

    TraceError("HrGetProcAddress", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadLibAndGetProcs
//
//  Purpose:    Load a dynamic link library and the addresses of one or
//              more procedures within that library.
//
//  Arguments:
//      pszLibPath         [in]  Path to the DLL to load.
//      cFunctions         [in]  Number of procedures to load.
//      apszaFunctionNames [in]  Array of function names.  (Must be 'cFunctions'
//                               of them.)
//      phmod              [out] Returned handle to the loaded module.
//      apfn               [out] Array of returned pointers to the procedures
//                               loaded.  (Must be 'cFunctions' of them.)
//
//  Returns:    S_OK if all procedures were loaded, S_FALSE if only
//              some of them were, or a Win32 error code.  If only
//              one procedure is to be loaded and it is not, S_FALSE will
//              not be returned, rather, the reason for why the single
//              procedure could not be loaded will be returned.  This allows
//              HrLoadLibAndGetProc to be implemented using this function.
//
//  Author:     shaunco   19 Jan 1998
//
//  Notes:      phmod should be freed by the caller using FreeLibrary if
//              the return value is S_OK.
//
HRESULT
HrLoadLibAndGetProcs (
    PCTSTR          pszLibPath,
    UINT            cFunctions,
    const PCSTR*    apszaFunctionNames,
    HMODULE*        phmod,
    FARPROC*        apfn)
{
    Assert (pszLibPath);
    Assert (cFunctions);
    Assert (apszaFunctionNames);
    Assert (phmod);
    Assert (apfn);

    HRESULT hr = S_OK;

    // Load the module and initialize the output parameters.
    //
    HMODULE hmod = LoadLibrary(pszLibPath);
    *phmod = hmod;
    ZeroMemory (apfn, cFunctions * sizeof(FARPROC));

    if (hmod)
    {
        // Get the proc address of each function.
        //
        for (UINT i = 0; i < cFunctions; i++)
        {
            apfn[i] = GetProcAddress (hmod, apszaFunctionNames[i]);

            if (!apfn[i])
            {
                // Couldn't load all functions.  We'll be returning S_FALSE
                // (if their are more than one function.)
                //
                hr = S_FALSE;

                TraceTag (ttidError, "HrLoadLibAndGetProcs: GetProcAddress "
                    "for '%s' failed.",
                    apszaFunctionNames[i]);
            }
        }

        // If we're only loading one function, and it failed,
        // return the failure.
        //
        if ((1 == cFunctions) && !apfn[0])
        {
            hr = HrFromLastWin32Error ();
            FreeLibrary (hmod);
        }
    }
    else
    {
        hr = HrFromLastWin32Error ();
        TraceTag (ttidError, "HrLoadLibAndGetProcs: LoadLibraryW (%S) failed.",
            pszLibPath);
    }

    TraceError ("HrLoadLibAndGetProcs", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FFileExists
//
//  Purpose:    Check for file existance. Returns TRUE if file is present,
//              FALSE otherwise (duh).
//
//  Arguments:
//      pszFileName [in]  File name to check for.
//      fDirectory  [in]  TRUE if the file is really a directory
//
//  Returns:
//
//  Author:     jeffspr   13 Jan 2000
//
//  Notes:
//
BOOL FFileExists(LPTSTR pszFileName, BOOL fDirectory)
{
    BOOL    fReturn = TRUE;
    HANDLE  hFile   = NULL;
    DWORD   dwFlags;

    if (fDirectory)
    {
        dwFlags = FILE_ATTRIBUTE_DIRECTORY | FILE_FLAG_BACKUP_SEMANTICS;
    }
    else
    {
        dwFlags = FILE_ATTRIBUTE_NORMAL;
    }

    hFile = CreateFile(
            pszFileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            dwFlags,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        fReturn = FALSE;
        goto Exit;
    }

Exit:
    if (hFile && hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\comutility.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O M U T I L I T Y . C P P 
//
//  Contents:   COM support classes and functions
//
//  Notes:      
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ComUtility.h"

HRESULT HrCoTaskMemAllocArray(long nNumber, long nElemSize, void ** ppv)
{
    CHECK_POINTER(ppv);
    Assert(nNumber);
    Assert(nElemSize);
    HRESULT hr = S_OK;
    *ppv = CoTaskMemAlloc(nNumber * nElemSize);
    if(!*ppv)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "HrCoTaskMemAllocArray");
    return hr;
}

HRESULT HrCoTaskMemAllocString(long nChars, wchar_t ** psz)
{
    CHECK_POINTER(psz);
    HRESULT hr = S_OK;
    *psz = reinterpret_cast<wchar_t*>(CoTaskMemAlloc(nChars * sizeof(wchar_t)));
    if(!*psz)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "HrCoTaskMemAllocString");
    return hr;
}

HRESULT HrCoTaskMemAllocString(wchar_t * sz, wchar_t ** psz)
{
    CHECK_POINTER(sz);
    CHECK_POINTER(psz);
    HRESULT hr = HrCoTaskMemAllocString(lstrlen(sz) + 1, psz);
    if(SUCCEEDED(hr))
    {
        lstrcpy(*psz, sz);
    }
    TraceHr(ttidError, FAL, hr, FALSE, "HrCoTaskMemAllocString");
    return hr;
}

HRESULT HrCoCreateInstanceBase(
    REFCLSID clsid,
    DWORD dwClsContext,
    REFIID riid,
    void ** ppv)
{
    return ::CoCreateInstance(
        clsid,
        NULL,
        dwClsContext,
        riid,
        ppv);
}

HRESULT HrCoCreateInstanceInprocBase(
    REFCLSID clsid,
    REFIID riid,
    void ** ppv)
{
    return ::CoCreateInstance(
        clsid,
        NULL,
        CLSCTX_INPROC_SERVER,
        riid,
        ppv);
}

HRESULT HrCoCreateInstanceLocalBase(
    REFCLSID clsid,
    REFIID riid,
    void ** ppv)
{
    return ::CoCreateInstance(
        clsid,
        NULL,
        CLSCTX_LOCAL_SERVER,
        riid,
        ppv);
}

HRESULT HrCoCreateInstanceServerBase(
    REFCLSID clsid,
    REFIID riid,
    void ** ppv)
{
    return ::CoCreateInstance(
        clsid,
        NULL,
        CLSCTX_SERVER,
        riid,
        ppv);
}

HRESULT HrIsSameObject(const IUnknown * pUnk1, const IUnknown * pUnk2)
{
    if(!pUnk1 || !pUnk2)
    {
        return E_POINTER;
    }
    IUnknown * pUnk1Temp = NULL;
    IUnknown * pUnk2Temp = NULL;
    HRESULT hr;
    hr = const_cast<IUnknown*>(pUnk1)->QueryInterface(&pUnk1Temp);
    if(FAILED(hr))
    {
        return hr;
    }
    hr = const_cast<IUnknown*>(pUnk2)->QueryInterface(&pUnk2Temp);
    if(SUCCEEDED(hr))
    {
        if(pUnk1Temp == pUnk2Temp)
        {
            hr = S_OK;
        }
        else 
        {
            hr = S_FALSE;
        }
        ReleaseObj(pUnk2Temp);
    }
    ReleaseObj(pUnk1Temp);
    return hr;
}

HRESULT HrSetProxyBlanketHelper(
    IUnknown * pUnkProxy,
    DWORD dwAuthnLevel,
    DWORD dwImpLevel,
    DWORD dwCapabilities)
{
    CHECK_POINTER(pUnkProxy);
    HRESULT hr = S_OK;

    DWORD dwAuthnSvc = 0;
    DWORD dwAuthzSvc = 0;
    wchar_t * szServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE authHandle;

    hr = CoQueryProxyBlanket(pUnkProxy, &dwAuthnSvc, &dwAuthzSvc, &szServerPrincName, 
                             NULL, NULL, &authHandle, NULL);
    if(SUCCEEDED(hr))
    {
        hr = CoSetProxyBlanket(pUnkProxy, dwAuthnSvc, dwAuthzSvc, szServerPrincName, 
                               dwAuthnLevel, dwImpLevel, authHandle, dwCapabilities);
        if(szServerPrincName)
        {
            CoTaskMemFree(szServerPrincName);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrSetProxyBlanketHelper");
    return hr;
}

HRESULT HrSetProxyBlanket(
    IUnknown * pUnkProxy,
    DWORD dwAuthnLevel,
    DWORD dwImpLevel,
    DWORD dwCapabilities)
{
    CHECK_POINTER(pUnkProxy);
    HRESULT hr = S_OK;

    hr = HrSetProxyBlanketHelper(pUnkProxy, dwAuthnLevel, dwImpLevel, dwCapabilities);
    if(SUCCEEDED(hr))
    {
        IUnknown * pUnk = NULL;
        hr = pUnkProxy->QueryInterface(&pUnk);
        if(SUCCEEDED(hr))
        {
            hr = HrSetProxyBlanketHelper(pUnk, dwAuthnLevel, dwImpLevel, dwCapabilities);
            pUnk->Release();
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrSetProxyBlanket");
    return hr;
}

HRESULT HrEnableStaticCloakingHelper(IUnknown * pUnkProxy)
{
    CHECK_POINTER(pUnkProxy);
    HRESULT hr = S_OK;

    DWORD dwAuthnLevel = 0;
    DWORD dwImpLevel = 0;
    DWORD dwCapabilities = 0;
    DWORD dwAuthnSvc = 0;
    DWORD dwAuthzSvc = 0;
    wchar_t * szServerPrincName = NULL;

    hr = CoQueryProxyBlanket(pUnkProxy, &dwAuthnSvc, &dwAuthzSvc, &szServerPrincName, 
                             &dwAuthnLevel, &dwImpLevel, NULL, &dwCapabilities);
    if(SUCCEEDED(hr))
    {
        dwCapabilities &= ~EOAC_DYNAMIC_CLOAKING;
        dwCapabilities |= EOAC_STATIC_CLOAKING;
        hr = CoSetProxyBlanket(pUnkProxy, dwAuthnSvc, dwAuthzSvc, szServerPrincName, 
                               dwAuthnLevel, dwImpLevel, NULL, dwCapabilities);
        if(szServerPrincName)
        {
            CoTaskMemFree(szServerPrincName);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrEnableStaticCloakingHelper");
    return hr;
}

HRESULT HrEnableStaticCloaking(IUnknown * pUnkProxy)
{
    CHECK_POINTER(pUnkProxy);
    HRESULT hr = S_OK;

    hr = HrEnableStaticCloakingHelper(pUnkProxy);
    if(SUCCEEDED(hr))
    {
        IUnknown * pUnk = NULL;
        hr = pUnkProxy->QueryInterface(&pUnk);
        if(SUCCEEDED(hr))
        {
            hr = HrEnableStaticCloakingHelper(pUnk);
            pUnk->Release();
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrEnableStaticCloaking");
    return hr;
}

HRESULT HrCopyProxyIdentityHelper(IUnknown * pUnkDest, IUnknown * pUnkSrc)
{
    CHECK_POINTER(pUnkDest);
    CHECK_POINTER(pUnkSrc);
    HRESULT hr = S_OK;

    DWORD dwAuthnLevel = 0;
    DWORD dwImpLevel = 0;
    DWORD dwCapabilities = 0;
    DWORD dwAuthnSvc = 0;
    DWORD dwAuthzSvc = 0;
    wchar_t * szServerPrincName = NULL;

    hr = CoQueryProxyBlanket(pUnkDest, &dwAuthnSvc, &dwAuthzSvc, &szServerPrincName, 
                             &dwAuthnLevel, &dwImpLevel, NULL, &dwCapabilities);

    if(SUCCEEDED(hr))
    {
        RPC_AUTH_IDENTITY_HANDLE auth;
        hr = CoQueryProxyBlanket(pUnkSrc, NULL, NULL, NULL, NULL, NULL, &auth, NULL);
        if(SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket(pUnkDest, dwAuthnSvc, dwAuthzSvc, szServerPrincName, 
                                   dwAuthnLevel, dwImpLevel, auth, dwCapabilities);
            if(szServerPrincName)
            {
                CoTaskMemFree(szServerPrincName);
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCopyProxyIdentityHelper");
    return hr;
}

HRESULT HrCopyProxyIdentity(IUnknown * pUnkDest, IUnknown * pUnkSrc)
{
    CHECK_POINTER(pUnkDest);
    CHECK_POINTER(pUnkSrc);
    HRESULT hr = S_OK;

    hr = HrCopyProxyIdentityHelper(pUnkDest, pUnkSrc);
    if(SUCCEEDED(hr))
    {
        IUnknown * pUnk = NULL;
        pUnkDest->QueryInterface(&pUnk);
        if(SUCCEEDED(hr))
        {
            hr = HrCopyProxyIdentityHelper(pUnk, pUnkSrc);
            pUnk->Release();
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCopyProxyIdentity");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncfile.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C F I L E . C P P
//
//  Contents:   Really useful file functions that are implemented in shlwapi
//              but which aren't exported.
//
//  Notes:      Stolen from shell32\path.c
//
//              Using these functions likely requires linking with shlwapi.lib
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "ncfile.h"
#include "trace.h"

#include <shlobj.h>
#include <shlobjp.h>    // PCS_ flags
#include <shlwapi.h>


// PathTruncateKeepExtension
//
// Attempts to truncate the filename pszSpec such that pszDir+pszSpec are less than MAX_PATH-5.
// The extension is protected so it won't get truncated or altered.
//
// in:
//      pszDir      the path to a directory.  No trailing '\' is needed.
//      pszSpec     the filespec to be truncated.  This should not include a path but can have an extension.
//                  This input buffer can be of any length.
//      iTruncLimit The minimum length to truncate pszSpec.  If addition truncation would be required we fail.
// out:
//      pszSpec     The truncated filespec with it's extension unaltered.
// return:
//      TRUE if the filename was truncated, FALSE if we were unable to truncate because the directory name
//      was too long, the extension was too long, or the iTruncLimit is too high.  pszSpec is unaltered
//      when this function returns FALSE.
//
STDAPI_(BOOL) PathTruncateKeepExtension( LPCTSTR pszDir, LPTSTR pszSpec, int iTruncLimit )
{
    LPTSTR pszExt = PathFindExtension(pszSpec);
    int cchExt = lstrlen(pszExt);
    int cchSpec = (int)(pszExt - pszSpec + cchExt);
    int cchKeep = MAX_PATH-lstrlen(pszDir)-5;   // the -5 is just to provide extra padding

    // IF...
    //  ...the filename is to long
    //  ...we are within the limit to which we can truncate
    //  ...the extension is short enough to allow the trunctation
    if ( (cchSpec > cchKeep) && (cchKeep >= iTruncLimit) && (cchKeep > cchExt) )
    {
        // THEN... go ahead and truncate
        StrCpy( pszSpec+cchKeep-cchExt, pszExt );
        return TRUE;
    }
    return FALSE;
}


// notes: modified to only handle LFN drives

STDAPI_(int) PathCleanupSpec2(LPCTSTR pszDir, LPTSTR pszSpec)
{
    LPTSTR pszNext, pszCur;
    UINT   uMatch = GCT_LFNCHAR;
    int    iRet = 0;
    LPTSTR pszPrevDot = NULL;

    for (pszCur = pszNext = pszSpec; *pszNext; pszNext = CharNext(pszNext))
    {
        if (PathGetCharType(*pszNext) & uMatch)
        {
            *pszCur = *pszNext;
#ifndef UNICODE
            if (IsDBCSLeadByte(*pszNext))
                *(pszCur + 1) = *(pszNext + 1);
#endif UNICODE
            pszCur = CharNext(pszCur);
        }
        else
        {
            switch (*pszNext)
            {
            case TEXT('/'):         // used often for things like add/remove
            case TEXT(' '):         // blank (only replaced for short name drives)
               *pszCur = TEXT('-');
               pszCur = CharNext(pszCur);
               iRet |= PCS_REPLACEDCHAR;
               break;
            default:
               iRet |= PCS_REMOVEDCHAR;
            }
        }
    }
    *pszCur = 0;     // null terminate

    if (pszDir && (lstrlen(pszDir) + lstrlen(pszSpec) > MAX_PATH - 1))
    {
        iRet |= PCS_PATHTOOLONG | PCS_FATAL;
    }

    return(iRet);
}




// PathCleanupSpecEx
//
// Just like PathCleanupSpec, PathCleanupSpecEx removes illegal characters from pszSpec
// and enforces 8.3 format on non-LFN drives.  In addition, this function will attempt to
// truncate pszSpec if the combination of pszDir + pszSpec is greater than MAX_PATH.
//
// in:
//      pszDir      The directory in which the filespec pszSpec will reside
//      pszSpec     The filespec that is being cleaned up which includes any extension being used
// out:
//      pszSpec     The modified filespec with illegal characters removed, truncated to
//                  8.3 if pszDir is on a non-LFN drive, and truncated to a shorter number
//                  of characters if pszDir is an LFN drive but pszDir + pszSpec is more
//                  than MAX_PATH characters.
// return:
//      returns a bit mask indicating what happened.  This mask can include the following cases:
//          PCS_REPLACEDCHAR    One or more illegal characters were replaced with legal characters
//          PCS_REMOVEDCHAR     One or more illegal characters were removed
//          PCS_TRUNCATED       Truncated to fit 8.3 format or because pszDir+pszSpec was too long
//          PCS_PATHTOOLONG     pszDir is so long that we cannot truncate pszSpec to form a legal filename
//          PCS_FATAL           The resultant pszDir+pszSpec is not a legal filename.  Always used with PCS_PATHTOOLONG.
//
// note: this is the stolen implementation of PathCleanupSpecEx, which is
//       defined in shlobjp.h but not exported by shell32.dll
//
STDAPI_(int) PathCleanupSpecEx2(LPCTSTR pszDir, LPTSTR pszSpec)
{
    int iRet = 0;

    iRet = PathCleanupSpec2(pszDir, pszSpec);
    if ( iRet & (PCS_PATHTOOLONG|PCS_FATAL) )
    {
        // 30 is the shortest we want to truncate pszSpec to to satisfy the
        // pszDir+pszSpec<MAX_PATH requirement.  If this amount of truncation isn't enough
        // then we go ahead and return PCS_PATHTOOLONG|PCS_FATAL without doing any further
        // truncation of pszSpec
        if ( PathTruncateKeepExtension(pszDir, pszSpec, 30 ) )
        {
            // We fixed the error returned by PathCleanupSpec so mask out the error.
            iRet |= PCS_TRUNCATED;
            iRet &= ~(PCS_PATHTOOLONG|PCS_FATAL);
        }
    }
    else
    {
        // ensure that if both of these aren't set then neither is set.
        Assert( !(iRet&PCS_PATHTOOLONG) && !(iRet&PCS_FATAL) );
    }

    return(iRet);
}

// if you already have a fully-qualified filename, just use PathFileExists
BOOL
fFileExistsAtPath(LPCTSTR pszFile, LPCTSTR pszPath)
{
    Assert(pszFile);
    Assert(pszPath);
    Assert((_tcslen(pszFile) + _tcslen(pszPath)) < MAX_PATH);

    TCHAR pszFullPath [ MAX_PATH + 1 ];
    BOOL fExists;
    BOOL fResult;

    fExists = FALSE;

    _tcscpy(pszFullPath, pszPath);

    fResult = ::PathAppend(pszFullPath, pszFile);
    if (fResult)
    {
        fExists = ::PathFileExists(pszFullPath);
    }
    else
    {
        TraceTag(ttidDefault, "fFileExistsAtPath: PathAppend failed");
    }

    return fExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncinet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I N E T . C P P
//
//  Contents:   Wrappers for the WinInet APIs so they return HRESULTs
//
//  Notes:
//
//  Author:     danielwe   11 Oct 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncinet.h"
#include "ncbase.h"
#include "ncdebug.h"

HINTERNET           g_hInetSess = NULL;
BOOL                g_fInited = FALSE;

HRESULT HrInternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    HRESULT     hr = S_OK;

    if (!InternetSetOptionA(hInternet, dwOption, lpBuffer, dwBufferLength))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorSkip1("HrInternetSetOptionA", hr,
                    HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    return hr;
}

HRESULT HrInternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    HRESULT     hr = S_OK;

    if (!InternetQueryOptionA(hInternet, dwOption, lpBuffer,lpdwBufferLength))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorSkip1("HrInternetQueryOption", hr,
                    HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    return hr;
}

INTERNET_STATUS_CALLBACK HinInternetSetStatusCallback(IN HINTERNET hInternet,
                                 IN INTERNET_STATUS_CALLBACK lpfnInternetCallback)
{
    HRESULT     hr = S_OK;

    return InternetSetStatusCallback(hInternet, lpfnInternetCallback);
}

HINTERNET HinInternetOpenA(IN LPCSTR lpszAgent, IN DWORD dwAccessType,
                           IN LPCSTR lpszProxyName, IN LPCSTR lpszProxyBypass,
                           IN DWORD dwFlags)
{
    HRESULT hr = S_OK;
    DWORD dwTimeout = 5000;  // 5 second

    HINTERNET hInet = InternetOpenA(lpszAgent, dwAccessType, lpszProxyName,
                                    lpszProxyBypass, dwFlags);
    if (hInet)
    {
        hr = HrInternetSetOptionA( hInet,
                                   INTERNET_OPTION_CONNECT_TIMEOUT,
                                   (LPVOID)&dwTimeout,
                                   sizeof(dwTimeout));
        if (SUCCEEDED(hr))
        {
            hr = HrInternetSetOptionA( hInet,
                                       INTERNET_OPTION_RECEIVE_TIMEOUT,
                                       (LPVOID)&dwTimeout,
                                       sizeof(dwTimeout));
        }
    }

    TraceError("HinInternetOpenA", hr);
    return hInet;
}

HRESULT HrInternetCloseHandle(HINTERNET hInternet)
{
    AssertSz(g_hInetSess, "Must have internet session already!");

    if (!InternetCloseHandle(hInternet))
    {
        HRESULT hr = HrFromLastWin32Error();
        TraceError("HrInternetCloseHandle", hr);
        return hr;
    }

    return S_OK;
}

HRESULT HrInternetCrackUrlA(IN LPCSTR lpszUrl, IN DWORD dwUrlLength,
                            IN DWORD dwFlags,
                            IN OUT LPURL_COMPONENTSA lpUrlComponents)
{
    HRESULT     hr = S_OK;

    if (!InternetCrackUrlA(lpszUrl, dwUrlLength, dwUrlLength, lpUrlComponents))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrInternetCrackUrl", hr);
    return hr;
}

HINTERNET HinInternetConnectA(IN HINTERNET hInternet, IN LPCSTR lpszServerName,
                              IN INTERNET_PORT nServerPort,
                              IN LPCSTR lpszUserName OPTIONAL,
                              IN LPCSTR lpszPassword OPTIONAL,
                              IN DWORD dwService, IN DWORD dwFlags,
                              IN DWORD_PTR dwContext)
{
    HRESULT     hr = S_OK;

    return InternetConnectA(hInternet, lpszServerName, nServerPort,
                            lpszUserName, lpszPassword, dwService,
                            dwFlags, dwContext);
}

HINTERNET HinHttpOpenRequestA(IN HINTERNET hConnect, IN LPCSTR lpszVerb,
                              IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion,
                              IN LPCSTR lpszReferrer OPTIONAL,
                              IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
                              IN DWORD dwFlags, IN DWORD_PTR dwContext)
{
    HRESULT     hr = S_OK;

    return HttpOpenRequestA(hConnect, lpszVerb, lpszObjectName, lpszVersion,
                            lpszReferrer, lplpszAcceptTypes, dwFlags,
                            dwContext);
}

HRESULT HrHttpAddRequestHeadersA(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,
                                 IN DWORD dwHeadersLength, IN DWORD dwModifiers)
{
    HRESULT     hr = S_OK;

    if (!HttpAddRequestHeadersA(hRequest, lpszHeaders, dwHeadersLength,
                                dwModifiers))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrHttpAddRequestHeaders", hr);
    return hr;
}

HRESULT HrHttpSendRequestExA(IN HINTERNET hRequest,
                             IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
                             OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
                             IN DWORD dwFlags, IN DWORD_PTR dwContext)
{
    HRESULT     hr = S_OK;

    if (!HttpSendRequestExA(hRequest, lpBuffersIn, lpBuffersOut,
                            dwFlags, dwContext))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrHttpSendRequestEx", hr);
    return hr;
}

HRESULT HrHttpSendRequestA(IN HINTERNET hRequest, IN LPCSTR lpszHeaders OPTIONAL,
                           IN DWORD dwHeadersLength, IN LPVOID lpOptional OPTIONAL,
                           IN DWORD dwOptionalLength)
{
    HRESULT     hr = S_OK;

    if (!HttpSendRequestA(hRequest, lpszHeaders, dwHeadersLength, lpOptional,
                          dwOptionalLength))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrHttpSendRequest", hr);
    return hr;
}

HRESULT HrInternetWriteFile(IN HINTERNET hFile, IN LPCVOID lpBuffer,
                            IN DWORD dwNumberOfBytesToWrite,
                            OUT LPDWORD lpdwNumberOfBytesWritten)
{
    HRESULT     hr = S_OK;

    if (!InternetWriteFile(hFile, lpBuffer, dwNumberOfBytesToWrite,
                           lpdwNumberOfBytesWritten))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrInternetWriteFile", hr);
    return hr;
}

HRESULT HrHttpEndRequest(IN HINTERNET hRequest,
                         OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
                         IN DWORD dwFlags, IN DWORD_PTR dwContext)
{
    HRESULT     hr = S_OK;

    if (!HttpEndRequestA(hRequest, lpBuffersOut, dwFlags, dwContext))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrHttpEndRequest", hr);
    return hr;
}

HRESULT HrHttpQueryInfo(IN HINTERNET hRequest, IN DWORD dwInfoLevel,
                        IN OUT LPVOID lpBuffer OPTIONAL,
                        IN OUT LPDWORD lpdwBufferLength,
                        IN OUT LPDWORD lpdwIndex OPTIONAL)
{
    HRESULT     hr = S_OK;

    if (!HttpQueryInfoA(hRequest, dwInfoLevel, lpBuffer,
                        lpdwBufferLength, lpdwIndex))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorSkip1("HrHttpQueryInfo", hr,
                    HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    return hr;
}

HRESULT HrGetRequestUriA(LPCSTR szUrl, DWORD cbUri, LPSTR szUri)
{
    URL_COMPONENTSA urlComp = {0};
    HRESULT         hr = S_OK;

    // Parse the server name out of the URL
    //
    urlComp.dwStructSize = sizeof(URL_COMPONENTS);
    urlComp.lpszUrlPath = szUri;
    urlComp.dwUrlPathLength = cbUri;

    hr = HrInternetCrackUrlA(szUrl, 0, 0, &urlComp);

    TraceError("HrGetRequestUri", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\nccom.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O M . C P P
//
//  Contents:   Helper functions for doing COM things
//
//  Notes:
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "nccom.h"
#include "ncbase.h"
#include "trace.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrMyWaitForMultipleHandles
//
//  Purpose:    Waits for specified handles to be signaled or for a specified
//              timeout period to elapse, pumping messages in the meantime.
//              For use by apartment-threaded object that have to block,
//              but are on a system that doesn't support
//              CoWaitForMultipleHandles.
//
//  Arguments:
//      [in] dwFlags    Wait options.  Values are taken from the
//                      COWAIT_FLAGS enumeration.
//
//      [in] dwTimeout  Timeout period, in milliseconds.
//
//      [in] cHandles   Number of elements in the pHandles array.
//
//      [in] pHandles   Array of Win32 handles.
//
//      [out] lpdwIndex Index to the event that was signalled
//
//  Returns:     S_OK   The required handle or handles were signaled.
//  RPC_S_CALLPENDING   The timeout period elapsed before the required
//                      handle or handles were signaled.
//  RPC_E_NO_SYNC       No handles were specified.
//
//  Notes:      This code was basically stolen from the implementation
//              of CoWaitForMultipleHandles and KB article Q136885.
//              It is meant to look and work exactly like
//              CoWaitForMultipleHandles, which exists on nt5 but not
//              on Millennium
//              See KB article Q136885 for more info.
//

HRESULT HrMyWaitForMultipleHandles(DWORD dwFlags,
                                   DWORD dwTimeout,
                                   ULONG cHandles,
                                   LPHANDLE pHandles,
                                   LPDWORD lpdwIndex)
{
    HRESULT hr;
    DWORD dwSignaled;
    HANDLE     hTimer = NULL;
    ULONG      cNewHandles = 0;
    LPHANDLE   pNewHandles = NULL;

    hr = S_OK;
    dwSignaled = 0;

    if ((pHandles == NULL) || (lpdwIndex == NULL))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((dwFlags & ~(COWAIT_WAITALL | COWAIT_ALERTABLE)) != 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If nothing to do, return
    if (0 == cHandles)
    {
        hr = RPC_E_NO_SYNC;
        goto Cleanup;
    }

    {
        if (INFINITE != dwTimeout)
        {

            // Create a waitable timer to implement the timeout.
            hTimer = CreateWaitableTimer(NULL, TRUE, NULL);

            if (NULL == hTimer)
            {
                hr = HrFromLastWin32Error();
                TraceError("HrMyWaitForMultipleHandles(): "
                           "Failed to create waitable timer",
                           hr);
                goto Cleanup;
            }

            // We need to add the waitable timer to the list of things to wait
            // on. So we allocate a new array, copy the handles passed in into
            // it, and add the timer as the last handle.

            cNewHandles = cHandles+1;
            pNewHandles = new HANDLE[cNewHandles];

            if (NULL == pNewHandles)
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrMyWaitForMultipleHandles(): "
                           "Failed to allocate new handle array",
                           hr);
                goto Cleanup;
            }

            for (ULONG i = 0; i < cHandles; i++)
            {
                pNewHandles[i] = pHandles[i];
            }

            pNewHandles[cHandles] = hTimer;
        }
        else
        {
            pNewHandles = pHandles;
            cNewHandles = cHandles;
        }

        DWORD dwWaitFlags;
        DWORD dwMessageSignal;

        dwWaitFlags = (dwFlags & COWAIT_WAITALL) ? MWMO_WAITALL : 0;

        dwWaitFlags |= (dwFlags & COWAIT_ALERTABLE) ? MWMO_ALERTABLE : 0;

        dwMessageSignal = WAIT_OBJECT_0 + cNewHandles;

        if (INFINITE != dwTimeout)
        {
            // About to enter the wait - set the waitable timer. Have to first
            // convert the timeout, given in milliseconds to 100 nanosecond
            // units.

            LARGE_INTEGER liTimeout;

            liTimeout.QuadPart = Int32x32To64(((LONG)dwTimeout * -1), 10000);

            if (!SetWaitableTimer(hTimer, &liTimeout, 0, NULL, NULL, FALSE))
            {
                hr = HrFromLastWin32Error();
                TraceError("HrMyWaitForMultipleHandles(): "
                           "Failed to set waitable timer",
                           hr);
                goto Cleanup;
            }
        }

        while (TRUE)
        {

            // CAUTION: the messages that MsgWaitForMultipleObjectsEx will
            // wake up for (the QS_* flags) MUST be a subset of the messages
            // that PeekMessage will process (PM_QS_*), or the CPU can be
            // pegged.
            //

            dwSignaled = ::MsgWaitForMultipleObjectsEx(cNewHandles,
                                                       pNewHandles,
                                                       INFINITE,
                                                       QS_ALLINPUT,
                                                       dwWaitFlags);
#pragma warning(push)
#pragma warning(disable:4296)


            if ((dwSignaled >= WAIT_OBJECT_0) &&
                (dwSignaled < dwMessageSignal))
            {
                // One (or all) of our handles was signalled
                //

                dwSignaled -= WAIT_OBJECT_0;

                if ((cNewHandles > cHandles) && (dwSignaled == cHandles) )
                {
                    // The timer was signaled - this is a timeout. Fix up
                    // the error code.
                    hr = RPC_S_CALLPENDING;
                    dwSignaled = WAIT_TIMEOUT;
                }

                break;
            }

#pragma warning(pop)

            else if (dwMessageSignal == dwSignaled)
            {
                MSG msg;

                // There is a window message available. Dispatch it.
                //
                while (PeekMessage(&msg,
                                   NULL,
                                   NULL,
                                   NULL,
                                   PM_REMOVE))
                {
                    ::TranslateMessage(&msg);
                    ::DispatchMessage(&msg);
                }
            }
            else
            {
                Assert(FImplies(WAIT_IO_COMPLETION == dwSignaled,
                       dwFlags & COWAIT_ALERTABLE));

                hr = HrFromLastWin32Error();
                break;
            }
        }
    }

Cleanup:
    if (hTimer)
    {
        CancelWaitableTimer(hTimer);
        CloseHandle(hTimer);
    }

    if (pNewHandles && (pNewHandles != pHandles))
    {
        delete [] pNewHandles;
        cNewHandles = 0;
    }

    if (lpdwIndex)
    {
        *lpdwIndex = dwSignaled;
    }

    TraceError("MyWaitForMultipleHandles", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FSupportsInterface
//
//  Purpose:    Returns TRUE if the specified object implements the given
//              interface, FALSE otherwise.
//
//  Arguments:
//      [in] punk       IUnknown * of object to query for a particular
//                      interface.
//
//      [in] piid       IID for the interface of interest
//
//
//  Returns:
//      TRUE            The specified interface is supported
//
//      FALSE           The specified interface is not suppored
//
BOOL
FSupportsInterface(IUnknown * punk, REFIID piid)
{
    Assert(punk);

    HRESULT hr;
    BOOL fResult;
    IUnknown * punkTemp;

    fResult = FALSE;
    punkTemp = NULL;

    hr = punk->QueryInterface(piid, (LPVOID*)&punkTemp);
    if (SUCCEEDED(hr))
    {
        Assert(punkTemp);

        fResult = TRUE;

        punkTemp->Release();
    }

    if (hr != E_NOINTERFACE)
    {
        TraceError("FSupportsInterface, QI", hr);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncmem.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M E M . C P P
//
//  Contents:   Common memory management routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncmem.h"

// This global heap handle will be set to the process heap when the
// first request to allocate memory through MemAlloc is made.
//
HANDLE g_hHeap;

//+---------------------------------------------------------------------------
//
//  Function:   HrMalloc
//
//  Purpose:    HRESULT returning version of malloc.
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//      ppv [out]   Address of returned allocation.
//
//  Returns:    S_OK or E_OUTOFMEMORY;
//
//  Author:     shaunco   31 Mar 1998
//
//  Notes:      Free the returned buffer with free.
//
HRESULT
HrMalloc (
    size_t  cb,
    PVOID*  ppv)
{
    Assert (ppv);

    HRESULT hr = S_OK;

    *ppv = MemAlloc (cb);
    if (!*ppv)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMalloc");
    return hr;
}

VOID*
MemAlloc (
    size_t cb)
{
#ifdef USE_HEAP_ALLOC
    if (!g_hHeap)
    {
        g_hHeap = GetProcessHeap();
    }
    return HeapAlloc (g_hHeap, 0, cb);
#else
    return malloc (cb);
#endif
}

VOID*
MemAllocRaiseException (
    size_t  cb)
{
    VOID* pv = MemAlloc (cb);
    if (!pv)
    {
        RaiseException (E_OUTOFMEMORY, 0, 0, NULL);
    }
    return pv;
}

VOID
MemFree (
    VOID*   pv)
{
#ifdef USE_HEAP_ALLOC
    if (!g_hHeap)
    {
        g_hHeap = GetProcessHeap();
    }
    HeapFree (g_hHeap, 0, pv);
#else
    free (pv);
#endif
}

//+---------------------------------------------------------------------------
// CRT memory function overloads
//

const raiseexception_t raiseexception;

VOID*
__cdecl
operator new (
    size_t cb,
    const raiseexception_t&)
{
    Assert(FALSE);
    return MemAllocRaiseException (cb);
}


const extrabytes_t extrabytes;

VOID*
__cdecl
operator new (
    size_t cb,
    const extrabytes_t&,
    size_t cbExtra)
{
    return MemAlloc (cb + cbExtra);
}


VOID*
__cdecl
operator new (
    size_t cb)
{
    return MemAlloc (cb);
}

VOID
__cdecl
operator delete (
    VOID* pv)
{
    if (pv)
    {
        MemFree (pv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncmsz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M S Z . C P P
//
//  Contents:   Common multi-sz routines.
//
//  Notes:      Split out from ncstring.cpp
//
//  Author:     shaunco   7 Jun 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncstring.h"
#include "ncmsz.h"

//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs except for the final terminating
//              NULL.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzSafe (
    IN PCTSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    ULONG cchTotal = 0;
    ULONG cch;
    while (*pmsz)
    {
        cch = _tcslen (pmsz) + 1;
        cchTotal += cch;
        pmsz += cch;
    }

    // Return the count of characters.
    return cchTotal;
}


//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzAndTermSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzAndTermSafe (
    IN PCTSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    // Return the count of characters plus room for the
    // extra null terminator.
    return CchOfMultiSzSafe (pmsz) + 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsSzInMultiSzSafe
//
//  Purpose:    Determine if a given string is present in a Multi-Sz string
//              by doing a case insensitive compare.
//
//  Arguments:
//      psz     [in]  String to search for in pmsz
//      pmsz    [in]  The multi-sz to search
//
//  Returns:    TRUE if the specified string 'psz' was found in 'pmsz'.
//
//  Author:     scottbri   25 Feb 1997
//
//  Notes:      Note that the code can handle Null input values.
//
BOOL
FIsSzInMultiSzSafe (
    IN PCTSTR psz,
    IN PCTSTR pmsz)
{
    if (!pmsz || !psz)
    {
        return FALSE;
    }

    while (*pmsz)
    {
        if (0 == _tcsicmp (pmsz, psz))
        {
            return TRUE;
        }
        pmsz += _tcslen (pmsz) + 1;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetSzPositionInMultiSzSafe
//
//  Purpose:    Determine if a given string is present in a Multi-Sz string
//              by doing a case insensitive compare.
//
//  Arguments:
//      psz                [in]  String to search for in pmsz
//      pmsz               [in]  The multi-sz to search
//      pdwIndex           [out] The index of the first matching psz in pmsz
//      pfDuplicatePresent [out] Optional. TRUE if the string is present in
//                               the multi-sz more than once. FALSE otherwise.
//      pcStrings          [out] Optional. The number of strings in pmsz
//
//  Returns:    TRUE if the specified string 'psz' was found in 'pmsz'.
//
//  Author:     BillBe   9 Oct 1998
//
//  Notes:      Note that the code can handle Null input values.
//
BOOL
FGetSzPositionInMultiSzSafe (
    IN PCTSTR psz,
    IN PCTSTR pmsz,
    OUT DWORD* pdwIndex,
    OUT BOOL *pfDuplicatePresent,
    OUT DWORD* pcStrings)
{
    // initialize out params.
    //
    *pdwIndex = 0;

    if (pfDuplicatePresent)
    {
        *pfDuplicatePresent = FALSE;
    }

    if (pcStrings)
    {
        *pcStrings = 0;
    }

    if (!pmsz || !psz)
    {
        return FALSE;
    }

    // Need to keep track if duplicates are found
    BOOL fFoundAlready = FALSE;
    DWORD dwIndex = 0;

    while (*pmsz)
    {
        if (0 == _tcsicmp (pmsz, psz))
        {
            if (!fFoundAlready)
            {
                *pdwIndex = dwIndex;
                fFoundAlready = TRUE;
            }
            else if (pfDuplicatePresent)
            {
                *pfDuplicatePresent = TRUE;
            }
        }
        pmsz += _tcslen (pmsz) + 1;
        ++dwIndex;
    }

    if (pcStrings)
    {
        *pcStrings = dwIndex;
    }

    return fFoundAlready;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAddSzToMultiSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      pmszIn          [in]    (OPTIONAL) The original Multi-Sz to add to.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Ensure the string is the first element of
//                                  the list. If the string is present and
//                                  duplicates aren't allowed, move the
//                                  string to the end.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Ensure the string is the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.  If the
//                                  string is present and duplicates aren't
//                                  allowed, move the string to the end.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the multi-sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the multi-sz, the string will be
//                                  placed at the end.
//                              STRING_FLAG_DONT_MODIFY_IF_PRESENT
//                                  If the string already exists in the
//                                  multi-sz then no modication will take
//                                  place.  Note: This takes precedent
//                                  over the presence/non-presence of the
//                                  STRING_FLAG_ALLOW_DUPLICATES flag.
//                                  i.e nothing will be added or removed
//                                  if this flag is set and the string was
//                                  present in the multi-sz
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//      pmszOut         [out]   The new multi-sz.
//      pfChanged       [out]   TRUE if the multi-sz changed in any way,
//                              FALSE otherwise.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      6 Oct 1998
//              (Extracted from HrRegAddStringTo MultiSz and modified)
//
HRESULT
HrAddSzToMultiSz(
    IN PCTSTR pszAddString,
    IN PCTSTR pmszIn,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PTSTR* ppmszOut,
    OUT BOOL* pfChanged)
{
    Assert(pszAddString && *pszAddString);
    Assert(ppmszOut);
    Assert(pfChanged);

    HRESULT hr = S_OK;

    BOOL fEnsureAtFront = dwFlags & STRING_FLAG_ENSURE_AT_FRONT;
    BOOL fEnsureAtEnd = dwFlags & STRING_FLAG_ENSURE_AT_END;
    BOOL fEnsureAtIndex = dwFlags & STRING_FLAG_ENSURE_AT_INDEX;

    // Can't specify more than one of these flags
    if ((fEnsureAtFront && fEnsureAtEnd) ||
        (fEnsureAtFront && fEnsureAtIndex) ||
        (fEnsureAtEnd && fEnsureAtIndex))
    {
        AssertSz(FALSE, "Invalid flags in HrAddSzToMultiSz");
        return E_INVALIDARG;
    }

    // Must specify at least one
    if (!fEnsureAtFront && !fEnsureAtEnd && !fEnsureAtIndex)
    {
        AssertSz(FALSE, "No operation flag specified in HrAddSzToMultiSz");
        return E_INVALIDARG;
    }

    // Initialize the output parameters.
    //
    *ppmszOut = NULL;
    *pfChanged = TRUE;
    DWORD dwIndex;
    BOOL fDupePresent;
    DWORD cItems;

    // If the string to add is not empty...
    //
    if (*pszAddString)
    {
        // Check if the string is already present in the MultiSz
        BOOL fPresent = FGetSzPositionInMultiSzSafe (pszAddString, pmszIn,
                &dwIndex, &fDupePresent, &cItems);

        if (fPresent)
        {
            // If the flag don't modify is present then we aren't changing
            // anything
            //
            if (dwFlags & STRING_FLAG_DONT_MODIFY_IF_PRESENT)
            {
                *pfChanged = FALSE;
            }

            // if there are no duplicates present and we are not allowing
            // duplicates, then we need to determine if the string is already in
            // the correct position
            //
            if (!fDupePresent && !(dwFlags & STRING_FLAG_ALLOW_DUPLICATES))
            {
                // If we are to insert the string at front but it is already
                // there, then we aren't changing anything
                //
                if (fEnsureAtFront && (0 == dwIndex))
                {
                    *pfChanged = FALSE;
                }

                // If we are to insert the string at the end but it is already
                // there, then we aren't changing anything
                //
                if (fEnsureAtEnd && (dwIndex == (cItems - 1)))
                {
                    *pfChanged = FALSE;
                }

                if (fEnsureAtIndex && (dwIndex == dwStringIndex))
                {
                    *pfChanged = FALSE;
                }
            }
        }
    }
    else
    {
        // If string to add was empty so we aren't changing anything
        *pfChanged = FALSE;
    }


    // If we are still going to change things...
    //
    if (*pfChanged)
    {

        DWORD cchDataSize = CchOfMultiSzSafe (pmszIn);

        // Enough space for the old data plus the new string and NULL, and for the
        // second trailing NULL (multi-szs are double-terminated)
        DWORD cchAllocSize = cchDataSize + _tcslen (pszAddString) + 1 + 1;

        PTSTR pmszOrderNew = (PTSTR) MemAlloc(cchAllocSize * sizeof(TCHAR));

        if (pmszOrderNew)
        {
            // If we've gotten the "insert at front" flag, do the insert. Otherwise,
            // the default is "insert at end"
            //
            DWORD cchOffsetNew = 0;
            DWORD dwCurrentIndex = 0;
            if (fEnsureAtFront || (fEnsureAtIndex && (0 == dwStringIndex)))
            {
                // Insert our passed-in value at the beginning of the new buffer.
                //
                _tcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                cchOffsetNew += _tcslen ((PTSTR)pmszOrderNew) + 1;
                ++dwCurrentIndex;
            }

            // Loop through the old buffer, and copy all of the strings that are not
            // identical to our insertion string.
            //
            DWORD cchOffsetOld = 0;
            PTSTR pszCurrent;
            while ((cchOffsetOld + 1) < cchDataSize)
            {
                if (fEnsureAtIndex && (dwCurrentIndex == dwStringIndex))
                {
                    // Insert our passed-in value at the current index of the
                    // new buffer.
                    //
                    _tcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                    cchOffsetNew += _tcslen (pmszOrderNew + cchOffsetNew) + 1;
                    ++dwCurrentIndex;
                }
                else
                {
                    BOOL    fCopyThisElement    = FALSE;

                    // Get the next string in the list.
                    //
                    pszCurrent = (PTSTR) (pmszIn + cchOffsetOld);

                    // If we allow duplicates, then copy this element, else
                    // check for a match, and if there's no match, then
                    // copy this element.
                    if (dwFlags & STRING_FLAG_ALLOW_DUPLICATES)
                    {
                        fCopyThisElement = TRUE;
                    }
                    else
                    {
                        if (_tcsicmp (pszCurrent, pszAddString) != 0)
                        {
                            fCopyThisElement = TRUE;
                        }
                    }

                    // If we're allowing the copy, then copy!
                    if (fCopyThisElement)
                    {
                        _tcscpy (pmszOrderNew + cchOffsetNew, pszCurrent);
                        cchOffsetNew +=
                                _tcslen (pmszOrderNew + cchOffsetNew) + 1;
                        ++dwCurrentIndex;
                    }

                    // Update the offset
                    //
                    cchOffsetOld += _tcslen (pmszIn + cchOffsetOld) + 1;
                }
            }


            // If we have the ENSURE_AT_END flag set or if the ENSURE_AT_INDEX
            // flag was set and the index was greater than the possible
            // index, this means we want to insert at the end
            //
            if (fEnsureAtEnd ||
                    (fEnsureAtIndex && (dwCurrentIndex <= dwStringIndex)))
            {
                _tcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                cchOffsetNew += _tcslen (pmszOrderNew + cchOffsetNew) + 1;
            }

            // Put the last of the double-NULL chars on the end.
            //
            pszCurrent = pmszOrderNew + cchOffsetNew;
            pszCurrent[0] = (TCHAR) 0;

            *ppmszOut = pmszOrderNew;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError("HrAddSzToMultiSz", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateArrayOfStringPointersIntoMultiSz
//
//  Purpose:    Allocates and initializes an array of string pointers.
//              The array of pointers is initialized to point to the
//              individual strings in a multi-sz.
//
//  Arguments:
//      pmszSrc   [in]  The multi-sz to index.
//      pcStrings [out] Returned count of string pointers in the array.
//      papsz     [out] Returned array of string pointers.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   20 Jun 1998
//
//  Notes:      It is the callers responsibility to ensure there is at
//              least one string. The restriction is explicitly chosen to
//              reduce confusion about what would be returned if the
//              multi-sz were empty.
//
//              Free the returned array with free.
//
HRESULT
HrCreateArrayOfStringPointersIntoMultiSz (
    IN PCTSTR pmszSrc,
    OUT UINT* pcStrings,
    OUT PCTSTR** papsz)
{
    Assert (pmszSrc && *pmszSrc);
    Assert (papsz);

    // First, count the number of strings in the multi-sz.
    //
    UINT    cStrings = 0;
    PCTSTR pmsz;
    for (pmsz = pmszSrc; *pmsz; pmsz += _tcslen(pmsz) + 1)
    {
        cStrings++;
    }

    Assert (cStrings);  // See Notes above.
    *pcStrings = cStrings;

    // Allocate enough memory for the array.
    //
    HRESULT hr = HrMalloc (cStrings * sizeof(PTSTR*),
            reinterpret_cast<VOID**>(papsz));

    if (S_OK == hr)
    {
        // Initialize the returned array. ppsz is a pointer to each
        // element of the array.  It is incremented after each element
        // is initialized.
        //
        PCTSTR* ppsz = *papsz;

        for (pmsz = pmszSrc; *pmsz; pmsz += _tcslen(pmsz) + 1)
        {
            *ppsz = pmsz;
            ppsz++;
        }
    }

    TraceError ("HrCreateArrayOfStringPointersIntoMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveSzFromMultiSz
//
//  Purpose:    Remove all occurrences of a string from a multi-sz.  The
//              removals are performed in place.
//
//  Arguments:
//      psz       [in]     The string to remove.
//      pmsz      [in out] The multi-sz to remove psz from.
//      dwFlags   [in]     Can contain one or more of the following
//                         values:
//
//                         STRING_FLAG_REMOVE_SINGLE
//                             Don't remove more than one value, if
//                             multiple are present.
//                         [default] STRING_FLAG_REMOVE_ALL
//                             If multiple matching values are present,
//                             remove them all.
//      pfRemoved [out]    Set to TRUE on return if one or more strings
//                         were removed.
//
//  Returns:    nothing
//
//  Author:     shaunco   8 Jun 1998
//
//  Notes:
//
VOID
RemoveSzFromMultiSz (
    IN PCTSTR psz,
    IN OUT PTSTR pmsz,
    IN DWORD dwFlags,
    OUT BOOL* pfRemoved)
{
    Assert (pfRemoved);

    // Initialize the output parameters.
    //
    *pfRemoved = FALSE;

    if (!pmsz || !psz || !*psz)
    {
        return;
    }

    // Look for all occurrences of psz in pmsz.  When one is found, move
    // the remaining part of the multi-sz over it.
    //
    while (*pmsz)
    {
        if (0 == _tcsicmp (pmsz, psz))
        {
            PTSTR  pmszRemain = pmsz + (_tcslen (pmsz) + 1);
            INT    cchRemain = CchOfMultiSzAndTermSafe (pmszRemain);

            MoveMemory (pmsz, pmszRemain, cchRemain * sizeof(TCHAR));

            *pfRemoved = TRUE;

            if (dwFlags & STRING_FLAG_REMOVE_SINGLE)
            {
                break;
            }
        }
        else
        {
            pmsz += _tcslen (pmsz) + 1;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SzListToMultiSz
//
//  Purpose:    Converts a comma-separated list into a multi-sz style list.
//
//  Arguments:
//      psz     [in]    String to be converted. It is not modified.
//      pcb     [out]   Number of *bytes* in the resulting string. If NULL,
//                      size is not returned.
//      ppszOut [out]   Resulting string.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   3 Apr 1997
//
//  Notes:      Resulting string must be freed with MemFree.
//
VOID
SzListToMultiSz (
    IN PCTSTR psz,
    OUT DWORD* pcb,
    OUT PTSTR* ppszOut)
{
    Assert(psz);
    Assert(ppszOut);

    PCTSTR      pch;
    INT         cch;
    PTSTR       pszOut;
    const TCHAR c_chSep = L',';

    // Add 2 to the length. One for final NULL, and one for second NULL.
    cch = _tcslen (psz) + 2;

    pszOut = (PTSTR)MemAlloc(CchToCb(cch));
    if (pszOut)
    {
        ZeroMemory(pszOut, CchToCb(cch));

        if (pcb)
        {
            *pcb = CchToCb(cch);
        }

        *ppszOut = pszOut;

        // count the number of separator chars and put NULLs there
        //
        for (pch = psz; *pch; pch++)
        {
            if (*pch == c_chSep)
            {
                *pszOut++ = 0;
            }
            else
            {
                *pszOut++ = *pch;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncinet2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ncinet2.cpp
//
//  Contents:   Wrappers for some Urlmon APIs
//
//  Notes:
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <wininet.h>        // for ICU_NO_ENCODE
#include "ncinet2.h"
#include "ncstring.h"       // WszAllocateAndCopyWsz




// note: this uses Urlmon, where the other methods only pull in
//       wininet.

HRESULT
HrCombineUrl(LPCWSTR pszBaseUrl,
             LPCWSTR pszRelativeUrl,
             LPWSTR * ppszResult)
{
    const DWORD dwCombineFlags = ICU_NO_ENCODE;

    HRESULT hr;
    LPWSTR pszResult;
    WCHAR wcharTemp;
    DWORD cchNeeded;

    pszResult = NULL;
    cchNeeded = 0;
    wcharTemp = L'\0';

    if (!ppszResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pszBaseUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pszRelativeUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // we use this instead of InternetCombineUrl so that pluggable
    // protocols can do their thing.
    // we're assuming here that the arguments have the same semantics
    // as InternetCombineUrl(), as CoInternetCombineUrl is poorly
    // documented.

    // note: we don't know what the length of the combined URL is.
    //       instead of doing two allocations, we do a dummy call to
    //       CoInternetCombineUrl to find the needed length, allocate
    //       the string, and then call CoInternetCombineUrl "for real".

    hr = CoInternetCombineUrl(pszBaseUrl,
                              pszRelativeUrl,
                              dwCombineFlags,     // the url should already be encoded
                              &wcharTemp,
                              1,
                              &cchNeeded,
                              0);
    // note(cmr): MSDN says that CoInternetCombineUrl will return S_FALSE
    // if we don't have enough space in our buffer.  Its implementation,
    // though, generally calls UrlCombineW, which is supposed to return
    // E_POINTER in this case.
    // Emperically, E_POINTER is returned here.  This seems like a case of
    // MSDN just being wrong.  We'll expect both E_POINTER and S_FALSE
    // as return values here, to be safe.
    if ((E_POINTER != hr) && FAILED(hr))
    {
        TraceError("HrCombineUrl: CoInternetCombineUrl", hr);

        hr = E_FAIL;
        goto Cleanup;
    }
    else if ((S_FALSE == hr) || (E_POINTER == hr))
    {
        Assert(cchNeeded);

        DWORD cchWritten;

        cchWritten = 0;

        // call CoInternetCombineUrl for real.
        // cchNeeded includes the room for

        pszResult = new WCHAR[cchNeeded];
        if (!pszResult)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = CoInternetCombineUrl(pszBaseUrl,
                                  pszRelativeUrl,
                                  dwCombineFlags,   // the url should already be encoded
                                  pszResult,        // note: this is WRITTEN to...
                                  cchNeeded,        // note: should THIS value include the null-terminator?
                                  &cchWritten,
                                  0);
        TraceError("HrCombineUrl: CoInternetCombineUrl", hr);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            goto Error;
        }
        else if (S_FALSE == hr)
        {
            // this shouldn't have happened.  we had enough space.

            hr = E_UNEXPECTED;
            goto Error;
        }

        Assert(S_OK == hr);
        Assert((cchNeeded - 1) == cchWritten);
        Assert(L'\0' == pszResult[cchWritten]);
    }
    else
    {
        Assert(S_OK == hr);
        Assert(L'\0' == wcharTemp);
        // since the result needs to be null-terminated, the combined url
        // must be the empty string.  Wacky.  Let's allocate a string and
        // return it regardless.

        pszResult = new WCHAR [1];
        if (!pszResult)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        *pszResult =  L'\0';
    }

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), pszResult));
    Assert(FImplies(FAILED(hr), !pszResult));

    if (ppszResult)
    {
        *ppszResult = pszResult;
    }

    TraceError("HrCombineUrl", hr);
    return hr;

Error:
    if (pszResult)
    {
        delete [] pszResult;
        pszResult = NULL;
    }
    goto Cleanup;
}

// verifies that the given url is a valid url, and if it is,
// copies it into a newly-allocated string at ppszResult
// return values
//   S_OK       it's a valid url.  *ppszResult is a copy
//   S_FALSE    it's not a valid url.  *ppszResult is NULL
HRESULT
HrCopyAndValidateUrl(LPCWSTR pszUrl,
                     LPWSTR * ppszResult)
{
    HRESULT hr;
    LPWSTR pszResult;

    pszResult = NULL;

    if (!ppszResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pszUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // make sure the URL we're handing back is well-formed
    hr = IsValidURL(NULL, pszUrl, 0);
    TraceError("HrCopyAndValidateUrl: IsValidURL", hr);
    if (S_OK == hr)
    {
        // the url was valid

        pszResult = WszAllocateAndCopyWsz(pszUrl);
        if (!pszResult)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

Cleanup:
    Assert(FImplies(S_OK == hr, pszResult));
    Assert(FImplies(S_OK != hr, !pszResult));

    if (ppszResult)
    {
        *ppszResult = pszResult;
    }

    TraceError("HrCopyAndValidateUrl", hr);
    return hr;
}

// this returns the security domain of the url, if one exists.
// if one doesn't exist, it returns null
HRESULT
HrGetSecurityDomainOfUrl(LPCWSTR pszUrl,
                         LPWSTR * ppszResult)
{
    HRESULT hr;
    LPWSTR pszResult;

    pszResult = NULL;

    if (!ppszResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppszResult = NULL;
    hr = CoInternetGetSecurityUrl(pszUrl,
                                  &pszResult,
                                  PSU_DEFAULT,
                                  0);
    if (FAILED(hr))
    {
        TraceError("HrGetSecurityDomainOfUrl: CoInternetGetSecurityUrl", hr);
        goto Cleanup;
    }

    *ppszResult = pszResult;

Cleanup:
    TraceError("HrGetSecurityDomainOfUrl", hr);
    return hr;
}

// Returns TRUE if the scheme of the specified URL is "http"
// or "https", FALSE otherwise.
// note: we do this because I really can't justify writing
//       a bunch of code to call a urlmon function that contains
//       a bunch of code to call a wininet function to do this
//       strcmp.
BOOL
FIsHttpUrl(LPCWSTR pszUrl)
{
    Assert(pszUrl);

    CONST WCHAR rgchHttpScheme [] = L"http:";
    CONST size_t cchHttpScheme = celems(rgchHttpScheme) - 1;
    CONST WCHAR rgchHttpsScheme [] = L"https:";
    CONST size_t cchHttpsScheme = celems(rgchHttpsScheme) - 1;

    BOOL fResult;
    int result;

    fResult = FALSE;

    result = wcsncmp(rgchHttpScheme, pszUrl, cchHttpScheme);
    if (0 == result)
    {
        fResult = TRUE;
    }
    else
    {
        result = wcsncmp(rgchHttpsScheme, pszUrl, cchHttpsScheme);
        if (0 == result)
        {
            fResult = TRUE;
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncreg2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G 2 . C P P
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     CWill   27 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncerror.h"
#include "ncipaddr.h"
#include "ncmem.h"
#include "ncreg.h"
#include "ncstring.h"
#include <regstr.h>

static const WCHAR  c_szSubkeyServices[] = REGSTR_PATH_SERVICES;

const struct REG_TYPE_MAP
{
    DWORD   dwPsuedoType;
    DWORD   dwType;
};

REG_TYPE_MAP    c_rgrtmTypes[] =
{
    {REG_BOOL,  REG_DWORD},
    {REG_IP,    REG_SZ},
};



DWORD DwRealTypeFromPsuedoType(const DWORD dwPsuedoType)
{
    for (UINT cLoop = 0; cLoop < celems(c_rgrtmTypes); cLoop++)
    {
        if (dwPsuedoType == c_rgrtmTypes[cLoop].dwPsuedoType)
        {
            return c_rgrtmTypes[cLoop].dwType;
        }
    }

    return dwPsuedoType;
}

struct SPECIAL_KEY_MAP
{
    HKEY        hkeyPseudo;
    HKEY        hkeyRoot;
    PCWSTR      pszSubKey;
};

static const SPECIAL_KEY_MAP c_rgskmSpec[] =
{
    HKLM_SVCS,      HKEY_LOCAL_MACHINE,     c_szSubkeyServices,
};



//+---------------------------------------------------------------------------
//
//  Member:     HkeyTrueParent
//
//  Purpose:    To get a real handle to a key from a pseudo handle
//
//  Arguments:
//      hkeyIn          The pseudo key name
//      samDesired      The access requested of the key
//      rghkeySpec      An array of the special keys.
//
//  Returns:    The handle to the opened key or NULL
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
HKEY HkeyTrueParent(const HKEY hkeyIn, const REGSAM samDesired,
        HKEY rghkeySpec[])
{
    HKEY    hkeyRet     = hkeyIn;

    for (UINT cKey = 0; cKey < celems(c_rgskmSpec); cKey++)
    {
        // Check arb->hkey for one of "our" well known keys.
        if (c_rgskmSpec[cKey].hkeyPseudo == hkeyIn)
        {
            if (!rghkeySpec[cKey])
            {
                // First time a special key was used.  We need to cache it.
#ifdef DBG
                HRESULT hr =
#endif // DBG
                HrRegOpenKeyEx(
                        c_rgskmSpec[cKey].hkeyRoot,
                        c_rgskmSpec[cKey].pszSubKey,
                        samDesired,
                        &rghkeySpec[cKey]);

                // If we fail to open the key, make sure the output
                // parameter was nulled.  This will allow us to proceed
                // without really handling the error as hkeyParent
                // will be set to null below and the following
                // HrRegOpenKey will fail.  We will then handle the failure
                // of that.
                AssertSz(FImplies(FAILED(hr), !rghkeySpec[cKey]), "Key not NULL");
            }

            hkeyRet = rghkeySpec[cKey];
            break;
        }
    }

    return hkeyRet;
}



VOID RegSafeCloseKeyArray(HKEY rghkey[], UINT cElems)
{
    for (UINT cKey = 0; cKey < cElems; cKey++)
    {
        RegSafeCloseKey(rghkey[cKey]);
    }

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     TranslateFromRegToData
//
//  Purpose:    Translates the data retrieved from the registry to a the user
//              data's storage format
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          Where the data gets stored
//      pbBuf           A buffer that stores the registry data
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID TranslateFromRegToData(DWORD dwType, BYTE* pbData, BYTE* pbBuf)
{
     // Take the data from the registry and happily convert it into
     // usable data
    switch (dwType)
    {

#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the stringized form of the ip address
        // into a DWORD.  (The actual 32-bit IP address.)
        DWORD dwIpAddr = IpPszToHostAddr((WCHAR*)pbBuf);
        *((DWORD*)pbData) = dwIpAddr;
        break;
    }

    case REG_BOOL:
    {
        // Form the boolean as 'TRUE' or 'FALSE' based on
        // whether the data is non-zero or zero respectively.
        DWORD   dwData = *((DWORD*)pbBuf);
        *((BOOL*)pbData) = (!!dwData);
        break;
    }

    case REG_DWORD:
    {
        // DWORDs are direct assignments
        *((DWORD*)pbData) = *((DWORD*)pbBuf);
        break;
    }

    case REG_SZ:
    {
        // Make a copy of the string
        *((PWSTR*) pbData) = SzDupSz((PWSTR)pbBuf);
        break;
    }
    }

    return;
}



inline VOID UseDefaultRegValue(DWORD dwType, BYTE* pbData, BYTE* pbDefault)
{
    AssertSz((pbData && pbDefault), "UseDefaultRegValue : Invalid params");
    AssertSz(pbDefault, "There is no default registry value");

    TranslateFromRegToData(dwType, pbData, pbDefault);

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     CbSizeOfDataToReg
//
//  Purpose:    To determine the size of buffer needed to store the data
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          The data that has to be translated
//
//  Returns:    The size of buffer need to store the data
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
DWORD CbSizeOfDataToReg(DWORD dwType, const BYTE* pbData)
{
    DWORD cbData = 0;

    switch (dwType)
    {
#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the 32-bit IP address to a stringized form.
        DWORD dwIpAddr = *((DWORD*)pbData);

        WCHAR pszIpAddr [32];
        IpHostAddrToPsz(dwIpAddr, pszIpAddr);

        cbData = CbOfSzAndTerm(pszIpAddr);
        break;
    }

    // Boolean values are stored as DWORDs
    case REG_BOOL:
    case REG_DWORD:
    {
        cbData = sizeof(DWORD);
        break;
    }

    case REG_SZ:
    case REG_EXPAND_SZ:
    {
        cbData = CbOfSzAndTerm(*((PCWSTR*)pbData));
        break;
    }
    }

    AssertSz(cbData, "We should have a size");

    return cbData;
}



//+---------------------------------------------------------------------------
//
//  Member:     TranslateFromDataToReg
//
//  Purpose:    Translates user data to a format the can be stored in the
//              registry
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          The data that has to be translated
//      pbBuf           A buffer that stores the registry data
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID
TranslateFromDataToReg(
    IN DWORD dwType,
    IN const BYTE* pbData,
    OUT const BYTE* pbBuf)
{
    switch (dwType)
    {
#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the 32-bit IP address to a stringized form.
        DWORD dwIpAddr = *((DWORD*)pbData);

        WCHAR pszIpAddr [32];
        IpHostAddrToPsz (dwIpAddr, pszIpAddr);

        // Copy the string
        lstrcpyW((PWSTR)pbBuf, pszIpAddr);
        break;
    }

    case REG_BOOL:
    {
        // Form the boolean as 'TRUE' or 'FALSE' based on
        // whether the data is non-zero or zero respectively.
        DWORD   dwData = *((DWORD*)pbData);
        *((BOOL*)pbBuf) = (!!dwData);
        break;
    }

    case REG_DWORD:
    {
        // DWORDs are direct assignments
        *((DWORD*)pbBuf) = *((DWORD*)pbData);
        break;
    }

    case REG_SZ:
    case REG_EXPAND_SZ:
    {
        // Make a copy of the string
        lstrcpyW((PWSTR)pbBuf, *((PCWSTR*)pbData));

        AssertSz(CbOfSzAndTerm(*((PCWSTR*)pbData)), "Zero length string");
        break;
    }
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     RegReadValues
//
//  Purpose:    To read a table of information from the registry into a user
//              defined data structure.
//
//  Arguments:
//      crb             The count of entries in the REGBATCH structure
//      arb             The pointer to the REGBATCH structure
//      pbUserData      The pointer to the source structure that is to retrieve
//                      the data from the registry
//      samDesired      The requested key access mask
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID RegReadValues(
    IN INT crb,
    IN const REGBATCH* arb,
    OUT const BYTE* pbUserData,
    IN REGSAM samDesired)
{
    AssertSz(FImplies(crb, arb), "Count without an array");

    HRESULT                 hr                                  = S_OK;
    const REGBATCH*         prbLast                             = NULL;
    HKEY                    rghkeySpec[celems(c_rgskmSpec)]     = {0};
    HKEY                    hkey                                = NULL;

    while (crb--)
    {
        BYTE*   pbData = (BYTE*)(pbUserData + arb->cbOffset);

        // Open the key if we need to.
        // We don't need to if it was the same as the previous one used.
        if ((!prbLast )
            || (prbLast->hkey != arb->hkey)
            || (prbLast->pszSubkey != arb->pszSubkey))
        {
            HKEY    hkeyParent;

            hkeyParent = HkeyTrueParent (arb->hkey, samDesired, rghkeySpec);

            // Close the previous key we used.
            RegSafeCloseKey (hkey);

            // Open the new key.
#ifdef DBG
            hr =
#endif // DBG
            HrRegOpenKeyEx (hkeyParent, arb->pszSubkey, samDesired, &hkey);
            AssertSz(FImplies(FAILED(hr), !hkey), "HrRegOpenKey not NULLing");
        }

        // Only continue if we have a key.
        if (hkey)
        {
            DWORD   dwType = arb->dwType;

            // We can't read NULL registry values
            if (REG_CREATE != dwType)
            {
                DWORD   cbData      = 0;
                BYTE*   pbStack     = NULL;
                DWORD   dwRealType  = DwRealTypeFromPsuedoType(dwType);

                // Ensure that we fail the first time around so that we can see how
                // big a buffer is needed
                (VOID) HrRegQueryValueEx(hkey, arb->pszValueName, &dwRealType,
                        NULL, &cbData);

                // Allocate memory on the stack to serve as our temporary buffer.
#ifndef STACK_ALLOC_DOESNT_WORK
                pbStack = (BYTE*)MemAlloc (cbData);
#else // !STACK_ALLOC_DOESNT_WORK
                pbStack = (BYTE*)PvAllocOnStack(cbData);
#endif // !STACK_ALLOC_DOESNT_WORK

                hr = HrRegQueryValueEx(hkey, arb->pszValueName, &dwRealType,
                        pbStack, &cbData);

                if (S_OK == hr)
                {
                    // Make sure its the type we were expecting.
                    AssertSz((dwRealType == DwRealTypeFromPsuedoType(dwType)),
                            "Value types do no match");

                    TranslateFromRegToData(dwType, pbData, pbStack);
                }
                else
                {
                    UseDefaultRegValue(dwType, pbData, arb->pbDefault);

                    TraceHr (ttidError, FAL, hr,
                        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
                        "RegReadValues: Could not open value %S", arb->pszValueName);
                }
#ifndef STACK_ALLOC_DOESNT_WORK
                MemFree (pbStack);
#endif // STACK_ALLOC_DOESNT_WORK
            }
        }
        else
        {
            TraceTag(ttidError, "RegReadValues: NULL key for %S", arb->pszSubkey);
            UseDefaultRegValue(arb->dwType, pbData, arb->pbDefault);
        }

        // Advance prbLast or set it to the first one if this is the
        // first time through.
        if (prbLast)
        {
            prbLast++;
        }
        else
        {
            prbLast = arb;
        }

        arb++;
    }

    // Clean up
    RegSafeCloseKey(hkey);
    RegSafeCloseKeyArray(rghkeySpec, celems(rghkeySpec));

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrRegWriteValues
//
//  Purpose:    To write a table of information to the registry from a user
//              defined data structure.
//
//  Arguments:
//      crb             The count of entries in the REGBATCH structure
//      arb             The pointer to the REGBATCH structure
//      pbUserData      The pointer to the source structure that provides
//                      the data that is to be written to the registry
//      dwOptions       Options to be used when creating the registry keys
//      samDesired      The requested key access mask
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
HRESULT HrRegWriteValues(
        INT crb,
        const REGBATCH* arb,
        const BYTE* pbUserData,
        DWORD dwOptions,
        REGSAM samDesired)
{
    AssertSz(FImplies(crb, arb), "HrWriteValues : Count with no array");

    HRESULT                 hr                                  = S_OK;
    const REGBATCH*         prbLast                             = NULL;
    HKEY                    hkey                                = NULL;
    HKEY                    rghkeySpec[celems(c_rgskmSpec)]     = {0};

    while (crb--)
    {
        BYTE*   pbData = const_cast<BYTE*>(pbUserData + arb->cbOffset);

        // Open the key if we need to.
        // We don't need to if it was the same as the previous one used.
        if ((!prbLast)
            || (prbLast->hkey != arb->hkey)
            || (prbLast->pszSubkey != arb->pszSubkey))
        {
            HKEY    hkeyParent;

            hkeyParent = HkeyTrueParent(arb->hkey, samDesired, rghkeySpec);

            // Close the previous key we used.
            RegSafeCloseKey(hkey);

            // Open the new key.
            DWORD dwDisposition;
            hr = HrRegCreateKeyEx(hkeyParent, arb->pszSubkey, dwOptions,
                    samDesired, NULL, &hkey, &dwDisposition);

            AssertSz(FImplies(FAILED(hr), !hkey), "HrRegCreateKey not NULLing");

            if (FAILED(hr))
            {
                TraceError("HrRegWriteValues: failed to open parent key", hr);
                break;
            }
        }

        // Should definately have hkey by now.
        AssertSz(hkey, "Why no key?");

        //
        // Format the data to be put into the registry
        //

        DWORD   dwType  = arb->dwType;

        // If all we want to do is create the key, then we are already done.
        if (REG_CREATE != dwType)
        {
            DWORD           dwRealType  = DwRealTypeFromPsuedoType(dwType);
            DWORD           cbReg       = CbSizeOfDataToReg(dwType, pbData);
            BYTE*           pbReg       = NULL;

            AssertSz(cbReg, "We must have some data");

#ifndef STACK_ALLOC_DOESNT_WORK
            pbReg = new BYTE[cbReg];
#else // !STACK_ALLOC_DOESNT_WORK
            pbReg = reinterpret_cast<BYTE*>(PvAllocOnStack(cbReg));
#endif // !STACK_ALLOC_DOESNT_WORK

            TranslateFromDataToReg(dwType, pbData, pbReg);

            // Write the data to the registry.
            hr = HrRegSetValueEx(
                    hkey,
                    arb->pszValueName,
                    dwRealType,
                    pbReg,
                    cbReg);

#ifndef STACK_ALLOC_DOESNT_WORK
            // Must have this call before the break
            delete [] pbReg;
#endif // STACK_ALLOC_DOESNT_WORK

        }

        if (FAILED(hr))
        {
            break;
        }

        // Advance prbLast or set it to the first one if this is the
        // first time through.
        if (prbLast)
        {
            prbLast++;
        }
        else
        {
            prbLast = arb;
        }

        arb++;
    }

    RegSafeCloseKey(hkey);
    RegSafeCloseKeyArray(rghkeySpec, celems(rghkeySpec));

    TraceError("HrWriteValues", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrRegWriteValueTable
//
//  Purpose:    To write a table of values to the registry from a user
//              defined data structure.
//
//  Arguments:
//      hkeyRoot        The key to which the values are written
//      cvt             The count of entries in the VALUETABLE structure
//      avt             The pointer to the VALUETABLE structure
//      pbUserData      The pointer to the source structure that provides
//                      the data that is to be written to the registry
//      dwOptions       Options to be used when creating the registry keys
//      samDesired      The requested key access mask
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill   06/26/97
//
//  Notes:
//
HRESULT HrRegWriteValueTable(
        HKEY hkeyRoot,
        INT cvt,
        const VALUETABLE* avt,
        const BYTE* pbUserData,
        DWORD dwOptions,
        REGSAM samDesired)
{
    HRESULT             hr          = S_OK;

    while (cvt--)
    {
        BYTE*   pbData  = NULL;
        DWORD   dwType  = REG_NONE;

        //
        // Format the data to be put into the registry
        //

        dwType = avt->dwType;
        pbData = const_cast<BYTE*>(pbUserData + avt->cbOffset);

        // If all we want to do is create the key, then we are already done.
        if (REG_CREATE != dwType)
        {
            DWORD           dwRealType  = DwRealTypeFromPsuedoType(dwType);
            DWORD           cbReg       = CbSizeOfDataToReg(dwType, pbData);
            BYTE*           pbReg       = NULL;

            AssertSz(cbReg, "We must have some data");

#ifndef STACK_ALLOC_DOESNT_WORK
            pbReg = new BYTE[cbReg];
#else // !STACK_ALLOC_DOESNT_WORK
            pbReg = reinterpret_cast<BYTE*>(PvAllocOnStack(cbReg));
#endif // !STACK_ALLOC_DOESNT_WORK

            TranslateFromDataToReg(dwType, pbData, pbReg);

            // Write the data to the registry.
            hr = HrRegSetValueEx(
                    hkeyRoot,
                    avt->pszValueName,
                    dwRealType,
                    pbReg,
                    cbReg);

#ifndef STACK_ALLOC_DOESNT_WORK
            // Must have this call before the break
            delete [] pbReg;
#endif // STACK_ALLOC_DOESNT_WORK
        }

        if (FAILED(hr))
        {
            break;
        }

        avt++;
    }

    TraceError("HrRegWriteValueTable", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncstring2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G 2 . C P P
//
//  Contents:   Common string routines that deal with COM functions
//
//  Notes:      This is a separate file because some parts of UPnP do not
//              link with ole32 and so the COM functions give link errors.
//
//  Author:     danielwe 27 Sep 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   COMSzFromWsz
//
//  Purpose:    Returns a string allocated with CoTaskMemAlloc(), containing
//              the same characters as an input string.
//
//  Arguments:
//      szOld [in]  String to duplicate
//
//  Returns:    Newly allocated copy
//
//  Author:     spather 26 Sep 2000
//
//  Notes:      Caller must free result with CoTaskMemFree
//
LPWSTR COMSzFromWsz(LPCWSTR szOld)
{
    LPWSTR  szNew;

    szNew = (LPWSTR) CoTaskMemAlloc((lstrlen(szOld) + 1) * sizeof(WCHAR));

    if (szNew)
    {
        lstrcpy(szNew, szOld);
    }

    return szNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G . C P P
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncreg.h"
#include "ncstring.h"
//#include "ncperms.h"

extern const TCHAR c_szBackslash[];
extern const TCHAR c_szParameters[];
extern const TCHAR c_szRegKeyServices[];

//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToMultiSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Ensure the string is the first element of
//                                  the list. If the string is present and
//                                  duplicates aren't allowed, move the
//                                  string to the end.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Ensure the string is the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.  If the
//                                  string is present and duplicates aren't
//                                  allowed, move the string to the end.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the multi-sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the multi-sz, the string will be
//                                  placed at the end.
//                              STRING_FLAG_DONT_MODIFY_IF_PRESENT
//                                  If the string already exists in the
//                                  multi-sz then no modication will take
//                                  place.  Note: This takes precedent
//                                  over the presence/non-presence of the
//                                  STRING_FLAG_ALLOW_DUPLICATES flag.
//                                  i.e nothing will be added or removed
//                                  if this flag is set and the string was
//                                  present in the multi-sz
//      dwIndex         [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
HRESULT
HrRegAddStringToMultiSz (
    IN PCTSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCTSTR  pszKeySubPath,
    IN PCTSTR  pszValueName,
    IN DWORD   dwFlags,
    IN DWORD   dwIndex)
{
    HRESULT     hr              = S_OK;
    DWORD       dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY        hkeyOpen        = NULL;     // Return value from RegCreateKeyEx
    HKEY        hkeyUse         = NULL;     // The key value that we'll actually use
    LPBYTE      pbOrderOld      = NULL;     // Return buffer for order reg value
    LPBYTE      pbOrderNew      = NULL;     // Build buffer for order swap

    // Check for valid parameters
    if (!pszAddString || !hkeyRoot || !pszValueName)
    {
        Assert(pszAddString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_REMOVE_SINGLE)      ||
        (dwFlags & STRING_FLAG_REMOVE_ALL)         ||
        ((dwFlags & STRING_FLAG_ENSURE_AT_FRONT)   &&
         (dwFlags & STRING_FLAG_ENSURE_AT_END)))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToMultiSz");

        hr = E_INVALIDARG;
        goto Exit;
    }

    // If the user passed in a subkey string, then we should attempt to open
    // the subkey of the passed in root, else we'll just use the
    // pre-opened hkeyRoot
    //
    if (pszKeySubPath)
    {
        // Open the key, creating if necessary
        //
        hr = HrRegCreateKeyEx (
                hkeyRoot,                           // Base hive
                pszKeySubPath,                      // Our reg path
                0,                                  // dwOptions
                KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
                NULL,                               // lpSecurityAttributes
                &hkeyOpen,                          // Our return hkey.
                NULL);
        if (FAILED(hr))
        {
            goto Exit;
        }

        hkeyUse = hkeyOpen;
    }
    else
    {
        // Use the passed in key for the Query.
        //
        hkeyUse = hkeyRoot;
    }

    // Retrieve the existing REG_MULTI_SZ
    //
    hr = HrRegQueryValueWithAlloc (
            hkeyUse,
            pszValueName,
            &dwRegType,
            &pbOrderOld,
            NULL);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value was missing, and we
            // should continue on, and create the value ourselves.
            hr = S_OK;
        }
        else
        {
            // Since there's an error that we didn't expect, drop out,
            // returning this error to the caller.
            //
            goto Exit;
        }
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_MULTI_SZ)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
            goto Exit;
        }
    }

    BOOL fChanged;
    hr = HrAddSzToMultiSz (pszAddString, (PCTSTR)pbOrderOld,
            dwFlags, dwIndex, (PTSTR*)&pbOrderNew, &fChanged);

    if ((S_OK == hr) && fChanged)
    {
        DWORD cbNew = CbOfMultiSzAndTermSafe ((PTSTR)pbOrderNew);

        // Save our string back into the registry
        //
        hr = HrRegSetValueEx (
                hkeyUse,
                pszValueName,
                REG_MULTI_SZ,
                (const BYTE *)pbOrderNew,
                cbNew);
    }

Exit:
    // Close the key, if opened
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pbOrderOld);
    MemFree (pbOrderNew);

    TraceError ("HrRegAddStringToMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '. This will
//                              be used to delimit the value that we add,
//                              as well.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Insert the string as the first element of
//                                  the list.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Insert the string as the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the sz, the string will be
//                                  placed at the end.
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRegAddStringToSz (
    IN PCTSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCTSTR  pszKeySubPath,
    IN PCTSTR  pszValueName,
    IN TCHAR   chDelimiter,
    IN DWORD   dwFlags,
    IN DWORD   dwStringIndex)
{
    HRESULT    hr              = S_OK;
    DWORD      dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY       hkeyOpen        = NULL;     // Open key to open
    PTSTR      pszOrderOld     = NULL;     // Return buffer for order reg value
    PTSTR      pszOrderNew     = NULL;     // Build buffer for order swap

    // Check for all of the required args
    //
    if (!pszAddString || !hkeyRoot || !pszValueName)
    {
        Assert(pszAddString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_REMOVE_SINGLE) ||
        (dwFlags & STRING_FLAG_REMOVE_ALL))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToSz");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Open the key, creating if necessary
    //
    hr = HrRegCreateKeyEx(
            hkeyRoot,                           // Base hive
            pszKeySubPath,                      // Our reg path
            0,                                  // dwOptions
            KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
            NULL,                               // lpSecurityAttributes
            &hkeyOpen,                          // Our return hkey.
            NULL);
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc(
            hkeyOpen,
            pszValueName,
            &dwRegType,
            (LPBYTE *) &pszOrderOld,
            NULL);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }
        else
        {
            goto Exit;
        }
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Exit;
        }
    }

    hr = HrAddStringToDelimitedSz(pszAddString, pszOrderOld, chDelimiter,
            dwFlags, dwStringIndex, &pszOrderNew);

    if (S_OK == hr)
    {

        // Save our string back into the registry
        //
        hr = HrRegSetSz(hkeyOpen, pszValueName, pszOrderNew);
        if (FAILED(hr))
        {
            goto Exit;
        }
    }

Exit:
    // Close the key, if open
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pszOrderOld);
    MemFree (pszOrderNew);

    TraceError ("HrRegAddStringToSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromSz
//
//  Purpose:    Removes a string from a REG_SZ registry value
//
//  Arguments:
//      pszRemoveString [in]    The string to be removed from the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_REMOVE_SINGLE
//                                  Don't remove more than one value, if
//                                  multiple are present.
//                              STRING_FLAG_REMOVE_ALL
//                                  If multiple matching values are present,
//                                  remove them all.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRegRemoveStringFromSz (
    IN PCTSTR pszRemoveString,
    IN HKEY hkeyRoot,
    IN PCTSTR pszKeySubPath,
    IN PCTSTR pszValueName,
    IN TCHAR chDelimiter,
    IN DWORD dwFlags )
{
    HRESULT     hr              = S_OK;
    DWORD       dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY        hkeyOpen        = NULL;     // Open key to open
    PTSTR       pszOrderOld     = NULL;     // Return buffer for order reg value
    PTSTR       pszOrderNew     = NULL;     // Build buffer for order swap
    DWORD       dwDataSize      = 0;

    // Check for all of the required args
    //
    if (!pszRemoveString || !hkeyRoot || !pszValueName)
    {
        Assert(pszRemoveString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_ENSURE_AT_FRONT)    ||
        (dwFlags & STRING_FLAG_ENSURE_AT_END)      ||
        ((dwFlags & STRING_FLAG_REMOVE_SINGLE)     &&
         (dwFlags & STRING_FLAG_REMOVE_ALL)))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToSz");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Open the key, creating if necessary
    //
    hr = HrRegOpenKeyEx (
            hkeyRoot,                           // Base hive
            pszKeySubPath,                      // Our reg path
            KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
            &hkeyOpen);                         // Our return hkey
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
        }
        goto Exit;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc (
            hkeyOpen,
            pszValueName,
            &dwRegType,
            (LPBYTE *) &pszOrderOld,
            &dwDataSize);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }
        goto Exit;
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a REG_SZ
        //
        if (dwRegType != REG_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Exit;
        }

        if (dwDataSize == 0)
        {
            // This is OK, but we're going to assert here anyway, because this is not
            // a case that I know about
            //
            AssertSz(dwDataSize > 0, "How did we retrieve something from the "
                    "registry with 0 size?");

            hr = S_OK;
            goto Exit;
        }
    }

    hr = HrRemoveStringFromDelimitedSz (pszRemoveString, pszOrderOld,
            chDelimiter, dwFlags, &pszOrderNew);

    if (S_OK == hr)
    {
        // Save our string back into the registry
        //
        hr = HrRegSetSz (hkeyOpen, pszValueName, pszOrderNew);
    }

Exit:
    // Close the key, if open
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pszOrderOld);
    MemFree (pszOrderNew);

    TraceError("HrRegRemoveStringFromSz", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromMultiSz
//
//  Purpose:    Removes the specified string from a multi-sz, if it is present.
//
//  Arguments:
//      pszRemoveString [in]
//      hkeyRoot        [in]
//      pszKeySubPath   [in]
//      pszValueName    [in]
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_REMOVE_SINGLE
//                                  Don't remove more than one value, if
//                                  multiple are present.
//                              [default] STRING_FLAG_REMOVE_ALL
//                                  If multiple matching values are present,
//                                  remove them all.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     ScottBri 11-Apr-1997
//
//  Notes:
//
HRESULT
HrRegRemoveStringFromMultiSz (
    IN PCTSTR  pszRemoveString,
    IN HKEY    hkeyRoot,
    IN PCTSTR  pszKeySubPath,
    IN PCTSTR  pszValueName,
    IN DWORD   dwFlags)
{
    DWORD   dwDataSize;
    DWORD   dwRegType;
    HKEY    hkey = NULL;
    HKEY    hkeyUse = hkeyRoot;
    HRESULT hr;
    PTSTR   psz = NULL;

    // Valid the input parameters
    if ((NULL == pszRemoveString) || (NULL == pszValueName) ||
        (NULL == hkeyRoot))
    {
        Assert(NULL != pszRemoveString);
        Assert(NULL != pszValueName);
        Assert(NULL != hkeyRoot);
        return E_INVALIDARG;
    }

    if ((STRING_FLAG_REMOVE_SINGLE & dwFlags) &&
        (STRING_FLAG_REMOVE_ALL & dwFlags))
    {
        AssertSz(FALSE, "Can't specify both 'remove all' and 'remove single'");
        return E_INVALIDARG;
    }

    if (NULL != pszKeySubPath)
    {
        hr = HrRegOpenKeyEx (hkeyRoot, pszKeySubPath, KEY_ALL_ACCESS, &hkey);
        if (S_OK != hr)
        {
            return hr;
        }

        hkeyUse = hkey;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc (hkeyUse, pszValueName, &dwRegType,
                                    (LPBYTE *)&psz, &dwDataSize);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr)
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }

        goto Done;
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_MULTI_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Done;
        }
    }

    // Search for and extract the specified string if present
    Assert(psz);
    BOOL fRemoved;
    RemoveSzFromMultiSz (pszRemoveString, psz, dwFlags, &fRemoved);

    // Rewrite the registry value if it was changed
    if (fRemoved)
    {
        dwDataSize = CbOfMultiSzAndTermSafe (psz);
        hr = HrRegSetValueEx (hkeyUse, pszValueName, REG_MULTI_SZ,
                               (const LPBYTE)psz, dwDataSize);
    }

Done:
    RegSafeCloseKey (hkey);
    MemFree (psz);

    TraceError ("HrRegRemoveStringFromMultiSz", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRegCreateKeyEx
//
//  Purpose:    Creates a registry key by calling RegCreateKeyEx.
//
//  Arguments:
//      hkey                 [in]
//      pszSubkey            [in]
//      dwOptions            [in]   See the Win32 documentation for the
//      samDesired           [in]   RegCreateKeyEx function.
//      lpSecurityAttributes [in]
//      phkResult            [out]
//      pdwDisposition       [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCTSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    LONG lr = RegCreateKeyEx (hkey, pszSubkey, 0, NULL, dwOptions, samDesired,
            lpSecurityAttributes, phkResult, pdwDisposition);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceError("HrRegCreateKeyEx", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKey
//
//  Purpose:    Delete the specified registry key.
//
//  Arguments:
//      hkey     [in]   See the Win32 documentation for the RegDeleteKey.
//      pszSubkey [in]   function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
HRESULT
HrRegDeleteKey (
    IN HKEY hkey,
    IN PCTSTR pszSubkey)
{
    Assert (hkey);
    Assert (pszSubkey);

    LONG lr = RegDeleteKey (hkey, pszSubkey);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceHr (ttidError, FAL, hr, ERROR_FILE_NOT_FOUND == lr,
        "HrRegDeleteKey");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKeyTree
//
//  Purpose:    Deletes an entire registry hive.
//
//  Arguments:
//      hkeyParent  [in]   Handle to open key where the desired key resides.
//      pszRemoveKey [in]   Name of key to delete.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCTSTR pszRemoveKey)
{
    Assert (hkeyParent);
    Assert (pszRemoveKey);

    // Open the key we want to remove
    HKEY hkeyRemove;
    HRESULT hr = HrRegOpenKeyEx(hkeyParent, pszRemoveKey, KEY_ALL_ACCESS,
            &hkeyRemove);

    if (S_OK == hr)
    {
        TCHAR       szValueName [MAX_PATH];
        DWORD       cchBuffSize = MAX_PATH;
        FILETIME    ft;
        LONG        lr;

        // Enum the keys children, and remove those sub-trees
        while (ERROR_SUCCESS == (lr = RegEnumKeyEx (hkeyRemove,
                0,
                szValueName,
                &cchBuffSize,
                NULL,
                NULL,
                NULL,
                &ft)))
        {
            HrRegDeleteKeyTree (hkeyRemove, szValueName);
            cchBuffSize = MAX_PATH;
        }
        RegCloseKey (hkeyRemove);

        if ((ERROR_SUCCESS == lr) || (ERROR_NO_MORE_ITEMS == lr))
        {
            lr = RegDeleteKey (hkeyParent, pszRemoveKey);
        }

        hr = HRESULT_FROM_WIN32 (lr);
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
            "HrRegDeleteKeyTree");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteValue
//
//  Purpose:    Deletes the given registry value.
//
//  Arguments:
//      hkey        [in]    See the Win32 documentation for the RegDeleteValue
//      pszValueName [in]    function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCTSTR pszValueName)
{
    Assert (hkey);
    Assert (pszValueName);

    LONG lr = RegDeleteValue (hkey, pszValueName);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceErrorOptional("HrRegDeleteValue", hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumKeyEx
//
//  Purpose:    Enumerates subkeys of the specified open registry key.
//
//  Arguments:
//      hkey             [in]
//      dwIndex          [in]   See the Win32 documentation for the
//      pszSubkeyName    [out]  RegEnumKeyEx function.
//      pcchSubkeyName   [inout]
//      pszClass         [out]
//      pcchClass        [inout]
//      pftLastWriteTime [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PTSTR  pszSubkeyName,
    IN OUT LPDWORD pcchSubkeyName,
    OUT PTSTR  pszClass,
    IN OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime)
{
    Assert (hkey);
    Assert (pszSubkeyName);
    Assert (pcchSubkeyName);
    Assert (pftLastWriteTime);

    LONG lr = RegEnumKeyEx (hkey, dwIndex, pszSubkeyName, pcchSubkeyName,
                            NULL, pszClass, pcchClass, pftLastWriteTime);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceHr (ttidError, FAL, hr, ERROR_NO_MORE_ITEMS == lr,
            "HrRegEnumKeyEx");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumValue
//
//  Purpose:    Enumerates the values for the specified open registry key.
//
//  Arguments:
//      hkey          [in]
//      dwIndex       [in]      See the Win32 documentation for the
//      pszValueName  [out]     RegEnumValue function.
//      pcbValueName  [inout]
//      pdwType       [out]
//      pbData        [out]
//      pcbData       [inout]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumValue (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PTSTR  pszValueName,
    IN OUT LPDWORD pcbValueName,
    OUT LPDWORD pdwType,
    OUT LPBYTE  pbData,
    IN OUT LPDWORD pcbData)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pcbValueName);
    Assert (FImplies(pbData, pcbData));

    LONG lr = RegEnumValue (hkey, dwIndex, pszValueName, pcbValueName,
                            NULL, pdwType, pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceErrorOptional("HrRegEnumValue", hr, (ERROR_NO_MORE_ITEMS == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCTSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    LONG lr = RegOpenKeyEx (hkey, pszSubkey, 0, samDesired, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32(lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceErrorOptional("HrRegOpenKeyEx",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx with the highest
//              access possible.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     scottbri    31-Oct-1997
//
//  Notes:
//
HRESULT
HrRegOpenKeyBestAccess (
    IN HKEY hkey,
    IN PCTSTR pszSubkey,
    OUT PHKEY phkResult)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    LONG lr = RegOpenKeyEx (hkey, pszSubkey, 0, KEY_ALL_ACCESS, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr) && (ERROR_FILE_NOT_FOUND != lr))
    {
        lr = RegOpenKeyEx (hkey, pszSubkey, 0, KEY_READ, phkResult);
        hr = HRESULT_FROM_WIN32 (lr);
        if (FAILED(hr))
        {
            *phkResult = NULL;
        }
    }
    TraceErrorOptional("HrRegOpenKeyEx",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDuplicateKeyEx
//
//  Purpose:    Duplicates a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   09 Apr 1997
//
//  Notes:
//
HRESULT
HrRegDuplicateKeyEx (
    IN HKEY hkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)

{
    Assert (hkey);
    Assert (phkResult);

    LONG lr = RegOpenKeyEx (hkey, NULL, 0, samDesired, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceError("HrRegDuplicateKeyEx", hr);
    return hr;
}

HRESULT
HrRegSetBool (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN BOOL fValue)
{
    DWORD dwValue = !!fValue;
    return HrRegSetValueEx (hkey, pszValueName,
                REG_DWORD,
                (LPBYTE)&dwValue, sizeof(DWORD));
}

HRESULT
HrRegSetDword (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN DWORD dwValue)
{
    return HrRegSetValueEx (hkey, pszValueName,
                REG_DWORD,
                (LPBYTE)&dwValue, sizeof(DWORD));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetValueEx
//
//  Purpose:    Sets the data for the given registry value by calling the
//              RegSetValueEx function.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      dwType       [in]    See the Win32 documentation for the RegSetValueEx
//      pbData       [in]    function.
//      cbData       [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegSetValueEx (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN DWORD dwType,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    Assert (hkey);
    Assert (FImplies (cbData > 0, pbData));

    LONG lr = RegSetValueEx(hkey, pszValueName, 0, dwType, pbData, cbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceError("HrRegSetValue", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSafeCloseKey
//
//  Purpose:    Closes the given registry key if it is non-NULL.
//
//  Arguments:
//      hkey [in]   Key to be closed. Can be NULL.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      If hkey is NULL this function does nothing.
//
VOID
RegSafeCloseKey (
    IN HKEY hkey)
{
    if (hkey)
    {
        RegCloseKey(hkey);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRestoreKey
//
//  Purpose:    Wrapper for RegRestoreKey
//
//  Arguments:
//      hkey        [in]    Parent key to restore into
//      pszFileName [in]    Name of file containing registry info
//      dwFlags     [in]    Flags for restore
//
//  Returns:    Win32 HRESULT if failure, otherwise S_OK
//
//  Author:     danielwe   8 Aug 1997
//
//  Notes:      See docs for RegRestoreKey for more info
//
HRESULT
HrRegRestoreKey (
    IN HKEY hkey,
    IN PCTSTR pszFileName,
    IN DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    LONG        lres;

    Assert(hkey);
    Assert(pszFileName);

    lres = RegRestoreKey(hkey, pszFileName, dwFlags);
    hr = HRESULT_FROM_WIN32(lres);

    TraceError("HrRegRestoreKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSaveKey
//
//  Purpose:    Wrapper for RegSaveKey
//
//  Arguments:
//      hkey        [in]     Parent key to restore into
//      pszFileName [in]     Name of file containing registry info
//      psa         [in]     Security attributes for the file
//
//  Returns:    Win32 HRESULT if failure, otherwise S_OK
//
//  Author:     BillBe   2 Jan 1998
//
//  Notes:      See docs for RegSaveKey for more info
//
HRESULT
HrRegSaveKey (
    IN HKEY hkey,
    IN PCTSTR pszFileName,
    IN LPSECURITY_ATTRIBUTES psa)
{
    HRESULT     hr;
    LONG        lres;

    Assert(hkey);
    Assert(pszFileName);

    lres = RegSaveKey (hkey, pszFileName, psa);
    hr = HRESULT_FROM_WIN32(lres);

    TraceError("HrRegSaveKey", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncregq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G Q . C P P
//
//  Contents:   HrRegQuery functions.
//
//  Notes:
//
//  Author:     shaunco   5 Jun 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncreg.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryDword
//
//  Purpose:    Gets a DWORD from the registry.  Checks that its type and
//              size are correct.  Easier to understand than HrRegQueryValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      pdwValue     [out]   The returned DWORD value if successful.  Zero
//                           if not.
//
//  Returns:    S_OK or HRESULT_FROM_WIN32.
//
//  Author:     shaunco   27 Mar 1997
//
//  Side Effects:   On error, the output DWORD is set to zero to line-up
//                  with the rules of COM in this regard.
//
HRESULT
HrRegQueryDword (
    HKEY    hkey,
    PCTSTR  pszValueName,
    LPDWORD pdwValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pdwValue);

    // Get the value.
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwType,
            (LPBYTE)pdwValue, &cbData);

    // It's type should be REG_DWORD. (duh).
    //
    if ((S_OK == hr) && (REG_DWORD != dwType))
    {
        TraceTag (ttidError, "Expected a type of REG_DWORD for %S.",
            pszValueName);
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
    }

    // It's size should be correct too.
    //
    AssertSz (FImplies(S_OK == hr, sizeof(DWORD) == cbData),
              "Expected sizeof(DWORD) bytes to be returned.");

    // Make sure we initialize the output value on error.
    // (We don't know for sure that RegQueryValueEx does this.)
    //
    if (S_OK != hr)
    {
        *pdwValue = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryDword");
    return hr;
}

#if 0
//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryExpandString
//
//  Purpose:    Query a REG_EXPAND_SZ value from the registry and
//              expand it using ExpandEnvironmentStrings.  Return the
//              result in a tstring.
//
//  Arguments:
//      hkey         [in]  The parent HKEY of szValueName
//      pszValueName [in]  The name of the value to query.
//      pstrValue    [out] The returned (expanded) value.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:
//
HRESULT
HrRegQueryExpandString (
    HKEY        hkey,
    PCTSTR      pszValueName,
    tstring*    pstrValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pstrValue);

    tstring strToExpand;
    HRESULT hr = HrRegQueryTypeString (hkey, pszValueName,
            REG_EXPAND_SZ, &strToExpand);

    if (S_OK == hr)
    {
        ExpandEnvironmentStringsIntoTstring (strToExpand.c_str(), pstrValue);
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr),
        "HrRegQueryExpandString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryInfoKey
//
//  Purpose:    Retrieves information about a registry key by calling
//              RegQueryInfoKey.
//
//  Arguments:
//      hkey                  [in]
//      pszClass              [out]
//      pcbClass              [inout]
//      pcSubKeys             [out]
//      pcbMaxSubKeyLen       [out]    See the Win32 documentation for the
//      pcbMaxClassLen        [out]    RegQueryInfoKey function.
//      pcValues              [out]
//      pcbMaxValueNameLen    [out]
//      pcbMaxValueLen        [out]
//      pcbSecurityDescriptor [out]
//      pftLastWriteTime      [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     BillBe   28 Aug 1998
//
//  Notes:      Note that pcbClass is an *in/out* param. Set this to the size
//              of the buffer pointed to by pszClass *before* calling this
//              function!
//
HRESULT
HrRegQueryInfoKey (
    IN HKEY         hkey,
    OUT PWSTR       pszClass,
    IN OUT LPDWORD  pcbClass,
    OUT LPDWORD     pcSubKeys,
    OUT LPDWORD     pcbMaxSubKeyLen,
    OUT LPDWORD     pcbMaxClassLen,
    OUT LPDWORD     pcValues,
    OUT LPDWORD     pcbMaxValueNameLen,
    OUT LPDWORD     pcbMaxValueLen,
    OUT LPDWORD     pcbSecurityDescriptor,
    OUT PFILETIME   pftLastWriteTime)
{
    Assert(hkey);

    LONG lr = RegQueryInfoKeyW(hkey, pszClass, pcbClass, NULL,pcSubKeys,
            pcbMaxSubKeyLen, pcbMaxClassLen, pcValues, pcbMaxValueNameLen,
            pcbMaxValueLen, pcbSecurityDescriptor, pftLastWriteTime);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRegQueryInfoKey");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryStringAsUlong
//
//  Purpose:    Reads a REG_SZ from the registry and converts it to a ulong
//              before returning
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      nBase        [in]    The numeric base to convert to
//      pulValue     [out]   The returned converted string if successful.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     billbe   13 Jun 1997
//
//  Notes:
//
//
HRESULT
HrRegQueryStringAsUlong (
    IN HKEY     hkey,
    IN PCTSTR   pszValueName,
    IN int      nBase,
    OUT ULONG*  pulValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (nBase);
    Assert (pulValue);

    // Get the value.
    //
    tstring strValue;
    HRESULT hr = HrRegQueryString (hkey, pszValueName, &strValue);

    if (S_OK == hr)
    {
        // Convert and assign the output parameters.
        PWSTR pszStopString;
        *pulValue = wcstoul (strValue.c_str(), &pszStopString, nBase);
    }
    else
    {
        *pulValue = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryStringAsUlong");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeString
//
//  Purpose:    Query a REG_SZ or REG_EXPAND_SZ value and returns it
//              in a tstring.
//
//  Arguments:
//      hkey         [in]  The parent HKEY of szValueName
//      pszValueName [in]  The name of the value to query.
//      dwType       [in]  REG_SZ or REG_EXPAND_SZ
//      pstr         [out] The returned value.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:      REG_EXPAND_SZ values ARE NOT expanded using
//              ExpandEnvironentStrings.  Use HrRegQueryExpandString instead.
//
HRESULT
HrRegQueryTypeString (
    IN HKEY       hkey,
    IN PCTSTR     pszValueName,
    IN DWORD      dwType,
    OUT tstring*  pstr)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pstr);

    AssertSz ((REG_SZ == dwType) ||
              (REG_EXPAND_SZ == dwType), "Only REG_SZ or REG_EXPAND_SZ "
              "types accepted.");

    BOOL fErase = TRUE;

    // Get size of the data.
    //
    DWORD  dwTypeRet;
    DWORD  cbData = 0;
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwTypeRet,
            NULL, &cbData);

    // Make sure it has the correct type.
    //
    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
    }

    if (S_OK == hr)
    {
        // Compute the number of characters in the data including the
        // NULL terminator.  After dividing the number of bytes by
        // the sizeof a TCHAR, add 1 if there is a remainder.  If we didn't,
        // and the number of bytes was not a multiple of the sizeof a TCHAR,
        // we'd come up short because integer division rounds down.
        // (The only time I can think of cbData would not be a multiple
        // of sizeof(TCHAR) is if the registry data were somehow corrupted.
        // It's not that I think corruption deserves a special case, but
        // we shouldn't AV in light of it.)
        //
        DWORD cchIncludingNull;

        cchIncludingNull  = cbData / sizeof(TCHAR);
        if (cbData % sizeof(TCHAR))
        {
            cchIncludingNull++;
        }

        // If we have more than just the terminator, allocate and
        // get the string.  Otherwise, we want it empty.
        //
        if (cchIncludingNull > 1)
        {
            // Reserve room for the correct number of characters.
            // cch is the count of characters without the terminator
            // since that is what tstring operates with.
            //
            DWORD cch = cchIncludingNull - 1;
            Assert (cch > 0);

            // assign will reserve cch characters and set them all to 0.
            // checking capacity afterwards ensures the allocation made
            // internally didn't fail.
            //
            pstr->assign (cch, 0);
            if (cch <= pstr->capacity ())
            {
                hr = HrRegQueryValueEx (hkey, pszValueName, &dwType,
                        (LPBYTE)pstr->data (), &cbData);

                if (S_OK == hr)
                {
                    // If everything went according to plan, the length
                    // of the string should now match what wcslen
                    // returns on the string itself.  The reason it will
                    // match is because we passed cch to assign.
                    //
                    Assert (pstr->length() == (size_t)wcslen (pstr->c_str()));
                    fErase = FALSE;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // Empty the output string on failure or if we think it should be
    // empty.
    //
    if (FAILED(hr) || fErase)
    {
        pstr->erase();
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr),
        "HrRegQueryTypeString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeSzBuffer
//
//  Purpose:    Gets a string from the registry using the given buffer. Checks
//              that its type is correct. Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]        The registry key.
//      pszValueName [in]        The name of the value to get.
//      dwType       [in]        Desired type. (REG_SZ, REG_EXPAND_SZ, etc.)
//      szData       [out]       String buffer to hold the data.
//      pcbData      [in,out]    IN: Number of *bytes* in buffer pointed to by
//                              szData. OUT: Number of bytes actually copied
//                              into the buffer.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   3 Apr 1997
//
//  Notes:      If the function fails, the buffer passed in is guaranteed to
//              be an empty string.
//
HRESULT
HrRegQueryTypeSzBuffer (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN DWORD dwType,
    OUT PWSTR pszData,
    OUT DWORD* pcbData)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pcbData);

    DWORD dwTypeRet;
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwTypeRet,
            (LPBYTE)pszData, pcbData);

    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        TraceTag (ttidError, "Expected a type of 0x%x for %S.",
            dwType, pszValueName);

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
    }

    if (FAILED(hr) && pszData)
    {
        // Make sure empty string is returned on failure.
        //
        *pszData = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryTypeSzBuffer");
    return hr;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueEx
//
//  Purpose:    Retrieves the data from the given registry value by calling
//              RegQueryValueEx.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      pdwType      [out]   See the Win32 documentation for the
//      pbData       [out]   RegQueryValueEx function.
//      pcbData      [in,out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   25 Feb 1997
//
//  Notes:      Note that pcbData is an *in/out* param. Set this to the size
//              of the buffer pointed to by pbData *before* calling this
//              function!
//
HRESULT
HrRegQueryValueEx (
    IN HKEY       hkey,
    IN PCTSTR     pszValueName,
    OUT LPDWORD   pdwType,
    OUT LPBYTE    pbData,
    OUT LPDWORD   pcbData)
{
    Assert (hkey);

    AssertSz (FImplies(pbData && pcbData, pdwType),
              "pdwType not provided to HrRegQueryValueEx.  You should be "
              "retrieving the type as well so you can make sure it is "
              "correct.");

    LONG lr = RegQueryValueEx (hkey, pszValueName, NULL, pdwType,
                    pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceHr (ttidError, FAL, hr,
        (ERROR_MORE_DATA == lr) || (ERROR_FILE_NOT_FOUND == lr),
        "HrRegQueryValueEx (%S)", pszValueName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueWithAlloc
//
//  Purpose:    Retrieve a registry value in a buffer allocated by this
//              function. This goes through the mess of checking the value
//              size, allocating the buffer, and then calling back to get the
//              actual value. Returns the buffer to the user.
//
//  Arguments:
//      hkey         [in]        An open HKEY (the one that contains the value
//                              to be read)
//      pszValueName [in]        Name of the registry value
//      pdwType      [in/out]    The REG_ type that we plan to be reading
//      ppbBuffer    [out]       Pointer to an LPBYTE buffer that will contain
//                              the registry value
//      pdwSize      [out]       Pointer to a DWORD that will contain the size
//                              of the ppbBuffer.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
HRESULT
HrRegQueryValueWithAlloc (
    IN HKEY       hkey,
    IN PCTSTR     pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize)
{
    HRESULT hr;
    BYTE abData [256];
    DWORD cbData;
    BOOL fReQuery = FALSE;

    Assert (hkey);
    Assert (pdwType);
    Assert (ppbBuffer);

    // Initialize the output parameters.
    //
    *ppbBuffer = NULL;
    if (pdwSize)
    {
        *pdwSize = 0;
    }

    // Get the size of the data, and if it will fit, the data too.
    //
    cbData = sizeof(abData);
    hr = HrRegQueryValueEx (
            hkey,
            pszValueName,
            pdwType,
            abData,
            &cbData);
    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
    {
        // The data didn't fit, so we'll have to requery for it after
        // we allocate our buffer.
        //
        fReQuery = TRUE;
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        // Allocate the buffer for the required size.
        //
        BYTE* pbBuffer = (BYTE*)MemAlloc (cbData);
        if (pbBuffer)
        {
            if (fReQuery)
            {
                hr = HrRegQueryValueEx (
                        hkey,
                        pszValueName,
                        pdwType,
                        pbBuffer,
                        &cbData);
            }
            else
            {
                CopyMemory (pbBuffer, abData, cbData);
            }

            if (S_OK == hr)
            {
                // Fill in the return values.
                //
                *ppbBuffer = pbBuffer;

                if (pdwSize)
                {
                    *pdwSize = cbData;
                }
            }
            else
            {
                MemFree (pbBuffer);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryValueWithAlloc");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncstring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G . C P P
//
//  Contents:   Common string routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncstring.h"
#include "ncmsz.h"

//+---------------------------------------------------------------------------
//
//  Function:   CbOfSzSafe, CbOfSzaSafe,
//              CbOfSzAndTermSafe, CbOfSzaAndTermSafe
//
//  Purpose:    Count the bytes required to hold a string.  The string
//              may be NULL in which case zero is returned.
//
//  Arguments:
//      psz [in] String to return count of bytes for.
//
//  Returns:    Count of bytes required to store string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      'AndTerm' variants includes space for the null-terminator.
//
ULONG
CbOfSzSafe (
    IN PCWSTR psz)
{
    return (psz) ? CbOfSz(psz) : 0;
}

ULONG
CbOfSzaSafe (
    IN PCSTR psza)
{
    return (psza) ? CbOfSza(psza) : 0;
}

ULONG
CbOfTSzSafe (
    IN PCTSTR psza)
{
    return (psza) ? CbOfTSz(psza) : 0;
}


ULONG
CbOfSzAndTermSafe (
    IN PCWSTR psz)
{
    return (psz) ? CbOfSzAndTerm(psz) : 0;
}

ULONG
CbOfSzaAndTermSafe (
    IN PCSTR psza)
{
    return (psza) ? CbOfSzaAndTerm(psza) : 0;
}

ULONG
CbOfTSzAndTermSafe (
    IN PCTSTR psza)
{
    return (psza) ? CbOfTSzAndTerm(psza) : 0;
}


ULONG
CchOfSzSafe (
    IN PCTSTR psz)
{
    return (psz) ? _tcslen(psz) : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwFormatString
//
//  Purpose:    Uses FormatMessage to format a string from variable arguments.
//              The string is formatted into a fixed-size buffer the caller
//              provides.
//              See the description of FormatMessage in the Win32 API.
//
//  Arguments:
//      pszFmt  [in]    pointer to format string
//      pszBuf  [out]   pointer to formatted output
//      cchBuf  [in]    count of characters in pszBuf
//      ...     [in]    replaceable string parameters
//
//  Returns:    the return value of FormatMessage
//
//  Author:     shaunco   15 Apr 1997
//
//  Notes:      The variable arguments must be strings otherwise
//              FormatMessage will barf.
//
DWORD
WINAPIV
DwFormatString (
    IN PCWSTR pszFmt,
    OUT PWSTR  pszBuf,
    IN DWORD   cchBuf,
    IN ...)
{
    Assert (pszFmt);

    va_list val;
    va_start(val, cchBuf);
    DWORD dwRet = FormatMessageW (FORMAT_MESSAGE_FROM_STRING,
            pszFmt, 0, 0, pszBuf, cchBuf, &val);
    va_end(val);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwFormatStringWithLocalAlloc
//
//  Purpose:    Uses FormatMessage to format a string from variable arguments.
//              The string is allocated by FormatMessage using LocalAlloc.
//              See the description of FormatMessage in the Win32 API.
//
//  Arguments:
//      pszFmt  [in]    pointer to format string
//      ppszBuf [out]   the returned formatted string
//      ...     [in]    replaceable string parameters
//
//  Returns:    the return value of FormatMessage
//
//  Author:     shaunco   3 May 1997
//
//  Notes:      The variable arguments must be strings otherwise
//              FormatMessage will barf.
//
DWORD
WINAPIV
DwFormatStringWithLocalAlloc (
    IN PCWSTR pszFmt,
    OUT PWSTR* ppszBuf,
    IN ...)
{
    Assert (pszFmt);

    va_list val;
    va_start(val, ppszBuf);
    DWORD dwRet = FormatMessageW (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                  FORMAT_MESSAGE_FROM_STRING,
                                  pszFmt, 0, 0,
                                  (PWSTR)ppszBuf,
                                  0, &val);
    va_end(val);
    return dwRet;
}


PWSTR
WszAllocateAndCopyWsz (
    IN PCWSTR pszSrc)
{
    if (!pszSrc)
    {
        return NULL;
    }

    ULONG cb = (wcslen (pszSrc) + 1) * sizeof(WCHAR);
    PWSTR psz = (PWSTR)MemAlloc (cb);
    if (psz)
    {
        CopyMemory (psz, pszSrc, cb);
    }

    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   WszLoadStringPcch
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//      pcch  [out] Pointer to returned character length.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      The loaded string is pointer directly into the read-only
//              resource section.  Any attempt to write through this pointer
//              will generate an access violation.
//
//              The implementations is referenced from "Win32 Binary Resource
//              Formats" (MSDN) 4.8 String Table Resources
//
//              User must have RCOPTIONS = -N turned on in your sources file.
//
PCWSTR
WszLoadStringPcch (
    IN HINSTANCE   hinst,
    IN UINT        unId,
    OUT int*       pcch)
{
    Assert(hinst);
    Assert(unId);
    Assert(pcch);

    static const WCHAR c_szSpace[] = L" ";

    PCWSTR psz = c_szSpace;
    int    cch = 1;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    // See KB ID: Q20011 for a half-explanation of the second argument below.
    HRSRC hrsrcInfo = FindResource (hinst,
                        (PTSTR)ULongToPtr( ((LONG)(((USHORT)unId >> 4) + 1)) ),
                        RT_STRING);
    if (hrsrcInfo)
    {
        // Page the resource segment into memory.
        HGLOBAL hglbSeg = LoadResource (hinst, hrsrcInfo);
        if (hglbSeg)
        {
            // Lock the resource.
            psz = (PCWSTR)LockResource(hglbSeg);
            if (psz)
            {
                // Move past the other strings in this segment.
                // (16 strings in a segment -> & 0x0F)
                unId &= 0x0F;

                cch = 0;
                do
                {
                    psz += cch;                // Step to start of next string
                    cch = *((WCHAR*)psz++);    // PASCAL like string count
                }
                while (unId--);

                // If we have a non-zero count, it includes the
                // null-terminiator.  Subtract this off for the return value.
                //
                if (cch)
                {
                    cch--;
                }
                else
                {
                    AssertSz(0, "String resource not found");
                    psz = c_szSpace;
                    cch = 1;
                }
            }
            else
            {
                psz = c_szSpace;
                cch = 1;
                TraceLastWin32Error("SzLoadStringPcch: LockResource failed.");
            }
        }
        else
            TraceLastWin32Error("SzLoadStringPcch: LoadResource failed.");
    }
    else
        TraceLastWin32Error("SzLoadStringPcch: FindResource failed.");

    *pcch = cch;
    Assert(*pcch);
    Assert(psz);
    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzaDupSza
//
//  Purpose:    Duplicates a string
//
//  Arguments:
//      pszaSrc [in]  string to be duplicated
//
//  Returns:    Pointer to the new copy of the string
//
//  Author:     CWill   25 Mar 1997
//
//  Notes:      The string return must be freed (MemFree).
//
PSTR
SzaDupSza (
        PCSTR pszaSrc)
{
    AssertSz(pszaSrc, "Invalid source string");

    PSTR  pszaDst;
    pszaDst = (PSTR) MemAlloc (CbOfSzaAndTerm(pszaSrc));

    if (pszaDst)
    {
        strcpy(pszaDst, pszaSrc);
    }

    return pszaDst;
}


//+---------------------------------------------------------------------------
//
//  Function:   TszDupTsz
//
//  Purpose:    Duplicates a string
//
//  Arguments:
//      pszSrc [in]  string to be duplicated
//
//  Returns:    Pointer to the new copy of the string
//
//  Notes:      The string return must be freed.
//
PTSTR
TszDupTsz (
    IN PCTSTR pszSrc)
{
    AssertSz(pszSrc, "Invalid source string");

    PTSTR   pszDst;
    pszDst = (PTSTR) MemAlloc (CbOfTSzAndTermSafe(pszSrc));
    if (pszDst)
    {
        _tcscpy(pszDst, pszSrc);
    }

    return pszDst;
}

//+---------------------------------------------------------------------------
//
//  Function:   WszDupWsz
//
//  Purpose:    Duplicates a wide string
//
//  Arguments:
//      szOld [in]  String to duplicate
//
//  Returns:    Newly allocated copy
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      Caller must free result with delete []
//
LPWSTR WszDupWsz(LPCWSTR szOld)
{
    LPWSTR  szNew;

    szNew = new WCHAR[lstrlen(szOld) + 1];
    if (szNew)
    {
        lstrcpy(szNew, szOld);
    }

    return szNew;
}

LPWSTR WszFromSz(LPCSTR szAnsi)
{
    Assert(szAnsi);

    LPWSTR pszResult;
    LPWSTR pszWide;
    INT cchWide;
    INT result;

    pszResult = NULL;

    if (!szAnsi)
    {
        goto Cleanup;
    }

    result = ::MultiByteToWideChar(CP_ACP,
                                   0,
                                   szAnsi,
                                   -1,
                                   NULL,
                                   0);
    if (!result)
    {
        TraceLastWin32Error("WszFromSz: MultiByteToWideChar #1");
        goto Cleanup;
    }

    cchWide = result;

    pszWide = new WCHAR [ cchWide ];
    if (!pszWide)
    {
        TraceError("WszFromSz: new", E_OUTOFMEMORY);
        goto Cleanup;
    }

    result = ::MultiByteToWideChar(CP_ACP,
                                   0,
                                   szAnsi,
                                   -1,
                                   pszWide,
                                   cchWide);
    if (!result)
    {
        TraceLastWin32Error("WszFromSz: MultiByteToWideChar #2");

        delete [] pszWide;
        goto Cleanup;
    }

    pszResult = pszWide;

Cleanup:
    return pszResult;
}

LPWSTR WszFromUtf8(LPCSTR szUtf8)
{
    Assert(szUtf8);

    LPWSTR pszResult;
    LPWSTR pszWide;
    INT cchWide;
    INT result;

    pszResult = NULL;

    if (!szUtf8)
    {
        goto Cleanup;
    }

    result = ::MultiByteToWideChar(CP_UTF8,
                                   0,
                                   szUtf8,
                                   -1,
                                   NULL,
                                   0);
    if (!result)
    {
        TraceLastWin32Error("WszFromUtf8: MultiByteToWideChar #1");
        goto Cleanup;
    }

    cchWide = result;

    pszWide = new WCHAR [ cchWide ];
    if (!pszWide)
    {
        TraceError("WszFromUtf8: new", E_OUTOFMEMORY);
        goto Cleanup;
    }

    result = ::MultiByteToWideChar(CP_UTF8,
                                   0,
                                   szUtf8,
                                   -1,
                                   pszWide,
                                   cchWide);
    if (!result)
    {
        TraceLastWin32Error("WszFromUtf8: MultiByteToWideChar #2");

        delete [] pszWide;
        goto Cleanup;
    }

    pszResult = pszWide;

Cleanup:
    return pszResult;
}

LPSTR SzFromWsz(LPCWSTR szWide)
{
    Assert(szWide);

    LPSTR pszResult;
    LPSTR pszAnsi;
    INT cbAnsi;
    INT result;

    pszResult = NULL;

    if (!szWide)
    {
        goto Cleanup;
    }

    result = ::WideCharToMultiByte(CP_ACP,
                                   0,
                                   szWide,
                                   -1,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);
    if (!result)
    {
        TraceLastWin32Error("SzFromWsz: WideCharToMultiByte #1");
        goto Cleanup;
    }

    cbAnsi = result;

    pszAnsi = (CHAR *)MemAlloc(cbAnsi);
    if (!pszAnsi)
    {
        TraceError("SzFromWsz: MemAlloc", E_OUTOFMEMORY);
        goto Cleanup;
    }

    result = ::WideCharToMultiByte(CP_ACP,
                                   0,
                                   szWide,
                                   -1,
                                   pszAnsi,
                                   cbAnsi,
                                   NULL,
                                   NULL);
    if (!result)
    {
        TraceLastWin32Error("SzFromWsz: WideCharToMultiByte #2");

        MemFree(pszAnsi);
        goto Cleanup;
    }

    pszResult = pszAnsi;

Cleanup:
    return pszResult;
}

LPSTR Utf8FromWsz(LPCWSTR szWide)
{
    Assert(szWide);

    LPSTR pszResult;
    LPSTR pszUtf8;
    INT cbUtf8;
    INT result;

    pszResult = NULL;

    if (!szWide)
    {
        goto Cleanup;
    }

    result = ::WideCharToMultiByte(CP_UTF8,
                                   0,
                                   szWide,
                                   -1,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);
    if (!result)
    {
        TraceLastWin32Error("Utf8FromWsz: WideCharToMultiByte #1");
        goto Cleanup;
    }

    cbUtf8 = result;

    pszUtf8 = (CHAR *)MemAlloc(cbUtf8);
    if (!pszUtf8)
    {
        TraceError("SzFromWsz: MemAlloc", E_OUTOFMEMORY);
        goto Cleanup;
    }

    result = ::WideCharToMultiByte(CP_UTF8,
                                   0,
                                   szWide,
                                   -1,
                                   pszUtf8,
                                   cbUtf8,
                                   NULL,
                                   NULL);
    if (!result)
    {
        TraceLastWin32Error("Utf8FromWsz: WideCharToMultiByte #2");

        MemFree(pszUtf8);
        goto Cleanup;
    }

    pszResult = pszUtf8;

Cleanup:
    return pszResult;
}

LPWSTR WszFromTsz(LPCTSTR  pszInputString)
{
#ifdef _UNICODE
    return WszAllocateAndCopyWsz(pszInputString);
#else // not unicode
    return WszFromSz(pszInputString);
#endif // _UNICODE
}

LPTSTR TszFromWsz(LPCWSTR pszInputString)
{
#ifdef _UNICODE
    return WszAllocateAndCopyWsz(pszInputString);
#else // not unicode
    return SzFromWsz(pszInputString);
#endif // _UNICODE
}

LPTSTR TszFromSz(LPCSTR szAnsi)
{
#ifdef _UNICODE
    return WszFromSz(szAnsi);
#else
    return SzaDupSza(szAnsi);
#endif
}

LPSTR SzFromTsz(LPCTSTR pszInputString)
{
#ifdef _UNICODE
    return SzFromWsz(pszInputString);
#else
    return SzaDupSza(pszInputString);
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToDelimitedSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value.
//
//  Arguments:
//      pszAddString    [in]    The string to add to the delimited psz.
//      pszIn           [in]    The delimited psz list.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '. This will
//                              be used to delimit the value that we add,
//                              as well.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Insert the string as the first element of
//                                  the list.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Insert the string as the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the psz.  If the index specified
//                                  is greater than the number of strings
//                                  in the psz, the string will be
//                                  placed at the end.
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//      pmszOut         [out]   The new delimited psz.
//
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      9 Nov 1998
//              (Extracted from HrRegAddStringToSz and modified)
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrAddStringToDelimitedSz (
    IN PCTSTR pszAddString,
    IN PCTSTR pszIn,
    IN TCHAR chDelimiter,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PTSTR* ppszOut)
{
    Assert(pszAddString);
    Assert(ppszOut);

    HRESULT hr = S_OK;

    // Don't continue if the pointers are NULL
    if (!pszAddString || !ppszOut)
    {
        hr =  E_POINTER;
    }

    if (S_OK == hr)
    {
        // Initialize out param
        *ppszOut = NULL;
    }

    BOOL fEnsureAtFront = dwFlags & STRING_FLAG_ENSURE_AT_FRONT;
    BOOL fEnsureAtEnd = dwFlags & STRING_FLAG_ENSURE_AT_END;
    BOOL fEnsureAtIndex = dwFlags & STRING_FLAG_ENSURE_AT_INDEX;

    // Can't specify more than one of these flags
    if ((fEnsureAtFront && fEnsureAtEnd) ||
        (fEnsureAtFront && fEnsureAtIndex) ||
        (fEnsureAtEnd && fEnsureAtIndex))
    {
        AssertSz(FALSE, "Invalid flags in HrAddStringToSz");
        hr = E_INVALIDARG;
    }

    // Have to specify at least one of these
    if (!fEnsureAtFront && !fEnsureAtEnd && !fEnsureAtIndex)
    {
        AssertSz(FALSE, "Must specify a STRING_FLAG_ENSURE flag");
        hr = E_INVALIDARG;
    }


    if (S_OK == hr)
    {
        // Alloc the new blob, including enough space for the trailing comma
        //
        *ppszOut = (PTSTR) MemAlloc (CbOfTSzAndTermSafe(pszIn) +
                CbOfTSzSafe(pszAddString) + sizeof(TCHAR));

        if (!*ppszOut)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        DWORD dwCurrentIndex = 0; // Current index in the new buffer

        // Prime the new string
        //
        (*ppszOut)[0] = L'\0';

        // If we have the "ensure at front" flag, do so with the passed in
        // value. We also do this if we have the ensure at index flag
        // set with index of 0 or if the ensure at index is set but
        // the input string is null or empty
        //
        if (fEnsureAtFront || (fEnsureAtIndex && (0 == dwStringIndex)) ||
                (fEnsureAtIndex && (!pszIn || !*pszIn)))
        {
            _tcscpy (*ppszOut, pszAddString);
            ++dwCurrentIndex;
        }

        // If there was a previous value, walk through it and copy as needed.
        // If not, then we're done.
        if (pszIn && *pszIn)
        {
            PCTSTR pszCurrent = pszIn;

            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //

            // Find the first string's end (at the delimiter).
            PCTSTR pszEnd = _tcschr (pszCurrent, chDelimiter);

            while (*pszCurrent)
            {
                // If the delimiter didn't exist, set the end to the end of the
                // entire string
                //
                if (!pszEnd)
                {
                    pszEnd = pszCurrent + _tcslen (pszCurrent);
                }

                LONG lLength = _tcslen (*ppszOut);
                if (fEnsureAtIndex && (dwCurrentIndex == dwStringIndex))
                {
                    // We know we are not at the first item since
                    // this would mean dwStringIndex is 0 and we would
                    // have copied the string before this point
                    //
                    (*ppszOut)[lLength++] = chDelimiter;
                    (*ppszOut)[lLength++] = L'\0';

                    // Append the string.
                    _tcscat (*ppszOut, pszAddString);
                    ++dwCurrentIndex;
                }
                else
                {
                    DWORD_PTR cch = pszEnd - pszCurrent;
                    // If we are allowing duplicates or the current string
                    // doesn't match the string we want to add, then we will
                    // copy it.
                    //
                    if ((dwFlags & STRING_FLAG_ALLOW_DUPLICATES) ||
                            (_tcsnicmp (pszCurrent, pszAddString, cch) != 0))
                    {
                        // If we're not the first item, then add the delimiter.
                        //
                        if (lLength > 0)
                        {
                            (*ppszOut)[lLength++] = chDelimiter;
                            (*ppszOut)[lLength++] = L'\0';
                        }

                        // Append the string.
                        _tcsncat (*ppszOut, pszCurrent, cch);
                        ++dwCurrentIndex;
                    }

                    // Advance the pointer to one past the end of the current
                    // string unless, the end is not the delimiter but NULL.
                    // In that case, set the current point to equal the end
                    // pointer
                    //
                    pszCurrent = pszEnd + (*pszEnd ? 1 : 0);

                    // If the current pointer is not at the end of the input
                    // string, then find the next delimiter
                    //
                    if (*pszCurrent)
                    {
                        pszEnd = _tcschr (pszCurrent, chDelimiter);
                    }
                }
            }
        }

        // If we don't have the "insert at front" flag, then we should insert
        // at the end (this is the same as having the
        // STRING_FLAG_ENSURE_AT_END flag set)
        //
        if (fEnsureAtEnd ||
                (fEnsureAtIndex && (dwCurrentIndex <= dwStringIndex)))
        {
            LONG lLength = _tcslen (*ppszOut);

            // If we're not the first item, add the delimiter.
            //
            if (_tcslen (*ppszOut) > 0)
            {
                (*ppszOut)[lLength++] = chDelimiter;
                (*ppszOut)[lLength++] = L'\0';
            }

            // Append the string.
            //
            _tcscat (*ppszOut, pszAddString);
        }
    }

    TraceError ("HrAddStringToDelimitedSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromDelimitedSz
//
//  Purpose:    Removes a string from a delimited string value
//
//  Arguments:
//      pszRemove  [in] The string to be removed from the multi-sz
//      pszIn      [in] The delimited list to scan for pszRemove
//      cDelimiter [in] The character to be used to delimit the
//                      values. Most multi-valued REG_SZ strings are
//                      delimited with either ',' or ' '.
//      dwFlags    [in] Can contain one or more of the following
//                      values:
//
//                      STRING_FLAG_REMOVE_SINGLE
//                          Don't remove more than one value, if
//                          multiple are present.
//                      STRING_FLAG_REMOVE_ALL
//                          If multiple matching values are present,
//                          remove them all.
//      ppszOut   [out] The string with pszRemove removed. Note
//                      that the output parameter is always set even
//                      if pszRemove did not exist in the list.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      10 Nov 1998
//              (Extracted from HrRegAddStringToSz and modified)
//
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRemoveStringFromDelimitedSz(
    IN PCTSTR pszRemove,
    IN PCTSTR pszIn,
    IN TCHAR chDelimiter,
    IN DWORD dwFlags,
    OUT PTSTR* ppszOut)
{

    Assert(pszIn && *pszIn);
    Assert(ppszOut);

    HRESULT hr = S_OK;

    // If the out param is not specified, get out
    if (!ppszOut)
    {
        return E_INVALIDARG;
    }

    // Alloc the new blob
    //
    hr = E_OUTOFMEMORY;
    *ppszOut = (PTSTR) MemAlloc (CbOfTSzAndTermSafe (pszIn));

    if (*ppszOut)
    {
        hr = S_OK;
        // Prime the new string
        //
        (*ppszOut)[0] = L'\0';

        // If there was a previous value, walk through it and copy as needed.
        // If not, then we're done
        //
        if (pszIn)
        {
            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //
            PCTSTR pszCurrent = pszIn;

            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //

            // Find the first string's end (at the delimiter).
            PCTSTR pszEnd = _tcschr (pszCurrent, chDelimiter);

            // Keep track of how many instances have been removed.
            DWORD   dwNumRemoved    = 0;

            while (*pszCurrent)
            {
                // If the delimiter didn't exist, set the end to the end of
                // the entire string.
                //
                if (!pszEnd)
                {
                    pszEnd = pszCurrent + _tcslen (pszCurrent);
                }

                DWORD_PTR cch = pszEnd - pszCurrent;
                INT iCompare;
                // If we have a match, and we want to remove it (meaning that
                // if we have the remove-single set, that we haven't removed
                // one already).

                iCompare = _tcsnicmp (pszCurrent, pszRemove, cch);

                if ((iCompare) ||
                    ((dwFlags & STRING_FLAG_REMOVE_SINGLE) &&
                     (dwNumRemoved > 0)))
                {
                    LONG lLength = _tcslen (*ppszOut);

                    // If we're not the first item, then add the delimiter.
                    //
                    if (lLength > 0)
                    {
                        (*ppszOut)[lLength++] = chDelimiter;
                        (*ppszOut)[lLength++] = L'\0';
                    }

                    // Append the string.
                    _tcsncat (*ppszOut, pszCurrent, cch);
                }
                else
                {
                    dwNumRemoved++;
                }

                // Advance the pointer to one past the end of the current
                // string unless, the end is not the delimiter but NULL.
                // In that case, set the current point to equal the end
                // pointer
                //
                pszCurrent = pszEnd + (*pszEnd ? 1 : 0);

                // If the current pointer is not at the end of the input
                // string, then find the next delimiter
                //
                if (*pszCurrent)
                {
                    pszEnd = _tcschr (pszCurrent, chDelimiter);
                }
            }
        }
    }

    TraceError("HrRemoveStringFromDelimitedSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrReallocAndCopyString
//
//  Purpose:    Copies a given string into a string pointer that might
//              already contain an alloc()ed string.  If the destination
//              pointer contains a string (e.g. is non-null), that string
//              is freed before the copy occurs.
//
//  Arguments:
//      pszSrc      The string to copy.  This may be NULL.
//      ppszDest    The address of the pointer which will contain the copied
//                  string.  If *ppszDest is non-NULL when the function is
//                  called, its value will be freed before the string is
//                  copied.  On return, it will contain a copy of pszSrc,
//                  or be set to NULL (if pszSrc is NULL).
//
//  Returns:    TRUE if the *ppszDest was set
//              E_OUTOFMEMORY if the new string could not be allocated
//
//  Notes:
//
HRESULT
HrReallocAndCopyString(/* IN */ LPCWSTR pszSrc, /* INOUT */ LPWSTR * ppszDest)
{
    Assert(ppszDest);

    HRESULT hr;
    LPWSTR pszTemp;

    hr = S_OK;

    pszTemp = NULL;

    if (pszSrc)
    {
        // copy the string into pszTemp
        pszTemp = WszAllocateAndCopyWsz(pszSrc);
        if (!pszTemp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if (*ppszDest)
    {
        delete [] *ppszDest;
    }
    *ppszDest = pszTemp;

Cleanup:
    TraceError("HrReallocAndCopyString", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCopyString
//
//  Purpose:    Copies a string using new
//
//  Arguments:
//      szSrc   [in]  String to be copied
//      pszDest [out] Copy
//
//  Returns:
//
//  Author:     mbend   12 Nov 2000
//
//  Notes:
//
HRESULT HrCopyString(const char * szSrc, char ** pszDest)
{
    HRESULT hr = S_OK;

    if(szSrc)
    {
        *pszDest = new char[lstrlenA(szSrc) + 1];
        if(!*pszDest)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            lstrcpyA(*pszDest, szSrc);
        }
    }
    else
    {
        hr = E_POINTER;
    }

    TraceHr(ttidError, FAL, hr, (hr == E_POINTER), "HrCopyString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCopyString
//
//  Purpose:    Copies a string using new
//
//  Arguments:
//      szSrc   [in]  String to be copied
//      pszDest [out] Copy
//
//  Returns:
//
//  Author:     mbend   12 Nov 2000
//
//  Notes:
//
HRESULT HrCopyString(const wchar_t * szSrc, wchar_t ** pszDest)
{
    HRESULT hr = S_OK;

    if(szSrc)
    {
        *pszDest = new wchar_t[lstrlen(szSrc) + 1];
        if(!*pszDest)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            lstrcpy(*pszDest, szSrc);
        }
    }
    else
    {
        hr = E_POINTER;
    }

    TraceHr(ttidError, FAL, hr, (hr == E_POINTER), "HrCopyString");
    return hr;
}

//
// Stol.. er. "borrowed" from \\index2\ntsrc\enduser\windows.com\wuv3\wuv3\string.cpp
//
char *stristr(const char *string1, const char *string2)
{
    char *pSave = (char *)string1;
    char *ps1   = (char *)string1;
    char *ps2   = (char *)string2;

    if ( !*ps1 || !ps2 || !ps1 )
        return NULL;

    if ( !*ps2 )
        return ps1;

    while( *ps1 )
    {
        while( *ps2 && (toupper(*ps2) == toupper(*ps1)) )
        {
            ps2++;
            ps1++;
        }
        if ( !*ps2 )
            return pSave;
        if ( ps2 == string2 )
        {
            ps1++;
            pSave = ps1;
        }
        else
            ps2 = (char *)string2;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C U I . C P P
//
//  Contents:   Common user interface routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "prsht.h"
#include "ncstring.h"
#include "ncui.h"

//+---------------------------------------------------------------------------
//
//  Function:   EnableOrDisableDialogControls
//
//  Purpose:    Enable or disable a group of controls all at once.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      ccid    [in] Count of elements in array pointed to by acid.
//      acid    [in] Array of control ids.
//      fEnable [in] TRUE to enable controls, FALSE to disable.
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
VOID
EnableOrDisableDialogControls (
    IN HWND        hDlg,
    IN INT         ccid,
    IN const INT*  acid,
    IN BOOL        fEnable)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (ccid, acid));

    while (ccid--)
    {
        EnableWindow (GetDlgItem (hDlg, *acid++), fEnable);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FMapRadioButtonToValue
//
//  Purpose:    Maps the current state of a set of radio buttons to a DWORD
//              value based on a mapping table.
//
//  Arguments:
//      hDlg     [in]  Window handle of parent dialog.
//      crbm     [in]  Count of elements in array pointed to by arbm.
//      arbm     [in]  Array of elements that map a radio button control id to
//                     its associated value.
//      pdwValue [out] The returned value.
//
//  Returns:    TRUE if a radio button was set and the value returned.
//              FALSE otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
BOOL
FMapRadioButtonToValue (
    IN HWND                    hDlg,
    IN INT                     crbm,
    IN const RADIO_BUTTON_MAP* arbm,
    OUT DWORD*                  pdwValue)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (crbm, arbm));
    Assert (pdwValue);

    while (crbm--)
    {
        // If it is set, return the corresponding value.
        if (BST_CHECKED & IsDlgButtonChecked (hDlg, arbm->cid))
        {
            *pdwValue = arbm->dwValue;
            return TRUE;
        }

        arbm++;
    }
    *pdwValue = 0;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FMapValueToRadioButton
//
//  Purpose:    Set the state of a set of radio buttons based on the value of
//              of a DWORD and a mapping table.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      crbm    [in] Count of elements in array pointed to by arbm.
//      arbm    [in] Array of elements that map a radio button control id to
//                   its associated value.
//      dwValue [in] value which gets mapped to set the appropriate radio
//                   button.
//
//  Returns:    TRUE if dwValue was found in the map.  FALSE otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
BOOL
FMapValueToRadioButton (
    IN HWND                    hDlg,
    IN INT                     crbm,
    IN const RADIO_BUTTON_MAP* arbm,
    IN DWORD                   dwValue,
    IN INT*                    pncid)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (crbm, arbm));

    while (crbm--)
    {
        if (dwValue == arbm->dwValue)
        {
            // Set the radio button.
            CheckDlgButton (hDlg, arbm->cid, BST_CHECKED);

            // Return the control id if requested.
            if (pncid)
            {
                *pncid = arbm->cid;
            }

            return TRUE;
        }

        arbm++;
    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   LresFromHr
//
//  Purpose:    Translates an HRESULT into a valid LRESULT to be returned by
//              a dialog handler function.
//
//  Arguments:
//      hr [in] HRESULT to be translated.
//
//  Returns:    LRESULT
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:
//
LRESULT
LresFromHr (
    IN HRESULT hr)
{
    AssertSz (((LRESULT)hr) != PSNRET_INVALID, "Don't pass PSNRET_INVALID to "
              "LresFromHr! Use equivalent NETCFG_E_* value instead!");
    AssertSz (((LRESULT)hr) != PSNRET_INVALID_NOCHANGEPAGE, "Don't pass "
              "PSNRET_INVALID_NOCHANGEPAGE to "
              "LresFromHr! Use equivalent NETCFG_E_* value instead!");


    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : (LRESULT)hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBox
//
//  Purpose:    Displays a message box using resource strings and replaceable
//              parameters.
//
//  Arguments:
//      hinst       [in] hinstance for resource strings
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCTSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...)
{
    INT    nRet = -1;
    PCWSTR pszwCaption = WszLoadString(hinst, unIdCaption);
    PCWSTR pszwFormat = WszLoadString(hinst, unIdFormat);

    if (pszwCaption && pszwFormat)
    {
        PCTSTR pszCaption = TszFromWsz(pszwCaption);
        PCTSTR pszFormat  = TszFromWsz(pszwFormat);

        if (pszCaption && pszFormat)
        {
            PTSTR  pszText = NULL;
            va_list val;
            va_start (val, unStyle);
            FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pszFormat, 0, 0, (PTSTR)&pszText, 0, &val);
            va_end (val);

            nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
            LocalFree (pszText);
        }

        if (pszCaption)
        {
            free((VOID *)pszCaption);
            pszCaption = NULL;
        }

        if (pszFormat)
        {
            free((VOID *)pszFormat);
            pszFormat = NULL;
        }
    }

    return nRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   SendDlgItemsMessage
//
//  Purpose:    Send a group of dialog items the same message.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      ccid    [in] Count of elements in array pointed to by acid.
//      acid    [in] Array of control ids.
//      unMsg   [in] Message to send
//      wParam  [in] First message parameter
//      lParam  [in] Second message parameter
//
//  Returns:    nothing
//
//  Author:     shaunco   11 Jun 1997
//
//  Notes:
//
VOID
SendDlgItemsMessage (
    IN HWND        hDlg,
    IN INT         ccid,
    IN const INT*  acid,
    IN UINT        unMsg,
    IN WPARAM      wParam,
    IN LPARAM      lParam)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (ccid, acid));

    while (ccid--)
    {
        Assert (IsWindow (GetDlgItem (hDlg, *acid)));

        SendDlgItemMessage (hDlg, *acid++, unMsg, wParam, lParam);
    }
}

//
// Function:    SetDefaultButton
//
// Purpose:     Set the new default pushbutton on a dialog
//
// Params:      hdlg  [in] - Dialog HWND
//              iddef [in] - Id of new default pushbutton
//
// Returns:     nothing
//
VOID
SetDefaultButton(
    IN HWND hdlg,
    IN INT iddef)
{
    HWND        hwnd;
    DWORD_PTR   dwData;

    Assert(hdlg);

    dwData = SendMessage (hdlg, DM_GETDEFID, 0, 0L);
    if ((HIWORD(dwData) == DC_HASDEFID) && LOWORD(dwData))
    {
        hwnd = GetDlgItem (hdlg, (INT)LOWORD(dwData));
        if ((LOWORD(dwData) != iddef) && (hwnd))
        {
            SendMessage (hwnd, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE);
        }
    }

    SendMessage (hdlg, DM_SETDEFID,(WPARAM)iddef, 0L);
    if (iddef)
    {
        hwnd = GetDlgItem (hdlg, iddef);
        Assert(hwnd);
        SendMessage (hwnd, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE);
    }
}

static const CONTEXTIDMAP c_adwContextIdMap[] =
{
    { IDOK,                   IDH_OK,     IDH_OK  },
    { IDCANCEL,               IDH_CANCEL, IDH_CANCEL },
    { 0,                      0,          0 },      // end marker
};

//+---------------------------------------------------------------------------
//
//  Function:   DwContextIdFromIdc
//
//  Purpose:    Converts the given control ID to a context help ID
//
//  Arguments:
//      idControl [in]  Control ID to convert
//
//  Returns:    Context help ID for that control (mapping comes from help
//              authors)
//
//  Author:     danielwe   27 May 1998
//
//  Notes:
//
DWORD DwContextIdFromIdc(
    PCCONTEXTIDMAP lpContextIdMap,
    BOOL bJpn,
    INT idControl)
{
    DWORD   idw;

    Assert(lpContextIdMap);

    for (idw = 0; lpContextIdMap[idw].idControl; idw++)
    {
        if (idControl == lpContextIdMap[idw].idControl)
        {
            if (!bJpn)
            {
                return lpContextIdMap[idw].dwContextId;
            }
            else
            {
                return lpContextIdMap[idw].dwContextIdJapan;
            }
        }
    }

    // Not found, just return 0
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnHelpGeneric
//
//  Purpose:    Handles help generically
//
//  Arguments:
//      hwnd   [in]     HWND of parent window
//      lParam [in]     lParam of the WM_HELP message
//
//  Returns:    Nothing
//
//  Author:     danielwe   27 May 1998
//              anbrad     18 May 1999 moved to common.  common control id's added.
//
//  Notes:
//
VOID OnHelpGeneric(
    HWND hwnd,
    LPHELPINFO lphi,
    PCCONTEXTIDMAP pContextMap,
    BOOL bJpn,
    PCTSTR pszHelpFile)
{
    static const TCHAR c_szWindowsHelpFile[] = TEXT("windows.hlp");

    Assert(lphi);

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
        switch(lphi->iCtrlId)
        {
        case -1:        // IDC_STATIC
            break;
        case IDOK:
        case IDCANCEL:
        case IDABORT:
        case IDRETRY:
        case IDIGNORE:
        case IDYES:
        case IDNO:
        case IDCLOSE:
        case IDHELP:
            WinHelp(hwnd, c_szWindowsHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(c_adwContextIdMap, bJpn, lphi->iCtrlId));
            break;
        default:
            WinHelp(hwnd, pszHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(pContextMap, bJpn, lphi->iCtrlId));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\upstrs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P S T R S . C P P 
//
//  Contents:   Common strings for the various UPnP projects.
//
//  Notes:      
//
//  Author:     jeffspr   9 Dec 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const DECLSPEC_SELECTANY

CONST_GLOBAL TCHAR c_szUPnPRegRoot[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\UPnP");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncutil.cpp ===
#include <pch.h>
#pragma hdrstop
#include "ncutil.h"
#include "oleauto.h"
#include "limits.h"
#include "stdio.h"

HRESULT HrGetProperty(IDispatch * lpObject, OLECHAR *lpszProperty, VARIANT * lpResult)
{
    HRESULT hr;
    DISPID pDisp;
    DISPPARAMS dp;

    // Setup empty DISPPARAMS structure
    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    // Clear out the result value
    VariantClear(lpResult);

    // See if such a property exists
    hr = lpObject->GetIDsOfNames(IID_NULL, &lpszProperty, 1, LOCALE_SYSTEM_DEFAULT, &pDisp);
    if (SUCCEEDED(hr))
    {
        // Get the property from the object
        hr = lpObject->Invoke(pDisp, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                              DISPATCH_PROPERTYGET, &dp, lpResult, NULL, NULL);
    }

    return hr;
}

HRESULT HrJScriptArrayToSafeArray(IDispatch *JScriptArray, VARIANT * pVtResult)
{
    HRESULT hr = E_UNEXPECTED;
    VARIANT vtPropertyValue, vtTemp, *pvtData;
    SAFEARRAY *pSArray = NULL;
    SAFEARRAYBOUND pSArrayBounds[1];
    long lIndex = -1;
    long cElements = -1;
    char szTemp[MAX_PATH];
    bool bFixedSizeArray = false;
    OLECHAR *pszPropertyIndex = NULL;

    if ((JScriptArray == NULL) || (pVtResult == NULL))
        return E_POINTER;

    // Initialise the variants
    VariantInit(&vtPropertyValue);
    VariantInit(&vtTemp);

    // Clear the return value
    VariantClear(pVtResult);

    // Fudge a 'try' block by using a once-only 'do' loop. Can't use
    // try-throw-catch in ATL MinDependency builds without linking in the CRT
    do
    {
        // Get the length of the array, if available
        hr = HrGetProperty(JScriptArray, L"length", &vtPropertyValue);
        if (SUCCEEDED(hr))
        {
            // Change to a 'long'
            hr = VariantChangeType(&vtTemp, &vtPropertyValue, 0, VT_I4);
            if (SUCCEEDED(hr))
            {
                cElements = vtTemp.lVal;

                // Create the array with the correct size
                pSArrayBounds[0].lLbound = 0;
                pSArrayBounds[0].cElements = cElements;
                pSArray = SafeArrayCreate(VT_VARIANT, 1, pSArrayBounds);

                // Couldn't create the array
                if (pSArray == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                // We know the size of the array, so it can be locked now
                // for faster access
                bFixedSizeArray = true;
                hr = SafeArrayAccessData(pSArray, (void **) &pvtData);

                // Couldn't lock data - something wrong
                if (FAILED(hr))
                {
                    break;
                }
            }
        }

        // Couldn't get the length (should never happen?), so create an empty array
        if (FAILED(hr))
        {
            // Default to maximum possible size
            cElements = LONG_MAX;

            // Create the array with zero size
            pSArrayBounds[0].lLbound = 0;
            pSArrayBounds[0].cElements = 0;
            pSArray = SafeArrayCreate(VT_VARIANT, 1, pSArrayBounds);

            // Couldn't create the array
            if (pSArray == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            // Need to dynamically size the array
            bFixedSizeArray = false;
        }

        // Allocate memory for the wide version of the property value
        pszPropertyIndex = (OLECHAR *) CoTaskMemAlloc(sizeof(OLECHAR) * MAX_PATH);

        // Start at 0
        for (lIndex = 0; lIndex < cElements; lIndex++)
        {
            // Get name of the next indexed element, and convert to Unicode
            sprintf(szTemp, "%ld", lIndex);
            MultiByteToWideChar(CP_ACP, NULL, szTemp, -1, pszPropertyIndex, MAX_PATH);

            // See if such a property exists, and get it
            hr = HrGetProperty(JScriptArray, pszPropertyIndex, &vtPropertyValue);
            if (SUCCEEDED(hr))
            {
                // Redim the array if needed (expensive!). There are 'better' ways to
                // do this, eg increase the size of the array in "chunks" and then
                // cut back extra elements at the end, etc.
                if (bFixedSizeArray == false)
                {
                    // Increase the size of the array, and lock the data
                    pSArrayBounds->cElements++;
                    hr = SafeArrayRedim(pSArray, pSArrayBounds);
                    hr = SafeArrayAccessData(pSArray, (void **) &pvtData);
                }
                else
                    hr = S_OK;

                if (SUCCEEDED(hr))
                {
                    hr = VariantCopy(&(pvtData[lIndex]),
                                     &vtPropertyValue);

                    // Unlock data again, if necessary
                    if (bFixedSizeArray == false)
                    {
                        SafeArrayUnaccessData(pSArray);
                    }
                }

                VariantClear(&vtPropertyValue);
            }

            // If we couldn't determine the length, and the property get
            // failed, then quit the loop. Don't quit if we know the length
            // because the array could be sparse
            if ((FAILED(hr)) && (bFixedSizeArray == false))
                break;
        }
        // Unlock data for fixed-size array
        if (bFixedSizeArray)
        {
            SafeArrayUnaccessData(pSArray);
        }
        // only do the loop once
    } while (false);

    // Clean up
    VariantClear(&vtPropertyValue);
    VariantClear(&vtTemp);
    if (pszPropertyIndex != NULL)
        CoTaskMemFree(pszPropertyIndex);

    // Success - the loop terminated because we got an array index
    // that didn't exist, or we got all the elements
    if ((hr == DISP_E_UNKNOWNNAME) || (lIndex == cElements))
    {
        pVtResult->vt = VT_VARIANT | VT_ARRAY;
        pVtResult->parray = pSArray;

        return S_OK;
    }
    // Loop terminated for another reason - fail
    else
    {
        SafeArrayDestroy(pSArray);
        return hr;
    }
}


/*
 * Function:    HrConvertStringToLong()
 *
 * Author:      Shyam Pather (SPATHER)
 *
 * Purpose:     Converts a string representation of a number into a long.
 *              Handles decimal and hexadecimal numbers.
 *
 * Arguments:
 *  pwsz    [in]    The string representation of the number
 *  plValue [out]   Returns the long representation of the number, if
 *                  the function succeeds.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  Format of the input string:
 *      - sign may be indicated by a '+' or '-' at the beginning of the
 *        string (if no sign is specified, the number is assumed to be
 *        positive)
 *      - leading zeroes are ignored
 *      - if the string contains "0x" or "0X" after the optional sign
 *        character, it is assumed to represent a hexadecimal number,
 *        otherwise it is assumed to represent a decimal number (and
 *        any hex digits found are considered invalid)
 *      - letters in hexadecimal numbers may be specified in upper or
 *        lower case
 *
 *  Known limitations:
 *      - will allow a string containing more than one consecutive
 *        leading sign character ('+' or '-') to be parsed - only the
 *        last sign character will be considered. e.g. will convert
 *        "---+--+1" to 1 and "+++-+--1" to -1.
 *      - allows zeroes to be mixed in with leading sign characters -
 *        these are ignored e.g. will convert "++0--1" to -1.
 */

HRESULT
HrConvertStringToLong(
                     IN    LPWSTR  pwsz,
                     OUT   LONG    * plValue)
{
    HRESULT hr = S_OK;
    int     iSign = 1;
    int     iBase = 10;

    *plValue = 0;

    if (pwsz)
    {
        size_t          ucch = 0;
        BOOL            bDoneLeader = FALSE;

        // Take care of any leader characters.

        while (!bDoneLeader)
        {
            switch (pwsz[0])
            {
                case L'+':
                    iSign = 1;
                    break;
                case L'-':
                    iSign = -1;
                    break;
                case L'0':
                    // Ignore leading zero.
                    break;
                case L'x':
                    iBase = 16;
                    break;
                case L'X':
                    iBase = 16;
                    break;

                default:
                    bDoneLeader = TRUE;
            };

            if (!bDoneLeader)
                pwsz++;
        };

        // Count remaining characters - these are the digits.

        ucch = wcslen(pwsz);

        if (ucch)
        {
            // Go through the string and determine the value of each digit.

            LPBYTE rgbDigitVals = NULL;

            rgbDigitVals = new BYTE [ucch];

            if (rgbDigitVals)
            {
                for (unsigned int i = 0; i < ucch; i++)
                {
                    if ((pwsz[i] >= L'0') && (pwsz[i] <= L'9'))
                    {
                        rgbDigitVals[i] = pwsz[i] - L'0';
                    }
                    else if ((16 == iBase) && (pwsz[i] >= L'A') && (pwsz[i] <= L'F'))
                    {
                        rgbDigitVals[i] = 10 + pwsz[i] - L'A';
                    }
                    else if ((16 == iBase) && (pwsz[i] >= L'a') && (pwsz[i] <= L'f'))
                    {
                        rgbDigitVals[i] = 10 + pwsz[i] - L'a';
                    }
                    else
                    {
                        // Invalid digit encountered.

                        hr = E_INVALIDARG;
                        break;
                    }
                }

                // If no invalid digits encountered, calculate the final number.

                if (SUCCEEDED(hr))
                {
                    LONG    lVal = 0;
                    LONG    lPlaceValue = 1;
                    UINT    j = ucch - 1;

                    // Have to start from the back of the array (least significant position).

                    for ( ; j != (UINT(-1)); --j)
                    {
                        // Calculate the value of this digit and add it to the result.

                        lVal += rgbDigitVals[j] * lPlaceValue;

                        // Calculate the value of the next digit position (i.e. in decimal, the first
                        // position has value 1, the second, value 10, the third, value 100 etc).

                        lPlaceValue *= iBase;
                    }

                    lVal *= iSign;  // Properly adjust for sign.

                    *plValue = lVal;
                }

                MemFree(rgbDigitVals);
                rgbDigitVals = NULL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}


HRESULT
HrBytesToVariantArray(
                     IN LPBYTE   pbData,
                     IN ULONG    cbData,
                     OUT VARIANT *pVariant
                     )
{
    HRESULT         hr = E_FAIL;
    SAFEARRAY *     pArrayVal = NULL;
    SAFEARRAYBOUND  arrayBound;
    CHAR HUGEP *    pArray = NULL;

    // Set bound for array
    arrayBound.lLbound = 0;
    arrayBound.cElements = cbData;

    // Create the safe array for the octet string. unsigned char elements;single dimension;aBound size.
    pArrayVal = SafeArrayCreate(VT_UI1, 1, &arrayBound);
    if (pArrayVal)
    {
        hr = SafeArrayAccessData(pArrayVal, (void HUGEP * FAR *) &pArray);
        if (SUCCEEDED(hr))
        {
            // Copy the bytes to the safe array.
            CopyMemory(pArray, pbData, arrayBound.cElements);
            SafeArrayUnaccessData(pArrayVal);

            // Set type to array of unsigned char
            V_VT(pVariant) = VT_ARRAY | VT_UI1;

            // Assign the safe array to the array member.
            V_ARRAY(pVariant) = pArrayVal;
            hr = S_OK;
        }
        else
        {
            // Clean up if array can't be accessed.
            if (pArrayVal)
            {
                SafeArrayDestroy(pArrayVal);
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("HrBytesToVariantArray", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetGITPointer
//
//  Purpose:    Returns a pointer to the system-supplied implementation
//              of IGlobalInterfaceTable for the current apartment.
//
//  Arguments:
//      [out] ppgit     On return, contains an IGlobalInterfaceTable
//                      reference which must be freed when no longer needed.
//
//
//  Returns:
//
HRESULT
HrGetGITPointer(IGlobalInterfaceTable ** ppgit)
{
    Assert(ppgit);

    HRESULT hr;
    IGlobalInterfaceTable * pgit;

    pgit = NULL;

    hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IGlobalInterfaceTable,
                          (LPVOID*)&pgit);
    if (FAILED(hr))
    {
        TraceError("HrGetGITPointer: CoCreateInstance", hr);
        pgit = NULL;
    }

    *ppgit = pgit;

    Assert(FImplies(SUCCEEDED(hr), pgit));
    Assert(FImplies(FAILED(hr), !pgit));

    TraceError("HrGetGITPointer", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\upfile.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U P F I L E . C P P 
//
//  Contents:   File utility functions.
//
//  Notes:      This is separate from ncfile.h so we don't bring the shell
//              dependencies into upnphost.
//
//  Author:     mbend   18 Aug 2000
//
//----------------------------------------------------------------------------


#include <pch.h>
#pragma hdrstop

#include "upfile.h"
#include "trace.h"
#include "ncbase.h"
#include "ComUtility.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateFile
//
//  Purpose:    Wrapper for CreateFile
//
//  Arguments:  
//      szFilename            [in]   Filename
//      dwDesiredAccess       [in]   0 / GENERIC_READ / GENERIC_WRITE
//      dwShareMode           [in]   0 / FILE_SHARE_READ / FILE_SHARE_WRITE
//      lpSecurityAttributes  [in]   Security
//      dwCreationDisposition [in]   CREATE_NEW / CREATE_ALWAYS / OPEN_EXISTING
//                                   OPEN_ALWAYS / TRUNCATE_EXISTING
//      dwFlagsAndAttributes  [in]   FILE_ATTRIBUTE_NORMAL / ...
//      phandle               [out] 
//
//  Returns:    S_OK on success or COM error code on failure.
//
//  Author:     mbend   18 Aug 2000
//
//  Notes:      
//
HRESULT HrCreateFile(
    const wchar_t * szFilename,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE * phandle)
{
    HRESULT hr = S_OK;
    *phandle = CreateFile(szFilename, dwDesiredAccess, dwShareMode, lpSecurityAttributes, 
        dwCreationDisposition, dwFlagsAndAttributes, NULL);
    if(INVALID_HANDLE_VALUE == *phandle)
    {
        hr = HrFromLastWin32Error();
    }
    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateFile");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadFileFromDisk
//
//  Purpose:    Loads a file's contents from disk into memory.
//
//  Arguments:  
//      szFilename [in]   Name of file to load 
//      pnFileSize [out]  Size of file loaded
//      parBytes   [out]  Bytes of file loaded
//
//  Returns:    S_OK on success and COM error code on failure.
//
//  Author:     mbend   18 Aug 2000
//
//  Notes:      
//
HRESULT HrLoadFileFromDisk(const wchar_t * szFilename, long * pnFileSize, byte ** parBytes)
{
    CHECK_POINTER(szFilename);
    CHECK_POINTER(pnFileSize);
    CHECK_POINTER(parBytes);

    HRESULT hr = S_OK;
    HANDLE h;
    hr = HrCreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ, 
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, &h);
    if(SUCCEEDED(hr))
    {
        *pnFileSize = GetFileSize(h, NULL);
        hr = HrCoTaskMemAllocArray(*pnFileSize, parBytes);
        if(SUCCEEDED(hr))
        {
            DWORD dwDummy = 0;
            if(!ReadFile(h, *parBytes, *pnFileSize, &dwDummy, NULL))
            {
                hr = HrFromLastWin32Error();
            }
            if(FAILED(hr))
            {
                if(*parBytes)
                {
                    CoTaskMemFree(*parBytes);
                }
            }
        }
        CloseHandle(h);
    }
    if(FAILED(hr))
    {
        *pnFileSize = 0;
        *parBytes = NULL;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "HrLoadFileFromDisk");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetFileExtension
//
//  Purpose:    Extracts an extension from a filename.
//
//  Arguments:  
//      szFilename       [in]    Filename to process.
//      szExt            [out]   Charachter buffer of size UH_MAX_EXTENSION.
//
//  Returns:    S_OK on success or E_INVALIDARG if filename doesn't have a valid extension.
//
//  Author:     mbend   18 Aug 2000
//
//  Notes:      
//
HRESULT HrGetFileExtension(const wchar_t * szFilename, wchar_t szExt[UH_MAX_EXTENSION])
{
    CHECK_POINTER(szFilename);
    CHECK_POINTER(szExt);
    HRESULT hr = E_INVALIDARG;

    long nLength = lstrlen(szFilename);
    long nMaxExt = UH_MAX_EXTENSION;
    // Check that extension size to search for is not greater than string size
    if(nLength < nMaxExt)
    {
        nMaxExt = nLength;
    }

    // Walk back until we hit a . or reach nMaxExt
    for(long n = 0; n < nMaxExt; ++n)
    {
        if(L'.' == szFilename[nLength - (n+1)])
        {
            // Copy string and return success
            hr = S_OK;
            lstrcpy(szExt, &szFilename[nLength - n]);
            break;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetFileExtension");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ncxml.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ncxml.cpp
//
//  Contents:   helper functions for doing remarkably simple things
//              with the XML DOM.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <oleauto.h>    // for SysFreeString()

#include "ncbase.h"
#include "ncdebug.h"

#include "ncxml.h"
#include "ncinet2.h"    // HrCombineUrl, HrCopyAndValidateUrl


struct DTNAME
{
    LPCWSTR         m_pszType;
    SST_DATA_TYPE   m_sdt;
};


// Lookup table, sorted by string
// Note: if you add strings here, you also have to add a
//       corresponding entry to SST_DATA_TYPE
//
static CONST DTNAME g_rgdtTypeStrings[] =
{
    {L"bin.base64",     SDT_BIN_BASE64},        // base64 as defined in the MIME IETF spec
    {L"bin.hex",        SDT_BIN_HEX},           // Hexadecimal digits representing octets VT_ARRAY safearray or stream
    {L"boolean",        SDT_BOOLEAN},           // boolean, "1" or "0" VT_BOOL int
    {L"char",           SDT_CHAR},              // char, string VT_UI2 wchar
    {L"date",           SDT_DATE_ISO8601},      // date.iso8601, A date in ISO 8601 format. (no time) VT_DATE long
    {L"dateTime",       SDT_DATETIME_ISO8601},  // dateTime.iso8601, A date in ISO 8601 format, with optional time and no optional zone. Fractional seconds may be as precise as nanoseconds. VT_DATE long
    {L"dateTime.tz",    SDT_DATETIME_ISO8601TZ},// dateTime.iso8601tz, A date in ISO 8601 format, with optional time and optional zone. Fractional seconds may be as precise as nanoseconds. VT_DATE long
    {L"fixed.14.4",     SDT_FIXED_14_4},        // fixed.14.4, Same as "number" but no more than 14 digits to the left of the decimal point, and no more than 4 to the right. VT_CY large_integer
    {L"float",          SDT_FLOAT},             // float, Same as for "number." VT_R8 double
    {L"i1",             SDT_I1},                // i1, A number, with optional sign, no fractions, no exponent. VT_I1 char
    {L"i2",             SDT_I2},                // i2, " VT_I2 short
    {L"i4",             SDT_I4},                // i4, " VT_I4 long
    {L"int",            SDT_INT},               // int, A number, with optional sign, no fractions, no exponent. VT_I4 long
    {L"number",         SDT_NUMBER},            // number, A number, with no limit on digits, may potentially have a leading sign, fractional digits, and optionally an exponent. Punctuation as in US English. VT_R8 double
    {L"r4",             SDT_R4},                // r4, Same as "number." VT_FLOAT float
    {L"r8",             SDT_R8},                // r8, " VT_DOUBLE double
    {L"string",         SDT_STRING},            // string, pcdata VT_BSTR BSTR
    {L"time",           SDT_TIME_ISO8601},      // time.iso8601, A time in ISO 8601 format, with no date and no time zone. VT_DATE long
    {L"time.tz",        SDT_TIME_ISO8601TZ},    // time.iso8601.tz, A time in ISO 8601 format, with no date but optional time zone. VT_DATE. long
    {L"ui1",            SDT_UI1},               // ui1, A number, unsigned, no fractions, no exponent. VT_UI1 unsigned char
    {L"ui2",            SDT_UI2},               // ui2, " VT_UI2 unsigned short
    {L"ui4",            SDT_UI4},               // ui4, " VT_UI4 unsigned long
    {L"uri",            SDT_URI},               // uri, Universal Resource Identifier VT_BSTR BSTR
    {L"uuid",           SDT_UUID},              // uuid, Hexadecimal digits representing octets, optional embedded hyphens which should be ignored. VT_BSTR GUID
    //
    // note(cmr): ADD NEW VALUES IN ALPHABETICAL ORDER
    //
};

// NOTE: the order of elements in this array must correspond to the order of
// elements in the SST_DATA_TYPE enum.
static CONST VARTYPE g_rgvtTypes[] =
{
    VT_BSTR,
    VT_BSTR,
    VT_I4,
    VT_CY,
    VT_BOOL,
    VT_DATE,
    VT_DATE,
    VT_DATE,
    VT_DATE,
    VT_DATE,
    VT_I1,
    VT_I2,
    VT_I4,
    VT_UI1,
    VT_UI2,
    VT_UI4,
    VT_R4,
    VT_R8,
    VT_R8,
    VT_BSTR,
    VT_ARRAY,
    VT_ARRAY,
    VT_UI2,
    VT_BSTR,
    //
    // note(cmr): ADD NEW VALUES IMMEDIATELY BEFORE THIS COMMENT.
    //            If adding new values, see comment above.
    //
    VT_EMPTY
};


/*
 * Function:    GetStringFromType()
 *
 * Purpose:     Returns an xml-data type string for the specified
 *              SDT_DATA_TYPE value.
 *
 * Arguments:
 *  sdt             [in]    The data type whose descriptive string is desired.
 *                          This must be a valid SST_DATA_TYPE value (less
 *                          than SDT_INVALID)
 *
 * Returns:
 *  A pointer to a constant string id representing the type.  This string
 *  should not be modified or freed.
 *  This method will never return NULL.
 *
 */
LPCWSTR
GetStringFromType(CONST SST_DATA_TYPE sdt)
{
    // there must be an entry in g_rgdtTypeStrings for every real
    // value of SST_DATA_TYPE
    //
    Assert(SDT_INVALID == celems(g_rgdtTypeStrings));
    Assert(sdt < SDT_INVALID);

    // since comparing SDT_s is somewhat cheaper than comparing whole strings,
    // we just walk through the whole list sequentually
    //

    CONST INT nSize = celems(g_rgdtTypeStrings);
    LPCWSTR pszResult;
    INT i;

    pszResult = NULL;
    i = 0;
    for ( ; i < nSize; ++i)
    {
        SST_DATA_TYPE sdtCurrent;

        sdtCurrent = g_rgdtTypeStrings[i].m_sdt;
        if (sdt == sdtCurrent)
        {
            // we have a match
            pszResult = g_rgdtTypeStrings[i].m_pszType;
            break;
        }
    }

    AssertSz(pszResult, "GetStringFromType: "
             "sdt not found in g_rgdtTypeStrings!");

    return pszResult;
}


/*
 * Function:    GetTypeFromString()
 *
 * Purpose:     Returns the appropriate SDT_DATA_TYPE value for the given
 *              xml-data type string.
 *
 * Arguments:
 *  pszTypeString   [in]    The data type identifier whose SDT_DATA_TYPE value
 *                          is desired.
 *
 * Returns:
 *  If the string is found, it returns the appropriate value of the
 *  SST_DATA_TYPE enumeration.
 *  If the string is not found, it returns SDT_INVALID.
 *
 * Notes:
 *  The source string is compared to known strings in a case-insensitive
 *  comparison.
 *
 */
SST_DATA_TYPE
GetTypeFromString(LPCWSTR pszTypeString)
{
    // there must be an entry in g_rgdtTypeStrings for every real
    // value of SST_DATA_TYPE
    //
    Assert(SDT_INVALID == celems(g_rgdtTypeStrings));

    SST_DATA_TYPE sdtResult;

    sdtResult = SDT_INVALID;

    {
        // now search for the string in the list, using a
        // standard binary search
        //
        INT nLow;
        INT nMid;
        INT nHigh;

        nLow = 0;
        nHigh = celems(g_rgdtTypeStrings) - 1;

        while (TRUE)
        {
            if (nLow > nHigh)
            {
                // not found
                //
                break;
            }

            nMid = (nLow + nHigh) / 2;

            {
                LPCWSTR pszCurrent;
                int result;

                pszCurrent = g_rgdtTypeStrings[nMid].m_pszType;

                result = _wcsicmp(pszTypeString, pszCurrent);
                if (result < 0)
                {
                    nHigh = nMid - 1;
                }
                else if (result > 0)
                {
                    nLow = nMid + 1;
                }
                else
                {
                    // found
                    //
                    sdtResult = g_rgdtTypeStrings[nMid].m_sdt;
                    break;
                }
            }
        }
    }

    return sdtResult;
}

VARTYPE
GetVarTypeFromString(LPCWSTR pszTypeString)
{
    SST_DATA_TYPE sdt = SDT_INVALID;

    sdt = GetTypeFromString(pszTypeString);

    return g_rgvtTypes[sdt];
}


// not an exported function, but one that we use internally...
HRESULT
HrGetChildElement(IXMLDOMNode * pxdn,
                  LPCWSTR pszNodeName,
                  IXMLDOMNode ** ppxdn);


CONST WCHAR pszTextType [] = L"string";

//+---------------------------------------------------------------------------
//
//  Function:   HrGetTypedValueFromElement
//
//  Purpose:    Given an IXMLDOMNode that should be of type
//              dt:string, returns a new BSTR containing that
//              string.
//
//  Arguments:
//      pxdn        IXMLDOMNode to extract the string from.
//                  It is intended that this node be of type
//                  NODE_ELEMENT.
//
//      pszDataType The type of the data encoded in the element.
//
//      pvarOut     Address of a VARIANT that will obtain the
//                  data value.  This must be freed when
//                  no longer needed.
//
//  Returns:
//      S_OK if *pvarOut contains the data of the desired type
//
//  Notes:
//
HRESULT
HrGetTypedValueFromElement(IXMLDOMNode * pxdn,
                           CONST LPCWSTR pszDataType,
                           VARIANT * pvarOut)
{
    Assert(pxdn);
    Assert(pszDataType);
    Assert(pvarOut);

    HRESULT hr;
    BSTR bstrDataType;

    bstrDataType = ::SysAllocString(pszDataType);
    if (bstrDataType)
    {
        hr = pxdn->put_dataType(bstrDataType);
        if (SUCCEEDED(hr))
        {
            hr = pxdn->get_nodeTypedValue(pvarOut);
            if (FAILED(hr))
            {
                TraceError("HrGetTypedValueFromElement: "
                           "get_nodeTypedValue()", hr);

                // clear pvarOut
                ::VariantInit(pvarOut);
            }
        }
        else
        {
            TraceError("HrGetTypedValueFromElement: "
                       "put_dataType()", hr);
        }

        ::SysFreeString(bstrDataType);
    }
    else
    {
        hr = E_OUTOFMEMORY;

        TraceError("HrGetTypedValueFromElement: "
                   "SysAllocString()", hr);
    }

    TraceError("HrGetTypedValueFromElement", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetTypedValueFromChildElement
//
//  Purpose:    Given an IXMLDOMElement, finds its child element
//              of the given name, and extracts the data contained
//              in that child element, decoding it from the specified
//              format.
//
//  Arguments:
//      pxdn          The element which should contain the specified
//                    children
//
//      arypszTokens  A serial list of child element names that uniquely
//                    describe the desired element.
//
//      cTokens       The number of element names contained in
//                    arypszTokens.
//
//      pszDataType   The type of the data encoded in the element.
//
//      pvarOut       Address of a VARIANT that will obtain the
//                    data value.  This must be freed when
//                    no longer needed.
//
//  Returns:
//      S_OK if *pbstrOut has been set to a new BSTR
//      S_FALSE if the specified element did not exist.
//              in this case, *pbstrOut is set to NULL
//
//  Notes:
//      for example, if the document looked like this:
//        <foo><bar>text</bar></foo>
//      and pxdn referred to <foo>, arypszTokens = [ "bar" ]
//      cTokens = 1, and sdtType = "string", this would
//      return "text".
//      See the definition of HrGetNestedChildElement() for
//      further explination.
//
HRESULT
HrGetTypedValueFromChildElement(IXMLDOMNode * pxdn,
                                CONST LPCWSTR * arypszTokens,
                                CONST ULONG cTokens,
                                CONST LPCWSTR pszDataType,
                                VARIANT * pvarOut)
{
    Assert(pxdn);
    Assert(arypszTokens);
    Assert(cTokens);
    Assert(pszDataType);
    Assert(pvarOut);

    HRESULT hr;
    IXMLDOMNode * pxdnTemp;

    pxdnTemp = NULL;

    hr = HrGetNestedChildElement(pxdn, arypszTokens, cTokens, &pxdnTemp);
    if (FAILED(hr))
    {
        pxdnTemp = NULL;

        goto Cleanup;
    }

    if (S_OK == hr)
    {
        Assert(pxdn);

        hr = HrGetTypedValueFromElement(pxdnTemp, pszDataType, pvarOut);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    // hr is S_FALSE if bstrResult is NULL, or S_OK if
    // pvarOut has been retrieved

Cleanup:
    SAFE_RELEASE(pxdnTemp);

    TraceErrorOptional("HrGetTypedValueFromChildElement", hr, (S_FALSE == hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetTextValueFromElement
//
//  Purpose:    Given an IXMLDOMNode that should be of type
//              dt:string, returns a new BSTR containing that
//              string.
//
//  Arguments:
//      pxdn        IXMLDOMNode to extract the string from.
//                  It is intended that this node be of type
//                  NODE_ELEMENT.
//
//      pbstrOut    Address of a BSTR that will obtain the
//                  text value.  This must be freed when
//                  no longer needed.
//
//  Returns:
//      S_OK if *pbstrOut has been set to a new BSTR
//
//  Notes:
//      This function should return an error if the element
//      contains things other than NODE_TEXT children.
//
HRESULT
HrGetTextValueFromElement(IXMLDOMNode * pxdn,
                          BSTR * pbstrOut)
{
    Assert(pxdn);
    Assert(pbstrOut);

    HRESULT hr;
    VARIANT varOut;

    *pbstrOut = NULL;

    hr = HrGetTypedValueFromElement(pxdn,
                                    pszTextType,
                                    &varOut);

    if (S_OK == hr)
    {
        Assert(VT_BSTR == V_VT(&varOut));

        *pbstrOut = V_BSTR(&varOut);

        // note: Don't clear varOut, since it's the returned BSTR
    }

    TraceErrorOptional("HrGetTextValueFromElement", hr, (S_FALSE == hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetTextValueFromChildElement
//
//  Purpose:    Given an IXMLDOMElement, finds its child element
//              of the given name, and extracts the dt:type="string"
//              data contained in that child element.
//
//  Arguments:
//      pxdn          The element which should contain the specified
//                    children
//
//      arypszTokens  A serial list of child element names that uniquely
//                    describe the desired element.
//
//      cTokens       The number of element names contained in
//                    arypszTokens.
//
//      pbstrOut    Address of a BSTR that will obtain the
//                  text value.  This must be freed when
//                  no longer needed.
//
//  Returns:
//      S_OK if *pbstrOut has been set to a new BSTR
//      S_FALSE if the specified element did not exist.
//              in this case, *pbstrOut is set to NULL
//
//  Notes:
//      for example, if the document looked like this:
//        <foo><bar>text</bar></foo>
//      and pxdn referred to <foo>, arypszTokens = [ "bar" ]
//      and cTokens = 1, this would return "text".
//      See the definition of HrGetNestedChildElement() for
//      further explination.
//
HRESULT
HrGetTextValueFromChildElement(IXMLDOMNode * pxdn,
                               const LPCWSTR * arypszTokens,
                               const ULONG cTokens,
                               BSTR * pbstrOut)
{
    HRESULT hr;
    VARIANT varOut;

    *pbstrOut = NULL;

    hr = HrGetTypedValueFromChildElement(pxdn,
                                         arypszTokens,
                                         cTokens,
                                         pszTextType,
                                         &varOut);
    if (S_OK == hr)
    {
        Assert(VT_BSTR == V_VT(&varOut));

        *pbstrOut = V_BSTR(&varOut);

        // note: Don't clear varOut, since it's the returned BSTR
    }

    TraceErrorOptional("HrGetTextValueFromChildElement", hr, (S_FALSE == hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsThisTheNodeName
//
//  Purpose:    Returns TRUE if the tag name of the specified XML DOM
//              element is the specified string.
//
//  Arguments:
//      pxdn        Node whose name is being tested
//
//      pszNodeName Proposed name of the node
//
//  Returns:
//      TRUE if the node name matches, FALSE if not
//
//  Notes:
//      for the xml node declared as
//          <ab:foo xmlns:ab="urn:...">...</ab:foo>
//      IsThisTheNodeName() will return TRUE only when
//      pszNodeName == T"foo";
BOOL
FIsThisTheNodeName(IXMLDOMNode * pxdn,
                   LPCWSTR pszNodeName)
{
    Assert(pxdn);
    Assert(pszNodeName);

    HRESULT hr;
    BSTR bstrNodeName;
    BOOL fResult;
    int result;

    bstrNodeName = NULL;

    hr = pxdn->get_baseName(&bstrNodeName);
    if (SUCCEEDED(hr))
    {
        Assert(bstrNodeName);

        result = wcscmp(bstrNodeName, pszNodeName);

        ::SysFreeString(bstrNodeName);

        return (result == 0) ? TRUE : FALSE;
    }

    TraceError("OBJ: FIsThisTheNodeName - get_baseName", hr);
    Assert(!bstrNodeName);

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsThisTheNodeNameWithNamespace
//
//  Purpose:    Returns TRUE if the element name of the specified XML DOM
//              element is the specified string and is in a given namespace.
//
//  Arguments:
//      pxdn               Node whose name is being tested
//      pszNodeName        Proposed base name of the node
//      pszNamespaceURI    Proposed namespace URI of the node
//
//  Returns:
//      TRUE if the node name matches, FALSE if not
//
//  Notes:
//      for the xml node declared as
//          <ab:foo xmlns:ab="urn:...">...</ab:foo>
//      FIsThisTheNodeNameWithNamespace() will return TRUE only when
//      pszNodeName == L"foo" and pszNamespaceURI == L"urn:..."
BOOL
FIsThisTheNodeNameWithNamespace(IXMLDOMNode * pxdn,
                                LPCWSTR pszNodeName,
                                LPCWSTR pszNamespaceURI)
{
    Assert(pxdn);
    Assert(pszNodeName);
    Assert(pszNamespaceURI);

    HRESULT hr = S_OK;;
    BSTR    bstrNodeName = NULL;
    BSTR    bstrNamespaceURI = NULL;
    BOOL    fResult = FALSE;

    hr = pxdn->get_baseName(&bstrNodeName);

    if (SUCCEEDED(hr))
    {
        if (bstrNodeName)
        {
            hr = pxdn->get_namespaceURI(&bstrNamespaceURI);

            if (SUCCEEDED(hr))
            {
                if (bstrNamespaceURI)
                {
                    if ((lstrcmpW(bstrNodeName, pszNodeName) == 0) &&
                        (lstrcmpW(bstrNamespaceURI, pszNamespaceURI) == 0))
                    {
                        fResult = TRUE;
                    }

                    ::SysFreeString(bstrNamespaceURI);
                }
            }

            ::SysFreeString(bstrNodeName);
        }
    }

    TraceError("FIsThisTheNodeNameWithNamespace(): "
               "Exiting", hr);

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsThisTheNodeTextValue
//
//  Purpose:    Determines whether the text value of a node matches a specified
//              value
//
//  Arguments:
//      pxdn         [in] The node to check
//      cszTextValue [in] The value to compare against
//
//  Returns:
//    TRUE if the node's text value matches the value specified in cszTextValue
//    FALSE otherwise
//
//  Author:     spather   2000/11/2
//
//  Notes:
//
BOOL
FIsThisTheNodeTextValue(
    IN IXMLDOMNode * pxdn,
    IN LPCWSTR     cszTextValue)
{
    HRESULT    hr = S_OK;
    BOOL       fResult = FALSE;
    BSTR       bstrNodeText = NULL;

    Assert(pxdn);
    Assert(cszTextValue);

    hr = pxdn->get_text(&bstrNodeText);

    if (SUCCEEDED(hr))
    {
        Assert(bstrNodeText);

        if (0 == lstrcmpW(bstrNodeText, cszTextValue))
        {
            fResult = TRUE;
        }
        SysFreeString(bstrNodeText);
    }
    else
    {
        TraceError("FIsThisTheNodeTextValue(): "
                   "Failed to get node text",
                   hr);
    }

    TraceError("FIsThisTheNodeTextValue(): "
               "Exiting",
               hr);

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   FAreNodeValuesEqual
//
//  Purpose:    Compares the text values of two DOM nodes and, if they are
//              equal, returns TRUE.
//
//  Arguments:
//      pxdn1 [in] The first node
//      pxdn2 [in] The second node
//
//  Returns:
//    TRUE if the nodes' text values are equal, false otherwise.
//
//  Author:     spather   2000/11/2
//
//  Notes:
//
BOOL
FAreNodeValuesEqual(
    IN IXMLDOMNode * pxdn1,
    IN IXMLDOMNode * pxdn2)
{
    HRESULT    hr = S_OK;
    BOOL       fResult = FALSE;
    BSTR       bstrNode1Text = NULL;
    BSTR       bstrNode2Text = NULL;

    hr = pxdn1->get_text(&bstrNode1Text);

    if (SUCCEEDED(hr))
    {
        Assert(bstrNode1Text);

        hr = pxdn2->get_text(&bstrNode2Text);

        if (SUCCEEDED(hr))
        {
            Assert(bstrNode2Text);
        }
        else
        {
            TraceError("FAreNodeValuesEqual(): "
                       "Failed to get node 2 text",
                       hr);
        }
    }
    else
    {
        TraceError("FAreNodeValuesEqual(): "
                   "Failed to get node 1 text",
                   hr);
    }

    if (SUCCEEDED(hr))
    {
        if (0 == lstrcmpW(bstrNode1Text, bstrNode2Text))
        {
            fResult = TRUE;
        }
    }

    if (bstrNode1Text)
    {
        SysFreeString(bstrNode1Text);
    }

    if (bstrNode2Text)
    {
        SysFreeString(bstrNode2Text);
    }

    TraceError("FAreNodeValuesEqual(): "
               "Exiting",
               hr);

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAreThereDuplicatesInChildNodeTextValues
//
//  Purpose:    Starting from a specified parent node, this function
//              examines all child nodes that have a given name, and
//              checks their text values to see whether duplicates
//              exist (i.e. whether two or more of these child nodes
//              have the same text value).
//
//  Arguments:
//      pxdn              [in]  The parent node
//      cszXSLPattern     [in]  XSL Pattern identifying the name of the child
//                              nodes to examine
//      fCaseSensitive    [in]  Indicates whether the text values should be
//                              examined with a case-sensitive or case-
//                              insensitive comparison (if TRUE, compare will
//                              be case-sensitive)
//      pfDuplicatesExist [out] Receives a boolean value indicating whether or
//                              not there were duplicates in the child node
//                              values. (TRUE if there were duplicates
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/11/5
//
//  Notes:
//    This function uses a very simple O(n^2) algorithm. Do not use it to
//    check nodes that have very many (> 100) children.

HRESULT
HrAreThereDuplicatesInChildNodeTextValues(
    IN  IXMLDOMNode * pxdn,
    IN  LPCWSTR     cszXSLPattern,
    IN  BOOL        fCaseSensitive,
    OUT BOOL        * pfDuplicatesExist)
{
    HRESULT            hr = S_OK;
    BOOL               fDuplicatesExist = FALSE;
    LONG               lNumNodes = 0;
    BSTR               * rgbstrValues = NULL;
    BSTR               bstrXSLPattern;
    IXMLDOMNodeList    * pxdnlNodes = NULL;

    Assert(pxdn);
    Assert(cszXSLPattern);
    Assert(pfDuplicatesExist);

    // Get the child nodes that match the XSL pattern.

    bstrXSLPattern = SysAllocString(cszXSLPattern);

    if (bstrXSLPattern)
    {
        hr = pxdn->selectNodes(bstrXSLPattern, &pxdnlNodes);

        SysFreeString(bstrXSLPattern);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrAreThereDuplicatesInChildNodeTextValues(): "
                   "Failed to allocate BSTR for XSL pattern",
                   hr);
    }

    // Construct an array of the child nodes' text values.

    if (SUCCEEDED(hr))
    {
        Assert(pxdnlNodes);

        hr = pxdnlNodes->get_length(&lNumNodes);

        if (SUCCEEDED(hr))
        {
            if (lNumNodes > 0)
            {
                rgbstrValues = new BSTR[lNumNodes];
                if (rgbstrValues)
                {
                    ZeroMemory(rgbstrValues, lNumNodes * sizeof(BSTR));

                    for (LONG i = 0; SUCCEEDED(hr) && (i < lNumNodes); i++)
                    {
                        IXMLDOMNode * pxdnChild = NULL;

                        hr = pxdnlNodes->get_item(i, &pxdnChild);

                        if (SUCCEEDED(hr))
                        {
                            Assert(pxdnChild);

                            hr = pxdnChild->get_text(&rgbstrValues[i]);

                            if (FAILED(hr))
                            {
                                TraceError("HrAreThereDuplicatesInChildNodeTextValues(): "
                                           "Failed to get node text value",
                                           hr);
                            }
                            pxdnChild->Release();
                        }
                        else
                        {
                            TraceError("HrAreThereDuplicatesInChildNodeTextValues(): "
                                       "Failed to get list item",
                                       hr);
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("HrAreThereDuplicatesInChildNodeTextValues(): "
                               "Failed to allocate text value array",
                               hr);
                }

            }
        }

        pxdnlNodes->Release();
    }
    else
    {
        TraceError("HrAreThereDuplicatesInChildNodeTextValues(): "
                   "Failed to get nodes matching XSL pattern",
                   hr);
    }

    // Check the array for duplicates.

    if (SUCCEEDED(hr) && (lNumNodes > 0))
    {
        Assert(rgbstrValues);

        for (LONG i = 0; i < lNumNodes; i++)
        {
            for (LONG j = i+1; j < lNumNodes; j++)
            {
                if (fCaseSensitive)
                {
                    if (0 == lstrcmpW(rgbstrValues[i], rgbstrValues[j]))
                    {
                        fDuplicatesExist = TRUE;
                        break;
                    }
                }
                else
                {
                    if (0 == lstrcmpiW(rgbstrValues[i], rgbstrValues[j]))
                    {
                        fDuplicatesExist = TRUE;
                        break;
                    }
                }
            }
        }
    }

    // Clean up the array.

    if (rgbstrValues)
    {
        for (LONG i = 0; i < lNumNodes; i++)
        {
            if (rgbstrValues[i])
            {
                SysFreeString(rgbstrValues[i]);
                rgbstrValues[i] = NULL;
            }
        }
        delete [] rgbstrValues;
        rgbstrValues = NULL;
    }

    if (SUCCEEDED(hr))
    {
        *pfDuplicatesExist = fDuplicatesExist;
    }

    TraceError("HrAreThereDuplicatesInChildNodeTextValues(): "
               "Exiting",
               hr);
    return hr;
}

HRESULT
HrGetFirstChildElement(IXMLDOMNode * pxdn,
                       LPCWSTR pszNodeName,
                       IXMLDOMNode ** ppxdn)
{
    Assert(pxdn);
    Assert(pszNodeName);
    Assert(ppxdn);

    HRESULT hr;
    IXMLDOMNode * pxdnChild;

    pxdnChild = NULL;

    hr = pxdn->get_firstChild(&pxdnChild);
    if (FAILED(hr))
    {
        TraceError("HrGetFirstChildElement - get_firstChild", hr);

        pxdnChild = NULL;

        goto Cleanup;
    }
    // maybe there is a child, maybe not.

    hr = HrGetChildElement(pxdnChild, pszNodeName, ppxdn);

Cleanup:
    SAFE_RELEASE(pxdnChild);

    TraceErrorOptional("HrGetFirstChildElement", hr, (S_FALSE == hr));
    return hr;
}


HRESULT
HrGetNextChildElement(IXMLDOMNode * pxdnLastChild,
                      LPCWSTR pszNodeName,
                      IXMLDOMNode ** ppxdn)
{
    Assert(pxdnLastChild);
    Assert(pszNodeName);
    Assert(ppxdn);

    HRESULT hr;
    IXMLDOMNode * pxdnChild;
    IXMLDOMNode * pxdnResult;

    pxdnChild = NULL;
    pxdnResult = NULL;

    // we're searching for another child.
    hr = pxdnLastChild->get_nextSibling(&pxdnChild);
    if (FAILED(hr))
    {
        TraceError("HrGetNextChildElement - get_nextSibling", hr);
        pxdnChild = NULL;

        // we couldn't get the next child, and we haven't found a result,
        // so we need to barf.
        goto Cleanup;
    }
    // maybe there was a next node, maybe there wasn't

    hr = HrGetChildElement(pxdnChild, pszNodeName, &pxdnResult);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    Assert(FImplies(S_OK == hr, pxdnResult));
    Assert(FImplies(S_OK != hr, !pxdnResult));

    SAFE_RELEASE(pxdnChild);

    *ppxdn = pxdnResult;

    TraceErrorOptional("HrGetNextChildElement", hr, (S_FALSE == hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetChildElement
//
//  Purpose:    Returns the first child element of a given name.
//
//  Arguments:
//      pxdn        Node to start searching at.  This node and its
//                  subsequent siblings are searched.
//                  Note that this MAY be null, in which case this
//                  function doesn't do much...
//
//      pszNodeName Name of the desired child node.
//
//      ppxdn       On return, contiains an AddRef()'d IXMLDOMNode
//                  pointer to the child element, if one of the
//                  given name exists.
//
//  Returns:
//      S_OK    if a matching child node has been found.  *ppxdn contains
//              a reference to this found node
//      S_FALSE if no matching child was found.  *ppxdn is set to NULL.
//
//  Notes:
//      To retrieve a child element declared as <xxxx:yyyy>, pszNodeName
//      must be "yyyy".
//      TODO: make sure the elements considered match a specified
//            namespace uri.
HRESULT
HrGetChildElement(IXMLDOMNode * pxdn,
                  LPCWSTR pszNodeName,
                  IXMLDOMNode ** ppxdn)
{
    Assert(ppxdn);
    Assert(pszNodeName);

    HRESULT hr;
    IXMLDOMNode * pxdnChild;

    if (pxdn)
    {
        pxdn->AddRef();
    }

    // in case pxdnChild is NULL
    hr = S_FALSE;
    pxdnChild = pxdn;

    while (pxdnChild)
    {
        // invaiant: pxdnChild is an addref()'d pointer to the current
        // child of interest
        IXMLDOMNode * pxdnTemp;
        DOMNodeType dnt;

        pxdnTemp = NULL;

        // get the DOMNodeType
        hr = pxdnChild->get_nodeType(&dnt);
        if (FAILED(hr))
        {
            TraceError("HrGetChildElement - get_nodeType", hr);

            goto Error;
        }

        if (NODE_ELEMENT == dnt)
        {
            if (FIsThisTheNodeName(pxdnChild, pszNodeName))
            {
                break;
            }
        }

        hr = pxdnChild->get_nextSibling(&pxdnTemp);
        if (FAILED(hr))
        {
            TraceError("HrGetChildElement - get_nextSibling", hr);

            // we couldn't get the next child, and we haven't found a result,
            // so we need to barf.
            goto Error;
        }
        Assert((S_OK == hr) || (S_FALSE == hr));
        Assert(FImplies(S_OK == hr, pxdnTemp));
        Assert(FImplies(S_FALSE == hr, !pxdnTemp));

        // note: if hr is S_FALSE, we're done

        pxdnChild->Release();
        pxdnChild = pxdnTemp;
    }

    Assert((S_OK == hr) || (S_FALSE == hr));
    Assert(FImplies(S_OK == hr, pxdnChild));
    Assert(FImplies(S_FALSE == hr, !pxdnChild));

    // post-loop-condition: pxdnChild is an addref'd pointer to the
    //                      matching child, of type NODE_ELEMENT.
    //                      if there is no match, pxdnChild is NULL.

Cleanup:
    *ppxdn = pxdnChild;

    TraceErrorOptional("HrGetChildElement", hr, (S_FALSE == hr));
    return hr;

Error:
    hr = E_FAIL;

    SAFE_RELEASE(pxdnChild);

    goto Cleanup;
}

// Used for Validation duplicate tags in Description Document - Guru
HRESULT HrIsElementPresentOnce(
    IXMLDOMNode * pxdnRoot,
    LPCWSTR pszNodeName ) {

    HRESULT hr = S_OK ;
    LONG nNumNodes = 0;
    IXMLDOMNodeList    * pxdnlNodes = NULL;
    BSTR bstrXSLPattern = NULL;

    bstrXSLPattern = SysAllocString(pszNodeName);

    if (bstrXSLPattern)
    {
        hr = pxdnRoot->selectNodes(bstrXSLPattern, &pxdnlNodes);
        if(hr == S_OK)
        {
            hr = pxdnlNodes->get_length(&nNumNodes);
            if(SUCCEEDED(hr))
            {
                if ( nNumNodes == 1 )
                   hr = S_OK;
                else {
                   hr = E_FAIL ;
                   //hr = S_FALSE;
                }
            }
        }
        else
            hr = E_FAIL;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrIsElementPresentOnce(): "
                   "Failed to allocate BSTR for XSL pattern",
                   hr);
    }

    SAFE_RELEASE(pxdnlNodes);
    SysFreeString(bstrXSLPattern);

    TraceErrorOptional("HrIsElementPresentOnce", hr, (S_FALSE == hr));
    return hr;
}

// Used for Validation duplicate tags in Description Document - Guru
HRESULT HrCheckForDuplicateElement(IXMLDOMNode * pxdnRoot,
                                            LPCWSTR pszNodeName ) {

    HRESULT hr = S_OK ;
    LONG nNumNodes = 0;
    IXMLDOMNodeList    * pxdnlNodes = NULL;
    BSTR bstrXSLPattern = NULL;

    bstrXSLPattern = SysAllocString(pszNodeName);

    if (bstrXSLPattern)
    {
        hr = pxdnRoot->selectNodes(bstrXSLPattern, &pxdnlNodes);
        if(hr == S_OK)
        {
            hr = pxdnlNodes->get_length(&nNumNodes);
            if(SUCCEEDED(hr))
            {
                if ( nNumNodes > 1 )
                {
                   hr = E_FAIL;
                   TraceError("HrCheckForDuplicateElement(): "
                             "Duplicate Tag Present",
                             hr);
                }
                else {
                    hr = S_OK;
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrCheckForDuplicateElement(): "
                   "Failed to allocate BSTR for XSL pattern",
                   hr);
    }

    SAFE_RELEASE(pxdnlNodes);
    SysFreeString(bstrXSLPattern);

    TraceErrorOptional("HrCheckForDuplicateElement", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetNestedChildElement
//
//  Purpose:    Returns the nth-level child of a particular element,
//              given the name of the element and the name of each
//              intermediate element.
//
//  Arguments:
//      pxdnRoot      The element which should contain the specified
//                    children
//
//      arypszTokens  A serial list of child element names that uniquely
//                    describe the desired element.  See notes below.
//
//      cTokens       The number of element names contained in
//                    arypszTokens.
//
//      ppxdn         On return, contiains an AddRef()'d IXMLDOMNode
//                    pointer to the child element, if one of the
//                    given name exists.
//
//  Returns:
//      S_OK    if a matching child node has been found.  *ppxdn contains
//              a reference to this found node
//      S_FALSE if no matching child was found.  *ppxdn is set to NULL.
//
//  Notes:
//      To retrieve a child element declared as <xxxx:yyyy>, pszNodeName
//      must be "yyyy".
//      TODO: make it ensure that there is only ONE matching node!
//      also...
//      TODO: make sure the elements considered match a specified
//            namespace uri.
//
// overview of function:
// given a list of element names and a root element, it returns the
// "n"th child element of the given element.
// e.g., if the "root" element passed in was <foo> and the tokens
// passed in were ["bar","car","dar" and "ear"], and the document
// looked like the following,
// <foo> <--- pxdnRoot
//  <bar>
//   <car>
//    <dar>
//     <ear/>
//    </dar>
//   </car>
//  </bar>
// </foo>
// this returns the IXMLDOMNode reference to "<ear/>"
//
// if more than one of the desired name exists at a given level,
// this will chose the first element.
// <foo>
//  <bar>...</bar> <!-- this one is returned -->
//  <bar>...</bar>
// </foo>
//
// TODO: only return an element if its namespace matches the desired
//       namespace uri
//
//      pszNameSpaceURI = URI of the namespace that each element in the
//      token list must be defined in
HRESULT
HrGetNestedChildElement(IXMLDOMNode * pxdnRoot,
                        const LPCWSTR * arypszTokens,
                        const ULONG cTokens,
                        IXMLDOMNode ** ppxdn)
{
    HRESULT hr;
    IXMLDOMNode * pxdnCurrent;
    ULONG i;

    Assert(pxdnRoot);
    Assert(arypszTokens);
    Assert(cTokens);
    Assert(ppxdn);

    pxdnCurrent = pxdnRoot;
    pxdnCurrent->AddRef();

    i = 0;
    for ( ; i < cTokens; ++i)
    {
        Assert(arypszTokens[i]);

        IXMLDOMNode * pxdnChild;

        pxdnChild = NULL;


        hr = HrGetFirstChildElement(pxdnCurrent, arypszTokens[i], &pxdnChild);
        if (FAILED(hr))
        {
            goto Error;
        }
        else if (S_FALSE == hr)
        {
            // the child of the specified name doesn't exist.  well, then...
            // we return S_FALSE and NULL in this case, which is what
            // we happen to have in hr and will put in pxdnCurrent
            goto Error;
        }
        Assert(pxdnChild);

        pxdnCurrent->Release();
        pxdnCurrent = pxdnChild;
    }
    Assert(pxdnCurrent);

    // pxdnCurrent is the desired child

Cleanup:
    Assert(FImplies((S_OK == hr), pxdnCurrent));
    Assert(FImplies(S_OK != hr, !pxdnCurrent));

    *ppxdn = pxdnCurrent;

    TraceErrorOptional("HrGetNestedChildElement", hr, (S_FALSE == hr));
    return hr;

Error:
    // we didn't find a match
    SAFE_RELEASE(pxdnCurrent);
    goto Cleanup;
}


// return values:
//   S_OK       all values have been read
//   error      some element couldn't be read.
//              the returned array is undefined.
HRESULT
HrReadElementWithParseData (IXMLDOMNode * pxdn,
                            const ULONG cElems,
                            const DevicePropertiesParsingStruct dppsInfo [],
                            LPCWSTR pszBaseUrl,
                            LPWSTR arypszReadValues [])
{
    Assert(pxdn);
    Assert(cElems);
    Assert(dppsInfo);
    Assert(arypszReadValues);

    HRESULT hr = S_OK;
    ULONG i;

    ::ZeroMemory(arypszReadValues, sizeof(LPWSTR *) * cElems);

    i = 0;
    for ( ; i < cElems; ++i )
    {
        BSTR bstrTemp;

        bstrTemp = NULL;

        hr = HrGetTextValueFromChildElement(pxdn,
                                            &(dppsInfo[i].m_pszTagName),
                                            1,
                                            &bstrTemp);
        Assert(FImplies((S_FALSE == hr), !bstrTemp));
        if (S_OK == hr)
        {
            Assert(bstrTemp);

            if (dppsInfo[i].m_fIsUrl)
            {
                LPWSTR pszTemp;

                pszTemp = NULL;
                if (pszBaseUrl)
                {
                    // we have to combine base and relative urls
                    hr = HrCombineUrl(pszBaseUrl, bstrTemp, &pszTemp);
                }
                else
                {
                    // just copy and validate the url
                    hr = HrCopyAndValidateUrl(bstrTemp, &pszTemp);
                    if (S_FALSE == hr)
                    {
                        // invalid urls aren't acceptable
                        hr = E_FAIL;
                    }
                }

                if (SUCCEEDED(hr))
                {
                    arypszReadValues[i] = pszTemp;
                }
            }
            else
            {
                // just copy the value
                arypszReadValues[i] = WszAllocateAndCopyWsz(bstrTemp);
                if (!(arypszReadValues[i]))
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            ::SysFreeString(bstrTemp);
        }
        // note: hr may have been changed by the above code

        if (FAILED(hr))
        {
            Assert(!(arypszReadValues[i]));
            goto Error;
        }
        TraceTag(ttidUPnPDescriptionDoc,"XML Tag - %S - %S",dppsInfo[i].m_pszTagName,arypszReadValues[i]);
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

Cleanup:
    TraceError("HrReadElementWithParseData", hr);
    return hr;

Error:
    // we need to free the strings we've already allocated
    {
        ULONG j;

        // i is the number of elements successfully read above
        j = 0;
        for ( ; j < i; ++j )
        {
            Assert(arypszReadValues[j]);

            delete [] arypszReadValues[j];

            arypszReadValues[j] = NULL;
        }
    }

    goto Cleanup;
}

// Used for Validation duplicate tags in Description Document - Guru
// If the element is optional we check if the Tag is present At most Once
// IF the element is required we check if its present exactly once
HRESULT HrAreElementTagsValid(IXMLDOMNode *pxdnRoot,
                                     const ULONG cElems,
                                     const DevicePropertiesParsingStruct dppsInfo [])
{
    HRESULT hr = S_OK;
    ULONG i;

    i = 0;
    for ( ; i < cElems; ++i )
    {
        if (dppsInfo[i].m_fOptional)
        {
            hr = HrCheckForDuplicateElement(pxdnRoot,dppsInfo[i].m_pszTagName);
        }
        else {
            hr = HrIsElementPresentOnce(pxdnRoot,dppsInfo[i].m_pszTagName);
        }
        if(FAILED(hr))
            break;
    }


    TraceError("HrAreElementTagsValid", hr);
    return hr;
}

// return TRUE if all of the non-optional values (as specified by the
// m_fOptional in dppsInfo) are non-null in arypszReadValues.
// equivalently, it returns FALSE if there exists a value marked as
// required (m_fOptional == FALSE) that is NULL in arypszReadValues.
BOOL
fAreReadValuesComplete (const ULONG cElems,
                        const DevicePropertiesParsingStruct dppsInfo [],
                        const LPCWSTR arypszReadValues [])
{
    ULONG i;
    BOOL fResult;

    fResult = TRUE;
    i = 0;
    for ( ; i < cElems; ++i )
    {
        if (!dppsInfo[i].m_fOptional)
        {
            if (!(arypszReadValues[i]))
            {
                fResult = FALSE;
                break;
            }
        }
    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetTextValueFromAttribute
//
//  Purpose:    Retrieves the text value of an attribute on a DOM element node
//
//  Arguments:
//      pxdn           [in] XML DOM Node representing the element whose
//                          attribute is to be read
//      szAttrName     [in] Name of the attribute
//      pbstrAttrValue [in] Receives the attribute text value.
//
//  Returns:
//    If the function successfully reads the attribute value, the return value
//    is S_OK and the attribute value is returned at pbstrAttrValue. If the
//    attribute does not exist on the element, the function returns S_FALSE,
//    and NULL at pbstrAttrValue. Otherwise the function returns one of the
//    error codes defined in WinError.h.
//
//  Author:     spather   2000/11/9
//
//  Notes:
//
HRESULT
HrGetTextValueFromAttribute(
    IN  IXMLDOMNode    * pxdn,
    IN  LPCWSTR        szAttrName,
    OUT BSTR           * pbstrAttrValue)
{
    HRESULT        hr = S_OK;
    IXMLDOMElement * pxde = NULL;
    BSTR           bstrValue = NULL;

    hr = pxdn->QueryInterface(IID_IXMLDOMElement,
                              (void **) &pxde);

    if (SUCCEEDED(hr))
    {
        BSTR   bstrAttrName = NULL;

        Assert(pxde);

        bstrAttrName = SysAllocString(szAttrName);

        if (bstrAttrName)
        {
            VARIANT varValue;

            VariantInit(&varValue);

            hr = pxde->getAttribute(bstrAttrName,
                                    &varValue);

            if (SUCCEEDED(hr))
            {
                if (VT_NULL == varValue.vt)
                {
                    Assert(S_FALSE == hr);
                }
                else if (VT_BSTR == varValue.vt)
                {
                    bstrValue = V_BSTR(&varValue);
                }
                else
                {
                    Assert(FALSE); // Should never be here.
                }
            }
            else
            {
                TraceError("HrGetTextValueFromAttribute(): "
                           "Failed to get attribute value",
                           hr);
            }

            SysFreeString(bstrAttrName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrGetTextValueFromAttribute(): "
                       "Failed to allocate attribute name BSTR",
                       hr);
        }

        pxde->Release();
    }
    else
    {
        TraceError("HrGetTextValueFromAttribute(): "
                   "Failed to get IXMLDOMElement interface",
                   hr);
    }

    if (SUCCEEDED(hr))
    {
        *pbstrAttrValue = bstrValue;
    }
    else
    {
        if (bstrValue)
        {
            SysFreeString(bstrValue);
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrGetTextValueFromAttribute");

    return hr;
}

/*
 * Function:    HrSetTextAttribute()
 *
 * Purpose:     Sets an text-valued attribute on an XML element.
 *
 * Arguments:
 *  pElement        [in]    The element on which to set the attribute
 *  pcwszAttrName   [in]    The attribute name
 *  pcwszValue      [in]    The value to give the attribute
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrSetTextAttribute(
                   IXMLDOMElement * pElement,
                   LPCWSTR        pcwszAttrName,
                   LPCWSTR        pcwszValue)
{
    HRESULT hr = S_OK;
    VARIANT vValue;
    BSTR    bstrValue, bstrAttrName;

    // Allocate BSTRs for the attribute name and value.

    bstrValue = SysAllocString(pcwszValue);

    if (bstrValue)
    {
        bstrAttrName = SysAllocString(pcwszAttrName);

        if (!bstrAttrName)
        {
            hr = E_OUTOFMEMORY;
            SysFreeString(bstrValue);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        // danielwe: Bug 144883
        VariantInit(&vValue);

        vValue.vt = VT_BSTR;
        V_BSTR(&vValue) = bstrValue;

        hr = pElement->setAttribute(bstrAttrName, vValue);

        SysFreeString(bstrValue);
        SysFreeString(bstrAttrName);
    }

    return hr;
}


/*
 * Function:    HrCreateElementWithType()
 *
 * Purpose:     Creates an XML element containing a binary value that is
 *              encoded in bin.base64.
 *
 * Arguments:
 *  pDoc                [in]    Document in which to create the element
 *  pcwszElementName    [in]    Name for the new element
 *  pszDataType         [in]    The type of the data encoded in the element.
 *  varData             [in]    Data to insert as the element's value
 *  ppElement           [out]   Address at which to place the pointer to the
 *                              new element object
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  This function does not actually insert the new element into the document
 *  tree.
 */

HRESULT
HrCreateElementWithType(
                     IN   IXMLDOMDocument *     pDoc,
                     IN   LPCWSTR               pcwszElementName,
                     IN   LPCWSTR               pszDataType,
                     IN   VARIANT               varData,
                     OUT  IXMLDOMElement **     ppElement)
{
    Assert(pDoc);
    Assert(pcwszElementName);
    Assert(pszDataType);
    Assert(ppElement);

    HRESULT         hr;
    BSTR            bstrElementName;

    hr = S_OK;
    *ppElement = NULL;

    bstrElementName = SysAllocString(pcwszElementName);
    if (bstrElementName)
    {
        IXMLDOMElement  * pElement = NULL;

        hr = pDoc->createElement(bstrElementName,
                                 &pElement);

        if (SUCCEEDED(hr))
        {
            BSTR bstrDataType;

            bstrDataType = ::SysAllocString(pszDataType);
            if (bstrDataType)
            {
                hr = pElement->put_dataType(bstrDataType);
                if (SUCCEEDED(hr))
                {
                    hr = pElement->put_nodeTypedValue(varData);
                    if (SUCCEEDED(hr))
                    {
                        *ppElement = pElement;
                        pElement->AddRef();
                    }
                    else
                    {
                        TraceError("HrCreateElementWithType(): "
                                   "put_nodeTypedValue", hr);
                    }
                }
                else
                {
                    TraceError("HrCreateElementWithType(): "
                               "put_dataType", hr);
                }

                ::SysFreeString(bstrDataType);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrCreateElementWithType(): "
                           "SysAllocString", hr);
            }

            pElement->Release();
        }
        else
        {
            TraceError("HrCreateElementWithType(): "
                       "Could not create element", hr);
        }

        ::SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrCreateElementWithType(): "
                   "Could not allocate BSTR", hr);
    }

    return hr;
}


/*
 * Function:    HrCreateElementWithTextValue()
 *
 * Purpose:     Creates an XML element containing a text string as
 *              a value.
 *
 * Arguments:
 *  pDoc                [in]    Document in which to create the element
 *  pcwszElementName    [in]    Name for the new element
 *  pcwszTextValue      [in]    Text to insert as the element's value
 *  ppElement           [out]   Address at which to place the pointer to the
 *                              new element object
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  This function does not actually insert the new element into the document
 *  tree.
 */

HRESULT
HrCreateElementWithTextValue(
                             IN   IXMLDOMDocument * pDoc,
                             IN   LPCWSTR         pcwszElementName,
                             IN   LPCWSTR         pcwszTextValue,
                             OUT  IXMLDOMElement  ** ppElement)
{
    HRESULT         hr = S_OK;
    IXMLDOMElement  * pElement = NULL;
    BSTR            bstrElementName, bstrTextValue;

    *ppElement = NULL;

    // Allocate BSTRs for the element name and value.

    bstrElementName = SysAllocString(pcwszElementName);

    if (bstrElementName)
    {
        bstrTextValue = SysAllocString(pcwszTextValue);

        if (!bstrTextValue)
        {
            hr = E_OUTOFMEMORY;
            SysFreeString(bstrElementName);
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = pDoc->createElement(bstrElementName,
                                 &pElement);

        if (SUCCEEDED(hr))
        {
            IXMLDOMText * pText = NULL;

            hr = pDoc->createTextNode(bstrTextValue,
                                  &pText);

            if (SUCCEEDED(hr))
            {
                VARIANT vAfter;

                // danielwe: Bug 144882
                VariantInit(&vAfter);

                vAfter.vt = VT_EMPTY;

                hr = pElement->insertBefore(pText,
                                            vAfter,
                                            NULL);

                if (FAILED(hr))
                {
                    TraceError("HrCreateElementWithTextValue(): "
                               "Failed to insert text node", hr);
                }

                pText->Release();
            }
            else
            {
                TraceError("HrCreateElementWithTextValue(): "
                           "Failed to create text node", hr);
            }


            if (SUCCEEDED(hr))
            {
                *ppElement = pElement;
                pElement->AddRef();
            }

            pElement->Release();
        }
        else
        {
            TraceError("HrCreateElementWithTextValue(): "
                       "Could not create element", hr);
        }

        SysFreeString(bstrElementName);
        SysFreeString(bstrTextValue);
    }
    else
    {
        TraceError("HrCreateElementWithTextValue(): "
                   "Could not allocate BSTRs", hr);
    }

    return hr;
}

/*
 * Function:    HrCreateElement()
 *
 * Purpose:     Create an XML Element DOM object
 *
 * Arguments:
 *  pxdd                [in]    The document object in whose context the
 *                              element will be created
 *  pcwszElementName    [in]    Name of the element to be created
 *  pcwszNamespaceURI   [in]    URI identifying the namespace to which
 *                              the element name belongs
 *  ppxdnNewElt         [out]   The newly created element object
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrCreateElement(
    IN  IXMLDOMDocument    * pxdd,
    IN  LPCWSTR            pcwszElementName,
    IN  LPCWSTR            pcwszNamespaceURI,
    OUT IXMLDOMNode        ** ppxdnNewElt)
{
    HRESULT        hr = S_OK;
    IXMLDOMNode    * pxdnNewElt = NULL;
    BSTR           bstrElementName = NULL;
    BSTR           bstrNamespaceURI = NULL;

    Assert(pxdd);
    Assert(pcwszElementName);
    Assert(ppxdnNewElt);

    // Allocate BSTRs

    bstrElementName = SysAllocString(pcwszElementName);

    if (bstrElementName)
    {
        if (pcwszNamespaceURI)
        {
            bstrNamespaceURI = SysAllocString(pcwszNamespaceURI);

            if (NULL == bstrNamespaceURI)
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrCreateElement(): "
                           "Failed to allocate memory for name string",
                           hr);
            }
        }

        if (SUCCEEDED(hr))
        {
            VARIANT varNodeType;

            VariantInit(&varNodeType);
            varNodeType.vt = VT_I4;
            V_I4(&varNodeType) = (int) NODE_ELEMENT;

            hr = pxdd->createNode(varNodeType,
                                  bstrElementName,
                                  bstrNamespaceURI,
                                  &pxdnNewElt);

            if (FAILED(hr))
            {
                TraceError("HrCreateElement(): "
                           "Failed to create element node",
                           hr);
            }


            if (bstrNamespaceURI)
            {
                SysFreeString(bstrNamespaceURI);
            }
        }


        SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrCreateElement(): "
                   "Failed to allocate memory for name string",
                   hr);
    }

    if (SUCCEEDED(hr))
    {
        *ppxdnNewElt = pxdnNewElt;
    }

    TraceError("HrCreateElement(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    HrAppendProcessingInstruction()
 *
 * Purpose:     Append a processing instruction to the DOM document
 *
 * Arguments:
 *  pxdd                [in]    The document object in whose context the
 *                              element will be created
 *  pcwszName           [in]    Name of the processing instruction to be created
 *  pcwszValue          [in]    The text value of the p.i.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrAppendProcessingInstruction(
    IN  IXMLDOMDocument * pxdd,
    IN  LPCWSTR         pcwszName,
    IN  LPCWSTR         pcwszValue)
{
    HRESULT hr = S_OK;

    Assert(pxdd);
    Assert(pcwszName);
    Assert(pcwszValue);

    IXMLDOMProcessingInstruction* pxdpi = NULL;
    BSTR bstrTarget = SysAllocString(pcwszName);
    BSTR bstrData = SysAllocString(pcwszValue);
    if (bstrTarget && bstrData)
    {
        hr = pxdd->createProcessingInstruction(bstrTarget, bstrData, &pxdpi);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    SysFreeString(bstrTarget);
    SysFreeString(bstrData);

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode* pxdn = NULL;
        hr = pxdpi->QueryInterface(IID_IXMLDOMNode, (void**)&pxdn);
        if (SUCCEEDED(hr))
        {
            hr = pxdd->appendChild(pxdn, NULL);
            pxdn->Release();
        }
    }

    if (pxdpi)
    {
        pxdpi->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\validatesd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       V A L I D A T E S D . C P P
//
//  Contents:   Implementation of service description validation routines
//
//  Notes:
//
//  Author:     spather   2000/10/17
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "upnp.h"
#include "Validate.h"
#include "ncxml.h"
#include "ncstring.h"

LPCWSTR CWSZ_UPNP_SERVICE_NAMESPACE = L"urn:schemas-upnp-org:service-1-0";


BOOL
fIsNodeValueInList(
    IN  IXMLDOMNode    * pxdn,
    IN  BOOL           fCaseSensitive,
    IN  const DWORD    cValues,
    IN  LPCWSTR        rgcszValues[],
    OUT DWORD          * pdwIndex)
{
    HRESULT hr = S_OK;
    BOOL    fResult = FALSE;
    BSTR    bstrText = NULL;

    Assert(cValues > 0);
    Assert(rgcszValues);

    hr = pxdn->get_text(&bstrText);

    if (SUCCEEDED(hr))
    {
        Assert(bstrText);

        for (DWORD i = 0; i < cValues; i++)
        {
            if (fCaseSensitive)
            {
                if (0 == lstrcmpW(bstrText, rgcszValues[i]))
                {
                    fResult = TRUE;
                    *pdwIndex = i;
                    break;
                }
            }
            else
            {
                if (0 == lstrcmpiW(bstrText, rgcszValues[i]))
                {
                    fResult = TRUE;
                    *pdwIndex = i;
                    break;
                }
            }
        }

        SysFreeString(bstrText);
    }
    else
    {
        TraceError("fIsNodeValueInList(): "
                   "Failed to get node text",
                   hr);
    }

    TraceError("fIsNodeValueInList(): "
               "Before returning",
               hr);

    return fResult;
}


LPWSTR
SzAllocateErrorString(
    LPCWSTR cszError,
    LPCWSTR cszOptionalParam)
{
    DWORD  cchError = 0;
    LPWSTR szError = NULL;

    Assert(cszError);

    cchError = lstrlenW(cszError);
    if (cszOptionalParam)
    {
        cchError += lstrlenW(cszOptionalParam);
    }

    szError = new WCHAR[cchError+1];

    if (szError)
    {
        if (cszOptionalParam)
        {
            wsprintf(szError, cszError, cszOptionalParam);
        }
        else
        {
            lstrcpyW(szError, cszError);
        }
    }
    else
    {
        TraceTag(ttidValidate,
                 "SzAllocateErrorString(): "
                 "Failed to allocate memory to duplicate error string %S",
                 cszError);
    }

    return szError;
}

inline
HRESULT
HrAllocErrorStringAndReturnHr(
    HRESULT hrDesired,
    LPCWSTR cszErrorText,
    LPCWSTR cszOptonalParam,
    LPWSTR* pszError)
{
    HRESULT hr = hrDesired;

    Assert(pszError);
    Assert(cszErrorText);

    *pszError = SzAllocateErrorString(cszErrorText, cszOptonalParam);

    if (NULL == *pszError)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
HrValidateName(
    IN  IXMLDOMNode    * pxdnName,
    IN  BOOL             fCheckAUnderscore,
    OUT LPWSTR         * pszError)
{
    HRESULT    hr = S_OK;
    LPWSTR     szError = NULL;
    BSTR       bstrName = NULL;

    Assert(pszError);

    hr = pxdnName->get_text(&bstrName);

    if (SUCCEEDED(hr))
    {
        Assert(bstrName);

        if (0 == lstrcmpW(bstrName, L""))
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                                          L"<name> element was empty",
                                          NULL, &szError);
        }

#if DBG
        if (SUCCEEDED(hr))
        {
            if (lstrlenW(bstrName) >= 32)
            {
                HRESULT hrTemp = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                                                   L"<name> element should be less than 32 characters",
                                                   NULL, &szError);
                if(SUCCEEDED(hrTemp))
                {
                    char * szaError = SzFromWsz(szError);
                    if(szaError)
                    {
                        TraceTag(ttidDefault, szaError);
                        delete [] szaError;
                    }

                    delete [] szError;
                    szError = NULL;
                }
            }
        }
#endif

        if (SUCCEEDED(hr))
        {
            WCHAR * sz = bstrName;
            int i = 0;
            BOOL hasHyphen = FALSE;

            while (sz[i])
            {
                if (sz[i] == L'-')
                {
                    hasHyphen = TRUE;
                    break;
                }
                i++;
            }

            if (hasHyphen)
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                                                   L"<name> element may not contain '-'",
                                                   NULL, &szError);
            }
        }

        SysFreeString(bstrName);
    }
    else
    {
        TraceError("HrValidateName(): "
                   "Failed to get node text",
                   hr);
    }

    if (szError)
    {
        *pszError = szError;
    }


    TraceError("HrValidateName(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrValidateRelatedStateVariable(
    IN  IXMLDOMNode    * pxdnRSV,
    IN  IXMLDOMNode    * pxdnSST,
    OUT LPWSTR         * pszError)
{
    HRESULT    hr = S_OK;
    LPWSTR     szError = NULL;
    BSTR       bstrRSVName = NULL;

    Assert(pszError);

    hr = HrGetTextValueFromElement(pxdnRSV, &bstrRSVName);

    if (SUCCEEDED(hr))
    {
        BSTR       bstrXSLPattern = NULL;

        Assert(bstrRSVName);

        bstrXSLPattern = SysAllocString(L"stateVariable/name");

        if (bstrXSLPattern)
        {
            IXMLDOMNodeList    * pxdnlSVNames = NULL;

            hr = pxdnSST->selectNodes(bstrXSLPattern, &pxdnlSVNames);

            if (SUCCEEDED(hr))
            {
                LONG listLength = 0;

                Assert(pxdnlSVNames);

                hr = pxdnlSVNames->get_length(&listLength);

                if (SUCCEEDED(hr))
                {
                    BOOL fMatch = FALSE;

                    for (LONG i = 0;
                         SUCCEEDED(hr) && (i < listLength) && (FALSE == fMatch);
                         i++)
                    {
                        IXMLDOMNode    * pxdnName = NULL;

                        hr = pxdnlSVNames->get_item(i, &pxdnName);

                        if (SUCCEEDED(hr))
                        {
                            Assert(pxdnName);

                            fMatch = fMatch ||FIsThisTheNodeTextValue(pxdnName,
                                                                   bstrRSVName);

                            pxdnName->Release();
                        }
                        else
                        {
                            TraceError("HrValidateRelatedStateVariable(): "
                                       "Failed to get list item",
                                       hr);
                        }
                    }

                    if (FALSE == fMatch)
                    {
                        hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                            L"<relatedStateVariable> '%s' did not contain the "
                            L"name of a state variable", bstrRSVName, &szError);
                    }
                }
                else
                {
                    TraceError("HrValidateRelatedStateVariable(): "
                               "Failed to get list length",
                               hr);
                }

                pxdnlSVNames->Release();
            }
            else
            {
                TraceError("HrValidateRelatedStateVariable(): "
                           "Failed to select nodes",
                           hr);
            }

            SysFreeString(bstrXSLPattern);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrValidateRelatedStateVariable(): "
                       "Failed to allocate XSL pattern string",
                       hr);
        }

        SysFreeString(bstrRSVName);
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateRelatedStateVariable(): "
               "Exiting(): ",
               hr);
    return hr;
}


HRESULT
HrValidateArg(
    IN  IXMLDOMNode    * pxdnArg,
    IN  IXMLDOMNode    * pxdnSST,
    OUT BOOL           * pbIsInArg,
    OUT BOOL           * pbIsRetval,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    LONG           lFoundName = 0;
    LONG           lFoundDir = 0;
    LONG           lFoundRSV = 0;
    BOOL           bFoundRetval = FALSE;

    Assert(pbIsInArg);
    Assert(pbIsRetval);
    Assert(pszError);

    hr = pxdnArg->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"name",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundName++;
            hr = HrValidateName(pxdnChild, FALSE, &szError);
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"direction",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundDir++;
            if (FIsThisTheNodeTextValue(pxdnChild, L"in"))
            {
                *pbIsInArg = TRUE;
            }
            else if (FIsThisTheNodeTextValue(pxdnChild, L"out"))
            {
                *pbIsInArg = FALSE;
            }
            else
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<direction> contained invalid value."
                    L" Must be \"in\" or \"out\".", NULL, &szError);
            }
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"retval",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            BSTR   bstrText = NULL;

            bFoundRetval = TRUE;
            hr = pxdnChild->get_text(&bstrText);

            if (SUCCEEDED(hr))
            {
                Assert(bstrText);

                if (0 == lstrcmpW(bstrText, L""))
                {
                    *pbIsRetval = TRUE;
                }
                else
                {
                    hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                        L"<retval> contained a text value. Must be empty.",
                        NULL, &szError);
                }
                SysFreeString(bstrText);
            }
            else
            {
                TraceError("HrValidateArg(): "
                           "Failed to get text of <retval> element",
                           hr);
            }
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"relatedStateVariable",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundRSV++;

            hr = HrValidateRelatedStateVariable(pxdnChild, pxdnSST, &szError);
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }

    if (SUCCEEDED(hr))
    {
        if (1 != lFoundName)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<argument> did not contain exactly one <name> element",
                NULL, &szError);
        }
        else if (1 != lFoundDir)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<argument> did not contain exactly one <directio> element",
                NULL, &szError);
        }
        else if (1 != lFoundRSV)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<argument> did not contain exactly one "
                L"<relatedStateVariable> element", NULL, &szError);
        }
        else
        {
            hr = S_OK;
            if (FALSE == bFoundRetval)
            {
                *pbIsRetval = FALSE;
            }
        }
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateArg(): "
               "Exiting",
               hr);
    return hr;
}

HRESULT
HrValidateArgList(
    IN  IXMLDOMNode    * pxdnArgList,
    IN  IXMLDOMNode    * pxdnSST,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    BOOL           bFoundArg = FALSE;
    BOOL           bIsInArg = FALSE;
    BOOL           bIsRetval = FALSE;
    BOOL           bFoundAtLeastOneOutArg = FALSE;

    Assert(pszError);
    hr = pxdnArgList->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"argument",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            bFoundArg = TRUE;

            bIsInArg = FALSE;
            bIsRetval = FALSE;

            hr = HrValidateArg(pxdnChild,
                               pxdnSST,
                               &bIsInArg,
                               &bIsRetval,
                               &szError);

            if (SUCCEEDED(hr))
            {
                if (bIsRetval)
                {
                    // <retval> can only appear in the first "out" argument.

                    if (bIsInArg)
                    {
                        // <retval> appeared in an "in" argument.
                        hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                            L"<retval> element found in \"in\" <argument>",
                            NULL, &szError);
                    }
                    else if (bFoundAtLeastOneOutArg)
                    {
                        // <retval> appeared in an "out" argument that was not
                        // the first one.

                        hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                            L"<retval> element found in \"out\" <argument> "
                            L"that was not the first one", NULL, &szError);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    if (bIsInArg)
                    {
                        if (bFoundAtLeastOneOutArg)
                        {
                            // Found an "in" arg after some "out" args.
                            hr = HrAllocErrorStringAndReturnHr(
                                UPNP_E_INVALID_DOCUMENT,
                                L"\"in\" <argument> found after one or "
                                L"more \"out\" <argument>s", NULL, &szError);
                        }
                    }
                    else
                    {
                        bFoundAtLeastOneOutArg = TRUE;
                    }

                }
            }
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;

    }

    if (SUCCEEDED(hr))
    {
        if (FALSE == bFoundArg)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<argumentList> did not contain any <argument> elements",
                NULL, &szError);
        }
        else
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        BOOL   bDuplicatesExist = FALSE;

        // Check for duplicate names.
        hr = HrAreThereDuplicatesInChildNodeTextValues(pxdnArgList,
                                                       L"argument/name",
                                                       FALSE,
                                                       &bDuplicatesExist);
        if (SUCCEEDED(hr))
        {
            if (bDuplicatesExist)
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<argumentList> contained <argument> elements with "
                    L"duplicate names", NULL, &szError);
            }
        }
        else
        {
            TraceError("HrValidateArgList(): "
                       "Failed to check for duplicate names",
                       hr);
        }
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateArgList(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrValidateAction(
    IN  IXMLDOMNode    * pxdnAction,
    IN  IXMLDOMNode    * pxdnSST,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    LONG           lFoundName = 0;

    Assert(pszError);

    hr = pxdnAction->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"name",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundName++;
            hr = HrValidateName(pxdnChild, TRUE, &szError);
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"argumentList",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            hr = HrValidateArgList(pxdnChild, pxdnSST, &szError);
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }

    if (SUCCEEDED(hr))
    {
        if (1 != lFoundName)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT, L"<action> "
                L"did not contain exactly one <name> element", NULL, &szError);
        }
        else
        {
            hr = S_OK;
        }
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateAction(): "
               "Exiting",
               hr);

    return hr;

}


HRESULT
HrValidateActionList(
    IN  IXMLDOMNode    * pxdnActionList,
    IN  IXMLDOMNode    * pxdnSST,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    BOOL           bFoundAction = FALSE;

    Assert(pszError);

    hr = pxdnActionList->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"action",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {

            bFoundAction = TRUE;

            hr = HrValidateAction(pxdnChild, pxdnSST, &szError);
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;

    }

    if (SUCCEEDED(hr))
    {
        if (FALSE == bFoundAction)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<actionList> did not contain any <action> elements",
                NULL, &szError);
        }
        else
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        BOOL   bDuplicatesExist = FALSE;

        // Check for duplicate names.
        hr = HrAreThereDuplicatesInChildNodeTextValues(pxdnActionList,
                                                       L"action/name",
                                                       FALSE,
                                                       &bDuplicatesExist);
        if (SUCCEEDED(hr))
        {
            if (bDuplicatesExist)
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<actionList> contained <action> elements with duplicate "
                    L"names", NULL, &szError);
            }
        }
        else
        {
            TraceError("HrValidateActionList(): "
                       "Failed to check for duplicate names",
                       hr);
        }
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateActionList(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrValidateAllowedValueRange(
    IN  IXMLDOMNode    * pxdnAllowedValueRange,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    LONG           lFoundMin = 0;
    LONG           lFoundMax = 0;
    LONG           lFoundStep = 0;

    Assert(pszError);

    hr = pxdnAllowedValueRange->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"minimum",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundMin++;
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"maximum",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundMax++;
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"step",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundStep++;
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }

    if (SUCCEEDED(hr))
    {
        if (1 != lFoundMin)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<allowedValueRange> did not contain exactly one <minimum> "
                L"element", NULL, &szError);
        }
        else if (1 != lFoundMax)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<allowedValueRange> did not contain exactly one <maximum> "
                L"element", NULL, &szError);
        }
        else if (1 < lFoundStep)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<allowedValueRange> contained multiple <step> elements",
                NULL, &szError);
        }
        else
        {
            hr = S_OK;
        }
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateAllowedValueRange(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrValidateAllowedValue(
    IN  IXMLDOMNode * pxdnAllowedValue,
    OUT LPWSTR      * pszError)
{
    HRESULT    hr = S_OK;
    LPWSTR     szError = NULL;
    BSTR       bstrName = NULL;

    Assert(pszError);
    Assert(pxdnAllowedValue);

    hr = pxdnAllowedValue->get_text(&bstrName);

    if (SUCCEEDED(hr))
    {
        int len = lstrlenW(bstrName);

        if (len == 0)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                                               L"<allowedValue> element must not be empty",
                                               NULL, &szError);
        }

        if (len >= 32)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                                               L"<allowedValue> element must be less than 32 characters",
                                               NULL, &szError);
        }
        SysFreeString(bstrName);
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateAllowedValue(): Exiting", hr);

    return hr;
}


HRESULT
HrValidateAllowedValueList(
    IN  IXMLDOMNode    * pxdnAllowedValueList,
    OUT LPWSTR         * pszError)
{
    HRESULT            hr = S_OK;
    LPWSTR             szError = NULL;
    IXMLDOMNodeList    * pxdnlChildren = NULL;

    Assert(pszError);

    hr = pxdnAllowedValueList->get_childNodes(&pxdnlChildren);

    if (SUCCEEDED(hr))
    {
        LONG lNumChildren = 0;

        Assert(pxdnlChildren);

        hr = pxdnlChildren->get_length(&lNumChildren);

        if (SUCCEEDED(hr))
        {
            BOOL fMatch = FALSE;

            for (LONG i = 0; SUCCEEDED(hr) && (i < lNumChildren); i++)
            {
                IXMLDOMNode * pxdnChild = NULL;

                hr = pxdnlChildren->get_item(i, &pxdnChild);

                if (SUCCEEDED(hr))
                {
                    Assert(pxdnChild);

                    if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                        L"allowedValue",
                                                        CWSZ_UPNP_SERVICE_NAMESPACE)
                        )
                    {
                        fMatch = TRUE;
                        hr = HrValidateAllowedValue(pxdnChild, &szError);
                    }

                    pxdnChild->Release();
                }
                else
                {
                    TraceError("HrValidateAllowedValueList(): "
                               "Failed to get list item",
                               hr);
                    break;
                }
            }

            if (fMatch == FALSE)
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<allowedValueList> element was empty", NULL, &szError);
            }
        }
        else
        {
            TraceError("HrValidateAllowedValueList(): "
                       "Failed to get list length",
                       hr);
        }

        pxdnlChildren->Release();
    }
    else
    {
        TraceError("HrValidateAllowedValueList(): "
                   "Failed to get node children",
                   hr);
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateAllowedValueList(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrValidateDataType(
    IN  IXMLDOMNode    * pxdnDT,
    OUT BOOL           * pfIsString,
    OUT BOOL           * pfIsNumeric,
    OUT LPWSTR         * pszError)
{
    HRESULT hr = S_OK;
    LPWSTR  szError = NULL;
    DWORD   dwIndex = 0;

    LPCWSTR rgcszTypeStrings[] =
    {
        L"char",    // iFirstString
        L"string",  // iLastString

        L"ui1",     // iFirstNumeric
        L"ui2",
        L"ui4",
        L"i1",
        L"i2",
        L"i4",
        L"int",
        L"number",
        L"r4",
        L"r8",
        L"fixed.14.4",
        L"float",   // iLastNumeric

        L"bin.base64",
        L"bin.hex",
        L"boolean",
        L"date",
        L"dateTime",
        L"dateTime.tz",
        L"time",
        L"time.tz",
        L"uri",
        L"uuid",
    };
    const DWORD ccTypeStrings = celems(rgcszTypeStrings);
    const DWORD iFirstString  = 0;
    const DWORD iLastString   = 1;
    const DWORD iFirstNumeric = 2;
    const DWORD iLastNumeric  = 13;

    if (FALSE == fIsNodeValueInList(pxdnDT,
                                    FALSE,
                                    ccTypeStrings,
                                    rgcszTypeStrings,
                                    &dwIndex))
    {
        hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT, L"<dataType> "
            L"element contained invalid value", NULL, &szError);
    }

    // Don't need to compare iFirstString <= dwIndex because this is always
    // true.
    *pfIsString  = dwIndex <= iLastString;

    *pfIsNumeric = (iFirstNumeric <= dwIndex && dwIndex <= iLastNumeric);

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateDataType(): "
               "Exiting",
               hr);
    return hr;
}



HRESULT
HrValidateStateVariable(
    IN  IXMLDOMNode    * pxdnSV,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    LONG           lFoundName = 0;
    LONG           lFoundDataType = 0;
    LONG           lFoundAllowedValueList = 0;
    LONG           lFoundAllowedValueRange = 0;
    BOOL           fIsString = FALSE;
    BOOL           fIsNumeric = FALSE;
    BSTR           bstrSendEvents = NULL;

    Assert(pszError);
    Assert(pxdnSV);

    hr = HrGetTextValueFromAttribute(pxdnSV, L"sendEvents", &bstrSendEvents);
    if (SUCCEEDED(hr))
    {
        if (hr == S_OK)
        {
            if (!(0 == lstrcmpiW(bstrSendEvents, L"yes") || 0 == lstrcmpiW(bstrSendEvents, L"no")))
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<stateVariable> optional attribute \"sendEvents\" must be "
                    L" \"yes\" or \"no\"", NULL, &szError);
            }
            SysFreeString(bstrSendEvents);
        }
        else
        {
            hr = S_OK; // we don't want to pass on the S_FALSE
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pxdnSV->get_firstChild(&pxdnChild);
    }

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"name",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundName++;
            hr = HrValidateName(pxdnChild, TRUE, &szError);
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"dataType",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            lFoundDataType++;
            hr = HrValidateDataType(pxdnChild, &fIsString, &fIsNumeric, &szError);
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"allowedValueList",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            if (lFoundAllowedValueRange)
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<stateVariable> contains both <allowedValueRange>"
                    L" and <allowedValueList>", NULL, &szError);
            }
            else
            {
                lFoundAllowedValueList++;
                hr = HrValidateAllowedValueList(pxdnChild, &szError);
            }
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"allowedValueRange",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            if (lFoundAllowedValueList)
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<stateVariable> contains both <allowedValueRange>"
                    L" and <allowedValueList>", NULL, &szError);
            }
            else
            {
                lFoundAllowedValueRange++;
                hr = HrValidateAllowedValueRange(pxdnChild, &szError);
            }
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"defaultValue",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            // ISSUE-2000/11/6-spather: Need to validate defaultValue somehow.

        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }

    if (SUCCEEDED(hr))
    {
        if (1 != lFoundName)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<stateVariable> did not contain exactly one <name> element",
                NULL, &szError);
        }
        else if (1 != lFoundDataType)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<stateVariable> did not contain exactly one <dataType> "
                L"element", NULL, &szError);
        }
        else if (1 < lFoundAllowedValueList)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<stateVariable> contains multiple <allowedValueList> "
                L"elements", NULL, &szError);
        }
        else if (1 < lFoundAllowedValueRange)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<stateVariable> contains multiple <allowedValueRange> "
                L"elements", NULL, &szError);
        }
        else if (lFoundAllowedValueList && FALSE == fIsString)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<allowedValueList> may only modify a string variable",
                NULL, &szError);
        }
        else if (lFoundAllowedValueRange && FALSE == fIsNumeric)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<allowedValueRange> may only modify a numeric variable",
                NULL, &szError);
        }
        else
        {
            hr = S_OK;
        }
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateStateVariable(): "
               "Exiting",
               hr);
    return hr;
}

HRESULT
HrValidateSST(
    IN  IXMLDOMNode    * pxdnSST,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    BOOL           bFoundStateVariable = FALSE;

    Assert(pszError);

    hr = pxdnSST->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"stateVariable",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {

            bFoundStateVariable = TRUE;

            hr = HrValidateStateVariable(pxdnChild, &szError);
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;

    }

    if (SUCCEEDED(hr))
    {
        if (FALSE == bFoundStateVariable)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                L"<serviceStateTable> did not contain any <stateVariable> "
                L"elements", NULL, &szError);
        }
        else
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        BOOL   bDuplicatesExist = FALSE;

        // Check for duplicate names.
        hr = HrAreThereDuplicatesInChildNodeTextValues(pxdnSST,
                                                       L"stateVariable/name",
                                                       FALSE,
                                                       &bDuplicatesExist);
        if (SUCCEEDED(hr))
        {
            if (bDuplicatesExist)
            {
                hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                    L"<serviceStateTable> contained <stateVariable> elements "
                    L"with duplicate names", NULL, &szError);
            }
        }
        else
        {
            TraceError("HrValidateSST(): "
                       "Failed to check for duplicate names",
                       hr);
        }
    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateSST(): "
               "Exiting",
               hr);
    return hr;
}



HRESULT
HrValidateSpecVersion(
    IN  IXMLDOMNode    * pxdnSpecVersion,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    LPWSTR         szError = NULL;
    IXMLDOMNode    * pxdnChild = NULL;
    LONG           lFoundMajor = 0;
    LONG           lFoundMinor = 0;

    Assert(pszError);

    hr = pxdnSpecVersion->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode * pxdnNextSibling = NULL;

        if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                            L"major",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            BSTR   bstrText = NULL;

            lFoundMajor++;

            hr = pxdnChild->get_text(&bstrText);

            if (SUCCEEDED(hr))
            {
                Assert(bstrText);

                if (0 != lstrcmpW(bstrText, L"1"))
                {
                    hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                        L"<major> version number is incorrect - "
                        L"should be \"1\"", NULL, &szError);
                }

                SysFreeString(bstrText);
            }
        }
        else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                 L"minor",
                                                 CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            BSTR   bstrText = NULL;

            lFoundMinor++;

            hr = pxdnChild->get_text(&bstrText);

            if (SUCCEEDED(hr))
            {
                Assert(bstrText);

                if (0 != lstrcmpW(bstrText, L"0"))
                {
                    hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                        L"<minor> version number is incorrect - "
                        L"should be \"0\"", NULL, &szError);
                }

                SysFreeString(bstrText);
            }
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }

    if (SUCCEEDED(hr))
    {
        if (1 != lFoundMajor)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT, L"<major> "
                L"specVersion element must appear exactly once", NULL, &szError);
        }
        else if (1 != lFoundMinor)
        {
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT, L"<minor> "
                L"specVersion element must appear exactly once", NULL, &szError);
        }
        else
        {
            hr = S_OK;
        }

    }

    if (szError)
    {
        *pszError = szError;
    }

    TraceError("HrValidateSpecVersion(): "
               "Exiting",
               hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrValidateServiceDescription
//
//  Purpose:    Validates a service description document.
//
//  Arguments:
//      pxdeRoot [in]  The DOM element representing the root of the document.
//      pszError [out] Receives a pointer to an error description string.
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/10/19
//
//  Notes:
//      The string returned at pszError must be freed by the caller using the
//      "delete" operator.
//
HRESULT
HrValidateServiceDescription(
    IN  IXMLDOMElement * pxdeRoot,
    OUT LPWSTR         * pszError)
{
    HRESULT        hr = S_OK;
    IXMLDOMNode    * pxdnSCPD = NULL;
    IXMLDOMNode    * pxdnSpecVersion = NULL;
    IXMLDOMNode    * pxdnActionList = NULL;
    IXMLDOMNode    * pxdnSST = NULL;
    LPWSTR         szError = NULL;

    // Check the overall structure to make sure the required root and top-level
    // elements are there.

    hr = pxdeRoot->QueryInterface(IID_IXMLDOMNode, (void **) &pxdnSCPD);

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode * pxdnChild = NULL;

        Assert(pxdnSCPD);

        if (FIsThisTheNodeNameWithNamespace(pxdnSCPD,
                                            L"scpd",
                                            CWSZ_UPNP_SERVICE_NAMESPACE))
        {
            LONG lFoundSpecVersion = 0;
            LONG lFoundActionList = 0;
            LONG lFoundSST = 0;

            hr = pxdnSCPD->get_firstChild(&pxdnChild);

            while (SUCCEEDED(hr) && pxdnChild)
            {
                IXMLDOMNode * pxdnNextSibling = NULL;

                if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                    L"specVersion",
                                                    CWSZ_UPNP_SERVICE_NAMESPACE))
                {
                    pxdnChild->AddRef();
                    pxdnSpecVersion = pxdnChild;
                    lFoundSpecVersion++;
                }
                else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                         L"actionList",
                                                         CWSZ_UPNP_SERVICE_NAMESPACE))
                {
                    pxdnChild->AddRef();
                    pxdnActionList = pxdnChild;
                    lFoundActionList++;
                }
                else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                         L"serviceStateTable",
                                                         CWSZ_UPNP_SERVICE_NAMESPACE))
                {
                    pxdnChild->AddRef();
                    pxdnSST = pxdnChild;
                    lFoundSST++;
                }

                if (FAILED(hr))
                {
                    pxdnChild->Release();
                    break;
                }

                hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
                pxdnChild->Release();
                pxdnChild = pxdnNextSibling;
            }

            // If we didn't find an unknown node and there was no other
            // error, hr will be S_FALSE now. But there may have been some
            // required nodes missing, so we'll check. If everything was
            // there, change hr to S_OK.

            if (SUCCEEDED(hr))
            {
                if (1 != lFoundSpecVersion)
                {
                    hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                        L"<specVersion> element must appear exactly once",
                        NULL, &szError);
                }
                else if (1 != lFoundSST)
                {
                    hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                        L"<serviceStateTable> element must appear exactly once",
                        NULL, &szError);
                }
                else if (1 < lFoundActionList)
                {
                    hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT,
                        L"<actionList> element must appear no more than once",
                        NULL, &szError);
                }
                else
                {
                    hr = S_OK;
                }
            }
        }
        else
        {
            // Wrong root node name.
            hr = HrAllocErrorStringAndReturnHr(UPNP_E_INVALID_DOCUMENT, L"Root node "
                L"invalid - should be <scpd "
                L"xmlns=\"urn:schemas-upnp-org:service-1-0\">", NULL, &szError);
        }
    }
    else
    {
        TraceError("HrValidateServiceDescription(): "
                   "Failed to get SCPD node",
                   hr);
    }


    // Next, validate each top-level node and its children.

    if (SUCCEEDED(hr))
    {
        hr = HrValidateSpecVersion(pxdnSpecVersion, &szError);

        if (SUCCEEDED(hr))
        {
            hr = HrValidateSST(pxdnSST, &szError);

            if (SUCCEEDED(hr) && NULL != pxdnActionList)
            {
                hr = HrValidateActionList(pxdnActionList, pxdnSST, &szError);
            }
        }

    }

    // Cleanup.
    if (pxdnSCPD)
    {
        pxdnSCPD->Release();
        pxdnSCPD = NULL;
    }

    if (pxdnSpecVersion)
    {
        pxdnSpecVersion->Release();
        pxdnSpecVersion = NULL;
    }

    if (pxdnActionList)
    {
        pxdnActionList->Release();
        pxdnActionList = NULL;
    }

    if (pxdnSST)
    {
        pxdnSST->Release();
        pxdnSST = NULL;
    }

    // Copy the error string to the output if necessary.

    if (szError)
    {
        if (pszError)
        {
            *pszError = szError;
        }
        else
        {
            delete [] szError;
            szError = NULL;
        }
    }

    TraceError("HrValidateServiceDescription(): "
               "Exiting",
               hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upcom\ustring2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U S T R I N G 2 . C P P
//
//  Contents:   Simple string class
//
//  Notes:
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "UString.h"
#include "ComUtility.h"

HRESULT CUString::HrGetBSTR(BSTR * pbstr) const
{
    CHECK_POINTER(pbstr);
    HRESULT hr = S_OK;
    *pbstr = SysAllocString(m_sz ? m_sz : L"");
    if(!*pbstr)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "CUString::GetBSTR");
    return hr;
}

HRESULT CUString::HrGetCOM(wchar_t ** psz) const
{
    CHECK_POINTER(psz);
    HRESULT hr = S_OK;
    *psz = reinterpret_cast<wchar_t*>(CoTaskMemAlloc((GetLength() + 1) * sizeof(wchar_t)));
    if(*psz)
    {
        lstrcpy(*psz, m_sz ? m_sz: L"\0");
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "CUString::GetCOM");
    return hr;
}

HRESULT CUString::HrInitFromGUID(const GUID & guid)
{
    HRESULT hr = S_OK;

    Clear();
    const int c_cchGuidWithTerm = 39; // includes terminating null

    wchar_t szGUID[c_cchGuidWithTerm];
    StringFromGUID2(guid, szGUID, c_cchGuidWithTerm);
    hr = HrAssign(szGUID);

    TraceHr(ttidError, FAL, hr, FALSE, "CUString::HrInitFromGUID");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upbase\ustring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U S T R I N G . C P P
//
//  Contents:   Simple string class
//
//  Notes:
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "UString.h"
#include "ComUtility.h"

HRESULT CUString::HrAssign(const wchar_t * sz)
{
    if(!sz)
    {
        Clear();
        return S_OK;
    }
    HRESULT hr = S_OK;
    wchar_t * szTemp = new wchar_t[lstrlen(sz) + 1];
    if(!szTemp)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        lstrcpy(szTemp, sz);
        delete [] m_sz;
        m_sz = szTemp;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "CUString::HrAssign");
    return hr;
}

HRESULT CUString::HrAssign(const char * sz)
{
    if(!sz)
    {
        Clear();
        return S_OK;
    }
    HRESULT hr = S_OK;

    long nLength = MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0);

    wchar_t * szTemp = new wchar_t[nLength];
    if(!szTemp)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        MultiByteToWideChar(CP_ACP, 0, sz, -1, szTemp, nLength);
        delete [] m_sz;
        m_sz = szTemp;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "CUString::HrAssign");
    return hr;
}

HRESULT CUString::HrAppend(const wchar_t * sz)
{
    // Ignore appending a blank/null string
    if(!sz)
    {
        return S_OK;
    }
    HRESULT hr = S_OK;
    long nLength = GetLength() + (sz?lstrlen(sz):0) + 1;
    wchar_t * szTemp = new wchar_t[nLength];
    if(!szTemp)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        *szTemp = 0;
        if(m_sz)
        {
            lstrcpy(szTemp, m_sz);
        }
        if(sz)
        {
            lstrcat(szTemp, sz);
        }
        delete [] m_sz;
        m_sz = szTemp;
    }
    TraceHr(ttidError, FAL, hr, FALSE, "CUString::HrAppend");
    return hr;
}

HRESULT CUString::HrPrintf(const wchar_t * szFormat, ...)
{
    va_list val;
    va_start(val, szFormat);
    wchar_t buf[1024];
    wvsprintf(buf, szFormat, val);
    va_end(val);
    HRESULT hr = HrAssign(buf);
    TraceHr(ttidError, FAL, hr, FALSE, "CUString::HrPrintf");
    return hr;
}

long CUString::CcbGetMultiByteLength() const
{
    if(!GetLength())
    {
        return 1;
    }
    return WideCharToMultiByte(CP_ACP, 0, m_sz, -1, NULL, 0, NULL, NULL);
}

HRESULT CUString::HrGetMultiByte(char * szBuf, long ccbLength) const
{
    HRESULT hr = S_OK;

    if(!GetLength())
    {
        *szBuf = '\0';
    }
    else
    {
        if(!WideCharToMultiByte(CP_ACP, 0, m_sz, -1, szBuf, ccbLength, NULL, NULL))
        {
            hr = HrFromLastWin32Error();
        }
    }
    TraceHr(ttidError, FAL, hr, FALSE, "CUString::HrGetMultiByte");
    return hr;
}

HRESULT CUString::HrGetMultiByteWithAlloc(char ** pszBuf) const
{
    HRESULT hr = S_OK;

    long ccbLength = CcbGetMultiByteLength();
    char * szBuf = new char[ccbLength];
    if(!szBuf)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = HrGetMultiByte(szBuf, ccbLength);
        if(FAILED(hr))
        {
            delete [] szBuf;
        }
        if(SUCCEEDED(hr))
        {
            *pszBuf = szBuf;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUString::HrGetMultiByteWithAlloc");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\updebug\dbgflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D B G F L A G S . C P P
//
//  Contents:   DebugFlag list for the NetCfg Project
//
//  Notes:
//
//  Author:     jeffspr   27 May 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// None of this should get compiled in unless we're in the debug version
// or we need to enable tracing code.
//
#if defined(DBG) || defined(ENABLETRACE)

#include "ncdebug.h"
//#include "ncbase.h"

// This is the DebugFlag list that everyone should be modifying.
//
DEBUGFLAGELEMENT g_DebugFlags[] =
{
//      :-----------    DebugFlagId dfid
//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           DWORD       dwValue ------------------------------------------------------------:
//      | | |                                                                                           |
//      | | |                                                                                           |
//      | | :-------------------------------------------:                                               |
//      | :----------------------:                      |                                               |
//      |                        |                      |                                               |
//      v                        v                      v                                               v
//
    { dfidBreakOnAddLegacy,         "BreakOnAddLegacy",         "Break during HrAddLegacyAdapters",     0 },
    { dfidBreakOnAlloc,             "BreakOnAlloc",             "Break on Specified Alloc",             0 },
    { dfidBreakOnDoUnattend,        "BreakOnDoUnattend",        "Break during HrDoUnattend",            0 },
    { dfidBreakOnError,             "BreakOnError",             "Break on TraceError",                  0 },
    { dfidBreakOnHr,                "BreakOnHr",                "Break when hr is specific value",      0 },
    { dfidBreakOnHrIteration,       "BreakOnHrInteration",      "Break when hr is hit N times",         0 },
    { dfidBreakOnIteration,         "BreakOnIteration",         "Break on Nth call to TraceError",      0 },
    { dfidBreakOnNetInstall,        "BreakOnNetInstall",        "Break during HrNetClassInstaller",     0 },
    { dfidBreakOnPrematureDllUnload,"BreakOnPrematureDllUnload","Break when DLL unloaded with open references",     0 },
    { dfidBreakOnWizard,            "BreakOnWizard",            "Break on Wizard",                      0 },
    { dfidBreakOnStartOfUpgrade,    "BreakOnStartOfUpgrade",    "Break at the beginning of InstallUpgradeWorkThread", 0 },
    { dfidBreakOnEndOfUpgrade,      "BreakOnEndOfUpgrade",      "Break after all calls to HrDoUnattend have been completed", 0 },
    { dfidDisableShellThreading,    "DisableShellThreading",    "Disable shell thread pool usage",      0 },
    { dfidDisableTray,              "DisableTray",              "Disable Tray",                         0 },
    { dfidExtremeTracing,           "Extreme Tracing",          "Output all traces, even on success",   0 },
    { dfidNetShellBreakOnInit,      "NetShellBreakOnInit",      "Break on Initialization of NetShell",  0 },
    { dfidNoErrorText,              "NoErrorText",              "Don't show wimpy error strings.",      0 },
    { dfidShowIgnoredErrors,        "ShowIgnoredErrors",        "Displays errors that would otherwise be ignored", 0 },
    { dfidShowProcessAndThreadIds,  "ShowProcessAndThreadIds",  "Displays process and thread id",       0 },
    { dfidSkipLanEnum,              "SkipLanEnum",              "Skip LAN Enumeration",                 0 },
    { dfidTracingTimeStamps,        "TracingTimeStamps",        "Add time stamps to tracing output",    0 },
    { dfidShowIdsInHex,             "ShowIdsInHex",             "Displays process and therad ids in hex, not decimal", 0 },
};

const INT g_nDebugFlagCount = celems(g_DebugFlags);


//+---------------------------------------------------------------------------
//
//  Function:   FIsDebugFlagSet
//
//  Purpose:    Return the state of a debug flag to the caller.
//
//  Arguments:
//      dfid [] Debug Flag ID
//
//  Returns:    TRUE if set, FALSE otherwise.
//
//  Author:     jeffspr   28 May 1997
//
//  Notes:
//
BOOL FIsDebugFlagSet( DEBUGFLAGID   dfid )
{
    return (g_DebugFlags[dfid].dwValue > 0);
}

DWORD   DwReturnDebugFlagValue( DEBUGFLAGID dfid )
{
    return (g_DebugFlags[dfid].dwValue);
}


#endif //! DBG || ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\updebug\ncdebug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D E B U G X . C P P
//
//  Contents:   Implementation of debug support routines.
//
//  Notes:
//
//  Author:     danielwe   16 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef DBG

#include "ncdebug.h"
#include "ncdefine.h"

static int  nAssertLevel = 0;
static PFNASSERTHOOK pfnAssertHook = DefAssertSzFn;

//
// We can only do memory tracking if we've included crtdbg.h and
// _DEBUG is defined.
//
#if defined(_INC_CRTDBG) && defined(_DEBUG)
struct DBG_SHARED_MEM
{
    _CrtMemState    crtState;
    DWORD           cRef;
};

DBG_SHARED_MEM *    g_pMem = NULL;
HANDLE              g_hMap = NULL;

static const WCHAR  c_szSharedMem[] = L"DBG_NetCfgSharedMemory";

//+---------------------------------------------------------------------------
//
//  Function:   InitDbgState
//
//  Purpose:    Initializes the memory leak detection code.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   13 May 1997
//
//  Notes:
//
VOID InitDbgState()
{
    g_hMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                             0, sizeof(DBG_SHARED_MEM), c_szSharedMem);
    if (g_hMap)
    {
        LPVOID  pvMem;
        BOOL    fExisted = (GetLastError() == ERROR_ALREADY_EXISTS);

        pvMem = MapViewOfFile(g_hMap, FILE_MAP_WRITE, 0, 0, 0);
        g_pMem = reinterpret_cast<DBG_SHARED_MEM *>(pvMem);

        if (!fExisted)
        {
            // First time creating the file mapping. Initialize things.

            g_pMem->cRef = 0;

            // start looking for leaks now
            _CrtMemCheckpoint(&g_pMem->crtState);
        }

        g_pMem->cRef++;
        TraceTag(ttidDefault, "DBGMEM: Init Refcount on shared mem is now %d",
                 g_pMem->cRef);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UnInitDbgState
//
//  Purpose:    Uninitializes the memory leak detection code.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   13 May 1997
//
//  Notes:
//
VOID UnInitDbgState()
{
    if (g_pMem)
    {
        g_pMem->cRef--;
        TraceTag(ttidDefault, "DBGMEM: Uninit Refcount on shared mem is now %d",
                 g_pMem->cRef);

        if (!g_pMem->cRef)
        {
            // manually force dump of leaks when refcount goes to 0
            _CrtMemDumpAllObjectsSince(&g_pMem->crtState);
        }

        UnmapViewOfFile(reinterpret_cast<LPVOID>(g_pMem));
        CloseHandle(g_hMap);
    }
}
#endif


BOOL WINAPI FInAssert(VOID)
{
    return nAssertLevel > 0;
}

VOID WINAPIV AssertFmt(BOOL fExp, PCSTR pszaFile, int nLine, PCSTR pszaFmt, ...)
{
    CHAR rgch[1024];

    if (!fExp)
    {
        va_list     valMarker;

        va_start(valMarker, pszaFmt);
        wvsprintfA(rgch, pszaFmt, valMarker);
        va_end(valMarker);

        AssertSzFn(rgch, pszaFile, nLine);
    }
}

VOID WINAPI AssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine)
{
    CHAR rgch[1024];

    ++nAssertLevel;

    if (pszaFile)
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "UPnP Assert Failure:\r\n  File %s, line %d:\r\n %s\r\n",
                      pszaFile, nLine, pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "UPnP Assert Failure:\r\n  File %s, line %d.\r\n",
                      pszaFile, nLine);
        }
    }
    else
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "UPnP Assert Failure:\r\n:\r\n %s\r\n",
                      pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "UPnP Assert Failure\r\n");
        }
    }

    OutputDebugStringA(rgch);

    if (pfnAssertHook)
    {
        (*pfnAssertHook)(pszaMsg, pszaFile, nLine);
    }

    --nAssertLevel;
}


VOID CALLBACK DefAssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine)
{
    CHAR    rgch[2048];
    INT     nID;
    int     cch;
    PSTR    pch;
    BOOL    fNYIWarning = FALSE;
    CHAR    szaNYI[]     = "NYI:";

    if (pszaFile)
    {
        wsprintfA(rgch, "File %s, line %d\r\n\r\n", pszaFile, nLine);
    }
    else
    {
        rgch[0] = 0;
    }

    if (pszaMsg)
    {
        // Check to see if this is an NYI alert. If so, then we'll want
        // to use a different MessageBox title
        if (strncmp(pszaMsg, szaNYI, lstrlenA(szaNYI)) == 0)
        {
            fNYIWarning = TRUE;
        }

        lstrcatA(rgch, pszaMsg);
    }


    cch = lstrlenA(rgch);
    pch = &rgch[cch];

    if (cch < celems(rgch))
    {
        lstrcpynA(pch, "\n\nPress Abort to crash, Retry to debug, or Ignore to ignore."
                       "\nHold down Shift to copy the assert text to the "
                       "clipboard before the action is taken.", celems(rgch) - cch - 1);
    }

    MessageBeep(MB_ICONHAND);

    nID = MessageBoxA(NULL, rgch,
            fNYIWarning ? "UPnP -- Not Yet Implemented" : "UPnP Assert Failure",
            MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 | MB_ICONHAND |
            MB_SETFOREGROUND | MB_TASKMODAL | MB_SERVICE_NOTIFICATION);

    if (nID == IDRETRY)
    {
        DebugBreak();
    }

    // if cancelling, force a hard exit w/ a GP-fault so that Dr. Watson
    // generates a nice stack trace log.
    if (nID == IDABORT)
    {
        *(BYTE *) 0 = 1;    // write to address 0 causes GP-fault
    }
}

VOID WINAPI SetAssertFn(PFNASSERTHOOK pfn)
{
    pfnAssertHook = pfn;
}

//+---------------------------------------------------------------------------
// To be called during DLL_PROCESS_DETACH for a DLL which implements COM
// objects or hands out references to objects which can be tracked.
// Call this function with the name of the DLL (so that it can be traced
// to the debugger) and the lock count of the DLL.  If the lock count is
// non-zero, it means the DLL is being unloaded prematurley.  When this
// condition is detected, a message is printed to the debugger and a
// DebugBreak will be invoked if the debug flag dfidBreakOnPrematureDllUnload
// is set.
//
// Assumptions:
//  Trace and debugging features have not been uninitialized.
//
//
VOID
DbgCheckPrematureDllUnload (
    PCSTR pszaDllName,
    UINT ModuleLockCount)
{
    if (0 != ModuleLockCount)
    {
        TraceTag(ttidUPnPBase, "ModuleLockCount == %d.  "
            "%s is being unloaded with clients still holding references!",
            ModuleLockCount,
            pszaDllName);

        if (FIsDebugFlagSet(dfidBreakOnPrematureDllUnload))
        {
            DebugBreak ();
        }
    }
}

#endif //! DBG

//+---------------------------------------------------------------------------
//
//  Function:   InitializeDebugging
//
//  Purpose:    Called by every DLL or EXE to initialize the debugging
//              objects (Trace and DebugFlag tables)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
NOTHROW void InitializeDebugging()
{
    // For debug builds or if we have retail tracing enabled we need to
    // include the tracing code.
    // Ignore the error return, since we don't return it here anyway.
    //
#ifdef ENABLETRACE
    (void) HrInitTracing();
#endif

#if defined(DBG) && defined(_INC_CRTDBG) && defined(_DEBUG)
    if (FIsDebugFlagSet (dfidDumpLeaks))
    {
        InitDbgState();
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   UnInitializeDebugging
//
//  Purpose:    Uninitialize the debugging objects (Tracing and DbgFlags)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
NOTHROW void UnInitializeDebugging()
{
    // For debug builds or if we have retail tracing enabled we will have
    // included the tracing code.  We now need to uninitialize it.
    // Ignore the error return, since we don't return it here anyway.
    //
#ifdef ENABLETRACE

    (void) HrUnInitTracing();

#endif

#if defined(DBG) && defined(_INC_CRTDBG) && defined(_DEBUG)
    if (FIsDebugFlagSet (dfidDumpLeaks))
    {
        UnInitDbgState();
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\updebug\trace.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E . C P P
//
//  Contents:   The actual tracing code (loading from ini, calling the
//              trace routines, etc.
//
//  Notes:
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include <stdio.h>
#include "ncdebug.h"
#include "ncbase.h"

#define DBG_BUFFER_SIZE_SMALL     (256)
#define DBG_BUFFER_SIZE_LARGE     (1024)

//---[ CTracing class ]-------------------------------------------------------
//
// Don't give this class a constructor or destructor.  We declare a global
// (static to this module) instance of this class and, by definition, static
// variables are automatically initialized to zero.
//
class CTracing
{
public:
    CTracing();
    // Initialize/Deinitialize this class
    //
    HRESULT HrInit();
    HRESULT HrUnInit();

    VOID Trace( TraceTagId    ttid,
                PCSTR         pszaTrace );

private:
    BOOL    m_fInitialized;                 // Has the object been initialized
    BOOL    m_fAttemptedLogFileOpen;        // Already attempted to open log
    BOOL    m_fDisableLogFile;              // Disable use of file logging?
    HANDLE  m_hLogFile;                     // Handle for debug output file
    HANDLE  m_hMutex;
    CHAR    m_szLogFilePath[MAX_PATH+1];    // File for debug output
    BOOL    m_fDebugFlagsLoaded;            // Have these been loaded yet.

    VOID    CorruptionCheck();              // Validate the tracetag structure

    HRESULT HrLoadOptionsFromIniFile();
    HRESULT HrLoadSectionsFromIniFile();
    HRESULT HrLoadDebugFlagsFromIniFile();
    HRESULT HrWriteDebugFlagsToIniFile();
    HRESULT HrOpenLogFile();

    HRESULT HrProcessTagSection(TraceTagElement *   ptte);
    HRESULT HrGetPrivateProfileString(  PCSTR   lpAppName,
                                        PCSTR   lpKeyName,
                                        PCSTR   lpDefault,
                                        PSTR    lpReturnedString,
                                        DWORD   nSize,
                                        PCSTR   lpFileName,
                                        DWORD * pcchReturn );
    BOOL    FIniFileExists();
};


//---[ Static Variables ]-----------------------------------------------------

static CTracing g_Tracing;                      // Our global tracing object

//---[ Constants ]------------------------------------------------------------

static const CHAR   c_szaDebugIniFileName[] = "upnpdbg.ini";       // .INI file
static const CHAR   c_szaTraceLogFileName[] = "nctrace.log";      // .LOG file

// constants for the INI file labels
static const CHAR   c_szaOptions[]          = "Options";
static const CHAR   c_szaLogFilePath[]      = "LogFilePath";
static const CHAR   c_szaDisableLogFile[]   = "DisableLogFile";
static const CHAR   c_szaLogFileMutex[]     = "UPNP_LOG_FILE_MUTEX";

const INT   c_iDefaultDisableLogFile    = 0;

//+---------------------------------------------------------------------------
//
//  Function:   HrInitTracing
//
//  Purpose:    Initialize the Tracing object and other random data.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   9 Apr 1997
//
//  Notes:
//
HRESULT HrInitTracing()
{
    HRESULT hr = g_Tracing.HrInit();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrUnInitTracing
//
//  Purpose:    Uninitialize the tracing object.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or a valid Win32 HRESULT
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
HRESULT HrUnInitTracing()
{
    HRESULT hr = g_Tracing.HrUnInit();
    return hr;
}

const DWORD TI_HRESULT      = 0x00000001;
const DWORD TI_WIN32        = 0x00000002;
const DWORD TI_IGNORABLE    = 0x00000004;

//+---------------------------------------------------------------------------
//
//  Function:   TraceInternal
//
//  Purpose:    The one and only place that a string to be traced is formed
//              and traced.
//
//  Arguments:
//
//  Returns:    nothing.
//
//  Author:     shaunco   13 Mar 1998
//
//  Notes:      Restructured from lots of other code that was added to this
//              module over the past year.
//
VOID
TraceInternal (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    DWORD       dwFlags,
    PCSTR       pszaCallerText,
    DWORD       dwErrorCode)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    BOOL fError     = dwFlags & (TI_HRESULT | TI_WIN32);
    BOOL fIgnorable = dwFlags & TI_IGNORABLE;

    HRESULT hr           = (dwFlags & TI_HRESULT) ? dwErrorCode : S_OK;
    DWORD   dwWin32Error = (dwFlags & TI_WIN32)   ? dwErrorCode : ERROR_SUCCESS;

    // Ignore if told and we're not set to trace ignored errors or warnings.
    //
    if (fError && fIgnorable &&
        !FIsDebugFlagSet (dfidShowIgnoredErrors) &&
        !FIsDebugFlagSet (dfidExtremeTracing))
    {
        return;
    }

    // Don't do anything if we're tracing for an error and we don't have one,
    // unless the "Extreme Tracing" flag is on, in which case we trace
    // everything in the world (for debugger use only, really)
    // This is the path taken by TraceError ("...", S_OK) or
    // TraceLastWin32Error when there is no last Win32 error.
    //
    if (fError && !dwErrorCode && !FIsDebugFlagSet(dfidExtremeTracing))
    {
        return;
    }

    CHAR szaBuf [DBG_BUFFER_SIZE_LARGE];
    PSTR pcha = szaBuf;

    // Form the prefix, process id and thread id.
    //
    static const CHAR c_szaFmtPrefix [] = "UPNPDBG";
    lstrcpyA (pcha, c_szaFmtPrefix);
    pcha += lstrlenA (c_szaFmtPrefix);

    // Add process and thread ids if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidShowProcessAndThreadIds))
    {
        static const CHAR c_szaFmtPidAndTidDecimal [] = " %03d.%03d";
        static const CHAR c_szaFmtPidAndTidHex [] = " 0x%04x.0x%04x";

        LPCSTR pszaFmtPidAndTid = NULL;

        if (FIsDebugFlagSet (dfidShowIdsInHex))
        {
            pszaFmtPidAndTid = c_szaFmtPidAndTidHex;
        }
        else
        {
            pszaFmtPidAndTid = c_szaFmtPidAndTidDecimal;
        }

        pcha += wsprintfA (pcha, pszaFmtPidAndTid,
                    GetCurrentProcessId (),
                    GetCurrentThreadId ());
    }

    // Add a time stamp if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidTracingTimeStamps))
    {
        static const CHAR c_szaFmtTime [] = " [%02d:%02d:%02d.%03d]";

        SYSTEMTIME stLocal;
        GetLocalTime (&stLocal);
        pcha += wsprintfA (pcha, c_szaFmtTime,
                    stLocal.wHour,
                    stLocal.wMinute,
                    stLocal.wSecond,
                    stLocal.wMilliseconds);
    }

    // Add a severity indicator if this trace is for an error or warning.
    //
    if (fError || (ttidError == ttid))
    {
        static const CHAR c_szaSevIgnored [] = " Ignored:";
        static const CHAR c_szaSevError   [] = " *ERROR*:";
        static const CHAR c_szaSevWarning [] = " Warning:";

        PCSTR pszaSev = NULL;

        if (fError && SUCCEEDED(hr) && !dwWin32Error && !fIgnorable)
        {
            pszaSev = c_szaSevWarning;
        }
        else
        {
            if (fIgnorable && FIsDebugFlagSet (dfidShowIgnoredErrors))
            {
                pszaSev = c_szaSevIgnored;
            }
            else
            {
                pszaSev = c_szaSevError;
            }
        }
        Assert (pszaSev);

        lstrcatA (pcha, pszaSev);
        pcha += lstrlenA (pszaSev);
    }

    // Add the tracetag short name.  Don't do this for ttidError if
    // we already have the severity indicator from above.
    //
    if (ttid && (ttid < g_nTraceTagCount) && (ttid != ttidError))
    {
        static const CHAR c_szaFmtTraceTag [] = " (%s)";

        pcha += wsprintfA (pcha, c_szaFmtTraceTag,
                    g_TraceTags[ttid].szShortName);
    }

    int nBytesCopied;
    int nBytesRemaining;

    // monitor bytes remaining from here on out...
    nBytesRemaining = sizeof(szaBuf) - (pcha - szaBuf);

    // Add the caller's text.
    //
    if (pszaCallerText)
    {
        static const CHAR c_szaFmtCallerText [] = " %s";

    // copy as many bytes as possible
    nBytesCopied = _snprintf (pcha,
                nBytesRemaining,
                c_szaFmtCallerText,
                pszaCallerText);

    // check for overflow
    if (nBytesCopied >= 0)
    {
        // increment pointer
        pcha += nBytesCopied;

        Assert (pcha > szaBuf);
        if ('\n' == *(pcha-1))
        {
        pcha--;
        *pcha = 0;
        }

        // update the number of bytes remaining...
        nBytesRemaining = sizeof(szaBuf) - (pcha - szaBuf);
    }
    else
    {
        // modify count
        nBytesRemaining = 0;
    }

    }

    // Add descriptive error text if this is an error and we can get some.
    //
    if ((nBytesRemaining > 0) && (FAILED(hr) || dwWin32Error))
    {
        BOOL fFacilityWin32 = (FACILITY_WIN32 == HRESULT_FACILITY(hr));

        // dwError will be the error code we pass to FormatMessage.  It may
        // come from hr or dwWin32Error.  Give preference to hr.
        //
        DWORD dwError = 0;

        if (fFacilityWin32)
        {
            dwError = HRESULT_CODE(hr);
        }
        else if (FAILED(hr))
        {
            dwError = hr;
        }
        else
        {
            dwError = dwWin32Error;
        }
        Assert (dwError);

        if (!FIsDebugFlagSet (dfidNoErrorText))
        {
            PSTR pszaErrorText = NULL;
            FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL, dwError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                           (PSTR)&pszaErrorText, 0, NULL);

            if (pszaErrorText)
            {
                // Strip off newline characters.
                //
                PSTR pchText = pszaErrorText;
                while (*pchText && (*pchText != '\r') && (*pchText != '\n'))
                {
                    pchText++;
                }
                *pchText = 0;

                // Add the error text.
                //
                static const CHAR c_szaFmtErrorText [] = " [%s]";

        // copy as many bytes as possible
        nBytesCopied = _snprintf (pcha,
                    nBytesRemaining,
                    c_szaFmtErrorText,
                    pszaErrorText);

        // check for overflow
        if (nBytesCopied >= 0)
        {
            // increment pointer
            pcha += nBytesCopied;

            // update the number of bytes remaining...
            nBytesRemaining = sizeof(szaBuf) - (pcha - szaBuf);
        }
        else
        {
            // modify count
            nBytesRemaining = 0;
        }

        LocalFree (pszaErrorText);
            }
        }

        // Add the Win32 error code.
        //
    if ((nBytesRemaining > 0) && (fFacilityWin32 || dwWin32Error))
        {
            static const CHAR c_szaFmtWin32Error [] = " Win32=%d,0x%08X";

        // copy as many bytes as possible
        nBytesCopied = _snprintf (pcha,
                nBytesRemaining,
                c_szaFmtWin32Error,
                dwError, dwError);

        // check for overflow
        if (nBytesCopied >= 0)
        {
        // increment pointer
        pcha += nBytesCopied;

        // update the number of bytes remaining...
        nBytesRemaining = sizeof(szaBuf) - (pcha - szaBuf);
        }
        else
        {
        // modify count
        nBytesRemaining = 0;
        }
        }
    }

    // Add the HRESULT.
    //
    if ((nBytesRemaining > 0) && (S_OK != hr))
    {
        static const CHAR c_szaFmtHresult [] = " hr=0x%08X";

    // copy as many bytes as possible
    nBytesCopied = _snprintf (pcha,
                nBytesRemaining,
                c_szaFmtHresult,
                hr);

    // check for overflow
    if (nBytesCopied >= 0)
    {
        // increment pointer
        pcha += nBytesCopied;

        // update the number of bytes remaining...
        nBytesRemaining = sizeof(szaBuf) - (pcha - szaBuf);
    }
    else
    {
        // modify count
        nBytesRemaining = 0;
    }
    }

    // Add the file and line.
    //
    if ((nBytesRemaining > 0) && (pszaFile))
    {
        static const CHAR c_szaFmtFileAndLine [] = " File:%s,%d";

    // copy as many bytes as possible
    nBytesCopied = _snprintf (pcha,
                nBytesRemaining,
                c_szaFmtFileAndLine,
                pszaFile, nLine);

    // check for overflow
    if (nBytesCopied >= 0)
    {
        // increment pointer
        pcha += nBytesCopied;

        // update the number of bytes remaining...
        nBytesRemaining = sizeof(szaBuf) - (pcha - szaBuf);
    }
    else
    {
        // modify count
        nBytesRemaining = 0;
    }
    }

    // check for full string
    if (nBytesRemaining > 2)
    {
    lstrcatA (pcha, "\n");
    }
    else
    {
    // add new line & terminate full string
    szaBuf[sizeof(szaBuf) - 2] = '\n';
    szaBuf[sizeof(szaBuf) - 1] = '\0';
    }

    g_Tracing.Trace (ttid, szaBuf);

    // Now that the message is on the debugger, break if we have an error
    // and the debug flag to break on error is set.
    //
    if ((FAILED(hr) || dwWin32Error || (ttidError == ttid)) &&
        !fIgnorable && FIsDebugFlagSet(dfidBreakOnError))
    {
        DebugBreak();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorFn
//
//  Purpose:    Output debug trace of an HRESULT, allowing an additional
//              caller-defined error string.
//
//  Arguments:
//      sz          []  Caller-defined additional error text
//      hr          []  The error HRESULT.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPI
TraceErrorFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr)
{
    TraceInternal (ttidError, pszaFile, nLine, TI_HRESULT, psza, hr);
}

VOID
WINAPI
TraceResultFn (
    PCSTR  pszaFile,
    INT    nLine,
    PCSTR  psza,
    BOOL   f)
{
    if (!f)
    {
        TraceInternal (ttidError, pszaFile, nLine, TI_WIN32, psza,
                       GetLastError());
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorOptionalFn
//
//  Purpose:    Implements TraceErrorOptional macro
//
//  Arguments:
//      pszaFile [in]     __FILE__ value
//      nLine    [in]     __LINE__ value
//      psza     [in]     String to trace.
//      hr       [in]     HRESULT value to trace.
//      fOpt     [in]     TRUE if error should be treated as optional, FALSE if
//                        ERROR is not optional and should be reported thru
//                        TraceError().
//
//  Returns:    Nothing.
//
//  Author:     danielwe   12 May 1997
//
//  Notes:
//
VOID
WINAPI
TraceErrorOptionalFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr,
    BOOL    fIgnorable)
{
    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }

    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorSkipFn
//
//  Purpose:    Implements TraceErrorOptional macro
//
//  Arguments:
//      pszaFile [in]     __FILE__ value
//      nLine    [in]     __LINE__ value
//      psza     [in]     String to trace.
//      hr       [in]     HRESULT value to trace.
//      c        [in]     count of pass-through Hresults.  if hr is any of these
//                        the error is treated as optional.
//      ...      [in]     list of hresults.
//
//  Returns:    Nothing.
//
//  Author:     sumitc      08 Jan 1998
//
//  Notes:
//
VOID WINAPI
TraceErrorSkipFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr,
    UINT    c, ...)
{
    va_list valMarker;
    BOOL fIgnorable = FALSE;

    va_start(valMarker, c);
    for (UINT i = 0; i < c; ++i)
    {
        fIgnorable = (va_arg(valMarker, HRESULT) == hr);
        if (fIgnorable)
        {
            break;
        }
    }
    va_end(valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceLastWin32ErrorFn
//
//  Purpose:    Trace the last Win32 error, which we get with GetLastError().
//              Not a whole lot to it.
//
//  Arguments:
//      sz []   Additional error text.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPIV
TraceLastWin32ErrorFn (
    PCSTR  pszaFile,
    INT    nLine,
    PCSTR  psza)
{
    TraceInternal (ttidError, pszaFile, nLine, TI_WIN32, psza, GetLastError());
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceHr
//
//  Purpose:    Generic replacement for the TraceErrorOptional, TraceError,
//              and a couple other random functions.
//
//  Arguments:
//      ttid       [] TraceTag to use for the debug output
//      pszaFile   [] Source file to log
//      nLine      [] Line number to log
//      hr         [] Error to log
//      fIgnorable [] Ignore this error? (The optional bit)
//      pszaFmt    [] Format of the vargs
//
//  Returns:
//
//  Author:     jeffspr   10 Oct 1997
//
//  Notes:
//
VOID
WINAPIV
TraceHr (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    HRESULT     hr,
    BOOL        fIgnorable,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR szaBuf [DBG_BUFFER_SIZE_SMALL];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);

    // copy as many bytes as possible
    _vsnprintf (szaBuf, sizeof(szaBuf), pszaFmt, valMarker);

    // terminate full string
    szaBuf[sizeof(szaBuf) - 1] = '\0';

    va_end (valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttid, pszaFile, nLine, dwFlags, szaBuf, hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceTag
//
//  Purpose:    Output a debug trace to one or more trace targets (ODS,
//              File, COM port, etc.). This function determines the targets
//              and performs the actual trace.
//
//  Arguments:
//      ttid    []  TraceTag to use for the debug output
//      pszaFmt []  Format of the vargs.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPIV
TraceTag (
    TRACETAGID  ttid,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR szaBuf [DBG_BUFFER_SIZE_SMALL];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);

    // copy as many bytes as possible
    _vsnprintf (szaBuf, sizeof(szaBuf), pszaFmt, valMarker);

    // terminate full string
    szaBuf[sizeof(szaBuf) - 1] = '\0';

    va_end (valMarker);

    TraceInternal (ttid, NULL, 0, 0, szaBuf, 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::CTracing
//
//  Purpose:    Constructor for CTracing. Initialize all vars.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Jan 1999
//
//  Notes:
//
CTracing::CTracing()
{
    m_fInitialized          = FALSE;    // Has the object been initialized
    m_fAttemptedLogFileOpen = FALSE;    // Already attempted to open log
    m_fDisableLogFile       = FALSE;    // Disable use of file logging?
    m_hLogFile              = NULL;     // Handle for debug output file
    m_szLogFilePath[0]      = '\0';     // File for debug output
    m_fDebugFlagsLoaded     = FALSE;    // Have these been loaded yet.
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrInit
//
//  Purpose:    Initialize the CTracing object.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   9 Apr 1997
//
//  Notes:      This should get called from some standard exe initialization
//              point. And make sure to call HrDeinit when you're done, eh?
//
HRESULT CTracing::HrInit()
{
    HRESULT hr  = S_OK;

    AssertSz(!m_fInitialized,
            "CTracing::HrInit -- Let's not go overboard. Already initialized");

    // Temporarily set this so the called functions don't believe that we're
    // uninitialized. At Exit, if we fail, we'll set it back so no-one tries
    // to call these functions when uninitialized.
    //
    m_fInitialized = TRUE;

    // Check for corruptions in the tracing structure. This can't fail, but
    // it will send up asserts all over the place if something is amiss.
    //
    CorruptionCheck();

    // Load the "options" section from the ini file
    //
    hr = HrLoadOptionsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Load the DebugFlags section from the ini file.
    //
    hr = HrLoadDebugFlagsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Load the tracetag sections from the ini file.
    // Make sure this is called after HrLoadDebugFlagsFromIniFile(),
    // as those options will affect the tracetag sections (we also
    // assert on this)
    //
    hr = HrLoadSectionsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

Exit:
    if (FAILED(hr))
    {
        m_fInitialized = FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrUnInit
//
//  Purpose:    Uninitialize the Tracing object
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrUnInit()
{
    HRESULT hr  = S_OK;

    // Don't assert on m_fInitialized here, because we allow this to
    // be called even if initialization failed.
    //
    if (m_fInitialized)
    {
        hr = HrWriteDebugFlagsToIniFile();
        if (FAILED(hr))
        {
            // continue on, but I want to know why this is failing.
            AssertSz(FALSE, "Whoa, why can't we write the debug flags?");
        }

        // Close the log file, if there's one open
        //
        if (m_hLogFile)
        {
            CloseHandle(m_hLogFile);
            m_hLogFile = NULL;
            m_fAttemptedLogFileOpen = FALSE;
        }

        if (m_hMutex)
        {
            CloseHandle(m_hMutex);
        }

        // Mark us as being uninitialized.
        //
        m_fInitialized = FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrGetPrivateProfileString
//
//  Purpose:
//
//  Arguments:
//      lpAppName        [] points to section name
//      lpKeyName        [] points to key name
//      lpDefault        [] points to default string
//      lpReturnedString [] points to destination buffer
//      nSize            [] size of destination buffer
//      lpFileName       [] points to initialization filename
//      pcchReturn          return buffer for the old Win32 API return code
//
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrGetPrivateProfileString(    PCSTR  lpAppName,
                                                PCSTR  lpKeyName,
                                                PCSTR  lpDefault,
                                                PSTR   lpReturnedString,
                                                DWORD  nSize,
                                                PCSTR  lpFileName,
                                                DWORD* pcchReturn
)
{
    HRESULT hr              = S_OK;

    Assert(m_fInitialized);

    // Assert on the known conditions required for this API call
    //
    Assert(lpDefault);
    Assert(lpFileName);

    // Call the Win32 API
    //
    DWORD dwGPPSResult = GetPrivateProfileStringA(
            lpAppName,
            lpKeyName,
            lpDefault,
            lpReturnedString,
            nSize,
            lpFileName);

    // Check to see if we've gotten a string-size error
    if (lpAppName && lpKeyName)
    {
        // If we get back (nSize - 1), then our string buffer wasn't
        // large enough
        //
        if (dwGPPSResult == (nSize - 1))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }
    }
    else
    {
        // Since either of the app name or key name are NULL, then
        // we're supposed to be receiving a doubly-NULL terminated
        // list of strings. If we're at (nSize - 2), that means
        // our buffer was too small.
        //
        if (dwGPPSResult == (nSize - 2))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }
    }

Exit:
    *pcchReturn = dwGPPSResult;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadOptionsFromIniFile
//
//  Purpose:    Load the options section from the ini file, and set our
//              state accordingly
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadOptionsFromIniFile()
{
    HRESULT hr                          = S_OK;
    DWORD   cchReturnBufferSize         = 0;
    CHAR    szaLogFilePath[MAX_PATH+1]  = { 0 };
    DWORD   dwTempPathLength            = 0;

    // Get the explicit log file path, if any. If it doesn't exist, then
    // use the default path, which is the temp file path plus the default
    // trace file name
    //

    // Get the location of the "temporary files" path
    dwTempPathLength = GetTempPathA(MAX_PATH, szaLogFilePath);
    if ((dwTempPathLength == 0) ||
        (dwTempPathLength > MAX_PATH))
    {
        TraceLastWin32Error("GetTempPath failure");

        hr = HrFromLastWin32Error();
        goto Exit;
    }

    // Tack the log file name onto the end.
    //
    wsprintfA(m_szLogFilePath, "%s%s", szaLogFilePath, c_szaTraceLogFileName);

    // This will overwrite the log file path if one exists in the INI file
    //
    hr = HrGetPrivateProfileString(
            c_szaOptions,           // "Options"
            c_szaLogFilePath,       // "LogFilePath
            m_szLogFilePath,        // Default string, already filled
            m_szLogFilePath,        // Return string (same string)
            MAX_PATH+1,
            c_szaDebugIniFileName,
            &cchReturnBufferSize);
    if (FAILED(hr))
    {
        // This should not cause problems with recursive failure, since
        // Traces will work regardless of the state of trace initialization.
        //
        TraceError(
                "GetPrivateProfileString failed on Options::LogFilePath", hr);
        goto Exit;
    }

    // Get the "disable log file option". No return code here.
    m_fDisableLogFile = GetPrivateProfileIntA(
            c_szaOptions,               // "Options"
            c_szaDisableLogFile,        // "DisableLogFile"
            c_iDefaultDisableLogFile,
            c_szaDebugIniFileName);
    if (FAILED(hr))
    {
        TraceError(
                "GetPrivateProfileInt failed on Options::DisableLogFile", hr);
        goto Exit;
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadSectionsFromIniFile
//
//  Purpose:    Load the individual tracetag sections from the ini file, and
//              set our array elements accordingly, defaulting if necessary.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadSectionsFromIniFile()
{
    HRESULT hr = S_OK;

    // Make sure that we've loaded the debug flags first, as they can
    // affect each tracetag section
    //
    Assert(m_fDebugFlagsLoaded);

    // Loop through the array and load the data.
    //
    for (INT nLoop = 0; nLoop < g_nTraceTagCount; nLoop++ )
    {
        // Process the individual lines from the section
        hr = HrProcessTagSection(&(g_TraceTags[nLoop]));
        if (FAILED(hr))
        {
            break;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadDebugFlagsFromIniFile
//
//  Purpose:    Load the individual debugflag values from the ini file, and
//              set our array elements accordingly, defaulting if necessary.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadDebugFlagsFromIniFile()
{
    HRESULT hr                  = S_OK;
    INT     nLoop;

    // Loop through the array and load the data.
    //
    for (nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
    {
        // Get the enabled file param
        //
        g_DebugFlags[nLoop].dwValue = GetPrivateProfileIntA(
                "DebugFlags",
                g_DebugFlags[nLoop].szShortName,
                FALSE,
                c_szaDebugIniFileName);
    }

    if (SUCCEEDED(hr))
    {
        m_fDebugFlagsLoaded = TRUE;
    }

    return hr;
}

BOOL CTracing::FIniFileExists()
{
    BOOL    fReturn             = TRUE;
    CHAR    szaPath[MAX_PATH+1] = "";
    UINT    uiCharsReturned     = 0;
    HANDLE  hFile               = INVALID_HANDLE_VALUE;

    uiCharsReturned =
            GetWindowsDirectoryA(szaPath, MAX_PATH);
    if ((uiCharsReturned == 0) || (uiCharsReturned > MAX_PATH))
    {
        AssertSz(FALSE, "GetWindowsDirectory failed in CTracing::FIniFileExists");

        fReturn = FALSE;
        goto Exit;
    }

    lstrcatA (szaPath, "\\");
    lstrcatA (szaPath, c_szaDebugIniFileName);

    hFile = CreateFileA(
            szaPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwLastError = GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            AssertSz(FALSE, "FIniFileExists failed for some reason other than FILE_NOT_FOUND");
        }

        fReturn = FALSE;
        goto Exit;
    }

Exit:
    if (hFile)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    return fReturn;
}

HRESULT CTracing::HrWriteDebugFlagsToIniFile()
{
    HRESULT hr = S_OK;

    // First, check to see if the file exists. If it doesn't, then we don't want
    // to write the entries.
    //
    if (FIniFileExists())
    {
        // Loop through the array and write the data.
        //
        for (INT nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
        {
            CHAR   szInt[16];      // Sure, it's arbitrary, but it's also OK.

            switch(nLoop)
            {
                // These store a DWORD in its standard form
                //
                case dfidBreakOnHr:
                case dfidBreakOnHrIteration:
                case dfidBreakOnIteration:
                    wsprintfA( szInt, "%d", g_DebugFlags[nLoop].dwValue);
                    break;

                // default are treated as boolean, and stored that way
                //
                default:
                    // !! means it will always be 1 or 0.
                    wsprintfA( szInt, "%d", (!!g_DebugFlags[nLoop].dwValue));
                    break;
            }

            // Write the param to the ini file
            WritePrivateProfileStringA(
                    "DebugFlags",
                    g_DebugFlags[nLoop].szShortName,
                    szInt,
                    c_szaDebugIniFileName);
        }
    }

    // For now, this is always S_OK, since there's nothing above that can
    // fail.
    //
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrProcessTagSection
//
//  Purpose:    Grab the parameters from the ini file. If they're not
//              available, then use the settings in default. Note - this
//              will always work because ttidDefault will always be the first
//              element. If a [default] section wasn't present, then it will
//              be using the settings that were in the struct initialization,
//              which is also fine.
//
//  Arguments:
//      ptte []     TraceTag element to load
//
//  Returns:
//
//  Author:     jeffspr   15 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrProcessTagSection(  TraceTagElement *   ptte )
{
    HRESULT hr                      = S_OK;

    AssertSz(m_fInitialized,
            "CTracing::HrProcessTagSection. Class not initialized");

    AssertSz(ptte, "CTracing::HrProcessTagSection -- invalid ptte");

    // Get the output to file param
    //
    ptte->fOutputToFile = GetPrivateProfileIntA(
            ptte->szShortName,
            "OutputToFile",
            ptte->fVerboseOnly ?
                FALSE : g_TraceTags[ttidDefault].fOutputToFile,
            c_szaDebugIniFileName);

    // Get the OutputDebugString param. Require that the error tag
    // always has at least output debug string on.
    //
    if (ptte->ttid == ttidError)
    {
        ptte->fOutputDebugString = TRUE;
    }
    else
    {
        // Load the OutputToDebug
        ptte->fOutputDebugString = GetPrivateProfileIntA(
                ptte->szShortName,
                "OutputToDebug",
                ptte->fVerboseOnly ?
                    FALSE : g_TraceTags[ttidDefault].fOutputDebugString,
                c_szaDebugIniFileName);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::CorruptionCheck
//
//  Purpose:    Validate the tracetag array. Check to see that the
//              shortnames are valid, that the descriptions are valid,
//              and that the tracetag elements are not out of order.
//              Also verify that the correct number of tracetag elements
//              exist.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   15 Apr 1997
//
//  Notes:
//      (shaunco) 16 Jul 1997: This is #if'defd out until JVert
//      gives us a fix for the alpha compiler.  It blows up compiling this
//      function in retail.
//
//      (jeffspr) Tough noogies for JVert - I need this code. Hopefully
//      this has been fixed by now.
//
VOID CTracing::CorruptionCheck()
{
    INT nLoop = 0;

    // Validate the tracetag structure
    //
    for (nLoop = 0; nLoop < g_nTraceTagCount; nLoop++)
    {
        // Verify that we're not out of order or missing ttids
        //
        AssertSz(g_TraceTags[nLoop].ttid == nLoop,
                "Invalid ttid in the tracetag structure. Out of order. " \
                "CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].ttid < g_nTraceTagCount,
                "Invalid ttid (out of range) in CTracing::CorruptionCheck");

        // Validate the shortname (verify not NULL or empty strings)
        //
        AssertSz(g_TraceTags[nLoop].szShortName,
                "Invalid tracetag short name (NULL) in CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].szShortName[0] != 0,
                "Invalid tracetagshort name (empty) in CTracing::CorruptionCheck");

        // Validate the descriptions (verify not NULL or empty strings)
        //
        AssertSz(g_TraceTags[nLoop].szDescription,
                "Invalid tracetagdescription in CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].szDescription[0] != 0,
                "Invalid tracetagdescription (empty) in CTracing::CorruptionCheck");
    }

    // Validate the debug flags structure
    //
    for (nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
    {
        // Verify that we're not out of order or missing dfids
        //
        AssertSz(g_DebugFlags[nLoop].dfid == nLoop,
                "Invalid dfid in the debugflag structure. Out of order. " \
                "CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].dfid < g_nDebugFlagCount,
                "Invalid dfid (out of range) in CTracing::CorruptionCheck");

        // Validate the shortname (verify not NULL or empty strings)
        //
        AssertSz(g_DebugFlags[nLoop].szShortName,
                "Invalid debug flag short name (NULL) in CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].szShortName[0] != 0,
                "Invalid debug flag short name (empty) in CTracing::CorruptionCheck");

        // Validate the descriptions (verify not NULL or empty strings)
        //
        AssertSz(g_DebugFlags[nLoop].szDescription,
                "Invalid debug flag description in CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].szDescription[0] != 0,
                "Invalid debug flag description (empty) in CTracing::CorruptionCheck");
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::Trace
//
//  Purpose:    The actual trace call that takes care of doing the output
//              to each trace target (file, OutputDebugString, etc.)
//
//  Arguments:
//      ttid      []     The tracetag to use for output
//      pszaTrace []     The trace string itself.
//
//  Returns:
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
VOID CTracing::Trace( TraceTagId    ttid,
                      PCSTR         pszaTrace )
{
    // HrInit should have called a corruption checker for the entire trace
    // block, but we'll check again just to make sure.
    //
    AssertSz(g_nTraceTagCount > ttid, "ttid out of range in CTracing::Trace");
    AssertSz(g_TraceTags[ttid].ttid == ttid,
            "TraceTag structure is corrupt in CTracing::Trace");

    // If they want debug string output
    //
    if (g_TraceTags[ttid].fOutputDebugString)
    {
        // Then output the string
        //
        OutputDebugStringA(pszaTrace);
    }

    // If they want file output
    if (g_TraceTags[ttid].fOutputToFile)
    {
        if (!m_hLogFile)
        {
            // Assuming that we haven't already tried to open the file
            // and failed, open it.
            if (!m_fAttemptedLogFileOpen)
            {
                HRESULT hr = HrOpenLogFile();
                if (FAILED(hr))
                {
                    AssertSz(FALSE, "Failed to open log file for tracing. No, "
                             "this isn't a coding error, but hey, figured that "
                             "you'd want to know...");
                }
            }
        }

        // If we were already open, or the open has now succeeded, do the
        // trace
        //
        if (m_hLogFile)
        {
            Assert(pszaTrace);

            // Since pszTrace is guaranteed to be a single-byte trace, we
            // don't need to do the WCHAR multiply on the length, just
            // a char multiply.
            //
            DWORD   dwBytesToWrite  = lstrlenA(pszaTrace) * sizeof(CHAR);
            DWORD   dwBytesWritten  = 0;
            BOOL    fWriteResult    = FALSE;

            WaitForSingleObject(m_hMutex, INFINITE);

            fWriteResult = WriteFile(
                    m_hLogFile,         // handle to file to write to
                    pszaTrace,           // pointer to data to write to file
                    dwBytesToWrite,     // size of trace
                    &dwBytesWritten,    // Bytes actually written.
                    NULL );             // No overlapped

            ReleaseMutex(m_hMutex);

            if (!fWriteResult || (dwBytesToWrite != dwBytesWritten))
            {
                AssertSz(FALSE, "CTracing failure: Can't write to log file."
                         " Can't trace or we'll be recursing on this failure.");
            }
        }
    }
}

HRESULT CTracing::HrOpenLogFile()
{
    HRESULT             hr  = S_OK;
    SECURITY_ATTRIBUTES sa = {0};
    SECURITY_DESCRIPTOR sd = {0};

    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = &sd;

    AssertSz(m_fInitialized,
            "CTracing not initialized in HrOpenLogFile()");
    AssertSz(!m_hLogFile,
            "File already open before call to HrOpenLogFile()");

    // Mark us as having attempted to open the file, so we don't call this
    // function everytime we log, if we can't open it.
    //
    m_fAttemptedLogFileOpen = TRUE;

    m_hMutex = CreateMutexA(&sa, FALSE, c_szaLogFileMutex);
    if (!m_hMutex)
    {
        hr = HrFromLastWin32Error();
        goto Exit;
    }

    WaitForSingleObject(m_hMutex, INFINITE);

    // $$TODO (jeffspr) - Allow flags in the Options section of the ini
    // file specify the create flags and attributes, which would allow
    // us to control the overwriting of log files and/or the write-through
    // properties.
    //

    // Actually open the file, creating if necessary.
    //
    m_hLogFile = CreateFileA(
            m_szLogFilePath,        // Pointer to name of file
            GENERIC_READ | GENERIC_WRITE,          // access (read-write) mode
            FILE_SHARE_READ | FILE_SHARE_WRITE,        // share mode (allow read access)
            NULL,                   // pointer to security attributes
            OPEN_ALWAYS,            // how to create
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
            NULL);
    if (INVALID_HANDLE_VALUE == m_hLogFile)
    {
        m_hLogFile = NULL;

        hr = HrFromLastWin32Error();
        goto ExitAndRelease;
    }

    SetFilePointer(m_hLogFile, 0, NULL, FILE_END);

ExitAndRelease:
    ReleaseMutex(m_hMutex);

Exit:
    return hr;
}


#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\updebug\tracetag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E T A G . C P P
//
//  Contents:   TraceTag list for the NetCfg Project
//
//  Notes:
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include "tracetag.h"


// This is the TraceTag list that everyone should be modifying.
//
TraceTagElement g_TraceTags[] =
{
//      :-----------    TraceTagId  ttid
//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           BOOL        fOutputDebugString -----------------------------:
//      | | |           BOOL        fOutputToFile ----------------------------------|---:
//      | | |           BOOL        fVerboseOnly------------------------------------|---|---:
//      | | |                                                                       |   |   |
//      | | |                                                                       |   |   |
//      | | :-----------------------------------------:                             |   |   |
//      | :-------------------:                       |                             |   |   |
//      |                     |                       |                             |   |   |
//      v                     v                       v                             v   v   v
//
    { ttidDefault,          "Default",              "Default",                      0,  0,  0 },
    { ttidDescMan,          "DescMan",              "Description Manager",          0,  0,  0 },
    { ttidError,            "Errors",               "Errors",                       0,  0,  0 },
    { ttidEsLock,           "EsLocks",              "Exception safe locks",         0,  0,  0 },
    { ttidEvents,           "Events",               "Event Subsystem",              0,  0,  0 },
    { ttidEventServer,      "EventServer",          "Event Server",                 0,  0,  0 },
    { ttidIsapiCtl,         "IsapiCtl",             "ISAPI Control Extension",      0,  0,  0 },
    { ttidIsapiEvt,         "IsapiEvt",             "ISAPI Event Requests",         0,  0,  0 },
    { ttidMedia,            "Media",                "Media Player Device",          0,  0,  0 },
    { ttidRegistrar,        "Registrar",            "UPnP Registrar",               0,  0,  0 },
    { ttidShellEnum,        "ShellEnum",            "Shell Folder Enumeration",     0,  0,  0 },
    { ttidShellFolder,      "ShellFolder",          "Shell Folder",                 0,  0,  0 },
    { ttidShellFolderIface, "ShellFolderIface",     "Shell Folder COM Interfaces",  0,  0,  1 },
    { ttidShellTray,        "ShellTray",            "Shell Tray",                   0,  0,  0 },
    { ttidShellViewMsgs,    "ShellViewMsgs",        "Shell View Callback Messages", 0,  0,  1 },
    { ttidSsdpAnnounce,     "SSDPAnnounce",         "SSDP Announcements",           0,  0,  0 },
    { ttidSsdpRpcInit,      "SSDPRpcInit",          "SSDP RPC Initialization",      0,  0,  0 },
    { ttidSsdpRpcStop,      "SSDPRpcStop",          "SSDP RPC Stop",                0,  0,  0 },
    { ttidSsdpRpcIf,        "SSDPRpcIf",            "SSDP RPC Interface",           0,  0,  0 },
    { ttidSsdpSocket,       "SSDPSocket",           "SSDP Socket",                  0,  0,  0 },
    { ttidSsdpRecv,         "SSDPRecv",             "SSDP Receive",                 0,  0,  0 },
    { ttidSsdpNetwork,      "SSDPNetwork",          "SSDP Network",                 0,  0,  0 },
    { ttidSsdpParser,       "SSDPParser",           "SSDP Parser",                  0,  0,  0 },
    { ttidSsdpSearchResp,   "SSDPSearchResp",       "SSDP Search Response",         0,  0,  0 },
    { ttidSsdpSysSvc,       "SSDPSysSvc",           "SSDP System Service",          0,  0,  0 },
    { ttidSsdpCache,        "SSDPCache",            "SSDP Cache",                   0,  0,  0 },
    { ttidSsdpNotify,       "SSDPNotify",           "SSDP Notify",                  0,  0,  0 },
    { ttidSsdpCRpcInit,     "SSDPCRpcInit",         "SSDP Client RPC Init",         0,  0,  0 },
    { ttidSsdpCNotify,      "SSDPCNotify",          "SSDP Client Notify",           0,  0,  0 },
    { ttidSsdpCSearch,      "SSDPCSearch",          "SSDP Client Search",           0,  0,  0 },
    { ttidSsdpCPublish,     "SSDPCPublish",         "SSDP Client Publish",          0,  0,  0 },
    { ttidSsdpTimer,        "SSDPTimer",            "SSDP Timer",                   0,  0,  0 },
    { ttidUPnPBase,         "UPnPBase",             "UPnP Base Messages",           0,  0,  0 },
    { ttidUPnPHost,         "UPnPHost",             "UPnP Device Host",             0,  0,  0 },
    { ttidUpdiag,           "UpDiag",               "UPnP Diagnostic App",          0,  0,  0 },
    { ttidUPnPDescriptionDoc,"UPnPDescription",     "UPnP Description Messages",    0,  0,  0 },
    { ttidUPnPDeviceFinder,  "UPnPDeviceFinder",    "UPnP Device Finder",           0,  0,  0 },
    { ttidRehydrator,        "Rehydrator",          "UPnP Rehydrator",              0,  0,  0 },
    { ttidUPnPService,       "UPnPService",         "UPnP Service Object",          0,  0,  0 },
    { ttidUPnPDocument,     "UPnPDocument",         "UPnP Document Object",         0,  0,  0 },
    { ttidUPnPEnum,         "UPnPEnum",             "UPnP Device/Service Enum",     0,  0,  0 },
    { ttidUPnPSampleDevice, "UPnPSampleDevice",     "UPnP Device Host Sample",      0,  0,  0 },
    { ttidSOAPRequest,      "SOAPRequest",          "SOAP Request Object",          0,  0,  0 },
    { ttidUDHISAPI,         "UDHISAPI",             "UDH ISAPI Extension",          0,  0,  0 },
    { ttidAutomationProxy,  "AutomationProxy",      "UPnP Automation Proxy",        0,  0,  0 },
    { ttidWebServer,        "Web Server",           "UPnP Web Server",              0,  0,  0 },
    { ttidValidate,         "Validation",           "UPnP Device Host Validation",  0,  0,  0 }
};

const INT g_nTraceTagCount = celems(g_TraceTags);

#endif //! ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upnetwork\interfacelist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E L I S T . C P P 
//
//  Contents:   Common code to manage the list of network interfaces
//
//  Notes:      
//
//  Author:     mbend   29 Dec 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "InterfaceList.h"
#include <iphlpapi.h>
#include <winsock2.h>

CUPnPInterfaceList CUPnPInterfaceList::s_instance;
CUPnPInterfaceList::CUPnPInterfaceList() : m_bGlobalEnable(TRUE), m_bICSEnabled(FALSE), m_hInterfaceChangeWait(NULL)
{
    ZeroMemory(&m_olInterfaceChangeEvent, sizeof(m_olInterfaceChangeEvent));
}

CUPnPInterfaceList::~CUPnPInterfaceList()
{
}

CUPnPInterfaceList & CUPnPInterfaceList::Instance()
{
    return s_instance;
}

HRESULT CUPnPInterfaceList::HrInitialize()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    // TODO: Read registry to set global enable state!!!!!

    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(!hEvent)
    {
        hr = HrFromLastWin32Error();
    }
    if(SUCCEEDED(hr))
    {
        if(!RegisterWaitForSingleObject(&m_hInterfaceChangeWait, hEvent, 
                &CUPnPInterfaceList::InterfaceChangeCallback, NULL, INFINITE, 0))
        {
            hr = HrFromLastWin32Error();
        }
        if(SUCCEEDED(hr))
        {
            m_olInterfaceChangeEvent.hEvent = hEvent;
            hr = HrBuildIPAddressList();
            if(SUCCEEDED(hr))
            {
                HANDLE hNotify = NULL;
                if(!NotifyAddrChange(&hNotify, &m_olInterfaceChangeEvent))
                {
                    hr = HrFromLastWin32Error();
                }
            }
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrInitialize");
    return hr;
}

HRESULT CUPnPInterfaceList::HrShutdown()
{
    HRESULT hr = S_OK;

    // Kill wait outside of a lock
    UnregisterWaitEx(m_hInterfaceChangeWait, INVALID_HANDLE_VALUE);

    CLock lock(m_critSec);

    CloseHandle(m_olInterfaceChangeEvent.hEvent);
    m_olInterfaceChangeEvent.hEvent = NULL;

    m_ipAddressList.Clear();
    m_indexList.Clear();
    m_interfaceList.Clear();

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrShutdown");
    return hr;
}

BOOL CUPnPInterfaceList::FShouldSendOnInterface(DWORD dwIpAddr)
{
    CLock lock(m_critSec);

    if(!m_bICSEnabled)
    {
        return m_bGlobalEnable;
    }

    long nIndex = -1;
    HRESULT hrTemp = m_ipAddressList.HrFind(dwIpAddr, nIndex);
#if DBG
    in_addr addr;
    addr.S_un.S_addr = dwIpAddr;
    char * szAddr = inet_ntoa(addr);
    if(S_OK != hrTemp)
    {
        TraceTag(ttidSsdpNetwork, "CUPnPInterfaceList::FShouldSendOnInterface - Blocked sending on IP Address (%s)", szAddr);
    }
#endif // DBG

    return S_OK == hrTemp;
}

BOOL CUPnPInterfaceList::FShouldSendOnIndex(DWORD dwIndex)
{
    CLock lock(m_critSec);

    if(!m_bICSEnabled)
    {
        return m_bGlobalEnable;
    }

    long nIndex = -1;
    HRESULT hrTemp = m_indexList.HrFind(dwIndex, nIndex);
#if DBG
    if(S_OK != hrTemp)
    {
        TraceTag(ttidSsdpNetwork, "CUPnPInterfaceList::FShouldSendOnIndex - Blocked sending on index (%d)", dwIndex);
    }
#endif // DBG

    return S_OK == hrTemp;
}

HRESULT CUPnPInterfaceList::HrSetGlobalEnable()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    m_bGlobalEnable = TRUE;

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrSetGlobalEnable");
    return hr;
}

HRESULT CUPnPInterfaceList::HrClearGlobalEnable()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    m_bGlobalEnable = FALSE;

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrClearGlobalEnable");
    return hr;
}

HRESULT CUPnPInterfaceList::HrSetICSInterfaces(long nCount, GUID * arInterfaceGuidsToAllow)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    m_bICSEnabled = TRUE;

    m_interfaceList.Clear();
    hr = m_interfaceList.HrSetCount(nCount);
    if(SUCCEEDED(hr))
    {
        for(long n = 0; n < nCount; ++n)
        {
            m_interfaceList[n] = arInterfaceGuidsToAllow[n];
        }
        hr = HrBuildIPAddressList();
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrSetICSInterfaces");
    return hr;
}

HRESULT CUPnPInterfaceList::HrSetICSOff()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    m_bICSEnabled = FALSE;
    m_interfaceList.Clear();
    hr = HrBuildIPAddressList();

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrSetICSOff");
    return hr;
}

HRESULT CUPnPInterfaceList::HrRegisterInterfaceChange(CUPnPInterfaceChange * pInterfaceChange)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    hr = m_interfaceChangeList.HrPushBack(pInterfaceChange);

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrRegisterInterfaceChange");
    return hr;
}

void CALLBACK CUPnPInterfaceList::InterfaceChangeCallback(void *, BOOLEAN)
{
    CLock lock(s_instance.m_critSec);
    HRESULT hr = S_OK;
    hr = s_instance.HrBuildIPAddressList();
    if(SUCCEEDED(hr))
    {
        HANDLE hNotify = NULL;
        if(!NotifyAddrChange(&hNotify, &s_instance.m_olInterfaceChangeEvent))
        {
            hr = HrFromLastWin32Error();
        }       
    }
    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::InterfaceChangeCallback");
}

HRESULT CUPnPInterfaceList::HrBuildIPAddressList()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    CInterfaceManager man;
    if(m_bICSEnabled)
    {
        hr = man.HrInitializeWithIncludedInterfaces(m_interfaceList);
        if(SUCCEEDED(hr))
        {
            hr = man.HrGetValidIpAddresses(m_ipAddressList);
            if(SUCCEEDED(hr))
            {
                hr = man.HrGetValidIndices(m_indexList);
            }
        }
    }
    else
    {
        hr = man.HrInitializeWithAllInterfaces();
    }
    if(SUCCEEDED(hr))
    {
        InterfaceMappingList interfaceMappingList;
        hr = man.HrGetMappingList(interfaceMappingList);
        if(SUCCEEDED(hr))
        {
            long nCount = m_interfaceChangeList.GetCount();
            for(long n = 0; n < nCount; ++n)
            {
                m_interfaceChangeList[n]->OnInterfaceChange(interfaceMappingList);
            }
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CUPnPInterfaceList::HrBuildIPAddressList");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upthread\upthread.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U P T H R E A D . C P P 
//
//  Contents:   Threading support code
//
//  Notes:      
//
//  Author:     mbend   29 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "upthread.h"
#include "ncbase.h"

CWorkItem::CWorkItem() : m_bDeleteOnComplete(FALSE)
{
}

CWorkItem::~CWorkItem()
{
}

HRESULT CWorkItem::HrStart(BOOL bDeleteOnComplete)
{
    HRESULT hr = S_OK;

    m_bDeleteOnComplete = bDeleteOnComplete;
    if(!QueueUserWorkItem(&CWorkItem::DwThreadProc, this, GetFlags()))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CWorkItem::HrStart(%x)", this);
    return hr;
}

ULONG CWorkItem::GetFlags()
{
    return WT_EXECUTEDEFAULT;
}

DWORD WINAPI CWorkItem::DwThreadProc(void * pvParam)
{
    CWorkItem * pWorkItem = reinterpret_cast<CWorkItem*>(pvParam);
    DWORD dwRet = pWorkItem->DwRun();
    if(pWorkItem->m_bDeleteOnComplete)
    {
        delete pWorkItem;
    }
    return dwRet;
}

CThreadBase::CThreadBase() : m_bDeleteOnComplete(FALSE), m_hThread(NULL), m_dwThreadId(0)
{
}

CThreadBase::~CThreadBase()
{
    if(m_hThread)
    {
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
}

HRESULT CThreadBase::HrStart(BOOL bDeleteOnComplete, BOOL bCreateSuspended)
{
    Assert(!m_hThread);
    HRESULT hr = S_OK;

    m_bDeleteOnComplete = bDeleteOnComplete;

    m_hThread = CreateThread(NULL, 0, &CThreadBase::DwThreadProc, this, bCreateSuspended ? CREATE_SUSPENDED : 0, &m_dwThreadId);

    if(!m_hThread)
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CThreadBase::HrStart(%x)", this);
    return hr;
}

DWORD WINAPI CThreadBase::DwThreadProc(void * pvParam)
{
    CThreadBase * pThread = reinterpret_cast<CThreadBase*>(pvParam);
    TraceTag(ttidUPnPBase, "CThreadBase(this=%x, id=%x) - thread started", pThread, pThread->m_dwThreadId);
    DWORD dwRet = pThread->DwRun();
    if(pThread->m_bDeleteOnComplete)
    {
        delete pThread;
    }
    return dwRet;
}

HRESULT CThreadBase::HrGetExitCodeThread(DWORD * pdwExitCode)
{
    HRESULT hr = S_OK;

    if(!GetExitCodeThread(m_hThread, pdwExitCode))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CThreadBase::HrGetExitCodeThread");
    return hr;
}

HRESULT CThreadBase::HrResumeThread()
{
    HRESULT hr = S_OK;

    if(-1 == ResumeThread(m_hThread))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CThreadBase::HrResumeThread");
    return hr;
}

HRESULT CThreadBase::HrSuspendThread()
{
    HRESULT hr = S_OK;

    if(-1 == SuspendThread(m_hThread))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CThreadBase::HrSuspendThread");
    return hr;
}

HANDLE CThreadBase::GetThreadHandle()
{
    return m_hThread;
}

DWORD CThreadBase::GetThreadId()
{
    return m_dwThreadId;
}

HRESULT CThreadBase::HrWait(DWORD dwTimeoutInMillis, BOOL * pbTimedOut)
{
    HRESULT hr = S_OK;

    DWORD dwRet = WaitForSingleObject(m_hThread, dwTimeoutInMillis);

    if(WAIT_TIMEOUT == dwRet)
    {
        hr = S_FALSE;
        TraceTag(ttidUPnPBase, "CThreadBase::HrWait(this=%x, id=%x) - timed out", this, m_dwThreadId);
    }
    else if(WAIT_FAILED == dwRet)
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CThreadBase::HrWait");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upnetwork\interfacemanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E M A N A G E R . C P P
//
//  Contents:   Manages building the list of IP addresses
//
//  Notes:
//
//  Author:     mbend   3 Jan 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "InterfaceManager.h"
#include "winsock2.h"

CInterfaceManager::CInterfaceManager()
{
}

CInterfaceManager::~CInterfaceManager()
{
}

HRESULT CInterfaceManager::HrInitializeWithAllInterfaces()
{
    HRESULT hr = S_OK;

    // Preallocate mapping table
    m_bAllInterfaces = TRUE;
    m_interfaceMappingList.Clear();
    hr = HrProcessIpAddresses();

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceManager::HrInitializeWithAllInterfaces");
    return hr;
}

HRESULT CInterfaceManager::HrInitializeWithIncludedInterfaces(const InterfaceList & interfaceList)
{
    HRESULT hr = S_OK;

    m_bAllInterfaces = FALSE;
    long nCount = interfaceList.GetCount();
    // Preallocate mapping table
    m_interfaceMappingList.Clear();
    hr = m_interfaceMappingList.HrSetCount(nCount);
    if(SUCCEEDED(hr))
    {
        for(long n = 0; n < nCount; ++n)
        {
            m_interfaceMappingList[n].m_guidInterface = interfaceList[n];
            m_interfaceMappingList[n].m_dwIpAddress = 0;
        }
        hr = HrProcessIpAddresses();
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceManager::HrInitializeWithIncludedInterfaces");
    return hr;
}

HRESULT CInterfaceManager::HrGetValidIpAddresses(IpAddressList & ipAddressList)
{
    HRESULT hr = S_OK;

    long nCount = m_interfaceMappingList.GetCount();
    ipAddressList.Clear();
    hr = ipAddressList.HrSetCount(nCount + 1);
    if(SUCCEEDED(hr))
    {
        for(long n = 0; n < nCount; ++n)
        {
            ipAddressList[n] = m_interfaceMappingList[n].m_dwIpAddress;
        }
        // Add loopback address
        ipAddressList[n] = inet_addr("127.0.0.1");
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceManager::HrGetValidIpAddresses");
    return hr;
}

HRESULT CInterfaceManager::HrGetValidIndices(IndexList & indexList)
{
    HRESULT hr = S_OK;

    long nCount = m_interfaceMappingList.GetCount();
    indexList.Clear();
    hr = indexList.HrSetCount(nCount);  
    if(SUCCEEDED(hr))
    {
        for(long n = 0; n < nCount; ++n)
        {
            indexList[n] = m_interfaceMappingList[n].m_dwIndex;
        }    
    }
    // Loopback case is handled separately but in HrGetValidIpAddresses() we have Loopback entry. 

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceManager::HrGetValidIndices");
    return hr;
}

HRESULT CInterfaceManager::HrAddInterfaceMappingIfPresent(DWORD dwIpAddress, DWORD dwIndex, const GUID & guidInterface)
{
    HRESULT hr = S_OK;

    if(m_bAllInterfaces)
    {
        //InterfaceMapping interfaceMapping = {guidInterface, dwIpAddress};
        InterfaceMapping interfaceMapping;
        interfaceMapping.m_dwIpAddress = dwIpAddress;
        interfaceMapping.m_dwIndex = dwIndex;
        interfaceMapping.m_guidInterface = guidInterface;
        hr = m_interfaceMappingList.HrPushBack(interfaceMapping);
    }
    else
    {
        long nCount = m_interfaceMappingList.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            if(m_interfaceMappingList[n].m_guidInterface == guidInterface)
            {
                m_interfaceMappingList[n].m_dwIndex = dwIndex;
                m_interfaceMappingList[n].m_dwIpAddress = dwIpAddress;
                break;
            }
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceManager::HrAddInterfaceMappingIfPresent");
    return hr;
}

HRESULT CInterfaceManager::HrProcessIpAddresses()
{
    HRESULT hr = S_OK;

    CInterfaceTable interfaceTable;
    hr = interfaceTable.HrInitialize();
    if(SUCCEEDED(hr))
    {
        InterfaceMappingList interfaceMappingList;
        hr = interfaceTable.HrGetMappingList(interfaceMappingList);
        if(SUCCEEDED(hr))
        {
            long nCount = interfaceMappingList.GetCount();
            for(long n = 0; n < nCount && SUCCEEDED(hr); ++n)
            {
                hr = HrAddInterfaceMappingIfPresent(
                    interfaceMappingList[n].m_dwIpAddress,
                    interfaceMappingList[n].m_dwIndex,
                    interfaceMappingList[n].m_guidInterface);
            }
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceManager::HrProcessIpAddresses");
    return hr;
}

HRESULT CInterfaceManager::HrGetMappingList(InterfaceMappingList & interfaceMappingList)
{
    HRESULT hr = S_OK;

    interfaceMappingList.Swap(m_interfaceMappingList);

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceManager::HrGetMappingList");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\common\uhcommon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H C O M M O N . C P P
//
//  Contents:   Common UPnP Device Host code
//
//  Notes:
//
//  Author:     mbend   21 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncbase.h"
#include "uhcommon.h"

static PSID g_pNetworkSid;

HRESULT HrUDNStringToGUID(const wchar_t * szUUID, UUID & uuid)
{
    HRESULT hr = S_OK;
    // Size of uuid:UUID
    const long nUDNStringLength = 41;
    // Size of uuid: prefix
    const long nUDNPrefix = 5;

    if(nUDNStringLength != lstrlen(szUUID))
    {
        TraceTag(ttidError, "GUIDFromString: Invalid GUID string");
        hr = E_INVALIDARG;
    }
    if(SUCCEEDED(hr))
    {
        // Skip past "uuid:"
        RPC_STATUS status;
        status = UuidFromString((unsigned short *)(const_cast<wchar_t*>(&szUUID[nUDNPrefix])), &uuid);
        if(RPC_S_INVALID_STRING_UUID == status)
        {
            TraceTag(ttidError, "GUIDFromString: Invalid GUID string");
            hr = E_INVALIDARG;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrUDNStringToGUID");
    return hr;
}

HRESULT HrContentURLToGUID(const wchar_t * szURL, GUID & guid)
{
    HRESULT hr = S_OK;

    const wchar_t * sz = szURL;
    while (*sz && *sz != '=')
    {
        sz++;
    }

    if (*sz == '=')
    {
        sz++;
        hr = HrUDNStringToGUID(sz, guid);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrContentURLToGUID");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSysAllocString
//
//  Purpose:    Simple HR wrapper for HrSysAllocString
//
//  Arguments:
//      pszSource [in]  Source string (WCHAR)
//      pbstrDest [out] Output param -- pointer to BSTR
//
//  Returns:    S_OK on success, E_OUTOFMEMORY if the alloc failed.
//
//  Author:     jeffspr   16 Sep 1999
//
//  Notes:
//
HRESULT HrSysAllocString(LPCWSTR pszSource, BSTR *pbstrDest)
{
    HRESULT hr  = S_OK;

    Assert(pszSource);
    Assert(pbstrDest);

    *pbstrDest = SysAllocString(pszSource);
    if (!*pbstrDest)
    {
        TraceTag(ttidError, "HrSysAllocString failed on %S", pszSource);
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrSysAllocString");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrIsAllowedCOMCallLocality
//
//  Purpose:    Used to check whether the caller of a method on a COM interface
//              should be allowed to call that method, based on whether it's 
//              a call from the local machine or across the network
//
//  Arguments:
//      clAllowedCallLocality - bitmask of allowed COM call localities
//
//  Returns :
//       E_ACCESSDENIED if access is denied, S_OK if access is granted, error HRESULT otherwise.
//
//  Author:     AMallet   15 Mar 2002
//
HRESULT HrIsAllowedCOMCallLocality( IN CALL_LOCALITY clAllowedCallLocality )
{
    HRESULT     hr = S_OK; 
    CALL_LOCALITY clCurrentCallLocality;

    //
    // Retrieve the current call locality
    //
    if ( FAILED( hr = HrGetCurrentCallLocality( &clCurrentCallLocality ) ))
    {
        TraceHr(ttidRegistrar,FAL, hr, FALSE,"HrGetCurrentCallLocality");
    }
    else
    {
        //
        // If current call locality isn't one of the allowed ones, deny access
        //
        if ( ( clCurrentCallLocality & clAllowedCallLocality ) == 0 )
        {
            TraceTag(ttidRegistrar, "Caller locality %d, granted locality %d, access denied.",
                     clCurrentCallLocality, clAllowedCallLocality);
            hr = E_ACCESSDENIED;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetCurrentCallLocality
//
//  Purpose:    Checks locality (in-proc, on same machine, on different machine) of 
//              caller of a COM method 
//
//  Arguments:
//      pclCurrentCallLocality [out] - set to 
//
//  Author:     radus   7 Mar 2002
//
//  Notes:  Currently implemented by checking the existence of the NETWORK
//           SID in the impersonation token of the calling thread

HRESULT HrGetCurrentCallLocality( OUT CALL_LOCALITY *pclCurrentCallLocality )
{
    HRESULT hr = S_OK; 
    HANDLE      hToken = NULL;
    BOOL fImpersonated = FALSE;

    if ( !pclCurrentCallLocality || !g_pNetworkSid )
    {
        return E_INVALIDARG;
    }

    //
    // Impersonate client 
    //
    hr = CoImpersonateClient();

    if(SUCCEEDED(hr))
    {
        fImpersonated = TRUE;

        //
        // open impersonation token
        //
        if( OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hToken))
        {
            //
            // Check whether the token has the NETWORK SID in it; if it does, 
            // assume the caller is on a different machine. Else, the caller 
            // is on the local machine. 
            //
            // Note : This isn't entirely foolproof in that it's possible for a local
            // user's token to also have the NETWORK SID eg if they called LsaLogonUser
            // with the Network LogonType, but it's the best we can do for XP SP1. 
            // COM may have a way to get more accurate information for .NET Server. 
            //
            BOOL    fIsMember;
            
            if( CheckTokenMembership(
                hToken,
                g_pNetworkSid,
                &fIsMember))
            {
                if ( fIsMember )
                {
                    *pclCurrentCallLocality = CALL_LOCALITY_DIFFERENTMACHINE;
                }
                else
                {
                    *pclCurrentCallLocality = (CALL_LOCALITY) 
                        ( CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC );
                }
            }
            else
            {
                hr = HrFromLastWin32Error();
                
                TraceHr(ttidRegistrar, FAL, hr, FALSE, "CheckTokenMembership");
            }
        }
        else
        {
            hr = HrFromLastWin32Error();
            
            TraceHr(ttidRegistrar, FAL, hr, FALSE, "OpenThreadToken");
        }
    }
    else
    {
        //
        // If the COM call is a direct in-proc v-tbl call, with no proxy, the call to
        // CoImpersonateClient will return RPC_E_CALL_COMPLETE; in this case,
        // we know the caller is in-proc to us
        //
        if ( hr == RPC_E_CALL_COMPLETE )
        {
            *pclCurrentCallLocality = CALL_LOCALITY_INPROC;
            hr = S_OK;
        }
        else
        {
            TraceHr(ttidRegistrar,FAL, hr, FALSE, "CoImpersonateClient");
        }
    }

    if ( hToken )
    {
        CloseHandle( hToken );
    }

    if ( fImpersonated )
    {
        CoRevertToSelf();
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "HrCheckAccessRights");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateNetworkSID
//
//  Purpose:    Allocates and initializes a SID structure with the NETWORK SID
//
//  Arguments:
//              None 
//
//  Author:     AMallet   16 Mar 2002
//

HRESULT HrCreateNetworkSID()
{
    HRESULT hr = S_OK;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;       

    //
    // Allocate the NETWORK SID 
    //
    if( !AllocateAndInitializeSid(
        &id, 
        1,
        SECURITY_NETWORK_RID, 
        0,0,0,0,0,0,0,
        &g_pNetworkSid ) )                             // S-1-5-2
    {
        hr = HrFromLastWin32Error();
        TraceHr(ttidError, FAL, hr, FALSE, "AllocateAndInitializeSid");
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupNetworkSID
//
//  Purpose:    Cleans up the NETWORK SID allocated via call to HrCreateNetworkSID
//
//  Arguments:
//              None 
//
//  Author:     AMallet   16 Mar 2002
//
VOID CleanupNetworkSID()
{
    if ( g_pNetworkSid )
    {
        FreeSid( g_pNetworkSid );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\common\upnetwork\interfacetable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E T A B L E . C P P
//
//  Contents:   Builds a mapping from IP addresses to interface guids
//
//  Notes:
//
//  Author:     mbend   7 Feb 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "InterfaceTable.h"
#include <winsock2.h>
#include <iphlpapi.h>

CInterfaceTable::CInterfaceTable()
{
}

CInterfaceTable::~CInterfaceTable()
{
}

HRESULT CInterfaceTable::HrInitialize()
{
    HRESULT hr = S_OK;

    PIP_ADAPTER_INFO pip = NULL;
    ULONG ulSize = 0;
    GetAdaptersInfo(NULL, &ulSize);
    if(ulSize)
    {
        pip = reinterpret_cast<PIP_ADAPTER_INFO>(malloc(ulSize));

        DWORD dwRet = GetAdaptersInfo(pip, &ulSize);
        hr = HRESULT_FROM_WIN32(dwRet);
        if(SUCCEEDED(hr))
        {
            PIP_ADAPTER_INFO pipIter = pip;
            while(pipIter && SUCCEEDED(hr))
            {
                wchar_t szAdapter[MAX_ADAPTER_NAME_LENGTH + 4];
                wchar_t *   pchAdapter = szAdapter;
                wchar_t *   pchAdapterEnd = szAdapter;

                MultiByteToWideChar(CP_ACP, 0, pipIter->AdapterName, -1, szAdapter, MAX_ADAPTER_NAME_LENGTH + 4);

                // Make sure it's not an empty string first
                if (*pchAdapter)
                {
                    // skip over the '{'
                    pchAdapter++;

                    // chop off the '}'
                    pchAdapterEnd = wcschr(szAdapter, '\0');
                    if (pchAdapterEnd)
                    {
                        pchAdapterEnd--;
                        *pchAdapterEnd = 0;
                    }
                }

                GUID guidInterface;
                if (RPC_S_OK == UuidFromString(pchAdapter, &guidInterface))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
                PIP_ADDR_STRING pipaddr = &pipIter->IpAddressList;
                while(pipaddr && SUCCEEDED(hr))
                {
                    InterfaceMapping interfaceMapping;
                    interfaceMapping.m_guidInterface = guidInterface;
                    interfaceMapping.m_dwIpAddress = inet_addr(pipaddr->IpAddress.String);
                    interfaceMapping.m_dwIndex = htonl(pipIter->Index);
                    if(interfaceMapping.m_dwIpAddress)
                    {
                        hr = m_interfaceMappingList.HrPushBack(interfaceMapping);
                    }
                    pipaddr = pipaddr->Next;
                }
                pipIter = pipIter->Next;
            }
        }

        free(pip);
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceTable::HrInitialize");
    return hr;
}

HRESULT CInterfaceTable::HrMapIpAddressToGuid(DWORD dwIpAddress, GUID & guidInterface)
{
    HRESULT hr = S_OK;

    ZeroMemory(&guidInterface, sizeof(GUID));

    long nCount = m_interfaceMappingList.GetCount();
    for(long n = 0; n < nCount; ++n)
    {
        if(m_interfaceMappingList[n].m_dwIpAddress == dwIpAddress)
        {
            guidInterface = m_interfaceMappingList[n].m_guidInterface;
            break;
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceTable::HrMapIpAddressToGuid");
    return hr;
}

HRESULT CInterfaceTable::HrGetMappingList(InterfaceMappingList & interfaceMappingList)
{
    HRESULT hr = S_OK;

    interfaceMappingList.Swap(m_interfaceMappingList);

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceTable::HrGetMappingList");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\common\uhthread.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H T H R E A D . C P P 
//
//  Contents:   Threading support code
//
//  Notes:      
//
//  Author:     mbend   29 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "uhthread.h"
#include "ncbase.h"

CWorkItem::CWorkItem() : m_bDeleteOnComplete(FALSE)
{
}

CWorkItem::~CWorkItem()
{
}

HRESULT CWorkItem::HrStart(BOOL bDeleteOnComplete)
{
    HRESULT hr = S_OK;

    m_bDeleteOnComplete = bDeleteOnComplete;
    if(!QueueUserWorkItem(&CWorkItem::DwThreadProc, this, GetFlags()))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CWorkItem::HrStart(%x)", this);
    return hr;
}

ULONG CWorkItem::GetFlags()
{
    return WT_EXECUTEDEFAULT;
}

DWORD WINAPI CWorkItem::DwThreadProc(void * pvParam)
{
    CWorkItem * pWorkItem = reinterpret_cast<CWorkItem*>(pvParam);
    DWORD dwRet = pWorkItem->DwRun();
    if(pWorkItem->m_bDeleteOnComplete)
    {
        delete pWorkItem;
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\inc\hostinc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       H O S T I N C . H
//
//  Contents:   Common includes for upnp device host.
//
//  Notes:
//
//  Author:     jeffspr   15 Sep 1999
//
//----------------------------------------------------------------------------

#ifndef _HOSTINC_H
#define _HOSTINC_H
#pragma once

#include <upnpatl.h>    // upnp common ATL usage includes
#include <ncbase.h>     // SAFE_RELEASE
#include <ncdebug.h>    // our bug-detection utilities
#include <ncdefine.h>

#endif // _HOSTINC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\inc\uhcommon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H C O M M O N . H 
//
//  Contents:   Common UPnP Device Host code
//
//  Notes:      
//
//  Author:     mbend   21 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once

typedef enum 
{
    CALL_LOCALITY_INPROC              = 1,
    CALL_LOCALITY_LOCAL               = 2,
    CALL_LOCALITY_DIFFERENTMACHINE    = 4
} CALL_LOCALITY;

HRESULT HrUDNStringToGUID(const wchar_t * szUUID, UUID & uuid);
HRESULT HrContentURLToGUID(const wchar_t * szURL, GUID & guid);
HRESULT HrSysAllocString(LPCWSTR pszSource, BSTR *pbstrDest);
HRESULT HrCreateNetworkSID();
VOID    CleanupNetworkSID();
HRESULT HrGetCurrentCallLocality( OUT CALL_LOCALITY *pclCurrentCallLocality );
HRESULT HrIsAllowedCOMCallLocality( IN CALL_LOCALITY clAllowedCallLocality );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\inc\uhthread.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H T H R E A D . H 
//
//  Contents:   Threading support code
//
//  Notes:      
//
//  Author:     mbend   29 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once

class CWorkItem
{
public:
    CWorkItem();
    virtual ~CWorkItem();

    HRESULT HrStart(BOOL bDeleteOnComplete);
protected:
    virtual DWORD DwRun() = 0;
    virtual ULONG GetFlags();
private:
    CWorkItem(const CWorkItem &);
    CWorkItem & operator=(const CWorkItem &);

    BOOL m_bDeleteOnComplete;

    static DWORD WINAPI DwThreadProc(void * pvParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\inc\msftcont.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       M S F T C O N T . H 
//
//  Contents:   Microsoft UPnP Device Host Container Identifier
//
//  Notes:      
//
//  Author:     mbend   5 Oct 2000
//
//----------------------------------------------------------------------------

const wchar_t c_szUPnPDeviceHostContainer[] = L"{1ED3DA4A-6CFD-483d-B44E-E3ECDF280773}";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\common\uhxml.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H X M L . C P P
//
//  Contents:   Helper routines for the XML DOM
//
//  Notes:
//
//  Author:     mbend   8 Oct 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <msxml2.h>
#include "uhxml.h"
#include "uhcommon.h"
#include "upnphost.h"

HRESULT HrLoadDocument(BSTR bstrTemplate, IXMLDOMDocumentPtr & pDoc)
{
    HRESULT hr = S_OK;

    hr = pDoc.HrCreateInstanceInproc(CLSID_DOMDocument30);
    if(SUCCEEDED(hr))
    {
        VARIANT_BOOL vb;
        pDoc->put_resolveExternals(VARIANT_FALSE);
        hr = pDoc->loadXML(bstrTemplate, &vb);
        if(SUCCEEDED(hr) && !vb)
        {
            hr = UPNP_E_INVALID_XML;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrLoadDocument");
    return hr;
}

HRESULT HrLoadDocumentFromFile(BSTR bstrUrl, IXMLDOMDocumentPtr & pDoc)
{
    HRESULT hr = S_OK;

    hr = pDoc.HrCreateInstanceInproc(CLSID_DOMDocument30);
    if(SUCCEEDED(hr))
    {
        VARIANT_BOOL    vb;
        VARIANT         varPath;

        V_VT(&varPath) = VT_BSTR;
        V_BSTR(&varPath) = bstrUrl;

        hr = pDoc->load(varPath, &vb);
        if(SUCCEEDED(hr) && !vb)
        {
            // Map variant bool error indicator to general COM failure
            hr = E_FAIL;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrLoadDocumentFromFile");
    return hr;
}

HRESULT HrSelectNodes(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    IXMLDOMNodeListPtr & pNodeList)
{
    HRESULT hr = S_OK;

    // Do BSTR conversion
    BSTR bstr = NULL;
    hr = HrSysAllocString(szPattern, &bstr);
    if(SUCCEEDED(hr))
    {
        pNodeList.Release();
        hr = pNode->selectNodes(bstr, pNodeList.AddressOf());
        if(S_FALSE == hr)
        {
            hr = E_FAIL;
        }
        SysFreeString(bstr);
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrSelectNodes");
    return hr;
}

HRESULT HrSelectNode(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    IXMLDOMNodePtr & pNodeMatch)
{
    HRESULT hr = S_OK;

    // Do BSTR conversion
    BSTR bstr = NULL;
    hr = HrSysAllocString(szPattern, &bstr);
    if(SUCCEEDED(hr))
    {
        pNodeMatch.Release();
        hr = pNode->selectSingleNode(bstr, pNodeMatch.AddressOf());
        if(S_FALSE == hr)
        {
            hr = E_FAIL;
        }
        SysFreeString(bstr);
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrSelectNode");
    return hr;
}

HRESULT HrSelectNodeText(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    CUString & strText)
{
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pNodeMatch;
    hr = HrSelectNode(szPattern, pNode, pNodeMatch);
    if(SUCCEEDED(hr))
    {
        BSTR bstr = NULL;
        hr = pNodeMatch->get_text(&bstr);
        if(SUCCEEDED(hr))
        {
            hr = strText.HrAssign(bstr);
            SysFreeString(bstr);
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrSelectNodeText");
    return hr;
}

HRESULT HrSelectAndSetNodeText(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    const CUString & strText)
{
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pNodeMatch;
    hr = HrSelectNode(szPattern, pNode, pNodeMatch);
    if(SUCCEEDED(hr))
    {
        BSTR bstr = NULL;
        hr = strText.HrGetBSTR(&bstr);
        if(SUCCEEDED(hr))
        {
            hr = pNodeMatch->put_text(bstr);
            SysFreeString(bstr);
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrSelectAndSetNodeText");
    return hr;
}

HRESULT HrGetNodeText(
    IXMLDOMNodePtr & pNode,
    CUString & strText)
{
    HRESULT hr = S_OK;

    BSTR bstr = NULL;
    hr = pNode->get_text(&bstr);
    if(SUCCEEDED(hr))
    {
        hr = strText.HrAssign(bstr);
        SysFreeString(bstr);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetNodeText");
    return hr;
}

HRESULT HrSetNodeText(
    IXMLDOMNodePtr & pNode,
    const CUString & strText)
{
    HRESULT hr = S_OK;

    BSTR bstr = NULL;
    hr = strText.HrGetBSTR(&bstr);
    if(SUCCEEDED(hr))
    {
        hr = pNode->put_text(bstr);
        SysFreeString(bstr);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrSetNodeText");
    return hr;
}

HRESULT HrIsNodeEmpty(
    IXMLDOMNodePtr & pNode)
{
    HRESULT hr = S_OK;

    BSTR bstr = NULL;
    hr = pNode->get_text(&bstr);
    if(S_OK == hr)
    {
        if(SysStringLen(bstr))
        {
            hr = S_FALSE;
        }
        SysFreeString(bstr);
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT HrIsPresentOnceHelper(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    IXMLDOMNodePtr & pNodeInstance)
{
    HRESULT hr = S_OK;

    IXMLDOMNodeListPtr pNodeList;
    hr = HrSelectNodes(szPattern, pNode, pNodeList);
    if(SUCCEEDED(hr))
    {
        long nLength = 0;
        hr = pNodeList->get_length(&nLength);
        if(SUCCEEDED(hr))
        {
            if(1 == nLength)
            {
                hr = pNodeList->get_item(0, pNodeInstance.AddressOf());
            }
            else if (nLength > 1)
            {
                hr = UPNP_E_DUPLICATE_NOT_ALLOWED;
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

HRESULT HrIsNodeOfValidLength(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    LONG cchMax)
{
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pNodeMatch;
    hr = HrSelectNode(szPattern, pNode, pNodeMatch);
    if(SUCCEEDED(hr))
    {
        BSTR bstr = NULL;
        hr = pNodeMatch->get_text(&bstr);
        if(S_OK == hr)
        {
            if (SysStringLen(bstr) > (ULONG)cchMax)
            {
                hr = S_FALSE;
            }

            SysFreeString(bstr);
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrSelectNodeText");
    return hr;
}

HRESULT HrIsNodePresentOnce(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode)
{
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pNodeInstance;
    hr = HrIsPresentOnceHelper(szPattern, pNode, pNodeInstance);

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrIsPresentOnce(%S)", szPattern);
    return hr;
}

HRESULT HrIsNodePresentOnceAndEmpty(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode)
{
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pNodeInstance;
    hr = HrIsPresentOnceHelper(szPattern, pNode, pNodeInstance);
    if(S_OK == hr)
    {
        hr = HrIsNodeEmpty(pNodeInstance);
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrIsPresentOnceAndEmpty(%S)", szPattern);
    return hr;
}

HRESULT HrIsNodePresentOnceAndNotEmpty(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode)
{
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pNodeInstance;
    hr = HrIsPresentOnceHelper(szPattern, pNode, pNodeInstance);
    if(S_OK == hr)
    {
        hr = HrIsNodeEmpty(pNodeInstance);
        if(S_OK == hr)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE), "HrIsNodePresentOnceAndNotEmpty(%S)", szPattern);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\inc\uhxml.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H X M L . H
//
//  Contents:   Helper routines for the XML DOM
//
//  Notes:
//
//  Author:     mbend   8 Oct 2000
//
//----------------------------------------------------------------------------

#pragma once

#include <ComUtility.h>
#include "ustring.h"

// Typedefs
typedef SmartComPtr<IXMLDOMDocument> IXMLDOMDocumentPtr;
typedef SmartComPtr<IXMLDOMNode> IXMLDOMNodePtr;
typedef SmartComPtr<IXMLDOMElement> IXMLDOMElementPtr;
typedef SmartComPtr<IXMLDOMNodeList> IXMLDOMNodeListPtr;
typedef SmartComPtr<IXMLDOMNamedNodeMap> IXMLDOMNamedNodeMapPtr;
typedef SmartComPtr<IXMLDOMAttribute> IXMLDOMAttributePtr;

HRESULT HrLoadDocument(BSTR bstrTemplate, IXMLDOMDocumentPtr & pDoc);
HRESULT HrLoadDocumentFromFile(BSTR bstrUrl, IXMLDOMDocumentPtr & pDoc);
HRESULT HrSelectNodes(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    IXMLDOMNodeListPtr & pNodeList);
HRESULT HrSelectNode(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    IXMLDOMNodePtr & pNodeMatch);
HRESULT HrSelectNodeText(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    CUString & strText);
HRESULT HrSelectAndSetNodeText(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    const CUString & strText);
HRESULT HrGetNodeText(
    IXMLDOMNodePtr & pNode,
    CUString & strText);
HRESULT HrSetNodeText(
    IXMLDOMNodePtr & pNode,
    const CUString & strText);
HRESULT HrIsNodeEmpty(
    IXMLDOMNodePtr & pNode);
HRESULT HrIsNodePresentOnce(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode);
HRESULT HrIsNodeOfValidLength(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode,
    LONG cchMax);
HRESULT HrIsNodePresentOnceAndEmpty(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode);
HRESULT HrIsNodePresentOnceAndNotEmpty(
    const wchar_t * szPattern,
    IXMLDOMNodePtr & pNode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\inc\uhsync.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H S Y N C . H 
//
//  Contents:   Synchronization classes
//
//  Notes:      
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "ncbase.h"

//+---------------------------------------------------------------------------
//
//  Class:      CUCriticalSection
//
//  Purpose:    Wrapper for Win32 critical sections
//
//  Author:     mbend   17 Aug 2000
//
//  Notes:      
//    The most important and lightweight Windows NT synchronization primitive.
//    Allows only one thread to enter itself at a single time.
//    An important property of critical sections is that they are 
//    thread reentrant which means that if a thread owns a critical
//    section and tries to enter it again, the thread is allowed to 
//    do so. When exiting the lock, the lock is not freed until it is
//    exited once for each time that it was entered.
//
//    Critical sections are lightweight because they are not kernel
//    objects. Instead they are implemented through a simple in
//    memory structure CRITICAL_SECTION. If there is no thread
//    contention, they are implemented by simple memory operations
//    and spin locks that are hundreds of times faster than
//    alternative kernel object solutions such as mutexes. However,
//    if there is thread contention, critical sections degraded into
//    kernel objects.
//
class CUCriticalSection
{
public:
    CUCriticalSection() 
    {
        InitializeCriticalSection(&m_critsec);
    }
    ~CUCriticalSection() 
    {
        DeleteCriticalSection(&m_critsec);
    }
    void Enter()
    {
        EnterCriticalSection(&m_critsec);
    }
    BOOL FTryEnter()
    {
        return TryEnterCriticalSection(&m_critsec);
    }
    void Leave()
    {
        LeaveCriticalSection(&m_critsec);
    }
    DWORD DwSetSpinCount(DWORD dwSpinCount)
    {
        return SetCriticalSectionSpinCount(&m_critsec, dwSpinCount);
    }
private:
    CUCriticalSection(const CUCriticalSection &);
    CUCriticalSection & operator=(const CUCriticalSection &);
    CRITICAL_SECTION m_critsec;
};

//+---------------------------------------------------------------------------
//
//  Class:      CLock
//
//  Purpose:    Used to place an auto lock on a critical section
//
//  Author:     mbend   17 Aug 2000
//
//  Notes:      
//    Typically this class is used in an class object methods like so:
//
//     class SynchronizedExample {
//     public:
//        void LockedMethod() {
//            CLock lock(m_critSec);
//            ...
//        }
//     private:
//        CUCriticalSection m_critSec;
//     };
class CLock {
public:
    // Not attached
    CLock(CUCriticalSection & critsec) : m_critsec(critsec) 
    {   
        m_critsec.Enter();
    }
    ~CLock() 
    {
        m_critsec.Leave();
    }
private:
    CLock(const CLock &);
    CLock & operator=(const CLock &);
    CUCriticalSection & m_critsec;
};

#ifdef __ATLCOM_H__

//+---------------------------------------------------------------------------
//
//  Class:      CALock
//
//  Purpose:    Used to place an auto lock on a CComObjectRootEx<CComMultiThreadModel> derived class
//
//  Author:     mbend   17 Aug 2000
//
//  Notes:      
//    Typically this class is used in an class object methods like so:
//
//     class SynchronizedExample : public CComObjectRootEx<CComMultiThreadModel> {
//     public:
//        void LockedMethod() {
//            CALock lock(*this);
//            ...
//        }
//     };
class CALock {
public:
    // Not attached
    CALock(CComObjectRootEx<CComMultiThreadModel> & object) : m_object(object) 
    {   
        m_object.Lock();
    }
    ~CALock() 
    {
        m_object.Unlock();
    }
private:
    CALock(const CLock &);
    CALock & operator=(const CLock &);
    CComObjectRootEx<CComMultiThreadModel> & m_object;
};

#endif // __ATLCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\dispimpl2.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D I S P I M P L 2 . H 
//
//  Contents:   Implementation of IDispatch without dual interfaces
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

//  -IDelegatingDispImpl for implementing IDispatch by delegation
//   to another interface (typically a custom interface).
//
// These classes are useful because ATL's IDispatchImpl can
// only implement duals.
//
/////////////////////////////////////////////////////////////////////////////
//
// IDelegatingDispImpl: For implementing IDispatch in terms of another
// (typically custom) interface, e.g.:
//
// [oleautomation]
// interface IFoo : IUnknown
// {
//    ...
// }
//
// IDelegatingDispImpl implements all four IDispatch methods.
// IDelegatingDispImpl gets the IDispatch vtbl entries by deriving from
// IDispatch in addition to the implementation interface.
//
// Usage:
//  class CFoo : ..., public IDelegatingDispImpl<IFoo>
//
// In the case where the coclass is intended to represent a control,
// there is a need for the coclass to have a [default] dispinterface.
// Otherwise, some control containers (notably VB) throw arcane error when
// the control is loaded.  For a control that you intend to provide the
// custom interface and delegating dispatch mechanism, you will have to
// provide a dispinterface defined in terms of a custom interface like
// so:
//
// dispinterface DFoo
// {
//    interface IFoo;
// }
//
// coclass Foo
// {
//  [default] interface DFoo;
//  interface IFoo;
// };
//
// For every other situation, declaring a dispinterface in terms of a
// custom interface is not necessary to use IDelegatingDispatchImpl.
// However, if you'd like DFoo to be in the base class list (as needed
// for the caveat control), you may use DFoo as the base class instead
// of the default template argument IDispatch like so:
//
// Usage:
//  class CFoo : ..., public IDelegatingDispImpl<IFoo, &IID_IFoo, DFoo>
//

#pragma once
#ifndef INC_DISPIMPL2
#define INC_DISPIMPL2

/////////////////////////////////////////////////////////////////////////////
// IDelegatingDispImpl

template <class T, const IID* piid = &__uuidof(T), class D = IDispatch,
          const GUID* plibid = &CComModule::m_libid, WORD wMajor = 1,
          WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDelegatingDispImpl : public T, public D
{
public:
    typedef tihclass _tihclass;

    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {
        *pctinfo = 1;
        return S_OK;
    }

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {
        return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
    }

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
        LCID lcid, DISPID* rgdispid)
    {
        return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }
    
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
    {
        // NOTE: reinterpret_cast because CComTypeInfoHolder makes the mistaken
        //       assumption that the typeinfo can only Invoke using an IDispatch*.
        //       Since the implementation only passes the itf onto
        //       ITypeInfo::Invoke (which takes a void*), this is a safe cast
        //       until the ATL team fixes CComTypeInfoHolder.
        return _tih.Invoke(reinterpret_cast<IDispatch*>(static_cast<T*>(this)),
                           dispidMember, riid, lcid, wFlags, pdispparams,
                           pvarResult, pexcepinfo, puArgErr);
    }

protected:
    static _tihclass _tih;

    static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
    {
        return _tih.GetTI(lcid, ppInfo);
    }
};

template <class T, const IID* piid, class D, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IDelegatingDispImpl<T, piid, D, plibid, wMajor, wMinor, tihclass>::_tihclass
    IDelegatingDispImpl<T, piid, D, plibid, wMajor, wMinor, tihclass>::_tih =
    { piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0 };

#endif  // INC_DISPIMPL2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\inst\res.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E S . H 
//
//  Contents:   Resource include file for device test
//
//  Notes:      
//
//  Author:     mbend   19 Sep 2000
//
//----------------------------------------------------------------------------

#define IDX_DESC_DOC 100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\inst\main.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       M A I N . C P P 
//
//  Contents:   Simple test harness for device host
//
//  Notes:      
//
//  Author:     mbend   19 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "res.h"

#include "ComUtility.h"
#include "upnphost.h"
#include "sdev.h"
#include "sdev_i.c"

// COM Smart Pointers
typedef SmartComPtr<IUPnPRegistrar> IUPnPRegistrarPtr;
typedef SmartComPtr<IUPnPReregistrar> IUPnPReregistrarPtr;
typedef SmartComPtr<IUPnPDeviceControl> IUPnPDeviceControlPtr;

enum TestCase { tcRegister, tcRunning, tcUnregister, tcUnregisterRunning, tcReregister, tcReregisterRunning};

void Test(TestCase tc)
{
    HRESULT hr = S_OK;

    IUPnPRegistrarPtr pRegistrar;
    hr = pRegistrar.HrCreateInstanceServer(CLSID_UPnPRegistrar);
    if(SUCCEEDED(hr))
    {
        HRSRC hrsrc = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(IDX_DESC_DOC), L"XML");
        if(hrsrc)
        {
            HGLOBAL hGlobal = LoadResource(GetModuleHandle(NULL), hrsrc);
            if(hGlobal)
            {
                void * pvData = LockResource(hGlobal);
                BSTR bstrData = NULL;
                if(pvData)
                {
                    long nLength = SizeofResource(GetModuleHandle(NULL), hrsrc);
                    wchar_t * sz = new wchar_t[nLength + 1];
                    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, reinterpret_cast<char*>(pvData), nLength, sz, nLength);
                    sz[nLength] = 0;
                    bstrData = SysAllocString(sz);
                    delete [] sz;
                }
                if(bstrData)
                {
                    BSTR bstrId = NULL;
                    BSTR bstrProgId = SysAllocString(L"Sdev.SampleDevice.1");
                    BSTR bstrInitString = SysAllocString(L"Init");
                    BSTR bstrContainerId = SysAllocString(L"Sample Container");
                    BSTR bstrPath = SysAllocString(L"C:\\upnp\\");

                    switch(tc)
                    {
                    case tcRegister:
                        {
                            hr = pRegistrar->RegisterDevice(
                                bstrData,
                                bstrProgId,
                                bstrInitString,
                                bstrContainerId,
                                bstrPath,
                                100000,
                                &bstrId);
                        }
                        break;
                    case tcRunning:
                        {
                            IUPnPDeviceControlPtr pDevice;
                            hr = pDevice.HrCreateInstanceInproc(CLSID_UPnPSampleDevice);
                            if(SUCCEEDED(hr))
                            {
                                hr = pRegistrar->RegisterRunningDevice(
                                    bstrData,
                                    pDevice,
                                    bstrInitString,
                                    bstrPath,
                                    100000,
                                    &bstrId);
                            }
                        }
                        break;
                    case tcUnregister:
                        {
                            hr = pRegistrar->RegisterDevice(
                                bstrData,
                                bstrProgId,
                                bstrInitString,
                                bstrContainerId,
                                bstrPath,
                                100000,
                                &bstrId);
                            if(SUCCEEDED(hr))
                            {
                                hr = pRegistrar->UnregisterDevice(bstrId, TRUE);
                            }
                        }
                        break;
                    case tcUnregisterRunning:
                        {
                            IUPnPDeviceControlPtr pDevice;
                            hr = pDevice.HrCreateInstanceInproc(CLSID_UPnPSampleDevice);
                            if(SUCCEEDED(hr))
                            {
                                hr = pRegistrar->RegisterRunningDevice(
                                    bstrData,
                                    pDevice,
                                    bstrInitString,
                                    bstrPath,
                                    100000,
                                    &bstrId);
                                if(SUCCEEDED(hr))
                                {
                                    hr = pRegistrar->UnregisterDevice(bstrId, TRUE);
                                }
                            }
                        }
                        break;
                    case tcReregister:
                        {
                            hr = pRegistrar->RegisterDevice(
                                bstrData,
                                bstrProgId,
                                bstrInitString,
                                bstrContainerId,
                                bstrPath,
                                100000,
                                &bstrId);
                            if(SUCCEEDED(hr))
                            {
                                hr = pRegistrar->UnregisterDevice(bstrId, FALSE);
                                if(SUCCEEDED(hr))
                                {
                                    IUPnPReregistrarPtr pReregistrar;
                                    hr = pReregistrar.HrAttach(pRegistrar);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = pReregistrar->ReregisterDevice(
                                            bstrId,
                                            bstrData,
                                            bstrProgId,
                                            bstrInitString,
                                            bstrContainerId,
                                            bstrPath,
                                            100000);
                                    }
                                }
                            }
                        }
                        break;
                    case tcReregisterRunning:
                        {
                            IUPnPDeviceControlPtr pDevice;
                            hr = pDevice.HrCreateInstanceInproc(CLSID_UPnPSampleDevice);
                            if(SUCCEEDED(hr))
                            {
                                hr = pRegistrar->RegisterRunningDevice(
                                    bstrData,
                                    pDevice,
                                    bstrInitString,
                                    bstrPath,
                                    100000,
                                    &bstrId);
                                if(SUCCEEDED(hr))
                                {
                                    hr = pRegistrar->UnregisterDevice(bstrId, FALSE);
                                    if(SUCCEEDED(hr))
                                    {
                                        IUPnPReregistrarPtr pReregistrar;
                                        hr = pReregistrar.HrAttach(pRegistrar);
                                        if(SUCCEEDED(hr))
                                        {
                                            hr = pReregistrar->ReregisterRunningDevice(
                                                bstrId,
                                                bstrData,
                                                pDevice,
                                                bstrInitString,
                                                bstrPath,
                                                100000);
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    }

                    SysFreeString(bstrProgId);
                    SysFreeString(bstrInitString);
                    SysFreeString(bstrContainerId);
                    SysFreeString(bstrPath);
                    if(SUCCEEDED(hr))
                    {
                        SysFreeString(bstrId);
                    }
                    SysFreeString(bstrData);
                }
                FreeResource(hGlobal);
            }
        }
    }
}

extern "C" int __cdecl wmain(int argc, wchar_t * argv[])
{
    TestCase tc = tcRegister;
    if(2 == argc)
    {
        if(!lstrcmpi(L"register", argv[1]))
        {
            tc = tcRegister;
        }
        else if(!lstrcmpi(L"running", argv[1]))
        {
            tc = tcRunning;
        }
        else if(!lstrcmpi(L"unregister", argv[1]))
        {
            tc = tcUnregister;
        }
        else if(!lstrcmpi(L"unregisterrunning", argv[1]))
        {
            tc = tcUnregisterRunning;
        }
        else if(!lstrcmpi(L"reregister", argv[1]))
        {
            tc = tcReregister;
        }
        else if(!lstrcmpi(L"reregisterrunning", argv[1]))
        {
            tc = tcReregisterRunning;
        }
    }

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    CoInitializeSecurity(
        NULL,
        -1,
        NULL,
        NULL,
        RPC_C_AUTHN_LEVEL_NONE,
        RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL,
        0,
        NULL);
    Test(tc);
    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\inst\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       P C H . H 
//
//  Contents:   Precompiled header for tester
//
//  Notes:      
//
//  Author:     mbend   19 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D L L M A I N . C P P 
//
//  Contents:   Dll file for sample device
//
//  Notes:      
//
//  Author:     mbend   25 Sep 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop
#include "sdevres.h"

#include "sdevbase.h"
#include "sdev.h"
#include "sdev_i.c"
#include "SampleDevice.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPSampleDevice, CSampleDevice)
END_OBJECT_MAP()

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        InitializeDebugging();

        _Module.Init(ObjectMap, hInstance, &LIBID_UPnPDeviceHostSampleLib);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("sdev.dll", _Module.GetLockCount());

        _Module.Term();

        UnInitializeDebugging();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI
DllCanUnloadNow ()
{
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
// Returns a class factory to create an object of the requested type
//
STDAPI
DllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = _Module.RegisterServer(TRUE);

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "sdev!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
    _Module.UnregisterServer ();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\sampledevice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . C P P 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "sdevbase.h"
#include "SampleDevice.h"
#include "SampleService.h"
#include "uhsync.h"
#include "ComUtility.h"

CSampleDevice::CSampleDevice() : m_pSampleService(NULL)
{
    m_pSampleService->CreateInstance(&m_pSampleService);
    m_pSampleService->GetUnknown()->AddRef();
}

CSampleDevice::~CSampleDevice()
{
   ReleaseObj(m_pSampleService->GetUnknown());
}

STDMETHODIMP CSampleDevice::Initialize(
   /*[in]*/ BSTR     bstrXMLDesc,
   /*[in]*/ BSTR     bstrDeviceIdentifier,
   /*[in]*/ BSTR     bstrInitString)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleDevice::Initialize");
    HRESULT hr = S_OK;

    typedef SmartComPtr<IUPnPRegistrar> IUPnPRegistrarPtr;

    IUPnPRegistrarPtr pRegistrar;
    hr = pRegistrar.HrCreateInstanceServer(CLSID_UPnPRegistrar);
    if(SUCCEEDED(hr))
    {
        BSTR bstrUDN = NULL;
        BSTR bstrTemplateUDN = SysAllocString(L"DummyUDN");
        if(!bstrTemplateUDN)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            hr = pRegistrar->GetUniqueDeviceName(bstrDeviceIdentifier, bstrTemplateUDN, &bstrUDN);
            if(SUCCEEDED(hr))
            {
                SysFreeString(bstrUDN);
            }
            SysFreeString(bstrTemplateUDN);
        }
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleDevice::Initialize");
    return hr;
}

STDMETHODIMP CSampleDevice::GetServiceObject(
   /*[in]*/          BSTR     bstrUDN,
   /*[in]*/          BSTR     bstrServiceId,
   /*[out, retval]*/ IDispatch ** ppdispService)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleDevice::GetServiceObject");
    HRESULT hr = S_OK;

    *ppdispService = m_pSampleService;
    m_pSampleService->GetUnknown()->AddRef();

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleDevice::GetServiceObject");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\sampledevice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E D E V I C E . H 
//
//  Contents:   UPnP Device Host Sample Device
//
//  Notes:      
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "sdevres.h"       // main symbols
#include "sdev.h"
#include "upnphost.h"
#include "ComUtility.h"

// Forward declarations
class CSampleService;
typedef CComObject<CSampleService> CSampleServiceType;

/////////////////////////////////////////////////////////////////////////////
// CSampleDevice
class ATL_NO_VTABLE CSampleDevice : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSampleDevice, &CLSID_UPnPSampleDevice>,
    public IUPnPDeviceControl
{
public:
    CSampleDevice();
    ~CSampleDevice();

DECLARE_REGISTRY_RESOURCEID(IDR_SAMPLE_DEVICE)

BEGIN_COM_MAP(CSampleDevice)
    COM_INTERFACE_ENTRY(IUPnPDeviceControl)
END_COM_MAP()

public:

    // IUPnPDeviceControl methods
   STDMETHOD(Initialize)(
       /*[in]*/ BSTR     bstrXMLDesc,
       /*[in]*/ BSTR     bstrDeviceIdentifier,
       /*[in]*/ BSTR     bstrInitString);
   STDMETHOD(GetServiceObject)(
       /*[in]*/          BSTR     bstrUDN,
       /*[in]*/          BSTR     bstrServiceId,
       /*[out, retval]*/ IDispatch ** ppdispService);

private:
    CSampleServiceType * m_pSampleService;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\sampleservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E S E R V I C E . C P P
//
//  Contents:   UPnP Device Host Sample Service
//
//  Notes:
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "sdevbase.h"
#include "SampleService.h"
#include "uhsync.h"
#include "ComUtility.h"

CSampleService::CSampleService() : m_vbPower(VARIANT_FALSE), m_nLevel(0)
{
}

CSampleService::~CSampleService()
{
}

// IUPnPEventSource methods

STDMETHODIMP CSampleService::Advise(
    /*[in]*/ IUPnPEventSink * pesSubscriber)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::Advise");
    HRESULT hr = S_OK;

    m_pEventSink = pesSubscriber;

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::Advise");
    return hr;
}

STDMETHODIMP CSampleService::Unadvise(
    /*[in]*/ IUPnPEventSink * pesSubscriber)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::Unadvise");
    HRESULT hr = S_OK;

    if(S_OK == m_pEventSink.HrIsEqual(pesSubscriber))
    {
        m_pEventSink.Release();
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::Unadvise");
    return hr;
}

// IUPnPSampleService methods

STDMETHODIMP CSampleService::get_Power(/*[out, retval]*/ VARIANT_BOOL * pbPower)
{
    CHECK_POINTER(pbPower);
    TraceTag(ttidUPnPSampleDevice, "CSampleService::get_Power");
    HRESULT hr = S_OK;

    *pbPower = m_vbPower;

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::get_Power");
    return hr;
}

STDMETHODIMP CSampleService::put_Power(/*[in]*/ VARIANT_BOOL bPower)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::put_Power");
    HRESULT hr = S_OK;

    m_vbPower = bPower;
    if(m_pEventSink)
    {
        DISPID dispid = DISPID_POWER;
        hr = m_pEventSink->OnStateChanged(1, &dispid);
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::put_Power");
    return hr;
}

STDMETHODIMP CSampleService::get_Level(/*[out, retval]*/ long * pnLevel)
{
    CHECK_POINTER(pnLevel);
    TraceTag(ttidUPnPSampleDevice, "CSampleService::get_Level");
    HRESULT hr = S_OK;

    *pnLevel = m_nLevel;

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::get_Level");
    return hr;
}

STDMETHODIMP CSampleService::put_Level(/*[in]*/ long nLevel)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::put_Level");
    HRESULT hr = S_OK;

    m_nLevel = nLevel;
    if(m_pEventSink)
    {
        DISPID dispid = DISPID_LEVEL;
        hr = m_pEventSink->OnStateChanged(1, &dispid);
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::put_Level");
    return hr;
}

STDMETHODIMP CSampleService::PowerOn()
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::PowerOn");
    HRESULT hr = S_OK;

    m_vbPower = VARIANT_TRUE;
    m_nLevel = 10;

    if(m_pEventSink)
    {
        DISPID rgdispid[] = {DISPID_POWER, DISPID_LEVEL};

        hr = m_pEventSink->OnStateChanged(2, rgdispid);
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::PowerOn");
    return hr;
}

STDMETHODIMP CSampleService::PowerOff()
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::PowerOff");
    HRESULT hr = S_OK;

    m_vbPower = VARIANT_FALSE;
    m_nLevel = 0;

    if(m_pEventSink)
    {
        DISPID rgdispid[] = {DISPID_POWER, DISPID_LEVEL};

        hr = m_pEventSink->OnStateChanged(2, rgdispid);
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::PowerOff");
    return hr;
}

STDMETHODIMP CSampleService::SetLevel(/*[in]*/ long nLevel)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::SetLevel");
    HRESULT hr = S_OK;

    m_nLevel = nLevel;
    if(m_pEventSink)
    {
        DISPID dispid = DISPID_LEVEL;
        hr = m_pEventSink->OnStateChanged(1, &dispid);
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::SetLevel");
    return hr;
}

STDMETHODIMP CSampleService::IncreaseLevel()
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::IncreaseLevel");
    HRESULT hr = S_OK;

    if (m_vbPower == VARIANT_TRUE)
    {
        ++m_nLevel;
        if(m_pEventSink)
        {
            DISPID dispid = DISPID_LEVEL;
            hr = m_pEventSink->OnStateChanged(1, &dispid);
        }
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::IncreaseLevel");
    return hr;
}

STDMETHODIMP CSampleService::DecreaseLevel()
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::DecreaseLevel");
    HRESULT hr = S_OK;

    if(m_nLevel)
    {
        --m_nLevel;
    }
    if(m_pEventSink)
    {
        DISPID dispid = DISPID_LEVEL;
        hr = m_pEventSink->OnStateChanged(1, &dispid);
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::DecreaseLevel");
    return hr;
}

STDMETHODIMP CSampleService::Test(/*[in]*/ long nMultiplier, /*[in, out]*/ long * pnNewValue, /*[out, retval]*/ long * pnOldValue)
{
    TraceTag(ttidUPnPSampleDevice, "CSampleService::Test");
    HRESULT hr = S_OK;

    *pnOldValue = m_nLevel;
    m_nLevel = m_nLevel * nMultiplier;
    *pnNewValue = m_nLevel;

    if(m_pEventSink)
    {
        DISPID dispid = DISPID_LEVEL;
        hr = m_pEventSink->OnStateChanged(1, &dispid);
    }

    TraceHr(ttidUPnPSampleDevice, FAL, hr, FALSE, "CSampleService::Test");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\sdevbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S D E V B A S E . H 
//
//  Contents:   Base include file for sdev.dll. Global defines.
//
//  Notes:      
//
//  Author:     mbend   25 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "ncatl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\sdevres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S D E V R E S . H 
//
//  Contents:   Master resource header for sdev.dll
//
//  Notes:      
//
//  Author:     mbend   25 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
//#define IDS_INBOUND_CONFIG_CONNECTION_NAME  100


//+---------------------------------------------------------------------------
// Registry resources
//
#define IDR_SAMPLE_DEVICE   100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\sampleservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S A M P L E S E R V I C E . H
//
//  Contents:   UPnP Device Host Sample Service
//
//  Notes:
//
//  Author:     mbend   26 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "sdevres.h"       // main symbols
#include "sdev.h"
#include "upnphost.h"
#include "dispimpl2.h"
#include "ComUtility.h"

// Typedefs
typedef SmartComPtr<IUPnPEventSink> IUPnPEventSinkPtr;


/////////////////////////////////////////////////////////////////////////////
// CSampleService
class ATL_NO_VTABLE CSampleService :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDelegatingDispImpl<IUPnPSampleService>,
    public IUPnPEventSource
{
public:
    CSampleService();
    ~CSampleService();

BEGIN_COM_MAP(CSampleService)
    COM_INTERFACE_ENTRY(IUPnPSampleService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
END_COM_MAP()

public:

    // IUPnPEventSource methods
    STDMETHOD(Advise)(
        /*[in]*/ IUPnPEventSink * pesSubscriber);
    STDMETHOD(Unadvise)(
        /*[in]*/ IUPnPEventSink * pesSubscriber);

    // IUPnPSampleService methods
    STDMETHOD(get_Power)(/*[out, retval]*/ VARIANT_BOOL * pbPower);
    STDMETHOD(put_Power)(/*[in]*/ VARIANT_BOOL bPower);
    STDMETHOD(get_Level)(/*[out, retval]*/ long * pnLevel);
    STDMETHOD(put_Level)(/*[in]*/ long nLevel);
    STDMETHOD(PowerOn)();
    STDMETHOD(PowerOff)();
    STDMETHOD(SetLevel)(/*[in]*/ long nLevel);
    STDMETHOD(IncreaseLevel)();
    STDMETHOD(DecreaseLevel)();
    STDMETHOD(Test)(/*[in]*/ long nMultiplier, /*[in, out]*/ long * pnNewValue, /*[out, retval]*/ long * pnOldValue);
private:
    IUPnPEventSinkPtr m_pEventSink;
    VARIANT_BOOL m_vbPower;
    long m_nLevel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\sample\src\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Device Host Test Device"
#define VER_INTERNALNAME_STR            "sdev.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhdiag\udhdiag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T I M E R T S T . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     danielwe   30 Jun 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "stdio.h"
#include "hostp.h"
#include "hostp_i.c"

EXTERN_C
VOID
__cdecl
wmain (
      IN INT     argc,
      IN PCWSTR argv[])
{
    HRESULT                     hr;
    IUPnPEventingManagerDiag *  puemd;

    CoInitialize(NULL);

    hr = CoCreateInstance(CLSID_UPnPEventingManagerDiag, NULL, CLSCTX_LOCAL_SERVER,
                          IID_IUPnPEventingManagerDiag, (LPVOID *)&puemd);
    if (SUCCEEDED(hr))
    {
        DWORD               ces;
        UDH_EVTSRC_INFO *   rgesInfo;

        hr = puemd->GetEventSourceInfo(&ces, &rgesInfo);
        if (SUCCEEDED(hr))
        {
            printf("Got event source info...\n");

            DWORD                   ies;
            DWORD                   isub;
            UDH_SUBSCRIBER_INFO *   psub;

            for (ies = 0; ies < ces; ies++)
            {
                printf("Event source ID: %S\n", rgesInfo[ies].szEsid);
                printf("-----------------------------------\n");

                for (isub = 0; isub < rgesInfo[ies].cSubs; isub++)
                {
                    printf("Subscriber #%d:\n", isub);
                    printf("SID: %S\n", rgesInfo[ies].rgSubs[isub].szSid);
                    printf("URL: %S\n", rgesInfo[ies].rgSubs[isub].szDestUrl);
                    printf("TO : %d\n", rgesInfo[ies].rgSubs[isub].csecTimeout);
                    printf("SEQ: %d\n", rgesInfo[ies].rgSubs[isub].iSeq);
                    printf("-----------------------------\n");

                    CoTaskMemFree(rgesInfo[ies].rgSubs[isub].szSid);
                    CoTaskMemFree(rgesInfo[ies].rgSubs[isub].szDestUrl);
                }

                printf("##################################################\n");

                CoTaskMemFree(rgesInfo[ies].rgSubs);
                CoTaskMemFree(rgesInfo[ies].szEsid);
            }

            CoTaskMemFree(rgesInfo);
        }
        else
        {
            printf("Failed to GetEventSourceInfo(): %08X\n", hr);
        }

        puemd->Release();
    }
    else
    {
        printf("Failed to CoCreateInstance() the diagnostic class: %08X\n", hr);
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhdiag\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Device Host Diagnostic Tool"
#define VER_INTERNALNAME_STR            "udhdiag.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\ctrlrqst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C T R L R Q S T . H
//
//  Contents:   Header file for control request processing implementation
//              for the UPnP Device Host ISAPI Extension
//
//  Notes:
//
//  Author:     spather   2000/08/31
//
//----------------------------------------------------------------------------

#pragma once

#ifndef __CTRLRQST_H
#define __CTRLRQST_H


typedef struct tagUPNP_SOAP_REQUEST
{
    BSTR               bstrActionName;
    IXMLDOMNodeList    * pxdnlArgs;
} UPNP_SOAP_REQUEST;


typedef struct tagUPNP_SOAP_RESPONSE
{
    BOOL              fSucceeded;
    IXMLDOMDocument   * pxddRespEnvelope;
} UPNP_SOAP_RESPONSE;


DWORD WINAPI
DwHandleControlRequest(
    LPVOID lpParameter);

#endif //!__CTRLRQST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\descrqst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E S C R Q S T . H 
//
//  Contents:   Header file for description request processing implementation 
//              for the UPnP Device Host ISAPI Extension.
//
//  Notes:      
//
//  Author:     spather   2000/08/31
//
//----------------------------------------------------------------------------

#pragma once

#ifndef __DESCRQST_H
#define __DESCRQST_H

DWORD WINAPI 
DwHandleContentRequest(
    LPVOID lpParameter);

#endif //!__DESCRQST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\ctrlrqst.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C T R L R Q S T . C P P
//
//  Contents:   Implementation of control request processing for the
//              UPnP Device Host ISAPI Extension
//
//  Notes:
//
//  Author:     spather   2000/08/31
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <wininet.h>
#include <msxml2.h>

#include "ctrlrqst.h"
#include "udhiutil.h"


#include "hostp.h"
#include "ncbase.h"
#include "ncxml.h"

#include "ValidateSOAP.h"

const WCHAR WSZ_SOAP_NAMESPACE_URI[] =
    L"http://schemas.xmlsoap.org/soap/envelope/";
const WCHAR WSZ_UPNP_NAMESPACE_URI[] =
    L"urn:schemas-upnp-org:control-1-0";


//+---------------------------------------------------------------------------
//
//  Function:   CleanupSerializedRequest
//
//  Purpose:    Frees resources used by the fields of a UPNP_SOAP_REQUEST
//              structure
//
//  Arguments:
//      pusr [in] Address of the structure to cleanup
//
//  Returns:
//      (none)
//
//  Author:     spather   2000/09/24
//
//  Notes:
//    This function just frees the resources used by the fields within
//    the passed in structure. It does not free the memory used by the
//    structure itself.
//
VOID
CleanupSerializedRequest(
    IN UPNP_SOAP_REQUEST    * pusr)
{
    if (pusr->bstrActionName)
    {
        SysFreeString(pusr->bstrActionName);
        pusr->bstrActionName = NULL;
    }

    if (pusr->pxdnlArgs)
    {
        pusr->pxdnlArgs->Release();
        pusr->pxdnlArgs = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CleanupSerializedResponse
//
//  Purpose:    Frees resources used by the fields of a UPNP_SOAP_RESPONSE
//              structure
//
//  Arguments:
//      pusr [in] Address of the structure to cleanup
//
//  Returns:
//      (none)
//
//  Author:     spather   2000/09/24
//
//  Notes:
//    This function just frees the resources used by the fields within
//    the passed in structure. It does not free the memory used by the
//    structure itself.
//
VOID
CleanupSerializedResponse(
    IN UPNP_SOAP_RESPONSE    * pusr)
{
    if (pusr->pxddRespEnvelope)
    {
        pusr->pxddRespEnvelope->Release();
        pusr->pxddRespEnvelope = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CleanupDeserializedRequest
//
//  Purpose:    Frees resources used by the fields of a UPNP_CONTROL_REQUEST
//              structure
//
//  Arguments:
//      pucr [in] Address of the structure to cleanup
//
//  Returns:
//      (none)
//
//  Author:     spather   2000/09/24
//
//  Notes:
//    This function just frees the resources used by the fields within
//    the passed in structure. It does not free the memory used by the
//    structure itself.
//
VOID
CleanupDeserializedRequest(
    IN UPNP_CONTROL_REQUEST    * pucr)
{
    if (pucr->bstrActionName)
    {
        SysFreeString(pucr->bstrActionName);
        pucr->bstrActionName = NULL;
    }

    if (pucr->rgvarInputArgs)
    {
        for (DWORD i = 0; i < pucr->cInputArgs; i++)
        {
            VariantClear(&pucr->rgvarInputArgs[i]);
        }

        delete [] pucr->rgvarInputArgs;
        pucr->rgvarInputArgs = NULL;
        pucr->cInputArgs = 0;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CleanupResponseData
//
//  Purpose:    Frees resources of a UPNP_CONTROL_RESPONSE_DATA
//              structure
//
//  Arguments:
//      pucr       [in] Address of the structure to cleanup
//      fSucceeded [in] Whether the structure is valid for success
//
//  Returns:
//      (none)
//
//  Author:     spather   2000/09/24
//
//  Notes:
//    This function just frees the resources used by the fields within
//    the passed in structure. It does not free the memory used by the
//    structure itself.
//
VOID
CleanupResponseData(
    IN UPNP_CONTROL_RESPONSE_DATA * pucrd,
    IN BOOL fSucceeded)
{
    Assert(pucrd);

    if (fSucceeded)
    {
        if (pucrd->Success.rgvarOutputArgs)
        {
            for (DWORD i = 0; i < pucrd->Success.cOutputArgs; i++)
            {
                VariantClear(&pucrd->Success.rgvarOutputArgs[i]);
            }

            CoTaskMemFree(pucrd->Success.rgvarOutputArgs);
            pucrd->Success.rgvarOutputArgs = NULL;
            pucrd->Success.cOutputArgs = 0;
        }
    }
    else
    {
        if (pucrd->Fault.bstrFaultCode)
        {
            SysFreeString(pucrd->Fault.bstrFaultCode);
            pucrd->Fault.bstrFaultCode = NULL;
        }

        if (pucrd->Fault.bstrFaultString)
        {
            SysFreeString(pucrd->Fault.bstrFaultString);
            pucrd->Fault.bstrFaultString = NULL;
        }

        if (pucrd->Fault.bstrUPnPErrorCode)
        {
            SysFreeString(pucrd->Fault.bstrUPnPErrorCode);
            pucrd->Fault.bstrUPnPErrorCode = NULL;
        }

        if (pucrd->Fault.bstrUPnPErrorString)
        {
            SysFreeString(pucrd->Fault.bstrUPnPErrorString);
            pucrd->Fault.bstrUPnPErrorString = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupDeserializedResponse
//
//  Purpose:    Frees resources used by the fields of a UPNP_CONTROL_RESPONSE
//              structure
//
//  Arguments:
//      pucr [in] Address of the structure to cleanup
//
//  Returns:
//      (none)
//
//  Author:     spather   2000/09/24
//
//  Notes:
//    This function just frees the resources used by the fields within
//    the passed in structure. It does not free the memory used by the
//    structure itself.
//
VOID
CleanupDeserializedResponse(
    IN UPNP_CONTROL_RESPONSE    * pucresp)
{
    if (pucresp->bstrActionName)
    {
        SysFreeString(pucresp->bstrActionName);
        pucresp->bstrActionName = NULL;
    }
    CleanupResponseData(&pucresp->ucrData, pucresp->fSucceeded);
}


//+---------------------------------------------------------------------------
//
//  Function:   HrValidateControlMethod
//
//  Purpose:    Validates that the HTTP verb used is valid for this
//              type of request.
//
//  Arguments:
//      pszaMethod [in] The HTTP verb
//
//  Returns:
//    If the method is valid, the return value is S_OK. If the method is
//    not valid, the function returns one of the COM error codes defined
//    in WinError.h.
//
//  Author:     spather   2000/09/21
//
//  Notes:
//

HRESULT
HrValidateControlMethod(
    IN LPSTR pszaMethod)
{
    HRESULT hr = S_OK;

    AssertSz(pszaMethod,
             "HrValidateControlMethod(): NULL Method passed");

    if ((0 != lstrcmpiA(pszaMethod, "POST")) &&
        (0 != lstrcmpiA(pszaMethod, "M-POST")))
    {
        if (0 == lstrcmpiA(pszaMethod, "GET") ||
            0 == lstrcmpiA(pszaMethod, "HEAD"))
        {
            hr = UPNP_E_METHOD_NOT_ALLOWED;
        }
        else
        {
            hr = UPNP_E_METHOD_NOT_IMPLEMENTED;
        }
    }

    TraceError("HrValidateControlMethod(): Exiting",
               hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrWriteResponse
//
//  Purpose:    Writes a control response back to the client
//
//  Arguments:
//      pecb             [in]  The extension control block for the request
//      pxdnRespEnvelope [in]  The XML DOM node representing the response
//                             envelope
//      fSucceeded       [in]  Indicates whether or not this is a success
//                             response
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/25
//
//  Notes:
//
HRESULT
HrWriteResponse(
    IN LPEXTENSION_CONTROL_BLOCK   pecb,
    IN IXMLDOMDocument             * pxddRespEnvelope,
    IN BOOL                        fSucceeded)
{
    HRESULT hr = S_OK;
    BSTR    bstrRespEnvelope = NULL;
    DWORD   cchRespEnvelope = 0;
    LPSTR   pszaRespEnvelope = NULL;
    DWORD   cchHeaders = 0;
    CHAR    szaHeaders[256];
    LPCSTR  pcszaHeadersFmt =
        "Content-Length: %d\r\n"
        "Content-Type: text/xml; charset=\"utf-8\"\r\n"
        "EXT:\r\n\r\n";

    // Convert response envelope to UTF-8 string.

    hr = pxddRespEnvelope->get_xml(&bstrRespEnvelope);

    if (SUCCEEDED(hr))
    {
        pszaRespEnvelope = Utf8FromWsz(bstrRespEnvelope);

        if (pszaRespEnvelope)
        {
            cchRespEnvelope = lstrlenA(pszaRespEnvelope);

            TraceTag(ttidUDHISAPI,
                     "HrWriteResponse(): "
                     "Sending response:\n"
                     "%s",
                     pszaRespEnvelope);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrWriteResponse(): "
                       "Failed to convert response envelope to ANSI",
                       hr);

        }

        SysFreeString(bstrRespEnvelope);
    }
    else
    {
        TraceError("HrWriteResponse(): "
                   "Failed to get envelope XML text",
                   hr);
    }

    wsprintfA(szaHeaders, pcszaHeadersFmt, cchRespEnvelope);
    cchHeaders = lstrlenA(szaHeaders);

    if (fSucceeded)
    {
        // Success response, so HTTP status is 200 OK
        if (bSendResponseToClient(pecb,
                                  "200 OK",
                                  cchHeaders,
                                  szaHeaders,
                                  cchRespEnvelope,
                                  pszaRespEnvelope))
        {
            pecb->dwHttpStatusCode = HTTP_STATUS_OK;
            TraceTag(ttidUDHISAPI,
                     "HrWriteResponse(): "
                     "Successfully sent success response");
        }
        else
        {
            hr = HrFromLastWin32Error();
            TraceLastWin32Error("HrWriteResponse(): "
                                "Failed to send success response to client");
        }

    }
    else
    {
        // Failure response, so HTTP status is 500 Internal Server Error
        if (bSendResponseToClient(pecb,
                                  "500 Internal Server Error",
                                  cchHeaders,
                                  szaHeaders,
                                  cchRespEnvelope,
                                  pszaRespEnvelope))
        {
            pecb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
            TraceTag(ttidUDHISAPI,
                     "HrWriteResponse(): "
                     "Successfully sent error response");
        }
        else
        {
            hr = HrFromLastWin32Error();
            TraceLastWin32Error("HrWriteResponse(): "
                                "Failed to send error response to client");
        }

    }


    if (pszaRespEnvelope)
    {
        delete [] pszaRespEnvelope;
        pszaRespEnvelope = NULL;
        cchRespEnvelope = 0;
    }

    TraceError("HrWriteResponse(): "
               "Exiting",
               hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAppendFaultElementToBody
//
//  Purpose:    Appends a SOAP fault element to a body element. The fault
//              element contains a SOAP fault code, fault string, and possibly
//              a detail element containing a UPnP error code and error string.
//
//  Arguments:
//      pxdd                [in] Document object to use to create elements
//      pxdnBody            [in] The body element
//      pucrespDeserialized [in] The deserialized response info
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/26
//
//  Notes:
//
HRESULT
HrAppendFaultElementToBody(
    IN IXMLDOMDocument         * pxdd,
    IN IXMLDOMNode             * pxdnBody,
    IN UPNP_CONTROL_RESPONSE   * pucrespDeserialized)
{
    HRESULT                    hr = S_OK;
    IXMLDOMNode                * pxdnFault = NULL;
    IXMLDOMElement             * pxdeFaultCode = NULL;
    IXMLDOMElement             * pxdeFaultString = NULL;
    IXMLDOMNode                * pxdnDetail = NULL;
    UPNP_CONTROL_RESPONSE_DATA * pucrd = NULL;

    pucrd = &pucrespDeserialized->ucrData;
    // Create the fault element.

    hr = HrCreateElement(pxdd,
                         L"SOAP-ENV:Fault",
                         WSZ_SOAP_NAMESPACE_URI,
                         &pxdnFault);

    if (SUCCEEDED(hr))
    {
        Assert(pxdnFault);

        // Create the Fault element's children.

        hr = HrCreateElementWithTextValue(pxdd,
                                          L"faultcode",
                                          pucrd->Fault.bstrFaultCode,
                                          &pxdeFaultCode);

        if (SUCCEEDED(hr))
        {
            Assert(pxdeFaultCode);

            hr = HrCreateElementWithTextValue(pxdd,
                                              L"faultstring",
                                              pucrd->Fault.bstrFaultString,
                                              &pxdeFaultString);
            if (SUCCEEDED(hr))
            {
                Assert(pxdeFaultString);

                hr = HrCreateElement(pxdd,
                                     L"detail",
                                     NULL,
                                     &pxdnDetail);

                if (SUCCEEDED(hr))
                {
                    IXMLDOMNode * pxdnUPnPError = NULL;

                    hr = HrCreateElement(pxdd,
                                         L"UPnPError",
                                         WSZ_UPNP_NAMESPACE_URI,
                                         &pxdnUPnPError);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMElement * pxdeErrorCode = NULL;

                        Assert(pxdnUPnPError);

                        // Add children to UPnPError.
                        hr = HrCreateElementWithTextValue(pxdd,
                                                          L"errorCode",
                                                          pucrd->Fault.bstrUPnPErrorCode,
                                                          &pxdeErrorCode);

                        if (SUCCEEDED(hr))
                        {
                            Assert(pxdeErrorCode);

                            hr = pxdnUPnPError->appendChild(pxdeErrorCode,
                                                            NULL);

                            if (SUCCEEDED(hr))
                            {
                                IXMLDOMElement * pxdeErrorDesc = NULL;

                                hr = HrCreateElementWithTextValue(pxdd,
                                                                  L"errorDescription",
                                                                  pucrd->Fault.bstrUPnPErrorString,
                                                                  &pxdeErrorDesc);
                                if (SUCCEEDED(hr))
                                {
                                    Assert(pxdeErrorDesc);

                                    hr = pxdnUPnPError->appendChild(pxdeErrorDesc,
                                                                    NULL);

                                    if (SUCCEEDED(hr))
                                    {
                                        TraceTag(ttidUDHISAPI,
                                                 "HrAppendFaultElementToBody(): "
                                                 "Successfully appended errorCode "
                                                 "and errorDescription elements");
                                    }
                                    else
                                    {
                                        TraceError("HrAppendFaultElementToBody(): "
                                                   "Failed to append errorCode element",
                                                   hr);
                                    }

                                    pxdeErrorDesc->Release();
                                }
                                else
                                {
                                    TraceError("HrAppendFaultElementToBody(): "
                                               "Failed to create errorDescription element",
                                               hr);
                                }
                            }
                            else
                            {
                                TraceError("HrAppendFaultElementToBody(): "
                                           "Failed to append errorCode element",
                                           hr);
                            }
                            pxdeErrorCode->Release();
                        }
                        else
                        {
                            TraceError("HrAppendFaultElementToBody(): "
                                       "Failed to create errorCode element",
                                       hr);
                        }



                        // If successful, attach UPnPError to detail.

                        if (SUCCEEDED(hr))
                        {
                            hr = pxdnDetail->appendChild(pxdnUPnPError,
                                                         NULL);
                            if (SUCCEEDED(hr))
                            {
                                TraceTag(ttidUDHISAPI,
                                         "HrAppendFaultElementToBody(): "
                                         "Successfully appended UPnPError "
                                         "element");
                            }
                            else
                            {
                                TraceError("HrAppendFaultElementToBody(): "
                                           "Failed to append UPnPError",
                                           hr);
                            }
                        }


                        pxdnUPnPError->Release();
                    }
                    else
                    {
                        TraceError("HrAppendFaultElementToBody(): "
                                   "Failed to create UPnPError element",
                                   hr);
                    }
                }
                else
                {
                    TraceError("HrAppendFaultElementToBody(): "
                               "Failed to create detail element",
                               hr);
                }
            }
            else
            {
                TraceError("HrAppendFaultElementToBody(): "
                           "Failed to create fault string element",
                           hr);
            }
        }
        else
        {
            TraceError("HrAppendFaultElementToBody(): "
                       "Failed to create fault code element",
                       hr);
        }

        // Attach the Fault element's children.

        if (SUCCEEDED(hr))
        {
            Assert(pxdeFaultCode);
            Assert(pxdeFaultString);
            Assert(pxdnDetail);

            hr = pxdnFault->appendChild(pxdeFaultCode, NULL);

            if (SUCCEEDED(hr))
            {
                TraceTag(ttidUDHISAPI,
                         "HrAppendFaultElementToBody(): "
                         "Successfully appended fault code element");

                hr = pxdnFault->appendChild(pxdeFaultString, NULL);

                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidUDHISAPI,
                             "HrAppendFaultElementToBody(): "
                             "Successfully appended fault string element");

                    hr = pxdnFault->appendChild(pxdnDetail, NULL);

                    if (SUCCEEDED(hr))
                    {
                        TraceTag(ttidUDHISAPI,
                                 "HrAppendFaultElementToBody(): "
                                 "Successfully appended detail element");
                    }
                    else
                    {
                        TraceError("HrAppendFaultElementToBody(): "
                                   "Failed to append detail element",
                                   hr);
                    }

                }
                else
                {
                    TraceError("HrAppendFaultElementToBody(): "
                               "Failed to append fault string element",
                               hr);
                }


            }
            else
            {
                TraceError("HrAppendFaultElementToBody(): "
                           "Failed to append fault code element",
                           hr);
            }
        }

        // If everything succeeded, then append the fault element to the body.
        if (SUCCEEDED(hr))
        {
            hr = pxdnBody->appendChild(pxdnFault,
                                       NULL);
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidUDHISAPI,
                         "HrAppendFaultElementToBody(): "
                         "Successfully appended fault element to body");
            }
            else
            {
                TraceError("HrAppendFaultElementToBody(): "
                           "Failed to append fault element to body",
                           hr);
            }
        }

        // Clean up.
        if (pxdeFaultCode)
        {
            pxdeFaultCode->Release();
            pxdeFaultCode = NULL;
        }

        if (pxdeFaultString)
        {
            pxdeFaultString->Release();
            pxdeFaultString = NULL;
        }

        if (pxdnDetail)
        {
            pxdnDetail->Release();
            pxdnDetail = NULL;
        }

        pxdnFault->Release();
    }
    else
    {
        TraceError("HrAppendFaultElementToBody(): "
                   "Failed to create fault element",
                   hr);
    }

    TraceError("HrAppendFaultElementToBody(): "
               "Exiting",
               hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAppendActionResponseElementToBody
//
//  Purpose:    Appends an action response XML element to a body element.
//              The action response element contains the action name and
//              the output arguments.
//
//  Arguments:
//      pxdd                [in] Document object to use to create elements
//      pxdnBody            [in] The body element
//      pucrDeserialized    [in] Address of the deserialized request structure
//                               (needed only for the QueryStateVariable case,
//                                to get the variable name)
//      pucrespDeserialized [in] The deserialized response info
//      pServiceDescInfo    [in] Service Description Info object for the
//                               service
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/26
//
//  Notes:
//
HRESULT
HrAppendActionResponseElementToBody(
    IN IUPnPAutomationProxy    * pAutomationProxy,
    IN IXMLDOMDocument         * pxdd,
    IN IXMLDOMNode             * pxdnBody,
    IN UPNP_CONTROL_REQUEST    * pucrDeserialized,
    IN UPNP_CONTROL_RESPONSE   * pucrespDeserialized,
    IN IUPnPServiceDescriptionInfo * pServiceDescInfo)
{
    HRESULT hr = S_OK;
    DWORD   cchSuffix = 0;
    DWORD   cchPrefix = 0;
    LPCWSTR pcszSuffix = L"Response";
    LPCWSTR pcszPrefix = L"m:";
    DWORD   cchElementName = 0;
    LPWSTR  pszElementName = NULL;
    BOOL    bIsQsv = FALSE;

    cchSuffix = lstrlenW(pcszSuffix);
    cchPrefix = lstrlenW(pcszPrefix);

    cchElementName = SysStringLen(pucrespDeserialized->bstrActionName) +
        cchSuffix + cchPrefix;

    pszElementName = new WCHAR[cchElementName+1];

    bIsQsv = (0 == lstrcmpW(pucrespDeserialized->bstrActionName, L"QueryStateVariable"));

    if (pszElementName)
    {
        IXMLDOMNode * pxdnActionResponse = NULL;

        wsprintfW(pszElementName,
                  L"%s%s%s",
                  pcszPrefix,
                  pucrespDeserialized->bstrActionName,
                  pcszSuffix);

        LPWSTR pszServiceType;

        hr = pAutomationProxy->GetServiceType(&pszServiceType);

        if (SUCCEEDED(hr))
        {
            if (bIsQsv)
            {
                hr = HrCreateElement(pxdd,
                                     pszElementName,
                                     WSZ_UPNP_NAMESPACE_URI,
                                     &pxdnActionResponse);
            }
            else
            {
                hr = HrCreateElement(pxdd,
                                     pszElementName,
                                     pszServiceType,
                                     &pxdnActionResponse);
            }

            CoTaskMemFree(pszServiceType);

            if (SUCCEEDED(hr))
            {
                UPNP_CONTROL_RESPONSE_DATA * pucrd = NULL;

                pucrd = &pucrespDeserialized->ucrData;
                if (pucrd->Success.cOutputArgs)
                {
                    DWORD cOutputArgs = 0;
                    BSTR  * rgbstrNames = NULL;
                    BSTR  * rgbstrTypes = NULL;

                    if (bIsQsv)
                    {
                        // Special case for QueryStateVariable.
                        // We know there is one "output argument" called
                        // "return" and its data type is the type of the
                        // variable being queried.

                        cOutputArgs = 1;
                        rgbstrNames = (BSTR *) CoTaskMemAlloc(sizeof(BSTR));
                        rgbstrTypes = (BSTR *) CoTaskMemAlloc(sizeof(BSTR));

                        if (rgbstrNames && rgbstrTypes)
                        {
                            rgbstrNames[0] = SysAllocString(L"return");

                            if (rgbstrNames[0])
                            {
                                rgbstrTypes[0] = NULL;
                                hr = pServiceDescInfo->GetVariableType(
                                    V_BSTR(&pucrDeserialized->rgvarInputArgs[0]),
                                    &rgbstrTypes[0]);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }

                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidUDHISAPI,
                                     "HrAppendActionResponseElementToBody(): "
                                     "Successfully obtained out arg name and data "
                                     "type for QueryStateVariable");
                        }
                        else
                        {
                            TraceError("HrAppendActionResponseElementToBody(): "
                                       "Failed to obtain out arg name and data "
                                       "type for QueryStateVariable",
                                       hr);

                            if (rgbstrNames)
                            {
                                if (rgbstrNames[0])
                                {
                                    SysFreeString(rgbstrNames[0]);
                                    rgbstrNames[0] = NULL;
                                }
                                CoTaskMemFree(rgbstrNames);
                                rgbstrNames = NULL;
                            }

                            if (rgbstrTypes)
                            {
                                if (rgbstrTypes[0])
                                {
                                    SysFreeString(rgbstrTypes[0]);
                                    rgbstrTypes[0] = NULL;
                                }
                                CoTaskMemFree(rgbstrTypes);
                                rgbstrTypes = NULL;
                            }
                        }
                    }
                    else
                    {
                        hr = pServiceDescInfo->GetOutputArgumentNamesAndTypes(
                            pucrespDeserialized->bstrActionName,
                            &cOutputArgs,
                            &rgbstrNames,
                            &rgbstrTypes);

                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidUDHISAPI,
                                     "HrAppendActionResponseElementToBody(): "
                                     "Successfully obtained out arg name and data "
                                     "type for action %S",
                                     pucrespDeserialized->bstrActionName);
                        }
                        else
                        {
                            TraceError("HrAppendActionResponseElementToBody(): "
                                       "Failed to obtain out arg name and data "
                                       "for action",
                                       hr);
                        }

                    }

                    if (SUCCEEDED(hr))
                    {
                        Assert(cOutputArgs == pucrd->Success.cOutputArgs);
                        Assert(rgbstrNames);
                        Assert(rgbstrTypes);

                        for (DWORD i = 0;
                             SUCCEEDED(hr) && (i < cOutputArgs);
                             i++)
                        {
                            IXMLDOMElement * pxdeArg = NULL;
                            WCHAR * pwszArgName;

                            pwszArgName = new WCHAR[lstrlenW(rgbstrNames[i]) + 1];
                            if (NULL == pwszArgName)
                            {
                                hr = E_OUTOFMEMORY;
                            }

                            if (SUCCEEDED(hr))
                            {
                                lstrcpyW(pwszArgName, rgbstrNames[i]);

                                hr = HrCreateElementWithType(pxdd,
                                                             pwszArgName,
                                                             rgbstrTypes[i],
                                                             pucrd->Success.rgvarOutputArgs[i],
                                                             &pxdeArg);

                                delete [] pwszArgName;
                            }

                            if (SUCCEEDED(hr))
                            {
                                hr = pxdnActionResponse->appendChild(pxdeArg,
                                                                     NULL);

                                if (SUCCEEDED(hr))
                                {
                                    TraceTag(ttidUDHISAPI,
                                             "HrAppendActionResponseElementToBody(): "
                                             "Successfully appended element for "
                                             "argument %S",
                                             rgbstrNames[i]);
                                }
                                else
                                {
                                    TraceError("HrAppendActionResponseElementToBody(): "
                                               "Failed to append argument element",
                                               hr);
                                }

                                pxdeArg->Release();
                            }
                            else if (E_FAIL == hr)
                            {
                                // something inside MSXML failed trying to put the value
                                // most likely, this is caused by an un-coercible type
                                TraceError("HrAppendActionResponseElementToBody(): "
                                           "Probably failed to coerce argument element",
                                           hr);
                                hr = UPNP_E_DEVICE_ERROR;
                            }
                            else
                            {
                                TraceError("HrAppendActionResponseElementToBody(): "
                                           "Failed to get create argument element",
                                           hr);
                            }
                        }

                        // Clean up.
                        for (DWORD i = 0; i < cOutputArgs; i++)
                        {
                            SysFreeString(rgbstrNames[i]);
                            rgbstrNames[i] = NULL;
                            SysFreeString(rgbstrTypes[i]);
                            rgbstrTypes[i] = NULL;
                        }
                        CoTaskMemFree(rgbstrNames);
                        rgbstrNames = NULL;
                        CoTaskMemFree(rgbstrTypes);
                        rgbstrTypes = NULL;
                    }
                }

                // If everything went ok, append action response element to
                // body.

                if (SUCCEEDED(hr))
                {
                    hr = pxdnBody->appendChild(pxdnActionResponse, NULL);

                    if (SUCCEEDED(hr))
                    {
                        TraceTag(ttidUDHISAPI,
                                 "HrAppendActionResponseElementToBody(): "
                                 "Successfully appended %S element to body",
                                 pszElementName);
                    }
                    else
                    {
                        TraceError("HrAppendActionResponseElementToBody(): "
                                   "Failed to append action response element",
                                   hr);
                    }
                }

                pxdnActionResponse->Release();
            }
            else
            {
                TraceError("HrAppendActionResponseElementToBody(): "
                           "Failed to create action response element",
                           hr);
            }
        }
        else
        {
            TraceError("HrAppendActionResponseElementToBody(): "
                       "Failed to get service type", hr);
        }

        delete [] pszElementName;
        pszElementName = NULL;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrAppendActionResponseElementToBody(): "
                   "Failed to allocate memory for action "
                   "response element name",
                   hr);
    }


    TraceError("HrAppendActionResponseElementToBody(): "
               "Exiting",
               hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSerializeResponse
//
//  Purpose:    Serializes response information.
//
//  Arguments:
//      pucrDeserialized    [in] Address of the deserialized request structure
//                               (needed only for the QueryStateVariable case,
//                                to get the variable name)
//      pucrespDeserialized [in] Address of structure containing deserialized
//                               response info
//      pServiceDescInfo    [in] Service Description Info object for the
//                               service
//      pusrespSerialized   [in] Address of structure whose fields will be
//                               initialized with serialized response info
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/25
//
//  Notes:
//
HRESULT
HrSerializeResponse(
    IN IUPnPAutomationProxy        * pAutomationProxy,
    IN UPNP_CONTROL_REQUEST        * pucrDeserialized,
    IN UPNP_CONTROL_RESPONSE       * pucrespDeserialized,
    IN IUPnPServiceDescriptionInfo * pServiceDescInfo,
    IN UPNP_SOAP_RESPONSE          * pusrespSerialized)
{
    HRESULT            hr = S_OK;
    IXMLDOMDocument    * pxddResponse = NULL;
    IXMLDOMNode        * pxdnRespEnvelope = NULL;

    // Create an XML DOM Document in which we'll build the XML response.

    hr = CoCreateInstance(CLSID_DOMDocument30,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IXMLDOMDocument,
                          (void **) &pxddResponse);

    if (SUCCEEDED(hr))
    {
        Assert(pxddResponse);

        hr = HrAppendProcessingInstruction(pxddResponse, L"xml", L"version=\"1.0\"");

        // Create the envelope element.

        if (SUCCEEDED(hr))
        {
            hr = HrCreateElement(pxddResponse,
                                 L"SOAP-ENV:Envelope",
                                 WSZ_SOAP_NAMESPACE_URI,
                                 &pxdnRespEnvelope);
        }

        if (SUCCEEDED(hr))
        {
            Assert(pxdnRespEnvelope);

            IXMLDOMElement    * pxdeRespEnvelope = NULL;

            hr = pxdnRespEnvelope->QueryInterface(IID_IXMLDOMElement, (void**)&pxdeRespEnvelope);

            if (SUCCEEDED(hr))
            {
                hr = HrSetTextAttribute(pxdeRespEnvelope, L"SOAP-ENV:encodingStyle",
                                        L"http://schemas.xmlsoap.org/soap/encoding/");
                pxdeRespEnvelope->Release();
                pxdeRespEnvelope = NULL;
            }

            if (SUCCEEDED(hr))
            {
                IXMLDOMNode    * pxdnBody = NULL;

                hr = HrCreateElement(pxddResponse,
                                     L"SOAP-ENV:Body",
                                     WSZ_SOAP_NAMESPACE_URI,
                                     &pxdnBody);

                if (SUCCEEDED(hr))
                {
                    Assert(pxdnBody);

                    if (pucrespDeserialized->fSucceeded)
                    {
                        hr = HrAppendActionResponseElementToBody(pAutomationProxy,
                                                                 pxddResponse,
                                                                 pxdnBody,
                                                                 pucrDeserialized,
                                                                 pucrespDeserialized,
                                                                 pServiceDescInfo);
                        if (UPNP_E_DEVICE_ERROR == hr)
                        {
                            // Failed at the last minute
                            // Change our minds and send a fault response
                            CleanupResponseData(&pucrespDeserialized->ucrData, TRUE);

                            pucrespDeserialized->fSucceeded = FALSE;
                            pucrespDeserialized->ucrData.Fault.bstrFaultCode =
                                SysAllocString(L"SOAP-ENV:Client");
                            pucrespDeserialized->ucrData.Fault.bstrFaultString =
                                SysAllocString(L"UPnPError");
                            pucrespDeserialized->ucrData.Fault.bstrUPnPErrorCode =
                                SysAllocString(L"501");
                            pucrespDeserialized->ucrData.Fault.bstrUPnPErrorString =
                                SysAllocString(L"Internal Device Error");

                            if (NULL == pucrespDeserialized->ucrData.Fault.bstrFaultCode ||
                                NULL == pucrespDeserialized->ucrData.Fault.bstrFaultString ||
                                NULL == pucrespDeserialized->ucrData.Fault.bstrUPnPErrorCode ||
                                NULL == pucrespDeserialized->ucrData.Fault.bstrUPnPErrorString)
                            {
                                hr = E_OUTOFMEMORY;
                                CleanupResponseData(&pucrespDeserialized->ucrData, FALSE);
                            }
                            else
                            {
                                hr = S_OK;
                            }
                        }
                    }
                    if (SUCCEEDED(hr) && FALSE == pucrespDeserialized->fSucceeded)
                    {
                        hr = HrAppendFaultElementToBody(pxddResponse,
                                                        pxdnBody,
                                                        pucrespDeserialized);
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = pxdnRespEnvelope->appendChild(pxdnBody,
                                                           NULL);
                    }
                    pxdnBody->Release();
                }
                else
                {
                    TraceError("HrSerializeResponse(): "
                               "Failed to create body element",
                               hr);
                }

            }
            else
            {
                // we weren't able to create the encodingStyle attribute
            }

            if (SUCCEEDED(hr))
            {
                hr = pxddResponse->appendChild(pxdnRespEnvelope, NULL);
            }

            if (pxdnRespEnvelope)
            {
                pxdnRespEnvelope->Release();
            }
        }
        else
        {
            TraceError("HrSerializeResponse(): "
                       "Failed to create envelope element",
                       hr);
        }

    }

    if (SUCCEEDED(hr))
    {
        Assert(pxddResponse);

        // Cleanup any old data.
        CleanupSerializedResponse(pusrespSerialized);
        pusrespSerialized->fSucceeded = pucrespDeserialized->fSucceeded;
        pusrespSerialized->pxddRespEnvelope = pxddResponse;
    }
    else
    {
        if (pxddResponse)
        {
            pxddResponse->Release();
            pxddResponse = NULL;
        }
    }

    TraceError("HrSerializeResponse(): "
               "Exiting",
               hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrExecuteRequest
//
//  Purpose:    Executes a request.
//
//  Arguments:
//      pAutomationProxy [in] The automation proxy for the target service
//      pucreq           [in] Address of the structure containing the
//                            deserialized request
//      pucresp          [in] Address of the structure whose fields will be
//                            initialized with the serialized response info
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/24
//
//  Notes:
//
HRESULT
HrExecuteRequest(
    IN IUPnPAutomationProxy    * pAutomationProxy,
    IN UPNP_CONTROL_REQUEST    * pucreq,
    IN UPNP_CONTROL_RESPONSE   * pucresp)
{
    HRESULT hr = S_OK;

    hr = pAutomationProxy->ExecuteRequest(pucreq, pucresp);

    if (SUCCEEDED(hr))
    {
        TraceTag(ttidUDHISAPI,
                 "HrExecuteRequest(): "
                 "IUPnPAutomationProxy::Execute() succeeded");
    }
    else
    {
        TraceError("HrExecuteRequest(): "
                   "Failed to execute request",
                   hr);
    }

    TraceError("HrExecuteRequest(): "
               "Exiting",
               hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDeserializeSOAPRequest
//
//  Purpose:    Deserializes a parsed SOAP Request
//
//  Arguments:
//      pusrParsed       [in] Address of structure containing parsed request
//      pServiceDescInfo [in] Service Description Info object for the service
//      pucrDeserialized [in] Address of structure whose fields will be
//                            initialized with the deserialized request info
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/24
//
//  Notes:
//
HRESULT
HrDeserializeSOAPRequest(
    IN UPNP_SOAP_REQUEST           * pusrParsed,
    IN IUPnPServiceDescriptionInfo * pServiceDescInfo,
    IN UPNP_CONTROL_REQUEST        * pucrDeserialized)
{
    HRESULT                hr = S_OK;
    UPNP_CONTROL_REQUEST   ucr;
    BOOL                   fIsQueryStateVariable = FALSE;

    ZeroMemory(&ucr, sizeof(UPNP_CONTROL_REQUEST));

    // First, copy the action name.

    ucr.bstrActionName = SysAllocString(pusrParsed->bstrActionName);

    if (ucr.bstrActionName)
    {
        if (0 == lstrcmpW(ucr.bstrActionName, L"QueryStateVariable"))
        {
            fIsQueryStateVariable = TRUE;
        }

        // Next, deserialize the arguments, if any.
        if (pusrParsed->pxdnlArgs)
        {
            LONG listLength = 0;

            hr = pusrParsed->pxdnlArgs->get_length(&listLength);

            if (SUCCEEDED(hr))
            {
                if (listLength)
                {
                    // Allocate array of VARIANT arguments.
                    ucr.cInputArgs = (DWORD) listLength;

                    ucr.rgvarInputArgs = new VARIANT[ucr.cInputArgs];

                    if (ucr.rgvarInputArgs)
                    {
                        DWORD  cInArgs = 0;
                        BSTR   * rgbstrNames = NULL;
                        BSTR   * rgbstrTypes = NULL;

                        ZeroMemory(ucr.rgvarInputArgs,
                                   ucr.cInputArgs * sizeof(VARIANT));

                        if (FALSE == fIsQueryStateVariable)
                        {
                            // Only get the argument names and types if this is
                            // not a QSV request. For a QSV request, there is
                            // only one argument (the variable name) and it's
                            // type is "string".

                            hr = pServiceDescInfo->GetInputArgumentNamesAndTypes(ucr.bstrActionName,
                                                                                 &cInArgs,
                                                                                 &rgbstrNames,
                                                                                 &rgbstrTypes);

                            if (SUCCEEDED(hr))
                            {
                                Assert(cInArgs == ucr.cInputArgs);
                                Assert(rgbstrNames);
                                Assert(rgbstrTypes);
                            }
                        }

                        if (SUCCEEDED(hr))
                        {
                            // For each argument node, get the value and put it into
                            // the variant array.

                            for (LONG i = 0; SUCCEEDED(hr) && (i < listLength); i++)
                            {
                                IXMLDOMNode    * pxdnItem = NULL;

                                hr = pusrParsed->pxdnlArgs->get_item(i, &pxdnItem);

                                if (SUCCEEDED(hr))
                                {
                                    if (fIsQueryStateVariable)
                                    {
                                        BSTR   * pbstr = &(V_BSTR(&ucr.rgvarInputArgs[i]));

                                        hr = pxdnItem->get_text(pbstr);

                                        if (SUCCEEDED(hr))
                                        {
                                            Assert(*pbstr);
                                            ucr.rgvarInputArgs[i].vt = VT_BSTR;
                                            TraceTag(ttidUDHISAPI,
                                                     "HrDeserializeSOAPRequest(): "
                                                     "Got variable name for QSV request: %S",
                                                     *pbstr);
                                        }
                                        else
                                        {
                                            TraceError("HrDeserializeSOAPRequest(): "
                                                       "Failed to get variable name for QSV request",
                                                       hr);
                                        }
                                    }
                                    else
                                    {
                                        hr = HrGetTypedValueFromElement(pxdnItem,
                                                                        rgbstrTypes[i],
                                                                        &ucr.rgvarInputArgs[i]);

                                        if (SUCCEEDED(hr))
                                        {
                                            TraceTag(ttidUDHISAPI,
                                                     "HrDeserializeSOAPRequest(): "
                                                     "Deserialized argument %S",
                                                     rgbstrNames[i]);
                                        }
                                        else
                                        {
                                            TraceError("HrDeserializeSOAPRequest(): "
                                                       "Failed to get node value",
                                                       hr);
                                        }
                                    }

                                    pxdnItem->Release();
                                }
                                else
                                {
                                    TraceError("HrDeserializeSOAPRequest(): "
                                               "Failed to get item from list",
                                               hr);
                                }
                            }

                            if (FALSE == fIsQueryStateVariable)
                            {
                                // Only got this stuff if it was not a QSV
                                // request, so only clean it up in this case.
                                for (DWORD i = 0; i < cInArgs; i++)
                                {
                                    SysFreeString(rgbstrNames[i]);
                                    rgbstrNames[i] = NULL;
                                    SysFreeString(rgbstrTypes[i]);
                                    rgbstrTypes[i] = NULL;
                                }
                                CoTaskMemFree(rgbstrNames);
                                rgbstrNames = NULL;
                                CoTaskMemFree(rgbstrTypes);
                                rgbstrTypes = NULL;
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrDeserializeSOAPRequest(): "
                                   "Failed to allocate array of variant arguments",
                                   hr);
                    }
                }
                else
                {
                    ucr.cInputArgs = 0;
                    ucr.rgvarInputArgs = NULL;
                }
            }
            else
            {
                TraceError("HrDeserializeSOAPRequest(): "
                           "Failed to get argument list length",
                           hr);
            }
        }
        else
        {
            ucr.cInputArgs = 0;
            ucr.rgvarInputArgs = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrDeserializeSOAPRequest(): "
                   "Failed to allocate memory to copy action name",
                   hr);
    }

    if (SUCCEEDED(hr))
    {
        Assert(ucr.bstrActionName);
        Assert(FImplies((ucr.cInputArgs > 0), ucr.rgvarInputArgs));
        Assert(FImplies((0 == ucr.cInputArgs), (NULL == ucr.rgvarInputArgs)));

        // Clean up any existing data in the output structure.
        CleanupDeserializedRequest(pucrDeserialized);

        pucrDeserialized->bstrActionName = ucr.bstrActionName;
        pucrDeserialized->cInputArgs = ucr.cInputArgs;
        pucrDeserialized->rgvarInputArgs = ucr.rgvarInputArgs;
    }
    else
    {
        // Clean up.
        CleanupDeserializedRequest(&ucr);
    }

    TraceError("HrDeserializeSOAPRequest(): "
               "Exiting",
               hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrParseSOAPRequest
//
//  Purpose:    Parses a SOAP request and returns the parsed action name
//              and list of arguments.
//
//  Arguments:
//      pxdnReqEnvelope [in] XML DOM node representing the SOAP envelope
//      pusrParsed      [in] Address of a UPNP_SOAP_REQUEST structure whose
//                           fields will be initialized with the parsed info
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/24
//
//  Notes:
//
HRESULT
HrParseSOAPRequest(
    IN IXMLDOMNode         * pxdnReqEnvelope,
    IN UPNP_SOAP_REQUEST   * pusrParsed)
{
    HRESULT            hr = S_OK;
    IXMLDOMNode        * pxdnBody = NULL;
    LPWSTR             rgpszBodyTokens[] = {L"Body"};
    BSTR               bstrActionName = NULL;
    IXMLDOMNodeList    * pxdnlArgs = NULL;

    hr = HrGetNestedChildElement(pxdnReqEnvelope,
                                 rgpszBodyTokens,
                                 1,
                                 &pxdnBody);

    if (S_OK == hr)
    {
        IXMLDOMNode * pxdnAction = NULL;

        Assert(pxdnBody);

        hr = pxdnBody->get_firstChild(&pxdnAction);

        if (S_OK == hr)
        {
            Assert(pxdnAction);

            hr = pxdnAction->get_baseName(&bstrActionName);

            if (SUCCEEDED(hr))
            {
                Assert(bstrActionName);

                hr = pxdnAction->get_childNodes(&pxdnlArgs);

                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidUDHISAPI,
                             "HrParseSOAPRequest(): "
                             "Successfully obtained name and argument list "
                             "for action %S\n",
                             bstrActionName);
                }
                else
                {
                    TraceError("HrParseSOAPRequest(): "
                               "Failed to get argument list",
                               hr);
                }
            }
            else
            {
                TraceError("HrParseSOAPRequest(): "
                           "Failed to get action name",
                           hr);
            }
            pxdnAction->Release();
        }
        else
        {
            TraceError("HrParseSOAPRequest(): "
                       "Failed to get action element",
                       hr);
            if (S_FALSE == hr)
            {
                hr = E_FAIL;
            }
        }


        pxdnBody->Release();
    }
    else
    {
        TraceError("HrParseSOAPRequest(): "
                   "Failed to get Body element",
                   hr);
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        // Clean up any existing data in the output strucutre.
        CleanupSerializedRequest(pusrParsed);

        pusrParsed->bstrActionName = bstrActionName;
        pusrParsed->pxdnlArgs = pxdnlArgs;
    }
    else
    {
        // Cleanup
        if (bstrActionName)
        {
            SysFreeString(bstrActionName);
            bstrActionName = NULL;
        }

        if (pxdnlArgs)
        {
            pxdnlArgs->Release();
            pxdnlArgs = NULL;
        }

        // any error other than E_OUTOFMEMORY implies bad SOAP
        if (hr != E_OUTOFMEMORY)
        {
            hr = UPNP_E_BAD_REQUEST;
        }
    }

    TraceError("HrParseSOAPRequest(): "
               "Exiting",
               hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrValidateControlRequest
//
//  Purpose:    Validates the structure and content of a control request
//
//  Arguments:
//      pecb            [in] The extension control block for the request
//      pxdnReqEnvelope [in] The request envelope
//      pServiceDescInfo[in] The service description info object for the
//                           service
//
//  Returns:
//   If the function succeeds, the return value is S_OK. Otherwise, the
//   function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/25
//
//  Notes:
//
HRESULT HrValidateControlRequest(
    IN LPEXTENSION_CONTROL_BLOCK   pecb,
    IN IXMLDOMNode                 * pxdnReqEnvelope,
    IN IUPnPServiceDescriptionInfo * pServiceDescInfo)
{
    HRESULT hr = S_OK;

    hr = HrValidateSOAPRequest(pxdnReqEnvelope,
                               pecb,
                               pServiceDescInfo);

    TraceError("HrValidateRequest(): "
               "Exiting",
               hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrReadRequest
//
//  Purpose:    Reads the HTTP packet body of a control request, loads
//              it into an XML DOM document, validates it for correctness,
//              and, if valid, returns a pointer to the XML DOM node
//              representing the request envelope.
//
//  Arguments:
//      pecb             [in]    The extension control block for the request.
//      ppxdnReqEnvelope [out]   Receives a pointer to the XML DOM node
//                               representing the request envelope.
//
//  Returns:
//   If the function succeeds, the return value is S_OK. Otherwise, the
//   function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/24
//
//  Notes:
//
HRESULT
HrReadRequest(
    IN     LPEXTENSION_CONTROL_BLOCK   pecb,
    OUT    IXMLDOMNode                 ** ppxdnReqEnvelope)
{
    HRESULT hr = S_OK;
    DWORD   cbReqBody = 0;
    LPSTR   pszaReqBody = NULL;
    BSTR    bstrReqBody = NULL;

    // Get the request body. If it's not all here, read it in.

    if (pecb->cbAvailable < pecb->cbTotalBytes)
    {
        // There is some data that is not available in the extension
        // control block. Read it from the client.

        cbReqBody = pecb->cbTotalBytes;

        pszaReqBody = new CHAR[cbReqBody];

        if (pszaReqBody)
        {
            DWORD cbBytesToRead = cbReqBody;
            DWORD cbBytesRead = 0;
            LPSTR pszaTemp = pszaReqBody;

            while (cbBytesRead < cbReqBody)
            {
                if (pecb->ReadClient(pecb->ConnID,
                                     pszaTemp,
                                     &cbBytesToRead))
                {
                    // After calling ReadClient, cbBytesToRead contains the
                    // number of bytes actually read.

                    cbBytesRead += cbBytesToRead;
                    pszaTemp += cbBytesToRead;

                    cbBytesToRead = cbReqBody - cbBytesRead;
                }
                else
                {
                    TraceLastWin32Error("HrReadRequest(): "
                                        "ReadClient() failed");

                    hr = HrFromLastWin32Error();
                    break;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrReadRequest(): "
                       "Could not allocate memory for request body",
                       hr);
        }
    }
    else
    {
        cbReqBody = pecb->cbAvailable;
        pszaReqBody = (LPSTR) pecb->lpbData;

        if (0 == cbReqBody)
        {
            // There is no body in the request.
            hr = UPNP_E_MISSING_CONTENT_LENGTH;
            TraceError("HrReadRequest(): "
                       "Request had no body",
                       hr);
        }
    }

    // Turn the request body into a BSTR.

    if (SUCCEEDED(hr))
    {
        INT    result = 0;
        INT    cchWide = 0;

        Assert(pszaReqBody);

        // Have to convert the request body into a BSTR to load it into
        // an XML DOM document.

        result = MultiByteToWideChar(CP_UTF8,
                                     0,
                                     pszaReqBody,
                                     cbReqBody,
                                     NULL,
                                     0);

        if (result)
        {
            LPWSTR pszBody = NULL;

            cchWide = result;

            pszBody = new WCHAR[cchWide+1]; // want NULL termination

            if (pszBody)
            {
                result = MultiByteToWideChar(CP_UTF8,
                                             0,
                                             pszaReqBody,
                                             cbReqBody,
                                             pszBody,
                                             cchWide);

                if (result)
                {
                    pszBody[cchWide] = UNICODE_NULL;

                    bstrReqBody = SysAllocString(pszBody);

                    if (bstrReqBody)
                    {
                        TraceTag(ttidUDHISAPI,
                                 "HrReadRequest(): "
                                 "Request Body is \n%S",
                                 bstrReqBody);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrReadRequest(): "
                                   "Failed to allocate BSTR request body",
                                   hr);
                    }
                }
                else
                {
                    TraceLastWin32Error("HrReadRequest(): "
                                        "MultiByteToWideChar #2 failed");
                    hr = HrFromLastWin32Error();
                }

                delete [] pszBody;
                pszBody = NULL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrReadRequest(): "
                           "Failed to allocate memory for wide char body",
                           hr);
            }
        }
        else
        {
            TraceLastWin32Error("HrReadRequest(): "
                                "MultiByteToWideChar #1 failed");
            hr = HrFromLastWin32Error();
        }

    }

    // Create an XML DOM document from the request body.

    if (SUCCEEDED(hr))
    {
        IXMLDOMDocument    * pxddRequest = NULL;

        hr = CoCreateInstance(CLSID_DOMDocument30,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IXMLDOMDocument,
                              (void **) &pxddRequest);

        if (SUCCEEDED(hr))
        {
            Assert(pxddRequest);

            hr = pxddRequest->put_async(VARIANT_FALSE);

            if (SUCCEEDED(hr))
            {
                VARIANT_BOOL   vbSuccess = VARIANT_FALSE;

                hr = HrValidateContentType(pecb);

                if (SUCCEEDED(hr))
                {
                    pxddRequest->put_resolveExternals(VARIANT_FALSE);
                    hr = pxddRequest->loadXML(bstrReqBody, &vbSuccess);
                }

                if (SUCCEEDED(hr) && (VARIANT_TRUE == vbSuccess))
                {
                    IXMLDOMElement * pxdeEnvelope = NULL;

                    hr = pxddRequest->get_documentElement(&pxdeEnvelope);

                    if (S_OK == hr)
                    {
                        Assert(pxdeEnvelope);

                        hr = pxdeEnvelope->QueryInterface(IID_IXMLDOMNode,
                                                          (void **)
                                                            ppxdnReqEnvelope);

                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidUDHISAPI,
                                     "HrReadRequest(): "
                                     "Successfully obtained XML DOM Node for "
                                     "request envelope");
                        }
                        else
                        {
                            TraceError("HrReadRequest(): "
                                       "Failed to QI for IXMLDOMNode",
                                       hr);
                        }

                        pxdeEnvelope->Release();
                    }
                    else
                    {
                        TraceError("HrReadRequest(): "
                                   "Failed to get document element",
                                   hr);
                    }
                }
                else
                {
                    if (S_FALSE == hr)
                    {
                        // There was a parse error.
                        Assert(VARIANT_FALSE == vbSuccess);
                        hr = UPNP_E_BAD_REQUEST;
                    }
                    TraceError("HrReadRequest(): "
                               "Failed to load XML",
                               hr);
                }
            }
            else
            {
                TraceError("HrReadRequest(): "
                           "Failed to set async property on DOM document",
                           hr);
            }

            pxddRequest->Release();
        }
        else
        {
            TraceError("HrReadRequest(): "
                       "Failed to create XML DOM document",
                       hr);
        }


    }

    // Cleanup

    if (bstrReqBody)
    {
        SysFreeString(bstrReqBody);
        bstrReqBody = NULL;
    }

    if (pszaReqBody && (pszaReqBody != (LPSTR)pecb->lpbData))
    {
        delete [] pszaReqBody;
        pszaReqBody = NULL;
        cbReqBody = 0;
    }

    TraceError("HrReadRequest(): "
               "Exiting",
               hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrParseControlQueryString
//
//  Purpose:    Parses the query string to a control request and uses
//              the registrar to obtain the Automation Proxy object for
//              the service specified in it.
//
//  Arguments:
//      pszaQueryString   [in]  The query string.
//      ppAutomationProxy [out] Receives a pointer to the Automation Proxy
//                              object for the service
//
//  Returns:
//   If the function succeeds, the return value is S_OK. Otherwise, the
//   function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/25
//
//  Notes:
//
HRESULT HrParseControlQueryString(
    IN     LPSTR                   pszaQueryString,
    OUT    IUPnPAutomationProxy    ** ppAutomationProxy)
{
    HRESULT hr = S_OK;
    DWORD   cchQueryString = 0;
    DWORD   cchPrefix = 0;
    LPCSTR  pcszaPrefix = "control=";
    LPWSTR  pszUDN = NULL;
    LPWSTR  pszServiceID = NULL;

    // Control query string is of the form:
    //   control=UDN+ServiceID.
    // We know that at least the word "control" is there because
    // that main dispatch code that called us already checked for it.

    cchPrefix = lstrlenA(pcszaPrefix);
    cchQueryString = lstrlenA(pszaQueryString);

    if (cchQueryString > cchPrefix)
    {
        LPSTR   pszaUDNStart = NULL;
        LPSTR   pszaDelimiter = NULL;

        pszaUDNStart = pszaQueryString+cchPrefix;

        for (DWORD i = cchPrefix; i < cchQueryString; i++)
        {
            if ('+' == pszaQueryString[i])
            {
                pszaDelimiter = &pszaQueryString[i];
                break;
            }
        }

        if (pszaDelimiter)
        {
            DWORD cchUDN = (DWORD) (pszaDelimiter - pszaUDNStart);
            LPSTR pszaUDN = NULL;

            pszaUDN = new CHAR[cchUDN+1];

            if (pszaUDN)
            {
                LPSTR pszaServiceID = NULL;

                lstrcpynA(pszaUDN, pszaUDNStart, cchUDN+1);

                pszaServiceID = pszaDelimiter+1;

                if (*pszaServiceID)
                {
                    pszUDN = WszFromSz(pszaUDN);

                    if (pszUDN)
                    {
                        pszServiceID = WszFromSz(pszaServiceID);

                        if (pszServiceID)
                        {
                            TraceTag(ttidUDHISAPI,
                                     "HrParseControlRequest(): "
                                     "UDN == %S and ServiceID == %S",
                                     pszUDN,
                                     pszServiceID);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            TraceError("HrParseControlQueryString(): "
                                       "Failed to convert Service ID to "
                                       "unicode string",
                                       hr);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrParseControlQueryString(): "
                                   "Failed to convert UDN to unicode string",
                                   hr);
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                    TraceError("HrParseControlQueryString(): "
                               "No service ID found",
                               hr);
                }

                delete [] pszaUDN;
                pszaUDN = NULL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrParseControlQueryString(): "
                           "Failed to allocate memory for UDN ANSI string",
                           hr);
            }

        }
        else
        {
            hr = E_INVALIDARG;
            TraceError("HrParseControlQueryString(): "
                       "Could not find delimiter character",
                       hr);
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceError("HrParseControlQueryString(): "
                   "Length of query string was <= length of the prefix",
                   hr);
    }


    // If the above succeeded, we should have the UDN and service ID
    // as wide strings.

    if (SUCCEEDED(hr))
    {
        IUPnPRegistrarLookup   * pRegistrarLookup = NULL;

        hr = CoCreateInstance(CLSID_UPnPRegistrar,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUPnPRegistrarLookup,
                              (void **) &pRegistrarLookup);

        if (SUCCEEDED(hr))
        {
            hr = pRegistrarLookup->GetAutomationProxy(pszUDN,
                                                      pszServiceID,
                                                      ppAutomationProxy);

            if (SUCCEEDED(hr))
            {
                TraceTag(ttidUDHISAPI,
                         "HrParseControlQuerySring(): "
                         "Successfully obtained automation proxy");
            }
            else
            {
                TraceError("HrParseControlQueryString(): "
                           "Failed to get automation proxy",
                           hr);
            }

            pRegistrarLookup->Release();
        }
        else
        {
            TraceError("HrParseControlQueryString(): "
                       "Failed to create registrar object",
                       hr);
        }
    }

    // Cleanup

    if (pszUDN)
    {
        delete [] pszUDN;
        pszUDN = NULL;
    }

    if (pszServiceID)
    {
        delete [] pszServiceID;
        pszServiceID = NULL;
    }

    TraceError("HrParseControlQueryString(): "
               "Exiting",
               hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDoRequestAndReturnResponse
//
//  Purpose:    This function does the main work in processing a control
//              request. It reads the request, parses it, deserializes it,
//              executes it, serializes the response, generates a SOAP
//              response and sends that to the client.
//
//  Arguments:
//      pecb [in] The extension control block for the request.
//
//  Returns:
//   If the function succeeds, the return value is S_OK. Otherwise, the
//   function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/24
//
//  Notes:
//
HRESULT
HrDoRequestAndReturnResponse(
    IN LPEXTENSION_CONTROL_BLOCK  pecb)
{
    HRESULT                        hr = S_OK;
    IXMLDOMNode                    * pxdnReqEnvelope = NULL;
    IUPnPAutomationProxy           * pAutomationProxy = NULL;
    IUPnPServiceDescriptionInfo    * pServiceDescriptionInfo = NULL;

    // At this point, we do not know if the request is valid. First we'll
    // parse the query string, use the registrar to look up the service it
    // specifies. If this succeeeds, we'll read the request body, and validate
    // its structure.

    hr = HrParseControlQueryString(pecb->lpszQueryString,
                                   &pAutomationProxy);

    if (SUCCEEDED(hr))
    {
        Assert(pAutomationProxy);

        hr = pAutomationProxy->QueryInterface(IID_IUPnPServiceDescriptionInfo,
                                              (void **) &pServiceDescriptionInfo);

        if (SUCCEEDED(hr))
        {
            Assert(pServiceDescriptionInfo);

            hr = HrReadRequest(pecb, &pxdnReqEnvelope);

            if (SUCCEEDED(hr))
            {
                hr = HrValidateControlRequest(pecb,
                                              pxdnReqEnvelope,
                                              pServiceDescriptionInfo);
            }
        }
        else
        {
            TraceError("HrDoRequestAndReturnResponse(): "
                       "Failed to get service desc info interface",
                       hr);
        }
    }

    // If everything above succeeded, we can assume the request is
    // completely valid.

    if (SUCCEEDED(hr))
    {
        UPNP_SOAP_REQUEST  usrParsed;

        Assert(pxdnReqEnvelope);

        ZeroMemory(&usrParsed, sizeof(UPNP_SOAP_REQUEST));

        hr = HrParseSOAPRequest(pxdnReqEnvelope, &usrParsed);

        if (SUCCEEDED(hr))
        {
            UPNP_CONTROL_REQUEST ucrDeserialized;

            ZeroMemory(&ucrDeserialized, sizeof(UPNP_CONTROL_REQUEST));

            hr = HrDeserializeSOAPRequest(&usrParsed,
                                          pServiceDescriptionInfo,
                                          &ucrDeserialized);

            if (SUCCEEDED(hr))
            {
                UPNP_CONTROL_RESPONSE ucrespDeserialized;

                ZeroMemory(&ucrespDeserialized, sizeof(UPNP_CONTROL_RESPONSE));

                hr = HrExecuteRequest(pAutomationProxy,
                                      &ucrDeserialized,
                                      &ucrespDeserialized);

                if (SUCCEEDED(hr))
                {
                    UPNP_SOAP_RESPONSE usrespSerialized = {0};

                    hr = HrSerializeResponse(pAutomationProxy,
                                             &ucrDeserialized,
                                             &ucrespDeserialized,
                                             pServiceDescriptionInfo,
                                             &usrespSerialized);

                    if (SUCCEEDED(hr))
                    {
                        Assert(usrespSerialized.pxddRespEnvelope);

                        hr = HrWriteResponse(pecb,
                                             usrespSerialized.pxddRespEnvelope,
                                             usrespSerialized.fSucceeded);

                        CleanupSerializedResponse(&usrespSerialized);
                    }

                    CleanupDeserializedResponse(&ucrespDeserialized);
                }

                CleanupDeserializedRequest(&ucrDeserialized);
            }

            CleanupSerializedRequest(&usrParsed);
        }
    }

    // Cleanup

    if (pServiceDescriptionInfo)
    {
        pServiceDescriptionInfo->Release();
        pServiceDescriptionInfo = NULL;
    }

    if (pAutomationProxy)
    {
        pAutomationProxy->Release();
        pAutomationProxy = NULL;
    }

    if (pxdnReqEnvelope)
    {
        pxdnReqEnvelope->Release();
        pxdnReqEnvelope = NULL;
    }

    TraceError("HrDoRequestAndReturnResponse(): "
               "Exiting",
               hr);
    return hr;
}


DWORD WINAPI
DwHandleControlRequest(
    LPVOID lpParameter)
{
    LPEXTENSION_CONTROL_BLOCK pecb = NULL;
    DWORD                     dwStatus = HSE_STATUS_SUCCESS;
    HCONN                     ConnID;
    HRESULT                   hr = S_OK;
    BOOL fKeepConn = FALSE;

    pecb = (LPEXTENSION_CONTROL_BLOCK) lpParameter;

    AssertSz(pecb,
             "DwHandleControlRequest(): "
             "NULL extension control block");

    pecb->ServerSupportFunction(
        pecb->ConnID,
        HSE_REQ_IS_KEEP_CONN,
        &fKeepConn,
        NULL,
        NULL);

    if(fKeepConn)
        dwStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
    else
        dwStatus = HSE_STATUS_SUCCESS;

    ConnID = pecb->ConnID;

    AssertSz(pecb->lpszQueryString,
             "DwHandleControlRequest(): "
             "NULL query string passed");


    // Validate the method.
    hr = HrValidateControlMethod(pecb->lpszMethod);

    if (SUCCEEDED(hr))
    {
        // Get the content GUID.

        TraceTag(ttidUDHISAPI,
                 "DwHandleControlRequest(): ConnID(0x%x) "
                 "Query string is %s",
                 ConnID,
                 pecb->lpszQueryString);

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

        if (SUCCEEDED(hr))
        {
            hr = HrDoRequestAndReturnResponse(pecb);

            CoUninitialize();
        }
        else
        {
            TraceTag(ttidUDHISAPI,
                     "DwHandleControlRequest(): ConnID(0x%x): "
                     "Failed to initialize COM, HRESULT == 0x%x",
                     ConnID,
                     hr);
        }
    }
    else
    {
        TraceTag(ttidUDHISAPI,
                 "DwHandleControlRequest(): ConnID(0x%x): "
                 "Failed to validate method %s, HRESULT == 0x%x",
                 ConnID,
                 pecb->lpszMethod,
                 hr);
    }


    if (FAILED(hr))
    {
        if (UPNP_E_MISSING_SOAP_ACTION == hr || UPNP_E_MISSING_CONTENT_LENGTH == hr)
        {
            // these errors result in the less specific error:
            hr = UPNP_E_BAD_REQUEST;
        }

        if (UPNP_E_INVALID_CONTENT_TYPE == hr)
        {
            SendSimpleResponse(pecb, HTTP_STATUS_UNSUPPORTED_MEDIA);
        }
        else if (UPNP_E_BAD_REQUEST == hr)
        {
            SendSimpleResponse(pecb, HTTP_STATUS_BAD_REQUEST);
        }
        else if (UPNP_E_METHOD_NOT_IMPLEMENTED == hr)
        {
            SendSimpleResponse(pecb, HTTP_STATUS_NOT_SUPPORTED);
        }
        else if (UPNP_E_METHOD_NOT_ALLOWED == hr)
        {
            LPCSTR pcszErrorHeaders = "Allow: POST, M-POST\r\n\r\n";

            if (bSendResponseToClient(pecb,
                                      "405 Method Not Allowed",
                                      lstrlenA(pcszErrorHeaders),
                                      pcszErrorHeaders,
                                      0,
                                      NULL))
            {
                pecb->dwHttpStatusCode = HTTP_STATUS_BAD_METHOD;
            }
        }
        else
        {
            LPCSTR pcszErrorHeaders = "\r\n";

            dwStatus = HSE_STATUS_ERROR;

            if (bSendResponseToClient(pecb,
                                      "500 Internal Server Error",
                                      lstrlenA(pcszErrorHeaders),
                                      pcszErrorHeaders,
                                      0,
                                      NULL))
            {
                pecb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
            }
        }
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\descrqst.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E S C R Q S T . C P P
//
//  Contents:   Implementation of description request processing for the
//              UPnP Device Host ISAPI Extension
//
//  Notes:
//
//  Author:     spather   2000/08/31
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <wininet.h>

#include "descrqst.h"
#include "udhiutil.h"

#include "hostp.h"
#include "uhcommon.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrValidateDescriptionMethod
//
//  Purpose:    Validates that the HTTP verb used is valid for this
//              type of request.
//
//  Arguments:
//      pszaMethod [in] The HTTP verb
//
//  Returns:
//    If the method is valid, the return value is S_OK. If the method is
//    not valid, the function returns one of the COM error codes defined
//    in WinError.h.
//
//  Author:     spather   2000/09/21
//
//  Notes:
//

HRESULT
HrValidateDescriptionMethod(
    IN LPSTR pszaMethod)
{
    HRESULT hr = S_OK;

    AssertSz(pszaMethod,
             "HrValidateDescriptionMethod(): NULL Method passed");

    if (0 != lstrcmpiA(pszaMethod, "GET"))
    {
        hr = E_FAIL;
    }

    TraceError("HrValidateDescriptionMethod(): Exiting",
               hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrParseDescriptionQueryString
//
//  Purpose:    Parses a description request's query string and extracts
//              the content GUID from it.
//
//  Arguments:
//      pszaQueryString [in]    The query string to parse
//      rguidContent    [out]   Points to a GUID structure that will be
//                              initialized with the content GUID as parsed
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/14
//
//  Notes:
//
HRESULT
HrParseDescriptionQueryString(
    IN     LPSTR       pszaQueryString,
    OUT    GUID        & rguidContent)
{
    HRESULT     hr = S_OK;
    LPWSTR      szQueryString;

    Assert(pszaQueryString);

    szQueryString = WszFromSz(pszaQueryString);
    if (szQueryString)
    {
        hr = HrContentURLToGUID(szQueryString, rguidContent);

        delete [] szQueryString;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrParseDescriptionQueryString(): "
                   "Unable to allocate memory for content URL",
                   hr);
    }

    TraceError("HrParseDescriptionQueryString(): "
               "Exiting",
               hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrReturnContent
//
//  Purpose:    Retrieves content from a content source and sends it back
//              to the originator of a description request
//
//  Arguments:
//      pecb         [in]  The extension control block for the description
//                         request
//      pudcs        [in]  The dynamic content source
//      rguidContent [in]  The GUID identifying the content being requested.
//
//  Returns:
//      If the function succeeds, the return value is S_OK. Otherwise, the
//      function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/09/14
//
//  Notes:
//
HRESULT
HrReturnContent(
    LPEXTENSION_CONTROL_BLOCK  pecb,
    IUPnPDynamicContentSource  * pudcs,
    REFGUID                    rguidContent)
{
    HRESULT    hr = S_OK;
    LONG       nHeaders = 0;
    LPWSTR     * rgszHeaders = NULL;
    LONG       nBytes = 0;
    BYTE       * rgBytes = NULL;

    hr = pudcs->GetContent(rguidContent,
                           &nHeaders,
                           &rgszHeaders,
                           &nBytes,
                           &rgBytes);

    if (SUCCEEDED(hr))
    {
        DWORD cchHeaders = 0;
        LPSTR pszaHeaders = NULL;

        Assert(rgszHeaders);
        Assert(rgBytes);

        // Need to merge the headers into a single ASCII string. Each
        // Headers will be delimited by \r\n pairs and the last header
        // will be followed by 2 \r\n pairs.

        for (LONG i = 0; i < nHeaders; i++)
        {
            cchHeaders += lstrlenW(rgszHeaders[i]);
            cchHeaders += 2; // For the "\r\n" pair
        }

        cchHeaders += 2; // For the final "\r\n"

        pszaHeaders = new CHAR[cchHeaders+1];

        if (pszaHeaders)
        {
            LPSTR pszaNextHeader = pszaHeaders;

            for (LONG i = 0; i < nHeaders; i++)
            {
                DWORD  cchCurHeader;

                cchCurHeader = lstrlenW(rgszHeaders[i]);

                wsprintfA(pszaNextHeader,
                         "%S\r\n",
                          rgszHeaders[i]);

                pszaNextHeader += cchCurHeader+2; // +2 for \r\n
            }

            lstrcpyA(pszaNextHeader,
                     "\r\n");

            if (bSendResponseToClient(pecb,
                                      "200 OK",
                                      cchHeaders,
                                      pszaHeaders,
                                      nBytes,
                                      (LPCSTR) rgBytes))
            {
                pecb->dwHttpStatusCode = HTTP_STATUS_OK;
                TraceTag(ttidUDHISAPI,
                         "HrReturnContent(): "
                         "Successfully sent response to client");
            }
           
            delete [] pszaHeaders;
            pszaHeaders = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrReturnContent(): "
                       "Failed to allocate memory for headers",
                       hr);
        }

        // Free memory returned from GetContent().
        for (LONG i = 0; i < nHeaders; i++)
        {
            CoTaskMemFree(rgszHeaders[i]);
            rgszHeaders[i] = NULL;
        }
        CoTaskMemFree(rgszHeaders);
        rgszHeaders = NULL;

        CoTaskMemFree(rgBytes);
        rgBytes = NULL;
    }
    else
    {
        TraceError("HrReturnContent(): "
                   "Failed to get content",
                   hr);
    }

    TraceError("HrReturnContent(): "
               "Exiting",
               hr);
    return hr;
}

DWORD WINAPI
DwHandleContentRequest(
    LPVOID lpParameter)
{
    LPEXTENSION_CONTROL_BLOCK pecb = NULL;
    DWORD                     dwStatus = HSE_STATUS_SUCCESS ;
    HCONN                     ConnID;
    HRESULT                   hr = S_OK;
    GUID                      guidContent;
    BOOL fKeepConn = FALSE;

    pecb = (LPEXTENSION_CONTROL_BLOCK) lpParameter;

    AssertSz(pecb,
             "DwHandleContentRequest(): "
             "NULL extension control block");
    
    pecb->ServerSupportFunction(
        pecb->ConnID,
        HSE_REQ_IS_KEEP_CONN,
        &fKeepConn,
        NULL,
        NULL);

    if(fKeepConn)
        dwStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
    else
        dwStatus = HSE_STATUS_SUCCESS;
    
    ConnID = pecb->ConnID;

    AssertSz(pecb->lpszQueryString,
             "DwHandleContentRequest(): "
             "NULL query string passed");


    // Validate the method.
    hr = HrValidateDescriptionMethod(pecb->lpszMethod);

    if (SUCCEEDED(hr))
    {
        // Get the content GUID.

        TraceTag(ttidUDHISAPI,
                 "DwHandleContentRequest(): ConnID(0x%x) "
                 "Query string is %s",
                 ConnID,
                 pecb->lpszQueryString);

        hr = HrParseDescriptionQueryString(pecb->lpszQueryString,
                                           guidContent);

        if (SUCCEEDED(hr))
        {
            hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

            if (SUCCEEDED(hr))
            {
                IUPnPDynamicContentSource  * pudcs = NULL;

                hr = CoCreateInstance(CLSID_UPnPDynamicContentSource,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IUPnPDynamicContentSource,
                                      (void **) &pudcs);

                if (SUCCEEDED(hr))
                {
                    hr = HrReturnContent(pecb,
                                         pudcs,
                                         guidContent);

                    pudcs->Release();
                }
                else
                {
                    TraceTag(ttidUDHISAPI,
                             "DwHandleContentRequest(): ConnID(0x%x): "
                             "Failed to CoCreate dynamic content source, "
                             " HRESULT == 0x%x",
                             ConnID,
                             hr);
                }


                CoUninitialize();
            }
            else
            {
                TraceTag(ttidUDHISAPI,
                         "DwHandleContentRequest(): ConnID(0x%x): "
                         "Failed to initialize COM, HRESULT == 0x%x",
                         ConnID,
                         hr);
            }

        }
        else
        {
            TraceTag(ttidUDHISAPI,
                     "DwHandleContentRequest(): ConnID(0x%x): "
                     "Failed to get content GUID, HRESULT == 0x%x",
                     ConnID,
                     hr);
        }
    }
    else
    {
        TraceTag(ttidUDHISAPI,
                 "DwHandleContentRequest(): ConnID(0x%x): "
                 "Failed to validate method %s, HRESULT == 0x%x",
                 ConnID,
                 pecb->lpszMethod,
                 hr);
    }


    if (FAILED(hr))
    {
        LPCSTR pcszErrorHeaders = "\r\n";

        dwStatus = HSE_STATUS_ERROR;

        if (bSendResponseToClient(pecb,
                                  "500 Internal Server Error",
                                  lstrlenA(pcszErrorHeaders),
                                  pcszErrorHeaders,
                                  0,
                                  NULL))
        {
            pecb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
        }
    }

    return dwStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\evtrqst.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V T R Q S T . C P P
//
//  Contents:   Handles eventing-related requests for the UPnP Device Host
//
//  Notes:
//
//  Author:     danielwe   11 Aug 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <httpext.h>
#include <wininet.h>
#include <winsock.h>
#include "udhiutil.h"
#include "evtrqst.h"
#include "hostp.h"
#include "ncbase.h"
#include "ncstring.h"

static const DWORD      c_csecDefaultTimeout = 6 * 60 * 60;     // 6 hours

DWORD WINAPI
DwHandleEventRequest(
    LPVOID lpParameter)
{
    DWORD                      hseStatus = HSE_STATUS_SUCCESS;
    LPEXTENSION_CONTROL_BLOCK  pecb = NULL;
    HRESULT                    hr = S_OK;

    pecb = (LPEXTENSION_CONTROL_BLOCK) lpParameter;

    AssertSz(pecb, "NULL Extension Control Block!");

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(hr))
    {
        if (pecb->lpszMethod)
        {
            TraceTag(ttidIsapiCtl, "Got method %s", pecb->lpszMethod);

            if (!lstrcmpiA(pecb->lpszMethod, "SUBSCRIBE"))
            {
                hseStatus = DwHandleSubscribeMethod(pecb);
            }
            else if (!lstrcmpiA(pecb->lpszMethod, "UNSUBSCRIBE"))
            {
                hseStatus = DwHandleUnSubscribeMethod(pecb);
            }
            else
            {
                pecb->dwHttpStatusCode = HTTP_STATUS_BAD_REQUEST;
                hseStatus = HSE_STATUS_ERROR;
            }
        }

        if (hseStatus == HSE_STATUS_ERROR)
        {
            SendSimpleResponse(pecb, pecb->dwHttpStatusCode);
        }

        CoUninitialize();
    }
    else
    {
        SendSimpleResponse(pecb, HTTP_STATUS_SERVER_ERROR);
    }

    if(hseStatus != HSE_STATUS_ERROR)
    {
        BOOL fKeepConn = FALSE;
        pecb->ServerSupportFunction(
        pecb->ConnID,
        HSE_REQ_IS_KEEP_CONN,
        &fKeepConn,
        NULL,
        NULL);

        if(fKeepConn)
            hseStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
        else
            hseStatus = HSE_STATUS_SUCCESS;
    }

    return hseStatus;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsHeaderPresent
//
//  Purpose:    Tests to see if a particular header is present on the given
//              HTTP request
//
//  Arguments:
//      pecb      [in]  Extension control block
//      szaHeader [in]  Header name to test
//
//  Returns:    TRUE if header was present, FALSE if not or if error
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
BOOL FIsHeaderPresent(LPEXTENSION_CONTROL_BLOCK pecb, LPCSTR szaHeader)
{
    LPSTR   szaResult;
    BOOL    fRet = FALSE;

    // Ensure SID header is NOT present
    if (DwQueryHeader(pecb, szaHeader, &szaResult) == ERROR_SUCCESS)
    {
        delete [] szaResult;
        fRet = TRUE;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwParseTime
//
//  Purpose:    Parses the Timeout header of a SUBSCRIBE request
//
//  Arguments:
//      szaTime [in]     Timeout value in the format defined by RFC2518
//
//  Returns:    Timeout value in SECONDS
//
//  Author:     danielwe   13 Oct 1999
//
//  Notes:
//
DWORD DwParseTime(LPCSTR szaTime)
{
    CHAR            szaDigits[64];
    const CHAR      c_szaTimeout[] = "Second-";
    const INT       c_cchTimeout = lstrlenA(c_szaTimeout);
    DWORD           iDigit = 0;

    if (szaTime && (lstrlenA(szaTime) > c_cchTimeout))
    {
        if (!_strnicmp(szaTime, c_szaTimeout, c_cchTimeout))
        {
            DWORD   dwDigits;

            // Ok we know we have at least "Timeout-x" now
            szaTime += c_cchTimeout;

            *szaDigits = 0;

            while (isdigit(*szaTime) && (iDigit < sizeof(szaDigits)))
            {
                // Copy the digits into the buffer
                szaDigits[iDigit++] = *szaTime++;
            }

            dwDigits = strtoul(szaDigits, NULL, 10);

            if (dwDigits)
            {
                return dwDigits;
            }
            else
            {
                return c_csecDefaultTimeout;
            }
        }
    }

    TraceTag(ttidEvents, "DwParseTime: Invalid timeout header %s. Returning "
             "default timeout of %d", szaTime ? szaTime : "<NULL>",
        c_csecDefaultTimeout);

    return c_csecDefaultTimeout;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwGetTimeout
//
//  Purpose:    Queries the timeout header for a SUBSCRIBE request and
//              parses it
//
//  Arguments:
//      pecb [in]   Extension control block
//
//  Returns:    Timeout queried, in seconds. If no timeout header was present
//              or it was invalid, a default timeout is returned.
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
DWORD DwGetTimeout(LPEXTENSION_CONTROL_BLOCK pecb)
{
    DWORD   csecTimeout;
    LPSTR   szaTimeout;

    if (DwQueryHeader(pecb, "HTTP_TIMEOUT", &szaTimeout) == ERROR_SUCCESS)
    {
        csecTimeout = DwParseTime(szaTimeout);

        TraceTag(ttidIsapiEvt, "DwGetTimeout: Queried "
                 "timeout header = %d", csecTimeout);

        delete [] szaTimeout;
    }
    else
    {
        // Default to reasonable amount
        csecTimeout = c_csecDefaultTimeout;

        TraceTag(ttidIsapiEvt, "DwGetTimeout: No Timeout header found. Using"
                 "default timeout: %d", csecTimeout);

    }

    return csecTimeout;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEventingManager
//
//  Purpose:    Given the query string passed to the ISAPI DLL, returns
//              the eventing manager object associated with that query
//
//  Arguments:
//      szaQueryString [in]     Query string from event subscription request
//      ppuem          [out]    Returns the eventing manager object
//
//  Returns:    S_OK if successful, E_OUTOFMEMORY, or E_INVALIDARG if the
//              query string was malformed. Also will return an error if
//              the corresponding eventing manager object could not be found.
//
//  Author:     danielwe   2000/08/16
//
//  Notes:
//
HRESULT HrGetEventingManager(LPSTR szaQueryString,
                             IUPnPEventingManager **ppuem)
{
    HRESULT     hr = S_OK;
    LPSTR       szaUdn;
    LPSTR       szaServiceId;
    LPWSTR      szUdn = NULL;
    LPWSTR      szServiceId = NULL;

    const CHAR  c_szPrefix[] = "event=";

    Assert(szaQueryString);

    szaQueryString = strstr(szaQueryString, c_szPrefix);
    if (szaQueryString)
    {
        szaQueryString += lstrlenA(c_szPrefix);
        TraceTag(ttidIsapiEvt, "HrGetEventingManager: Asking registrar for "
                 "the eventing manager with query string: %s", szaQueryString);
    }
    else
    {
        hr = E_INVALIDARG;
        TraceTag(ttidIsapiEvt, "HrGetEventingManager: Invalid query"
                 " string: %s", szaQueryString);
        goto cleanup;
    }

    szaUdn = strtok(szaQueryString, "+");
    if (szaUdn)
    {
        szUdn = WszFromSz(szaUdn);
        if (szUdn)
        {
            szaServiceId = strtok(NULL, "+");
            if (szaServiceId)
            {
                szServiceId = WszFromSz(szaServiceId);
                if (szServiceId)
                {
                    IUPnPRegistrarLookup *  purl = NULL;

                    hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IUPnPRegistrarLookup,
                                          (LPVOID *)&purl);
                    if (SUCCEEDED(hr))
                    {
                        hr = purl->GetEventingManager(szUdn, szServiceId,
                                                      ppuem);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_INVALIDARG;
                TraceTag(ttidIsapiEvt, "HrGetEventingManager: Invalid query"
                         " string: %s", szaQueryString);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceTag(ttidIsapiEvt, "HrGetEventingManager: Invalid query"
                 " string: %s", szaQueryString);
    }

cleanup:
    delete [] szUdn;
    delete [] szServiceId;

    TraceError("HrGetEventingManager", hr);
    return hr;
}

static const DWORD c_dwUPnPMajorVersion = 1;
static const DWORD c_dwUPnPMinorVersion = 0;
static const DWORD c_dwHostMajorVersion = 1;
static const DWORD c_dwHostMinorVersion = 0;

//+---------------------------------------------------------------------------
//
//  Function:   DwSendSubscribeResponse
//
//  Purpose:    Sends the response to a SUBSCRIBE request
//
//  Arguments:
//      pecb        [in]    Extension control block
//      csecTimeout [in]    Subscription timeout in seconds
//      szaSid      [in]    SID of subscription
//
//  Returns:    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
DWORD DwSendSubscribeResponse(LPEXTENSION_CONTROL_BLOCK pecb,
                              DWORD csecTimeout, LPCSTR szaSid)
{
    DWORD           dwReturn = HSE_STATUS_SUCCESS;
    CHAR            szaTimeout[256];
    CHAR            szaSidHeader[256];
    OSVERSIONINFO   osvi = {0};
    LPSTR           szaBuf;
    DWORD           cchBuf;
    HSE_SEND_HEADER_EX_INFO    HeaderExInfo;
    BOOL fKeepConn = FALSE;

    // Maximum size of SID value
    static const DWORD  c_cchMaxSid = 47;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);

    wsprintfA(szaTimeout, "Timeout: Second-%d\r\n", csecTimeout);

    AssertSz(lstrlenA(szaSid) <= c_cchMaxSid, "Invalid SID size!");

    wsprintfA(szaSidHeader, "SID: %s\r\n", szaSid);

    cchBuf = lstrlenA(szaTimeout) +
             lstrlenA(szaSidHeader) +
             2 + // CRLF (terminating)
             1;  // Terminating NULL

    szaBuf = new CHAR[cchBuf];
    if (!szaBuf)
    {
        dwReturn = HSE_STATUS_ERROR;
        pecb->dwHttpStatusCode = HTTP_STATUS_SERVICE_UNAVAIL;
    }
    else
    {
        lstrcpyA(szaBuf, szaTimeout);
        lstrcatA(szaBuf, szaSidHeader);
        lstrcatA(szaBuf, "\r\n");

        pecb->ServerSupportFunction(
                        pecb->ConnID,
                        HSE_REQ_IS_KEEP_CONN,
                        &fKeepConn,
                        NULL,
                        NULL);

        HeaderExInfo.pszStatus = NULL;
        HeaderExInfo.pszHeader = szaBuf;
        HeaderExInfo.cchStatus = 0 ;
        HeaderExInfo.cchHeader = cchBuf;
        HeaderExInfo.fKeepConn = fKeepConn;

        pecb->ServerSupportFunction(
                            pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER_EX,
                            &HeaderExInfo,
                            NULL,
                            NULL);


        delete [] szaBuf;
    }

    return dwReturn;
}

const CHAR c_szaUrlPrefix[]             = "<http://";

//+--------------------------------------------------------------------------
// Function: strcasestr
//
// Purpose: a case-insensitive variant of strstr
//
// Arguments: szBuff [in] the string to search
//                   szText[in] the text to search for
//
// Returns: a pointer to the first match in szBuff, or NULL if no match
//

LPSTR strcasestr(LPSTR szBuff, const LPSTR szText)
{
       const LPSTR szText1 = (const LPSTR)(szText+1);
	char firstc = *szText;
	if (firstc)
	{
	    if (isupper(firstc)) 
	        firstc = (char)tolower(firstc);
	    int len = strlen(szText1);
	    do {
	    	// search for a match of the first char
	    	char buffc;
	    	for (;;)
	    	{
	    		buffc = *szBuff++;
	    		if (buffc == 0) return NULL; // failure
	    		if ((buffc == firstc) || (isupper(buffc) && (tolower(buffc) == firstc)))
	    			break; // matched!
	    	}
	    	// we matched the first char. Now check the rest. If we fail,
	    	// loop around again; if we succeed, stop looping
	    } while (_strnicmp(szBuff, szText1, len) != 0);
	    // go back one as we matched (szText+1)
	    --szBuff;
	}
	return szBuff;
}

//+---------------------------------------------------------------------------
//
//  Function:   FParseCallbackUrl
//
//  Purpose:    Given the Callback URL header value, determines the list of
//              http:// URLs.
//
//  Arguments:
//      szCallbackUrl [in]  URL to process (comes from Callback: header)
//      pcszOut       [out] Number of URLs parsed
//      pszOut        [out] Array of valid callback URLs.
//
//  Returns:    TRUE if URL format is valid, FALSE if not or if out of
//              memory.
//
//  Author:     danielwe   13 Oct 1999
//
//  Notes:      Caller must free the prgszOut array with delete []
//
BOOL FParseCallbackUrl(LPCSTR szaCallbackUrl, DWORD *pcszOut,
                       LPWSTR **prgszOut)
{
    CONST INT   c_cchPrefix = lstrlenA(c_szaUrlPrefix);
    LPSTR       szaTemp;
    LPSTR       pchPos;
    LPSTR       szaOrig = NULL;
    BOOL        fResult = FALSE;
    LPWSTR *    rgszOut = NULL;
    DWORD       isz = 0;

    // NOTE: This function will return http:// as a URL.. Corner case, but
    // not catastrophic

    Assert(szaCallbackUrl);
    Assert(prgszOut);
    Assert(pcszOut);

    *prgszOut = NULL;
    *pcszOut = 0;

    // Copy the original URL so we can lowercase
    //
    szaTemp = SzaDupSza(szaCallbackUrl);

    if (!szaTemp)
    {
        TraceError("FParseCallbackUrl", E_OUTOFMEMORY);
        return FALSE;
    }

    szaOrig = szaTemp;

    // Count the approximate number of URLs so we know how big of an array to
    // allocate. We do this by counting the number of open angle brackets we
    // see (<).

    DWORD   cUrl = 0;

    pchPos = szaTemp;

    while (*pchPos)
    {
        if (*pchPos == '<')
        {
            cUrl++;
        }

        pchPos++;
    }

    rgszOut = new LPWSTR[cUrl];
    if (rgszOut)
    {
        // Look for <http://
        //

        pchPos = strcasestr(szaTemp, (const LPSTR)c_szaUrlPrefix);
        while (pchPos)
        {
            // Look for the closing '>'
            szaTemp = pchPos + c_cchPrefix;
            while (*szaTemp && *szaTemp != '>')
            {
                szaTemp++;
            }

            pchPos++;

            if (*szaTemp)
            {
                DWORD_PTR   cchOut;
                CHAR        szaUrl[INTERNET_MAX_PATH_LENGTH];

                Assert(*szaTemp == '>');

                // copy in the URL
                //
                cchOut = min(szaTemp - pchPos + 1, INTERNET_MAX_PATH_LENGTH - 1);
                lstrcpynA(szaUrl, pchPos, (int)cchOut);
                szaUrl[cchOut] = 0;

                rgszOut[isz] = WszFromSz(szaUrl);
                if (rgszOut[isz++])
                {
                    fResult = TRUE;
                }
                else
                {
                    fResult = FALSE;
                    break;
                }
            }

            pchPos = szaTemp;
            pchPos = strstr(pchPos, c_szaUrlPrefix);
        }
    }

    if (fResult)
    {
        *prgszOut = rgszOut;
        *pcszOut = isz;
    }
    else
    {
        DWORD   iszIter;

        for (iszIter = 0; iszIter < isz; iszIter++)
        {
            delete [] rgszOut[iszIter];
        }
        delete [] rgszOut;
    }

    delete [] szaOrig;

    TraceResult("FParseCallbackUrl", fResult);
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwHandleSubscribeRequest
//
//  Purpose:    Handles the processing of a SUBSCRIBE request
//
//  Arguments:
//      pecb [in]   Extension control block
//
//  Returns:    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
DWORD DwHandleSubscribeRequest(LPEXTENSION_CONTROL_BLOCK pecb)
{
    DWORD                   dwReturn;
    DWORD                   csecTimeout;
    HRESULT                 hr = S_OK;
    LPSTR                   szaTimeout = NULL;
    LPWSTR                  szCallbackUrl = NULL;
    LPWSTR                  szSid = NULL;
    LPSTR                   szaSid = NULL;
    LPSTR                   szaAddr = NULL;
    LPSTR                   szaCallback = NULL;
    LPWSTR *                rgszUrl;
    DWORD                   cszUrl = 0;
    DWORD                   dwIpAddr = 0;
    IUPnPEventingManager *  puem = NULL;

    pecb->dwHttpStatusCode = HTTP_STATUS_OK;

    dwReturn = DwQueryHeader(pecb, "LOCAL_ADDR", &szaAddr);
    if (ERROR_SUCCESS == dwReturn)
    {
        dwIpAddr = inet_addr(szaAddr);

        delete [] szaAddr;
    }
    else
    {
        TraceError("Could not obtain remote IP address!", E_FAIL);
    }

    dwReturn = DwQueryHeader(pecb, "HTTP_CALLBACK", &szaCallback);
    if (dwReturn == ERROR_SUCCESS)
    {
        AssertSz(szaCallback, "Callback string must not be NULL!");

        // Parse the callback URL given us. It will be of the format:
        // <[url]><[url]> but we only care about the first URL in the list
        // That's what we will have after this function returns. If the format
        // of the callback header was invalid, the return will be FALSE
        //
        if (!FParseCallbackUrl(szaCallback, &cszUrl, &rgszUrl))
        {
            TraceTag(ttidIsapiEvt, "Invalid callback URL: '%s'", szaCallback);

            // Callback URL is not valid
            pecb->dwHttpStatusCode = HTTP_STATUS_PRECOND_FAILED;
            dwReturn = HSE_STATUS_ERROR;
        }
        else
        {
            // Valid callback URL. Continue
            csecTimeout = DwGetTimeout(pecb);

            // Ensure SID header is NOT present
            if (FIsHeaderPresent(pecb, "HTTP_SID"))
            {
                TraceTag(ttidIsapiEvt, "SID header was present on a subscribe!");
                // Not supposed to have this header. Return error!
                pecb->dwHttpStatusCode = HTTP_STATUS_BAD_REQUEST;
                dwReturn = HSE_STATUS_ERROR;
            }
            else
            {
                dwReturn = ERROR_SUCCESS;

                hr = HrGetEventingManager(pecb->lpszQueryString, &puem);
                if (SUCCEEDED(hr))
                {
                    Assert(rgszUrl);
                    Assert(cszUrl);

                    hr = puem->AddSubscriber(cszUrl,
                                             const_cast<LPCWSTR *>(rgszUrl),
                                             dwIpAddr,
                                             &csecTimeout, &szSid);
                    if (SUCCEEDED(hr))
                    {
                        // Covert the SID returned from the EM object back to
                        // an ANSI string for the response
                        //
                        szaSid = SzFromWsz(szSid);

                        if (!szaSid)
                        {
                            pecb->dwHttpStatusCode = HTTP_STATUS_SERVICE_UNAVAIL;
                            dwReturn = HSE_STATUS_ERROR;
                            goto cleanup;
                        }

                        dwReturn = DwSendSubscribeResponse(pecb, csecTimeout,
                                                           szaSid);
                    }
                    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                    {
                        TraceTag(ttidIsapiEvt, "Eventing manager says event "
                                 "source did not exist!");

                        pecb->dwHttpStatusCode = HTTP_STATUS_NOT_FOUND;
                        dwReturn = HSE_STATUS_ERROR;

                        // So we don't overwrite this error
                        hr = S_OK;
                    }
                }
            }

            DWORD   iszUrl;

            for (iszUrl = 0; iszUrl < cszUrl; iszUrl++)
            {
                delete [] rgszUrl[iszUrl];
            }

            delete [] rgszUrl;
        }
    }
    else
    {
        TraceTag(ttidIsapiEvt, "DwHandleSubscribeRequest: Callback URL was "
                 "not present!");

        // Callback URL is not present
        pecb->dwHttpStatusCode = HTTP_STATUS_PRECOND_FAILED;
        dwReturn = HSE_STATUS_ERROR;
    }

cleanup:

    if (FAILED(hr))
    {
        TraceError("DwHandleSubscribeRequest", hr);

        pecb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
        dwReturn = HSE_STATUS_ERROR;
    }

    TraceTag(ttidIsapiEvt, "DwHandleSubscribeRequest returning %d", dwReturn);


    delete [] szaTimeout;
    delete [] szaSid;
    delete [] szCallbackUrl;

    CoTaskMemFree(szSid);

    delete [] szaCallback;

    ReleaseObj(puem);

    return dwReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwHandleResubscribeRequest
//
//  Purpose:    Handles the processing of a re-SUBSCRIBE request
//
//  Arguments:
//      pecb [in]   Extension control block
//
//  Returns:    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
DWORD DwHandleResubscribeRequest(LPEXTENSION_CONTROL_BLOCK pecb)
{
    DWORD                   dwReturn = HSE_STATUS_SUCCESS;
    LPSTR                   szaSid = NULL;
    LPWSTR                  szSid = NULL;
    HRESULT                 hr = S_OK;
    IUPnPEventingManager *  puem = NULL;

    pecb->dwHttpStatusCode = HTTP_STATUS_OK;

    // Ensure SID header is NOT present
    dwReturn = DwQueryHeader(pecb, "HTTP_SID", &szaSid);
    if (dwReturn == ERROR_SUCCESS)
    {
        AssertSz(!FIsHeaderPresent(pecb, "HTTP_NT"), "NT header is "
                 "not supposed to be here!");

        if (FIsHeaderPresent(pecb, "HTTP_CALLBACK"))
        {
            TraceTag(ttidIsapiEvt, "Callback header was present on a "
                     "re-subscribe!");

            pecb->dwHttpStatusCode = HTTP_STATUS_BAD_REQUEST;
            dwReturn = HSE_STATUS_ERROR;
        }
        else
        {
            DWORD   csecTimeout;

            csecTimeout = DwGetTimeout(pecb);

            hr = HrGetEventingManager(pecb->lpszQueryString, &puem);
            if (SUCCEEDED(hr))
            {
                // Convert the SID from the request to a UNICODE string for
                // the EM object
                //
                szSid = WszFromSz(szaSid);

                if (!szSid)
                {
                    pecb->dwHttpStatusCode = HTTP_STATUS_SERVICE_UNAVAIL;
                    dwReturn = HSE_STATUS_ERROR;
                    goto cleanup;
                }

                hr = puem->RenewSubscriber(&csecTimeout, szSid);
                if (SUCCEEDED(hr))
                {
                    dwReturn = DwSendSubscribeResponse(pecb, csecTimeout,
                                                       szaSid);
                }
                else if (HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) == hr)
                {
                    TraceTag(ttidIsapiEvt, "Eventing manager says subscriber"
                             " did not exist!");

                    pecb->dwHttpStatusCode = HTTP_STATUS_PRECOND_FAILED;
                    dwReturn = HSE_STATUS_ERROR;

                    // So we don't overwrite this error
                    hr = S_OK;
                }
            }
        }
    }
    else
    {
        TraceTag(ttidIsapiEvt, "SID header was NOT present on a re-subscribe!");

        pecb->dwHttpStatusCode = HTTP_STATUS_PRECOND_FAILED;
        dwReturn = HSE_STATUS_ERROR;
    }

cleanup:
    if (FAILED(hr))
    {
        TraceError("DwHandleResubscribeRequest", hr);

        pecb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
        dwReturn = HSE_STATUS_ERROR;
    }

    TraceTag(ttidIsapiEvt, "DwHandleResubscribeRequest: returning %d",
             dwReturn);

    delete [] szaSid;
    delete [] szSid;

    ReleaseObj(puem);

    return dwReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwHandleSubscribeMethod
//
//  Purpose:    Handles the processing of a request with the SUBSCRIBE
//              method
//
//  Arguments:
//      pecb [in]   Extension control block
//
//  Returns:    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
DWORD DwHandleSubscribeMethod(LPEXTENSION_CONTROL_BLOCK pecb)
{
    DWORD   dwReturn;
    LPSTR   szaNt;

    dwReturn = DwQueryHeader(pecb, "HTTP_NT", &szaNt);
    if (dwReturn == ERROR_SUCCESS)
    {
        TraceTag(ttidIsapiEvt, "Queried NT header was '%s'", szaNt);

        if (!lstrcmpiA("upnp:event", szaNt))
        {
            // NT header was present and is correctly "upnp:event". Assume
            // that it is a subscribe request
            dwReturn = DwHandleSubscribeRequest(pecb);
        }
        else
        {
            TraceTag(ttidIsapiEvt, "NT header was not \"upnp:event\" (%s)",
                     szaNt);

            // Whoa! Not "upnp:event". Send 412 Precondition failed
            pecb->dwHttpStatusCode = HTTP_STATUS_PRECOND_FAILED;
            dwReturn = HSE_STATUS_ERROR;
        }

        delete [] szaNt;
    }
    else if (dwReturn == ERROR_INVALID_INDEX)
    {
        // NT header was not present. Assume it's now a re-subscribe request
        dwReturn = DwHandleResubscribeRequest(pecb);
    }
    else
    {
        dwReturn = HSE_STATUS_ERROR;
        pecb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
    }

    return dwReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwHandleUnSubscribeMethod
//
//  Purpose:    Handles the processing of an UNSUBSCRIBE request
//
//  Arguments:
//      pecb [in]   Extension control block
//
//  Returns:    HSE_STATUS_SUCCESS or HSE_STATUS_ERROR
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
DWORD DwHandleUnSubscribeMethod(LPEXTENSION_CONTROL_BLOCK pecb)
{
    DWORD   dwReturn = HSE_STATUS_SUCCESS;
    LPSTR   szaSid = NULL;
    HRESULT hr = S_OK;
    LPWSTR  szSid = NULL;

    pecb->dwHttpStatusCode = HTTP_STATUS_OK;

    // Ensure SID header is NOT present
    dwReturn = DwQueryHeader(pecb, "HTTP_SID", &szaSid);
    if (dwReturn == ERROR_SUCCESS)
    {
        if (FIsHeaderPresent(pecb, "HTTP_CALLBACK") ||
            FIsHeaderPresent(pecb, "HTTP_NT"))
        {
            TraceTag(ttidIsapiEvt, "Callback or NT header was present on an "
                     "unsubscribe!");

            pecb->dwHttpStatusCode = HTTP_STATUS_BAD_REQUEST;
            dwReturn = HSE_STATUS_ERROR;
        }
        else
        {
            IUPnPEventingManager *  puem = NULL;

            hr = HrGetEventingManager(pecb->lpszQueryString, &puem);
            if (SUCCEEDED(hr))
            {
                szSid = WszFromSz(szaSid);
                if (!szSid)
                {
                    pecb->dwHttpStatusCode = HTTP_STATUS_SERVICE_UNAVAIL;
                    dwReturn = HSE_STATUS_ERROR;
                    goto cleanup;
                }

                hr = puem->RemoveSubscriber(szSid);
                if (SUCCEEDED(hr))
                {
                    SendSimpleResponse(pecb, HTTP_STATUS_OK);
                }

                // No explicit response headers needed because UNSUBSCRIBE
                // doesn't have any headers associated with its response

                ReleaseObj(puem);
            }
        }
    }
    else
    {
        TraceTag(ttidIsapiEvt, "SID header was not present on an UNSUBSCRIBE");

        pecb->dwHttpStatusCode = HTTP_STATUS_PRECOND_FAILED;
        dwReturn = HSE_STATUS_ERROR;
    }

cleanup:

    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            pecb->dwHttpStatusCode = HTTP_STATUS_PRECOND_FAILED;
        }
        else
        {
            pecb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
        }

        TraceError("DwHandleUnSubscribeMethod", hr);

        dwReturn = HSE_STATUS_ERROR;
    }

    TraceTag(ttidIsapiEvt, "DwHandleUnSubscribeMethod: returning %d",
             dwReturn);

    delete [] szSid;
    delete [] szaSid;

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\udhiutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U D H I U T I L . H
//
//  Contents:   Header file for UDH ISAPI extension utilities.
//
//  Notes:
//
//  Author:     spather   2000/09/8
//
//----------------------------------------------------------------------------


#pragma once

#ifndef __UDHIUTIL_H
#define __UDHIUTIL_H

#include <httpext.h>

extern BOOL
bSendResponseToClient(
    IN     LPEXTENSION_CONTROL_BLOCK  pecb,
    IN     LPCSTR                     pcszStatus,
    IN     DWORD                      cchHeaders,
    IN     LPCSTR                     pcszHeaders,
    IN     DWORD                      cchBody,
    IN     LPCSTR                     pcszBody);

extern BOOL
bCompleteRequest(
    IN LPEXTENSION_CONTROL_BLOCK   pecb,
    IN DWORD                       dwStatus);

VOID
SendSimpleResponse(
    IN     LPEXTENSION_CONTROL_BLOCK   pecb,
    IN     DWORD                       dwStatusCode);

DWORD
DwQueryHeader(LPEXTENSION_CONTROL_BLOCK pecb,
              LPCSTR szaHeader,
              LPSTR *pszaResult);

#endif //! __UDHIUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\evtrqst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V T R Q S T . H
//
//  Contents:   External functions exposed by the event handling code
//
//  Notes:
//
//  Author:     danielwe   14 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _EVTRQST_H
#define _EVTRQST_H

DWORD WINAPI
DwHandleEventRequest(
    LPVOID lpParameter);

DWORD
DwHandleSubscribeMethod(
    LPEXTENSION_CONTROL_BLOCK pecb);

DWORD
DwHandleUnSubscribeMethod(
    LPEXTENSION_CONTROL_BLOCK pecb);

BOOL
FParseCallbackUrl(LPCSTR szaCallbackUrl, DWORD *pcszOut,
                  LPWSTR **prgszOut);

#endif //!_EVTRQST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\udhiutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U D H I U T I L . C P P
//
//  Contents:   Implementation of various utility functions used by the
//              UPnP Device Host ISAPI extension
//
//  Notes:
//
//  Author:     spather   2000/09/8
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <httpext.h>
#include "wininet.h"
#include "udhiutil.h"

//+---------------------------------------------------------------------------
//
//  Function:   bSendResponseToClient
//
//  Purpose:    Sends an HTTP response to the originator of a request
//
//  Arguments:
//      pecb       [in]    The extension control block for the request
//      pszStatus  [in]    HTTP status string e.g. "200 OK" or "400 Bad Request"
//      cchHeaders [in]    Number of characters in pszHeaders string
//      pszHeaders [in]    Headers string e.g. "Content-type: text/html\r\n\r\n"
//      cchBody    [in]    Number of bytes in pszBody
//      pszBody    [in]    Response body (may be NULL to send no body)
//
//  Returns:
//      TRUE if successful
//      FALSE if unsuccessful (call GetLastError() to get error info)
//
//  Author:     spather   2000/09/7
//
//  Notes:
//      All strings passed in must be NULL terminated.
//      pszHeaders string may contain multiple headers separated by \r\n pairs.
//      pszHeaders string must end in "\r\n\r\n" as required by HTTP
//      If a body is specified at pszBody, the pszHeaders string should contain
//      a Content-Length header.
//
BOOL
bSendResponseToClient(
    IN     LPEXTENSION_CONTROL_BLOCK   pecb,
    IN     LPCSTR                      pcszStatus,
    IN     DWORD                       cchHeaders,
    IN     LPCSTR                      pcszHeaders,
    IN     DWORD                       cchBody,
    IN     LPCSTR                      pcszBody)
{
    BOOL                       bRet = TRUE;
    HSE_SEND_HEADER_EX_INFO    HeaderExInfo;

    AssertSz(pecb,
             "bSendResponseToClient(): NULL pecb");
    AssertSz(pcszStatus,
             "bSendResponseToClient(): NULL pcszStatus");
    AssertSz(pcszHeaders,
             "bSendResponseToClient(): NULL pcszHeaders");

    BOOL fKeepConn = FALSE;
   
    bRet = pecb->ServerSupportFunction(
        pecb->ConnID,
        HSE_REQ_IS_KEEP_CONN,
        &fKeepConn,
        NULL,
        NULL);

    //
    // Prepare headers.
    //

    HeaderExInfo.pszStatus = pcszStatus;
    HeaderExInfo.pszHeader = pcszHeaders;
    HeaderExInfo.cchStatus = lstrlenA(pcszStatus);
    HeaderExInfo.cchHeader = cchHeaders;
    HeaderExInfo.fKeepConn = fKeepConn;
    //
    // Send the headers.
    //

    TraceTag(ttidUDHISAPI,
             "bSendResponseHeaders(): "
             "Sending Status \"%s\" and Headers:\n%s",
             pcszStatus,
             pcszHeaders);
    

    bRet = pecb->ServerSupportFunction(
        pecb->ConnID,
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        &HeaderExInfo,
        NULL,
        NULL);

    if (bRet)
    {
        //
        // Send the body if there is one.
        //

        if (pcszBody)
        {
            DWORD dwBytesToWrite = cchBody;

            bRet = pecb->WriteClient(pecb->ConnID,
                                     (LPVOID) pcszBody,
                                     &dwBytesToWrite,
                                     HSE_IO_SYNC);

            if (bRet)
            {
                AssertSz((cchBody == dwBytesToWrite),
                         "bSendResponseToClient(): "
                         "Didn't write the correct number of bytes");
            }
            else
            {
                TraceLastWin32Error("bSendResponseToClient(): "
                                    "Failed to send response body");
            }
        }
    }
    else
    {
        TraceLastWin32Error("bSendResponseToClient(): "
                            "Failed to send response headers");
    }

    TraceTag(ttidUDHISAPI,
             "bSendResponseToClient(): "
             "Exiting - returning %d",
             bRet);

    return bRet;
}

VOID
SendSimpleResponse(
    IN     LPEXTENSION_CONTROL_BLOCK   pecb,
    IN     DWORD                       dwStatusCode)
{
    BOOL                fRet;
    static const CHAR   c_szErrorHeaders[] = "\r\n";
    LPSTR               szaResponse;

    switch(dwStatusCode)
    {
    case HTTP_STATUS_OK:
        szaResponse = "200 OK";
        break;
    case HTTP_STATUS_CREATED:
        szaResponse = "201 Created";
        break;
    case HTTP_STATUS_ACCEPTED:
        szaResponse = "202 Accepted";
        break;
    case HTTP_STATUS_NO_CONTENT:
        szaResponse = "204 No Content";
        break;

    case HTTP_STATUS_AMBIGUOUS:
        szaResponse = "300 Multiple";
        break;
    case HTTP_STATUS_MOVED:
        szaResponse = "301 Moved Permanently";
        break;
    case HTTP_STATUS_REDIRECT:
        szaResponse = "302 Moved Temporarily";
        break;
    case HTTP_STATUS_NOT_MODIFIED:
        szaResponse = "304 Not Modified";
        break;


    case HTTP_STATUS_BAD_REQUEST:
        szaResponse = "400 Bad Request";
        break;
    case HTTP_STATUS_DENIED:
        szaResponse = "401 Unauthorized";
        break;
    case HTTP_STATUS_FORBIDDEN:
        szaResponse = "403 Forbidden";
        break;
    case HTTP_STATUS_NOT_FOUND:
        szaResponse = "404 Not Found";
        break;
    case HTTP_STATUS_BAD_METHOD:
        szaResponse = "405 Method Not Allowed";
        break;
    case HTTP_STATUS_LENGTH_REQUIRED:
        szaResponse = "411 The Server Refused to Accept Request Without a Length";
        break;
    case HTTP_STATUS_PRECOND_FAILED:
        szaResponse = "412 Precondition Failed";
        break;
    case HTTP_STATUS_UNSUPPORTED_MEDIA:
        szaResponse = "415 Unsupported Media Type";
        break;



    case HTTP_STATUS_SERVER_ERROR:
        szaResponse = "500 Internal Server Error";
        break;
    case HTTP_STATUS_NOT_SUPPORTED:
        szaResponse = "501 Not Implemented";
        break;
    case HTTP_STATUS_BAD_GATEWAY:
        szaResponse = "502 Bad Gateway";
        break;
    case HTTP_STATUS_SERVICE_UNAVAIL:
        szaResponse = "503 Service Unavailable";
        break;

    default:
        AssertSz(FALSE, "You must pass in a known HTTP status code to "
                 "SendErrorResponse()");
        break;

    }

    if (bSendResponseToClient(pecb, szaResponse, lstrlenA(c_szErrorHeaders),
                              c_szErrorHeaders, 0, NULL))
    {
        pecb->dwHttpStatusCode = dwStatusCode;
    }

    DWORD   dwHseStatus;

    dwHseStatus = (dwStatusCode >= HTTP_STATUS_BAD_REQUEST) ?
                   HSE_STATUS_ERROR : HSE_STATUS_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwQueryHeader
//
//  Purpose:    Queries one of the headers sent in an HTTP request
//
//  Arguments:
//      pecb       [in]     Exetnsion control block
//      szaHeader  [in]     Header name to query
//      pszaResult [out]    Returns value of header or NULL if not present
//
//  Returns:    ERROR_SUCCESS, ERROR_OUTOFMEMORY, or an ISAPI error code
//
//  Author:     danielwe   14 Aug 2000
//
//  Notes:
//
DWORD DwQueryHeader(LPEXTENSION_CONTROL_BLOCK pecb, LPCSTR szaHeader,
                    LPSTR *pszaResult)
{
    DWORD   cbHeader = 0;
    LPSTR   szaBuf = NULL;
    DWORD   dwReturn = ERROR_SUCCESS;

    Assert(pszaResult);

    *pszaResult = 0;

    if (!pecb->GetServerVariable(pecb->ConnID, (LPSTR)szaHeader, NULL, &cbHeader))
    {
        dwReturn = GetLastError();
        if (dwReturn == ERROR_INSUFFICIENT_BUFFER)
        {
            szaBuf = new CHAR[cbHeader / sizeof(CHAR)];
            if (szaBuf)
            {
                if (!pecb->GetServerVariable(pecb->ConnID, (LPSTR)szaHeader,
                                             (LPVOID)szaBuf, &cbHeader))
                {
                    dwReturn = GetLastError();
                }
                else
                {
                    *pszaResult = szaBuf;
                    dwReturn = ERROR_SUCCESS;
                }
            }
            else
            {
                dwReturn = ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            AssertSz(dwReturn != ERROR_SUCCESS, "How can it succeed if I gave"
                     " it a NULL pointer!");
        }
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\udres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U D R E S . H
//
//  Contents:   Master resource header for udhisapi.dll
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
//#define IDS_EMPTY_NODE_NOT_PRESENT                  200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\udhisapi.cpp ===
#include <pch.h>
#pragma hdrstop

#include <httpext.h>
#include <wininet.h>

#include "ncstring.h"
#include "udhiutil.h"
#include "descrqst.h"
#include "ctrlrqst.h"
#include "evtrqst.h"

#include "hostp.h"
#include "hostp_i.c"

static LONG g_fTracingInit = 0;

typedef LPTHREAD_START_ROUTINE PFN_UPNP_REQUEST_HANDLER;

typedef enum {
    URT_CONTENT = 0,
    URT_CONTROL = 1,
    URT_EVENTING   = 2,
    // URT_INVALID __MUST__ be last. Insert new types before URT_INVALID
    URT_INVALID
} UPNP_REQUEST_TYPE;

typedef struct tagUPNP_REQUEST_DISPATCH_ENTRY
{
    LPCSTR                     pszaTypeString;
    UPNP_REQUEST_TYPE          urt;
    PFN_UPNP_REQUEST_HANDLER   pfnHandler;
} UPNP_REQUEST_DISPATCH_ENTRY;

const UPNP_REQUEST_DISPATCH_ENTRY gc_DispatchTable[] =
{
    {"content",    URT_CONTENT,    DwHandleContentRequest},  // URT_CONTENT
    {"control",    URT_CONTROL,    DwHandleControlRequest},  // URT_CONTROL
    {"event",      URT_EVENTING,   DwHandleEventRequest},    // URT_EVENTING
    {NULL,         URT_INVALID,    NULL}                     // URT_INVALID - MUST be last
};

//+---------------------------------------------------------------------------
//
//  Function:   UPnPRequestTypeFromQueryString
//
//  Purpose:    Parses a query string and determines the type of request
//              it specifies.
//
//  Arguments:
//      pszaQueryString [in]    Query string to parse
//      purt            [out]   Receives a reference to the UPNP_REQUEST_TYPE
//                              value corresponding to the query string
//
//  Returns:
//      (none) - See Notes section below.
//
//  Author:     spather   2000/08/31
//
//  Notes:
//      If the query string does not specify a valid request, the value
//      returned at purt is URT_INVALID.
//
VOID
UPnPRequestTypeFromQueryString(
    IN     LPSTR              pszaQueryString,
    OUT    UPNP_REQUEST_TYPE   * purt)
{

    AssertSz(pszaQueryString,
             "UPnPRequestTypeFromQueryString(): "
             "NULL query string passed");

    if (purt)
    {
        UPNP_REQUEST_TYPE  urt = URT_INVALID;
        DWORD              cchQueryString = 0;
        int                i = 0;

        cchQueryString = lstrlenA(pszaQueryString);

        // Loop through the dispatch table, looking for an entry with
        // a request type string matching the one in the query string.

        while (gc_DispatchTable[i].urt != URT_INVALID)
        {
            DWORD  cchTypeString = 0;
            LPCSTR pcszaTypeString = NULL;

            pcszaTypeString = gc_DispatchTable[i].pszaTypeString;
            cchTypeString = lstrlenA(pcszaTypeString);

            // If the query string is shorter than the request type string
            // then this is obviously not a match.

            if (cchQueryString >= cchTypeString)
            {
                if (_strnicmp(pszaQueryString,
                              pcszaTypeString,
                              cchTypeString) == 0)
                {
                    urt = gc_DispatchTable[i].urt;
                    break;
                }
            }
            i++;
        }

        *purt = urt;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   UPnPRequestHandlerFromRequestType
//
//  Purpose:    Retrieves a pointer to a handler function for a particular
//              request type.
//
//  Arguments:
//      urt         [in]    The UPnP request type
//      ppfnHandler [out]   Receives a pointer to a handler function for the
//                          UPnP request type
//
//  Returns:
//      (none) - See Notes section below.
//
//  Author:     spather   2000/09/1
//
//  Notes:
//      If urt is URT_INVALID, then a NULL pointer is returned at ppfnHandler.
//
VOID
UPnPRequestHandlerFromRequestType(
    IN     UPNP_REQUEST_TYPE           urt,
    OUT    PFN_UPNP_REQUEST_HANDLER    * ppfnHandler)
{
    if (ppfnHandler)
    {
        int                        i = 0;
        PFN_UPNP_REQUEST_HANDLER   pfnHandler = NULL;

        if (urt != URT_INVALID)
        {
            // Loop through the dispatch table, looking for an entry
            // with a matching request type. If one is found, we return
            // the handler function from it.

            while (gc_DispatchTable[i].urt != URT_INVALID)
            {
                if (gc_DispatchTable[i].urt == urt)
                {
                    pfnHandler = gc_DispatchTable[i].pfnHandler;
                    break;
                }

                i++;
            }
        }

        *ppfnHandler = pfnHandler;
    }
}

static const LPCSTR c_rgszHeaders[] =
{
    "HOST",
    "NT",
    "CALLBACK",
    "TIMEOUT",
    "SID"
};

static const int c_cHeaders = celems(c_rgszHeaders);

BOOL FExistDuplicateHeaders(LPEXTENSION_CONTROL_BLOCK pecb)
{
    LPSTR   szHeaders;

    if (DwQueryHeader(pecb, "ALL_RAW", &szHeaders) == ERROR_SUCCESS)
    {
        INT     ih;

        AssertSz(szHeaders, "No headers?");

        for (ih = 0; ih < c_cHeaders; ih++)
        {
            LPSTR   szMatch;

            szMatch = stristr(szHeaders, c_rgszHeaders[ih]);
            if (szMatch)
            {
                if ((szMatch == szHeaders) ||
                   (((*(szMatch - 1) == '\n') &&
                        (szMatch - 1 != szHeaders) &&
                        (*(szMatch - 2) == '\r'))))
                {
                    szMatch += lstrlenA(c_rgszHeaders[ih]);

                    LPSTR   szMatch2;

                    szMatch2 = stristr(szMatch, c_rgszHeaders[ih]);
                    while (szMatch2)
                    {
                        if ((szMatch2 == szHeaders) ||
                           (((*(szMatch2 - 1) == '\n') &&
                                (szMatch2 - 1 != szHeaders) &&
                                (*(szMatch2 - 2) == '\r'))))
                        {
                            // Got another header! Duplicate!

                            TraceTag(ttidIsapiCtl, "Header %s is duplicated!",
                                     c_rgszHeaders[ih]);

                            delete [] szHeaders;

                            return TRUE;
                        }
                        else
                        {
                            szMatch2 += lstrlenA(c_rgszHeaders[ih]);
                            szMatch2 = stristr(szMatch2, c_rgszHeaders[ih]);
                        }
                    }
                }
            }
        }

        delete [] szHeaders;
    }

    return FALSE;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpv)
{
    return TRUE;
}

BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO * pver)
{
    TraceTag(ttidIsapiCtl, "GetExtensionVersion");

    if (pver)
    {
        pver->dwExtensionVersion = MAKELONG(1, 0);
        lstrcpyA(pver->lpszExtensionDesc, "UPnP Device Host ISAPI Extension");
    }

    return TRUE;
}

DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb)
{
    DWORD              hseStatus = HSE_STATUS_SUCCESS;
    UPNP_REQUEST_TYPE  urt = URT_INVALID;
    DWORD dwReturn ;
    LPSTR szaHost = NULL;

    BOOL fKeepConn = FALSE;
    pecb->ServerSupportFunction(
        pecb->ConnID,
        HSE_REQ_IS_KEEP_CONN,
        &fKeepConn,
        NULL,
        NULL);

    if(fKeepConn)
        hseStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
    else
        hseStatus = HSE_STATUS_SUCCESS;

    AssertSz(pecb,
             "HttpExtensionProc(): "
             "NULL extenion control block passed!");

    if (!InterlockedCompareExchange(&g_fTracingInit, 1, 0))
    {
        InitializeDebugging();
        TraceTag(ttidUDHISAPI, "Debugging initialized");
    }

#if DBG
    CHAR    szAddr[256];
    DWORD   cb = sizeof(szAddr);
    pecb->GetServerVariable(pecb->ConnID, "REMOTE_ADDR", (LPVOID)szAddr,
                            &cb);

    TraceTag(ttidUDHISAPI,
             "HttpExtensionProc(): "
             "--------Enter: NEW REQUEST from %s--------", szAddr);
#endif

    // Determine the type of request.

    UPnPRequestTypeFromQueryString(pecb->lpszQueryString,
                                   &urt);

    if (URT_INVALID != urt)
    {
        if (FExistDuplicateHeaders(pecb))
        {
            TraceTag(ttidUDHISAPI,
                     "HttpExtensionProc(): Duplicate headers exist for %s!",
                     pecb->lpszQueryString);

            SendSimpleResponse(pecb, HTTP_STATUS_BAD_REQUEST);
        }
        else
        {
            dwReturn = DwQueryHeader(pecb, "HTTP_HOST", &szaHost);
            if ((dwReturn == ERROR_SUCCESS) && szaHost && *szaHost )
            {
                PFN_UPNP_REQUEST_HANDLER pfnHandler = NULL;

                TraceTag(ttidUDHISAPI,
                         "HttpExtensionProc(): Request type is %d",
                         urt);

                // Valid request type found. Find a handler for it.

                UPnPRequestHandlerFromRequestType(urt, &pfnHandler);

                AssertSz(pfnHandler,
                         "HttpExtensionProc(): "
                         "Got NULL handler function for request type");

                pfnHandler(pecb);
            }
            else
            {
                TraceTag(ttidUDHISAPI, "Host Header is not present");
                pecb->dwHttpStatusCode = HTTP_STATUS_BAD_REQUEST;
                SendSimpleResponse(pecb, HTTP_STATUS_BAD_REQUEST);
            }

            delete[] szaHost;
        }
    }
    else
    {
        TraceTag(ttidUDHISAPI,
                 "HttpExtensionProc(): "
                 "Query string (%s) did not contain a valid request type",
                 pecb->lpszQueryString);

        SendSimpleResponse(pecb, HTTP_STATUS_BAD_REQUEST);
    }

    TraceTag(ttidUDHISAPI,
             "HttpExtensionProc(): Exit, returning %d",
             hseStatus);

    return hseStatus;
}


BOOL WINAPI TerminateExtension(DWORD dwFlags)
{
    if (g_fTracingInit)
    {
        UnInitializeDebugging();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\validatesoap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       V A L I D A T E S O A P . H
//
//  Contents:   Header file for SOAP request validation.
//
//  Notes:
//
//  Author:     spather   2000/11/8
//
//----------------------------------------------------------------------------

#pragma once

#ifndef __VALIDATESOAP_H
#define __VALIDATESOAP_H

HRESULT
HrValidateSOAPRequest(
    IN IXMLDOMNode                 * pxdnReqEnvelope,
    IN LPEXTENSION_CONTROL_BLOCK   pecb,
    IN IUPnPServiceDescriptionInfo * pServiceDescInfo);

HRESULT
HrValidateContentType(
    IN LPEXTENSION_CONTROL_BLOCK   pecb);

#endif // !__VALIDATESOAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Device Host ISAPI Extension"
#define VER_INTERNALNAME_STR            "udhisapi.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\cont\container.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O N T A I N E R . H
//
//  Contents:   Serves as container for device host objects.
//
//  Notes:
//
//  Author:     mbend   6 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "ucres.h"       // main symbols

#include "hostp.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// TestObject
class ATL_NO_VTABLE CContainer :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CContainer, &CLSID_UPnPContainer>,
    public IUPnPContainer
{
public:
    CContainer();
    ~CContainer();

DECLARE_REGISTRY_RESOURCEID(IDR_CONTAINER)

DECLARE_NOT_AGGREGATABLE(CContainer)

BEGIN_COM_MAP(CContainer)
    COM_INTERFACE_ENTRY(IUPnPContainer)
END_COM_MAP()

public:
    // IUPnPContainer methods
    STDMETHOD(CreateInstance)(
        /*[in]*/ REFCLSID clsid,
        /*[in]*/ REFIID riid,
        /*[out, iid_is(riid)]*/ void ** ppv);
    STDMETHOD(Shutdown)();
    STDMETHOD(SetParent)(
        /*[in]*/ DWORD pid);

    static void DoNormalShutdown();
private:
    static HANDLE s_hThreadShutdown;
    static HANDLE s_hEventShutdown;
    static HANDLE s_hProcessDiedWait;
    static HANDLE s_hParentProc;

    static DWORD WINAPI ShutdownThread(void*);
    static VOID WINAPI KillThread(void*, BOOLEAN);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\cont\container.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O N T A I N E R . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     mbend   6 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ucbase.h"
#include "hostp.h"
#include "Container.h"
#include "ComUtility.h"

HANDLE CContainer::s_hThreadShutdown = INVALID_HANDLE_VALUE;
HANDLE CContainer::s_hEventShutdown = INVALID_HANDLE_VALUE;
HANDLE CContainer::s_hProcessDiedWait = INVALID_HANDLE_VALUE;
HANDLE CContainer::s_hParentProc = INVALID_HANDLE_VALUE;

CContainer::CContainer()
{
}

CContainer::~CContainer()
{
}

STDMETHODIMP CContainer::CreateInstance(
    /*[in]*/ REFCLSID clsid,
    /*[in]*/ REFIID riid,
    /*[out, iid_is(riid)]*/ void ** ppv)
{
    HRESULT hr = S_OK;

    hr = HrCoCreateInstanceInprocBase(clsid, riid, ppv);

    TraceHr(ttidError, FAL, hr, FALSE, "CContainer::CreateInstance");
    return hr;
}

STDMETHODIMP CContainer::Shutdown()
{
    HRESULT hr = S_OK;

    s_hEventShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(INVALID_HANDLE_VALUE == s_hEventShutdown)
    {
        hr = HrFromLastWin32Error();
    }

    if(SUCCEEDED(hr))
    {
        s_hThreadShutdown = CreateThread(NULL, 0, &CContainer::ShutdownThread, NULL, 0, NULL);
        if(INVALID_HANDLE_VALUE == s_hThreadShutdown)
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CContainer::Shutdown");
    return hr;
}

STDMETHODIMP CContainer::SetParent(DWORD pid)
{
    HANDLE hParent;
    HANDLE hWait = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    hParent = OpenProcess(SYNCHRONIZE, FALSE, pid);

    if (hParent)
    {
        if (INVALID_HANDLE_VALUE == InterlockedCompareExchangePointer(
            &s_hParentProc, hParent, INVALID_HANDLE_VALUE))
        {
            // we haven't created a kill thread yet
            if (!RegisterWaitForSingleObject(&s_hProcessDiedWait, hParent,
                &CContainer::KillThread, NULL, INFINITE, WT_EXECUTEONLYONCE))
            {
                hr = E_FAIL;
                s_hProcessDiedWait = INVALID_HANDLE_VALUE;
                s_hParentProc = INVALID_HANDLE_VALUE;
                CloseHandle(hParent);
            }
        }
        else
        {
            // we've already create the kill thread
            CloseHandle(hParent);
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }
    return hr;
}

void CContainer::DoNormalShutdown()
{
    SetEvent(s_hEventShutdown);
    WaitForSingleObject(s_hThreadShutdown, 500);
    CloseHandle(s_hThreadShutdown);
}

DWORD WINAPI CContainer::ShutdownThread(void*)
{
    DWORD dwRet = WaitForSingleObject(s_hEventShutdown, 2000);
    if (s_hProcessDiedWait != INVALID_HANDLE_VALUE)
    {
        UnregisterWait(s_hProcessDiedWait);
    }
    if(WAIT_OBJECT_0 == dwRet)
    {
        CloseHandle(s_hEventShutdown);
    }
    else
    {
        CloseHandle(s_hEventShutdown);
        CloseHandle(s_hThreadShutdown);
        ExitProcess(-1);
    }
    return 0;
}

VOID WINAPI CContainer::KillThread(void*, BOOLEAN bTimedOut)
{
    ExitProcess(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\udhisapi\validatesoap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       V A L I D A T E S O A P . C P P
//
//  Contents:   Implementation of SOAP request validation.
//
//  Notes:
//
//  Author:     spather   2000/11/8
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <httpext.h>

#include "hostp.h"
#include "ncxml.h"
#include "ncbase.h"

#include "ValidateSOAP.h"

const WCHAR CSZ_SOAP_NAMESPACE_URI[] =
    L"http://schemas.xmlsoap.org/soap/envelope/";
const WCHAR CSZ_SOAP_ENCODING_STYLE_URI[] =
    L"http://schemas.xmlsoap.org/soap/encoding/";


HRESULT
HrValidateArguments(
    IN  IXMLDOMNode                    * pxdnAction,
    IN  IXMLDOMNodeList                * pxdnlArgs,
    IN  IUPnPServiceDescriptionInfo    * pServiceDescInfo)
{
    HRESULT    hr = S_OK;
    BSTR       bstrActionName = NULL;

    hr = pxdnAction->get_baseName(&bstrActionName);

    if (SUCCEEDED(hr))
    {
        BOOL   fIsQueryStateVariable = FALSE;
        DWORD  cInArgs = 0;
        BSTR   * rgbstrNames = NULL;
        BSTR   * rgbstrTypes = NULL;

        Assert(bstrActionName);

        if (0 == lstrcmpW(bstrActionName, L"QueryStateVariable"))
        {
            fIsQueryStateVariable = TRUE;
            cInArgs = 1;
        }
        else
        {
            fIsQueryStateVariable = FALSE;
            hr = pServiceDescInfo->GetInputArgumentNamesAndTypes(bstrActionName,
                                                                 &cInArgs,
                                                                 &rgbstrNames,
                                                                 &rgbstrTypes);
        }

        if (SUCCEEDED(hr))
        {
            long listLength = 0;

            hr = pxdnlArgs->get_length(&listLength);

            if (SUCCEEDED(hr))
            {
                if ((DWORD)listLength == cInArgs)
                {
                    if (cInArgs > 0)
                    {
                        for (DWORD i = 0; i < cInArgs; i++)
                        {
                            IXMLDOMNode    * pxdnArg = NULL;

                            hr = pxdnlArgs->get_item(i, &pxdnArg);

                            if (SUCCEEDED(hr))
                            {
                                BSTR   bstrArgName = NULL;

                                // Check that the name matches.
                                Assert(pxdnArg);

                                hr = pxdnArg->get_baseName(&bstrArgName);

                                if (SUCCEEDED(hr))
                                {
                                    Assert(bstrArgName);

                                    if (fIsQueryStateVariable)
                                    {
                                        if (0 == lstrcmpiW(bstrArgName,
                                                           L"varName"))

                                        {
                                            hr = S_OK;
                                        }
                                        else
                                        {
                                            hr = E_FAIL;
                                            TraceError("HrValidateArguments(): "
                                                       "Invalid argument name",
                                                       hr);
                                        }
                                    }
                                    else
                                    {
                                        if (0 == lstrcmpiW(bstrArgName,
                                                           rgbstrNames[i]))

                                        {
                                            hr = S_OK;
                                        }
                                        else
                                        {
                                            hr = E_FAIL;
                                            TraceError("HrValidateArguments(): "
                                                       "Invalid argument name",
                                                       hr);
                                        }
                                    }

                                    SysFreeString(bstrArgName);
                                }
                                pxdnArg->Release();
                            }
                            else
                            {
                                TraceError("HrValidateArguments(): "
                                           "Failed to get item",
                                           hr);
                            }
                        }
                    }
                }
                else
                {
                    hr = E_FAIL;
                    TraceError("HrValidateArguments(): "
                               "Wrong number of input arguments in request",
                               hr);
                }

            }
            else
            {
                TraceError("HrValidateArguments(): "
                           "Failed to get list length",
                           hr);
            }

            if (FALSE == fIsQueryStateVariable)
            {
                if (cInArgs > 0)
                {
                    for (DWORD i = 0; i < cInArgs; i++)
                    {
                        SysFreeString(rgbstrNames[i]);
                        rgbstrNames[i] = NULL;
                        SysFreeString(rgbstrTypes[i]);
                        rgbstrTypes[i] = NULL;
                    }
                    CoTaskMemFree(rgbstrNames);
                    rgbstrNames = NULL;
                    CoTaskMemFree(rgbstrTypes);
                    rgbstrTypes = NULL;
                }
            }
        }


        SysFreeString(bstrActionName);
    }
    else
    {
        TraceError("HrValidateArguments(): "
                   "Failed to get action name",
                   hr);
    }

    TraceError("HrValidateArguments(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrValidateActionName(
    IN  IXMLDOMNode    * pxdnAction,
    IN  LPWSTR         szSOAPActionHeader)
{
    HRESULT    hr = S_OK;
    LPWSTR     szStrippedHeader = NULL;
    DWORD      cchSOAPActionHeader = 0;
    LPWSTR     szActionName = NULL;

    cchSOAPActionHeader = lstrlenW(szSOAPActionHeader);

    // Due to bugs in some SOAP implementations (specifically, the URT, not us)
    // the SOAPActionHeader may or may not have double-quotes around it. We'll
    // just remove them here if they are there (they should be, according to
    // the SOAP spec).

    if ((L'"' == szSOAPActionHeader[0]) &&
        (L'"' == szSOAPActionHeader[cchSOAPActionHeader-1]))
    {
        // Modify the string in place - insert a NULL where the close
        // quote is, and start the string 1 character from the beginning.
        // Doing it this way, rather than copying the string saves us 1
        // memory allocation.

        szSOAPActionHeader[cchSOAPActionHeader-1] = UNICODE_NULL;
        szStrippedHeader = szSOAPActionHeader+1;
    }
    else
    {
        szStrippedHeader = szSOAPActionHeader;
    }


    // Check that the action name matches the SOAPAction header.
    // SOAPAction header is of the form servicetype#actionName.

    szActionName = wcsstr(szStrippedHeader, L"#");

    if (szActionName)
    {
        BSTR bstrActionName = NULL;

        szActionName++; // Advance to the character after the "#"

        hr = pxdnAction->get_baseName(&bstrActionName);

        if (S_OK == hr)
        {
            if (0 == lstrcmpiW(bstrActionName, szActionName))
            {
                hr = S_OK;

                TraceTag(ttidValidate,
                         "HrValidateActionName(): "
                         "Action node name and SOAPAction header value match!");
            }
            else
            {
                hr = E_FAIL;
                TraceError("HrValidateActionName(): "
                           "Action node name did not match SOAPAction header",
                           hr);
            }

            SysFreeString(bstrActionName);
        }
        else
        {
            TraceError("HrValidateActionName(): "
                       "Failed to get node name",
                       hr);
        }
    }
    else
    {
        hr = E_FAIL;
        TraceError("HrValidateActionName(): "
                   "SOAPActionHeader did not contain \"#\" character",
                   hr);
    }

    TraceError("HrValidateActionName(): "
               "Exiting",
               hr);
    return hr;
}

HRESULT
HrValidateBody(
    IN  IXMLDOMNode                    * pxdnBody,
    IN  IUPnPServiceDescriptionInfo    * pServiceDescInfo,
    IN  LPWSTR                         szSOAPActionHeader)
{
    HRESULT        hr = S_OK;
    IXMLDOMNode    * pxdnAction = NULL;

    hr = pxdnBody->get_firstChild(&pxdnAction);

    if (SUCCEEDED(hr))
    {
        if (pxdnAction)
        {
            hr = HrValidateActionName(pxdnAction, szSOAPActionHeader);

            if (SUCCEEDED(hr))
            {
                IXMLDOMNodeList    * pxdnlArgs = NULL;

                hr = pxdnAction->get_childNodes(&pxdnlArgs);

                if (SUCCEEDED(hr))
                {
                    Assert(pxdnlArgs);

                    hr = HrValidateArguments(pxdnAction,
                                             pxdnlArgs,
                                             pServiceDescInfo);

                    pxdnlArgs->Release();
                }
            }

            // Finally, if all the above succeeded, check that the
            // action element does not have a sibling (there should
            // only be one child of the body element).

            if (SUCCEEDED(hr))
            {
                IXMLDOMNode    * pxdnSibling = NULL;

                hr = pxdnAction->get_nextSibling(&pxdnSibling);

                if (S_FALSE == hr)
                {
                    Assert(NULL == pxdnSibling);

                    hr = S_OK;

                    TraceTag(ttidValidate,
                             "HrValidateBody(): "
                             "Body is valid!");
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        Assert(pxdnSibling);
                        pxdnSibling->Release();
                        hr = E_FAIL;
                        TraceError("HrValidateBody(): "
                                   "Body element had more than one child",
                                   hr);
                    }
                    else
                    {
                        TraceError("HrValidateBody(): "
                                   "Failure trying to get next sibling",
                                   hr);
                    }

                }
            }

            pxdnAction->Release();
        }
        else
        {
            hr = E_FAIL;
            TraceError("HrValidateBody(): "
                       "Body element was empty",
                       hr);
        }
    }
    else
    {
        TraceError("HrValidateBody(): "
                   "Failed to get first child of body element",
                   hr);
    }

    TraceError("HrValidateBody(): "
               "Exiting",
               hr);
    return hr;
}



HRESULT
HrValidateSOAPHeader(
    IN  IXMLDOMNode    * pxdnHeader)
{
    HRESULT        hr = S_OK;
    IXMLDOMNode    * pxdnChild = NULL;

    // A request may have headers as long as none of them have the
    // "mustUnderstand" attribute set because we don't understand any
    // headers.

    hr = pxdnHeader->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode    * pxdnNextSibling = NULL;
        BSTR           bstrMustUnderstand = NULL;

        hr = HrGetTextValueFromAttribute(pxdnChild,
                                         L"mustUnderstand",
                                         &bstrMustUnderstand);

        if (SUCCEEDED(hr))
        {
            if (NULL == bstrMustUnderstand)
            {
                hr = S_OK;
                TraceTag(ttidValidate,
                         "HrValidateSOAPHeader(): "
                         "Found header without mustUnderstand attribute - ok!");
            }
            else
            {
                if (0 == lstrcmpW(bstrMustUnderstand, L"0"))
                {
                    hr = S_OK;
                    TraceTag(ttidValidate,
                             "HrValidateSOAPHeader(): "
                             "Found header with mustUnderstand "
                             "attribute == 0 - ok!");
                }
                else if (0 == lstrcmpW(bstrMustUnderstand, L"1"))
                {
                    hr = E_FAIL;
                    TraceError("HrValidateSOAPHeader(): "
                               "Found header with mustUnderstand attribute set",
                               hr);
                }
                else
                {
                    hr = E_FAIL;
                    TraceError("HrValidateSOAPHeader(): "
                               "Found header with invalid "
                               "mustUnderstand attribute value",
                               hr);
                }

                SysFreeString(bstrMustUnderstand);
            }
        }
        else
        {
            TraceError("HrValidateSOAPError(): "
                       "Failed to get mustUnderstand attribute value",
                       hr);
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }

    TraceError("HrValidateSOAPHeader(): "
               "Exiting",
               hr);
    return hr;
}



HRESULT
HrValidateSOAPStructure(
    IN  IXMLDOMNode                    * pxdnReqEnvelope,
    IN  IUPnPServiceDescriptionInfo    * pServiceDescInfo,
    IN  LPWSTR                         szSOAPActionHeader)
{
    HRESULT    hr = S_OK;

    if (FIsThisTheNodeNameWithNamespace(pxdnReqEnvelope,
                                        L"Envelope",
                                        CSZ_SOAP_NAMESPACE_URI))
    {
        IXMLDOMNode    * pxdnChild = NULL;
        BOOL           bFoundHeader = FALSE;
        BOOL           bFoundBody = FALSE;


        hr = pxdnReqEnvelope->get_firstChild(&pxdnChild);

        while (SUCCEEDED(hr) && pxdnChild)
        {
            IXMLDOMNode    * pxdnNextSibling = NULL;

            if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                L"Header",
                                                CSZ_SOAP_NAMESPACE_URI))
            {
                if (FALSE == bFoundHeader)
                {
                    bFoundHeader = TRUE;
                    hr = HrValidateSOAPHeader(pxdnChild);
                }
                else
                {
                    hr = E_FAIL;
                    TraceError("HrValidateSOAPStructure(): "
                               "Duplicate header element found",
                               hr);
                }
            }
            else if (FIsThisTheNodeNameWithNamespace(pxdnChild,
                                                     L"Body",
                                                     CSZ_SOAP_NAMESPACE_URI))
            {
                if (FALSE == bFoundBody)
                {
                    bFoundBody = TRUE;
                    hr = HrValidateBody(pxdnChild,
                                        pServiceDescInfo,
                                        szSOAPActionHeader);
                }
                else
                {
                    hr = E_FAIL;
                    TraceError("HrValidateSOAPStructure(): "
                               "Duplicate body element found",
                               hr);
                }
            }
            else
            {
                hr = E_FAIL;
                TraceError("HrValidateSOAPStructure(): "
                           "Unknown element found inside SOAP envelope",
                           hr);
            }

            if (FAILED(hr))
            {
                pxdnChild->Release();
                break;
            }

            hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
            pxdnChild->Release();
            pxdnChild = pxdnNextSibling;
        }

        if (SUCCEEDED(hr))
        {
            if (FALSE == bFoundBody)
            {
                hr = E_FAIL;
                TraceError("HrValidateSOAPStrucutre(): "
                           "Request was missing body element",
                           hr);
            }
            else
            {
                hr = S_OK;
                TraceTag(ttidValidate,
                         "HrValidateSOAPStructure(): "
                         "SOAP structure is valid!");
            }
        }
    }
    else
    {
        hr = E_FAIL;
        TraceError("HrValidateSOAPStructure(): "
                   "Root element is not a SOAP envelope",
                   hr);
    }

    TraceError("HrValidateSOAPStructure(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrGetSOAPActionHeader(
    IN  LPEXTENSION_CONTROL_BLOCK  pecb,
    OUT LPWSTR                     * pszSOAPActionHeader)
{
    HRESULT    hr = S_OK;
    LPWSTR     szSOAPActionHeader = NULL;
    CHAR       * szaBuffer = NULL;
    DWORD      cbBuffer = 0;
    BOOL       bReturn = FALSE;

    // First we need to find the size of buffer we need to get all the HTTP
    // headers.

    bReturn = pecb->GetServerVariable(pecb->ConnID,
                                      "ALL_RAW",
                                      szaBuffer,
                                      &cbBuffer);

    if (FALSE == bReturn)
    {
        DWORD  dwError = 0;

        // Expect to be here - we passed in a null buffer and a zero size,
        // in order to find what the real size should be.

        dwError = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER == dwError)
        {
            Assert(cbBuffer > 0);

            szaBuffer = new CHAR[cbBuffer+1];

            if (szaBuffer)
            {
                bReturn = pecb->GetServerVariable(pecb->ConnID,
                                                  "ALL_RAW",
                                                  szaBuffer,
                                                  &cbBuffer);

                if (bReturn)
                {
                    hr = S_OK;
                    TraceTag(ttidValidate,
                             "HrGetSOAPActionHeader(): "
                             "All HTTP Headers:\n%s", szaBuffer);
                }
                else
                {
                    hr = HrFromLastWin32Error();
                    TraceError("HrGetSOAPActionHeader(): "
                               "Failed to get all HTTP headers",
                               hr);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrGetSOAPActionHeader(): "
                           "Failed to allocate buffer for all HTTP headers",
                           hr);
            }

        }
        else
        {
            hr = HrFromLastWin32Error();
            TraceError("HrGetSOAPActionHeader(): "
                       "Failed to get buffer size for all HTTP headers",
                       hr);
        }
    }
    else
    {
        // Should never be here.

        Assert(FALSE);
    }

    if (SUCCEEDED(hr))
    {
        CHAR   * szaSOAPActionStart = NULL;

        // Convert the buffer to uppercase.
        for (DWORD i = 0; i < cbBuffer; i++)
        {
            szaBuffer[i] = (CHAR) toupper(szaBuffer[i]);
        }

        // Now we need find the SOAPAction header and get it's value.

        szaSOAPActionStart = strstr(szaBuffer, "SOAPACTION:");

        if (szaSOAPActionStart)
        {
            // Count the number of characters in the value of the header.

            DWORD  cbSOAPActionHeader = 0;
            CHAR   * szaSOAPActionValueStart = NULL;
            CHAR   * szaTemp = NULL;

            szaSOAPActionValueStart = szaSOAPActionStart +
                strlen("SOAPACTION:");

            while (' ' == *szaSOAPActionValueStart || '\t' == *szaSOAPActionValueStart)
            {
                szaSOAPActionValueStart++;
            }

            szaTemp = szaSOAPActionValueStart;

            while (('\0' != *szaTemp) &&
                   ('\r' != *szaTemp) &&
                   ('\n' != *szaTemp))
            {
                szaTemp++;
                cbSOAPActionHeader++;
            }

            if (cbSOAPActionHeader > 0)
            {
                CHAR  * szaSOAPActionHeader = NULL;

                szaSOAPActionHeader = new CHAR[cbSOAPActionHeader + 1];

                if (szaSOAPActionHeader)
                {
                    strncpy(szaSOAPActionHeader,
                            szaSOAPActionValueStart,
                            cbSOAPActionHeader);

                    szaSOAPActionHeader[cbSOAPActionHeader] = '\0';

                    szSOAPActionHeader = WszFromSz(szaSOAPActionHeader);

                    if (szSOAPActionHeader)
                    {
                        hr = S_OK;
                        TraceTag(ttidUDHISAPI,
                                 "HrGetSOAPActionHeader(): "
                                 "SOAPAction header value is %S",
                                 szSOAPActionHeader);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrGetSOAPActionHeader(): "
                                   "Failed to allocate memory for "
                                   "wide character SOAPAction header",
                                   hr);
                    }
                    delete [] szaSOAPActionHeader;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("HrGetSOAPActionHeader(): "
                               "Failed to allocate memory for SOAPAction header",
                               hr);
                }
            }
            else
            {
                hr = E_FAIL;
                TraceError("HrGetSOAPActionHeader(): "
                           "SOAPAction header had no value",
                           hr);
            }
        }
        else
        {
            hr = UPNP_E_MISSING_SOAP_ACTION;
            TraceError("HrGetSOAPActionHeader(): "
                       "Could not find SOAPAction header",
                       hr);
        }


    }

    // Cleanup.
    if (szaBuffer)
    {
        delete [] szaBuffer;
        szaBuffer = NULL;
    }

    // Copy the string to the out parameter if succeeded, otherwise
    // clean it up.

    if (SUCCEEDED(hr))
    {
        *pszSOAPActionHeader = szSOAPActionHeader;
    }
    else
    {
        // Cleanup.
        if (szSOAPActionHeader)
        {
            delete [] szSOAPActionHeader;
            szSOAPActionHeader = NULL;
        }
    }

    TraceError("HrGetSOAPActionHeader(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrValidateContentType(
    IN LPEXTENSION_CONTROL_BLOCK   pecb)
{
    HRESULT    hr = S_OK;
    BOOL       bReturn = FALSE;
    const DWORD cdwBufSize = 512;
    CHAR       szaBuffer[cdwBufSize];
    DWORD      cbBuffer = cdwBufSize;
    LPCSTR     cszaExpectedContentType = "text/xml";

    bReturn = pecb->GetServerVariable(pecb->ConnID,
                                      "CONTENT_TYPE",
                                      szaBuffer,
                                      &cbBuffer);

    if (bReturn)
    {
        Assert(cbBuffer <= cdwBufSize);

        if (0 == strncmp(szaBuffer,
                         cszaExpectedContentType,
                         strlen(cszaExpectedContentType)))
        {
            hr = S_OK;
            TraceTag(ttidValidate,
                     "HrValidateContentType(): "
                     "Valid content type %s",
                     szaBuffer);
        }
        else
        {
            hr = UPNP_E_INVALID_CONTENT_TYPE;
            TraceTag(ttidValidate,
                     "HrValidateContentType(): "
                     "Invalid content type %s",
                     szaBuffer);
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
        TraceError("HrValidateContentType(): "
                   "Failed to get content type",
                   hr);
    }

    TraceError("HrValidateContentType(): "
               "Exiting",
               hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrValidateSOAPRequest
//
//  Purpose:    Validates the structure of a SOAP request.
//
//  Arguments:
//      pxdnReqEnvelope  [in] The XML DOM Node for the SOAP envelope element
//      pecb             [in] The extension control block for the request
//      pServiceDescInfo [in] The service description info object for the
//                            service at which the request is targeted
//
//  Returns:
//   If the function succeeds, the return value is S_OK. Otherwise, the
//   function returns one of the COM error codes defined in WinError.h.
//
//  Author:     spather   2000/11/8
//
//  Notes:
//

HRESULT
HrValidateSOAPRequest(
    IN IXMLDOMNode                 * pxdnReqEnvelope,
    IN LPEXTENSION_CONTROL_BLOCK   pecb,
    IN IUPnPServiceDescriptionInfo * pServiceDescInfo)
{
    HRESULT    hr = S_OK;

    Assert(pxdnReqEnvelope);
    Assert(pecb);
    Assert(pServiceDescInfo);

    hr = HrValidateContentType(pecb);

    if (SUCCEEDED(hr))
    {
        LPWSTR szSOAPActionHeader = NULL;

        hr = HrGetSOAPActionHeader(pecb, &szSOAPActionHeader);

        if (SUCCEEDED(hr))
        {
            Assert(szSOAPActionHeader);

            hr = HrValidateSOAPStructure(pxdnReqEnvelope,
                                         pServiceDescInfo,
                                         szSOAPActionHeader);

            delete [] szSOAPActionHeader;
        }
    }

    if (E_FAIL == hr)
    {
        hr = UPNP_E_BAD_REQUEST;
    }

    TraceError("HrValidateSOAPRequest(): "
               "Exiting",
               hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\dll\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

//#pragma comment(lib, "rpcndr.lib")
//#pragma comment(lib, "rpcns4.lib")
//#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "hostp_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    return TRUE;
}

STDAPI
PrxDllCanUnloadNow ()
{
    return S_OK;
}

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI
PrxDllRegisterServer ()
{
    return S_OK;
}

STDAPI
PrxDllUnregisterServer ()
{
    return S_OK;
}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\dll\dllpubdatax.c ===
#include "public_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Device Host Container"
#define VER_INTERNALNAME_STR            "upnpcont.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\dll\dlldatax.h ===
#pragma once

#ifdef _MERGE_PROXYSTUB

extern "C"
{

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved);

STDAPI
PrxDllCanUnloadNow ();

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv);

STDAPI
PrxDllRegisterServer ();

STDAPI
PrxDllUnregisterServer ();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

//#pragma comment(lib, "rpcndr.lib")
//#pragma comment(lib, "rpcns4.lib")
//#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "hostp_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    return TRUE;
}

STDAPI
PrxDllCanUnloadNow ()
{
    return S_OK;
}

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI
PrxDllRegisterServer ()
{
    return S_OK;
}

STDAPI
PrxDllUnregisterServer ()
{
    return S_OK;
}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   DLL entry points for upnpcont.dll
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ucres.h"

#include "ucbase.h"
#include "hostp.h"
#include "hostp_i.c"

// Headers of COM objects
#include "Container.h"

//#define INITGUID
//#include "uhclsid.h"

//+---------------------------------------------------------------------------
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for foo.idl by adding the following
//      files to the Outputs.
//          foo_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f foops.mk in the project directory.

// Proxy/Stub registration entry points
//
#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPContainer, CContainer)
END_OBJECT_MAP()

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
        return FALSE;
    }
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        InitializeDebugging();

        _Module.Init(ObjectMap, hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("netshell.dll", _Module.GetLockCount());

        _Module.Term();

        UnInitializeDebugging();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI
DllCanUnloadNow ()
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }
#endif

    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
// Returns a class factory to create an object of the requested type
//
STDAPI
DllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}


//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
#ifdef _MERGE_PROXYSTUB
        hr = PrxDllRegisterServer ();
        if (FAILED(hr))
        {
            goto Exit;
        }
#endif

        hr = _Module.RegisterServer();

Exit:
        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netshell!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer ();
#endif

    _Module.UnregisterServer ();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\dlldatax.h ===
#pragma once

#ifdef _MERGE_PROXYSTUB

extern "C"
{

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved);

STDAPI
PrxDllCanUnloadNow ();

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv);

STDAPI
PrxDllRegisterServer ();

STDAPI
PrxDllUnregisterServer ();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\exe\main.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   DLL entry points for upnpcont.dll
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ucres.h"

#include "ucbase.h"
#include "hostp.h"
#include "hostp_i.c"

// Headers of COM objects
#include "Container.h"


CServerAppModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPContainer, CContainer)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//
extern "C" 
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    HRESULT hr = S_OK;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    TraceHr(ttidError, FAL, hr, FALSE, "WinMain - CoInitializeEx failed!");
    if(SUCCEEDED(hr))
    {
        hr = CoInitializeSecurity(
            NULL,
            -1,
            NULL,
            NULL,
            RPC_C_AUTHN_LEVEL_CONNECT,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,
            0,
            NULL);
    }

    _Module.Init(ObjectMap, hInstance);

    BOOL bRun = _Module.ParseCommandLine(lpCmdLine, L"{4F0AC159-5804-4aa7-AE91-117D6E67BB9B}", &hr);

    if (bRun)
    {
        _Module.StartMonitor();
        hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_SINGLEUSE | REGCLS_SUSPENDED);
        TraceHr(ttidError, FAL, hr, FALSE, "_Module.RegisterClassObjects failed!");
        hr = CoResumeClassObjects();
        TraceHr(ttidError, FAL, hr, FALSE, "CoResumeClassObjects failed");

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();

        // Terminate the shutdown thread
        CContainer::DoNormalShutdown();
    }

    _Module.Term();
    CoUninitialize();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\inc\ucbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U C B A S E . H 
//
//  Contents:   Base include file for upnpcont.dll. Global defines.
//
//  Notes:      
//
//  Author:     mbend   16 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
#include <atlapp.h>
extern CServerAppModule _Module;
#include <atlcom.h>

#include "ncatl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\dllpubdatax.c ===
#include "public_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\inc\ucres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U C R E S . H
//
//  Contents:   Master resource header for upnpcont.dll
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
//#define IDS_INBOUND_CONFIG_CONNECTION_NAME  100


//+---------------------------------------------------------------------------
// Registry resources
//
#define IDR_CONTAINER   100
#define IDR_UPNPCONT    101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpcont\exe\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Device Host Container"
#define VER_INTERNALNAME_STR            "upnpcont.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\automationproxy\automationproxy.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       A U T O M A T I O N P R O X Y . C P P
//
//  Contents:   Implementation of the Automation Proxy class
//
//  Notes:
//
//  Author:     spather   2000/09/25
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <msxml2.h>

#include "uhbase.h"
#include "AutomationProxy.h"

#include "ncstring.h"
#include "ncxml.h"
#include "ComUtility.h"
#include "uhcommon.h"

CUPnPAutomationProxy::CUPnPAutomationProxy()
{
    m_fInitialized = FALSE;
    m_pdispService = NULL;
    m_cVariables = 0;
    m_cEventedVariables = 0;
    m_rgVariables = NULL;
    m_cActions = 0;
    m_rgActions = NULL;
    m_wszServiceType = NULL;
}

CUPnPAutomationProxy::~CUPnPAutomationProxy()
{
    if (m_pdispService)
    {
        m_pdispService->Release();
    }

    FreeVariableTable();

    FreeActionTable();

    if (m_wszServiceType)
    {
        delete[] m_wszServiceType;
    }

    m_fInitialized = FALSE;
}

// ATL methods
HRESULT
CUPnPAutomationProxy::FinalConstruct()
{
    return S_OK;
}


HRESULT
CUPnPAutomationProxy::FinalRelease()
{
    return S_OK;
}


STDMETHODIMP
CUPnPAutomationProxy::Initialize(
    /*[in]*/   IUnknown    * punkSvcObject,
    /*[in]*/   LPWSTR      pszSvcDescription,
    /*[in]*/   LPWSTR      pszSvcType,
    /*[in]*/   BOOL        bRunning)
{
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if (FAILED(hr))
    {
        TraceError("HrIsAllowedCOMCallLocality failed !",hr);
        goto Cleanup;
    }


    Assert(!m_fInitialized);
    Assert(pszSvcType);

        
    if (punkSvcObject)
    {
        m_wszServiceType = WszDupWsz(pszSvcType);

        if (m_wszServiceType)
        {
            hr = punkSvcObject->QueryInterface(IID_IDispatch,
                                               (void **) &m_pdispService);

            if(SUCCEEDED(hr))
            {
                if(bRunning)
                {
                    hr = HrCopyProxyIdentity(m_pdispService, punkSvcObject);
                }
            }
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidAutomationProxy,
                         "CUPnPAutomationProxy::Initialize(): "
                         "Successfully obtained IDispatch pointer on service");

                hr = HrProcessServiceDescription(pszSvcDescription);
            }

            if (SUCCEEDED(hr))
            {
                m_fInitialized = TRUE;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::Initialize - Unable to allocate service type!",
                       hr);
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceError("CUPnPAutomationProxy::Initialize - NULL service object!",
                   hr);
    }

Cleanup:

    TraceError("CUPnPAutomationProxy::Initialize(): "
               "Exiting",
               hr);
    return hr;
}


STDMETHODIMP
CUPnPAutomationProxy::GetDispIdsOfEventedVariables(
    /*[out]*/   DWORD   * pcEventedVars,
    /*[out]*/   DISPID  ** prgdispidEventedVars)
{
    HRESULT    hr = S_OK;
    DISPID     * rgdispidEventedVars = NULL;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if (FAILED(hr))
    {
        TraceError("HrIsAllowedCOMCallLocality failed !",hr);
        goto Cleanup;
    }

    Assert(m_fInitialized);

    if (prgdispidEventedVars && (m_cEventedVariables > 0))
    {
        rgdispidEventedVars = (DISPID *) CoTaskMemAlloc(m_cEventedVariables *
                                                        sizeof(DISPID));

        if (rgdispidEventedVars)
        {
            ZeroMemory(rgdispidEventedVars,
                       m_cEventedVariables * sizeof(DISPID));

            for (DWORD i = 0, j = 0; i < m_cVariables; i++)
            {
                if (FALSE == m_rgVariables[i].fNonEvented)
                {
                    rgdispidEventedVars[j] = m_rgVariables[i].dispid;
                    j++;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::GetDispIdsOfEventedVariables(): "
                       "Could not allocate array of dispids",
                       hr);
        }

    }

    if (SUCCEEDED(hr))
    {
        if (pcEventedVars)
        {
            *pcEventedVars = m_cEventedVariables;
        }

        if (prgdispidEventedVars)
        {
            *prgdispidEventedVars = rgdispidEventedVars;
        }
    }

Cleanup:

    TraceError("CUPnPAutomationProxy::GetDispIdsOfEventedVariables(): "
               "Exiting",
               hr);
    return hr;
}


STDMETHODIMP
CUPnPAutomationProxy::QueryStateVariablesByDispIds(
    /*[in]*/   DWORD       cDispIds,
    /*[in]*/   DISPID      * rgDispIds,
    /*[out]*/  DWORD       * pcVariables,
    /*[out]*/  LPWSTR      ** prgszVariableNames,
    /*[out]*/  VARIANT     ** prgvarVariableValues,
    /*[out]*/  LPWSTR      ** prgszVariableDataTypes)
{
    HRESULT hr = S_OK;
    DWORD   cDispIdsToLookUp;
    DISPID  * rgDispIdsToLookUp;
    LPWSTR  * rgszVariableNames = NULL;
    VARIANT * rgvarVariableValues = NULL;
    LPWSTR  * rgszVariableDataTypes = NULL;
    DWORD   cVariables = 0;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if (FAILED(hr))
    {
        TraceError("HrIsAllowedCOMCallLocality failed !",hr);
        goto Cleanup;
    }

    Assert(m_fInitialized);


    if (0 == cDispIds)
    {
        // This means return all variables. Make an array of all our dispids.
        cDispIdsToLookUp = m_cVariables;
        rgDispIdsToLookUp = new DISPID[cDispIdsToLookUp];

        if (rgDispIdsToLookUp)
        {
            for (DWORD i = 0; i < cDispIdsToLookUp; i++)
            {
                rgDispIdsToLookUp[i] = m_rgVariables[i].dispid;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::"
                       "QueryStateVariablesByDispIds(): "
                       "Could not allocate array of dispids",
                       hr);
        }
    }
    else
    {
        cDispIdsToLookUp = cDispIds;
        rgDispIdsToLookUp = rgDispIds;
    }

    if (SUCCEEDED(hr))
    {
        // Allocate output arrays of size cDispIds.

        rgszVariableNames = (LPWSTR *)CoTaskMemAlloc(
            cDispIdsToLookUp * sizeof(LPWSTR));
        rgvarVariableValues = (VARIANT *)CoTaskMemAlloc(
            cDispIdsToLookUp * sizeof(VARIANT));
        rgszVariableDataTypes = (LPWSTR *)CoTaskMemAlloc(
            cDispIdsToLookUp * sizeof(LPWSTR));

        // Fill in values.

        if (rgszVariableNames && rgvarVariableValues && rgszVariableDataTypes)
        {
            ZeroMemory(rgszVariableNames, cDispIdsToLookUp * sizeof(LPWSTR));
            ZeroMemory(rgvarVariableValues, cDispIdsToLookUp * sizeof(VARIANT));
            ZeroMemory(rgszVariableDataTypes, cDispIdsToLookUp * sizeof(LPWSTR));

            for (DWORD i = 0; SUCCEEDED(hr) && (i < cDispIdsToLookUp); i++)
            {
                UPNP_STATE_VARIABLE    * pVariable = NULL;

                cVariables++;

                pVariable = LookupVariableByDispID(rgDispIdsToLookUp[i]);

                if (pVariable)
                {
                    rgszVariableNames[i] = COMSzFromWsz(pVariable->bstrName);
                    rgszVariableDataTypes[i] = COMSzFromWsz(pVariable->bstrDataType);

                    if (rgszVariableNames[i] && rgszVariableDataTypes[i])
                    {
                        UINT uArgErr = 0;
                        DISPPARAMS dispparamsEmpty = {NULL, NULL, 0, 0};

                        hr = m_pdispService->Invoke(rgDispIdsToLookUp[i],
                                                    IID_NULL,
                                                    LOCALE_SYSTEM_DEFAULT,
                                                    DISPATCH_PROPERTYGET,
                                                    &dispparamsEmpty,
                                                    &rgvarVariableValues[i],
                                                    NULL,
                                                    &uArgErr);

                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidAutomationProxy,
                                     "CUPnPAutomationProxy::"
                                     "QueryStateVariablesByDispIds(): "
                                     "Successfully obtained value for "
                                     "dispid %d",
                                     rgDispIdsToLookUp[i]);
                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::"
                                       "QueryStateVariablesByDispIds(): "
                                       "IDispatch::Invoke failed",
                                       hr);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("CUPnPAutomationProxy::"
                                   "QueryStateVariablesByDispIds(): "
                                   "Could not allocate name/data type strings",
                                   hr);
                    }
                }
                else
                {
                    hr = DISP_E_MEMBERNOTFOUND;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::"
                       "QueryStateVariablesByDispIds(): "
                       "Could not allocate output arrays",
                       hr);
        }
    }


    // Copy the output arrays to the out parameters.
    if (SUCCEEDED(hr))
    {
        *pcVariables = cVariables;
        *prgszVariableNames = rgszVariableNames;
        *prgvarVariableValues = rgvarVariableValues;
        *prgszVariableDataTypes = rgszVariableDataTypes;
    }
    else
    {
        // Clean up. Assume cVariables accurately describes the number
        // of initialized items in the arrays.

        if (rgszVariableNames)
        {
            for (DWORD i = 0; i < cVariables; i++)
            {
                if (rgszVariableNames[i])
                {
                    CoTaskMemFree(rgszVariableNames[i]);
                    rgszVariableNames[i] = NULL;
                }
            }

            CoTaskMemFree(rgszVariableNames);
            rgszVariableNames = NULL;
        }

        if (rgvarVariableValues)
        {
            for (DWORD i = 0; i < cVariables; i++)
            {
                VariantClear(&rgvarVariableValues[i]);
            }

            CoTaskMemFree(rgvarVariableValues);
            rgvarVariableValues = NULL;
        }

        if (rgszVariableDataTypes)
        {
            for (DWORD i = 0; i < cVariables; i++)
            {
                if (rgszVariableDataTypes[i])
                {
                    CoTaskMemFree(rgszVariableDataTypes[i]);
                    rgszVariableDataTypes[i] = NULL;
                }
            }

            CoTaskMemFree(rgszVariableDataTypes);
            rgszVariableDataTypes = NULL;
        }
    }

    // Clean up custom array of dispIds if we have one.

    if (rgDispIdsToLookUp != rgDispIds)
    {
        delete [] rgDispIdsToLookUp;
        rgDispIdsToLookUp = NULL;
        cDispIdsToLookUp = 0;
    }

Cleanup:

    TraceError("CUPnPAutomationProxy::"
               "QueryStateVariablesByDispIds(): "
               "Exiting",
               hr);

    return hr;
}


STDMETHODIMP
CUPnPAutomationProxy::ExecuteRequest(
    /*[in]*/   UPNP_CONTROL_REQUEST    * pucreq,
    /*[out]*/  UPNP_CONTROL_RESPONSE   * pucresp)
{
    HRESULT hr = S_OK;

    Assert(m_fInitialized);

    if (lstrcmpW(pucreq->bstrActionName, L"QueryStateVariable") == 0)
    {
        hr = HrQueryStateVariable(pucreq, pucresp);
    }
    else
    {
        hr = HrInvokeAction(pucreq, pucresp);
    }

    TraceError("CUPnPAutomationProxy::ExecuteRequest(): "
               "Exiting",
               hr);

    return hr;
}

STDMETHODIMP
CUPnPAutomationProxy::GetVariableType(
    /*[in]*/   LPWSTR      pszVarName,
    /*[out]*/  BSTR        * pbstrType)
{
    HRESULT                hr = S_OK;
    BSTR                   bstrType = NULL;
    UPNP_STATE_VARIABLE    * pusv = NULL;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if (FAILED(hr))
    {
        TraceError("HrIsAllowedCOMCallLocality failed !",hr);
        goto Cleanup;
    }

    Assert(m_fInitialized);


    pusv = LookupVariableByName(pszVarName);

    if (pusv)
    {
        Assert(pusv->bstrDataType);
        bstrType = SysAllocString(pusv->bstrDataType);
    }
    else
    {
        hr = E_INVALIDARG;
    }


    if (SUCCEEDED(hr))
    {
        *pbstrType = bstrType;
    }
    else
    {
        if (bstrType)
        {
            SysFreeString(bstrType);
            bstrType = NULL;
        }
    }

Cleanup:

    TraceError("CUPnPAutomationProxy::GetVariableType(): "
               "Exiting",
               hr);

    return hr;
}

STDMETHODIMP
CUPnPAutomationProxy::GetServiceType(
    /*[out]*/   LPWSTR * pszServiceType)
{
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if (FAILED(hr))
    {
        TraceError("HrIsAllowedCOMCallLocality failed !",hr);
        goto Cleanup;
    }


    *pszServiceType = (LPWSTR)CoTaskMemAlloc(CbOfSzAndTerm(m_wszServiceType));
    if (*pszServiceType)
    {
        lstrcpy(*pszServiceType, m_wszServiceType);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:

    return hr;
}

STDMETHODIMP
CUPnPAutomationProxy::GetInputArgumentNamesAndTypes(
    /*[in]*/   LPWSTR      pszActionName,
    /*[out]*/  DWORD       * pcInArguments,
    /*[out]*/  BSTR        ** prgbstrNames,
    /*[out]*/  BSTR        ** prgbstrTypes)
{
    HRESULT        hr = S_OK;
    DWORD          cInArguments = 0;
    BSTR           * rgbstrNames = NULL;
    BSTR           * rgbstrTypes = NULL;
    UPNP_ACTION    * pua = NULL;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if (FAILED(hr))
    {
        TraceError("HrIsAllowedCOMCallLocality failed !",hr);
        goto Cleanup;
    }

    Assert(m_fInitialized);

    pua = LookupActionByName(pszActionName);

    if (pua)
    {
        // Allocate arrays for the names and data types.
        cInArguments = pua->cInArgs;

        if (cInArguments > 0)
        {
            rgbstrNames = (BSTR *) CoTaskMemAlloc(cInArguments * sizeof(BSTR));
            rgbstrTypes = (BSTR *) CoTaskMemAlloc(cInArguments * sizeof(BSTR));

            if (rgbstrNames && rgbstrTypes)
            {
                for (DWORD i = 0; SUCCEEDED(hr) && (i < cInArguments); i++)
                {
                    UPNP_STATE_VARIABLE    * pusvRelated = NULL;

                    rgbstrNames[i] = SysAllocString(pua->rgInArgs[i].bstrName);

                    pusvRelated = pua->rgInArgs[i].pusvRelated;

                    Assert(pusvRelated);

                    rgbstrTypes[i] = SysAllocString(pusvRelated->bstrDataType);

                    if (rgbstrNames[i] && rgbstrTypes[i])
                    {
                        TraceTag(ttidAutomationProxy,
                                 "CUPnPAutomationProxy::"
                                 "GetInputArgumentNamesAndTypes(): "
                                 "Successfully copied input argument %S "
                                 "of type %S",
                                 rgbstrNames[i],
                                 rgbstrTypes[i]);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("CUPnPAutomationProxy::"
                                   "GetInputArgumentNamesAndTypes(): "
                                   "Failed to allocate argument name and/or type",
                                   hr);
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPAutomationProxy::"
                           "GetInputArgumentNamesAndTypes(): "
                           "Failed to allocate output arrays",
                           hr);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceError("CUPnPAutomationProxy::"
                   "GetIntputArgumentNamesAndTypes(): "
                   "No such action",
                   hr);
    }

    // If successful, copy to the output, otherwise, clean up.
    if (SUCCEEDED(hr))
    {
        *pcInArguments = cInArguments;
        *prgbstrNames = rgbstrNames;
        *prgbstrTypes = rgbstrTypes;
    }
    else
    {
        if (rgbstrNames)
        {
            for (DWORD i = 0; i < cInArguments; i++)
            {
                if (rgbstrNames[i])
                {
                    SysFreeString(rgbstrNames[i]);
                    rgbstrNames[i] = NULL;
                }
            }
            CoTaskMemFree(rgbstrNames);
            rgbstrNames = NULL;
        }

        if (rgbstrTypes)
        {
            for (DWORD i = 0; i < cInArguments; i++)
            {
                if (rgbstrTypes[i])
                {
                    SysFreeString(rgbstrTypes[i]);
                    rgbstrTypes[i] = NULL;
                }
            }
            CoTaskMemFree(rgbstrTypes);
            rgbstrTypes = NULL;
        }

        cInArguments = 0;
    }

Cleanup:

    TraceError("CUPnPAutomationProxy::GetInputArgumentNamesAndTypes(): "
               "Exiting",
               hr);

    return hr;
}


STDMETHODIMP
CUPnPAutomationProxy::GetOutputArgumentNamesAndTypes(
    /*[in]*/   LPWSTR      pszActionName,
    /*[out]*/  DWORD       * pcOutArguments,
    /*[out]*/  BSTR        ** prgbstrNames,
    /*[out]*/  BSTR        ** prgbstrTypes)
{
    HRESULT        hr = S_OK;
    DWORD          cOutArguments = 0;
    BSTR           * rgbstrNames = NULL;
    BSTR           * rgbstrTypes = NULL;
    UPNP_ACTION    * pua = NULL;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if (FAILED(hr))
    {
        TraceError("HrIsAllowedCOMCallLocality failed !",hr);
        goto Cleanup;
    }

    Assert(m_fInitialized);

    pua = LookupActionByName(pszActionName);

    if (pua)
    {
        // Allocate arrays for the names and data types.
        cOutArguments = pua->cOutArgs;

        if (cOutArguments > 0)
        {
            rgbstrNames = (BSTR *) CoTaskMemAlloc(cOutArguments * sizeof(BSTR));
            rgbstrTypes = (BSTR *) CoTaskMemAlloc(cOutArguments * sizeof(BSTR));

            if (rgbstrNames && rgbstrTypes)
            {
                for (DWORD i = 0; SUCCEEDED(hr) && (i < cOutArguments); i++)
                {
                    UPNP_STATE_VARIABLE    * pusvRelated = NULL;

                    rgbstrNames[i] = SysAllocString(pua->rgOutArgs[i].bstrName);

                    pusvRelated = pua->rgOutArgs[i].pusvRelated;

                    Assert(pusvRelated);

                    rgbstrTypes[i] = SysAllocString(pusvRelated->bstrDataType);

                    if (rgbstrNames[i] && rgbstrTypes[i])
                    {
                        TraceTag(ttidAutomationProxy,
                                 "CUPnPAutomationProxy::"
                                 "GetOutputArgumentNamesAndTypes(): "
                                 "Successfully copied output argument %S "
                                 "of type %S",
                                 rgbstrNames[i],
                                 rgbstrTypes[i]);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("CUPnPAutomationProxy::"
                                   "GetOutputArgumentNamesAndTypes(): "
                                   "Failed to allocate argument name and/or type",
                                   hr);
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPAutomationProxy::"
                           "GetOutputArgumentNamesAndTypes(): "
                           "Failed to allocate output arrays",
                           hr);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceError("CUPnPAutomationProxy::"
                   "GetOutputArgumentNamesAndTypes(): "
                   "No such action",
                   hr);
    }

    // If successful, copy to the output, otherwise, clean up.
    if (SUCCEEDED(hr))
    {
        *pcOutArguments = cOutArguments;
        *prgbstrNames = rgbstrNames;
        *prgbstrTypes = rgbstrTypes;
    }
    else
    {
        if (rgbstrNames)
        {
            for (DWORD i = 0; i < cOutArguments; i++)
            {
                if (rgbstrNames[i])
                {
                    SysFreeString(rgbstrNames[i]);
                    rgbstrNames[i] = NULL;
                }
            }
            CoTaskMemFree(rgbstrNames);
            rgbstrNames = NULL;
        }

        if (rgbstrTypes)
        {
            for (DWORD i = 0; i < cOutArguments; i++)
            {
                if (rgbstrTypes[i])
                {
                    SysFreeString(rgbstrTypes[i]);
                    rgbstrTypes[i] = NULL;
                }
            }
            CoTaskMemFree(rgbstrTypes);
            rgbstrTypes = NULL;
        }

        cOutArguments = 0;
    }

    TraceError("CUPnPAutomationProxy::GetOutputArgumentNamesAndTypes(): "
               "Exiting",
               hr);

Cleanup:

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CUPnPAutomationProxy::FreeVariable
//
//  Purpose:    Frees resources used by a state variable structure
//
//  Arguments:
//      pVariable [in] Address of the structure to free
//
//  Returns:
//   (none)
//
//  Author:     spather   2000/09/26
//
//  Notes:
//   This frees only the memory used by the fields of the structure, not
//   the structure itself.
//
VOID
CUPnPAutomationProxy::FreeVariable(UPNP_STATE_VARIABLE * pVariable)
{
    if (pVariable->bstrName)
    {
        SysFreeString(pVariable->bstrName);
        pVariable->bstrName = NULL;
    }

    if (pVariable->bstrDataType)
    {
        SysFreeString(pVariable->bstrDataType);
        pVariable->bstrDataType = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPAutomationProxy::FreeAction
//
//  Purpose:    Frees resources used by an action structure
//
//  Arguments:
//      pAction [in] Address of the structure to free
//
//  Returns:
//   (none)
//
//  Author:     spather   2000/09/26
//
//  Notes:
//   This frees only the memory used by the fields of the structure, not
//   the structure itself.
//
VOID
CUPnPAutomationProxy::FreeAction(UPNP_ACTION * pAction)
{
    if (pAction->bstrName)
    {
        SysFreeString(pAction->bstrName);
        pAction->bstrName = NULL;
    }

    if (pAction->rgInArgs)
    {
        for (DWORD i = 0; i < pAction->cInArgs; i++)
        {
            FreeArgument(&pAction->rgInArgs[i]);
        }
        delete [] pAction->rgInArgs;
        pAction->rgInArgs = NULL;
    }
    pAction->cInArgs = 0;

    if (pAction->rgOutArgs)
    {
        for (DWORD i = 0; i < pAction->cOutArgs; i++)
        {
            FreeArgument(&pAction->rgOutArgs[i]);
        }
        delete [] pAction->rgOutArgs;
        pAction->rgOutArgs = NULL;
    }
    pAction->cOutArgs = 0;
    pAction->puaRetVal = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPAutomationProxy::FreeArgument
//
//  Purpose:    Frees resources used by an argument structure
//
//  Arguments:
//      pArg [in] Address of the structure to free
//
//  Returns:
//   (none)
//
//  Author:     spather   2000/09/26
//
//  Notes:
//   This frees only the memory used by the fields of the structure, not
//   the structure itself.
//
VOID
CUPnPAutomationProxy::FreeArgument(UPNP_ARGUMENT * pArg)
{
    if (pArg->bstrName)
    {
        SysFreeString(pArg->bstrName);
        pArg->bstrName = NULL;
    }
    pArg->pusvRelated = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPAutomationProxy::FreeVariableTable
//
//  Purpose:    Frees the Automation Proxy object's variable table.
//
//  Arguments:
//      (none)
//
//  Returns:
//      (none)
//
//  Author:     spather   2000/09/26
//
//  Notes:
//
VOID
CUPnPAutomationProxy::FreeVariableTable()
{
    for (DWORD i = 0; i < m_cVariables; i++)
    {
        FreeVariable(&m_rgVariables[i]);
    }
    delete [] m_rgVariables;
    m_rgVariables = NULL;
    m_cVariables = 0;
    m_cEventedVariables = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPAutomationProxy::FreeVariableTable
//
//  Purpose:    Frees the Automation Proxy object's action table.
//
//  Arguments:
//      (none)
//
//  Returns:
//      (none)
//
//  Author:     spather   2000/09/26
//
//  Notes:
//

VOID
CUPnPAutomationProxy::FreeActionTable()
{
    for (DWORD i = 0; i < m_cActions; i++)
    {
        FreeAction(&m_rgActions[i]);
    }
    delete [] m_rgActions;
    m_rgActions = NULL;
    m_cActions = 0;
}


VOID
CUPnPAutomationProxy::FreeControlResponse(
    UPNP_CONTROL_RESPONSE * pucresp)
{
    if (pucresp->bstrActionName)
    {
        SysFreeString(pucresp->bstrActionName);
        pucresp->bstrActionName = NULL;
    }

    UPNP_CONTROL_RESPONSE_DATA * pucrd = &pucresp->ucrData;

    if (pucresp->fSucceeded)
    {
        if (pucrd->Success.rgvarOutputArgs)
        {
            for (DWORD i = 0; i < pucrd->Success.cOutputArgs; i++)
            {
                VariantClear(&pucrd->Success.rgvarOutputArgs[i]);
            }

            CoTaskMemFree(pucrd->Success.rgvarOutputArgs);
            pucrd->Success.rgvarOutputArgs = NULL;
            pucrd->Success.cOutputArgs = 0;
        }
    }
    else
    {
        if (pucrd->Fault.bstrFaultCode)
        {
            SysFreeString(pucrd->Fault.bstrFaultCode);
            pucrd->Fault.bstrFaultCode = NULL;
        }

        if (pucrd->Fault.bstrFaultString)
        {
            SysFreeString(pucrd->Fault.bstrFaultString);
            pucrd->Fault.bstrFaultString = NULL;
        }

        if (pucrd->Fault.bstrUPnPErrorCode)
        {
            SysFreeString(pucrd->Fault.bstrUPnPErrorCode);
            pucrd->Fault.bstrUPnPErrorCode = NULL;
        }

        if (pucrd->Fault.bstrUPnPErrorString)
        {
            SysFreeString(pucrd->Fault.bstrUPnPErrorString);
            pucrd->Fault.bstrUPnPErrorString = NULL;
        }
    }
}

HRESULT
CUPnPAutomationProxy::HrProcessServiceDescription(
    IN LPWSTR  pszSvcDescription)
{
    HRESULT            hr = S_OK;
    IXMLDOMDocument    * pxddSvcDesc = NULL;

    TraceTag(ttidAutomationProxy,
             "CUPnPAutomationProxy::"
             "HrProcessServiceDescription(): "
             "Processing service description:\n"
             "%S",
             pszSvcDescription);

    hr = CoCreateInstance(CLSID_DOMDocument30,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IXMLDOMDocument,
                          (void **) &pxddSvcDesc);

    if (SUCCEEDED(hr))
    {
        BSTR bstrSvcDesc = NULL;

        Assert(pxddSvcDesc);

        bstrSvcDesc = SysAllocString(pszSvcDescription);

        if (bstrSvcDesc)
        {
            hr = pxddSvcDesc->put_async(VARIANT_FALSE);

            if (SUCCEEDED(hr))
            {
                VARIANT_BOOL vbSuccess = VARIANT_FALSE;

                pxddSvcDesc->put_resolveExternals(VARIANT_FALSE);
                hr = pxddSvcDesc->loadXML(bstrSvcDesc, &vbSuccess);

                if (SUCCEEDED(hr) && (VARIANT_TRUE == vbSuccess))
                {
                    IXMLDOMElement * pxdeRoot = NULL;

                    hr = pxddSvcDesc->get_documentElement(&pxdeRoot);

                    if (S_OK == hr)
                    {
                        Assert(pxdeRoot);

                        hr = HrValidateServiceDescription(pxdeRoot);

                        if (SUCCEEDED(hr))
                        {
                            hr = HrBuildTablesFromServiceDescription(pxdeRoot);

                            if (SUCCEEDED(hr))
                            {
                                TraceTag(ttidAutomationProxy,
                                         "CUPnPAutomationProxy::"
                                         "HrProcessServiceDescription(): "
                                         "Successfully built tables from "
                                         "service description",
                                         hr);
                            }
                            else
                            {
                                TraceError("CUPnPAutomationProxy::"
                                           "HrProcessServiceDescription(): "
                                           "Could not build tables from "
                                           "service description",
                                           hr);
                            }
                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::"
                                       "HrProcessServiceDescription(): "
                                       "Could not validate service "
                                       "description",
                                       hr);
                        }

                        pxdeRoot->Release();
                    }
                    else
                    {
                        TraceError("CUPnPAutomationProxy::"
                                   "HrProcessServiceDescription(): "
                                   "Could not get document element",
                                   hr);
                    }
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::"
                               "HrProcessServiceDescription(): "
                               "Failed to load XML",
                               hr);
                }
            }
            else
            {
                TraceError("CUPnPAutomationProxy::"
                           "HrProcessServiceDescription(): "
                           "Could not set async property",
                           hr);
            }



            SysFreeString(bstrSvcDesc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::HrProcessServiceDescription(): "
                       "Could not allocate BSTR service description",
                       hr);
        }

        pxddSvcDesc->Release();
    }
    else
    {
        TraceError("CUPnPAutomationProxy::HrProcessServiceDescription(): "
                   "Could not create DOM document",
                   hr);
    }

    TraceError("CUPnPAutomationProxy::HrProcessServiceDescription(): "
               "Exiting",
               hr);

    return hr;
}

HRESULT
CUPnPAutomationProxy::HrValidateServiceDescription(
    IXMLDOMElement * pxdeRoot)
{
    return S_OK;
}

HRESULT
CUPnPAutomationProxy::HrBuildTablesFromServiceDescription(
    IXMLDOMElement * pxdeRoot)
{
    HRESULT        hr = S_OK;
    IXMLDOMNode    * pxdnRoot = NULL;

    hr = pxdeRoot->QueryInterface(IID_IXMLDOMNode,
                                  (void **) &pxdnRoot);

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode    * pxdnSST = NULL;
        LPCWSTR        arypszTokens[] = {L"serviceStateTable"};

        Assert(pxdnRoot);

        // Get the <serviceStateTable> element and use it's children to
        // build the variable table.

        hr = HrGetNestedChildElement(pxdnRoot,
                                     arypszTokens,
                                     1,
                                     &pxdnSST);

        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList * pxdnlStateVars = NULL;

            Assert(pxdnSST);

            // Get the list of <stateVariable> nodes.

            hr = pxdnSST->get_childNodes(&pxdnlStateVars);

            if (SUCCEEDED(hr))
            {
                hr = HrBuildVariableTable(pxdnlStateVars);

                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidAutomationProxy,
                             "CUPnPAutomationProxy::"
                             "HrBuildTablesFromServiceDescription(): "
                             "Successfully built variable table");
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::"
                               "HrBuildTablesFromServiceDescription(): "
                               "Failed to build variable table",
                               hr);
                }

                pxdnlStateVars->Release();
            }
            else
            {
                TraceError("CUPnPAutomationProxy::"
                           "HrBuildTablesFromServiceDescription(): "
                           "Failed to get <stateVariable> elements",
                           hr);
            }

            pxdnSST->Release();
        }
        else
        {
            TraceError("CUPnPAutomationProxy::"
                       "HrBuildTablesFromServiceDescription(): "
                       "Failed to get <serviceStateTable> element",
                       hr);
        }

        // If the above succeeded, we'll now build the action
        // table.

        if (SUCCEEDED(hr))
        {
            IXMLDOMNode    * pxdnActionList = NULL;
            LPCWSTR        arypszALTokens[] = {L"actionList"};

            Assert(pxdnRoot);

            // Get the <actionList> element and use it's children to
            // build the action table.

            hr = HrGetNestedChildElement(pxdnRoot,
                                         arypszALTokens,
                                         1,
                                         &pxdnActionList);

            if (SUCCEEDED(hr) && hr != S_FALSE)
            {
                IXMLDOMNodeList * pxdnlActions = NULL;

                Assert(pxdnActionList);

                // Get the list of <action> nodes.

                hr = pxdnActionList->get_childNodes(&pxdnlActions);

                if (SUCCEEDED(hr))
                {
                    hr = HrBuildActionTable(pxdnlActions);

                    if (SUCCEEDED(hr))
                    {
                        TraceTag(ttidAutomationProxy,
                                 "CUPnPAutomationProxy::"
                                 "HrBuildTablesFromServiceDescription(): "
                                 "Successfully built action table");
                    }
                    else
                    {
                        TraceError("CUPnPAutomationProxy::"
                                   "HrBuildTablesFromServiceDescription(): "
                                   "Failed to build action table",
                                   hr);
                    }

                    pxdnlActions->Release();
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::"
                               "HrBuildTablesFromServiceDescription(): "
                               "Failed to get <action> elements",
                               hr);
                }

                pxdnActionList->Release();
            }
            else
            {
                TraceErrorOptional("CUPnPAutomationProxy::"
                           "HrBuildTablesFromServiceDescription(): "
                           "Failed to get <actionList> element",
                           hr, (S_FALSE == hr));
            }

        }

        pxdnRoot->Release();
    }


    TraceError("CUPnPAutomationProxy::"
               "HrBuildTablesFromServiceDescription(): "
               "Exiting",
               hr);

    return hr;
}


HRESULT
CUPnPAutomationProxy::HrBuildVariableTable(
    IXMLDOMNodeList * pxdnlStateVars)
{
    HRESULT hr = S_OK;
    LONG    listLength = 0;

    hr = pxdnlStateVars->get_length(&listLength);

    if (SUCCEEDED(hr))
    {
        Assert(listLength > 0);

        m_rgVariables = new UPNP_STATE_VARIABLE[listLength];

        if (m_rgVariables)
        {
            ZeroMemory(m_rgVariables,
                       listLength * sizeof(UPNP_STATE_VARIABLE));

            m_cVariables = 0;
            m_cEventedVariables = 0;
            for (long i = 0; SUCCEEDED(hr) && (i < listLength); i++)
            {
                IXMLDOMNode * pxdnStateVar = NULL;

                hr = pxdnlStateVars->get_item(i, &pxdnStateVar);

                if (SUCCEEDED(hr))
                {
                    LPCWSTR rgszNameTokens[] = {L"name"};
                    Assert(pxdnStateVar);

                    // Get the "name" and "dataType" values.

                    hr = HrGetTextValueFromChildElement(pxdnStateVar,
                                                        rgszNameTokens,
                                                        1,
                                                        &(m_rgVariables[i].bstrName));

                    if (SUCCEEDED(hr))
                    {
                        LPCWSTR rgszDataTypeTokens[] = {L"dataType"};

                        hr = HrGetTextValueFromChildElement(pxdnStateVar,
                                                            rgszDataTypeTokens,
                                                            1,
                                                            &(m_rgVariables[i].bstrDataType));

                        if (SUCCEEDED(hr))
                        {
                            BSTR   bstrSendEvents = NULL;

                            TraceTag(ttidAutomationProxy,
                                     "HrBuildVariableTable(): "
                                     "Variable name %S and data type %S",
                                     m_rgVariables[i].bstrName,
                                     m_rgVariables[i].bstrDataType);

                            hr = HrGetTextValueFromAttribute(pxdnStateVar,
                                                             L"sendEvents",
                                                             &bstrSendEvents);

                            if (SUCCEEDED(hr))
                            {
                                if (NULL == bstrSendEvents)
                                {
                                    hr = S_OK;
                                    m_rgVariables[i].fNonEvented = FALSE;
                                    m_cEventedVariables++;
                                    TraceTag(ttidAutomationProxy,
                                             "HrBuildVariableTable(): "
                                             "Variable %S did not have a "
                                             "sendEvents attribute - treating "
                                             "it as evented",
                                             m_rgVariables[i].bstrName);
                                }
                                else
                                {
                                    if (0 == lstrcmpW(bstrSendEvents, L"yes"))
                                    {
                                        m_rgVariables[i].fNonEvented = FALSE;
                                        m_cEventedVariables++;
                                        TraceTag(ttidAutomationProxy,
                                                 "HrBuildVariableTable(): "
                                                 "Variable %S is evented ",
                                                 m_rgVariables[i].bstrName);

                                    }
                                    else if (0 == lstrcmpW(bstrSendEvents, L"no"))
                                    {
                                        m_rgVariables[i].fNonEvented = TRUE;
                                        TraceTag(ttidAutomationProxy,
                                                 "HrBuildVariableTable(): "
                                                 "Variable %S is non-evented ",
                                                 m_rgVariables[i].bstrName);

                                    }
                                    SysFreeString(bstrSendEvents);
                                }
                            }
                            else
                            {
                                TraceError("CUPnPAutomationProxy::"
                                           "HrBuildVariableTable(): "
                                           "Failed to get sendEvents attribute",
                                           hr);
                            }

                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::"
                                       "HrBuildVariableTable(): "
                                       "Failed to get variable data type",
                                       hr);
                        }

                    }
                    else
                    {
                        TraceError("CUPnPAutomationProxy::"
                                   "HrBuildVariableTable(): "
                                   "Failed to get variable name",
                                   hr);
                    }

                    pxdnStateVar->Release();
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::"
                               "HrBuildVariableTable(): "
                               "Failed to get list item",
                               hr);
                }

                if (SUCCEEDED(hr))
                {
                    m_cVariables++;
                }
                else
                {
                    FreeVariable(&m_rgVariables[i]);
                }
            }

        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::"
                       "HrBuildVariableTable(): "
                       "Failed to allocate variable table",
                       hr);
        }
    }
    else
    {
        TraceError("CUPnPAutomationProxy::"
                   "HrBuildVariableTable(): "
                   "Failed to get list length",
                   hr);
    }

    // Got the names and data types, now just need to get the DISPIDs.

    if (SUCCEEDED(hr))
    {
        for (DWORD i = 0; SUCCEEDED(hr) && (i < m_cVariables); i++)
        {

            hr = m_pdispService->GetIDsOfNames(IID_NULL,
                                               &m_rgVariables[i].bstrName,
                                               1,
                                               LOCALE_SYSTEM_DEFAULT,
                                               &m_rgVariables[i].dispid);

            if (SUCCEEDED(hr))
            {
                Assert(DISPID_UNKNOWN != m_rgVariables[i].dispid);

                TraceTag(ttidAutomationProxy,
                         "CUPnPAutomationProxy::"
                         "HrBuildVariableTable(): "
                         "Variable %S has dispID %d",
                         m_rgVariables[i].bstrName,
                         m_rgVariables[i].dispid);
            }
            else
            {
                TraceError("CUPnPAutomationProxy::"
                           "HrBuildVariableTable(): "
                           "Failed to get dispId",
                           hr);
            }
        }
    }

    TraceError("CUPnPAutomationProxy::"
               "HrBuildVariableTable(): "
               "Exiting",
               hr);

    return hr;
}


HRESULT
CUPnPAutomationProxy::HrBuildActionTable(
    IXMLDOMNodeList    * pxdnlActions)
{
    HRESULT hr = S_OK;
    LONG    listLength = 0;

    hr = pxdnlActions->get_length(&listLength);

    if (SUCCEEDED(hr))
    {
        Assert(listLength > 0);

        m_rgActions = new UPNP_ACTION[listLength];

        if (m_rgActions)
        {
            ZeroMemory(m_rgActions,
                       listLength * sizeof(UPNP_ACTION));

            m_cActions = 0;
            for (long i = 0; SUCCEEDED(hr) && (i < listLength); i++)
            {
                IXMLDOMNode * pxdnAction = NULL;

                hr = pxdnlActions->get_item(i, &pxdnAction);

                if (SUCCEEDED(hr))
                {
                    LPCWSTR rgszNameTokens[] = {L"name"};

                    Assert(pxdnAction);

                    // Get the "name" value.

                    hr = HrGetTextValueFromChildElement(pxdnAction,
                                                        rgszNameTokens,
                                                        1,
                                                        &(m_rgActions[i].bstrName));

                    if (SUCCEEDED(hr))
                    {
                        // Initialize arguments.

                        hr = HrBuildArgumentLists(pxdnAction,
                                                  &m_rgActions[i]);

                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidAutomationProxy,
                                     "HrBuildActionTable(): "
                                     "Action %S initialized",
                                     m_rgActions[i].bstrName);
                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::"
                                       "HrBuildActionTable(): "
                                       "Failed to build argument lists",
                                       hr);
                        }

                    }
                    else
                    {
                        TraceError("CUPnPAutomationProxy::"
                                   "HrBuildActionTable(): "
                                   "Failed to get action name",
                                   hr);
                    }

                    pxdnAction->Release();
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::"
                               "HrBuildActionTable(): "
                               "Failed to get list item",
                               hr);
                }

                if (SUCCEEDED(hr))
                {
                    m_cActions++;
                }
                else
                {
                    FreeAction(&m_rgActions[i]);
                }
            }

        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::"
                       "HrBuildActionTable(): "
                       "Failed to allocate action table",
                       hr);
        }
    }
    else
    {
        TraceError("CUPnPAutomationProxy::"
                   "HrBuildActionTable(): "
                   "Failed to get list length",
                   hr);
    }

    // Got the names and arguments, now just need to get the DISPIDs.

    if (SUCCEEDED(hr))
    {
        for (DWORD i = 0; SUCCEEDED(hr) && (i < m_cActions); i++)
        {

            hr = m_pdispService->GetIDsOfNames(IID_NULL,
                                               &m_rgActions[i].bstrName,
                                               1,
                                               LOCALE_SYSTEM_DEFAULT,
                                               &m_rgActions[i].dispid);

            if (SUCCEEDED(hr))
            {
                Assert(DISPID_UNKNOWN != m_rgActions[i].dispid);

                TraceTag(ttidAutomationProxy,
                         "CUPnPAutomationProxy::"
                         "HrBuildActionTable(): "
                         "Action %S has dispID %d",
                         m_rgActions[i].bstrName,
                         m_rgActions[i].dispid);
            }
            else
            {
                TraceError("CUPnPAutomationProxy::"
                           "HrBuildActionTable(): "
                           "Failed to get dispId",
                           hr);
            }
        }
    }


    TraceError("CUPnPAutomationProxy::HrBuildActionTable(): "
               "Exiting",
               hr);

    return hr;
}


HRESULT
CUPnPAutomationProxy::HrBuildArgumentLists(
    IXMLDOMNode    * pxdnAction,
    UPNP_ACTION    * pAction)
{
    HRESULT        hr = S_OK;
    IXMLDOMNode    * pxdnArgList = NULL;
    LPCWSTR        arypszTokens[] = {L"argumentList"};

    Assert(pxdnAction);
    Assert(pAction);

    hr = HrGetNestedChildElement(pxdnAction, arypszTokens, 1, &pxdnArgList);

    if (SUCCEEDED(hr))
    {
        if (pxdnArgList)
        {
            IXMLDOMNodeList * pxdnlArgs = NULL;

            hr = pxdnArgList->get_childNodes(&pxdnlArgs);

            if (SUCCEEDED(hr))
            {
                DWORD cInArgs = 0;
                DWORD cOutArgs = 0;

                hr = HrCountInAndOutArgs(pxdnlArgs, &cInArgs, &cOutArgs);

                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidAutomationProxy,
                             "CUPnPAutomationProxy::HrBuildArgumentLists(): "
                             "Action %S has %d input arguments and "
                             "%d output arguments",
                             pAction->bstrName,
                             cInArgs,
                             cOutArgs);

                    // Allocate memory for the argument lists.

                    if (cInArgs > 0)
                    {
                        pAction->rgInArgs = new UPNP_ARGUMENT[cInArgs];

                        if (pAction->rgInArgs)
                        {
                            pAction->cInArgs = cInArgs;
                            ZeroMemory(pAction->rgInArgs,
                                       cInArgs * sizeof(UPNP_ARGUMENT));
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            TraceError("CUPnPAutomationProxy::"
                                       "HrBuildArgumentLists(): "
                                       "Failed to allocate memory for input "
                                       "arguments",
                                       hr);
                        }
                    }
                    else
                    {
                        pAction->cInArgs = 0;
                        pAction->rgInArgs = NULL;
                    }

                    if (SUCCEEDED(hr))
                    {
                        if (cOutArgs > 0)
                        {
                            pAction->rgOutArgs = new UPNP_ARGUMENT[cOutArgs];

                            if (pAction->rgOutArgs)
                            {
                                pAction->cOutArgs = cOutArgs;
                                ZeroMemory(pAction->rgOutArgs,
                                           cOutArgs * sizeof(UPNP_ARGUMENT));
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                                TraceError("CUPnPAutomationProxy::"
                                           "HrBuildArgumentLists(): "
                                           "Failed to allocate memory for out "
                                           "arguments",
                                           hr);
                            }
                        }
                        else
                        {
                            pAction->cOutArgs = 0;
                            pAction->rgOutArgs = NULL;
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = HrInitializeArguments(pxdnlArgs,
                                                   pAction);

                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidAutomationProxy,
                                     "CUPnPAutomationProxy::"
                                     "HrBuildArgumentLists(): "
                                     "Successfully initialized arguments");
                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::"
                                       "HrBuildArgumentLists(): "
                                       "Failed to initialize arguments",
                                       hr);
                        }
                    }

                    // If anything above failed, pAction structure will
                    // be cleaned up on return from this function.
                }

                pxdnlArgs->Release();
            }
            else
            {
                TraceError("CUPnPAutomationProxy::HrBuildArgumentLists(): "
                           "Failed to get <argumentList> children",
                           hr);
            }

            pxdnArgList->Release();
        }
        else
        {
            TraceTag(ttidAutomationProxy,
                     "CUPnPAutomationProxy::HrBuildArgumentLists(): "
                     "Action %S does not have any arguments",
                     pAction->bstrName);

            pAction->cInArgs = 0;
            pAction->rgInArgs = NULL;
            pAction->cOutArgs = 0;
            pAction->rgOutArgs = NULL;
            pAction->puaRetVal = NULL;

            // Fix up the return value.
            hr = S_OK;
        }
    }
    else
    {
        TraceError("CUPnPAutomationProxy::HrBuildArgumentLists(): "
                   "Failed to get <argumentList> element",
                   hr);
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE),
            "CUPnPAutomationProxy::HrBuildArgumentLists");

    return hr;
}


HRESULT
CUPnPAutomationProxy::HrCountInAndOutArgs(
    IXMLDOMNodeList * pxdnlArgs,
    DWORD * pcInArgs,
    DWORD * pcOutArgs)
{
    HRESULT hr = S_OK;
    LONG    listLength = 0;
    DWORD   cInArgs = 0;
    DWORD   cOutArgs = 0;

    Assert(pxdnlArgs);
    Assert(pcInArgs);
    Assert(pcOutArgs);

    hr = pxdnlArgs->get_length(&listLength);

    if (SUCCEEDED(hr))
    {
        Assert(listLength > 0);

        // Loop through the list of <argument> elements and read each one's
        // <direction> element.

        for (LONG i = 0; SUCCEEDED(hr) && (i < listLength); i++)
        {
            IXMLDOMNode * pxdnArg = NULL;

            hr = pxdnlArgs->get_item(i, &pxdnArg);

            if (SUCCEEDED(hr))
            {
                LPCWSTR    arypszTokens[] = {L"direction"};
                BSTR       bstrDirection = NULL;

                hr = HrGetTextValueFromChildElement(pxdnArg,
                                                    arypszTokens,
                                                    1,
                                                    &bstrDirection);

                if (SUCCEEDED(hr) && hr != S_FALSE)
                {
                    if (lstrcmpW(bstrDirection, L"in") == 0)
                    {
                        cInArgs++;
                    }
                    else if (lstrcmpW(bstrDirection, L"out") == 0)
                    {
                        cOutArgs++;
                    }
                    else
                    {
                        // Document has already been validated - <direction>
                        // should contain either "in" or "out". Should never
                        // be here.

                        AssertSz(FALSE,
                                 "Validated direction element contained"
                                 "invalid value");
                    }

                    SysFreeString(bstrDirection);
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::HrCountInAndOutArgs(): "
                               "Failed to get <direction> value",
                               hr);
                }


                pxdnArg->Release();
            }
            else
            {
                TraceError("CUPnPAutomationProxy::HrCountInAndOutArgs(): "
                           "Failed to get list item",
                           hr);
            }
        }
    }
    else
    {
        TraceError("CUPnPAutomationProxy::HrCountInAndOutArgs(): "
                   "Failed to get list length",
                   hr);
    }

    // If everything succeeded, return counts through out parameters.

    if (SUCCEEDED(hr))
    {
        *pcInArgs = cInArgs;
        *pcOutArgs = cOutArgs;
    }

    TraceError("CUPnPAutomationProxy::HrCountInAndOutArgs(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
CUPnPAutomationProxy::HrInitializeArguments(
    IXMLDOMNodeList    * pxdnlArgs,
    UPNP_ACTION        * pAction)
{
    HRESULT hr = S_OK;

    Assert(pxdnlArgs);
    Assert(pAction);

    // There should either be some input or some output arguments.
    // For both input and output arguments, if there are any, an
    // array should be allocated for them.

    Assert(pAction->cInArgs || pAction->cOutArgs);
    Assert(FImplies(pAction->cInArgs, pAction->rgInArgs));
    Assert(FImplies(pAction->cOutArgs, pAction->rgOutArgs));

    // In arguments must be declared before out arguments, so we can assume
    // they are at the front of the list.

    for (DWORD i = 0; SUCCEEDED(hr) && (i < pAction->cInArgs); i++)
    {
        LONG           lIndex = (LONG) i;
        IXMLDOMNode    * pxdnArg = NULL;

        hr = pxdnlArgs->get_item(lIndex, &pxdnArg);

        if (SUCCEEDED(hr))
        {
            UPNP_ARGUMENT * puaCurrent = &pAction->rgInArgs[i];
            LPCWSTR       arypszNameTokens[] = {L"name"};

            Assert(pxdnArg);

            hr = HrGetTextValueFromChildElement(pxdnArg,
                                                arypszNameTokens,
                                                1,
                                                &puaCurrent->bstrName);

            if (SUCCEEDED(hr))
            {
                LPCWSTR    arypszRSVTokens[] = {L"relatedStateVariable"};
                BSTR       bstrRelStateVar = NULL;

                TraceTag(ttidAutomationProxy,
                         "CUPnPAutomationProxy::HrInitializeArguments(): "
                         "Initializing argument %S",
                         puaCurrent->bstrName);

                hr = HrGetTextValueFromChildElement(pxdnArg,
                                                    arypszRSVTokens,
                                                    1,
                                                    &bstrRelStateVar);

                if (SUCCEEDED(hr))
                {
                    UPNP_STATE_VARIABLE * pusvRelated = NULL;

                    TraceTag(ttidAutomationProxy,
                             "CUPnPAutomationProxy::HrInitializeArguments(): "
                             "Argument %S is related to state variable %S",
                             puaCurrent->bstrName,
                             bstrRelStateVar);


                    pusvRelated = LookupVariableByName(bstrRelStateVar);

                    if (pusvRelated)
                    {
                        puaCurrent->pusvRelated = pusvRelated;
                    }
                    else
                    {
                        puaCurrent->pusvRelated = NULL;
                        hr = E_INVALIDARG;
                        TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                                   "Failed to find related state variable",
                                   hr);
                    }

                    SysFreeString(bstrRelStateVar);
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                               "Failed to get <relatedStateVariable> value",
                               hr);
                }
            }
            else
            {
                TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                           "Failed to get <name> value",
                           hr);
            }

            pxdnArg->Release();
        }
        else
        {
            TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                       "Failed to get list item",
                       hr);
        }
    }

    // Now get the out arguments.

    for (DWORD i = 0; SUCCEEDED(hr) && (i < pAction->cOutArgs); i++)
    {
        LONG           lIndex = (LONG) (pAction->cInArgs + i);
        IXMLDOMNode    * pxdnArg = NULL;

        hr = pxdnlArgs->get_item(lIndex, &pxdnArg);

        if (SUCCEEDED(hr))
        {
            UPNP_ARGUMENT * puaCurrent = &pAction->rgOutArgs[i];
            LPCWSTR       arypszNameTokens[] = {L"name"};

            Assert(pxdnArg);

            hr = HrGetTextValueFromChildElement(pxdnArg,
                                                arypszNameTokens,
                                                1,
                                                &puaCurrent->bstrName);

            if (SUCCEEDED(hr))
            {
                LPCWSTR    arypszRSVTokens[] = {L"relatedStateVariable"};
                BSTR       bstrRelStateVar = NULL;

                TraceTag(ttidAutomationProxy,
                         "CUPnPAutomationProxy::HrInitializeArguments(): "
                         "Initializing argument %S",
                         puaCurrent->bstrName);

                hr = HrGetTextValueFromChildElement(pxdnArg,
                                                    arypszRSVTokens,
                                                    1,
                                                    &bstrRelStateVar);

                if (SUCCEEDED(hr))
                {
                    UPNP_STATE_VARIABLE * pusvRelated = NULL;

                    TraceTag(ttidAutomationProxy,
                             "CUPnPAutomationProxy::HrInitializeArguments(): "
                             "Argument %S is related to state variable %S",
                             puaCurrent->bstrName,
                             bstrRelStateVar);


                    pusvRelated = LookupVariableByName(bstrRelStateVar);

                    if (pusvRelated)
                    {
                        LPCWSTR       arypszRetvalTokens[] = {L"retval"};
                        IXMLDOMNode   * pxdnRetVal = NULL;

                        puaCurrent->pusvRelated = pusvRelated;

                        hr = HrGetNestedChildElement(pxdnArg,
                                                     arypszRetvalTokens,
                                                     1,
                                                     &pxdnRetVal);

                        if (SUCCEEDED(hr))
                        {
                            if (pxdnRetVal)
                            {
                                // This is the return value.
                                pAction->puaRetVal = puaCurrent;
                            }
                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::"
                                       "HrInitializeArguments(): "
                                       "Failed get retval element",
                                       hr);
                        }
                    }
                    else
                    {
                        puaCurrent->pusvRelated = NULL;
                        hr = E_INVALIDARG;
                        TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                                   "Failed to find related state variable",
                                   hr);
                    }

                    SysFreeString(bstrRelStateVar);
                }
                else
                {
                    TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                               "Failed to get <relatedStateVariable> value",
                               hr);
                }
            }
            else
            {
                TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                           "Failed to get <name> value",
                           hr);
            }

            pxdnArg->Release();
        }
        else
        {
            TraceError("CUPnPAutomationProxy::HrInitializeArguments(): "
                       "Failed to get list item",
                       hr);
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == S_FALSE),
            "CUPnPAutomationProxy::HrInitializeArguments");

    return hr;
}



UPNP_STATE_VARIABLE *
CUPnPAutomationProxy::LookupVariableByDispID(DISPID dispid)
{
    UPNP_STATE_VARIABLE    * pusv = NULL;

    for (DWORD i = 0; i < m_cVariables; i++)
    {
        if (m_rgVariables[i].dispid == dispid)
        {
            pusv = &m_rgVariables[i];
            break;
        }
    }

    if (pusv)
    {
        TraceTag(ttidAutomationProxy,
                 "CUPnPAutomationProxy::LookupVariableByDispID(): "
                 "DISPID %d corresponds to variable %S",
                 pusv->dispid,
                 pusv->bstrName);
    }
    else
    {
        TraceTag(ttidAutomationProxy,
                 "CUPnPAutomationProxy::LookupVariableByDispID(): "
                 "DISPID %d does not match any variable",
                 dispid);
    }

    return pusv;
}


UPNP_STATE_VARIABLE *
CUPnPAutomationProxy::LookupVariableByName(LPCWSTR pcszName)
{
    UPNP_STATE_VARIABLE    * pusv = NULL;

    for (DWORD i = 0; i < m_cVariables; i++)
    {
        if (lstrcmpiW(m_rgVariables[i].bstrName, pcszName) == 0)
        {
            pusv = &m_rgVariables[i];
            break;
        }
    }

    if (pusv)
    {
        TraceTag(ttidAutomationProxy,
                 "CUPnPAutomationProxy::LookupVariableByName(): "
                 "Found %S in variable table",
                 pusv->bstrName);
    }
    else
    {
        TraceTag(ttidAutomationProxy,
                 "CUPnPAutomationProxy::LookupVariableByName(): "
                 "%S does not match any variable in variable table",
                 pcszName);
    }

    return pusv;
}


UPNP_ACTION *
CUPnPAutomationProxy::LookupActionByName(LPCWSTR pcszName)
{
    UPNP_ACTION * pua = NULL;

    for (DWORD i = 0; i < m_cActions; i++)
    {
        if (lstrcmpiW(m_rgActions[i].bstrName, pcszName) == 0)
        {
            pua = &m_rgActions[i];
            break;
        }
    }

    if (pua)
    {
        TraceTag(ttidAutomationProxy,
                 "CUPnPAutomationProxy::LookupActionByName(): "
                 "Found %S in action table",
                 pua->bstrName);
    }
    else
    {
        TraceTag(ttidAutomationProxy,
                 "CUPnPAutomationProxy::LookupActionByName(): "
                 "%S does not match any action in action table",
                 pcszName);
    }

    return pua;
}


HRESULT
CUPnPAutomationProxy::HrBuildFaultResponse(
    UPNP_CONTROL_RESPONSE_DATA * pucrd,
    LPCWSTR                    pcszFaultCode,
    LPCWSTR                    pcszFaultString,
    LPCWSTR                    pcszUPnPErrorCode,
    LPCWSTR                    pcszUPnPErrorString)
{
    HRESULT hr = S_OK;

    pucrd->Fault.bstrFaultCode = SysAllocString(pcszFaultCode);

    if (pucrd->Fault.bstrFaultCode)
    {
        pucrd->Fault.bstrFaultString = SysAllocString(pcszFaultString);

        if (pucrd->Fault.bstrFaultString)
        {
            pucrd->Fault.bstrUPnPErrorCode = SysAllocString(pcszUPnPErrorCode);

            if (pucrd->Fault.bstrUPnPErrorCode)
            {
                pucrd->Fault.bstrUPnPErrorString = SysAllocString(pcszUPnPErrorString);

                if (pucrd->Fault.bstrUPnPErrorString)
                {
                    TraceTag(ttidAutomationProxy,
                             "CUPnPAutomationProxy::HrBuildFaultResponse(): "
                             "Successfully built fault response: \n"
                             "\tFaultCode: %S\n"
                             "\tFaultString: %S\n"
                             "\tUPnPErrorCode: %S\n"
                             "\tUPnPErrorString: %S",
                             pucrd->Fault.bstrFaultCode,
                             pucrd->Fault.bstrFaultString,
                             pucrd->Fault.bstrUPnPErrorCode,
                             pucrd->Fault.bstrUPnPErrorString);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPAutomationProxy::HrBuildFaultResponse(): "
                               "Failed to allocate UPnP error string",
                               hr);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPAutomationProxy::HrBuildFaultResponse(): "
                           "Failed to allocate UPnP Error code string",
                           hr);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPAutomationProxy::HrBuildFaultResponse(): "
                       "Failed to allocate fault string",
                       hr);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("CUPnPAutomationProxy::HrBuildFaultResponse(): "
                   "Failed to allocate fault code string",
                   hr);
    }

    TraceError("CUPnPAutomationProxy::HrBuildFaultResponse(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
CUPnPAutomationProxy::HrVariantInitForXMLType(VARIANT * pvar,
                                              LPCWSTR pcszDataTypeString)
{
    HRESULT    hr = S_OK;
    VARTYPE    vt = VT_ERROR;
    VARIANT    var;

    VariantInit(&var);

    vt = GetVarTypeFromString(pcszDataTypeString);

    if (VT_EMPTY != vt)
    {
        var.vt = vt;

        switch (vt)
        {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_INT:
        case VT_UINT:
        case VT_CY:
        case VT_BOOL:
        case VT_DATE:
            var.dblVal = 0;
            break;

        case VT_BSTR:
            var.bstrVal = SysAllocString(L"");

            if (NULL == var.bstrVal)
            {
                hr = E_OUTOFMEMORY;
            }
            break;
        default:
            hr = E_INVALIDARG;
        }
    }
    else
    {
        // Should never happen because the data type strings come from
        // our internal tables, which must be valid.
        AssertSz(FALSE,
                 "CUPnPAutomationProxy::HrVariantInitForXMLType(): "
                 "Invalid data type string passed in");

    }

    if (SUCCEEDED(hr))
    {
        *pvar = var;
    }
    else
    {
        VariantClear(&var);
    }

    TraceError("CUPnPAutomationProxy::HrVariantInitFroXMLType(): "
               "Exiting",
               hr);

    return hr;
}


HRESULT
CUPnPAutomationProxy::HrInvokeAction(
    UPNP_CONTROL_REQUEST    * pucreq,
    UPNP_CONTROL_RESPONSE   * pucresp)
{
    HRESULT                hr = S_OK;
    UPNP_CONTROL_RESPONSE  ucresp = {0};
    UPNP_ACTION            * pua = NULL;

    pua = LookupActionByName(pucreq->bstrActionName);

    if (pua)
    {
        // Check that we've got the right number of input arguments.
        if (pua->cInArgs == pucreq->cInputArgs)
        {
            DWORD      cTotalArgs = 0;
            DWORD      cOutArgs = 0;
            VARIANTARG * rgvarg = NULL;
            VARIANTARG * rgvargData = NULL;
            VARIANT    varResult;
            EXCEPINFO  excepInfo = {0};

            VariantInit(&varResult);

            // Build an array of arguments to pass to the service object.

            cTotalArgs = pua->cInArgs + pua->cOutArgs;

            if (pua->puaRetVal)
            {
                Assert(cTotalArgs > 0);

                // In UTL, the retval is considered an out parameter. In the
                // automation world, it's considered separate, so reduce the
                // count of parameters by 1 if there is a retval.
                cTotalArgs--;
            }

            cOutArgs = cTotalArgs - pua->cInArgs;

            if (cTotalArgs > 0)
            {
                rgvarg = new VARIANTARG[cTotalArgs];
                if (cOutArgs > 0)
                {
                    rgvargData = new VARIANTARG[cOutArgs];
                }
                else
                {
                    rgvargData = NULL;
                }

                if (rgvarg && (!cOutArgs || rgvargData))
                {
                    // Have to copy the arguments in reverse order. Out args
                    // go first.

                    for (DWORD i = 0,
                         index = pua->cOutArgs - 1;
                         SUCCEEDED(hr) && (i < cOutArgs);
                         i++, index--)
                    {
                        UPNP_STATE_VARIABLE * pusvRelated = NULL;

                        pusvRelated = pua->rgOutArgs[index].pusvRelated;

                        hr = HrVariantInitForXMLType(&rgvargData[i],
                                                     pusvRelated->bstrDataType);

                        if (SUCCEEDED(hr))
                        {
                            rgvarg[i].vt = rgvargData[i].vt | VT_BYREF;
                            rgvarg[i].pdblVal = &(rgvargData[i].dblVal);

                            if (SUCCEEDED(hr))
                            {
                                TraceTag(ttidAutomationProxy,
                                         "CUPnPAutomationProxy::HrInvokeAction(): "
                                         "Successfully initialized output arg %d",
                                         i);
                            }
                            else
                            {
                                TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                                           "Failed to initialize output argument",
                                           hr);
                            }
                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                                       "Failed to initialize for XML data type",
                                       hr);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // Now the in arguments.
                        // i is the index into the array of arguments we'll
                        // pass to IDispatch::Invoke. It starts at the first
                        // index after the out arguments. j is the index into
                        // the array of input arguments - it starts at the last
                        // and goes down to the first.

                        for (DWORD i = cOutArgs, j = pucreq->cInputArgs - 1;
                             i < cTotalArgs;
                             i++, j--)
                        {
                            // These will only be read,
                            // so we're going to just do straight binary copies i.e.
                            // we won't do VariantCopy().
                            // Note that because of this, we don't own the memory used
                            // by the input argument elements, so we don't free them
                            // when we clean up rgvarg down below.

                            rgvarg[i] = pucreq->rgvarInputArgs[j];
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                               "Failed to allocate arguments array",
                               hr);
                }
            }
            else
            {
                rgvarg = NULL;
            }

            // Now we have the arguments sorted out. Execute the request.

            if (SUCCEEDED(hr))
            {
                DISPPARAMS actionParams;

                actionParams.rgvarg = rgvarg;
                actionParams.cArgs = cTotalArgs;
                actionParams.rgdispidNamedArgs = NULL;
                actionParams.cNamedArgs = 0;

                hr = m_pdispService->Invoke(pua->dispid,
                                            IID_NULL,
                                            LOCALE_SYSTEM_DEFAULT,
                                            DISPATCH_METHOD,
                                            &actionParams,
                                            &varResult,
                                            &excepInfo,
                                            NULL);
            }

            // Build a response.

            if (SUCCEEDED(hr))
            {
                UPNP_CONTROL_RESPONSE_DATA * pucrd = NULL;

                TraceTag(ttidAutomationProxy,
                         "CUPnPAutomationProxy::HrInvokeAction(): "
                         "Action %S executed successfully",
                         pua->bstrName);

                ucresp.bstrActionName = SysAllocString(pua->bstrName);

                if (ucresp.bstrActionName)
                {
                    ucresp.fSucceeded = TRUE;
                    pucrd = &ucresp.ucrData;

                    if (pua->cOutArgs > 0)
                    {
                        pucrd->Success.rgvarOutputArgs = (VARIANT *) CoTaskMemAlloc(
                            pua->cOutArgs * sizeof(VARIANT));

                        if (pucrd->Success.rgvarOutputArgs)
                        {
                            DWORD dwStartIndex = 0;

                            pucrd->Success.cOutputArgs = pua->cOutArgs;

                            if (pua->puaRetVal)
                            {
                                VariantInit(&pucrd->Success.rgvarOutputArgs[0]);

                                hr = VariantCopy(&pucrd->Success.rgvarOutputArgs[0],
                                                 &varResult);
                                if (SUCCEEDED(hr))
                                {
                                    dwStartIndex = 1;
                                    TraceTag(ttidAutomationProxy,
                                             "CUPnPAutomationProxy::"
                                             "HrInvokeAction(): "
                                             "Successfully copied retval");
                                }
                                else
                                {
                                    TraceError("CUPnPAutomationProxy::"
                                               "HrInvokeAction(): "
                                               "Failed to copy retval",
                                               hr);
                                }
                            }

                            if (SUCCEEDED(hr))
                            {
                                for (DWORD i = 0,
                                     j = cOutArgs + dwStartIndex - 1;
                                     SUCCEEDED(hr) && (i < cOutArgs);
                                     i++, j--)
                                {
                                    VariantInit(&pucrd->Success.rgvarOutputArgs[j]);
                                    hr = VariantCopy(&pucrd->Success.rgvarOutputArgs[j],
                                                     &rgvargData[i]);

                                    if (SUCCEEDED(hr))
                                    {
                                        TraceTag(ttidAutomationProxy,
                                                 "CUPnPAutomationProxy::"
                                                 "HrInvokeAction(): "
                                                 "Successfully copied out arg %d",
                                                 j);
                                    }
                                    else
                                    {
                                        TraceError("CUPnPAutomationProxy::"
                                                   "HrInvokeAction(): "
                                                   "Failed to copy out arg",
                                                   hr);
                                    }
                                }
                            }

                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                                       "Failed to allocate memory for out args",
                                       hr);
                        }

                    }
                    else
                    {
                        pucrd->Success.rgvarOutputArgs = NULL;
                        pucrd->Success.cOutputArgs = 0;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                               "Failed to allocate memory for action name",
                               hr);
                }

            }
            else if (DISP_E_EXCEPTION == hr)
            {
                UPNP_CONTROL_RESPONSE_DATA * pucrd = NULL;

                TraceTag(ttidAutomationProxy,
                         "CUPnPAutomationProxy::HrInvokeAction(): "
                         "Action %S returned an exception",
                         pua->bstrName);

                // Fix up the HRESULT. Even though this is an error in the
                // UPnP sense, we are returning success because from the
                // processing point of view, the request went through correctly
                // and just returned a fault response.
                hr = S_OK;

                ucresp.bstrActionName = SysAllocString(pua->bstrName);

                if (ucresp.bstrActionName)
                {
                    ucresp.fSucceeded = FALSE;
                    pucrd = &ucresp.ucrData;

                    // If the service object requested deferred fill-in of
                    // the exception info, call its callback function now.

                    if (excepInfo.pfnDeferredFillIn)
                    {
                        hr = (*(excepInfo.pfnDeferredFillIn))(&excepInfo);

                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidAutomationProxy,
                                     "CUPnPAutomationProxy::HrInvokeAction(): "
                                     "Successfully filled in "
                                     "deferred exception info");
                        }
                        else
                        {
                            TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                                       "Failed to fill in "
                                       "deferred exception info",
                                       hr);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // excepInfo may not be complete
                        LPCWSTR pszSource = excepInfo.bstrSource ? excepInfo.bstrSource : L"501";
                        LPCWSTR pszDesc = excepInfo.bstrDescription ? excepInfo.bstrDescription : L"Action Failed";

                        hr = HrBuildFaultResponse(pucrd,
                                                  L"SOAP-ENV:Client",
                                                  L"UPnPError",
                                                  pszSource,
                                                  pszDesc);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                               "Failed to allocate memory for action name",
                               hr);
                }


            }
            else
            {
                TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                           "Failed to invoke action",
                           hr);

                // Build up a SOAP Fault response with the UPnP error code
                // "501 - Action Failed". Allow the above HRESULT to be lost
                // because even though there was an "error", we're going to
                // return success.

                ucresp.bstrActionName = SysAllocString(pua->bstrName);

                if (ucresp.bstrActionName)
                {
                    UPNP_CONTROL_RESPONSE_DATA * pucrd = NULL;

                    ucresp.fSucceeded = FALSE;
                    pucrd = &ucresp.ucrData;

                    hr = HrBuildFaultResponse(pucrd,
                                              L"SOAP-ENV:Client",
                                              L"UPnPError",
                                              L"501",
                                              L"Action Failed");

                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
                               "Failed to allocate memory for action name",
                               hr);
                }
            }

            // Cleanup. At this point, all the output information should be
            // in the ucresp structure.

            if (rgvarg)
            {
                // The input arguments were straight binary copies, so
                // we don't want to free them. Free only the output arguments.

                for (DWORD i = 0; i < cOutArgs; i++)
                {
                    VariantClear(&rgvargData[i]);
                }

                delete [] rgvarg;
                delete [] rgvargData;
                rgvarg = NULL;
                rgvargData = NULL;
                cTotalArgs = 0;
            }

            VariantClear(&varResult);
        }
        else
        {
            // Invalid arguments.
            ucresp.fSucceeded = FALSE;
            hr = HrBuildFaultResponse(&ucresp.ucrData,
                                      L"SOAP-ENV:Client",
                                      L"UPnPError",
                                      L"402",
                                      L"Invalid Args");
        }
    }
    else
    {
        // Invalid Action name
        ucresp.fSucceeded = FALSE;
        hr = HrBuildFaultResponse(&ucresp.ucrData,
                                  L"SOAP-ENV:Client",
                                  L"UPnPError",
                                  L"401",
                                  L"Invalid Action");
    }

    // If succeeded, copy the response info to the output structure, otherwise
    // free it.

    if (SUCCEEDED(hr))
    {
        *pucresp = ucresp;
    }
    else
    {
        FreeControlResponse(&ucresp);
    }

    TraceError("CUPnPAutomationProxy::HrInvokeAction(): "
               "Exiting",
               hr);

    return hr;
}

HRESULT
CUPnPAutomationProxy::HrQueryStateVariable(
    UPNP_CONTROL_REQUEST    * pucreq,
    UPNP_CONTROL_RESPONSE   * pucresp)
{
    HRESULT                hr = S_OK;
    UPNP_CONTROL_RESPONSE  ucresp = {0};
    UPNP_STATE_VARIABLE    * pusv = NULL;
    BSTR                   bstrVarName = NULL;

    // QueryStateVariable should have 1 input argument which is the variable
    // name.

    Assert(pucreq->cInputArgs == 1);
    Assert(pucreq->rgvarInputArgs[0].vt == VT_BSTR);

    bstrVarName = V_BSTR(&pucreq->rgvarInputArgs[0]);

    pusv = LookupVariableByName(bstrVarName);

    if (pusv)
    {
        DISPPARAMS dispparamsEmpty = {NULL, NULL, 0, 0};
        VARIANT    varResult;
        EXCEPINFO  excepInfo = {0};

        VariantInit(&varResult);

        // Query the value.

        hr = m_pdispService->Invoke(pusv->dispid,
                                    IID_NULL,
                                    LOCALE_SYSTEM_DEFAULT,
                                    DISPATCH_PROPERTYGET,
                                    &dispparamsEmpty,
                                    &varResult,
                                    &excepInfo,
                                    NULL);

        // Build a response.

        if (SUCCEEDED(hr))
        {
            UPNP_CONTROL_RESPONSE_DATA * pucrd = NULL;

            TraceTag(ttidAutomationProxy,
                     "CUPnPAutomationProxy::HrQueryStateVariable(): "
                     "PROPGET for %S succeeded",
                     bstrVarName);

            ucresp.bstrActionName = SysAllocString(L"QueryStateVariable");

            if (ucresp.bstrActionName)
            {
                ucresp.fSucceeded = TRUE;
                pucrd = &ucresp.ucrData;

                pucrd->Success.cOutputArgs = 1;
                pucrd->Success.rgvarOutputArgs = (VARIANT *) CoTaskMemAlloc(
                    sizeof(VARIANT));

                if (pucrd->Success.rgvarOutputArgs)
                {
                    VariantInit(&pucrd->Success.rgvarOutputArgs[0]);

                    hr = VariantCopy(&pucrd->Success.rgvarOutputArgs[0],
                                     &varResult);

                    if (SUCCEEDED(hr))
                    {
                        TraceTag(ttidAutomationProxy,
                                 "CUPnPAutomationProxy::HrQueryStateVariable(): "
                                 "Successfully copied result to output");
                    }
                    else
                    {
                        TraceError("CUPnPAutomationProxy::HrQueryStateVariable(): "
                                   "Failed to copy result to output",
                                   hr);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPAutomationProxy::HrQueryStateVariable(): "
                               "Failed to allocate memory for output arg",
                               hr);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPAutomationProxy::HrQueryStateVariable(): "
                           "Failed to allocate memory for action name",
                           hr);
            }

        }
        else if (DISP_E_EXCEPTION == hr)
        {
            UPNP_CONTROL_RESPONSE_DATA * pucrd = NULL;

            TraceTag(ttidAutomationProxy,
                     "CUPnPAutomationProxy::HrQueryStateVariable(): "
                     "PROPGET for %S returned an exception",
                     bstrVarName);

            // Fix up the HRESULT. Even though this is an error in the
            // UPnP sense, we are returning success because from the
            // processing point of view, the request went through correctly
            // and just returned a fault response.
            hr = S_OK;

            ucresp.bstrActionName = SysAllocString(L"QueryStateVariable");

            if (ucresp.bstrActionName)
            {
                ucresp.fSucceeded = FALSE;
                pucrd = &ucresp.ucrData;

                // If the service object requested deferred fill-in of
                // the exception info, call its callback function now.

                if (excepInfo.pfnDeferredFillIn)
                {
                    hr = (*(excepInfo.pfnDeferredFillIn))(&excepInfo);

                    if (SUCCEEDED(hr))
                    {
                        TraceTag(ttidAutomationProxy,
                                 "CUPnPAutomationProxy::HrQueryStateVariable(): "
                                 "Successfully filled in "
                                 "deferred exception info");
                    }
                    else
                    {
                        TraceError("CUPnPAutomationProxy::HrQueryStateVariable(): "
                                   "Failed to fill in "
                                   "deferred exception info",
                                   hr);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // excepInfo may not be complete
                    LPCWSTR pszSource = excepInfo.bstrSource ? excepInfo.bstrSource : L"501";
                    LPCWSTR pszDesc = excepInfo.bstrDescription ? excepInfo.bstrDescription : L"Action Failed";

                    hr = HrBuildFaultResponse(pucrd,
                                              L"SOAP-ENV:Client",
                                              L"UPnPError",
                                              pszSource,
                                              pszDesc);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPAutomationProxy::HrQueryStateVariable(): "
                           "Failed to allocate memory for action name",
                           hr);
            }

        }
        else
        {
            TraceError("CUPnPAutomationProxy::HrQueryStateVariable(): "
                       "PROPGET failed",
                       hr);
        }

        VariantClear(&varResult);
    }
    else
    {
        // Invalid variable name
        ucresp.fSucceeded = FALSE;
        hr = HrBuildFaultResponse(&ucresp.ucrData,
                                  L"SOAP-ENV:Client",
                                  L"UPnPError",
                                  L"404",
                                  L"Invalid Var");
    }

    // If succeeded, copy the response info to the output structure, otherwise
    // free it.

    if (SUCCEEDED(hr))
    {
        *pucresp = ucresp;
    }
    else
    {
        FreeControlResponse(&ucresp);
    }

    TraceError("CUPnPAutomationProxy::HrQueryStateVariable(): "
               "Exiting",
               hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Device Host"
#define VER_INTERNALNAME_STR            "unpnhost.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "uhbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\test.cpp ===
#include "pch.h"
#pragma hdrstop

#include "exetst.h"
#include "evtapi.h"
#include "oleauto.h"

/*
HRESULT HrComposeEventBody(DWORD cVars, LPWSTR *rgszNames, LPWSTR *rgszTypes,
                           VARIANT *rgvarValues, LPWSTR *pszBody);
*/

DWORD WINAPI SubmitWorker(LPVOID pvContext)
{
    if (PtrToUlong(pvContext) == 1)
    {
        HrSubmitEvent(L"EID 1", L"test body");
        HrSubmitEvent(L"EID 1", L"test body");
        HrSubmitEvent(L"EID 1", L"test body");
        HrSubmitEvent(L"EID 1", L"test body");
        HrSubmitEvent(L"EID 1", L"test body");
    }
    else
    {
        HrSubmitEvent(L"EID 2", L"test body");
        HrSubmitEvent(L"EID 2", L"test body");
        HrSubmitEvent(L"EID 2", L"test body");
        HrSubmitEvent(L"EID 2", L"test body");
        HrSubmitEvent(L"EID 2", L"test body");
        HrSubmitEvent(L"EID 2", L"test body");
    }

    return 0;
}


VOID WINAPI Test()
{
    LPWSTR  szSid;
    LPWSTR  szSid2 = L"foo";

    HRESULT hr;

    (VOID)HrInitEventApi();
    CoInitialize(NULL);

    hr = HrRegisterEventSource(L"EID 1");
    hr = HrRegisterEventSource(L"EID 2");
    hr = HrRegisterEventSource(L"Testing 3");
    hr = HrRegisterEventSource(L"Testing 4");

    //LPWSTR  szBody;

    LPWSTR rgszNames[] =
    {
        L"PropertyName1",
        L"PropertyName2"
    };

    LPWSTR rgszTypes[] =
    {
        L"string",
        L"string"
    };

    VARIANT rgvarValues[2];

    VariantInit(&rgvarValues[0]);
    VariantInit(&rgvarValues[1]);

    V_VT(&rgvarValues[0]) = VT_I4;
    V_VT(&rgvarValues[1]) = VT_I4;

    V_I4(&rgvarValues[0]) = 100;
    V_I4(&rgvarValues[1]) = 200;

    //hr = HrComposeEventBody(2, rgszNames, rgszTypes, rgvarValues, &szBody);

    DWORD csecTimeout;



    LPCWSTR c_rgszCallback1[] = {L"http://danielwew/upnp/foo1"};
    LPCWSTR c_rgszCallback2[] = {L"http://danielwew/upnp/foo2"};
    LPCWSTR c_rgszCallback3[] = {L"http://danielwew/upnp/foo3"};
    LPCWSTR c_rgszCallback4[] = {L"http://danielwew/upnp/foo4"};
    LPCWSTR c_rgszCallback5[] = {L"http://danielwew/upnp/foo5"};
    LPCWSTR c_rgszCallback6[] = {L"http://danielwew/upnp/foo6"};
    LPCWSTR c_rgszCallback7[] = {L"http://danielwew/upnp/foo7"};
    LPCWSTR c_rgszCallback8[] = {L"http://danielwew/upnp/foo8"};
    LPCWSTR c_rgszCallback9[] = {L"http://danielwew/upnp/foo9"};

    csecTimeout = 10;
    hr = HrAddSubscriber(L"EID 1", 0, 1, c_rgszCallback1, L"test event zero body", &csecTimeout, &szSid);
    csecTimeout = 20;
    hr = HrAddSubscriber(L"EID 1", 0, 1, c_rgszCallback2, L"test event zero body", &csecTimeout, &szSid2);
    csecTimeout = 30;
    hr = HrAddSubscriber(L"EID 1", 0, 1, c_rgszCallback3, L"test event zero body", &csecTimeout, &szSid);
    csecTimeout = 40;
    hr = HrAddSubscriber(L"EID 2", 0, 1, c_rgszCallback4, L"test event zero body", &csecTimeout, &szSid);
    csecTimeout = 5;
    hr = HrAddSubscriber(L"EID 2", 0, 1, c_rgszCallback5, L"test event zero body", &csecTimeout, &szSid);
    csecTimeout = 50;
    hr = HrAddSubscriber(L"EID 2", 0, 1, c_rgszCallback6, L"test event zero body", &csecTimeout, &szSid);
    csecTimeout = 60;
    hr = HrAddSubscriber(L"EID 1", 0, 1, c_rgszCallback7, L"test event zero body", &csecTimeout, &szSid);
    csecTimeout = 70;
    hr = HrAddSubscriber(L"EID 1", 0, 1, c_rgszCallback8, L"test event zero body", &csecTimeout, &szSid);
    csecTimeout = 80;
    hr = HrAddSubscriber(L"EID 2", 0, 1, c_rgszCallback9, L"test event zero body", &csecTimeout, &szSid);

    hr = HrDeregisterEventSource(L"bTesting 4");
    hr = HrDeregisterEventSource(L"Testing 3");
    hr = HrDeregisterEventSource(L"Testing 2");

    //Sleep(20000);

    csecTimeout = 100;
    hr = HrRenewSubscriber(L"EID 1", &csecTimeout, szSid);
    hr = HrRenewSubscriber(L"EID 1", &csecTimeout, szSid2);

   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)1, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);
   QueueUserWorkItem(SubmitWorker, (LPVOID)2, WT_EXECUTELONGFUNCTION);

/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)1); */
/*     SubmitWorker((LPVOID)2); */
/*     SubmitWorker((LPVOID)2); */


    hr = HrRemoveSubscriber(L"EID 1", szSid2);
    hr = HrRemoveSubscriber(L"EID 1", szSid);

    hr = HrRemoveSubscriber(L"EID 2", szSid);

    OutputDebugString(L"Sleeping...\n");
    Sleep(20000);

    hr = HrDeregisterEventSource(L"EID 1");
    hr = HrDeregisterEventSource(L"EID 2");

    DeInitEventApi();
    CoUninitialize();

    Sleep(2000);

    OutputDebugString(L"Exiting...\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   DLL entry points for upnphost.dll
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "uhbase.h"
#include "uhres.h"

#include "hostp.h"
#include "hostp_i.c"

#include "uhutil.h"

#define INITGUID
#include "uhclsid.h"

//+---------------------------------------------------------------------------
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for foo.idl by adding the following
//      files to the Outputs.
//          foo_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f foops.mk in the project directory.

// Proxy/Stub registration entry points
//
#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved)
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hinst, dwReason, pvReserved))
    {
        return FALSE;
    }
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls (hinst);
        InitializeDebugging();
        _Module.DllProcessAttach (hinst);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("upnphost.dll", _Module.GetLockCount());
        _Module.DllProcessDetach ();
        UnInitializeDebugging();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI
DllCanUnloadNow ()
{
#ifdef _MERGE_PROXYSTUB
    return PrxDllCanUnloadNow();
#endif
}

//+---------------------------------------------------------------------------
// Returns a class factory to create an object of the requested type
//
STDAPI
DllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

//+---------------------------------------------------------------------------
// ServiceMain - Called by the generic service process when starting
//                this service.
//
// type of LPSERVICE_MAIN_FUNCTIONW
//
EXTERN_C
VOID
WINAPI
ServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    _Module.ServiceMain (argc, argv);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrChangeServiceToRestart
//
//  Purpose:    Change the SCM registration to restart the service automatically if
//              dies prematurely.
//
//  Arguments:
//      (none)
//
//  Author:     mbend   11 Jan 2001
//
//  Notes:
//
HRESULT HrChangeServiceToRestart()
{
    HRESULT hr = S_OK;

    SC_HANDLE scm = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
    if(!scm)
    {
        hr = HrFromLastWin32Error();
    }
    if(SUCCEEDED(hr))
    {
        SC_HANDLE scUpnphost = OpenService(scm, L"upnphost", SERVICE_CHANGE_CONFIG | SERVICE_START);
        if(!scUpnphost)
        {
            hr = HrFromLastWin32Error();
        }
        if(SUCCEEDED(hr))
        {
            SC_ACTION scAction = {SC_ACTION_RESTART, 0};
            SERVICE_FAILURE_ACTIONS sfa = {INFINITE, NULL, NULL, 1, &scAction};

            if(!ChangeServiceConfig2(scUpnphost, SERVICE_CONFIG_FAILURE_ACTIONS, &sfa))
            {
                hr = HrFromLastWin32Error();
            }
            CloseServiceHandle(scUpnphost);
        }
        CloseServiceHandle(scm);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "HrChangeServiceToRestart");
    return hr;
}

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL    fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        _Module.UpdateRegistryFromResource (IDR_UPNPHOST, TRUE);

        hr = NcAtlModuleRegisterServer (&_Module);

#ifdef _MERGE_PROXYSTUB

        if(SUCCEEDED(hr))
        {
            hr = PrxDllRegisterServer ();
        }
#endif

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HrChangeServiceToRestart();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netman!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
    _Module.UpdateRegistryFromResource (IDR_UPNPHOST, FALSE);

    _Module.UnregisterServer ();

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer ();
#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\svcmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S V C M A I N . C P P
//
//  Contents:   Service main for upnphost.dll
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <dbt.h>
#include "uhbase.h"
#include "uhinit.h"
#include "uhres.h"
#include "hostp.h"

// Includes for COM objects needed in the following object map.
#include "DynamicContentSource.h"
#include "DescriptionManager.h"
#include "DevicePersistenceManager.h"
#include "ContainerManager.h"
#include "Registrar.h"
#include "AutomationProxy.h"
#include "evtobj.h"
#include "ValidationManager.h"
#include "udhhttp.h"
#include "uhcommon.h"

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_UPnPDynamicContentSource,           CDynamicContentSource)
    OBJECT_ENTRY(CLSID_UPnPDescriptionManager,             CDescriptionManager)
    OBJECT_ENTRY(CLSID_UPnPDevicePersistenceManager,       CDevicePersistenceManager)
    OBJECT_ENTRY(CLSID_UPnPContainerManager,               CContainerManager)
    OBJECT_ENTRY(CLSID_UPnPRegistrar,                      CRegistrar)
    OBJECT_ENTRY(CLSID_UPnPAutomationProxy,                CUPnPAutomationProxy)
    OBJECT_ENTRY(CLSID_UPnPEventingManager,                CUPnPEventingManager)
    OBJECT_ENTRY(CLSID_UPnPValidationManager,              CValidationManager)
END_OBJECT_MAP()


VOID
CServiceModule::DllProcessAttach (
    HINSTANCE hinst)
{
    CComModule::Init (ObjectMap, hinst);
}

VOID
CServiceModule::DllProcessDetach (
    VOID)
{
    CComModule::Term ();
}

DWORD
CServiceModule::DwHandler (
    DWORD dwControl,
    DWORD dwEventType,
    PVOID pEventData,
    PVOID pContext)
{
    if ((SERVICE_CONTROL_STOP == dwControl) ||
        (SERVICE_CONTROL_SHUTDOWN == dwControl))
    {
        TraceTag (ttidUPnPHost, "Received SERVICE_CONTROL_STOP request");
        SetServiceStatus (SERVICE_STOP_PENDING);

        // Post the quit message.
        //
        PostThreadMessage (m_dwThreadID, WM_QUIT, 0, 0);
    }

    else if (SERVICE_CONTROL_INTERROGATE == dwControl)
    {
        TraceTag (ttidUPnPHost, "Received SERVICE_CONTROL_INTERROGATE request");
        UpdateServiceStatus (FALSE);
    }

    return 1;
}

VOID
CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    m_status.dwCheckPoint   = 0;
    if (!::SetServiceStatus (m_hStatus, &m_status))
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::SetServiceStatus");
    }
}

VOID CServiceModule::UpdateServiceStatus (
    BOOL fUpdateCheckpoint /* = TRUE */)
{
    if (fUpdateCheckpoint)
    {
        m_status.dwCheckPoint++;
    }

    if (!::SetServiceStatus (m_hStatus, &m_status))
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::UpdateServiceStatus");
    }
}

VOID
CServiceModule::Run()
{
    HRESULT hr = S_OK;

    hr = CoInitializeEx (NULL,
                         COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    TraceHr (ttidError, FAL, hr, FALSE, "CServiceModule::Run: "
        "CoInitializeEx failed");

    if (SUCCEEDED(hr))
    {
        hr = HrCreateNetworkSID();
        TraceHr(ttidError, FAL, hr, FALSE,"HrCreateNetworkSID");
    }

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidUPnPHost, "Calling RegisterClassObjects...");

        // Create the event to sychronize registering our class objects
        // with the connection manager which attempts to CoCreate
        // objects which are also registered here.  I've seen cases
        // where the connection manager will be off and running before
        // this completes causing CoCreateInstance to fail.
        // The connection manager will wait on this event before
        // executing CoCreateInstance.
        //
        HANDLE hEvent;
        hr = HrNmCreateClassObjectRegistrationEvent (&hEvent);
        if (SUCCEEDED(hr))
        {
            hr = _Module.RegisterClassObjects (
                    CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
                    REGCLS_MULTIPLEUSE);
            TraceHr (ttidError, FAL, hr, FALSE, "CServiceModule::Run: "
                "_Module.RegisterClassObjects failed");

            if(SUCCEEDED(hr))
            {
                IUPnPRegistrarPrivate * pPriv = NULL;
                hr = HrCoCreateInstanceInproc(CLSID_UPnPRegistrar, &pPriv);
                if(SUCCEEDED(hr))
                {
                    hr = pPriv->Initialize();
                    ReleaseObj(pPriv);
                }
            }
            // Signal the event and close it.  If this delete's the
            // event, so be it. It's purpose is served as all
            // class objects have been registered.
            //
            SetEvent (hEvent);
            CloseHandle (hEvent);
        }

        if (SUCCEEDED(hr))
        {
            hr = HrHttpInitialize();
        }

        if (SUCCEEDED(hr))
        {
            SetServiceStatus (SERVICE_RUNNING);

            TraceTag (ttidUPnPHost, "upnphost is now running...");

            MSG msg;
            while (GetMessage (&msg, 0, 0, 0))
            {
                DispatchMessage (&msg);
            }

//            // We must synchronize with the install queue's thread otherwise
//            // RevokeClassObjects will kill the InstallQueue object and
//            // CoUninitialize will free the NetCfg module before the thread
//            // is finished.
//            //
//            WaitForInstallQueueToExit();

            if (SUCCEEDED(hr))
            {
                hr = HrHttpShutdown();
            }

            IUPnPRegistrarPrivate * pPriv = NULL;
            hr = HrCoCreateInstanceInproc(CLSID_UPnPRegistrar, &pPriv);
            if(SUCCEEDED(hr))
            {
                CoSuspendClassObjects();
                hr = pPriv->Shutdown();
                ReleaseObj(pPriv);
            }

            _Module.RevokeClassObjects ();
        }

        CoUninitialize();
    }

    CleanupNetworkSID();
}

VOID
CServiceModule::ServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    m_dwThreadID = GetCurrentThreadId ();

    ZeroMemory (&m_status, sizeof(m_status));
    m_status.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;

    // Register the service control handler.
    //
    m_hStatus = RegisterServiceCtrlHandlerEx (
                    L"upnphost",
                    _DwHandler,
                    NULL);
    if (m_hStatus)
    {
        SetServiceStatus (SERVICE_START_PENDING);

        // When the Run function returns, the service has stopped.
        //
        Run ();

        SetServiceStatus (SERVICE_STOPPED);
    }
    else
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::ServiceMain - RegisterServiceCtrlHandler failed");
    }
}

// static
DWORD
WINAPI
CServiceModule::_DwHandler (
    DWORD dwControl,
    DWORD dwEventType,
    PVOID pEventData,
    PVOID pContext)
{
    return _Module.DwHandler (dwControl, dwEventType, pEventData, pContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\upnphost.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P N P H O S T . C P P
//
//  Contents:   DLL initialization for UPnP Device Host
//
//  Notes:
//
//  Author:     danielwe   10 Jul 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "hostinc.h"
#include "exetst.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL    bRet = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        InitializeDebugging();

        _Module.Init(ObjectMap, hInstance, &LIBID_UPNPLib);
        DisableThreadLibraryCalls(hInstance);

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();

        UnInitializeDebugging();
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return(_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\dll\uhinit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H I N I T . C P P
//
//  Contents:   Initialization routines for upnphost.
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "uhbase.h"
#include "uhinit.h"

static const WCHAR c_szClassObjectRegistrationEvent [] =
    L"UpnphostClassObjectRegistrationEvent";

//+---------------------------------------------------------------------------
//
//  Function:   HrNmCreateClassObjectRegistrationEvent
//
//  Purpose:    Create the named event that will be signaled after
//              our class objects have been registered.
//
//  Arguments:
//      phEvent [out] Returned event handle
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   27 Jan 1998
//
//  Notes:
//
HRESULT
HrNmCreateClassObjectRegistrationEvent (
    HANDLE* phEvent)
{
    Assert (phEvent);

    HRESULT hr = S_OK;

    // Create the name event and return it.
    //
    *phEvent = CreateEvent (NULL, FALSE, FALSE,
                    c_szClassObjectRegistrationEvent);
    if (!*phEvent)
    {
        hr = HrFromLastWin32Error ();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrNmCreateClassObjectRegistrationEvent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNmWaitForClassObjectsToBeRegistered
//
//  Purpose:    For the event to be signaled if it can be opened.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   27 Jan 1998
//
//  Notes:
//
HRESULT
HrNmWaitForClassObjectsToBeRegistered ()
{
    HRESULT hr = S_OK;

    // Try to open the named event.  If it does not exist,
    // that's okay because we've probably already created and destroyed
    // it before this function was called.
    //
    HANDLE hEvent = OpenEvent (SYNCHRONIZE, FALSE,
                        c_szClassObjectRegistrationEvent);
    if (hEvent)
    {
        // Now wait for the event to be signaled while pumping messages
        // as needed.  We'll wait for up to 10 seconds.  That should be
        // plenty of time for the class objects to be registered.
        //
        while (1)
        {
            const DWORD cMaxWaitMilliseconds = 10000;   // 10 seconds

            DWORD dwWait = MsgWaitForMultipleObjects (1, &hEvent, FALSE,
                                cMaxWaitMilliseconds, QS_ALLINPUT);
            if ((WAIT_OBJECT_0 + 1) == dwWait)
            {
                // We have messages to pump.
                //
                MSG msg;
                while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                    DispatchMessage (&msg);
                }
            }
            else
            {
                // Wait is satisfied, or we had a timeout, or an error.
                //
                if (WAIT_TIMEOUT == dwWait)
                {
                    hr = HRESULT_FROM_WIN32 (ERROR_TIMEOUT);
                }
                else if (0xFFFFFFFF == dwWait)
                {
                    hr = HrFromLastWin32Error ();
                }

                break;
            }
        }

        CloseHandle (hEvent);
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "HrNmWaitForClassObjectsToBeRegistered");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\evtapi\evtapi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V T A P I . C P P
//
//  Contents:   Private low-level APIs dealing with UPnP events.
//
//  Notes:
//
//  Author:     danielwe   18 Oct 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <hostinc.h>
#include "evtapi.h"
#include "stdio.h"
#include "interfacelist.h"
#include <wininet.h>
#include <winsock.h>

HANDLE                      g_hTimerQ = NULL;
CRITICAL_SECTION            g_csListEventSource;
UPNP_EVENT_SOURCE *         g_pesList = NULL;
HINTERNET                   g_hInetSess = NULL;
static const DWORD          c_csecTimeout = 30;     // Internet connect
                                                    // timeout (in seconds)

// Default subscription timeout (6 hours)
static const DWORD          c_csecDefSubsTimeout = 60 * 60 * 6;

// Minimum subscription timeout (10 minutes??)
static const DWORD          c_csecMinSubsTimeout = 60 * 10;

VOID FreeEventSourceBlocking(UPNP_EVENT_SOURCE * pes);

//+---------------------------------------------------------------------------
//
//  Function:   HrInitEventApi
//
//  Purpose:    Initializes the low-level eventing API
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
HRESULT HrInitEventApi()
{
    HRESULT     hr = S_OK;

    InitializeCriticalSection(&g_csListEventSource);

    if (SUCCEEDED(hr))
    {
        AssertSz(!g_hTimerQ, "Already initialized timer queue?!?");

        g_hTimerQ = CreateTimerQueue();
        if (!g_hTimerQ)
        {
            hr = HrFromLastWin32Error();
            TraceError("HrInitEventApi: CreateTimerQueue", hr);
        }
    }

    TraceError("HrInitEventApi", hr);
    return hr;
}

HRESULT HrInitInternetSession()
{
    HRESULT     hr = S_OK;

    AssertSz(!g_hInetSess, "Already initialized?");

    g_hInetSess = InternetOpen(L"Mozilla/4.0 (compatible; UPnP/1.0; Windows NT/5.1)",
                               INTERNET_OPEN_TYPE_DIRECT,
                               NULL, NULL, 0);
    if (g_hInetSess)
    {
        DWORD   dwTimeout = c_csecTimeout * 1000;

        if (!InternetSetOption(g_hInetSess, INTERNET_OPTION_CONNECT_TIMEOUT,
                               (LPVOID)&dwTimeout, sizeof(DWORD)))
        {
            hr = HrFromLastWin32Error();
            TraceError("HrFromLastWin32Error: InternetSetOption",
                       HrFromLastWin32Error());
        }
        else
        {
            TraceTag(ttidEventServer, "HrFromLastWin32Error: Suscessfully set "
                     "internet connect timeout to %d seconds",
                     c_csecTimeout);
        }
        if(SUCCEEDED(hr))
        {
            INTERNET_PROXY_INFO ipi;
            ZeroMemory(&ipi, sizeof(ipi));
            ipi.dwAccessType = INTERNET_OPEN_TYPE_DIRECT;
            if(!InternetSetOption(g_hInetSess, INTERNET_OPTION_PROXY, &ipi, sizeof(ipi)))
            {
                hr = HrFromLastWin32Error();
                TraceError("HrFromLastWin32Error: InternetSetOption",
                           HrFromLastWin32Error());
            }
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
        TraceError("HrInitInternetSession: InternetOpen", hr);
    }

    TraceError("HrInitInternetSession", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeInitEventApi
//
//  Purpose:    De-initializes the low-level eventing API
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      The debug version fills the critsec struct after deleting it
//              to catch use afterwards
//
VOID DeInitEventApi()
{
    UPNP_EVENT_SOURCE * pesCur;
    UPNP_EVENT_SOURCE * pesNext;

    // Delete any remaining event sources from the list. This will block until
    // all event sources have been deleted
    //
    EnterCriticalSection(&g_csListEventSource);

    for (pesCur = g_pesList; pesCur; pesCur = pesNext)
    {
        pesNext = pesCur->pesNext;

        FreeEventSourceBlocking(pesCur);
    }

    g_pesList = NULL;

    LeaveCriticalSection(&g_csListEventSource);

    if (g_hInetSess)
    {
        InternetCloseHandle(g_hInetSess);
        g_hInetSess = NULL;
    }

    if (g_hTimerQ)
    {
        // This will wait for all callback threads to finish before continuing
        // (in other words, it blocks)
        //
        DeleteTimerQueueEx(g_hTimerQ, INVALID_HANDLE_VALUE);

        TraceTag(ttidEventServer, "DeInitEventApi: Deleted timer queue");

        g_hTimerQ = NULL;
    }

    DeleteCriticalSection(&g_csListEventSource);

#if DBG
    FillMemory(&g_csListEventSource, sizeof(CRITICAL_SECTION), 0xDA);
#endif

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeSubscriber
//
//  Purpose:    Frees the memory and resources used by a subscriber and frees
//              the subscriber itself
//
//  Arguments:
//      psub         [in]   Subscriber to free
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
VOID FreeSubscriber(UPNP_SUBSCRIBER *psub)
{
    UPNP_EVENT *    pevtCur;
    UPNP_EVENT *    pevtNext;
    HANDLE          hWait = NULL;

    if (!psub)
    {
        return;
    }

#if DBG
    if (psub->szSid)
    {
        TraceTag(ttidEventServer, "Freeing subscriber %S", psub->szSid);
    }
#endif

    DWORD isz;

    for (isz = 0; isz < psub->cszUrl; isz++)
    {
        delete [] psub->rgszUrl[isz];
    }

    delete [] psub->szSid;
    delete [] psub->rgszUrl;

    // Free the event queue
    //
    for (pevtCur = psub->pevtQueue;
         pevtCur;
         pevtCur = pevtNext)
    {
        delete [] pevtCur->szBody;

        pevtNext = pevtCur->pevtNext;
        delete pevtCur;
    }

    if (psub->hWait)
    {
        TraceTag(ttidEventServer, "About to call UnregisterWaitEx()");
        // This will wait for all callback threads to finish before continuing
        // (in other words, it blocks)
        //
        if (!UnregisterWaitEx(psub->hWait, INVALID_HANDLE_VALUE))
        {
            TraceError("FreeSubscriber: UnregisterWaitEx",
                       HrFromLastWin32Error());
        }
        else
        {
            TraceTag(ttidEventServer, "FreeSubscriber: Unregistered wait");
        }
    }

    if (psub->hEventQ && psub->hEventQ != INVALID_HANDLE_VALUE)
    {
        CloseHandle(psub->hEventQ);
        TraceTag(ttidEventServer, "FreeSubscriber: Closed event handle");
    }

    if (psub->hTimer)
    {
        AssertSz(g_hTimerQ, "No timer queue??");

        if (!DeleteTimerQueueTimer(g_hTimerQ, psub->hTimer,
                                   INVALID_HANDLE_VALUE))
        {
            TraceError("FreeSubscriber: DeleteTimerQueueTimer",
                       HrFromLastWin32Error());
        }
        else
        {
            TraceTag(ttidEventServer, "FreeSubscriber: Deleted timer "
                     "queue timer");
        }
    }

    // Delete renewal params
    //
    delete [] psub->ur.szEsid;
    delete [] psub->ur.szSid;

    // Delete event queue worker wait params
    //
    delete [] psub->uwp.szEsid;
    delete [] psub->uwp.szSid;

    delete psub;
}

VOID FreeEventSourceBlocking(UPNP_EVENT_SOURCE * pes)
{
    UPNP_SUBSCRIBER *   psubCur;
    UPNP_SUBSCRIBER *   psubNext;

    for (psubCur = pes->psubList;
         psubCur;
         psubCur = psubNext)
    {
        psubNext = psubCur->psubNext;

        FreeSubscriber(psubCur);
    }

    delete [] pes->szEsid;
    delete pes;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeEventSourceWorker
//
//  Purpose:    Worker function to free an event source and the resources it
//              uses
//
//  Arguments:
//      pvContext [in]  Context data = event source to free
//
//  Returns:    0
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      This function is always called from a separate thread
//
DWORD WINAPI FreeEventSourceWorker(LPVOID pvContext)
{
    UPNP_EVENT_SOURCE * pes;

    pes = (UPNP_EVENT_SOURCE *)pvContext;

    Assert(pes);

    FreeEventSourceBlocking(pes);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeSubscriberWorker
//
//  Purpose:    Worker function to free a subscriber and the resources it uses
//
//  Arguments:
//      pvContext [in]  Context data = subscriber to free
//
//  Returns:    0
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      This function is always called from a separate thread
//
DWORD WINAPI FreeSubscriberWorker(LPVOID pvContext)
{
    UPNP_SUBSCRIBER *   psub;

    psub = (UPNP_SUBSCRIBER *)pvContext;

    Assert(psub);

    TraceTag(ttidEventServer, "FreeSubscriberWorker: Freeing subscriber %S",
             psub->szSid);

    FreeSubscriber(psub);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeEventSource
//
//  Purpose:    Frees an event source structure and the resources it uses
//
//  Arguments:
//      pes [in]    Event source to free
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      The free is done asynchronously, on a separate thread
//
VOID FreeEventSource(UPNP_EVENT_SOURCE * pes)
{
    if (pes)
    {
#if DBG
        EnterCriticalSection(&g_csListEventSource);

        AssertSz(!PesFindEventSource(pes->szEsid), "I will not let you free"
                 " an event source that's still in the global list!");

        LeaveCriticalSection(&g_csListEventSource);
#endif

        TraceTag(ttidEventServer, "Queueing a work item to free event "
                 "source %S", pes->szEsid);

        // Now that the event source is off the list and no external function can
        // access it anymore we can queue a work item to do the time consuming stuff
        //
        QueueUserWorkItem(FreeEventSourceWorker, (LPVOID)pes,
                          WT_EXECUTELONGFUNCTION);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterEventSource
//
//  Purpose:    Registers a service as an event source
//
//  Arguments:
//      szEsid      [in]  Event source identifier
//
//  Returns:    S_OK if successful, E_OUTOFMEMORY, or Win32 error
//
//  Author:     danielwe   10 Jul 2000
//
//  Notes:
//
HRESULT HrRegisterEventSource(LPCWSTR szEsid)
{
    HRESULT             hr = S_OK;
    UPNP_EVENT_SOURCE * pesNew = NULL;

    Assert(szEsid && *szEsid);

    EnterCriticalSection(&g_csListEventSource);

    if (!PesFindEventSource(szEsid))
    {
        pesNew = new UPNP_EVENT_SOURCE;
        if (pesNew)
        {
            ZeroMemory(pesNew, sizeof(UPNP_EVENT_SOURCE));

            pesNew->szEsid = WszDupWsz(szEsid);
            if (!pesNew->szEsid)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        TraceTag(ttidEventServer, "HrRegisterEventSource - duplicated event "
                 "source %S", szEsid);
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        // Link in this event source at the head of the global list
        //
        pesNew->pesNext = g_pesList;
        g_pesList = pesNew;
    }

    LeaveCriticalSection(&g_csListEventSource);

    if (FAILED(hr))
    {
        FreeEventSource(pesNew);
    }
    else
    {
        //DbgDumpListEventSource();
    }

    TraceError("HrRegisterEventSource", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDeregisterEventSource
//
//  Purpose:    Deregisters a service as an event source
//
//  Arguments:
//      szEsid [in]     Event source identifier
//
//  Returns:    S_OK if success, E_INVALIDARG
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
HRESULT HrDeregisterEventSource(LPCWSTR szEsid)
{
    HRESULT             hr = S_OK;
    UPNP_EVENT_SOURCE * pesCur;
    UPNP_EVENT_SOURCE * pesPrev;

    EnterCriticalSection(&g_csListEventSource);

    for (pesCur = pesPrev = g_pesList;
         pesCur;
         pesPrev = pesCur, pesCur = pesCur->pesNext)
    {
        if (!lstrcmpi(pesCur->szEsid, szEsid))
        {
            TraceTag(ttidEventServer, "Deregistering event source %S", szEsid);

            if (pesCur == g_pesList)
            {
                g_pesList = pesCur->pesNext;
            }
            else
            {
                AssertSz(pesPrev != pesCur, "Event sourcelist is messed up!");
                AssertSz(pesCur != g_pesList, "Event sourcelist is messed up!");

                pesPrev->pesNext = pesCur->pesNext;
            }

            break;
        }
    }

    if (pesCur)
    {
        FreeEventSource(pesCur);
    }
    else
    {
        TraceTag(ttidEventServer, "Event source %S not found!", szEsid);
        hr = E_INVALIDARG;
    }

    LeaveCriticalSection(&g_csListEventSource);

    //DbgDumpListEventSource();

    TraceError("HrDeregisterEventSource", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzGetNewSid
//
//  Purpose:    Returns a new "uuid:{SID}" identifier
//
//  Arguments:
//      (none)
//
//  Returns:    Newly allocated SID string
//
//  Author:     danielwe   13 Oct 1999
//
//  Notes:      Caller must free the returned string with delete []
//
LPWSTR SzGetNewSid()
{
    WCHAR           szSid[256];
    UUID            uuid;
    unsigned short *szUuid;

    if (UuidCreate(&uuid) == RPC_S_OK)
    {
        if (UuidToString(&uuid, &szUuid) == RPC_S_OK)
        {
            wsprintf(szSid, L"uuid:%s", szUuid);
            RpcStringFree(&szUuid);
            return WszDupWsz(szSid);
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   EventQueueWorker
//
//  Purpose:    Worker function to remove an event off the event queue for
//              a specific subscriber and submit it to that subscriber
//
//  Arguments:
//      pvContext [in]  Context data = event source and subscriber
//      fTimeOut  [in]  UNUSED
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      This function calls into WinINET
//
VOID WINAPI EventQueueWorker(LPVOID pvContext, BOOLEAN fTimeOut)
{
    UPNP_WAIT_PARAMS *  puwp;
    LPWSTR              szSid = NULL;
    LPWSTR *            rgszUrl = NULL;
    DWORD               cszUrl = 0;
    HRESULT             hr = S_OK;
    BOOL                fLeave = TRUE;
    UPNP_EVENT_SOURCE * pes;
    DWORD               isz;

    puwp = (UPNP_WAIT_PARAMS *)pvContext;

    Assert(puwp);

    TraceTag(ttidEventServer, "Event queue worker (%S:%S) entering critsec...",
             puwp->szEsid, puwp->szSid);

    EnterCriticalSection(&g_csListEventSource);

    TraceTag(ttidEventServer, "...entered");

    pes = PesFindEventSource(puwp->szEsid);
    if (pes)
    {
        UPNP_SUBSCRIBER *   psub;
        UPNP_EVENT *        pevt;
        DWORD               iSeq;
        HANDLE              hEvent;

        psub = PsubFindSubscriber(pes, puwp->szSid);
        if (psub)
        {
            if (CUPnPInterfaceList::Instance().FShouldSendOnInterface(psub->dwIpAddr))
            {
                BOOL    fEmpty;

                // Remove first event off the list
                //
                pevt = psub->pevtQueue;

                TraceTag(ttidEventServer, "Processing event %p", pevt);

                AssertSz(pevt, "Worker is awake but nothing to do today!");

                psub->pevtQueue = pevt->pevtNext;

                // Any more items on the queue?
                fEmpty = !psub->pevtQueue;

                if (fEmpty)
                {
                    psub->pevtQueueTail = NULL;
                }

                TraceTag(ttidEventServer, "Event queue is%s empty",
                         fEmpty ? "" : " NOT");

                szSid = WszDupWsz(psub->szSid);
                if (!szSid)
                {
                    hr = E_OUTOFMEMORY;
                    goto cleanup;
                }

                // Copy the list of URLs so we can access it safely outside of the
                // critsec
                cszUrl = psub->cszUrl;

                Assert(cszUrl);

                rgszUrl = new LPWSTR[cszUrl];
                if (!rgszUrl)
                {
                    hr = E_OUTOFMEMORY;
                    goto cleanup;
                }

                for (isz = 0; isz < cszUrl; isz++)
                {
                    rgszUrl[isz] = WszDupWsz(psub->rgszUrl[isz]);
                    if (!rgszUrl[isz])
                    {
                        hr = E_OUTOFMEMORY;
                        goto cleanup;
                    }
                }

                // Wrap sequence number to 1 to avoid overflow
                if (psub->iSeq == MAXDWORD)
                {
                    psub->iSeq = 1;
                }

                // Increment the sequence number after assigning it to a local
                // variable.
                //
                iSeq = psub->iSeq++;

                TraceTag(ttidEventServer, "New sequence # is %d. About to send "
                         "sequence #%d", psub->iSeq, iSeq);

                // Last thing to do is signal the queue event so another worker
                // can pick up the next event off the queue. Only do this if the
                // event queue is still not empty.
                //
                if (!fEmpty)
                {
                    TraceTag(ttidEventServer, "Signalling event again");
                    SetEvent(psub->hEventQ);
                }

                // Don't need the lock anymore
                LeaveCriticalSection(&g_csListEventSource);

                TraceTag(ttidEventServer, "Released lock on global event source list");

                fLeave = FALSE;

                LPWSTR  szHeaders;

                hr = HrComposeUpnpNotifyHeaders(iSeq, szSid, &szHeaders);
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;

                    // Try the list of URLs until either we run out of them, or
                    // we succeed
                    //
                    for (isz = 0; FAILED(hr) && isz < cszUrl; isz++)
                    {
                        hr = HrSubmitNotifyToSubscriber(szHeaders, pevt->szBody,
                                                        rgszUrl[isz]);
                    }

                    delete [] szHeaders;
                }

                delete [] pevt->szBody;
                delete pevt;
            }
            else
            {
                TraceTag(ttidEventServer, "EventQueueWorker: Not sending to subscriber since it"
                         " came in on IP address %s",
                         inet_ntoa(*(struct in_addr *)&psub->dwIpAddr));
            }
        }
        else
        {
            TraceTag(ttidEventServer, "EventQueueWorker: Did not find "
                     "subscriber %S in event source %S", puwp->szEsid,
                     puwp->szSid);
        }
    }
    else
    {
        TraceTag(ttidEventServer, "EventQueueWorker: Did not find "
                 "event source %S", puwp->szEsid);
    }

cleanup:

    delete [] szSid;

    if (rgszUrl)
    {
        for (isz = 0; isz < cszUrl; isz++)
        {
            delete [] rgszUrl[isz];
        }
    }

    delete [] rgszUrl;

    if (fLeave)
    {
        LeaveCriticalSection(&g_csListEventSource);
        TraceTag(ttidEventServer, "Release lock (2) on global event source list");
    }

    TraceError("EventQueueWorker", hr)
}

//+---------------------------------------------------------------------------
//
//  Function:   RenewalCallback
//
//  Purpose:    Callback function that is called when a subscriber's renewal
//              timer has expired, which means it should be removed
//
//  Arguments:
//      pvContext [in]  Context data = event source identifier and subscriber
//      fTimeOut  [in]  UNUSED
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
VOID WINAPI RenewalCallback(LPVOID pvContext, BOOLEAN fTimeOut)
{
    UPNP_RENEWAL *      pur;
    UPNP_EVENT_SOURCE * pes;
    HRESULT             hr = S_OK;
    UPNP_SUBSCRIBER *   psubToDelete = NULL;

    pur = (UPNP_RENEWAL *)pvContext;

    Assert(pur);

    TraceTag(ttidEventServer, "RenewalCallback: Called for %S:%S (%d)",
             pur->szEsid, pur->szSid, pur->iRenewal);

    EnterCriticalSection(&g_csListEventSource);

    pes = PesFindEventSource(pur->szEsid);
    if (pes)
    {
        UPNP_SUBSCRIBER *   psubCur;
        UPNP_SUBSCRIBER *   psubPrev;

        for (psubCur = psubPrev = pes->psubList;
             psubCur;
             psubPrev = psubCur,
             psubCur = psubCur->psubNext)
        {
            if (!lstrcmpi(psubCur->szSid, pur->szSid))
            {
                if (psubCur->cRenewals == pur->iRenewal)
                {
                    TraceTag(ttidEventServer, "RenewalCallback: Removing subscriber"
                             " %S from event source %S", psubCur->szSid,
                             pes->szEsid);

                    // Remove subscriber from the list

                    if (psubCur == pes->psubList)
                    {
                        // Removal of head item
                        pes->psubList = psubCur->psubNext;
                    }
                    else
                    {
                        psubPrev->psubNext = psubCur->psubNext;
                    }

                    TraceTag(ttidEventServer, "RenewalCallback: Queuing work item"
                             " to free subscriber %S", pur->szSid);

                    // Can no longer rely on this because once the subscriber is
                    // removed from the list, its owning event source is off limits
                    //
                    psubCur->pes = NULL;

                    psubToDelete = psubCur;
                }
                else
                {
                    TraceTag(ttidEventServer, "RenewalCallback: Found subscriber %S"
                             "but renewal counter does not match %d vs. %d",
                             psubCur->szSid, psubCur->cRenewals, pur->iRenewal);
                }
                break;
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        TraceTag(ttidEventServer, "RenewalCallback: Did not find event"
                 " source %S", pur->szEsid);
    }

    LeaveCriticalSection(&g_csListEventSource);

    if (psubToDelete)
    {
        QueueUserWorkItem(FreeSubscriberWorker, (LPVOID)psubToDelete,
                          WT_EXECUTELONGFUNCTION);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddSubscriber
//
//  Purpose:    Adds a new subscriber to the list for a particular event source
//
//  Arguments:
//      szEsid          [in]      Event source identifier
//      dwIpAddr        [in]      Local IP address that the subscribe came in on
//      cszUrl          [in]      Number of callback URLs
//      rgszCallbackUrl [in]      Callback URLs of subscriber
//      pcsecTimeout    [in out]  Subscription timeout requested by subscriber
//                                Upon return, receives the timeout chosen by
//                                the device host
//      pszSid          [out]     Returns the newly allocated SID
//
//  Returns:    S_OK if success, E_OUTOFMEMORY,
//              or ERROR_FILE_NOT_FOUND if the event source did not exist
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      Caller should free the returned pszSid with delete []
//
HRESULT HrAddSubscriber(LPCWSTR szEsid, DWORD dwIpAddr, DWORD cszUrl,
                        LPCWSTR *rgszCallbackUrl,
                        LPCWSTR szEventBody, DWORD *pcsecTimeout,
                        LPWSTR *pszSid)
{
    HRESULT             hr = S_OK;
    UPNP_SUBSCRIBER *   psub;
    UPNP_WAIT_PARAMS *  puwp;
    UPNP_EVENT_SOURCE * pes;
    LPWSTR              szSid = NULL;

    Assert(pszSid);
    Assert(pcsecTimeout);

    TraceTag(ttidEventServer, "Adding subscriber from %S (%d) to %S",
             rgszCallbackUrl[0], cszUrl, szEsid);

    psub = new UPNP_SUBSCRIBER;
    if (!psub)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    ZeroMemory(psub, sizeof(UPNP_SUBSCRIBER));

    psub->dwIpAddr = dwIpAddr;

    psub->hEventQ = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!psub->hEventQ || psub->hEventQ == INVALID_HANDLE_VALUE)
    {
        hr = HrFromLastWin32Error();
        TraceError("HrAddSubscriber: CreateEvent", hr);
        goto cleanup;
    }

    psub->szSid = SzGetNewSid();
    if (!psub->szSid)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    TraceTag(ttidEventServer, "Allocated new SID: %S", psub->szSid);

    // Make a local copy of this for later use in HrSubmitEventZero() and also
    // so we can return it to the caller
    //
    szSid = WszDupWsz(psub->szSid);
    if (!szSid)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    DWORD   isz;

    psub->cszUrl = cszUrl;
    psub->rgszUrl = new LPWSTR[cszUrl];
    if (!psub->rgszUrl)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    for (isz = 0; isz < cszUrl; isz++)
    {
        psub->rgszUrl[isz] = WszDupWsz(rgszCallbackUrl[isz]);
        if (!psub->rgszUrl[isz])
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    psub->uwp.szEsid = WszDupWsz(szEsid);
    if (!psub->uwp.szEsid)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    psub->uwp.szSid = WszDupWsz(psub->szSid);
    if (!psub->uwp.szSid)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // ISSUE-2000/10/2-danielwe: Registering the wait with the
    // WT_EXECUTELONGFUNCTION flag means that a new thread will be created
    // FOR EACH SUBSCRIBER. This may be a bad thing depending on how many
    // subscribers there are expected to be. Creating threads with this flag
    // would be to handle the case where one or more subscribers are timing
    // out sending the NOTIFY to them or they are just plain slow. If this
    // flag is not used, these subscribers will cause the eventing queues to
    // bottleneck because no free threads are available to service them. So,
    // to summarize:
    //
    // Using the WT_EXECUTELONGFUNCTION flag:
    // --------------------------------------
    // Pros: Never a bottleneck sending event notifications. They always
    //       arrive when expected.
    // Cons: Will end up with lots of threads if there are lots of subscribers
    //       However, once the subscribers unsubscribe, the thread count would
    //       eventually go back down again.
    //
    // Not using the flag:
    // -------------------
    // Pros: Efficient. Only create the threads that are needed.
    // Cons: May end up with events backing up in the queue if subscribers
    //       time out frequently.
    //
    // Choice is still up in the air. We'll set the flag for now and see how
    // bad this gets during stress time.
    //
    if (!RegisterWaitForSingleObject(&psub->hWait, psub->hEventQ,
                                     EventQueueWorker, (LPVOID)&psub->uwp,
                                     INFINITE, WT_EXECUTELONGFUNCTION))
    {
        hr = HrFromLastWin32Error();
        TraceError("HrAddSubscriber: RegisterWaitForSingleObject", hr);
        goto cleanup;
    }

    EnterCriticalSection(&g_csListEventSource);

    pes = PesFindEventSource(szEsid);
    if (!pes)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        TraceTag(ttidEventServer, "HrAddSubscriber: Event source %S not found!",
                 szEsid);
        LeaveCriticalSection(&g_csListEventSource);
        goto cleanup;
    }

    psub->ur.iRenewal = psub->cRenewals;

    psub->ur.szEsid = WszDupWsz(pes->szEsid);
    if (!psub->ur.szEsid)
    {
        hr = E_OUTOFMEMORY;
        LeaveCriticalSection(&g_csListEventSource);
        goto cleanup;
    }

    psub->ur.szSid = WszDupWsz(psub->szSid);
    if (!psub->ur.szSid)
    {
        hr = E_OUTOFMEMORY;
        LeaveCriticalSection(&g_csListEventSource);
        goto cleanup;
    }

    if (!*pcsecTimeout)
    {
        *pcsecTimeout = c_csecDefSubsTimeout;
    }
    else
    {
        *pcsecTimeout = max(c_csecMinSubsTimeout, *pcsecTimeout);
    }

    psub->csecTimeout = *pcsecTimeout;

    if (!CreateTimerQueueTimer(&psub->hTimer, g_hTimerQ,
                               RenewalCallback, (LPVOID)&psub->ur,
                               *pcsecTimeout * 1000, 0, WT_EXECUTEINTIMERTHREAD))
    {
        hr = HrFromLastWin32Error();
        TraceError("HrAddSubscriber: CreateTimerQueueTimer", hr);
        LeaveCriticalSection(&g_csListEventSource);
        goto cleanup;
    }

    psub->pes = pes;

    // Link in the new subscriber to the event source's list (add at head
    // of list because it's quicker and order doesn't matter one bit)
    //
    if (!pes->psubList)
    {
        pes->psubList = psub;
    }
    else
    {
        psub->psubNext = pes->psubList;
        pes->psubList = psub;
    }

    TraceTag(ttidEventServer, "Adding psub = %p to list", psub);

    LeaveCriticalSection(&g_csListEventSource);

    *pszSid = szSid;

    TraceTag(ttidEventServer, "Adding event zero notification for %S:%S",
             szEsid, szSid);

    hr = HrSubmitEventZero(szEsid, szSid, szEventBody);

done:
    TraceError("HrAddSubscriber", hr);
    return hr;

cleanup:

    delete [] szSid;

    FreeSubscriber(psub);
    goto done;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRenewSubscriber
//
//  Purpose:    Renews the given subscriber's subscription
//
//  Arguments:
//      szEsid          [in]        Event source identifier
//      pcsecTimeout    [in out]    Subscription timeout requested by subscriber
//                                  Upon return, receives the timeout chosen by
//                                  the device host
//      szSid           [in]        Subscriber identifier (SID)
//
//  Returns:    S_OK if success, ERROR_FILE_NOT_FOUND if event source or
//              subscription was not found
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
HRESULT HrRenewSubscriber(LPCWSTR szEsid, DWORD *pcsecTimeout, LPCWSTR szSid)
{
    HRESULT             hr = S_OK;
    UPNP_EVENT_SOURCE * pes;
    HANDLE              hTimerDel = NULL;

    TraceTag(ttidEventServer, "HrRenewSubscriber: Renewing subscriber with "
             "SID %S for event source %S", szSid, szEsid);
    TraceTag(ttidEventServer, "Tickcount for renewal callback is %d",
             GetTickCount());

    EnterCriticalSection(&g_csListEventSource);

    pes = PesFindEventSource(szEsid);
    if (pes)
    {
        UPNP_SUBSCRIBER *   psub;

        psub = PsubFindSubscriber(pes, szSid);
        if (psub)
        {
            // We don't care if the timer is currently executing because we're
            // inside the critsec right now and so if we got here before the
            // timer proc did, then we made it just in time to bump the
            // renewal count so the proc doesn't delete this guy. If the timer
            // proc had acquired the critsec first, then we couldn't possibly
            // be here because it would have removed the subscriber from the
            // list already
            //

            hTimerDel = psub->hTimer;

            psub->cRenewals++;

            // Delete the old renewal structure
            //
            delete [] psub->ur.szEsid;
            delete [] psub->ur.szSid;

            psub->ur.szEsid = NULL;
            psub->ur.szSid = NULL;
            psub->ur.iRenewal = psub->cRenewals;

            psub->ur.szEsid = WszDupWsz(pes->szEsid);
            if (!psub->ur.szEsid)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                psub->ur.szSid = WszDupWsz(psub->szSid);
                if (!psub->ur.szSid)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    if (!*pcsecTimeout)
                    {
                        *pcsecTimeout = c_csecDefSubsTimeout;
                    }
                    else
                    {
                        *pcsecTimeout = max(c_csecMinSubsTimeout,
                                            *pcsecTimeout);
                    }

                    psub->csecTimeout = *pcsecTimeout;

                    if (!CreateTimerQueueTimer(&psub->hTimer, g_hTimerQ,
                                               RenewalCallback,
                                               (LPVOID)&psub->ur,
                                               *pcsecTimeout * 1000, 0,
                                               WT_EXECUTEINTIMERTHREAD))
                    {
                        hr = HrFromLastWin32Error();
                        TraceError("HrRenewSubscriber: CreateTimerQueueTimer", hr);
                    }
                    else
                    {
                        TraceTag(ttidEventServer, "Started server renewal "
                                 "timer for %d seconds at tickcount %d",
                                 *pcsecTimeout, GetTickCount());
                    }
                }
            }
        }
        else
        {
            // Return 412 Precondition Failed
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
            TraceTag(ttidEventServer, "HrRenewSubscriber: Did not find"
                     " subscriber %S in event source %S", szSid, szEsid);
        }
    }
    else
    {
        // Return 404 Not Found
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        TraceTag(ttidEventServer, "HrRenewSubscriber: Did not find event"
                 " source %S", szEsid);
    }

    LeaveCriticalSection(&g_csListEventSource);

    // ISSUE-2000/12/1-danielwe: DeleteTimerQueueTimer() apparently
    // will block if called on a timer that is currently executing
    // its callback. It is unknown whether this is a bug in its
    // implementation or not. To work around this problem, we'll
    // leave the critsec so that the RenewalCallback() function can complete
    // and then delete the timer. After deleting the timer, we signal the
    // event that allows FreeEventSourceWorker() to delete the timer queue
    //

    if (hTimerDel)
    {
        DeleteTimerQueueTimer(g_hTimerQ, hTimerDel, NULL);
    }

    TraceError("HrRenewSubscriber", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveSubscriber
//
//  Purpose:    Removes a subscriber from the list of subscribers to an
//              event source
//
//  Arguments:
//      szEsid [in]     Event source identifier
//      szSid  [in]     Subscriber identifier (SID)
//
//  Returns:    S_OK if success, ERROR_FILE_NOT_FOUND if event source or
//              subscription was not found
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
HRESULT HrRemoveSubscriber(LPCWSTR szEsid, LPCWSTR szSid)
{
    HRESULT     hr = S_OK;

    UPNP_EVENT_SOURCE * pes;

    TraceTag(ttidEventServer, "HrRemoveSubscriber: Removing subscriber with "
             "SID %S for event source %S", szSid, szEsid);

    EnterCriticalSection(&g_csListEventSource);

    pes = PesFindEventSource(szEsid);
    if (pes)
    {
        UPNP_SUBSCRIBER *   psubCur;
        UPNP_SUBSCRIBER *   psubPrev;

        for (psubCur = psubPrev = pes->psubList;
             psubCur;
             psubPrev = psubCur,
             psubCur = psubCur->psubNext)
        {
            if (!lstrcmpi(psubCur->szSid, szSid))
            {
                TraceTag(ttidEventServer, "HrRemoveSubscriber: Removing subscriber"
                         " %S from event source %S", psubCur->szSid, pes->szEsid);

                // Remove subscriber from the list

                if (psubCur == pes->psubList)
                {
                    // Removal of head item
                    pes->psubList = psubCur->psubNext;
                }
                else
                {
                    psubPrev->psubNext = psubCur->psubNext;
                }
                break;
            }
        }

        if (psubCur)
        {
            TraceTag(ttidEventServer, "HrRemoveSubscriber: Removing subscriber"
                     " %S", szSid);

            // Can no longer rely on this because once the subscriber is
            // removed from the list, its owning event source is off limits
            //
            psubCur->pes = NULL;

            QueueUserWorkItem(FreeSubscriberWorker, (LPVOID)psubCur,
                              WT_EXECUTELONGFUNCTION);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            TraceTag(ttidEventServer, "HrRemoveSubscriber: Did not find"
                     " subscriber %S in event source %S", szSid, szEsid);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        TraceTag(ttidEventServer, "HrRemoveSubscriber: Did not find event"
                 " source %S", szEsid);
    }

    LeaveCriticalSection(&g_csListEventSource);

    TraceError("HrRemoveSubscriber", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSubmitEvent
//
//  Purpose:    Submits an event for an event source
//
//  Arguments:
//      szEsid      [in]   Event source identifier
//      szEventBody [in]   Full XML body of event message
//
//  Returns:    S_OK if success, E_OUTOFMEMORY, or ERROR_FILE_NOT_FOUND if
//              event source was not found
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
HRESULT HrSubmitEvent(LPCWSTR szEsid, LPCWSTR szEventBody)
{
    HRESULT     hr = S_OK;

    TraceTag(ttidEventServer, "HrSubmitEvent: Submitting event for %S ",
             szEsid);

    Assert(szEsid);

    EnterCriticalSection(&g_csListEventSource);

    UPNP_EVENT_SOURCE * pes;

    if (!g_hInetSess)
    {
        hr = HrInitInternetSession();
    }

    if (SUCCEEDED(hr))
    {
        Assert(g_hInetSess);

        pes = PesFindEventSource(szEsid);
        if (pes)
        {
            UPNP_SUBSCRIBER * psub;

            for (psub = pes->psubList;
                 psub;
                 psub = psub->psubNext)
            {
                if (psub->iSeq > 0)
                {
                    UPNP_EVENT *    pevt;

                    pevt = new UPNP_EVENT;
                    if (!pevt)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    else
                    {
                        pevt->pevtNext = NULL;

                        pevt->szBody = WszDupWsz(szEventBody);
                        if (pevt->szBody)
                        {
                            AppendToEventQueue(psub, pevt);
                        }
                        else
                        {
                            delete pevt;
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            TraceTag(ttidEventServer, "HrSubmitEvent: Did not find event"
                     " source %S", szEsid);
        }
    }

    LeaveCriticalSection(&g_csListEventSource);

    TraceError("HrSubmitEvent", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendToEventQueue
//
//  Purpose:    Adds the given event structure to the end of the event queue
//              for that subscriber
//
//  Arguments:
//      psub [in]   Subscriber to add event to
//      pevt [in]   Event to add
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
VOID AppendToEventQueue(UPNP_SUBSCRIBER * psub, UPNP_EVENT * pevt)
{
    if (psub->pevtQueue)
    {
        psub->pevtQueueTail->pevtNext = pevt;
        psub->pevtQueueTail = pevt;

        TraceTag(ttidEventServer, "Adding %p to event queue for sub %S",
                 pevt, psub->szSid);
    }
    else
    {
        AssertSz(!psub->pevtQueueTail, "If head is NULL so should tail be too");

        psub->pevtQueue = pevt;
        psub->pevtQueueTail = pevt;

        TraceTag(ttidEventServer, "Adding %p to event queue for sub %S and"
                 " signalling event", pevt, psub->szSid);

        // Signal the event that says that a new item is ready on the queue
        //
        SetEvent(psub->hEventQ);
    }

    Assert(!pevt->pevtNext);
    AssertSz(psub->pevtQueueTail == pevt, "Didn't insert at the tail?");
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSubmitEventZero
//
//  Purpose:    Submits the initial notify event for a subscriber
//
//  Arguments:
//      szEsid      [in]     Event source identifier
//      szSid       [in]     Subscriber to submit the event to
//      szEventBody [in]     XML body of event message
//
//  Returns:    S_OK if success, E_OUTOFMEMORY
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:      The subscriber's event queue MUST be empty when this function
//              is called
//
HRESULT HrSubmitEventZero(LPCWSTR szEsid, LPCWSTR szSid, LPCWSTR szEventBody)
{
    HRESULT             hr = S_OK;
    UPNP_EVENT_SOURCE * pes;
    UPNP_SUBSCRIBER *   psub;

    EnterCriticalSection(&g_csListEventSource);

    if (!g_hInetSess)
    {
        hr = HrInitInternetSession();
    }

    if (SUCCEEDED(hr))
    {
        Assert(g_hInetSess);

        pes = PesFindEventSource(szEsid);
        if (pes)
        {
            UPNP_EVENT *    pevt;

            psub = PsubFindSubscriber(pes, szSid);
            if (psub)
            {
                pevt = new UPNP_EVENT;
                if (!pevt)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pevt->pevtNext = NULL;

                    pevt->szBody = WszDupWsz(szEventBody);
                    if (pevt->szBody)
                    {
                        AssertSz(!psub->pevtQueue, "Event queue is not empty!!!");
                        AppendToEventQueue(psub, pevt);
                    }
                    else
                    {
                        delete pevt;
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else
            {
                TraceTag(ttidEventServer, "Interesting.. Subscriber %S was removed"
                         " before event zero was submitted for a subscriber?? Oh well"
                         " no big deal.", szSid);
            }
        }
        else
        {
            TraceTag(ttidEventServer, "Interesting.. Event source %S was removed"
                     " before event zero was submitted for a subscriber?? Oh well"
                     " no big deal.", szEsid);
        }

        LeaveCriticalSection(&g_csListEventSource);
    }

    TraceError("HrSubmitEventZero", hr);
    return hr;
}

static const WCHAR c_szHeaderNt[]           = L"NT";
static const WCHAR c_szHeaderNts[]          = L"NTS";
static const WCHAR c_szHeaderSid[]          = L"SID";
static const WCHAR c_szHeaderSeq[]          = L"SEQ";
static const WCHAR c_szHeaderContentType[]  = L"Content-Type";

const WCHAR c_szNotifyMethod[]              = L"NOTIFY";

const WCHAR c_szHttpVersion[]               = L"HTTP/1.1";

static const DWORD c_cchHeaderNt            = celems(c_szHeaderNt);
static const DWORD c_cchHeaderNts           = celems(c_szHeaderNts);
static const DWORD c_cchHeaderSid           = celems(c_szHeaderSid);
static const DWORD c_cchHeaderSeq           = celems(c_szHeaderSeq);
static const DWORD c_cchHeaderContentType   = celems(c_szHeaderContentType);

static const WCHAR c_szNt[]                 = L"upnp:event";
static const WCHAR c_szNts[]                = L"upnp:propchange";

static const DWORD c_cchNt                  = celems(c_szNt);
static const DWORD c_cchNts                 = celems(c_szNts);

static const WCHAR c_szColon[]              = L":";
static const WCHAR c_szCrlf[]               = L"\r\n";

static const DWORD c_cchColon               = celems(c_szColon);
static const DWORD c_cchCrlf                = celems(c_szCrlf);

const WCHAR c_szTextXml[]                   = L"text/xml";

const DWORD c_cchTextXml                    = celems(c_szTextXml);

//+---------------------------------------------------------------------------
//
//  Function:   HrComposeUpnpNotifyHeaders
//
//  Purpose:    Composes the headers for a NOTIFY request to be sent to a
//              subscriber.
//
//  Arguments:
//      iSeq       [in]     Sequence number of event
//      szSid      [in]     SID of subscriber
//      pszHeaders [out]    Returns newly allocated headers in proper format
//
//  Returns:    S_OK if success or E_OUTOFMEMORY if no memory
//
//  Author:     danielwe   12 Oct 1999
//
//  Notes:      Caller must free pszHeaders with delete []
//
HRESULT HrComposeUpnpNotifyHeaders(DWORD iSeq, LPCTSTR szSid,
                                   LPWSTR *pszHeaders)
{
    DWORD   cchHeaders = 0;
    WCHAR   szSeq[32];
    LPWSTR  szHeaders;
    DWORD   iNumOfBytes = 0;
    HRESULT hr = S_OK;

    wsprintf(szSeq, L"%d", iSeq);

    cchHeaders += c_cchHeaderNt + c_cchColon + c_cchNt + c_cchCrlf;
    cchHeaders += c_cchHeaderNts + c_cchColon + c_cchNts + c_cchCrlf;
    cchHeaders += c_cchHeaderSid + c_cchColon + lstrlen(szSid) + c_cchCrlf;
    cchHeaders += c_cchHeaderSeq + c_cchColon + lstrlen(szSeq) + c_cchCrlf;
    cchHeaders += c_cchHeaderContentType + c_cchColon + c_cchTextXml + c_cchCrlf;

    szHeaders = new WCHAR[cchHeaders + 1];
    if (szHeaders)
    {
        iNumOfBytes += wsprintf(szHeaders + iNumOfBytes, L"%s%s%s%s",
                                c_szHeaderNt, c_szColon, c_szNt, c_szCrlf);
        iNumOfBytes += wsprintf(szHeaders + iNumOfBytes, L"%s%s%s%s",
                                c_szHeaderNts, c_szColon, c_szNts, c_szCrlf);
        iNumOfBytes += wsprintf(szHeaders + iNumOfBytes, L"%s%s%s%s",
                                c_szHeaderSid, c_szColon, szSid, c_szCrlf);
        iNumOfBytes += wsprintf(szHeaders + iNumOfBytes, L"%s%s%s%s",
                                c_szHeaderSeq, c_szColon, szSeq, c_szCrlf);
        iNumOfBytes += wsprintf(szHeaders + iNumOfBytes, L"%s%s%s%s",
                                c_szHeaderContentType, c_szColon,
                                c_szTextXml, c_szCrlf);

        *pszHeaders = szHeaders;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("HrComposeUpnpNotifyHeaders", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSubmitNotifyToSubscriber
//
//  Purpose:    Submits a NOTIFY request to the given URL
//
//  Arguments:
//      szHeaders [in]  Headers of request
//      szBody    [in]  Body of request (in XML)
//      szUrl     [in]  URL to send request to
//
//  Returns:    S_OK if successful, E_UNEXPECTED if the internet session
//              was not initialized
//
//  Author:     danielwe   7 Aug 2000
//
//  Notes:
//
HRESULT HrSubmitNotifyToSubscriber(LPCWSTR szHeaders, LPCWSTR szBody,
                                   LPCWSTR szUrl)
{
    HRESULT         hr = S_OK;
    URL_COMPONENTS  urlComp = {0};
    WCHAR           szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    WCHAR           szUrlPath[INTERNET_MAX_URL_LENGTH];

    urlComp.dwStructSize = sizeof(URL_COMPONENTS);

    urlComp.lpszHostName = (LPWSTR) &szHostName;
    urlComp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

    urlComp.lpszUrlPath = (LPWSTR) &szUrlPath;
    urlComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

    if (InternetCrackUrl(szUrl, 0, 0, &urlComp))
    {
        // Hack for not able to send to loopback in LocalService
        if(0 == lstrcmp(szHostName, L"127.0.0.1"))
        {
            lstrcpy(szHostName, L"localhost");
        }
        HINTERNET   hinC;

        if (g_hInetSess)
        {
            hinC = InternetConnect(g_hInetSess, szHostName, urlComp.nPort,
                                   NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
            if (hinC)
            {
                HINTERNET   hinR;

                TraceTag(ttidEventServer, "Connected to host %S:%d.",
                         szHostName, urlComp.nPort);
                hinR = HttpOpenRequest(hinC, c_szNotifyMethod, szUrlPath,
                                       c_szHttpVersion, NULL, NULL,
                                       INTERNET_FLAG_KEEP_CONNECTION, 0);
                if (hinR)
                {
                    LPSTR   szaBody;

                    TraceTag(ttidEventServer, "Sending the following request to "
                             "subscriber at %S:", szUrlPath);
                    TraceTag(ttidEventServer, "-------------------------------------------");
                    TraceTag(ttidEventServer, "\n%S\n%S", szHeaders, szBody);
                    TraceTag(ttidEventServer, "-------------------------------------------");

                    szaBody = Utf8FromWsz(szBody);
                    if (szaBody)
                    {
                        if (!HttpSendRequest(hinR, szHeaders, 0, (LPVOID)szaBody,
                                        CbOfSza(szaBody)))
                        {
                            TraceTag(ttidError, "Failed to send request [http://%S:%d%S]",
                                   szHostName, urlComp.nPort, szUrlPath);
                            hr = HrFromLastWin32Error();
                            TraceError("HrSubmitNotifyToSubscriber: "
                                       "HttpSendRequest", hr);
                        }
                        else
                        {
                            TraceTag(ttidEventServer, "Request sent successfully!");
                        }

                        delete [] szaBody;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrSubmitNotifyToSubscriber: SzFromWsz", hr);
                    }

                    InternetCloseHandle(hinR);
                }
                else
                {
                    hr = HrFromLastWin32Error();
                    TraceError("HrSubmitNotifyToSubscriber: HttpOpenRequest",
                               hr);
                }

                InternetCloseHandle(hinC);
            }
            else
            {
                hr = HrFromLastWin32Error();
                TraceError("HrSubmitNotifyToSubscriber: InternetConnect",
                           hr);
            }
        }
        else
        {
            hr = E_UNEXPECTED;
            TraceError("HrSubmitEventToSubscriber: No internet session!", hr);
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
        TraceError("HrSubmitNotifyToSubscriber: InternetCrackUrl", hr);
    }

    TraceError("HrSubmitNotifyToSubscriber", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   PesFindEventSource
//
//  Purpose:    Helper function to return the event source identified by
//              szEsid.
//
//  Arguments:
//      szEsid [in]     Event source identifier
//
//  Returns:    Pointer to event source that matches the identifier passed in
//              or NULL if not found
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
UPNP_EVENT_SOURCE *PesFindEventSource(LPCWSTR szEsid)
{
    UPNP_EVENT_SOURCE * pesCur;

    for (pesCur = g_pesList; pesCur; pesCur = pesCur->pesNext)
    {
        if (!lstrcmpi(pesCur->szEsid, szEsid))
        {
            break;
        }
    }

    return pesCur;
}

//+---------------------------------------------------------------------------
//
//  Function:   PsubFindSubscriber
//
//  Purpose:    Helper function to return the subscriber identified by the
//              SID passed in
//
//  Arguments:
//      pes   [in]  Event source to search in
//      szSid [in]  Subscription identifier
//
//  Returns:    Pointer to subscriber that matches the SID or NULL if not
//              found
//
//  Author:     danielwe   4 Aug 2000
//
//  Notes:
//
UPNP_SUBSCRIBER *PsubFindSubscriber(UPNP_EVENT_SOURCE *pes, LPCWSTR szSid)
{
    UPNP_SUBSCRIBER *   psubCur;

    for (psubCur = pes->psubList;
         psubCur;
         psubCur = psubCur->psubNext)
    {
        if (!lstrcmpi(psubCur->szSid, szSid))
        {
            break;
        }
    }

    return psubCur;
}

//
// Debug functions
//

VOID DbgDumpSubscriber(UPNP_SUBSCRIBER *psub)
{
    SYSTEMTIME   st;
    WCHAR        szLocalDate[255];
    WCHAR        szLocalTime[255];

    FileTimeToSystemTime(&psub->ftTimeout, &st);
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL,
                  szLocalDate, 255);
    GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL,
                 szLocalTime, 255);

    TraceTag(ttidEventServer, "Subscription at address 0x%08X", psub);
    TraceTag(ttidEventServer, "--------------------------------------");

    TraceTag(ttidEventServer, "Subscription timeout is %d seconds from "
            "now. It expires at %S %S", psub->csecTimeout,
            szLocalDate, szLocalTime);

    TraceTag(ttidEventServer, "Sequence #  : %d", psub->iSeq);
    TraceTag(ttidEventServer, "Callback Url: %S", psub->rgszUrl[0]);
    TraceTag(ttidEventServer, "SID         : %S", psub->szSid);
    TraceTag(ttidEventServer, "--------------------------------------");
}

VOID DbgDumpEventSource(UPNP_EVENT_SOURCE *pes)
{
    DWORD               iVar;
    UPNP_SUBSCRIBER *   psubCur;

    TraceTag(ttidEventServer, "Event source 0x%08X - %S", pes, pes->szEsid);
    TraceTag(ttidEventServer, "-------------------------------------------------");

    if (pes->psubList)
    {
        for (psubCur = pes->psubList; psubCur; psubCur = psubCur->psubNext)
        {
            DbgDumpSubscriber(psubCur);
        }
    }
    else
    {
        TraceTag(ttidEventServer, "NO SUBSCRIBERS");
    }

    TraceTag(ttidEventServer, "-------------------------------------------------");
}

VOID DbgDumpListEventSource()
{
    UPNP_EVENT_SOURCE * pesCur;

    if (g_pesList)
    {
        EnterCriticalSection(&g_csListEventSource);

        for (pesCur = g_pesList; pesCur; pesCur = pesCur->pesNext)
        {
            DbgDumpEventSource(pesCur);
        }

        LeaveCriticalSection(&g_csListEventSource);
    }
    else
    {
        TraceTag(ttidEventServer, "Event source list is EMPTY!");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\evtapi\evtdiag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       E V T D I A G . C P P
//
//  Contents:   Eventing manager diagnostic functions
//
//  Notes:
//
//  Author:     danielwe   2000/10/2
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <upnpatl.h>
#include "hostp.h"
#include "evtapi.h"
#include "evtdiag.h"
#include "ncstring.h"

extern CRITICAL_SECTION     g_csListEventSource;
extern UPNP_EVENT_SOURCE *  g_pesList;

STDMETHODIMP CUPnPEventingManagerDiag::GetEventSourceInfo(
                DWORD *pces, UDH_EVTSRC_INFO **prgesInfo)
{
    HRESULT             hr = S_OK;
    UPNP_EVENT_SOURCE * pesCur;
    UDH_EVTSRC_INFO *   rguei = NULL;
    DWORD               ces = 0;
    DWORD               ies;

    Assert(pces);
    Assert(prgesInfo);

    *pces = 0;
    *prgesInfo = NULL;

    EnterCriticalSection(&g_csListEventSource);

    if (g_pesList)
    {
        for (pesCur = g_pesList; pesCur; pesCur = pesCur->pesNext)
        {
            ces++;
        }

        rguei = (UDH_EVTSRC_INFO *)CoTaskMemAlloc(sizeof(UDH_EVTSRC_INFO) * ces);
        if (rguei)
        {
            ZeroMemory(rguei, sizeof(UDH_EVTSRC_INFO) * ces);

            for (ies = 0, pesCur = g_pesList;
                 pesCur;
                 pesCur = pesCur->pesNext, ies++)
            {
                UPNP_SUBSCRIBER *   psubCur;

                for (psubCur = pesCur->psubList; psubCur; psubCur = psubCur->psubNext)
                {
                    rguei[ies].cSubs++;
                }

                rguei[ies].szEsid = COMSzFromWsz(pesCur->szEsid);

                rguei[ies].rgSubs = (UDH_SUBSCRIBER_INFO *)CoTaskMemAlloc(sizeof(UDH_SUBSCRIBER_INFO) * rguei[ies].cSubs);
                if (rguei[ies].rgSubs)
                {
                    DWORD   isub;

                    ZeroMemory(rguei[ies].rgSubs, sizeof(UDH_SUBSCRIBER_INFO) * rguei[ies].cSubs);
                    for (isub = 0, psubCur = pesCur->psubList;
                         psubCur;
                         isub++, psubCur = psubCur->psubNext)
                    {
                        rguei[ies].rgSubs[isub].csecTimeout = psubCur->csecTimeout;
                        rguei[ies].rgSubs[isub].ftTimeout = psubCur->ftTimeout;
                        rguei[ies].rgSubs[isub].iSeq = psubCur->iSeq;
                        rguei[ies].rgSubs[isub].szDestUrl = COMSzFromWsz(psubCur->rgszUrl[0]);
                        rguei[ies].rgSubs[isub].szSid = COMSzFromWsz(psubCur->szSid);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        *prgesInfo = rguei;
        *pces = ces;
    }

    LeaveCriticalSection(&g_csListEventSource);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\automationproxy.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       A U T O M A T I O N P R O X Y . H
//
//  Contents:   Header file for the Automation Proxy class.
//
//  Notes:
//
//  Author:     spather   2000/09/25
//
//----------------------------------------------------------------------------

#ifndef __AUTOMATIONPROXY_H
#define __AUTOMATIONPROXY_H

#pragma once

#include "uhres.h"
#include "hostp.h"

typedef struct tagUPNP_STATE_VARIABLE
{
    BSTR   bstrName;
    BSTR   bstrDataType;
    BOOL   fNonEvented;
    DISPID dispid;
} UPNP_STATE_VARIABLE;


typedef struct tagUPNP_ARGUMENT
{
    BSTR                   bstrName;
    UPNP_STATE_VARIABLE    * pusvRelated;
} UPNP_ARGUMENT;


typedef struct tagUPNP_ACTION
{
    BSTR           bstrName;
    DISPID         dispid;
    DWORD          cInArgs;
    UPNP_ARGUMENT  * rgInArgs;
    DWORD          cOutArgs;
    UPNP_ARGUMENT  * rgOutArgs;
    UPNP_ARGUMENT  * puaRetVal;
} UPNP_ACTION;


class ATL_NO_VTABLE CUPnPAutomationProxy :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CUPnPAutomationProxy, &CLSID_UPnPAutomationProxy>,
    public IUPnPAutomationProxy,
    public IUPnPServiceDescriptionInfo
{
public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_REGISTRY_RESOURCEID(IDR_AUTOMATION_PROXY)

    DECLARE_NOT_AGGREGATABLE(CUPnPAutomationProxy)

    BEGIN_COM_MAP(CUPnPAutomationProxy)
        COM_INTERFACE_ENTRY(IUPnPAutomationProxy)
        COM_INTERFACE_ENTRY(IUPnPServiceDescriptionInfo)
    END_COM_MAP()

    CUPnPAutomationProxy();
    ~CUPnPAutomationProxy();

    // ATL methods
    HRESULT FinalConstruct();
    HRESULT FinalRelease();


// IUPnPAutomationProxy
public:
    STDMETHOD(Initialize)(
        /*[in]*/   IUnknown    * punkSvcObject,
        /*[in]*/   LPWSTR      pszSvcDescription,
        /*[in]*/   LPWSTR      pszSvcType,
        /*[in]*/   BOOL        bRunning);

    STDMETHOD(GetDispIdsOfEventedVariables)(
       /*[out]*/   DWORD   * pcEventedVars,
       /*[out]*/   DISPID  ** prgdispidEventedVars);

    STDMETHOD(QueryStateVariablesByDispIds)(
        /*[in]*/   DWORD       cDispIds,
        /*[in]*/   DISPID      * rgDispIds,
        /*[out]*/  DWORD       * pcVariables,
        /*[out]*/  LPWSTR      ** prgszVariableNames,
        /*[out]*/  VARIANT     ** prgvarVariableValues,
        /*[out]*/  LPWSTR      ** prgszVariableDataTypes);

    STDMETHOD(ExecuteRequest)(
        /*[in]*/   UPNP_CONTROL_REQUEST    * pucreq,
        /*[out]*/  UPNP_CONTROL_RESPONSE   * pucresp);

    STDMETHOD(GetServiceType)(
        /*[out]*/  LPWSTR * pszSvcType);

// IUPnPServiceDescriptionInfo
public:

    STDMETHOD(GetVariableType)(
        /*[in]*/   LPWSTR      pszVarName,
        /*[out]*/  BSTR        * pbstrType);


    STDMETHOD(GetInputArgumentNamesAndTypes)(
        /*[in]*/   LPWSTR      pszActionName,
        /*[out]*/  DWORD       * pcInArguments,
        /*[out]*/  BSTR        ** prgbstrNames,
        /*[out]*/  BSTR        ** prgbstrTypes);


    STDMETHOD(GetOutputArgumentNamesAndTypes)(
        /*[in]*/   LPWSTR      pszActionName,
        /*[out]*/  DWORD       * pcOutArguments,
        /*[out]*/  BSTR        ** prgbstrNames,
        /*[out]*/  BSTR        ** prgbstrTypes);

// Helper functions
private:
    VOID FreeVariable(UPNP_STATE_VARIABLE * pVariable);
    VOID FreeAction(UPNP_ACTION * pAction);
    VOID FreeArgument(UPNP_ARGUMENT * pArg);
    VOID FreeVariableTable();
    VOID FreeActionTable();
    VOID FreeControlResponse(UPNP_CONTROL_RESPONSE * pucresp);
    HRESULT HrProcessServiceDescription(LPWSTR pszSvcDescription);
    HRESULT HrValidateServiceDescription(IXMLDOMElement * pxdeRoot);
    HRESULT HrBuildTablesFromServiceDescription(IXMLDOMElement * pxdeRoot);
    HRESULT HrBuildVariableTable(IXMLDOMNodeList * pxdnlStateVars);
    HRESULT HrBuildActionTable(IXMLDOMNodeList * pxdnlActions);
    HRESULT HrBuildArgumentLists(IXMLDOMNode * pxdnAction, UPNP_ACTION * pAction);
    HRESULT HrCountInAndOutArgs(IXMLDOMNodeList * pxdnlArgs,
                                DWORD * pcInArgs,
                                DWORD * pcOutArgs);
    HRESULT HrInitializeArguments(IXMLDOMNodeList * pxdnlArgs, UPNP_ACTION * pAction);
    UPNP_STATE_VARIABLE *LookupVariableByDispID(DISPID dispid);
    UPNP_STATE_VARIABLE *LookupVariableByName(LPCWSTR pcszName);
    UPNP_ACTION *LookupActionByName(LPCWSTR pcszName);
    HRESULT HrBuildFaultResponse(UPNP_CONTROL_RESPONSE_DATA * pucrd,
                                 LPCWSTR                    pcszFaultCode,
                                 LPCWSTR                    pcszFaultString,
                                 LPCWSTR                    pcszUPnPErrorCode,
                                 LPCWSTR                    pcszUPnPErrorString);
    HRESULT HrVariantInitForXMLType(VARIANT * pvar,
                                    LPCWSTR pcszDataTypeString);

    HRESULT HrInvokeAction(UPNP_CONTROL_REQUEST    * pucreq,
                           UPNP_CONTROL_RESPONSE   * pucresp);

    HRESULT HrQueryStateVariable(UPNP_CONTROL_REQUEST    * pucreq,
                                 UPNP_CONTROL_RESPONSE   * pucresp);

// State
private:
    BOOL                   m_fInitialized;
    IDispatch              * m_pdispService;
    DWORD                  m_cVariables;
    DWORD                  m_cEventedVariables;
    UPNP_STATE_VARIABLE    * m_rgVariables;
    DWORD                  m_cActions;
    UPNP_ACTION            * m_rgActions;
    LPWSTR                 m_wszServiceType;
};


#endif //!__AUTOMATIONPROXY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__B6C2EC65_A7EF_4A9E_A95F_C94091F5F146__INCLUDED_)
#define AFX_DLLDATAX_H__B6C2EC65_A7EF_4A9E_A95F_C94091F5F146__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B6C2EC65_A7EF_4A9E_A95F_C94091F5F146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\evtapi\evtobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V T O B J . C P P
//
//  Contents:   Implements the Eventing Manager object for the UPnP Device
//              Host
//
//  Notes:
//
//  Author:     danielwe   7 Aug 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <msxml2.h>
#include <upnpatl.h>
#include "hostp.h"
#include "upnphost.h"
#include "evtobj.h"
#include "evtapi.h"
#include "ncbase.h"
#include "ncxml.h"
#include "ComUtility.h"
#include "uhcommon.h"

//
// IUPnPEventingManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::Initialize
//
//  Purpose:    Initializes the Eventing Manager object for a hosted service
//
//  Arguments:
//      szUdn   [in]    UDN of the device
//      szSid   [in]    Service identifier of the service within the device
//      puap    [in]    Interface pointer to the service's automation proxy
//      punkSvc [in]    Interface pointer to the service's object
//
//  Returns:    S_OK if success, E_OUTOFMEMORY, or any other OLE interface
//              error code
//
//  Author:     danielwe   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CUPnPEventingManager::Initialize(LPCWSTR szUdn,
                                              LPCWSTR szSid,
                                              IUPnPAutomationProxy *puap,
                                              IUnknown *punkSvc,
                                              BOOL bRunning)
{
    HRESULT     hr = S_OK;
    DWORD       cch;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    Assert(szUdn);
    Assert(szSid);
    Assert(punkSvc);
    Assert(puap);

    Assert(!m_szEsid);
    Assert(!m_puap);
    Assert(!m_pues);

    AddRefObj(m_puap = puap);

    cch = lstrlen(szUdn) + lstrlen(szSid) + lstrlen(L"+") + 1;

    m_szEsid = new WCHAR[cch];
    if (!m_szEsid)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Make the event source identifier by combining the UDN and SID

        lstrcpy(m_szEsid, szUdn);
        lstrcat(m_szEsid, L"+");
        lstrcat(m_szEsid, szSid);

        hr = punkSvc->QueryInterface(IID_IUPnPEventSource, (LPVOID *)&m_pues);
        if (SUCCEEDED(hr))
        {
            if(bRunning)
            {
                hr = HrCopyProxyIdentity(m_pues, punkSvc);
            }
            if(SUCCEEDED(hr))
            {
                // Get a reference to ourselves to hand out to the hosted service
                //
                hr = m_pues->Advise(this);
            }
            if (FAILED(hr))
            {
                m_pues->Release();
                m_pues = NULL;
            }
        }
        else
        {
            TraceError("CUPnPEventingManager::Initialize - Object passed in"
                       " does not support IUPnPEventSource!", hr);
        }
    }

    if (FAILED(hr))
    {
        delete [] m_szEsid;
        m_szEsid = NULL;
    }

Cleanup:

    TraceError("CUPnPEventingManager::Initialize", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::AddSubscriber
//
//  Purpose:
//
//  Arguments:
//      cszUrl          [in]      Count of callback URLs
//      rgszCallbackUrl [in]      List of callback URLs to which NOTIFY
//                                requests will be sent
//      dwIpAddr        [in]      Local IP address that the subscribe came in on
//      pcsecTimeout    [in out]  On entry, this is the requested timeout from
//                                the control point.
//                                On exit, this is the timeout the device chose
//      pszSid          [out]     Returns the SID (subscription identifier) for
//                                the new subscription
//
//  Returns:
//
//  Author:     danielwe   2000/12/28
//
//  Notes:
//
STDMETHODIMP CUPnPEventingManager::AddSubscriber(DWORD cszUrl,
                                                 LPCWSTR *rgszCallbackUrl,
                                                 DWORD dwIpAddr,
                                                 DWORD *pcsecTimeout,
                                                 LPWSTR *pszSid)
{
    HRESULT     hr = S_OK;
    LPWSTR      szBody = NULL;
    DWORD       cVars;
    LPWSTR *    rgszNames;
    LPWSTR *    rgszTypes;
    VARIANT *   rgvarValues;
    DWORD       cDispids;
    DISPID *    rgDispids = NULL;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    if (FAILED(hr))
    {
        return hr;
    }

    AssertSz(m_szEsid, "What? Did we not get initialized or something?");
    AssertSz(m_puap, "Automation proxy not initialized?");
    Assert(rgszCallbackUrl);
    Assert(cszUrl);
    Assert(pszSid);

   
    *pszSid = NULL;

    hr = m_puap->GetDispIdsOfEventedVariables(&cDispids, &rgDispids);

    if (SUCCEEDED(hr))
    {
        hr = m_puap->QueryStateVariablesByDispIds(cDispids, rgDispids, &cVars,
                                                  &rgszNames, &rgvarValues,
                                                  &rgszTypes);
        if (SUCCEEDED(hr))
        {
            hr = HrComposeEventBody(m_puap, cVars, rgszNames, rgszTypes,
                                    rgvarValues, &szBody);
            if (SUCCEEDED(hr))
            {
                LPWSTR  szSid;

                hr = HrAddSubscriber(m_szEsid, dwIpAddr, cszUrl,
                                     rgszCallbackUrl, szBody,
                                     pcsecTimeout, &szSid);
                if (SUCCEEDED(hr))
                {
                    *pszSid = (LPWSTR)CoTaskMemAlloc(CbOfSzAndTerm(szSid));
                    if (*pszSid)
                    {
                        lstrcpy(*pszSid, szSid);
                    }
                    else
                    {
                        TraceError("CUPnPEventingManager::AddSubscriber - "
                                   "CoTaskMemAlloc()", hr);
                        hr = E_OUTOFMEMORY;
                    }

                    delete [] szSid;
                }

                delete [] szBody;
            }

            DWORD   ivar;

            for (ivar = 0; ivar < cVars; ivar++)
            {
                CoTaskMemFree(rgszTypes[ivar]);
                CoTaskMemFree(rgszNames[ivar]);
                VariantClear(&rgvarValues[ivar]);
            }

            CoTaskMemFree(rgszTypes);
            CoTaskMemFree(rgszNames);
            CoTaskMemFree(rgvarValues);
        }

        CoTaskMemFree(rgDispids);
    }

    TraceError("CUPnPEventingManager::AddSubscriber", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::RenewSubscriber
//
//  Purpose:    Renews an existing subscriber to a hosted service
//
//  Arguments:
//      pcsecTimeout  [in out]  On entry, this is the requested timeout from
//                              the control point.
//                              On exit, this is the timeout the device chose
//      szSid        [in]       The SID (subscription identifier) of the
//                              subscriber to renew
//
//  Returns:    S_OK if success, E_OUTOFMEMORY, or any other OLE interface
//              error code
//
//  Author:     danielwe   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CUPnPEventingManager::RenewSubscriber(DWORD *pcsecTimeout,
                                                   LPWSTR szSid)
{
    HRESULT     hr = S_OK;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (FAILED(hr))
    {
        return hr;
    }

    AssertSz(m_szEsid, "What? Did we not get initialized or something?");
    Assert(szSid);

    hr = HrRenewSubscriber(m_szEsid, pcsecTimeout, szSid);

    TraceError("CUPnPEventingManager::RenewSubscriber", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::RemoveSubscriber
//
//  Purpose:    Removes a subscriber from the list of subscribers to a hosted
//              service
//
//  Arguments:
//      szSid        [in]       The SID (subscription identifier) of the
//                              subscriber to renew
//
//  Returns:    S_OK if success, E_OUTOFMEMORY, or any other OLE interface
//              error code
//
//  Author:     danielwe   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CUPnPEventingManager::RemoveSubscriber(LPWSTR szSid)
{
    HRESULT     hr = S_OK;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (FAILED(hr))
    {
        return hr;
    }

    AssertSz(m_szEsid, "What? Did we not get initialized or something?");
    Assert(szSid);

    hr = HrRemoveSubscriber(m_szEsid, szSid);

    TraceError("CUPnPEventingManager::RemoveSubscriber", hr);
    return hr;
}

//
// IUPnPEventSink
//


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::OnStateChanged
//
//  Purpose:    Notifies the eventing manager that the state of a service on
//              a hosted device has changed
//
//  Arguments:
//      cChanges        [in]    Number of state variables that have changed
//      rgdispidChanges [in]    Array of DISPIDs for those state variables
//
//  Returns:    S_OK if success, E_OUTOFMEMORY, or any other OLE interface
//              error code otherwise.
//
//  Author:     danielwe   2000/09/21
//
//  Notes:
//
STDMETHODIMP CUPnPEventingManager::OnStateChanged(DWORD cChanges,
                                                  DISPID rgdispidChanges[])
{
    HRESULT     hr = S_OK;
    LPWSTR      szBody = NULL;
    DWORD       cVars;
    LPWSTR *    rgszNames;
    LPWSTR *    rgszTypes;
    VARIANT *   rgvarValues;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    AssertSz(m_szEsid, "What? Did we not get initialized or something?");
    AssertSz(m_puap, "Automation proxy not initialized?");


    if (!m_pues)
    {
        hr = E_UNEXPECTED;
    }
    else if (!cChanges || !rgdispidChanges)
    {
        hr = E_INVALIDARG;

        TraceError("OnStateChanged() called, but nothing to do.", hr);
    }
    else
    {
        hr = m_puap->QueryStateVariablesByDispIds(cChanges, rgdispidChanges,
                                                  &cVars, &rgszNames,
                                                  &rgvarValues, &rgszTypes);
        if (SUCCEEDED(hr))
        {
            hr = HrComposeEventBody(m_puap, cVars, rgszNames, rgszTypes,
                                    rgvarValues, &szBody);
            if (SUCCEEDED(hr))
            {
                hr = HrSubmitEvent(m_szEsid, szBody);

                delete [] szBody;
            }

            DWORD   ivar;

            for (ivar = 0; ivar < cVars; ivar++)
            {
                CoTaskMemFree(rgszTypes[ivar]);
                CoTaskMemFree(rgszNames[ivar]);
                VariantClear(&rgvarValues[ivar]);
            }

            CoTaskMemFree(rgvarValues);
            CoTaskMemFree(rgszTypes);
            CoTaskMemFree(rgszNames);
        }
    }

Cleanup:

    TraceError("CUPnPEventingManager::OnStateChanged", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::OnStateChangedSafe
//
//  Purpose:    Same as OnStateChanged, except this is for VB users that need
//              to pass the array of DISPIDs in a SafeArray.
//
//  Arguments:
//      psa     [in]    SafeArray of DISPIDs that have changed
//
//  Returns:    Same as OnStateChanged
//
//  Author:     danielwe   2000/09/21
//
//  Notes:
//
STDMETHODIMP CUPnPEventingManager::OnStateChangedSafe(VARIANT varsadispidChanges)
{
    HRESULT         hr = S_OK;
    DISPID HUGEP *  rgdispids;
    SAFEARRAY *     psa;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    psa = V_ARRAY(&varsadispidChanges);

    if (psa)
    {
        // Get a pointer to the elements of the array.
        hr = SafeArrayAccessData(psa, (void HUGEP**)&rgdispids);
        if (SUCCEEDED(hr))
        {
            hr = OnStateChanged(psa->rgsabound[0].cElements, rgdispids);
            SafeArrayUnaccessData(psa);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

Cleanup:

    TraceError("CUPnPEventingManager::OnStateChangedSafe", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::Shutdown
//
//  Purpose:    Tells the eventing manager object to go away
//
//  Arguments:
//      (none)
//
//  Returns:    E_UNEXPECTED if the object was never initialized.
//
//  Author:     danielwe   2000/09/21
//
//  Notes:
//
STDMETHODIMP CUPnPEventingManager::Shutdown()
{
    HRESULT     hr = S_OK;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (!m_pues)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = m_pues->Unadvise(this);

        ReleaseObj(m_pues);

        m_pues = NULL;
    }

Cleanup:
    TraceError("CUPnPEventingManager::Shutdown", hr);
    return hr;
}

//
// ATL Methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPEventingManager::FinalRelease
//
//  Purpose:    Called when the Eventing Manager object is released for the
//              last time
//
//  Arguments:
//      (none)
//
//  Returns:    Not much.
//
//  Author:     danielwe   8 Aug 2000
//
//  Notes:
//
HRESULT CUPnPEventingManager::FinalRelease()
{
    HRESULT     hr = S_OK;

    delete [] m_szEsid;

    ReleaseObj(m_puap);

    TraceError("CUPnPEventingManager::FinalRelease", hr);
    return hr;
}

//
// Private functions
//

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateElement
//
//  Purpose:    Creates an element in the specified DOM Document
//
//  Arguments:
//      pxdd         [in]   DOM Document to create element in
//      szName       [in]   Element name
//      ppxdnElement [out]  Returns the newly created element
//
//  Returns:    S_OK if successful, E_OUTOFMEMORY, or OLE error code
//
//  Author:     danielwe   16 Aug 2000
//
//  Notes:      The element is NOT automatically inserted into the document
//
HRESULT HrCreateElement(IXMLDOMDocument *pxdd, LPCWSTR szName,
                        IXMLDOMNode **ppxdnElement)
{
    HRESULT hr = S_OK;
    BSTR    bstrElementName;

    Assert(pxdd);
    Assert(ppxdnElement);

    *ppxdnElement = NULL;

    bstrElementName = SysAllocString(szName);
    if (bstrElementName)
    {
        IXMLDOMNode *   pxdn;
        BSTR            bstrNamespaceURI;

        bstrNamespaceURI = SysAllocString(L"urn:schemas-upnp-org:event-1-0");
        if (bstrNamespaceURI)
        {
            VARIANT varNodeType;

            VariantInit(&varNodeType);
            varNodeType.vt = VT_I4;
            V_I4(&varNodeType) = (int) NODE_ELEMENT;

            hr = pxdd->createNode(varNodeType, bstrElementName,
                                  bstrNamespaceURI, &pxdn);
            if (SUCCEEDED(hr))
            {
                *ppxdnElement = pxdn;
            }
            else
            {
                ReleaseObj(pxdn);
            }

            SysFreeString(bstrNamespaceURI);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("HrAddRootElement", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrComposeEventBody
//
//  Purpose:    Composes the event notification body given a list of names,
//              values, and data types
//
//  Arguments:
//      cVars       [in]    Number of state variables to work with
//      rgszNames   [in]    List of variable names
//      rgszTypes   [in]    List of variable types
//      rgvarValues [in]    List of variable values
//      pszBody     [out]   Returns newly created XML body as a string
//
//  Returns:    S_OK if successful, E_OUTOFMEMORY, or OLE error code
//
//  Author:     danielwe   16 Aug 2000
//
//  Notes:      pszBody must be freed by the caller with delete []
//
HRESULT HrComposeEventBody(IUPnPAutomationProxy* puap, DWORD cVars, LPWSTR *rgszNames,
                           LPWSTR *rgszTypes, VARIANT *rgvarValues, LPWSTR *pszBody)
{
    HRESULT             hr = S_OK;
    IXMLDOMDocument *   pxdd;

    Assert(pszBody);
    Assert(cVars);

    *pszBody = NULL;

    // Create a new XML DOM Document
    //

    hr = CoCreateInstance(CLSID_DOMDocument30, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLDOMDocument, (LPVOID *) &pxdd);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *   pxdnRoot;

        hr = HrAppendProcessingInstruction(pxdd, L"xml", L"version=\"1.0\"");

        if (SUCCEEDED(hr))
        {
            hr = HrCreateElement(pxdd, L"e:propertyset", &pxdnRoot);
            if (SUCCEEDED(hr))
            {
                IXMLDOMElement* pxde;
                hr = pxdnRoot->QueryInterface(IID_IXMLDOMElement, (void**)&pxde);
                if (SUCCEEDED(hr))
                {
                    Assert(puap);
                    LPWSTR szServiceType = NULL;
                    hr = puap->GetServiceType(&szServiceType);
                    if (SUCCEEDED(hr))
                    {
                        HrSetTextAttribute(pxde, L"xmlns:s", szServiceType);
                        CoTaskMemFree(szServiceType);
                    }
                    pxde->Release();
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            DWORD   iVar;

            // Loop thru each passed in variable and create a typed element
            // for each, adding to a new container element for "property" as
            // described in the UPnP architecture 1.0.

            for (iVar = 0;
                 iVar < cVars && SUCCEEDED(hr);
                 iVar++)
            {
                IXMLDOMNode *    pxdnProp;

                hr = HrCreateElement(pxdd, L"e:property", &pxdnProp);
                if (SUCCEEDED(hr))
                {
                    IXMLDOMElement *    pxdeVar;

                    LPWSTR szPrefixedName = new WCHAR[lstrlenW(rgszNames[iVar]) + 3];
                    if (szPrefixedName)
                    {
                        lstrcpyW(szPrefixedName, L"s:");
                        lstrcatW(szPrefixedName, rgszNames[iVar]);

                        hr = HrCreateElementWithType(pxdd, szPrefixedName,
                                                     (LPCWSTR)rgszTypes[iVar],
                                                     rgvarValues[iVar], &pxdeVar);
                        if (SUCCEEDED(hr))
                        {
                            // Add both the container "<e:property>" and the
                            // variable "<e:[varName]>" to the root
                            //

                            hr = pxdnRoot->appendChild(pxdnProp, NULL);
                            hr = pxdnProp->appendChild(pxdeVar, NULL);

                            ReleaseObj(pxdeVar);
                        }

                        ReleaseObj(pxdnProp);
                        delete [] szPrefixedName;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Add the root element to the DOM itself
                hr = pxdd->appendChild(pxdnRoot, NULL);
            }

            // If all went well, ask the document to give us the XML as a string
            //

            if (SUCCEEDED(hr))
            {
                BSTR    bstrBody;

                hr = pxdd->get_xml(&bstrBody);
                if (SUCCEEDED(hr))
                {
                    DWORD   cch = SysStringLen(bstrBody) + 1;
                    LPWSTR  szBody;

                    szBody = new WCHAR[cch];
                    if (szBody)
                    {
                        lstrcpy(szBody, bstrBody);

                        TraceTag(ttidDefault, "Body is %S", szBody);

                        *pszBody = szBody;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    SysFreeString(bstrBody);
                }
            }

            ReleaseObj(pxdnRoot);
        }

        ReleaseObj(pxdd);
    }

    TraceError("HrComposeEventBody", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\auth.h ===
//  Called once, determines which settings we're using

class CReg;
void AuthInitialize(CReg *, BOOL *pfBasicAuth, BOOL *pfNTLMAuth);





// state information for NTLM auth scheme, 1 per request.
// NOTE:  In the middle of an httpd request using NTLM, this structure
// must be maintained.  This is evident in HttpConnectionThread in httpmain.cpp

typedef enum
{
	NTLM_NO_INIT_LIB = 0,			// Needs the libraries, fcn setup.  Per session
	NTLM_NO_INIT_CONTEXT,		// needs context structures to be initialized.  Per request
	NTLM_PROCESSING,			// in the middle of request, keep structures around.
	NTLM_DONE					// Set after 2nd NTLM pass, it's either failed.  Remove context, not library.
}  NTLM_CONVERSATION;


typedef struct
{
    NTLM_CONVERSATION m_Conversation;				// Are we in the middle of a request?

    BOOL m_fHaveCredHandle;					// Is m_hcred initialized?
	CredHandle m_hcred;						

    BOOL m_fHaveCtxtHandle;					// Is m_hctxt initialized?
    struct _SecHandle  m_hctxt;				
} AUTH_NTLM, *PAUTH_NTLM;		

//  Functions used each session
BOOL HandleBasicAuth(PSTR pszData, PSTR* ppszUser, PSTR *ppszPassword, 
					 AUTHLEVEL* pAuth, PAUTH_NTLM pNTLMState, WCHAR *wszVRootUserList);
BOOL NTLMInitLib(PAUTH_NTLM pNTLMState);
BOOL BasicToNTLM(PAUTH_NTLM pNTLMState, WCHAR * wszPassword, WCHAR * wszRemoteUser, 
				 AUTHLEVEL *pAuth, WCHAR *wszVRootUserList);
void FreeNTLMHandles(PAUTH_NTLM pNTLMState);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\buffio.h ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: BUFFIO.H
Author: Arul Menezes
Abstract: Buffer handling class & socket IO helpers
--*/


// returned from the socket IO functions
typedef enum
{
    INPUT_OK = 0,
    INPUT_TIMEOUT = 1,
    INPUT_ERROR = 2,
    INPUT_NOCHANGE = 3
    //INPUT_EOF = 2,
}
HRINPUT;

class CHttpRequest;     // forward declaration


int MySelect(SOCKET sock, DWORD dwMillisecs);

//
// There is one such buffer for all the headers of a request and another for the POST-body if any
//
class CBuffer
{
private:
    PSTR    m_pszBuf;
    int     m_iSize;
    int     m_iNextOut;
    int     m_iNextIn;
    int     m_iNextInFollow;   // next place to read, needed by raw read filters.
    CHAR    m_chSaved;  // Used by the parser

    BOOL AllocMem(DWORD dwLen);
    BOOL NextToken(PSTR* ppszTok, int* piLen, BOOL fWS, BOOL fColon = FALSE);

public:
    CBuffer() {
        memset(this, 0, sizeof(*this));
    }

    ~CBuffer() {
        MyFree(m_pszBuf);
    }

    //  Used to reset a buffer through the course of 1 session, uses
    //  same allocated mem block. (don't change m_iSize)
    void Reset()
    {
        m_iNextInFollow = m_iNextOut = m_iNextIn = m_chSaved = 0;
    }

    // accessors
    DWORD Count() { return m_iNextIn - m_iNextOut; }
    BOOL  HasPostData()    { return (m_iNextIn > m_iNextOut);  }
    PBYTE Data()  { return (PBYTE)(m_pszBuf + m_iNextOut); }
    DWORD UnaccessedCount() { return m_iNextIn - m_iNextInFollow; }  // this is data that hasn't been modified yet, for filters
    DWORD AvailableBufferSize()  { return m_iSize - m_iNextInFollow; }  // size of buffer, used by filters
    PBYTE FilterRawData()  { return (PBYTE)(m_pszBuf + m_iNextInFollow); }
    PSTR Headers() { return m_pszBuf; }  // Http headers are at beginning of buf
    DWORD GetINextOut()  { return m_iNextOut; }
    BOOL TrimWhiteSpace();


    // input functions
    HRINPUT RecvToBuf(SOCKET sock, DWORD dwLength, DWORD dwTimeout,BOOL fFromFilter=FALSE);
    HRINPUT RecvHeaders(SOCKET sock)
    {
        DEBUGCHK(!m_iNextOut && !m_iNextIn);
        return RecvToBuf(sock, (DWORD)-1, KEEPALIVETIMEOUT);
    };
    HRINPUT RecvBody(SOCKET sock, DWORD dwLength, BOOL fFromFilter = FALSE)
    {
        DEBUGCHK(m_pszBuf && m_iSize);
        DEBUGCHK(m_iNextOut <= m_iNextIn);
        DEBUGCHK(m_iNextInFollow <= m_iNextIn);
        return RecvToBuf(sock, dwLength, RECVTIMEOUT,fFromFilter);
    };
    BOOL NextTokenWS(PSTR* ppszTok, int * piLen)  { return NextToken(ppszTok, piLen, TRUE); }
    BOOL NextTokenEOL(PSTR* ppszTok, int * piLen) { return NextToken(ppszTok, piLen, FALSE); }
    BOOL NextTokenColon(PSTR* ppszTok, int * piLen) { return NextToken(ppszTok, piLen, TRUE, TRUE); }
    BOOL NextLine();
    BOOL AddHeader(PSTR pszName, PSTR pszValue, BOOL fAddColon=FALSE);


    // output functions
    BOOL AppendData(PSTR pszData, int iLen);
    BOOL SendBuffer(SOCKET sock, CHttpRequest *pRequest);
    BOOL FilterDataUpdate(PVOID pvData, DWORD cbData, BOOL fModifiedPointer);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\authhlp.h ===
/*--
Copyright (c) 1999  Microsoft Corporation
Module Name: AUTHHLP
Abstract: NTLM Authentication for telnetd.
--*/

/****************************************************************************
 USAGE

 Call AuthHelpValidateUser(A/W), depending on whether the user name and 
 password are in ANSI or UNICODE strings.  The ACL is always in UNICODE
 in CE because it is typically read from the registry.  The function will
 return TRUE if access is allowed and FALSE if it is not allowed.

 Access may be denied if the user is not a valid user on the domain, or 
 if they are not in the Access Control List (ACL).  
 The ACL is a string, each element separeted by a semicolon, that specifies
 the name of a group or user to either allow or deny service to.  To specify
 a group, put a "@" immediatly before it.  To specify either a user or a group
 is to be denied access, put a "-" before it.  

 
 For instance, ACL = "good_user1; @good_group1; -bad_user1; -@bad_group1; good_user2"
 will allow users named good_user1, good_user2, and anyone who is a member of
 the group good_group1 access (assuming they've succesfully been authenticated
 by NTLM).  It will deny access to anyone named bad_user1 and in bad_group1.

 The checks are made from left to right, and the check will stop being made
 as soon as a match (either positive or negative) is made.

 In the above example, if good_user1 is also a member of bad_group1, they will
 recieve access because good_user1 came before bad_group1.  However, if
 good_user2 is a member of bad_group1, they will be denied access because 
 bad_group1 came before good_user2.
 
 A "*" in the ACL list means that all users are granted access, provided they 
 have not been disqualified by any of the arguments to the left of the arg
 list.

 For instance, if ACL = "-bad_user1; *" then all users will be granted
 access, except for bad_user1.
 

 IMPORTANT SECURITY CONSIDERATIONS

 Note that there is some danger in using this API set over a public network
 such as the Internet if the passwords are not encrypted by the calling 
 application.  It is possible for a malicious user to intercept packets sent 
 to  your network application and to learn the password, either on the 
 Domain or on the CE device, depending on which options are used.  Use
 this with care.


 See the telnetd sample for an example of how to use this API.

****************************************************************************/


#ifndef _AUTH_H_
#define _AUTH_H_

#ifndef UNDER_CE
#define SECURITY_WIN32
#endif

#include <windows.h>
#include <sspi.h>
#include <issperr.h>
#include <tchar.h>

BOOL AuthHelpValidateUserA(PSTR pszRemoteUser, PSTR pszPassword, TCHAR *pszACL, DWORD dwFlags);
BOOL AuthHelpValidateUserW(PWSTR wszRemoteUser, PWSTR wszPassword, TCHAR *pszACL, DWORD dwFlags);
BOOL AuthHelpValidateUser(TCHAR *pszRemoteUser, TCHAR *pszPassword, TCHAR * pszACL, DWORD dwFlags);
BOOL IsAccessAllowed(TCHAR *pszRemoteUser, TCHAR *pszRemoteUserGroups, TCHAR *pszACL, BOOL fPeek);


BOOL AuthHelpUnload();
BOOL AuthHelpInitialize();


#define AUTH_HELP_FLAGS_NO_NTLM             0x01  // Set if we skip NTLM checking
#endif // _AUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\asp.h ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: asp.h
Author: John Spaith
Abstract: ASP data block definition
--*/



BOOL InitASP(SCRIPT_LANG *psl, UINT *plCodepage, LCID *plcid);

// struct used to pass data between httpd and ASP.dll, like extension control block
typedef struct _ASP_CONTROL_BLOCK {

    DWORD	cbSize;					// size of this struct.
	HCONN	ConnID;					// Points to calling request pointer
	HINSTANCE hInst;				// ASP dll handle, used for LoadString.
    DWORD	cbTotalBytes;			// Total bytes indicated from client

	WCHAR*	wszFileName;			// name of asp file to execute
	PSTR    pszVirtualFileName;     // Virtual root of file, to display to user on error case.
	PSTR	pszForm;				// raw Form data
	PSTR	pszQueryString;			// raw QueryString data	
	PSTR	pszCookie;				// raw Cookie data, read only from client	

	// These values are read by httpd from the registry and are used  
	// if no ASP processing directive are on the executing page
	
	SCRIPT_LANG scriptLang;
	UINT    	lCodePage;
	LCID    	lcid;


	// Familiar ISAPI functions
    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

	
    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );
	
	// ASP specific fcns
	// Acts like AddHeader or SetHeader found in ISAPI filter fcns
	BOOL (WINAPI * AddHeader)(   HCONN hConn,
								 	LPSTR lpszName,
									LPSTR lspzValue);    
	
	// Sends data to client
	BOOL (WINAPI * Flush) ( HCONN hConn);

	// Clears data, if data is being buffered
	BOOL (WINAPI * Clear) ( HCONN hConn);


	// Accessors to whether we buffer data request or not
	BOOL (WINAPI * SetBuffer)    ( HCONN hConn,
								   BOOL fBuffer);					   

} ASP_CONTROL_BLOCK, *PASP_CONTROL_BLOCK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\exetst.h ===
VOID WINAPI Test(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\evtdiag.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       E V T D I A G . H
//
//  Contents:   Eventing manager diagnostic class
//
//  Notes:
//
//  Author:     danielwe   2000/10/2
//
//----------------------------------------------------------------------------


#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CUPnPEventingManagerDiag
class ATL_NO_VTABLE CUPnPEventingManagerDiag :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CUPnPEventingManagerDiag, &CLSID_UPnPEventingManagerDiag>,
    public IUPnPEventingManagerDiag
{
public:
    CUPnPEventingManagerDiag() {}
    ~CUPnPEventingManagerDiag() {}

DECLARE_NOT_AGGREGATABLE(CUPnPEventingManagerDiag)
DECLARE_CLASSFACTORY_SINGLETON(CUPnPEventingManagerDiag)
DECLARE_REGISTRY_RESOURCEID(IDR_EVENTING_MANAGER_DIAG)

BEGIN_COM_MAP(CUPnPEventingManagerDiag)
    COM_INTERFACE_ENTRY(IUPnPEventingManagerDiag)
END_COM_MAP()

public:
    // IUPnPEventingManagerDiag
        HRESULT STDMETHODCALLTYPE GetEventSourceInfo(
            /* [out] */ DWORD *pces,
            /* [size_is][size_is][out] */ UDH_EVTSRC_INFO **rgesInfo);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\filters.h ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: filter.h
Author: John Spaith
Abstract: ISAPI Filter handling class
--*/



//  on certain return codes we don't accept more filter calls
//  For instance if a call to WriteClient calling SEND_RAW_DATA ends up 
//  returning end connection, doesn't make sense to keep servicing further callbacks



class CHeaders;   			// forward declaration
class CHttpRequest; 		// forward declaration



// Like log and vroots classes, only one of these is made at startup
// This acts as a container for the many ISAPI classes that can be created

typedef struct 
{
	PWSTR wszDLLName;   
	CISAPI *pCISAPI;
	DWORD dwFlags;  	// flags filter set on GetFilterVersion
} 
FILTERINFO, *PFILTERINFO;



//  Container class that is accessed globally
class CISAPIFilterCon 
{
private:
	BOOL Init();
	void Cleanup();
public:
	int m_nFilters;		// # of filters in use
	PFILTERINFO m_pFilters;

	CISAPIFilterCon()  {ZEROMEM(this); Init(); }
	~CISAPIFilterCon() { Cleanup(); }
	void Unload(int i);
}; 


//  Memeber of CHttpRequest, hold filter specific data
class CFilterInfo
{
friend class CHttpRequest;

private:
	DWORD m_dwStartTick;		// initial tick count

	DWORD *m_pdwEnable;			// extra flags, for if ith filter is enabled in this request (bits set initally to 1'-)
	PVOID *m_ppvContext;  		// context array, used in pfc struct passed to filter
	int   m_iFIndex; 			// which filter is being acted on in filter call
	DWORD m_dwSFEvent;			// current (or last) event to be proccessed

	PHTTP_FILTER_LOG m_pFLog;	// if !NULL, it's contents override server data on log


	PVOID *m_pAllocMem;  		// Allocated memory associated with this request
	DWORD m_nAllocBlocks;		// # of blocks allocated through AllocMem

	BOOL  m_fSentHeaders;		// If TRUE, don't write back any page content.
	DWORD m_dwNextReadSize;     // amount of bytes to read in on next read filter
public:
	VOID  FreeAllocMem();  
	VOID* AllocMem(DWORD cbSize, DWORD dwReserved);

	// m_fAccept is set to FALSE when a filter returns a request finished or error code, 
	// used to stop call back functions from being carried out.
	// If a callback fnc tries to execute after this flag is set FALSE,
	// the error ERROR_OPERATION_ABORTED is set.  Like IIS.

	BOOL  m_fFAccept;			
	PSTR  m_pszDenyHeader;		// Header to tack on only on a denial

	// Used for logging
	DWORD m_dwBytesSent;
	DWORD m_dwBytesReceived;

	BOOL  ReInit();
	CFilterInfo();
	~CFilterInfo(); 
};


// Function prototypes
BOOL InitFilters();
void CleanupFilters();
CFilterInfo* CreateCFilterInfo(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\evtapi.h ===
#pragma once

#ifndef _EVTAPI_H
#define _EVTAPI_H

struct UPNP_EVENT_SOURCE;

struct UPNP_EVENT
{
    LPWSTR                  szBody;         // Body of event NOTIFY message
    UPNP_EVENT *            pevtNext;       // Next in list
};

struct UPNP_WAIT_PARAMS
{
    LPWSTR                  szEsid;         // Event source identifier
    LPWSTR                  szSid;          // Subscription Identifier
};

struct UPNP_RENEWAL
{
    LPWSTR                  szEsid;         // Event source identifier
    LPWSTR                  szSid;          // Subscription Identifier
    DWORD                   iRenewal;       // renewal index
};

struct UPNP_SUBSCRIBER
{
    UPNP_EVENT_SOURCE *     pes;            // Pointer to event source [valid
                                            // only when subscriber is in list]
    LPWSTR *                rgszUrl;        // Callback URL list
    DWORD                   cszUrl;         // Number of URLs in the list
    DWORD                   csecTimeout;    // Timeout period
    FILETIME                ftTimeout;      // Timeout period in FILETIME
    DWORD                   iSeq;           // Event sequence number
    LPWSTR                  szSid;          // Subscription Identifier
    DWORD                   cRenewals;      // # of renewals received
    DWORD                   dwIpAddr;       // IP address of subscriber's host
    HANDLE                  hEventQ;        // Event signaled when Q full
    UPNP_EVENT *            pevtQueue;      // Event queue
    UPNP_EVENT *            pevtQueueTail;  // Event queue tail
    HANDLE                  hWait;          // Handle of registered wait
    HANDLE                  hTimer;         // TimerQueue timer handle
    UPNP_WAIT_PARAMS        uwp;            // Params for the registered wait
    UPNP_RENEWAL            ur;             // Subscription renewal params
    UPNP_SUBSCRIBER *       psubNext;       // Next in list
};

const DWORD                 c_cuwlAlloc = 5; // Number of items to alloc in one chunk

struct UPNP_EVENT_SOURCE
{
    LPWSTR                  szEsid;         // Event source identifier
    UPNP_SUBSCRIBER *       psubList;       // List of subscribers
    UPNP_EVENT_SOURCE *     pesNext;        // Next in list
};

HRESULT HrInitEventApi(VOID);
HRESULT HrInitInternetSession(VOID);
VOID DeInitEventApi(VOID);

HRESULT HrRegisterEventSource(LPCWSTR szEsid);

HRESULT HrDeregisterEventSource(LPCWSTR szEsid);

HRESULT HrSubmitEvent(LPCWSTR szEsid,
                      LPCWSTR szEventBody);

HRESULT HrSubmitEventZero(LPCWSTR szEsid,
                          LPCWSTR szSid,
                          LPCWSTR szEventBody);

UPNP_EVENT_SOURCE *PesFindEventSource(LPCWSTR szEsid);
UPNP_SUBSCRIBER *PsubFindSubscriber(UPNP_EVENT_SOURCE *pes, LPCWSTR szSid);
VOID WINAPI EventQueueWorker(LPVOID pvContext, BOOL fTimeOut);
VOID AppendToEventQueue(UPNP_SUBSCRIBER * psub, UPNP_EVENT * pevt);
HRESULT HrComposeUpnpNotifyHeaders(DWORD iSeq, LPCTSTR szSid,
                                   LPWSTR *pszHeaders);
//HRESULT HrComposeXmlBodyFromEventSource(EVENT_VARIABLE *rgevVars, DWORD cVars,
//                                        LPWSTR *pszOut);
HRESULT HrSubmitNotifyToSubscriber(LPCWSTR szHeaders, LPCWSTR szBody,
                                   LPCWSTR szUrl);


VOID DbgDumpListEventSource(VOID);

HRESULT HrAddSubscriber(
    LPCWSTR     szEsid,
    DWORD       dwIpAddr,
    DWORD       cszUrl,
    LPCWSTR *   rgszCallbackUrl,
    LPCWSTR     szEventBody,
    DWORD *     pcsecTimeout,
    LPWSTR *    pszSid);

HRESULT HrRenewSubscriber(
    LPCWSTR     szEsid,
    DWORD *     pcsecTimeout,
    LPCWSTR     szSid);

HRESULT HrRemoveSubscriber(
    LPCWSTR     szEsid,
    LPCWSTR     szSid);

#endif //!_EVTAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\httpcomn.h ===
/*--
Copyright (c) 1999  Microsoft Corporation
Module Name: HTTPCOMN.H
Author: John Spaith
Abstract: Registry settings and default values used by httpd.dll, the http
          admin object, and ASP.
--*/

//  Default settings for httpd that are used by admin object and httpd.
#define HTTPD_DEFAULT_PAGES   L"default.htm;index.htm"
#define HTTPD_ALLOW_DIR_BROWSE 0    // 1 --> allow directory browsing, 0 --> don't
#define HTTP_DEFAULTP_PERMISSIONS  HSE_URL_FLAGS_EXECUTE | HSE_URL_FLAGS_READ | HSE_URL_FLAGS_SCRIPT



//------------- Registry keys -----------------------
//  These are used by httpd and by the httpd administration object.


#define RK_HTTPD        L"SOFTWARE\\MICROSOFT\\UPnP Device Host\\HTTP Server"
#define RK_HTTPDVROOTS  L"SOFTWARE\\MICROSOFT\\UPnP Device Host\\HTTP Server\\VROOTS"
#define RK_ASP          L"SOFTWARE\\MICROSOFT\\UPnP Device Host\\HTTP Server\\ASP"
#define RV_PORT         L"Port"
#define RV_BASIC        L"Basic"
#define RV_NTLM         L"NTLM"
#define RV_DIRBROWSE    L"DirBrowse"
#define RV_DEFAULTPAGE  L"DefaultPage"
#define RV_PERM         L"p"    // permissions
#define RV_AUTH         L"a"    // authentication reqd
#define RV_USERLIST     L"UserList"   // Per vroot Access Control List
#define RV_MAXLOGSIZE   L"MaxLogSize"   // largest log gets before roll over
#define RV_FILTER       L"Filter DLLs"
#define RV_LOGDIR       L"LogFileDirectory"
#define RV_ADMINUSERS   L"AdminUsers"
#define RV_ADMINGROUPS  L"AdminGroups"
#define RV_ISENABLED    L"IsEnabled"
#define RV_POSTREADSIZE L"PostReadSize"
#define RV_EXTENSIONMAP L"ExtensionMap"

#define RV_ASP_LANGUAGE   L"LANGUAGE"
#define RV_ASP_CODEPAGE   L"CODEPAGE"
#define RV_ASP_LCID       L"LCID"

#define RV_MAXCONNECTIONS L"MaxConnections"

typedef enum
{
    VBSCRIPT,
    JSCRIPT
} SCRIPT_LANG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\httpd.h ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: HTTPD.H
Author: Arul Menezes
Abstract: Global defns for the HTTP server
--*/

#ifndef _HTTPD_H_
#define _HTTPD_H_


#ifndef UNDER_CE
#define SECURITY_WIN32
#endif

#if DBG
#define DEBUG
#endif

#include <windows.h>
#include <winsock2.h>

// OLD_CE_BUILD is defined when using the Windows CE Toolkit in Visual
// Studio (in proj servers\vc\httpexece).  We build this way when we're building for
// older Windows CE devices (version 2.x).  The reason we do this in the first place is
// for shipping a beta version of the web server.
// We won't have functions like sprintf or sscanf, so we implement our own, scaled down versions.
// Also, there is no ASP support in this case.

#ifdef OLD_CE_BUILD
#pragma message ("Using Visual Studio Windows CE Toolkit Settings")

// Write our own strrchr if we're using version 2.0 of CE, it wouldn't exist otherwise
inline char *strrchr( const char *string, int c )
{
    PCSTR pszTrav = string;
    PSTR pszLast = NULL;
    while ( *pszTrav )
    {
        if (*pszTrav == (CHAR) c)
            pszLast = (PSTR) pszTrav;
        pszTrav++;
    }
    return pszLast;
}

inline int isspace(int c) {
    return ( c == ' ' || c == '\n' || c == '\t' || c == '\r' || c == '\f' || c == '\v');
}
#else
#include <stdio.h>
#endif


#include <httpext.h>
#include <httpfilt.h>
#include <service.h>
#include <uhres.h>
#include <creg.hxx>
#include <sspi.h>
#include <issperr.h>
#include <servutil.h>
#include <httpcomn.h>


#ifdef UNDER_CE
#include <windbase.h>
#include <extfile.h>
#else
#include <wininet.h>
#endif


//------------- Arbitrary constants -----------------------

// the assumption is that this buffer size covers the vast majority of requests
#define MINBUFSIZE      1024
// this the the timeout we use when waiting for the next request on a keep-alive connection
#define KEEPALIVETIMEOUT 60000
// subsequent-input timeout value. shoudl only hit on malformed headers/garbled packets
#define RECVTIMEOUT     30000
// maximum size of output headers
#define MAXHEADERS      512
// maximum size of a mime-type
#define MAXMIME         64
// maximum size username+password
#define MAXUSERPASS     256
// the assumption is that this buffer size covers most dir listings
#define DIRBUFSIZE      4096
// Size of response headers ("normal" headers, cookies and other extra headers are dynamic)
#define HEADERBUFSIZE   4096
// Used for dynamically growing arrays
#define VALUE_GROW_SIZE   5
// Size of buffer to hold all the bodies on web server errors
#define BODYSTRINGSIZE     2048

#define HTTPD_DEV_PREFIX   L"HTP"
#define HTTPD_DEV_INDEX   0
#define HTTPD_DEV_NAME     L"HTP0:"


//------------- not-so-arbitrary constants -----------------------

#define IPPORT_HTTP     2869


//-------------------- Debug defines ------------------------

// Debug zones
#ifdef DEBUG
  #define ZONE_ERROR    DEBUGZONE(0)
  #define ZONE_INIT     DEBUGZONE(1)
  #define ZONE_LISTEN   DEBUGZONE(2)
  #define ZONE_SOCKET   DEBUGZONE(3)
  #define ZONE_REQUEST  DEBUGZONE(4)
  #define ZONE_RESPONSE DEBUGZONE(5)
  #define ZONE_ISAPI    DEBUGZONE(6)
  #define ZONE_VROOTS   DEBUGZONE(7)
  #define ZONE_ASP      DEBUGZONE(8)
  #define ZONE_DEVICE   DEBUGZONE(9)
  #define ZONE_MEM      DEBUGZONE(13)
  #define ZONE_PARSER   DEBUGZONE(14)
  #define ZONE_TOKEN    DEBUGZONE(15)
#endif


#define NTLM_PACKAGE_NAME   TEXT("NTLM")

// We need CE_STRING because GetProcAddress takes a LPCSTR as arg on NT, but UNICODE is defined
// so the TEXT macro would return a UNICODE string
#ifdef  UNDER_CE
#define NTLM_DLL_NAME     TEXT("secur32.dll")
#define CE_STRING(x)      TEXT(x)
#define SECURITY_ENTRYPOINT_CE  SECURITY_ENTRYPOINT
#else
#define NTLM_DLL_NAME     TEXT("security.dll")
#define CE_STRING(x)      (LPCSTR) (x)
#define SECURITY_ENTRYPOINT_CE  SECURITY_ENTRYPOINT_ANSIA
#endif




#define ASP_DLL_NAME      TEXT("asp.dll")

/////////////////////////////////////////////////////////////////////////////
// Misc string handling helpers
/////////////////////////////////////////////////////////////////////////////

PSTR MySzDupA(PCSTR pszIn, int iLen=0);
PWSTR MySzDupW(PCWSTR wszIn, int iLen=0);
PWSTR MySzDupAtoW(PCSTR pszIn, int iInLen=-1);
PSTR MySzDupWtoA(PCWSTR wszIn, int iInLen=-1);
BOOL MyStrCatA(PSTR *ppszDest, PSTR pszSource, PSTR pszDivider=NULL);


// Misc HTTP helper macros
#define CHECKHCONN(h) if(!h || ((CHttpRequest*)h)->m_dwSig != CHTTPREQUEST_SIG) { SetLastError(ERROR_INVALID_PARAMETER); return FALSE; }
#define CHECKPFC(h)  if (!h || ((CHttpRequest*)h->ServerContext)->m_dwSig != CHTTPREQUEST_SIG) { SetLastError(ERROR_INVALID_PARAMETER); return FALSE; }
#define CHECKPTR(p) if (!p) { SetLastError(ERROR_INVALID_PARAMETER); return FALSE; }
#define CHECKPTRS2(p1, p2) if(!p1 || !p2) { SetLastError(ERROR_INVALID_PARAMETER); return FALSE; }
#define CHECKPTRS3(p1, p2, p3) if(!p1 || !p2 || !p3) { SetLastError(ERROR_INVALID_PARAMETER); return FALSE; }

#define CHECKFILTER(pfc)    { if (! ((CHttpRequest*)pfc->ServerContext)->m_pFInfo->m_fFAccept)  \
                                    {       SetLastError(ERROR_OPERATION_ABORTED);  return FALSE;   } }
#define SkipWWhiteSpace(lpsz)    while ( (lpsz)[0] != L'\0' && iswspace((lpsz)[0])) ++(lpsz)



//------------- Scalar Data typedefs -----------------------
// HTTP status codes
typedef enum
{
    STATUS_OK = 0,
    STATUS_MOVED,
    STATUS_NOTMODIFIED,
    STATUS_BADREQ,
    STATUS_UNAUTHORIZED,
    STATUS_FORBIDDEN,
    STATUS_NOTFOUND,
    STATUS_INTERNALERR,
    STATUS_NOTIMPLEM,
    STATUS_NOTSUPP,
    STATUS_MAX,
}
RESPONSESTATUS;

// Data used for response static data
typedef struct
{
    DWORD dwStatusNumber;
    PCSTR pszStatusText;
    PCSTR pszStatusBody;
}
STATUSINFO;



//------------- Const data prototypes -----------------------


extern STATUSINFO rgStatus[STATUS_MAX];
extern const char cszTextHtml[];
extern const char cszEmpty[];
extern const char cszServerID[];
extern const char cszProductID[];
extern const char* rgMonth[];
extern const char cszKeepAlive[];
extern const char cszHTTPVER[];
extern const char cszDateParseFmt[];
extern const char cszDateOutputFmt[];
extern const char* rgWkday[];
extern const char* rgMonth[];
extern const char cszCRLF[];
extern const char cszBasic[];
extern BOOL g_fFromExe;     // Did the executable start us?


//----------------------- Class defns -----------------------


#include <asp.h>
#include <buffio.h>
#include <extns.h>
#include <vroots.hpp>
#include <auth.h>
#include <request.h>
#include <log.h>
#include <filters.h>
#include <authhlp.h>

//-------------------- All global data is accessed through Global Class ----------

class CGlobalVariables
{
public:
    SOCKET    m_sockListen;
    DWORD     m_dwListenPort;           // port we're listening on (can be modified in registry. default=80)
    CVRoots*  m_pVroots;                // ptr to VRoot structure, containing or URL-->Paths mappings
    BOOL      m_fBasicAuth;             // are we allowing Basic auth (from registry)
    BOOL      m_fNTLMAuth;              // are we allowing NTLM auth (from registry)
    BOOL      m_fFilters;               // Is ISAPI filter component included?
    BOOL      m_fExtensions;            // Is ISAPI extension component included?
    BOOL      m_fASP;                   // Is ASP component included?
    BOOL      m_fDirBrowse;             // are we allowing directory browsing (from registry)
    PWSTR     m_wszDefaultPages;        // are we allowing directory browsing (from registry)
    BOOL      m_fAcceptConnections;     // are we accepting new threads?
    LONG      m_nConnections;           // # of connections (threads) we're handling
    LONG      m_nMaxConnections;        // Maximum # of connections we support concurrently
    CLog*     m_pLog;                   // Logging structure
    DWORD     m_dwPostReadSize;         // Size of chunks of data to recv() in POST request.
    PSTR      m_pszServerID;            // Server ID

    CISAPICache *m_pISAPICache;         // Used to cache ISAPI extension and ASP dlls
    DWORD     m_dwCacheSleep;           // How often (in millesecs) do we

    PWSTR     m_wszAdminUsers;          // List of users who have administrative privelages
    PWSTR     m_wszAdminGroups;         // List of groups who have administrative privelages

    PSTR      m_pszStatusBodyBuf;       // Holds the strings of http bodies loaded from rc file

    SVSThreadPool *m_pThreadPool;       // All httpd threads other than HttpConnectionThread use this
    LONG      m_fISAPICacheRunning;     // Is ISAPI cache cleanup thread running?

    // ASP Specific
    SCRIPT_LANG m_ASPScriptLang;        // Registry set default scripting language
    LCID        m_ASPlcid;              // Registry set default LCID
    UINT        m_lASPCodePage;         // Registry set default Code Page

    // Authentication Specific
    HINSTANCE               m_hNTLMLib;         // Global NTLM library handle
    DWORD                   m_cbNTLMMax;        // max ntlm allowable data size
    PSecurityFunctionTable  m_pNTLMFuncs;       // fcn table for NTLM requests

    HANDLE                  m_hEventSelect;
    HANDLE                  m_hEventShutdown;


    CGlobalVariables();
    ~CGlobalVariables();
};

extern CGlobalVariables *g_pVars;
extern HINSTANCE g_hInst;
extern HANDLE    g_hListenThread;
extern BOOL      g_fRegistered;
extern LONG      g_fState;

//------------- Function prototypes -------------------------
DWORD WINAPI HttpConnectionThread(LPVOID lpv);
DWORD WINAPI HandleAccept(LPVOID lpv);
extern "C" int HttpInitialize(TCHAR *szRegPath);


void GetRemoteAddress(SOCKET sock, PSTR pszBuf);
void GetLocalAddress(SOCKET sock, PSTR pszBuf);
DWORD WINAPI RemoveUnusedISAPIs(LPVOID lpv);
BOOL SetHTTPVersion(PSTR pszVersion, DWORD *pdwVersion);
void WriteHTTPVersion(PSTR pszVersion, DWORD dwVersion);
char *strcpyEx(char *szDest, const char *szSrc);

BOOL SetHTTPDate(PSTR pszDate, PSTR pszMonth, SYSTEMTIME *pst,PDWORD pdwModifiedLength);
PSTR WriteHTTPDate(PSTR pszDateBuf, SYSTEMTIME *pst, BOOL fAddGMT);
void InitializeResponseCodes(PSTR pszStatusBodyBuf);

BOOL Base64Encode(
            BYTE *   bufin,          // in
            DWORD    nbytes,         // in
            char *   pbuffEncoded);   // out
BOOL Base64Decode(
            char   * bufcoded,       // in
            char   * pbuffdecoded,   // out
            DWORD  * pcbDecoded);     // in out


#endif //_HTTPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\evtobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V T O B J . H
//
//  Contents:   Declares the Eventing Manager object for the UPnP Device Host
//              API
//
//  Notes:
//
//  Author:     danielwe   7 Aug 2000
//
//----------------------------------------------------------------------------

#ifndef _EVTOBJ_H
#define _EVTOBJ_H

#pragma once

#include "uhres.h"
#include "hostp.h"

/////////////////////////////////////////////////////////////////////////////
// CUPnPEventingManager
class ATL_NO_VTABLE CUPnPEventingManager :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CUPnPEventingManager, &CLSID_UPnPEventingManager>,
    public IUPnPEventingManager,
    public IUPnPEventSink
{
private:
    LPWSTR                  m_szEsid;
    IUPnPEventSource *      m_pues;
    IUPnPAutomationProxy *  m_puap;

public:

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_REGISTRY_RESOURCEID(IDR_EVENTING_MANAGER)

    DECLARE_NOT_AGGREGATABLE(CUPnPEventingManager)

    BEGIN_COM_MAP(CUPnPEventingManager)
        COM_INTERFACE_ENTRY(IUPnPEventingManager)
        COM_INTERFACE_ENTRY(IUPnPEventSink)
    END_COM_MAP()

    CUPnPEventingManager(VOID)
    {
        m_szEsid = NULL;
        m_pues = NULL;
        m_puap = NULL;
    }

// IUPnPEventingManager
public:

    STDMETHOD(Initialize)(/* [in] */ LPCWSTR szUdn,
                          /* [in] */ LPCWSTR szSid,
                          /* [in] */ IUPnPAutomationProxy *puap,
                          /* [in] */ IUnknown *punkSvc,
                          /* [in] */ BOOL bRunning);

    STDMETHOD(AddSubscriber)(/* [in] */ DWORD cszUrl,
                             /* [size_is][in] */ LPCWSTR *rgszCallbackUrl,
                             /* [in] */ DWORD dwIpAddr,
                             /* [in,out] */ DWORD *pcsecTimeout,
                             /* [out] */ LPWSTR *pszSid);

    STDMETHOD(RenewSubscriber)(/* [in,out] */ DWORD *pcsecTimeout,
                               /* [in] */ LPWSTR szSid);

    STDMETHOD(RemoveSubscriber)(/* [in] */ LPWSTR szSid);

    STDMETHOD(Shutdown)(VOID);

// IUPnPEventSink
public:
    STDMETHOD(OnStateChanged)(/* [in] */ DWORD cChanges,
                              /* [size_is][in] */ DISPID rgdispidChanges[]);

    STDMETHOD(OnStateChangedSafe)(/* [in] */ VARIANT varsadispidChanges);


// ATL methods
    HRESULT FinalConstruct() {return S_OK;}
    HRESULT FinalRelease();
};

HRESULT HrComposeEventBody(IUPnPAutomationProxy* puap, DWORD cVars, LPWSTR *rgszNames, LPWSTR *rgszTypes,
                           VARIANT *rgvarValues, LPWSTR *pszBody);

VOID RemoveDuplicateDispids(DWORD *pcChanges, DISPID *rgdispids);

#endif //!_EVTOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\extns.h ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: ISAPI.H
Author: Arul Menezes
Abstract: ISAPI Exten & Filter handling classes
--*/


typedef enum
{
	SCRIPT_TYPE_NONE = 0,
	SCRIPT_TYPE_EXTENSION,
	SCRIPT_TYPE_ASP,
	SCRIPT_TYPE_FILTER
}
SCRIPT_TYPE;




typedef DWORD (WINAPI *PFN_HTTPFILTERPROC)(HTTP_FILTER_CONTEXT* pfc, DWORD NotificationType, VOID* pvNotification);
typedef BOOL  (WINAPI *PFN_GETFILTERVERSION)(HTTP_FILTER_VERSION* pVer);
typedef BOOL  (WINAPI *PFN_TERMINATEFILTER)(DWORD dwFlags);
typedef void  (WINAPI *PFN_TERMINATEASP)();
typedef DWORD (WINAPI *PFN_EXECUTEASP)(PASP_CONTROL_BLOCK pASPBlock);

class CISAPICache; 
BOOL InitExtensions(CISAPICache **ppISAPICache, DWORD *pdwCacheSleep);
int RecvToBuf(SOCKET socket,PVOID pv, DWORD dw,DWORD dwTimeout=RECVTIMEOUT);

class CISAPI
{
friend CISAPICache;

// ISAPI extension & filter handling data members
	SCRIPT_TYPE  m_scriptType;   // Extension, Filter, or ASP?
	HINSTANCE  m_hinst;
	FARPROC m_pfnGetVersion;
	FARPROC m_pfnHttpProc;
	FARPROC m_pfnTerminate;
	DWORD dwFilterFlags;  	// Flags negotiated on GetFilterVersion	

	// Used by the caching class 
	PWSTR   m_wszDLLName;	// full path of ISAPI Dll
	DWORD   m_cRef;			// Reference Count
	__int64 m_ftLastUsed;	// Last used, treat as FILETIME struct


public:
	CISAPI(SCRIPT_TYPE st) 
	{ 
		ZEROMEM(this); 
		m_scriptType = st; 
	}

	~CISAPI() 	{ MyFree(m_wszDLLName); 	}
	void Unload(PWSTR wszDLLName=NULL);
	BOOL Load(PWSTR wszPath);
	void CoFreeUnusedLibrariesIfASP()
	{
		if (m_scriptType == SCRIPT_TYPE_ASP)
		{
			// calls into ASP exported function, which calls CoFreeUnusedLibraries
			// but does nothing else.  We don't call CoFreeUnusedLibraries from the web 
			// server directly because we don't want to have to link it to COM.

			// Does not free asp.dll, because we have a reference to it in the server.
			((PFN_TERMINATEASP)m_pfnTerminate)();
		}
	}
	
	DWORD CallExtension(EXTENSION_CONTROL_BLOCK * pECB)	{ return ((PFN_HTTPEXTENSIONPROC)m_pfnHttpProc)(pECB); }
	DWORD CallFilter(HTTP_FILTER_CONTEXT* pfc, DWORD n, VOID* pv) { return ((PFN_HTTPFILTERPROC)m_pfnHttpProc)(pfc, n, pv); }
	DWORD CallASP(PASP_CONTROL_BLOCK pACB)  { return ((PFN_EXECUTEASP) m_pfnHttpProc)(pACB); }
	DWORD GetFilterFlags()  { return dwFilterFlags; }
};


typedef struct _isapi_node
{
	CISAPI *m_pISAPI;		// class has library and entry point functions
	struct _isapi_node *m_pNext;
} ISAPINODE, *PISAPINODE;

class CISAPICache
{
private:
	PISAPINODE m_pHead;
	CRITICAL_SECTION m_CritSec;

public:
	CISAPICache()    	
	{ 
		ZEROMEM(this);  	
		InitializeCriticalSection(&m_CritSec);
	}
	~CISAPICache()
	{
		DeleteCriticalSection(&m_CritSec);
	}

	
	HINSTANCE Load(PWSTR wszDLLName, CISAPI **ppISAPI, SCRIPT_TYPE st=SCRIPT_TYPE_EXTENSION);
	void Unload(CISAPI *pISAPI)
	{
		SYSTEMTIME st;
		if (NULL == pISAPI)
			return;
			
		EnterCriticalSection(&m_CritSec);
		
		GetSystemTime(&st);
		SystemTimeToFileTime(&st,(FILETIME *) &pISAPI->m_ftLastUsed);
		pISAPI->m_cRef--;

		LeaveCriticalSection(&m_CritSec);
	}

	void RemoveUnusedISAPIs(BOOL fRemoveAll);
	friend DWORD WINAPI RemoveUnusedISAPIs(LPVOID lpv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\service.h ===
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.
Copyright (c) 1995-1998  Microsoft Corporation

Module Name:  

service.h

Abstract:  
	Defines programming model for Windows CE Services
	
Notes: 


--*/
#if ! defined (__service_H__)
#define __service_H__		1

#ifdef OLD_CE_BUILD
// We have to make a private copy of it here because we can't include
// \public\common\oak\inc without seriously confusing VC.
#define FILE_DEVICE_SERVICE				0x00000104
#endif
#include <winioctl.h>



//
//	Return codes
//
#define SERVICE_SUCCESS				0

//
//	Service states
//
#define SERVICE_STATE_OFF           0
#define SERVICE_STATE_ON            1
#define SERVICE_STATE_STARTING_UP   2
#define SERVICE_STATE_SHUTTING_DOWN 3


//
//	Service is interfaced via series of IOCTL calls that define service life cycle.
//	Actual implementation is service-specific.
//

//
//	Start the service that has been in inactive state. Return code: SERVICE_SUCCESS or error code.
//
#define IOCTL_SERVICE_START		CTL_CODE(FILE_DEVICE_SERVICE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Stop service, but do not unload service's DLL
//
#define IOCTL_SERVICE_STOP		CTL_CODE(FILE_DEVICE_SERVICE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Refresh service's state from registry or other configuration storage
//
#define IOCTL_SERVICE_REFRESH	CTL_CODE(FILE_DEVICE_SERVICE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Have service configure its registry for auto-load
//
#define IOCTL_SERVICE_INSTALL	CTL_CODE(FILE_DEVICE_SERVICE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Remove registry configuration
//
#define IOCTL_SERVICE_UNINSTALL	CTL_CODE(FILE_DEVICE_SERVICE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Unload the service which should be stopped.
//
#define IOCTL_SERVICE_UNLOAD	CTL_CODE(FILE_DEVICE_SERVICE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Supply a configuration or command string and code to the service.
//
#define IOCTL_SERVICE_CONTROL	CTL_CODE(FILE_DEVICE_SERVICE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//	Return service status.
//
#define IOCTL_SERVICE_STATUS	CTL_CODE(FILE_DEVICE_SERVICE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif	/* __service_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UPnP.rc
//
#define IDS_PROJNAME                    100

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\log.h ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: LOG.H
Author: John Spaith
Abstract: Logging functions
--*/



// If registry key doesn't exist, this will be the largest we'll let log grow to


class CHttpRequest;  // forward declaration


// Right now we assume only one object handles all requests.

#ifdef WEB_SERVER_LOGGING
class CLog
{
private:
    HANDLE m_hLog;
    DWORD_PTR m_dwMaxFileSize;              // Max log can grow before it's rolled over
    DWORD_PTR m_dwFileSize;                 // Current file lenght
    CRITICAL_SECTION m_CritSection;
    WCHAR lpszCurrentLog[MAX_PATH+1];
    WCHAR lpszPrevLog[MAX_PATH+1];

public:
    CLog(DWORD_PTR dwMaxFileLen, WCHAR * lpszLogDir);
    ~CLog();

    void WriteData(PSTR wszData, DWORD_PTR dwToWrite);
    void WriteLog(CHttpRequest* pThis);
    void WriteEvent(DWORD dwEvent,...);
};
#else
class CLog
{
public:
    CLog(DWORD_PTR dwMaxFileLen, WCHAR * lpszLogDir) {}
    ~CLog() {}

    void WriteData(PSTR wszData, DWORD_PTR dwToWrite) {}
    void WriteLog(CHttpRequest* pThis) {}
    void WriteEvent(DWORD dwEvent,...){}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\udhhttp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U D H H T T P . H
//
//  Contents:   Device host HTTP server interface
//
//  Notes:
//
//  Author:     danielwe   2000/10/31
//
//----------------------------------------------------------------------------

#ifndef _UDHHTTP_H
#define _UDHHTTP_H

#pragma once

HRESULT HrHttpInitialize(VOID);
HRESULT HrAddVroot(LPWSTR szUrl, LPWSTR szPath);
HRESULT HrRemoveVroot(LPWSTR szUrl);
HRESULT HrHttpShutdown(VOID);

#endif //_UDHHTTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\uhbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H B A S E . H
//
//  Contents:   Base include file for upnphost.dll.  Defines globals.
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once
//#include "netcon.h"
//#include "netconp.h"

#include <atlbase.h>

class CServiceModule : public CComModule
{
public:
    VOID    DllProcessAttach (HINSTANCE hinst);
    VOID    DllProcessDetach (VOID);

    VOID    ServiceMain (DWORD argc, PWSTR argv[]);
    DWORD   DwHandler (DWORD dwControl, DWORD dwEventType,
                       PVOID pEventData, PVOID pContext);
    VOID    Run ();
    VOID    SetServiceStatus (DWORD dwState);
    VOID    UpdateServiceStatus (BOOL fUpdateCheckpoint = TRUE);
    DWORD   DwServiceStatus () { return m_status.dwCurrentState; }

private:
    static
    DWORD
    WINAPI
    _DwHandler (
        DWORD dwControl,
        DWORD dwEventType,
        PVOID pEventData,
        PVOID pContext);

public:
    DWORD                   m_dwThreadID;
    SERVICE_STATUS_HANDLE   m_hStatus;
    SERVICE_STATUS          m_status;
};


extern CServiceModule _Module;
#include <atlcom.h>

#include "ncatl.h"
#include "ncstring.h"
#include "uhclsid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\servutil.h ===
/*--
Copyright (c) 1995-1999  Microsoft Corporation
Module Name: servutil.h
Authors: Arul Menezes
         John Spaith
Abstract: Common macros for servers project
--*/


#ifndef UNDER_CE
#ifdef DEBUG
#   define DEBUGMSG(x, y)   wprintf y
#   define DEBUGCHK(exp)    Assert(exp)
#   define RETAILMSG(x,y)   wprintf y
#else
#   define DEBUGMSG(x, y)
#   define DEBUGCHK(exp)
#   define RETAILMSG(x,y)
#endif  // DEBUG
#endif  // UNDER_CE

// Debug Macros
// Some functions use a local variable err to help with debugging messages,
// -- if err != 0 then there's been an error, which will be print out.
// However we don't want this extra variable and checks in retail mode.

// ISSUE-2000/11/7-danielwe: Need to remove this eventually
#define DEBUG_CODE_INIT     int err = 0;

#ifdef DEBUG
#define DEBUGMSG_ERR(x,y)    { if (err)  {  DEBUGMSG(x,y); } }
#define myretleave(r,e) { ret=r; err=e; goto done; }
#define myleave(e)      { err=e; goto done; }
#else
#define DEBUGMSG_ERR(x,y)
#define myretleave(r,e) { ret=r; goto done; }
#define myleave(e)      { goto done; }
#endif



#define ARRAYSIZEOF(x)  (sizeof(x) / sizeof((x)[0]))
#define CCHSIZEOF       ARRAYSIZEOF
#define ZEROMEM(p)      memset(p, 0, sizeof(*(p)))

#define CELOADSZ(ids)       ((LPCTSTR)LoadString(g_hInst, ids, NULL, 0) )

inline void *svsutil_AllocZ (DWORD dwSize, void *pvAllocData) {
    void *pvRes = svsutil_Alloc (dwSize, pvAllocData);

    if (pvRes)
        memset (pvRes, 0, dwSize);

    return pvRes;
}

inline void *svsutil_ReAlloc(DWORD dwSizeOld, DWORD dwSizeNew, BYTE *pvDataOld, void *pvAllocData)
{
    DEBUGCHK(dwSizeOld < dwSizeNew);
    BYTE *pvRes = (BYTE *) svsutil_Alloc(dwSizeNew, pvAllocData);

    if (pvRes)
    {
        memcpy(pvRes,pvDataOld,dwSizeOld);
        memset(pvRes + dwSizeOld,0,dwSizeNew - dwSizeOld);
        g_funcFree(pvDataOld,g_pvFreeData);
    }

    return pvRes;
}

#define MyAllocZ(typ)       ((typ*)svsutil_AllocZ(sizeof(typ), g_pvAllocData))
#define MyAllocNZ(typ)      ((typ*)g_funcAlloc(sizeof(typ), g_pvAllocData))
#define MyRgAllocZ(typ, n)  ((typ*)svsutil_AllocZ((n)*sizeof(typ), g_pvAllocData))
#define MyRgAllocNZ(typ, n) ((typ*)g_funcAlloc((n)*sizeof(typ), g_pvAllocData))
#define MyRgReAlloc(typ, p, nOld, nNew) ((typ*) svsutil_ReAlloc(sizeof(typ)*(nOld), sizeof(typ)*(nNew), (BYTE*) p, g_pvAllocData))
#define MyFree(p)           { if (p) { g_funcFree ((void *) p, g_pvFreeData); (p)=0;}  }
#define MyFreeNZ(p)         { if (p) { g_funcFree ((void *) p, g_pvFreeData);}  }

#define MySzAllocA(n)       MyRgAllocNZ(CHAR, (1+(n)))
#define MySzAllocW(n)       MyRgAllocNZ(WCHAR, (1+(n)))
#define MySzReAllocA(p, nOld, nNew)  MyRgReAlloc(CHAR, p, nOld, (1+(n)))



#define ResetString(oldStr, newStr)   { MyFree(oldStr); oldStr = MySzDupA(newStr); }

#define Nstrcpy(szDest, szSrc, nLen)     { memcpy((szDest), (szSrc), (nLen));   \
                                           (szDest)[(nLen)] = 0; }

// Copy from pszDest to pszDest, and move
#define CONSTSIZEOF(x)      (sizeof(x)-1)

#define NTFAILED(x)          (INVALID_HANDLE_VALUE == (x))


#define MyFreeLib(h)        { if(h) FreeLibrary(h); }
#define MyCloseHandle(h)    { if(INVALID_HANDLE_VALUE != h) CloseHandle(h); }
#define MyCreateProcess(app, args) CreateProcess(app, args, NULL,NULL,FALSE,0,NULL,NULL,NULL,NULL)
#define MyCreateThread(fn, arg)    CreateThread(NULL, 0, fn, (LPVOID)arg, 0, NULL)
#define MyOpenReadFile(path)       CreateFile(path, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)
#define MyOpenAppendFile(path)     CreateFile(path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0)
#define MyOpenQueryFile(path)     CreateFile(path, 0, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)


#define abs(x)      ( (x) < 0 ? -(x) : (x) )
#define MyStrlenA(str)   ( str ? strlen(str) : 0 )
#define MyStrlenW(str)   ( str ? wcslen(str) : 0 )
//------------- Error handling macros ------------------------

#define GLE(e)          (e ? GetLastError() : 0)

/////////////////////////////////////////////////////////////////////////////
// Misc string handling helpers
/////////////////////////////////////////////////////////////////////////////

#define MyA2W(psz, wsz, iOutLen) MultiByteToWideChar(CP_ACP, 0, psz, -1, wsz, iOutLen)
#define MyW2A(wsz, psz, iOutLen) WideCharToMultiByte(CP_ACP, 0, wsz, -1, psz, iOutLen, 0, 0)
#define MyW2ACP(wsz, psz, iOutLen, lCodePage) WideCharToMultiByte(lCodePage, 0, wsz, -1, psz, iOutLen, 0, 0)

#define _stricmp(sz1, sz2) lstrcmpiA(sz1, sz2)
#define strcmpi _stricmp

//  max # of times we try to get our server going in device.exe
#define MAX_SERVER_STARTUP_TRIES   60
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\uhclsid.h ===
#include <guiddef.h>

// Reserved GUIDS for our use
//
// 9aa718e0-6d59-11d4-bf42-00b0d0118b56
// 9aa718e1-6d59-11d4-bf42-00b0d0118b56
// 9aa718e2-6d59-11d4-bf42-00b0d0118b56
// 9aa718e3-6d59-11d4-bf42-00b0d0118b56
// 9aa718e4-6d59-11d4-bf42-00b0d0118b56
// 9aa718e5-6d59-11d4-bf42-00b0d0118b56
// 9aa718e6-6d59-11d4-bf42-00b0d0118b56
// 9aa718e7-6d59-11d4-bf42-00b0d0118b56
// 9aa718e8-6d59-11d4-bf42-00b0d0118b56
// 9aa718e9-6d59-11d4-bf42-00b0d0118b56
// 9aa718ea-6d59-11d4-bf42-00b0d0118b56
// 9aa718eb-6d59-11d4-bf42-00b0d0118b56
// 9aa718ec-6d59-11d4-bf42-00b0d0118b56
// 9aa718ed-6d59-11d4-bf42-00b0d0118b56
// 9aa718ee-6d59-11d4-bf42-00b0d0118b56
// 9aa718ef-6d59-11d4-bf42-00b0d0118b56
// 9aa718f0-6d59-11d4-bf42-00b0d0118b56
// 9aa718f1-6d59-11d4-bf42-00b0d0118b56
// ......
// 9aa71cb7-6d59-11d4-bf42-00b0d0118b56
// 9aa71cb8-6d59-11d4-bf42-00b0d0118b56

// The following CLSIDs are defined in uuid.lib because the public uses them.
//
//EXTERN_C const CLSID CLSID_ConnectionManager;

//DEFINE_GUID(CLSID_ConnectionManagerEnumConnection,          //0xBA126AD2,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\request.h ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: REQUEST.H
Author: Arul Menezes
Abstract: HTTP request class
--*/



// Scalar types used by CHTTPRequest
typedef enum {
    TOK_GET=1,
    TOK_HEAD,
    TOK_POST,
    TOK_UNKNOWN_VERB,
    TOK_DATE,
    TOK_PRAGMA,
    TOK_COOKIE,
    TOK_ACCEPT,
    TOK_REFERER,
    TOK_UAGENT,
    TOK_AUTH,
    TOK_IFMOD,
    TOK_TYPE,
    TOK_LENGTH,
    TOK_ENCODING,
    TOK_CONNECTION,
}
TOKEN;

typedef enum
{
    CONN_NONE  = 0,
    CONN_CLOSE = 1,
    CONN_KEEP  = 2,
}
CONNHEADER;

#define CHTTPREQUEST_SIG 0xAB0D


// This object is the top-level object for an incoming HTTP request. One such object
// is created per request & a thread is created to handle it.

class CFilterInfo;

class CHttpRequest
{

// socket
    DWORD   m_dwSig;
    SOCKET  m_socket;

// buffers
    CBuffer m_bufRequest;
    CBuffer m_bufRespBody;

// method, version, URL etc. Direct results of parse
    PSTR    m_pszMethod;
    PSTR    m_pszURL;
    PSTR    m_pszContentType;
    DWORD   m_dwContentLength;
    PSTR    m_pszAccept;
    FILETIME m_ftIfModifiedSince;
    DWORD   m_dwIfModifiedLength;
    BOOL    m_fKeepAlive;
    PSTR    m_pszCookie;


// Decoded URL (indirect results of parse)
    PSTR    m_pszQueryString;
    PWSTR   m_wszPath;
    PWSTR   m_wszExt;
    PSTR    m_pszPathInfo;
    PSTR    m_pszPathTranslated;

// VRoot information
    SCRIPT_TYPE m_VRootScriptType;
    DWORD   m_dwPermissions;
    AUTHLEVEL m_AuthLevelReqd;

// Logging members
    PSTR    m_pszLogParam;
    RESPONSESTATUS m_rs;

    BOOL m_fBufferedResponse;   // Are we using m_bufResponse or sending straight to client?

// Async support
    HANDLE m_hEvent;
    DWORD m_dwStatus;
    LPEXTENSION_CONTROL_BLOCK m_pECB;
    PVOID m_pvContext;
    PFN_HSE_IO_COMPLETION m_pfnCompletion;

// Parsing functions
    void FreeHeaders(void)
    {
        MyFree(m_pszMethod);
        MyFree(m_pszURL);
        MyFree(m_pszContentType);
        MyFree(m_pszAccept);
        MyFree(m_pszQueryString);
        MyFree(m_wszPath);
        MyFree(m_wszExt);
        MyFree(m_pszCookie);
        MyFree(m_pszLogParam);
        MyFree(m_pszPathInfo);
        MyFree(m_pszPathTranslated);
    }
    BOOL ParseHeaders();
    BOOL MyCrackURL(PSTR pszRawURL, int iLen);

public:
    BOOL ParseMethod(PCSTR pszMethod, int cbMethod);
    BOOL ParseContentLength(PCSTR pszMethod, TOKEN id);
    BOOL ParseContentType(PCSTR pszMethod, TOKEN id);
    BOOL ParseIfModifiedSince(PCSTR pszMethod, TOKEN id);
    BOOL ParseAuthorization(PCSTR pszMethod, TOKEN id);
    BOOL ParseAccept(PCSTR pszMethod, TOKEN id);
    BOOL ParseConnection(PCSTR pszMethod, TOKEN id);
    BOOL ParseCookie(PCSTR pszMethod, TOKEN id);
    BOOL HandleNTLMAuth(PSTR pszNTLMData);
    PSTR    m_pszNTLMOutBuf;        // buffer to send client on NTLM response, Base64 encoded
    DWORD   m_dwVersion;    // LOWORD=minor, HIWORD=major.
    TOKEN   m_idMethod;
    CBuffer m_bufRespHeaders;
    CFilterInfo *m_pFInfo;      // Filter state information

private:

// Authentication data members
    AUTHLEVEL m_AuthLevelGranted;
    PSTR    m_pszAuthType;
    PSTR    m_pszRawRemoteUser;     // Holds base64 encoded data, before auth decodes it
    PSTR    m_pszRemoteUser;
    PSTR    m_pszPassword;
    AUTH_NTLM m_NTLMState;          // state info for NTLM process, needs to be saved across requests
    DWORD   m_dwAuthFlags;
    WCHAR   *m_wszVRootUserList;    // Do NOT free this, points to global mem.  Contains user/group ACL

// Authentication functions
    void FreeAuth(void)
    {
        MyFree(m_pszAuthType);
        MyFree(m_pszRawRemoteUser);
        MyFree(m_pszRemoteUser);
        MyFree(m_pszPassword);
        MyFree(m_pszNTLMOutBuf);
        //  Don't free NTLM structs in here
    }

    BOOL CheckAuth(AUTHLEVEL AuthLevelReqd)
    {
        return ( (AuthLevelReqd <= m_AuthLevelGranted));
    }
    BOOL CheckAuth() { return CheckAuth(m_AuthLevelReqd); }


// File GET/HEAD handling functions
    BOOL IsNotModified(HANDLE hFile, DWORD dwLength);
    static RESPONSESTATUS GLEtoStatus(int iGLE);


// Directory: Default page & browsing functions
    BOOL MapDirToDefaultPage(void);
    BOOL EmitDirListing(void);

    void Init();


    BOOL ReadPostData(DWORD dwMaxSizeToRead, BOOL fInitialPostRead);
    CONNHEADER GetConnHeader()   { return m_fKeepAlive ? CONN_KEEP : CONN_CLOSE; }


// ISAPI extension handling functions
    BOOL HandleScript();
    BOOL ExecuteISAPI(void);
    void FillECB(LPEXTENSION_CONTROL_BLOCK pECB);
    BOOL GetServerVariable(PSTR pszVar, PVOID pvOutBuf, PDWORD pdwOutSize, BOOL fFromFilter);
    BOOL WriteClient(PVOID pvBuf, PDWORD pdwSize, BOOL fFromFilter);
    BOOL WriteClientAsync(PVOID pvBuf, PDWORD pdwSize, BOOL fFromFilter);
    BOOL ServerSupportFunction(DWORD dwReq, PVOID pvBuf, PDWORD pdwSize, PDWORD pdwType);
    BOOL ReadClient(PVOID pv, PDWORD pdw);

    void StartRemoveISAPICacheIfNeeded();

//  Filter Specific
    BOOL FillFC(PHTTP_FILTER_CONTEXT pfc, DWORD dwNotifyType,
                          LPVOID *ppStFilter, LPVOID *ppStFilterOrg,
                          PSTR *ppvBuf1, int *pcbBuf, PSTR *ppvBuf2, int *pcbBuf2);
    void CleanupFC(DWORD dwNotifyType, LPVOID* pFilterStruct, LPVOID *pFilterStructOrg,
                            PSTR *ppvBuf1, int *pcbBuf, PSTR *ppvBuf2);

    BOOL AuthenticateFilter();
    BOOL FilterMapURL(PSTR pvBuf, WCHAR *wszPath, DWORD *pdwSize, DWORD dwBufNeeded, PSTR pszURLEx=NULL);
    BOOL MapURLToPath(PSTR pszBuffer, PDWORD pdwSize, LPHSE_URL_MAPEX_INFO pUrlMapEx=NULL);

    // Filter Callbacks
    BOOL ServerSupportFunction(enum SF_REQ_TYPE sfReq,PVOID pData,ULONG_PTR ul1, ULONG_PTR ul2);
    BOOL GetHeader(LPSTR lpszName, LPVOID lpvBuffer, LPDWORD lpdwSize);
    BOOL SetHeader(LPSTR lpszName, LPSTR lpszValue);
    BOOL AddResponseHeaders(LPSTR lpszHeaders,DWORD dwReserved);


//  ASP Setup Fcns
    BOOL ExecuteASP();
    BOOL FillACB(void *p, HINSTANCE hInst);

public:
    CHttpRequest(SOCKET sock)
    {
        Init();
        m_socket = sock;
        // Fixes BUG 11771.  On a poorly formatted request line, if we didn't
        // read in the http version right we assumed it's value was 0, since 0 < 1.0
        // we'd treat this as a http/0.9 request, no headers would be sent.
        m_dwVersion = MAKELONG(0,1);
    }

    ~CHttpRequest();
    BOOL ReInit();

    void HandleRequest();
    friend DWORD WINAPI HttpConnectionThread(LPVOID lpv);

    void GenerateLog(PSTR szBuffer, DWORD_PTR *pdwToWrite);
//  BOOL SetupHeader(PSTR *ppszHeader, int *piHeader, PSTR *ppszExtra, int *piExtra, BOOL fAccessDenied);

    DWORD GetLogBufferSize();

//  ISAPI Extension / ASP Specific
    friend BOOL WINAPI GetServerVariable(HCONN hConn, PSTR psz, PVOID pv, PDWORD pdw);
    friend BOOL WINAPI ReadClient(HCONN hConn, PVOID pv, PDWORD pdw);
    friend BOOL WINAPI WriteClient(HCONN hConn, PVOID pv, PDWORD pdw, DWORD dw);
    friend BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwReq, PVOID pvBuf, PDWORD pdwSize, PDWORD pdwType);


//  ASP SPECIFIC
    friend BOOL WINAPI Flush(HCONN hConn);
    friend BOOL WINAPI Clear(HCONN hConn);
    friend BOOL WINAPI SetBuffer(HCONN hConn, BOOL fBuffer);

    friend BOOL WINAPI AddHeader (HCONN hConn, LPSTR lpszName, LPSTR lpszValue);


//  FILTER SPECIFIC
    BOOL CallFilter(DWORD dwNotifyType, PSTR *ppvBuf1 = NULL,int *pcbBuf = NULL,
                    PSTR *ppvBuf2 = NULL, int *pcbBuf2 = NULL);
    BOOL FilterNoResponse(void);

    // Filters Friends  (exposed to Filter dll)
    friend BOOL WINAPI GetServerVariable(PHTTP_FILTER_CONTEXT pfc, PSTR psz, PVOID pv, PDWORD pdw);
    friend BOOL WINAPI AddResponseHeaders(PHTTP_FILTER_CONTEXT pfc,LPSTR lpszHeaders,DWORD dwReserved);
    friend VOID* WINAPI AllocMem(PHTTP_FILTER_CONTEXT pfc, DWORD cbSize, DWORD dwReserved);
    friend BOOL WINAPI WriteClient(PHTTP_FILTER_CONTEXT pfc, PVOID pv, PDWORD pdw, DWORD dwFlags);
    friend BOOL WINAPI ServerSupportFunction(PHTTP_FILTER_CONTEXT pfc,enum SF_REQ_TYPE sfReq,
                                    PVOID pData, ULONG_PTR ul1, ULONG_PTR ul2);
    friend BOOL WINAPI SetHeader(PHTTP_FILTER_CONTEXT pfc, LPSTR lpszName, LPSTR lpszValue);
    friend BOOL WINAPI GetHeader(PHTTP_FILTER_CONTEXT pfc, LPSTR lpszName, LPVOID lpvBuffer, LPDWORD lpdwSize);
};


void SendFile(SOCKET sock, HANDLE hFile, CHttpRequest *pRequest);
// Response object. This object doesn't own any of the handles or pointers
// it uses so it doesnt free anything. The caller is responsible in all cases
// for keeping the handles & memory alive while this object is extant & freeing
// them as approp at a later time
class CHttpResponse
{
    SOCKET  m_socket;
    RESPONSESTATUS m_rs;
    CONNHEADER m_connhdr;
    PCSTR   m_pszType;
    DWORD   m_dwLength;
    PCSTR   m_pszRedirect;
    PCSTR   m_pszExtraHeaders;
    PCSTR   m_pszBody;
    HANDLE  m_hFile;
    char    m_szMime[MAXMIME];
    CHttpRequest *m_pRequest;   // calling request class, for callbacks

private:
    void SetTypeFromExtW(PCWSTR wszExt)
    {
        DEBUGCHK(!m_pszType);
        m_szMime[0] = 0;
        if(wszExt)
        {
            CReg reg(HKEY_CLASSES_ROOT, wszExt);
            MyW2A(reg.ValueSZ(L"Content Type"), m_szMime, sizeof(m_szMime));
        }
        if(m_szMime[0])
            m_pszType = m_szMime;
        else
            m_pszType = cszTextHtml;
    }
public:
    CHttpResponse(SOCKET sock, RESPONSESTATUS status, CONNHEADER connhdr, CHttpRequest *pRequest=NULL)
    {
        ZEROMEM(this);
        m_socket = sock;
        m_rs = status;
        m_connhdr = connhdr;
        m_pRequest = pRequest;
    }
    // for generated bodies (dir listings, redirects etc) & default bodies
    void SetBody(PCSTR pszBody, PCSTR pszType)
    {
        DEBUGCHK(!m_hFile && !m_pszBody && !m_pszType && !m_dwLength);
        m_pszType = pszType;
        m_dwLength = strlen(pszBody);
        m_pszBody = pszBody;
    }
    // for error reponses (NOTE: some have no body, and hence psztatusBdy will be NULL in the table)
    void SetDefaultBody()
    {
        if(rgStatus[m_rs].pszStatusBody)
            SetBody(rgStatus[m_rs].pszStatusBody, cszTextHtml);
    }
    // for real files
    void SetBody(HANDLE hFile, PCWSTR wszExt=NULL, DWORD dwLen=0)
    {
        DEBUGCHK(!m_hFile && !m_pszBody && !m_pszType && !m_dwLength);
        m_hFile = hFile;
        SetTypeFromExtW(wszExt);
        if (dwLen)
            m_dwLength = dwLen;
        else
        {
            m_dwLength = GetFileSize(m_hFile, 0);
            if (m_dwLength == 0)
                m_dwLength = -1;  // Use this to signify empty file, needed for keep-alives
        }
    }
private:
    void SendBody();
public:
    void SendHeaders(PCSTR pszExtraHeaders, PCSTR pszNewRespStatus);
    void SendRedirect(PCSTR pszRedirect, BOOL fFromFilter=FALSE);
    void SendResponse(PCSTR pszExtraHeaders=NULL, PCSTR pszNewRespStatus=NULL, BOOL fFromFilter=FALSE)
    {
        // see FilterNoResponse for comments on this
        if (!fFromFilter && m_pRequest->FilterNoResponse())
            return;


        SendHeaders(pszExtraHeaders,pszNewRespStatus);
        SendBody();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\uhinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H I N I T . H
//
//  Contents:   Initialization routines for upnphost.
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

HRESULT
HrNmCreateClassObjectRegistrationEvent (
    HANDLE* phEvent);

HRESULT
HrNmWaitForClassObjectsToBeRegistered ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\vroots.hpp ===
typedef enum
{
    AUTH_PUBLIC = 0,
    AUTH_USER   = 1,
    AUTH_ADMIN  = 2,
    AUTH_MAX    = 99
}
AUTHLEVEL;

typedef struct
{
    PWSTR wszExt;
    PWSTR wszPath;
}
EXTMAP, *PEXTMAP;

typedef struct
{
    int     iURLLen;
    PSTR    pszURL;
    int     iPathLen;
    PWSTR   wszPath;
    DWORD   dwPermissions;
    AUTHLEVEL   AuthLevel;
    SCRIPT_TYPE ScriptType;   // Does vroot physical path map to an ASP or ISAPI?
    WCHAR *wszUserList;
    BOOL    bRootDir;
    int nExtensions;
    PEXTMAP pExtMap;
}
VROOTINFO, *PVROOTINFO;

class CVRoots
{
    CRITICAL_SECTION    m_csVroot;
    int m_nVRoots;
    PVROOTINFO m_pVRoots;

    BOOL LoadExtensionMap (PVROOTINFO pvr, HKEY rootreg);
    VOID FreeExtensionMap (PVROOTINFO pvr);
    BOOL FindExtInURL (PSTR pszInputURL, PSTR *ppszStart, PSTR *ppszEnd);
    PVROOTINFO MatchVRoot(PCSTR pszInputURL, int iInputLen);
    BOOL FillVRoot(PVROOTINFO pvr, LPWSTR wszURL, LPWSTR wszPath);
    BOOL Init(VOID);
    VOID Cleanup(VOID);
    VOID Sort(VOID);

public:
    CVRoots()  { ZEROMEM(this); Init(); }
    ~CVRoots() { Cleanup(); }
    DWORD      Count()
    {
        DWORD   cVRoots;

        EnterCriticalSection(&m_csVroot);
        cVRoots = m_nVRoots;
        LeaveCriticalSection(&m_csVroot);

        return cVRoots;
    }

    BOOL AddVRoot(LPWSTR szUrl, LPWSTR szPath);
    BOOL RemoveVRoot(LPWSTR szUrl);
    PWSTR URLAtoPathW(PSTR pszInputURL, PDWORD pdwPerm=0,
                      AUTHLEVEL* pAuthLevel=0, SCRIPT_TYPE *pScriptType=0,
                      PSTR *ppszPathInfo=0, WCHAR **ppwszUserList=0);
    PWSTR MapExtToPath (PSTR pszInputURL, PSTR *ppszEndOfURL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\containermanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O N T A I N E R M A N A G E R . H
//
//  Contents:   Manages process isolation support for device host.
//
//  Notes:
//
//  Author:     mbend   11 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "hostp.h"
#include "UString.h"
#include "Table.h"
#include "RegDef.h"

// Typedefs

struct ContainerInfo
{
    IUPnPContainerPtr m_pContainer;
    long m_nRefs;
};

inline void TypeTransfer(ContainerInfo & dst, ContainerInfo & src)
{
    dst.m_pContainer.Swap(src.m_pContainer);
    dst.m_nRefs = src.m_nRefs;
}
inline void TypeClear(ContainerInfo & type)
{
    type.m_pContainer.Release();
}

/////////////////////////////////////////////////////////////////////////////
// CContainerManager
class ATL_NO_VTABLE CContainerManager :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CContainerManager, &CLSID_UPnPContainerManager>,
    public IUPnPContainerManager
{
public:
    CContainerManager();
    ~CContainerManager();

DECLARE_CLASSFACTORY_SINGLETON(CContainerManager)
DECLARE_REGISTRY_RESOURCEID(IDR_CONTAINER_MANAGER)
DECLARE_NOT_AGGREGATABLE(CContainerManager)

BEGIN_COM_MAP(CContainerManager)
    COM_INTERFACE_ENTRY(IUPnPContainerManager)
END_COM_MAP()

public:
    // IUPnPContainerManager methods
    STDMETHOD(ReferenceContainer)(
        /*[in, string]*/ const wchar_t * szContainer);
    STDMETHOD(UnreferenceContainer)(
        /*[in, string]*/ const wchar_t * szContainer);
    STDMETHOD(CreateInstance)(
        /*[in, string]*/ const wchar_t * szContainer,
        /*[in]*/ REFCLSID clsid,
        /*[in]*/ REFIID riid,
        /*[out, iid_is(riid)]*/ void ** ppv);
    STDMETHOD(CreateInstanceWithProgId)(
        /*[in, string]*/ const wchar_t * szContainer,
        /*[in, string]*/ const wchar_t * szProgId,
        /*[in]*/ REFIID riid,
        /*[out, iid_is(riid)]*/ void ** ppv);
    STDMETHOD(Shutdown)();

private:
    typedef CTable<CUString, ContainerInfo> ContainerTable;

    ContainerTable m_containerTable;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\uhutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H U T I L . H
//
//  Contents:   Common routines and constants for UPnP Device Host
//
//  Notes:
//
//  Author:     mbend   6 Sep 2000
//
//----------------------------------------------------------------------------

#include "UString.h"
#include "uhcommon.h"

// Registry locations
extern const wchar_t c_szRegistryMicrosoft[];
extern const wchar_t c_szUPnPDeviceHost[];
extern const wchar_t c_szMicrosoft[];

HRESULT HrRegQueryString(HKEY hKey, const wchar_t * szValueName, CUString & str);
HRESULT HrCreateOrOpenDeviceHostKey(HKEY * phKeyDeviceHost);
HRESULT HrCreateAndReferenceContainedObject(
    const wchar_t * szContainer,
    REFCLSID clsid,
    REFIID riid,
    void ** ppv);
HRESULT HrCreateAndReferenceContainedObjectByProgId(
    const wchar_t * szContainer,
    const wchar_t * szProgId,
    REFIID riid,
    void ** ppv);
HRESULT HrDereferenceContainer(
    const wchar_t * szContainer);
HRESULT HrPhysicalDeviceIdentifierToString(const GUID & pdi, CUString & str);
HRESULT HrStringToPhysicalDeviceIdentifier(const wchar_t * szStrPdi, GUID & pdi);
HRESULT HrGUIDToUDNString(const UUID & uuid, CUString & strUUID);
HRESULT HrMakeFullPath(
    const wchar_t * szPath,
    const wchar_t * szFile,
    CUString & strFullPath);
HRESULT HrEnsurePathBackslash(CUString & strPath);
HRESULT HrAddDirectoryToPath(CUString & strPath, const wchar_t * szDir);
HRESULT HrGetUPnPHostPath(CUString & strPath);
HRESULT HrMakeIsapiExtensionDirectory();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\winioctl.h ===
/* 
 * Copyright (c) 1990-2000 Microsoft Corporation.  All rights reserved.
 * Module Name: winioctl.h
 * Abstract: this module defines device IO control codes.
*/

#ifndef _WINIOCTL_
#define _WINIOCTL_

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//

#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe


//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036

//
// Windows CE Specific Defines
//
#define FILE_DEVICE_HAL					0x00000101
#define FILE_DEVICE_CONSOLE             0x00000102
#define FILE_DEVICE_PSL					0x00000103
#define FILE_DEVICE_SERVICE				0x00000104

#endif	// _WINIOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\containermanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O N T A I N E R M A N A G E R . C P P
//
//  Contents:   Manages process isolation support for device host.
//
//  Notes:
//
//  Author:     mbend   11 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "hostp.h"
#include "ContainerManager.h"
#include "uhsync.h"
#include "ComUtility.h"
#include "msftcont.h"
#include "uhcommon.h"

CContainerManager::CContainerManager()
{
}

CContainerManager::~CContainerManager()
{
}

STDMETHODIMP CContainerManager::ReferenceContainer(
    /*[in, string]*/ const wchar_t * szContainer)
{
    CALock lock(*this);
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        // Ignore special container
        if(!lstrcmp(c_szUPnPDeviceHostContainer, szContainer))
        {
            return S_OK;
        }
        
        CUString strContainer;
        hr = strContainer.HrAssign(szContainer);
        if(SUCCEEDED(hr))
        {
            ContainerInfo * pContainerInfo = NULL;
            hr = m_containerTable.HrLookup(strContainer, &pContainerInfo);
            if(SUCCEEDED(hr))
            {
                ++pContainerInfo->m_nRefs;
            }
            else
            {
                hr = S_OK;
                ContainerInfo containerInfo;
                containerInfo.m_nRefs = 1;
                hr = containerInfo.m_pContainer.HrCreateInstanceLocal(CLSID_UPnPContainer);
                if(SUCCEEDED(hr))
                {
                    hr = m_containerTable.HrInsertTransfer(strContainer, containerInfo);
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CContainerManager::ReferenceContainer");
    return hr;
}

STDMETHODIMP CContainerManager::UnreferenceContainer(
    /*[in, string]*/ const wchar_t * szContainer)
{
    CALock lock(*this);
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        // Ignore special container
        if(!lstrcmp(c_szUPnPDeviceHostContainer, szContainer))
        {
            return S_OK;
        }
        
        CUString strContainer;
        hr = strContainer.HrAssign(szContainer);
        if(SUCCEEDED(hr))
        {
            ContainerInfo * pContainerInfo = NULL;
            hr = m_containerTable.HrLookup(strContainer, &pContainerInfo);
            if(SUCCEEDED(hr))
            {
                --pContainerInfo->m_nRefs;
                if(!pContainerInfo->m_nRefs)
                {
                    // No one is using
                    hr = pContainerInfo->m_pContainer->Shutdown();
                    pContainerInfo->m_pContainer.Release();
                    if(SUCCEEDED(hr))
                    {
                        hr = m_containerTable.HrErase(strContainer);
                    }
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CContainerManager::UnreferenceContainer");
    return hr;
}

STDMETHODIMP CContainerManager::CreateInstance(
    /*[in, string]*/ const wchar_t * szContainer,
    /*[in]*/ REFCLSID clsid,
    /*[in]*/ REFIID riid,
    /*[out, iid_is(riid)]*/ void ** ppv)
{
    CHECK_POINTER(szContainer);
    CHECK_POINTER(ppv);
    CALock lock(*this);
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        // Create inproc for special container
        if(!lstrcmp(c_szUPnPDeviceHostContainer, szContainer))
        {
            hr = HrCoCreateInstanceInprocBase(clsid, riid, ppv);
        }
        else
        {
            CUString strContainer;
            hr = strContainer.HrAssign(szContainer);
            if(SUCCEEDED(hr))
            {
                ContainerInfo * pContainerInfo = NULL;
                hr = m_containerTable.HrLookup(strContainer, &pContainerInfo);
                if(SUCCEEDED(hr))
                {
                    hr = pContainerInfo->m_pContainer->CreateInstance(clsid, riid, ppv);
                    if (SUCCEEDED(hr))
                    {
                        hr = pContainerInfo->m_pContainer->SetParent(GetCurrentProcessId());
                    }
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CContainerManager::CreateInstance");
    return hr;
}

STDMETHODIMP CContainerManager::CreateInstanceWithProgId(
    /*[in, string]*/ const wchar_t * szContainer,
    /*[in, string]*/ const wchar_t * szProgId,
    /*[in]*/ REFIID riid,
    /*[out, iid_is(riid)]*/ void ** ppv)
{
    CALock lock(*this);
    HRESULT hr = S_OK;
    CLSID clsid;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        hr = CLSIDFromProgID(szProgId, &clsid);
        if(SUCCEEDED(hr))
        {
            hr = CreateInstance(szContainer, clsid, riid, ppv);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CContainerManager::CreateInstanceWithProgId");
    return hr;
}

STDMETHODIMP CContainerManager::Shutdown()
{
    CALock lock(*this);
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        long nCount = m_containerTable.Values().GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            m_containerTable.Values()[n].m_pContainer->Shutdown();
            const_cast<IUPnPContainerPtr&>(m_containerTable.Values()[n].m_pContainer).Release();
        }
        m_containerTable.Clear();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CContainerManager::Shutdown");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\inc\uhres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H R E S . H
//
//  Contents:   Master resource header for upnphost.dll
//
//  Notes:
//
//  Author:     mbend   8 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
#define IDS_EMPTY_NODE_NOT_PRESENT                  200
#define IDS_NON_EMPTY_NODE_NOT_PRESENT              201
#define IDS_SERVICE_MISSING                         202
#define IDS_DUPLICATES_NOT_ALLOWED                  203
#define IDS_ROOT_DEVICE_MISSING                     204
#define IDS_INVALID_XML                             205
#define IDS_INVALID_ICON                            206
#define IDS_INVALID_ROOT_NAMESPACE                  207
#define IDS_SUFFIX_TOO_LONG                         208
#define IDS_URLBASE_PRESENT                         209
#define IDS_ELEMENT_VALUE_TOO_LONG                  210
#define IDS_ICON_MISSING                            211
#define IDS_DEVICE_MISSING                          212

//+---------------------------------------------------------------------------
// Reigstry resources
//

// Upnphost application
//
#define IDR_UPNPHOST                    100
#define IDR_DYNAMIC_CONTENT_SOURCE      101
#define IDR_DESCRIPTION_MANAGER         102
#define IDR_DEVICE_PERSISTENCE_MANAGER  103
#define IDR_CONTAINER_MANAGER           104
#define IDR_REGISTRAR                   105
#define IDR_AUTOMATION_PROXY            106
#define IDR_EVENTING_MANAGER            107
#define IDR_VALIDATION_MANAGER          109


//
// UDHHTTP resources
//

#define IDS_LINKTOPARENTDIR             5


#define RESBASE_body                    500

// The offsets need to match the enum RESPONSESTATUS.  These correspond to HTTP response codes.
#define IDS_MOVED                       (RESBASE_body + 1)
#define IDS_BADREQ                      (RESBASE_body + 3)
#define IDS_UNAUTHORIZED                (RESBASE_body + 4)
#define IDS_FORBIDDEN                   (RESBASE_body + 5)
#define IDS_NOTFOUND                    (RESBASE_body + 6)
#define IDS_INTERNALERR                 (RESBASE_body + 7)
#define IDS_NOTIMPLEM                   (RESBASE_body + 8)
#define IDS_NOTSUPP                     (RESBASE_body + 9)


// Misc Codes.
#define IDS_SERVER_BUSY                 30


// Codes that are not part of HTTP, but are generated by the web server for log.
#define IDS_HTTPD_STARTUP             50
#define IDS_HTTPD_SHUTDOWN_START      51
#define IDS_HTTPD_EXCEPTION           52
#define IDS_HTTPD_FILT_EXCEPTION      53
#define IDS_HTTPD_EXT_EXCEPTION       54
#define IDS_HTTPD_NO_REGKEY           55
#define IDS_HTTPD_DISABLED            56
#define IDS_HTTPD_SHUTDOWN_COMPLETE   57
#define IDS_HTTPD_NO_VROOTS           58
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\descriptionmanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E S C R I P T I O N M A N A G E R . H
//
//  Contents:   Process UPnP Description document
//
//  Notes:
//
//  Author:     mbend   18 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "ComUtility.h"
#include "Array.h"
#include "hostp.h"
#include "Table.h"
#include "UString.h"
#include "RegDef.h"
#include "uhsync.h"
#include "uhxml.h"

// Forward declarations
struct _SSDP_MESSAGE;
typedef _SSDP_MESSAGE SSDP_MESSAGE;

// Must define these here to satisfy data structure requirements
typedef CUString Filename;
typedef CUString Mimetype;
struct FileInfo
{
    Filename m_filename;
    Mimetype m_mimetype;
};
inline HRESULT HrTypeAssign(FileInfo & dst, const FileInfo & src)
{
    HRESULT hr = S_OK;
    hr = HrTypeAssign(dst.m_filename, src.m_filename);
    if(SUCCEEDED(hr))
    {
        hr = HrTypeAssign(dst.m_mimetype, src.m_mimetype);
    }
    return hr;
}
inline void TypeTransfer(FileInfo & dst, FileInfo & src)
{
    TypeTransfer(dst.m_filename, src.m_filename);
    TypeTransfer(dst.m_mimetype, src.m_mimetype);
}
inline void TypeClear(FileInfo & type)
{
    TypeClear(type.m_filename);
    TypeClear(type.m_mimetype);
}
typedef CTable<UDN, UDN> UDNReplacementTable;
// Not implemented - should not use
// inline HRESULT HrTypeAssign(UDNReplacementTable & dst, const UDNReplacementTable & src)
inline void TypeTransfer(UDNReplacementTable & dst, UDNReplacementTable & src)
{
    dst.Swap(src);
}
inline void TypeClear(UDNReplacementTable & type)
{
    type.Clear();
}
typedef CTable<PhysicalDeviceIdentifier, UDNReplacementTable> ReplacementTable;

/////////////////////////////////////////////////////////////////////////////
// TestObject
class ATL_NO_VTABLE CDescriptionManager :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CDescriptionManager, &CLSID_UPnPDescriptionManager>,
    public IUPnPDescriptionManager,
    public IUPnPDynamicContentProvider
{
public:
    CDescriptionManager();
    ~CDescriptionManager();

DECLARE_REGISTRY_RESOURCEID(IDR_DESCRIPTION_MANAGER)
DECLARE_NOT_AGGREGATABLE(CDescriptionManager)

BEGIN_COM_MAP(CDescriptionManager)
    COM_INTERFACE_ENTRY(IUPnPDescriptionManager)
    COM_INTERFACE_ENTRY(IUPnPDynamicContentProvider)
END_COM_MAP()

public:
    // IUPnPDescriptionManager methods
    STDMETHOD(GetContent)(
        /*[in]*/ REFGUID guidContent,
        /*[out]*/ long * pnHeaderCount,
        /*[out, string, size_is(,*pnHeaderCount)]*/ wchar_t *** arszHeaders,
        /*[out]*/ long * pnBytes,
        /*[out, size_is(,*pnBytes)]*/ byte ** parBytes);

    // IUPnPDynamicContentProvider methods
    STDMETHOD(ProcessDescriptionTemplate)(
        /*[in]*/ BSTR bstrTemplate,
        /*[in, string]*/ const wchar_t * szResourcePath,
        /*[in, out]*/ GUID * pguidPhysicalDeviceIdentifier,
        /*[in]*/ BOOL bPersist,
        /*[in]*/ BOOL bReregister);
    STDMETHOD(PublishDescription)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[in]*/ long nLifeTime);
    STDMETHOD(LoadDescription)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier);
    STDMETHOD(RemoveDescription)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[in]*/ BOOL bPermanent);
    STDMETHOD(GetDescriptionText)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[out]*/ BSTR * pbstrDescriptionDocument);
    STDMETHOD(GetUDNs)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[out]*/ long * pnUDNCount,
        /*[out, size_is(,*pnUDNCount,), string]*/
            wchar_t *** parszUDNs);
    STDMETHOD(GetUniqueDeviceName)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[in, string]*/ const wchar_t * szTemplateUDN,
        /*[out, string]*/ wchar_t ** pszUDN);
    STDMETHOD(GetSCPDText)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[in, string]*/ const wchar_t * szUDN,
        /*[in, string]*/ const wchar_t * szServiceId,
        /*[out, string]*/ wchar_t ** pszSCPDText,
        /*[out, string]*/ wchar_t ** pszServiceType);
private:
    typedef BSTR DescriptionDocument;
    typedef CTable<PhysicalDeviceIdentifier, DescriptionDocument> DocumentTable;
    typedef GUID FileId;
    typedef CTable<FileId, FileInfo> FileTable;
    struct CleanupItem
    {
        PhysicalDeviceIdentifier m_physicalDeviceIdentifier;
        FileId m_fileId;
    };
    typedef CUArray<CleanupItem> CleanupList;
    typedef CUArray<HANDLE> HandleList;
    typedef CTable<PhysicalDeviceIdentifier, HandleList *> SSDPRegistrationTable;

    DocumentTable m_documentTable;
    FileTable m_fileTable;
    CleanupList m_cleanupList;
    CUCriticalSection m_critSecReplacementTable;
    ReplacementTable m_replacementTable;
    SSDPRegistrationTable m_ssdpRegistrationTable;

    // Internal helper routines
    HRESULT HrPersistDeviceSettingsToRegistry(
        const PhysicalDeviceIdentifier & physicalDeviceIdentifier,
        const UDNReplacementTable & udnReplacementTable,
        const FileTable & fileTable,
        BOOL bPersist);
    HRESULT HrLoadDocumentAndRootNode(
        const PhysicalDeviceIdentifier & physicalDeviceIdentifier,
        IXMLDOMNodePtr & pRootNode);

    // (PDT) Process Device Template helper functions
    HRESULT HrPDT_FetchCollections(
        BSTR bstrTemplate,
        IXMLDOMDocumentPtr & pDoc,
        IXMLDOMNodePtr & pRootNode,
        CUString & strRootUdnOld,
        IXMLDOMNodeListPtr & pNodeListDevices,
        IXMLDOMNodeListPtr & pNodeListUDNs,
        IXMLDOMNodeListPtr & pNodeListSCPDURLs,
        IXMLDOMNodeListPtr & pNodeListIcons);
    HRESULT HrPDT_DoUDNToUDNMapping(
        IXMLDOMNodeListPtr & pNodeListUDNs,
        UDNReplacementTable & udnReplacementTable);
    HRESULT HrPDT_ReregisterUDNsInDescriptionDocument(
        UDNReplacementTable & udnReplacementTable,
        IXMLDOMNodeListPtr & pNodeListUDNs);
    HRESULT HrPDT_FetchPhysicalIdentifier(
        UDNReplacementTable & udnReplacementTable,
        const CUString & strRootUdnOld,
        PhysicalDeviceIdentifier & pdi);
    HRESULT HrPDT_ReplaceSCPDURLs(
        IXMLDOMNodeListPtr & pNodeListSCPDURLs,
        const wchar_t * szResourcePath,
        FileTable & fileTable);
    HRESULT HrPDT_ReplaceIcons(
        IXMLDOMNodeListPtr & pNodeListIcons,
        const wchar_t * szResourcePath,
        FileTable & fileTable);
    HRESULT HrPDT_ReplaceControlAndEventURLs(
        IXMLDOMNodeListPtr & pNodeListDevices);
    HRESULT HrPDT_PersistDescriptionDocument(
        const PhysicalDeviceIdentifier & pdi,
        IXMLDOMDocumentPtr & pDoc);
    // presentation specific functions
    HRESULT HrPDT_ProcessPresentationURLs(
        REFGUID guidPhysicalDeviceIdentifier,
        IXMLDOMNodeListPtr & pNodeListDevices,
        BOOL *fIsPresURLTagPresent);

   // (PD) Publish Description helper functions
    HRESULT HrPD_DoRootNotification(
        IXMLDOMNodePtr & pNodeRootDevice,
        SSDP_MESSAGE * pMsg,
        HandleList * pHandleList);
    HRESULT HrPD_DoDevicePublication(
        IXMLDOMNodeListPtr & pNodeListDevices,
        SSDP_MESSAGE * pMsg,
        HandleList * pHandleList);
    HRESULT HrPD_DoServicePublication(
        IXMLDOMNodePtr & pNodeDevice,
        const CUString & strUDN,
        SSDP_MESSAGE * pMsg,
        HandleList * pHandleList);

    // (LD) Load Description helper functions
    HRESULT HrLD_ReadUDNMappings(
        HKEY hKeyPdi,
        UDNReplacementTable & udnReplacementTable);
    HRESULT HrLD_ReadFileMappings(
        HKEY hKeyPdi,
        FileTable & fileTable);
    HRESULT HrLD_LoadDescriptionDocumentFromDisk(
        const PhysicalDeviceIdentifier & pdi,
        IXMLDOMDocumentPtr & pDoc);
    HRESULT HrLD_SaveDescriptionDocumentText(
        IXMLDOMDocumentPtr & pDoc,
        const PhysicalDeviceIdentifier & pdi);

    // (RD) Remove Description helper functions
    HRESULT HrRD_RemoveFromEventing(const PhysicalDeviceIdentifier & pdi);
    HRESULT HrRD_RemoveFromDataStructures(const PhysicalDeviceIdentifier & pdi);
    HRESULT HrRD_CleanupPublication(const PhysicalDeviceIdentifier & pdi);
};

HRESULT HrCreateOrOpenDescriptionKey(
    HKEY * phKeyDescription);
HRESULT HrOpenPhysicalDeviceDescriptionKey(
    const UUID & pdi,
    HKEY * phKeyPdi);
HRESULT HrGetDescriptionDocumentPath(
    const UUID & pdi,
    CUString & strPath);
HRESULT HrRegisterServiceWithEventing(
    IXMLDOMNodePtr & pNodeService,
    const CUString & strUDN,
    BOOL bRegister);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\descriptionmanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E S C R I P T I O N M A N A G E R . C P P
//
//  Contents:   Process UPnP Description document
//
//  Notes:
//
//  Author:     mbend   18 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <msxml2.h>

#include "uhbase.h"
#include "hostp.h"
#include "DescriptionManager.h"
#include "uhsync.h"
#include "upfile.h"
#include "ncreg.h"
#include "ssdpapi.h"
#include "evtapi.h"
#include "uhutil.h"
#include "udhhttp.h"  // remove this if you are moving the function for presentation virtual directory.
#include "ncxml.h"
#include "ssdpapi.h"
#include "uhcommon.h"

// String constants
const wchar_t c_szDescription[] = L"Description";
const wchar_t c_szUDNMappings[] = L"UDN Mappings";
const wchar_t c_szFiles[] = L"Files";
const wchar_t c_szFilename[] = L"Filename";
const wchar_t c_szMimetype[] = L"Mimetype";
const wchar_t c_szDescriptionDocuments[] = L"Description Documents";
const wchar_t c_szRemoveId[] = L"REMOVE";

CDescriptionManager::CDescriptionManager ()
{
}

CDescriptionManager::~CDescriptionManager ()
{
    // Free description documents
    BSTR bstr = NULL;
    long n;
    long nCount = m_documentTable.Values().GetCount();
    for(n = 0; n < nCount; ++n)
    {
        bstr = const_cast<BSTR>(m_documentTable.Values()[n]);
        SysFreeString(bstr);
    }
    m_documentTable.Clear();

    // Unpublish and free the arrays for all publications
    HandleList * pHandleList = NULL;
    nCount = m_ssdpRegistrationTable.Values().GetCount();
    for(n = 0; n < nCount; ++n)
    {
        pHandleList = const_cast<HandleList*>(m_ssdpRegistrationTable.Values()[n]);
        if(pHandleList)
        {
            long nHandleLists = pHandleList->GetCount();
            for(long n = 0; n < nHandleLists; ++n)
            {
                DeregisterService((*pHandleList)[n], TRUE);
            }
            delete pHandleList;
        }
    }
    m_ssdpRegistrationTable.Clear();
}

STDMETHODIMP CDescriptionManager::GetContent(
    /*[in]*/ REFGUID guidContent,
    /*[out]*/ long * pnHeaderCount,
    /*[out, string, size_is(,*pnHeaderCount,)]*/ wchar_t *** parszHeaders,
    /*[out]*/ long * pnBytes,
    /*[out, size_is(,*pnBytes)]*/ byte ** parBytes)
{
    CALock lock(*this);
    HRESULT hr = S_OK;
    wchar_t ** arszHeaders = NULL;
    long nHeaderCount = 2;
    long nBytes = 0;
    byte * arBytes = NULL;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        // Allocate the header array
        hr = HrCoTaskMemAllocArray(2, &arszHeaders);
    }

    // Other header variables, filled in body and copied to [out]
    // or cleaned up up at end of function

    if(SUCCEEDED(hr))
    {
        // Set header initially to NULL;
        arszHeaders[0] = NULL;
        arszHeaders[1] = NULL;
        // See if it is a description document
        BSTR * pbstr = m_documentTable.Lookup(guidContent);
        if(pbstr)
        {
            // This GUID is a description document

            // Allocate the content-type
            hr = HrCoTaskMemAllocString(L"content-type: text/xml", arszHeaders);
            if(SUCCEEDED(hr))
            {
                // Copy the document as ansi
                // nLength is the number of (wide)chars in the source
                // dSpace is the space reserved for the UTF-8 destination

                long nLength = SysStringLen(*pbstr);
                int dSpace = WideCharToMultiByte(CP_UTF8, 0, *pbstr, nLength, NULL, 0, NULL, NULL) + 1; // add 1 for NULL

                char * szBody = NULL;
                hr = HrCoTaskMemAllocArray(dSpace, &szBody);
                if(SUCCEEDED(hr))
                {
                    if(!WideCharToMultiByte(CP_UTF8, 0, *pbstr, nLength, szBody, dSpace, NULL, NULL))
                    {
                        hr = HrFromLastWin32Error();
                    }
                    if(SUCCEEDED(hr))
                    {
                        arBytes = reinterpret_cast<byte*>(szBody);
                        nBytes = dSpace-1; // number of bytes less the terminating nul
                        arBytes[nBytes] = 0; // add NULL terminator
                    }
                    if(FAILED(hr))
                    {
                        CoTaskMemFree(szBody);
                        szBody = NULL;
                    }
                }
            }
        }
        else
        {
            // See if it is in the file table
            FileInfo * pFileInfo = m_fileTable.Lookup(guidContent);
            if(pFileInfo)
            {
                // Allocate the content type
                CUString strContentType;
                hr = strContentType.HrAssign(L"content-type:");
                if(SUCCEEDED(hr))
                {
                    hr = strContentType.HrAppend(pFileInfo->m_mimetype);
                    if(SUCCEEDED(hr))
                    {
                        hr = strContentType.HrGetCOM(arszHeaders);
                        if(SUCCEEDED(hr))
                        {
                            // Load the file from disk
                            hr = HrLoadFileFromDisk(pFileInfo->m_filename, &nBytes, &arBytes);
                        }
                    }
                }
            }
            else
            {
                // This provider didn't process it
                hr = S_FALSE;
            }
        }

        if(S_OK == hr)
        {
            wchar_t szBuf[128];
            wsprintf(szBuf, L"content-length: %d", nBytes);
            hr = HrCoTaskMemAllocString(szBuf, &arszHeaders[1]);
        }

        if(FAILED(hr) || S_FALSE == hr)
        {
            // Centralized cleanup code

            if(arszHeaders)
            {
                if(*arszHeaders)
                {
                    // Free header (at most one)
                    CoTaskMemFree(*arszHeaders);
                }
                if(arszHeaders[1])
                {
                    CoTaskMemFree(arszHeaders[1]);
                }
                // Free length one header array
                CoTaskMemFree(arszHeaders);
            }
            if(arBytes)
            {
                // Free body bytes
                CoTaskMemFree(arBytes);
            }
            // Blank out the output params
            *pnHeaderCount = 0;
            *parszHeaders = NULL;
            *pnBytes = 0;
            *parBytes = NULL;
        }
    }
    if(S_OK == hr)
    {
        // Copy to output parameters
        *pnHeaderCount = nHeaderCount;
        *parszHeaders = arszHeaders;
        *pnBytes = nBytes;
        *parBytes = arBytes;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::GetContent");
    return hr;
}

HRESULT HrNewUDNString(CUString & strUUID)
{
    UUID uuid;
    HRESULT hr = S_OK;

    hr = CoCreateGuid(&uuid);
    if(SUCCEEDED(hr))
    {
        hr = HrGUIDToUDNString(uuid, strUUID);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrNewUDNString");
    return hr;
}

HRESULT HrGetURLBase(CUString & strURLBase)
{
    HRESULT hr = S_OK;

    hr = strURLBase.HrAssign(L"http://");
    if(SUCCEEDED(hr))
    {
        hr = strURLBase.HrAppend(c_szReplaceGuid);
        if(SUCCEEDED(hr))
        {
            hr = strURLBase.HrAppend(L":2869/upnphost/");
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetURLBase");
    return hr;
}

HRESULT HrGetContentURL(const UUID & uuid, CUString & strURL)
{
    HRESULT hr = S_OK;

    hr = strURL.HrAssign(L"udhisapi.dll?content=");
    if(SUCCEEDED(hr))
    {
        CUString strUUID;
        hr = HrGUIDToUDNString(uuid, strUUID);
        if(SUCCEEDED(hr))
        {
            hr = strURL.HrAppend(strUUID);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetContentURL");
    return hr;
}

// Create Virual directory using the Physical Device Identifier and map it to the resource path
HRESULT HrCreatePresentationVirtualDir(const UUID &uuid, const LPWSTR szResourcePath)
{
    HRESULT hr = S_OK;

    CUString    strUUID;
    BSTR        bstrVirDir;

    hr = HrGUIDToUDNString(uuid, strUUID);
    if(SUCCEEDED(hr))
    {
        CUString strTmp;
        hr = strTmp.HrAssign(L"/");
        if (SUCCEEDED(hr))
        {
            hr = strTmp.HrAppend(strUUID);
            if (SUCCEEDED(hr))
            {
                hr = strTmp.HrGetBSTR(&bstrVirDir);
                if(SUCCEEDED(hr))
                {
                    HrRemoveVroot(bstrVirDir);
                    hr = HrAddVroot(bstrVirDir,szResourcePath);

                    SysFreeString(bstrVirDir);
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreatePresentationVirtualDir");
    return hr;
}

// Remove the virtual directory
HRESULT HrRemovePresentationVirtualDir(const UUID &uuid )
{
    HRESULT hr = S_OK;
    CUString strUUID;
    BSTR bstrVirDir ;
    CUString strTmp;

    hr = strTmp.HrAssign(L"/");
    if(SUCCEEDED(hr))
    {
        hr = HrGUIDToUDNString(uuid, strUUID);
        if(SUCCEEDED(hr))
        {
            hr = strTmp.HrAppend(strUUID);
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = strTmp.HrGetBSTR(&bstrVirDir);
        if(SUCCEEDED(hr))
        {
            hr = HrRemoveVroot(bstrVirDir);
            SysFreeString(bstrVirDir);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrRemovePresentationVirtualDir");
    return hr;
}

// prepare base URL for the presentation URL
HRESULT HrGetPresentationBaseURL(const UUID &uuid, CUString &strPresentationBaseURL)
{
    HRESULT hr = S_OK;

    if(SUCCEEDED(hr))
    {
        CUString strUUID;
        hr = strPresentationBaseURL.HrAppend(L"/");
        if (SUCCEEDED(hr))
        {
            hr = HrGUIDToUDNString(uuid, strUUID);
            if(SUCCEEDED(hr))
            {
                hr = strPresentationBaseURL.HrAppend(strUUID);
                if(SUCCEEDED(hr))
                {
                    hr = strPresentationBaseURL.HrAppend(L"/");
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetPresentationBaseURL");
    return hr;
}

HRESULT HrGenerateControlAndEventURLs(
    IXMLDOMNodePtr & pNodeDevice)
{
    HRESULT hr = S_OK;

    CUString strControlURLBase;
    CUString strEventURLBase;
    CUString strUDN;

    hr = strControlURLBase.HrAssign(L"udhisapi.dll?control=");
    if(SUCCEEDED(hr))
    {
        hr = strEventURLBase.HrAssign(L"udhisapi.dll?event=");
    }
    if(SUCCEEDED(hr))
    {
        // Fetch the UDN
        hr = HrSelectNodeText(L"UDN", pNodeDevice, strUDN);
    }

    // Get all of the services
    IXMLDOMNodeListPtr pNodeListServices;
    if(SUCCEEDED(hr))
    {
        hr = HrSelectNodes(L"serviceList/service", pNodeDevice, pNodeListServices);
        if(SUCCEEDED(hr))
        {
            while(SUCCEEDED(hr))
            {
                IXMLDOMNodePtr pNodeService;
                // Process each service
                HRESULT hrTmp = S_OK;
                hrTmp = pNodeListServices->nextNode(pNodeService.AddressOf());
                if(S_OK != hrTmp)
                {
                    break;
                }
                CUString strSid;
                hr = HrSelectNodeText(L"serviceId", pNodeService, strSid);
                if(SUCCEEDED(hr))
                {
                    // Generate the URL suffix
                    CUString strURL;
                    hr = strURL.HrAssign(strUDN);
                    if(SUCCEEDED(hr))
                    {
                        hr = strURL.HrAppend(L"+");
                        if(SUCCEEDED(hr))
                        {
                            hr = strURL.HrAppend(strSid);

                        }
                    }
                    CUString strControlURL;
                    CUString strEventURL;
                    // Build the real URLs
                    if(SUCCEEDED(hr))
                    {
                        hr = strControlURL.HrAssign(strControlURLBase);
                        if(SUCCEEDED(hr))
                        {
                            hr = strControlURL.HrAppend(strURL);
                            if(SUCCEEDED(hr))
                            {
                                hr = strEventURL.HrAssign(strEventURLBase);
                                if(SUCCEEDED(hr))
                                {
                                    hr = strEventURL.HrAppend(strURL);
                                }
                            }
                        }
                    }
                    // Now replace them in the document
                    if(SUCCEEDED(hr))
                    {
                        CUString    strNode;

                        hr = strNode.HrAssign(L"/upnphost/");
                        if (SUCCEEDED(hr))
                        {
                            hr = strNode.HrAppend(strControlURL);
                            if (SUCCEEDED(hr))
                            {
                                hr = HrSelectAndSetNodeText(L"controlURL",
                                                            pNodeService,
                                                            strNode);
                            }
                        }
                    }

                    CUString    strOldText;

                    hr = HrSelectNodeText(L"eventSubURL", pNodeService,
                                          strOldText);
                    if (SUCCEEDED(hr))
                    {
                        CUString    strNode;

                        // Only replace the URL if it doesn't have the remove
                        // identifier in it. Otherwise, remove the identifier
                        //
                        if (lstrcmpi(strOldText, c_szRemoveId))
                        {
                            hr = strNode.HrAssign(L"/upnphost/");
                            if (SUCCEEDED(hr))
                            {
                                hr = strNode.HrAppend(strEventURL);
                                if (SUCCEEDED(hr))
                                {
                                    hr = HrSelectAndSetNodeText(L"eventSubURL",
                                                                pNodeService,
                                                                strNode);
                                }
                            }
                        }
                        else
                        {
                            CUString    strEmpty;

                            hr = strEmpty.HrAssign(L"");
                            if (SUCCEEDED(hr))
                            {
                                hr = HrSelectAndSetNodeText(L"eventSubURL",
                                                            pNodeService, strEmpty);
                            }
                        }
                    }
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGenerateControlAndEventURLs");
    return hr;
}

HRESULT HrGenDescAndUDNURLForPresentation(
    REFGUID guidPhysicalDeviceIdentifier,
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strDescAndUDNURL)
{
    HRESULT hr = S_OK ;
    CUString strDesc ;
    CUString strUDN ;

    hr = HrGetContentURL(guidPhysicalDeviceIdentifier, strDesc);
    if(SUCCEEDED(hr))
    {
        hr = strDescAndUDNURL.HrAssign(L"/upnphost/");
        if(SUCCEEDED(hr))
        {
            hr = strDescAndUDNURL.HrAppend(strDesc);
        }
    }
    if(SUCCEEDED(hr))
    {
        hr = strDescAndUDNURL.HrAppend(L"+");
        if(SUCCEEDED(hr))
        {
            hr = HrSelectNodeText(L"UDN", pNodeDevice, strUDN);
            if(SUCCEEDED(hr))
            {
                hr = strDescAndUDNURL.HrAppend(strUDN);
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGenDescAndUDNURLForPresentation");
    return hr;
}

BOOL IsAbsoluteURL(BSTR bstrPresURL)
{
    HRESULT hr = S_OK;
    const WCHAR c_szhttp[] = L"http://";
    const DWORD c_chhttp = celems(c_szhttp)-1;

    // include other conditions for absolute URL like https:// etc.
    if(wcsncmp(bstrPresURL,c_szhttp,c_chhttp) == 0 )
        return true;
    else
        return false;
}

HRESULT HrGenPresentationURL(
    REFGUID guidPhysicalDeviceIdentifier,
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strPresFileName,
    CUString & strPresentationURL)
{
    HRESULT hr = S_OK;
    CUString strDescURL ;

    hr = HrGetPresentationBaseURL(guidPhysicalDeviceIdentifier,strPresentationURL);
    if(SUCCEEDED(hr))
    {
        hr = strPresentationURL.HrAppend(strPresFileName);
        if(SUCCEEDED(hr))
        {
            hr = strPresentationURL.HrAppend(L"?");
            if(SUCCEEDED(hr))
            {
                hr = HrGenDescAndUDNURLForPresentation(guidPhysicalDeviceIdentifier,pNodeDevice,strDescURL);
                if(SUCCEEDED(hr))
                {
                    hr = strPresentationURL.HrAppend(strDescURL);
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGenPresentationURL");
    return hr;
}


// Replaces the presentation URL for a device. If presentationURL element has absolute address no change is made.
// File name to the main presentation page is expected, can be without presentation page
HRESULT HrReplacePresentationURL(
    REFGUID guidPhysicalDeviceIdentifier,
    IXMLDOMNodePtr & pNodeDevice,
    BOOL *fIsPresURLTagPresent)
{

    HRESULT hr = S_OK;
    CUString strPresentationURL;
    CUString strPresFileName ;
    CUString strUDN;
    CUString strUrl;
    CUString strDescAndUDNURL;
    BSTR bstrPresURL = NULL;
    WCHAR chQueryChar = '?' ;

    hr = HrSelectNodeText(L"presentationURL", pNodeDevice, strPresFileName);
    if(SUCCEEDED(hr))
    {
        hr = strPresFileName.HrGetBSTR(&bstrPresURL);
        if(SUCCEEDED(hr))
        {
            if(bstrPresURL != NULL && (wcscmp(bstrPresURL,L"") != 0 ) ) {        // check if its absolute URL !!!
                //if(wcsncmp(bstrPresURL,c_szhttp,c_chhttp) == 0 ) {
                if(IsAbsoluteURL(bstrPresURL)) {
                    if (wcschr(bstrPresURL,chQueryChar) ) {
                        hr = S_OK;
                    }
                    else {
                        hr = HrGenDescAndUDNURLForPresentation(guidPhysicalDeviceIdentifier,pNodeDevice,strDescAndUDNURL);
                        if(SUCCEEDED(hr))
                        {
                            hr = strPresentationURL.HrAppend(strPresFileName);
                            if(SUCCEEDED(hr))
                            {
                                hr = strPresentationURL.HrAppend(L"?");
                                if(SUCCEEDED(hr))
                                {
                                    hr = strPresentationURL.HrAppend(strDescAndUDNURL);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = HrSelectAndSetNodeText(L"presentationURL", pNodeDevice, strPresentationURL);
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    *fIsPresURLTagPresent = true ;
                    hr = HrGenPresentationURL(guidPhysicalDeviceIdentifier,pNodeDevice,strPresFileName,strPresentationURL);
                    if(SUCCEEDED(hr))
                    {
                        hr = HrSelectAndSetNodeText(L"presentationURL", pNodeDevice, strPresentationURL);
                    }
                }
            }
            else {
                hr = S_OK;
            }
        }
    }
    else {
        // write a function which will test for tag and return S_FALSE if tag is not present
        hr = S_OK;
    }
    SysFreeString(bstrPresURL);

    TraceHr(ttidError, FAL, hr, FALSE, "HrReplacePresentationURL");
    return hr;
}

HRESULT CDescriptionManager::HrPersistDeviceSettingsToRegistry(
    const PhysicalDeviceIdentifier & physicalDeviceIdentifier,
    const UDNReplacementTable & udnReplacementTable,
    const FileTable & fileTable,
    BOOL bPersist)
{
    HRESULT hr = S_OK;

    // Create / open device host key
    HKEY hKeyDescription;
    DWORD dwDisposition = 0;
    hr = HrCreateOrOpenDescriptionKey(&hKeyDescription);
    if(SUCCEEDED(hr))
    {
        // Generate key name and registry key
        CUString strPdi;
        HKEY hKeyPdi;
        hr = strPdi.HrInitFromGUID(physicalDeviceIdentifier);
        if(SUCCEEDED(hr))
        {
            hr = HrRegCreateKeyEx(hKeyDescription, strPdi, 0, KEY_ALL_ACCESS, NULL, &hKeyPdi, &dwDisposition);
            if(SUCCEEDED(hr))
            {
                // Create UDN mappings
                HKEY hKeyMappings;
                hr = HrRegCreateKeyEx(hKeyPdi, c_szUDNMappings, 0, KEY_ALL_ACCESS, NULL, &hKeyMappings, &dwDisposition);
                if(SUCCEEDED(hr))
                {
                    long nMappings = udnReplacementTable.Keys().GetCount();
                    for(long n = 0; n < nMappings && SUCCEEDED(hr); ++n)
                    {
                        // Create key for mapping
                        HKEY hKeyMapping;
                        hr = HrRegCreateKeyEx(hKeyMappings, udnReplacementTable.Keys()[n],
                                              0, KEY_ALL_ACCESS, NULL, &hKeyMapping, &dwDisposition);
                        if(SUCCEEDED(hr))
                        {
                            // Write the value for the mapping
                            hr = HrRegSetSz(hKeyMapping, L"", udnReplacementTable.Values()[n]);
                            RegCloseKey(hKeyMapping);
                        }
                    }
                    RegCloseKey(hKeyMappings);
                }
                // Create file mappings for a fully persistent device
                if(bPersist)
                {
                    HKEY hKeyFileMappings;
                    hr = HrRegCreateKeyEx(hKeyPdi, c_szFiles, 0, KEY_ALL_ACCESS, NULL, &hKeyFileMappings, &dwDisposition);
                    if(SUCCEEDED(hr))
                    {
                        long nMappings = fileTable.Keys().GetCount();
                        for(long n = 0; n < nMappings && SUCCEEDED(hr); ++n)
                        {
                            CUString strFileId;
                            hr = strFileId.HrInitFromGUID(fileTable.Keys()[n]);
                            if(SUCCEEDED(hr))
                            {
                                // Create key for mapping
                                HKEY hKeyMapping;
                                hr = HrRegCreateKeyEx(hKeyFileMappings, strFileId, 0, KEY_ALL_ACCESS, NULL, &hKeyMapping, &dwDisposition);
                                if(SUCCEEDED(hr))
                                {
                                    // Save values
                                    hr = HrRegSetSz(hKeyMapping, c_szFilename, fileTable.Values()[n].m_filename);
                                    if(SUCCEEDED(hr))
                                    {
                                        hr = HrRegSetSz(hKeyMapping, c_szMimetype, fileTable.Values()[n].m_mimetype);
                                    }
                                }
                            }
                        }
                        RegCloseKey(hKeyFileMappings);
                    }
                }
                RegCloseKey(hKeyPdi);
            }
        }
        // If anything fails, whack the whole key
        if(FAILED(hr))
        {
            HrRegDeleteKeyTree(hKeyDescription, strPdi);
        }
        RegCloseKey(hKeyDescription);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::HrPersistDeviceSettingsToRegistry");
    return hr;
}

HRESULT CDescriptionManager::HrLoadDocumentAndRootNode(
    const PhysicalDeviceIdentifier & physicalDeviceIdentifier,
    IXMLDOMNodePtr & pRootNode)
{
    HRESULT hr = S_OK;

    // Lookup the id
    BSTR * pbstrDocument = m_documentTable.Lookup(physicalDeviceIdentifier);
    if(pbstrDocument)
    {
        // Load the document
        IXMLDOMDocumentPtr  pDoc;

        hr = HrLoadDocument(*pbstrDocument, pDoc);
        if(SUCCEEDED(hr))
        {
            hr = pRootNode.HrAttach(pDoc);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::HrLoadDocumentAndRootNode");
    return hr;
}



HRESULT CDescriptionManager::HrPDT_FetchCollections(
    BSTR bstrTemplate,
    IXMLDOMDocumentPtr & pDoc,
    IXMLDOMNodePtr & pRootNode,
    CUString & strRootUdnOld,
    IXMLDOMNodeListPtr & pNodeListDevices,
    IXMLDOMNodeListPtr & pNodeListUDNs,
    IXMLDOMNodeListPtr & pNodeListSCPDURLs,
    IXMLDOMNodeListPtr & pNodeListIcons)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_FetchCollections");
    HRESULT hr = S_OK;

    // Load document and fetch needed items
    hr = HrLoadDocument(bstrTemplate, pDoc);
    if(SUCCEEDED(hr))
    {
        hr = pRootNode.HrAttach(pDoc);
        if(SUCCEEDED(hr))
        {
            // Get the old root UDN
            hr = HrSelectNodeText(L"/root/device/UDN", pRootNode, strRootUdnOld);
            if(SUCCEEDED(hr))
            {
                // Get the lists
                hr = HrSelectNodes(L"//device", pRootNode, pNodeListDevices);
                if(SUCCEEDED(hr))
                {
                    hr = HrSelectNodes(L"//UDN", pRootNode, pNodeListUDNs);
                    if(SUCCEEDED(hr))
                    {
                        hr = HrSelectNodes(L"//SCPDURL", pRootNode, pNodeListSCPDURLs);
                        if(SUCCEEDED(hr))
                        {
                            hr = HrSelectNodes(L"//icon", pRootNode, pNodeListIcons);
                        }
                    }
                }
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_FetchCollections");
    return hr;
}

HRESULT CDescriptionManager::HrPDT_DoUDNToUDNMapping(
    IXMLDOMNodeListPtr & pNodeListUDNs,
    UDNReplacementTable & udnReplacementTable)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_DoUDNToUDNMapping");
    HRESULT hr = S_OK;

    // Do UDN to UDN mapping
    HRESULT hrTmp = S_OK;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        // Process each UDN
        hrTmp = pNodeListUDNs->nextNode(pNode.AddressOf());
        if(S_OK != hrTmp)
        {
            break;
        }
        // Allocate UDN storage and generate new UDN
        CUString strOld;
        CUString strNew;
        hr = HrNewUDNString(strNew);
        if(SUCCEEDED(hr))
        {
            // Read the old UDN
            hr = HrGetNodeText(pNode, strOld);
            if(SUCCEEDED(hr))
            {
                // Do replacement
                hr = HrSetNodeText(pNode, strNew);
                if(SUCCEEDED(hr))
                {
                    // Add temporary table mapping
                    hr = udnReplacementTable.HrInsertTransfer(strOld, strNew);
                }
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_DoUDNToUDNMapping");
    return hr;
}

HRESULT CDescriptionManager::HrPDT_ReregisterUDNsInDescriptionDocument(
    UDNReplacementTable & udnReplacementTable,
    IXMLDOMNodeListPtr & pNodeListUDNs)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_ReregisterUDNsInDescriptionDocument");
    HRESULT hr = S_OK;

    HRESULT hrTmp = S_OK;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        // Process each UDN
        hrTmp = pNodeListUDNs->nextNode(pNode.AddressOf());
        if(S_OK != hrTmp)
        {
            break;
        }
        // Read the old UDN
        CUString strOld;
        hr = HrGetNodeText(pNode, strOld);
        if(SUCCEEDED(hr))
        {
            // Lookup in replacement table
            CUString * pstrNew = udnReplacementTable.Lookup(strOld);
            if(pstrNew)
            {
                // Do the replacement
                hr = HrSetNodeText(pNode, *pstrNew);
            }
            else
            {
                TraceTag(ttidDescMan, "HrPDT_ReregisterUDNsInDescriptionDocument: Got invalid UDN in reregister '%S'",
                         static_cast<const wchar_t *>(strOld));
                hr = E_UNEXPECTED;
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_ReregisterUDNsInDescriptionDocument");
    return hr;
}

HRESULT CDescriptionManager::HrPDT_FetchPhysicalIdentifier(
    UDNReplacementTable & udnReplacementTable,
    const CUString & strRootUdnOld,
    PhysicalDeviceIdentifier & pdi)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_FetchPhysicalIdentifier");
    HRESULT hr = S_OK;

    // Fetch identifier of root node
    UDN * pUDN = udnReplacementTable.Lookup(strRootUdnOld);
    if(!pUDN)
    {
        TraceTag(ttidError, "CDescriptionManager::ProcessDescriptionTemplate: We can't find the root UDN.");
        hr = E_INVALIDARG;
    }
    if(SUCCEEDED(hr))
    {
        hr = HrUDNStringToGUID(*pUDN, pdi);
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_FetchPhysicalIdentifier");
    return hr;
}

BOOL FEventedVariablesPresent(
    IXMLDOMNodeListPtr pNodeList)
{
    HRESULT     hr = S_OK;
    HRESULT     hrTmp;
    BOOL        fResult = FALSE;

    while (SUCCEEDED(hr) && !fResult)
    {
        IXMLDOMNodePtr pNode;

        // Process each node
        hrTmp = pNodeList->nextNode(pNode.AddressOf());
        if (S_OK != hrTmp)
        {
            break;
        }

        BSTR    bstrSendEvents = NULL;

        hr = HrGetTextValueFromAttribute(pNode, L"sendEvents", &bstrSendEvents);
        if (S_OK == hr)
        {
            // sendEvents was present so we know there is at least one evented
            // variable.. ok to exit now
            if (!lstrcmpiW(bstrSendEvents, L"yes"))
            {
                fResult = TRUE;
            }

            SysFreeString(bstrSendEvents);
        }
        else
        {
            // sendEvents was not present which means we default to evented
            // ok to exit now.
            fResult = TRUE;
        }
    }

    return fResult;
}

HRESULT HrCheckForEventedVariables(
    CUString & strUrl)
{
    HRESULT     hr = S_OK;
    BSTR        bstrUrl;
    BOOL        fEventedVariables = FALSE;

    hr = strUrl.HrGetBSTR(&bstrUrl);
    if (SUCCEEDED(hr))
    {
        IXMLDOMDocumentPtr  pDoc;

        hr = HrLoadDocumentFromFile(bstrUrl, pDoc);
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodePtr  pRootNode;

            hr = pRootNode.HrAttach(pDoc);
            if (SUCCEEDED(hr))
            {
                IXMLDOMNodeListPtr pNodeList;

                hr = HrSelectNodes(L"//stateVariable",
                                   pRootNode, pNodeList);
                if (SUCCEEDED(hr))
                {
                    if (FEventedVariablesPresent(pNodeList))
                    {
                        fEventedVariables = TRUE;
                    }
                }
            }
        }

        SysFreeString(bstrUrl);
    }

    if (SUCCEEDED(hr))
    {
        hr = fEventedVariables ? S_OK : S_FALSE;
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "HrCheckForEventedVariables");
    return hr;
}

HRESULT CDescriptionManager::HrPDT_ReplaceSCPDURLs(
    IXMLDOMNodeListPtr & pNodeListSCPDURLs,
    const wchar_t * szResourcePath,
    FileTable & fileTable)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_ReplaceSCPDURLs");
    HRESULT hr = S_OK;

    // Replace SCPDURLs
    HRESULT hrTmp = S_OK;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        // Process each SCPDURL
        hrTmp = pNodeListSCPDURLs->nextNode(pNode.AddressOf());
        if(S_OK != hrTmp)
        {
            break;
        }
        // Allocate filename storage and generate new URL
        CUString strOld;
        CUString strNew;
        GUID guid;
        hr = CoCreateGuid(&guid);
        if(SUCCEEDED(hr))
        {
            // Generate the URL
            hr = HrGetContentURL(guid, strNew);
            if(SUCCEEDED(hr))
            {
                // Read the filename
                CUString strFilename;
                hr = HrGetNodeText(pNode, strFilename);
                if(SUCCEEDED(hr))
                {
                    // Make an absolute filename
                    hr = HrMakeFullPath(szResourcePath, strFilename, strOld);
                }
            }
            if(SUCCEEDED(hr))
            {
                CUString    strNode;

                hr = strNode.HrAssign(L"/upnphost/");
                if (SUCCEEDED(hr))
                {
                    hr = strNode.HrAppend(strNew);
                    if (SUCCEEDED(hr))
                    {
                        // Do replacement
                        hr = HrSetNodeText(pNode, strNode);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Determine if the eventSubURL should be replaced later on
                //
                hr = HrCheckForEventedVariables(strOld);
                if (S_FALSE == hr)
                {
                    // No evented variables were found.. mark the eventSubURL
                    // element to be emptied later on when we process the
                    // eventing URLs.
                    //

                    CUString    strRemove;

                    hr = strRemove.HrAssign(c_szRemoveId);
                    if (SUCCEEDED(hr))
                    {
                        hr = HrSelectAndSetNodeText(L"../eventSubURL", pNode,
                                                    strRemove);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Add mapping to data structure
                FileInfo fi;
                fi.m_filename.Transfer(strOld);
                hr = fi.m_mimetype.HrAssign(L"text/xml");
                if(SUCCEEDED(hr))
                {
                    hr = fileTable.HrInsertTransfer(guid, fi);
                }
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_ReplaceSCPDURLs");
    return hr;
}

HRESULT CDescriptionManager::HrPDT_ReplaceIcons(
    IXMLDOMNodeListPtr & pNodeListIcons,
    const wchar_t * szResourcePath,
    FileTable & fileTable)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_ReplaceIcons");
    HRESULT hr = S_OK;

    // Replace icons
    HRESULT hrTmp = S_OK;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        // Process each icon
        hrTmp = pNodeListIcons->nextNode(pNode.AddressOf());
        if(S_OK != hrTmp)
        {
            break;
        }
        // Allocate filename storage and generate new URL
            CUString strOld;
        CUString strNew;
        GUID guid;
        hr = CoCreateGuid(&guid);
        if(SUCCEEDED(hr))
        {
            // Generate the URL
            hr = HrGetContentURL(guid, strNew);
            if(SUCCEEDED(hr))
            {
                // Read the filename
                CUString strFilename;
                hr = HrSelectNodeText(L"url", pNode, strFilename);
                if(SUCCEEDED(hr))
                {
                    // Make an absolute filename
                    hr = HrMakeFullPath(szResourcePath, strFilename, strOld);
                }
            }
            if(SUCCEEDED(hr))
            {
                CUString    strNode;

                hr = strNode.HrAssign(L"/upnphost/");
                if (SUCCEEDED(hr))
                {
                    hr = strNode.HrAppend(strNew);
                    if (SUCCEEDED(hr))
                    {
                        // Do replacement
                        hr = HrSelectAndSetNodeText(L"url", pNode, strNode);
                    }
                }
            }
            if(SUCCEEDED(hr))
            {
                // Add mapping to data structure
                FileInfo fi;
                fi.m_filename.Transfer(strOld);
                // Get the mimetype
                CUString strMimetype;
                hr = HrSelectNodeText(L"mimetype", pNode, strMimetype);
                if(SUCCEEDED(hr))
                {
                    fi.m_mimetype.Transfer(strMimetype);
                    hr = fileTable.HrInsertTransfer(guid, fi);
                }
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_ReplaceIcons");
    return hr;
}

HRESULT CDescriptionManager::HrPDT_ReplaceControlAndEventURLs(
    IXMLDOMNodeListPtr & pNodeListDevices)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_ReplaceControlAndEventURLs");
    HRESULT hr = S_OK;

    // Fill in the control and eventing URL for each document
    HRESULT hrTmp = S_OK;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        // Process each device
        hrTmp = pNodeListDevices->nextNode(pNode.AddressOf());
        if(S_OK != hrTmp)
        {
            break;
        }
        hr = HrGenerateControlAndEventURLs(pNode);
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_ReplaceControlAndEventURLs");
    return hr;
}

// Iterates over the devices and fills in the presentation URL for each device
HRESULT CDescriptionManager::HrPDT_ProcessPresentationURLs(
    REFGUID guidPhysicalDeviceIdentifier,
    IXMLDOMNodeListPtr & pNodeListDevices,
    BOOL *fIsPresURLTagPresent)
{
        TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_ProcessPresentationURLs");
    HRESULT hr = S_OK;

    // Fill in the presentation URL for each device
    HRESULT hrTmp = S_OK;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        hrTmp = pNodeListDevices->nextNode(pNode.AddressOf());
        if(S_OK != hrTmp)
        {
            break;
        }
        hr = HrReplacePresentationURL(guidPhysicalDeviceIdentifier,pNode,fIsPresURLTagPresent);
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_ProcessPresentationURLs");
    return hr;
}


HRESULT CDescriptionManager::HrPDT_PersistDescriptionDocument(
    const PhysicalDeviceIdentifier & pdi,
    IXMLDOMDocumentPtr & pDoc)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPDT_PersistDescriptionDocument");
    HRESULT hr = S_OK;

    // Write description document to disk

    // Get the path to save to
    CUString strPath;
    hr = HrGetDescriptionDocumentPath(pdi, strPath);
    if(SUCCEEDED(hr))
    {
        BSTR bstr = NULL;
        hr = strPath.HrGetBSTR(&bstr);
        if(SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            var.vt = VT_BSTR;
            var.bstrVal = bstr;
            hr = pDoc->save(var);
            SysFreeString(bstr);
            TraceHr(ttidError, FAL, hr, FALSE, "ProcessDescriptionTemplate: IXMLDOMDocument::save failed.");
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPDT_PersistDescriptionDocument");
    return hr;
}

STDMETHODIMP CDescriptionManager::ProcessDescriptionTemplate(
    /*[in]*/ BSTR bstrTemplate,
    /*[in, string]*/ const wchar_t * szResourcePath,
    /*[in, out]*/ GUID * pguidPhysicalDeviceIdentifier,
    /*[in]*/ BOOL bPersist,
    /*[in]*/ BOOL bReregister)
{
    CHECK_POINTER(bstrTemplate);
    CHECK_POINTER(szResourcePath);
    CHECK_POINTER(pguidPhysicalDeviceIdentifier);

    CALock lock(*this);
    HRESULT hr = S_OK;

    // Values to fetch in first phase
    IXMLDOMDocumentPtr pDoc;
    IXMLDOMNodePtr pRootNode;
    CUString strRootUdnOld;
    IXMLDOMNodeListPtr pNodeListDevices;
    IXMLDOMNodeListPtr pNodeListUDNs;
    IXMLDOMNodeListPtr pNodeListSCPDURLs;
    IXMLDOMNodeListPtr pNodeListIcons;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        // Load document and fetch needed items
        hr = HrPDT_FetchCollections(bstrTemplate, pDoc, pRootNode, strRootUdnOld, pNodeListDevices,
                                    pNodeListUDNs, pNodeListSCPDURLs, pNodeListIcons);

    }

    // Temporary data structures to do work in
    PhysicalDeviceIdentifier pdi;
    UDNReplacementTable udnReplacementTable;
    FileTable fileTable;

    if(!bReregister)
    {
        // Do UDN to UDN mapping
        if(SUCCEEDED(hr))
        {
            hr = HrPDT_DoUDNToUDNMapping(pNodeListUDNs, udnReplacementTable);
        }

        // Fetch identifier of root node
        if(SUCCEEDED(hr))
        {
            hr = HrPDT_FetchPhysicalIdentifier(udnReplacementTable, strRootUdnOld, pdi);
        }
    }
    else
    {
        if(SUCCEEDED(hr))
        {
            // Set the physical device identifier
            pdi = *pguidPhysicalDeviceIdentifier;
            // Open physical device identifier's registry key
            HKEY hKeyPdi;
            hr = HrOpenPhysicalDeviceDescriptionKey(pdi, &hKeyPdi);
            if(SUCCEEDED(hr))
            {
                // Load the UDNs from registry
                hr = HrLD_ReadUDNMappings(hKeyPdi, udnReplacementTable);
                if(SUCCEEDED(hr))
                {
                    // Update UDNs in the document
                    hr = HrPDT_ReregisterUDNsInDescriptionDocument(udnReplacementTable, pNodeListUDNs);
                }
                RegCloseKey(hKeyPdi);
            }
        }
    }

    // Replace SCPDURLs
    if(SUCCEEDED(hr))
    {
        hr = HrPDT_ReplaceSCPDURLs(pNodeListSCPDURLs, szResourcePath, fileTable);
    }

    // Replace icons
    if(SUCCEEDED(hr))
    {
        hr = HrPDT_ReplaceIcons(pNodeListIcons, szResourcePath, fileTable);
    }

    // Fill in the control and eventing URL for each document
    if(SUCCEEDED(hr))
    {
        hr = HrPDT_ReplaceControlAndEventURLs(pNodeListDevices);
    }

    // Fill in the presentation URL for each device
    if(SUCCEEDED(hr))
    {
        BOOL fIsPresURLTagPresent = false ;
        hr = pNodeListDevices->reset();
        if(SUCCEEDED(hr))
        {
            hr = HrPDT_ProcessPresentationURLs(pdi,pNodeListDevices,&fIsPresURLTagPresent);
                 // Create Virtual Directory for the presentation files
            if(SUCCEEDED(hr) && fIsPresURLTagPresent )
            {
                BSTR bstrResourcePath;
                bstrResourcePath = SysAllocString(szResourcePath);
                hr = HrCreatePresentationVirtualDir(pdi,bstrResourcePath);
                SysFreeString(bstrResourcePath);
            }
        }
    }

    // Write description document to disk
    if(SUCCEEDED(hr) && bPersist)
    {
        hr = HrPDT_PersistDescriptionDocument(pdi, pDoc);
    }

    // Commit changes to registry for bPersist
    if(SUCCEEDED(hr))
    {
        hr = HrPersistDeviceSettingsToRegistry(pdi, udnReplacementTable, fileTable, bPersist);
    }

    // Commit changes to variables
    if(SUCCEEDED(hr))
    {
        // Add entries to the cleanup table
        CleanupItem ci;
        ci.m_physicalDeviceIdentifier = pdi;
        long nCount = fileTable.Keys().GetCount();
        for(long n = 0; n < nCount && SUCCEEDED(hr); ++n)
        {
            ci.m_fileId = fileTable.Keys()[n];
            hr = m_cleanupList.HrPushBack(ci);
        }
        if(SUCCEEDED(hr))
        {
            {
                CLock lockTable(m_critSecReplacementTable);
                hr = m_replacementTable.HrInsertTransfer(pdi, udnReplacementTable);
            }
            if(SUCCEEDED(hr))
            {
                hr = m_fileTable.HrAppendTableTransfer(fileTable);
            }
        }
    }

    // Save description document
    if(SUCCEEDED(hr))
    {
        BSTR bstrDocument = NULL;
        hr = pRootNode->get_xml(&bstrDocument);
        if(SUCCEEDED(hr))
        {
            hr = m_documentTable.HrInsert(pdi, bstrDocument);
            if(FAILED(hr))
            {
                SysFreeString(bstrDocument);
            }
        }
    }

    // Return identifier
    if(SUCCEEDED(hr) && !bReregister)
    {
        *pguidPhysicalDeviceIdentifier = pdi;
    }

    if(FAILED(hr))
    {
        RemoveDescription(pdi, FALSE);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::ProcessDescriptionTemplate");
    return hr;
}

HRESULT HrRegisterService(PSSDP_MESSAGE pSsdpMessage, DWORD dwFlags, HANDLE * pHandle)
{
    CHECK_POINTER(pSsdpMessage);
    CHECK_POINTER(pHandle);
    HRESULT hr = S_OK;

    *pHandle = RegisterService(pSsdpMessage, dwFlags);
    if(INVALID_HANDLE_VALUE == *pHandle)
    {
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrRegisterService:(%s) (%s)", pSsdpMessage->szType, pSsdpMessage->szUSN);
    return hr;
}

HRESULT CDescriptionManager::HrPD_DoRootNotification(
    IXMLDOMNodePtr & pNodeRootDevice,
    SSDP_MESSAGE * pMsg,
    HandleList * pHandleList)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPD_DoRootNotification");
    HRESULT hr = S_OK;

    // Do the root node notification
    char szaUSN[256];
    HANDLE hSvc;

    // Get the UDN
    CUString strUDN;
    hr = HrSelectNodeText(L"UDN", pNodeRootDevice, strUDN);
    if(SUCCEEDED(hr))
    {
        // Format the fields, generate the notificatio, and save the handle
        wsprintfA(szaUSN, "%S::upnp:rootdevice", static_cast<const wchar_t*>(strUDN));
        pMsg->szUSN = szaUSN;
        pMsg->szType = "upnp:rootdevice";
        hr = HrRegisterService(pMsg, 0, &hSvc);
        if(SUCCEEDED(hr))
        {
            hr = pHandleList->HrPushBack(hSvc);
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPD_DoRootNotification");
    return hr;
}

HRESULT CDescriptionManager::HrPD_DoDevicePublication(
    IXMLDOMNodeListPtr & pNodeListDevices,
    SSDP_MESSAGE * pMsg,
    HandleList * pHandleList)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPD_DoDevicePublication");
    HRESULT hr = S_OK;

    // Do the device publication
    char szaUSN[256];
    char szaType[256];
    HANDLE hSvc;

    // Process each node in the device list
    HRESULT hrTmp = S_OK;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        hrTmp = pNodeListDevices->nextNode(pNode.AddressOf());
        if(S_OK != hrTmp)
        {
            break;
        }
        // Fetch the UDN
        CUString strUDN;
        hr = HrSelectNodeText(L"UDN", pNode, strUDN);
        if(SUCCEEDED(hr))
        {
            wsprintfA(szaUSN, "%S", static_cast<const wchar_t*>(strUDN));
            pMsg->szUSN = szaUSN;
            pMsg->szType = szaUSN;
            hr = HrRegisterService(pMsg, 0, &hSvc);
            if(SUCCEEDED(hr))
            {
                hr = pHandleList->HrPushBack(hSvc);
            }
        }
        if(SUCCEEDED(hr))
        {
            // Fetch the device type
            CUString strDeviceType;
            hr = HrSelectNodeText(L"deviceType", pNode, strDeviceType);
            if(SUCCEEDED(hr))
            {
                wsprintfA(szaUSN, "%S::%S", static_cast<const wchar_t*>(strUDN), static_cast<const wchar_t*>(strDeviceType));
                wsprintfA(szaType, "%S", static_cast<const wchar_t*>(strDeviceType));
                pMsg->szUSN = szaUSN;
                pMsg->szType = szaType;
                hr = HrRegisterService(pMsg, 0, &hSvc);
                if(SUCCEEDED(hr))
                {
                    hr = pHandleList->HrPushBack(hSvc);
                }
            }
        }
        // Do the services
        if(SUCCEEDED(hr))
        {
            hr = HrPD_DoServicePublication(pNode, strUDN, pMsg, pHandleList);
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPD_DoDevicePublication");
    return hr;
}

HRESULT CDescriptionManager::HrPD_DoServicePublication(
    IXMLDOMNodePtr & pNodeDevice,
    const CUString & strUDN,
    SSDP_MESSAGE * pMsg,
    HandleList * pHandleList)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrPD_DoServicePublication");
    HRESULT hr = S_OK;

    // Do the services
    char szaUSN[256];
    char szaType[256];
    HANDLE hSvc;

    // Get the services for this device
    IXMLDOMNodeListPtr pNodeListServices;
    hr = HrSelectNodes(L"serviceList/service", pNodeDevice, pNodeListServices);
    if(SUCCEEDED(hr))
    {
        // Process each service in the list
        HRESULT hrTmp = S_OK;
        while(SUCCEEDED(hr))
        {
            IXMLDOMNodePtr pNodeService;
            hrTmp = pNodeListServices->nextNode(pNodeService.AddressOf());
            if(S_OK != hrTmp)
            {
                break;
            }
            // Fetch the service type
            CUString strServiceType;
            hr = HrSelectNodeText(L"serviceType", pNodeService, strServiceType);
            // We need to only send out one anouncement for each service type.
            // Do a selectSingleNode for this type and see if we match.
            IXMLDOMNodePtr pNodeTemp;
            if(SUCCEEDED(hr))
            {
                CUString strPattern;
                hr = strPattern.HrAssign(L"serviceList/service[./serviceType = '");
                if(SUCCEEDED(hr))
                {
                    hr = strPattern.HrAppend(strServiceType);
                    if(SUCCEEDED(hr))
                    {
                        hr = strPattern.HrAppend(L"']");
                    }
                }
                if(SUCCEEDED(hr))
                {
                    hr = HrSelectNode(strPattern, pNodeDevice, pNodeTemp);
                }
            }
            if(SUCCEEDED(hr) && S_OK == pNodeTemp.HrIsEqual(pNodeService))
            {
                wsprintfA(szaType, "%S", static_cast<const wchar_t*>(strServiceType));
                wsprintfA(szaUSN, "%S::%S", static_cast<const wchar_t*>(strUDN),
                          static_cast<const wchar_t*>(strServiceType));
                pMsg->szUSN = szaUSN;
                pMsg->szType = szaType;
                hr = HrRegisterService(pMsg, 0, &hSvc);
                if(SUCCEEDED(hr))
                {
                    hr = pHandleList->HrPushBack(hSvc);
                }
            }
            // Register with eventing
            if(SUCCEEDED(hr))
            {
                hr = HrRegisterServiceWithEventing(pNodeService, strUDN, TRUE);
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrPD_DoServicePublication");
    return hr;
}

STDMETHODIMP CDescriptionManager::PublishDescription(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[in]*/ long nLifeTime)
{
    CALock lock(*this);
    HRESULT hr = S_OK;
    char szaLocHeader[256];
    SSDP_MESSAGE msg = {0};
    CUString strUrl;
    CUString strDesc;
    HandleList *pHandleList = NULL;

    // Set lifetime and invariants
    msg.iLifeTime = nLifeTime;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        if ( !( pHandleList = new HandleList ) )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = HrGetContentURL(guidPhysicalDeviceIdentifier, strDesc);
    }

    if(SUCCEEDED(hr))
    {
        hr = HrGetURLBase(strUrl);
        if(SUCCEEDED(hr))
        {
            hr = strUrl.HrAppend(strDesc);
            if(SUCCEEDED(hr))
            {
                wsprintfA(szaLocHeader, "%S", static_cast<const wchar_t*>(strUrl));
                msg.szLocHeader = szaLocHeader;
            }
        }
    }

    IXMLDOMNodeListPtr pNodeListDevices;
    IXMLDOMNodePtr pNodeRootDevice;

    // Get the DOM collections needed
    if(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pRootNode;
        hr = HrLoadDocumentAndRootNode(guidPhysicalDeviceIdentifier, pRootNode);
        if(SUCCEEDED(hr))
        {
            // Fetch the devices
            hr = HrSelectNodes(L"//device", pRootNode, pNodeListDevices);
            if(SUCCEEDED(hr))
            {
                hr = HrSelectNode(L"/root/device", pRootNode, pNodeRootDevice);
            }
        }
    }

    // Do the root node notification
    if(SUCCEEDED(hr))
    {
        hr = HrPD_DoRootNotification(pNodeRootDevice, &msg, pHandleList);
    }

    // Do the device publication
    if(SUCCEEDED(hr))
    {
        hr = HrPD_DoDevicePublication(pNodeListDevices, &msg, pHandleList);
    }

    // If we have succeeded then add handle array to table
    if(SUCCEEDED(hr))
    {
        AssertSz(!m_ssdpRegistrationTable.Lookup(guidPhysicalDeviceIdentifier),
                 "CDescriptionManager::PublishDescription: Republishing known identifier!");
        hr = m_ssdpRegistrationTable.HrInsert(guidPhysicalDeviceIdentifier, pHandleList);
        if(SUCCEEDED(hr))
        {
            // Do this so it doesn't get cleared below
            pHandleList = NULL;
        }
    }

    // If handle list gets added to data structure it will be nulled out and this won't be cleaned up
    if(pHandleList)
    {
        long nCount = pHandleList->GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            DeregisterService((*pHandleList)[n], TRUE);
        }
        delete pHandleList;
    }
    if(FAILED(hr))
    {
        HrRD_RemoveFromEventing(guidPhysicalDeviceIdentifier);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::PublishDescription");
    return hr;
}

HRESULT CDescriptionManager::HrLD_ReadUDNMappings(
    HKEY hKeyPdi,
    UDNReplacementTable & udnReplacementTable)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrLD_ReadUDNMappings");
    HRESULT hr = S_OK;

    // Read the UDN mappings
    HKEY hKeyMappings;
    hr = HrRegOpenKeyEx(hKeyPdi, c_szUDNMappings, KEY_ALL_ACCESS, &hKeyMappings);
    if(SUCCEEDED(hr))
    {
        wchar_t szBuf[_MAX_PATH];
        DWORD dwSize = _MAX_PATH;
        FILETIME ft;
        DWORD dwIndex;
        for(dwIndex = 0;
            SUCCEEDED(hr) && S_OK == HrRegEnumKeyEx(hKeyMappings, dwIndex, szBuf, &dwSize, NULL, NULL, &ft);
            dwSize = _MAX_PATH, ++dwIndex)
        {
            // Open the mapping key
            HKEY hKeyMapping;
            hr = HrRegOpenKeyEx(hKeyMappings, szBuf, KEY_ALL_ACCESS, &hKeyMapping);
            if(SUCCEEDED(hr))
            {
                CUString strFrom;
                CUString strTo;
                hr = strFrom.HrAssign(szBuf);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegQueryString(hKeyMapping, L"", strTo);
                    if(SUCCEEDED(hr))
                    {
                        hr = udnReplacementTable.HrInsertTransfer(strFrom, strTo);
                    }
                }
                RegCloseKey(hKeyMapping);
            }
        }
        RegCloseKey(hKeyMappings);
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrLD_ReadUDNMappings");
    return hr;
}

HRESULT CDescriptionManager::HrLD_ReadFileMappings(
    HKEY hKeyPdi,
    FileTable & fileTable)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrLD_ReadFileMappings");
    HRESULT hr = S_OK;

    HKEY hKeyFileMappings;
    hr = HrRegOpenKeyEx(hKeyPdi, c_szFiles, KEY_ALL_ACCESS, &hKeyFileMappings);
    if(SUCCEEDED(hr))
    {
        wchar_t szBuf[_MAX_PATH];
        DWORD dwSize = _MAX_PATH;
        FILETIME ft;
        DWORD dwIndex;
        for(dwIndex = 0;
            SUCCEEDED(hr) && S_OK == HrRegEnumKeyEx(hKeyFileMappings, dwIndex, szBuf, &dwSize, NULL, NULL, &ft);
            dwSize = _MAX_PATH, ++dwIndex)
        {
            // Open the mapping key
            HKEY hKeyMapping;
            hr = HrRegOpenKeyEx(hKeyFileMappings, szBuf, KEY_ALL_ACCESS, &hKeyMapping);
            if(SUCCEEDED(hr))
            {
                // Convert the FileId to a guid
                GUID guidFileId;
                hr = CLSIDFromString(szBuf, &guidFileId);
                if(SUCCEEDED(hr))
                {
                    // Read the values
                    CUString strFilename;
                    CUString strMimetype;
                    hr = HrRegQueryString(hKeyMapping, c_szFilename, strFilename);
                    if(SUCCEEDED(hr))
                    {
                        hr = HrRegQueryString(hKeyMapping, c_szMimetype, strMimetype);
                        if(SUCCEEDED(hr))
                        {
                            FileInfo fi;
                            fi.m_filename.Transfer(strFilename);
                            fi.m_mimetype.Transfer(strMimetype);
                            hr = fileTable.HrInsertTransfer(guidFileId, fi);
                        }
                    }
                }
                RegCloseKey(hKeyMapping);
            }
        }
        RegCloseKey(hKeyFileMappings);
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrLD_ReadFileMappings");
    return hr;
}

HRESULT CDescriptionManager::HrLD_LoadDescriptionDocumentFromDisk(
    const PhysicalDeviceIdentifier & pdi,
    IXMLDOMDocumentPtr & pDoc)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrLD_LoadDescriptionDocumentFromDisk");
    HRESULT hr = S_OK;

    // Load the document - use the DOM to at least validate that it is XML

    // Get the path to load from
    CUString strPath;
    hr = HrGetDescriptionDocumentPath(pdi, strPath);
    if(SUCCEEDED(hr))
    {
        BSTR bstr = NULL;
        hr = strPath.HrGetBSTR(&bstr);
        if(SUCCEEDED(hr))
        {
            hr = pDoc.HrCreateInstanceInproc(CLSID_DOMDocument30);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                VariantInit(&var);
                var.vt = VT_BSTR;
                var.bstrVal = bstr;
                VARIANT_BOOL vb;
                hr = pDoc->load(var, &vb);
                SysFreeString(bstr);
                TraceHr(ttidError, FAL, hr, FALSE, "LoadDescription: IXMLDOMDocument::load failed.");
                if(SUCCEEDED(hr) && !vb)
                {
                    hr = E_FAIL;
                }
                if(FAILED(hr))
                {
                    pDoc.Release();
                }
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrLD_LoadDescriptionDocumentFromDisk");
    return hr;
}

HRESULT CDescriptionManager::HrLD_SaveDescriptionDocumentText(
    IXMLDOMDocumentPtr & pDoc,
    const PhysicalDeviceIdentifier & pdi)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrLD_SaveDescriptionDocumentText");
    HRESULT hr = S_OK;

    // Save description document
    BSTR bstrDocument = NULL;
    IXMLDOMNodePtr pRootNode;
    hr = pRootNode.HrAttach(pDoc);
    if(SUCCEEDED(hr))
    {
        hr = pRootNode->get_xml(&bstrDocument);
        if(SUCCEEDED(hr))
        {
            hr = m_documentTable.HrInsert(pdi, bstrDocument);
            if(FAILED(hr))
            {
                SysFreeString(bstrDocument);
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrLD_SaveDescriptionDocumentText");
    return hr;
}

STDMETHODIMP CDescriptionManager::LoadDescription(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier)
{
    CALock lock(*this);
    HRESULT hr = S_OK;

    UDNReplacementTable udnReplacementTable;
    FileTable fileTable;

    // Open physical device identifier's registry key
    HKEY hKeyPdi;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = HrOpenPhysicalDeviceDescriptionKey(guidPhysicalDeviceIdentifier, &hKeyPdi);
    }

    if(SUCCEEDED(hr))
    {
        // Read the UDN mappings
        hr = HrLD_ReadUDNMappings(hKeyPdi, udnReplacementTable);

        // Read the file mappings
        if(SUCCEEDED(hr))
        {
            hr = HrLD_ReadFileMappings(hKeyPdi, fileTable);
        }
        RegCloseKey(hKeyPdi);
    }

    IXMLDOMDocumentPtr pDoc;
    // Load the document - use the DOM to at least validate that it is XML
    if(SUCCEEDED(hr))
    {
        hr = HrLD_LoadDescriptionDocumentFromDisk(guidPhysicalDeviceIdentifier, pDoc);
    }

    // Everything has succeeded to memory so transfer to variables
    if(SUCCEEDED(hr))
    {
        // Add entries to the cleanup table
        CleanupItem ci;
        ci.m_physicalDeviceIdentifier = guidPhysicalDeviceIdentifier;
        long nCount = fileTable.Keys().GetCount();
        for(long n = 0; n < nCount && SUCCEEDED(hr); ++n)
        {
            ci.m_fileId = fileTable.Keys()[n];
            hr = m_cleanupList.HrPushBack(ci);
        }
        if(SUCCEEDED(hr))
        {
            {
                CLock lockTable(m_critSecReplacementTable);
                hr = m_replacementTable.HrInsertTransfer(const_cast<UUID&>(guidPhysicalDeviceIdentifier), udnReplacementTable);
            }
            if(SUCCEEDED(hr))
            {
                hr = m_fileTable.HrAppendTableTransfer(fileTable);
            }
        }
    }

    // Save description document
    if(SUCCEEDED(hr))
    {
        hr = HrLD_SaveDescriptionDocumentText(pDoc, guidPhysicalDeviceIdentifier);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::LoadDescription");
    return hr;
}

HRESULT CDescriptionManager::HrRD_RemoveFromEventing(const PhysicalDeviceIdentifier & pdi)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrRD_RemoveFromEventing");
    HRESULT hr = S_OK;

    // Remove from eventing
    IXMLDOMNodePtr pRootNode;
    hr = HrLoadDocumentAndRootNode(pdi, pRootNode);
    if(SUCCEEDED(hr))
    {
        // Fetch the devices
        IXMLDOMNodeListPtr pNodeListDevices;
        hr = HrSelectNodes(L"//device", pRootNode, pNodeListDevices);
        if(SUCCEEDED(hr))
        {
            // Process each node in the device list
            HRESULT hrTmp = S_OK;
            while(SUCCEEDED(hr))
            {
                IXMLDOMNodePtr pNode;
                hrTmp = pNodeListDevices->nextNode(pNode.AddressOf());
                if(S_OK != hrTmp)
                {
                    break;
                }
                // Fetch the UDN
                CUString strUDN;
                hr = HrSelectNodeText(L"UDN", pNode, strUDN);
                // Do the services
                if(SUCCEEDED(hr))
                {
                    // Get the services for this device
                    IXMLDOMNodeListPtr pNodeListServices;
                    hr = HrSelectNodes(L"serviceList/service", pNode, pNodeListServices);
                    if(SUCCEEDED(hr))
                    {
                        // Process each service in the list
                        HRESULT hrTmp = S_OK;
                        while(SUCCEEDED(hr))
                        {
                            IXMLDOMNodePtr pNodeService;
                            hrTmp = pNodeListServices->nextNode(pNodeService.AddressOf());
                            if(S_OK != hrTmp)
                            {
                                break;
                            }
                            // Deregister with eventing
                            hr = HrRegisterServiceWithEventing(pNodeService, strUDN, FALSE);
                        }
                    }
                }
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrRD_RemoveFromEventing");
    return hr;
}

HRESULT CDescriptionManager::HrRD_RemoveFromDataStructures(const PhysicalDeviceIdentifier & pdi)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrRD_RemoveFromDataStructures");
    HRESULT hr = S_OK;

    // Remove from data structures

    // Walk cleanup list
    long n = 0;
    while(n < m_cleanupList.GetCount())
    {
        for(n = 0; n < m_cleanupList.GetCount(); ++n)
        {
            // If we match this cleanup item then remove from fileTable and restart
            if(pdi == m_cleanupList[n].m_physicalDeviceIdentifier)
            {
                m_fileTable.HrErase(m_cleanupList[n].m_fileId);
                m_cleanupList.HrErase(n);
                break;
            }
        }
    }

    // Remove from document table
    BSTR * pbstr = m_documentTable.Lookup(pdi);
    if(pbstr)
    {
        SysFreeString(*pbstr);
    }
    else
    {
        TraceTag(ttidError, "CDescriptionManager::RemoveDescription: Document not found!");
    }
    m_documentTable.HrErase(pdi);

    // Free the UDN replacement table items
    if(SUCCEEDED(hr))
    {
        CLock lockTable(m_critSecReplacementTable);
        hr = m_replacementTable.HrErase(pdi);
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrRD_RemoveFromDataStructures");
    return hr;
}

HRESULT CDescriptionManager::HrRD_CleanupPublication(const PhysicalDeviceIdentifier & pdi)
{
    TraceTag(ttidDescMan, "CDescriptionManager::HrRD_CleanupPublication");
    HRESULT hr = S_OK;

    // Cleanup the publication
    HandleList ** ppHandleList = NULL;
    ppHandleList = m_ssdpRegistrationTable.Lookup(pdi);
    if(ppHandleList)
    {
        long nCount = (*ppHandleList)->GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            DeregisterService((**ppHandleList)[n], TRUE);
        }
        delete *ppHandleList;
        hr = m_ssdpRegistrationTable.HrErase(pdi);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "CDescriptionManager::HrRD_CleanupPublication");
    return hr;
}

STDMETHODIMP CDescriptionManager::RemoveDescription(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[in]*/ BOOL bPermanent)
{
    CALock lock(*this);
    HRESULT hr = S_OK;

    // Remove from the registry if present

    // Create / open description key
    HKEY hKeyDescription;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = HrCreateOrOpenDescriptionKey(&hKeyDescription);
    }

    if(SUCCEEDED(hr))
    {
        // Generate key name and registry key
        CUString strPdi;
        hr = strPdi.HrInitFromGUID(guidPhysicalDeviceIdentifier);
        if(SUCCEEDED(hr))
        {
            if(bPermanent)
            {
                hr = HrRegDeleteKeyTree(hKeyDescription, strPdi);
            }
            else
            {
                // Just delete the file stuff
                HKEY hKeyPdi;
                hr = HrRegOpenKeyEx(hKeyDescription, strPdi, KEY_ALL_ACCESS, &hKeyPdi);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegDeleteKeyTree(hKeyPdi, c_szFiles);
                    RegCloseKey(hKeyPdi);
                }
            }
        }
        RegCloseKey(hKeyDescription);
    }
    // Ignore registry failures
    hr = S_OK;

    // Delete the document from disk
    CUString strPath;
    hr = HrGetDescriptionDocumentPath(guidPhysicalDeviceIdentifier, strPath);
    if(SUCCEEDED(hr))
    {
        DeleteFile(strPath);
    }
    // Ignore file deletion failures - might not exist
    hr = S_OK;

    // Remove from eventing
    hr = HrRD_RemoveFromEventing(guidPhysicalDeviceIdentifier);

    // Remove from data structures
    hr = HrRD_RemoveFromDataStructures(guidPhysicalDeviceIdentifier);

    // Cleanup the publication
    hr = HrRD_CleanupPublication(guidPhysicalDeviceIdentifier);

    // Remove Virtual Directory Created for Presentation
    // CHECK - Virtual Directory may not be present
    hr = HrRemovePresentationVirtualDir(guidPhysicalDeviceIdentifier);
    if (FAILED(hr))
        hr = S_OK ;

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::RemoveDescription");
    return hr;
}

STDMETHODIMP CDescriptionManager::GetDescriptionText(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[out]*/ BSTR * pbstrDescriptionDocument)
{
    CHECK_POINTER(pbstrDescriptionDocument);
    CALock lock(*this);
    HRESULT hr = S_OK;


    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        // Lookup the id
        BSTR * pbstrDocument = m_documentTable.Lookup(guidPhysicalDeviceIdentifier);
        if(pbstrDocument)
        {
            hr = HrSysAllocString(*pbstrDocument, pbstrDescriptionDocument);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::GetDescriptionText");
    return hr;
}

STDMETHODIMP CDescriptionManager::GetUDNs(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[out]*/ long * pnUDNCount,
    /*[out, size_is(,*pnUDNCount,), string]*/
        wchar_t *** parszUDNs)
{
    CHECK_POINTER(pnUDNCount);
    CHECK_POINTER(parszUDNs);
    CALock lock(*this);
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pRootNode;
    IXMLDOMNodeListPtr pNodeListUDNs;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = HrLoadDocumentAndRootNode(guidPhysicalDeviceIdentifier, pRootNode);
    }

    if(SUCCEEDED(hr))
    {
        // Fetch the UDNs
        hr = HrSelectNodes(L"//UDN", pRootNode, pNodeListUDNs);
    }

    long nLength = 0;
    wchar_t ** arszUDNs = NULL;
    // Process the UDNs
    if(SUCCEEDED(hr))
    {
        // Get length
        hr = pNodeListUDNs->get_length(&nLength);
        if(SUCCEEDED(hr))
        {
            // Allocate array
            hr = HrCoTaskMemAllocArray(nLength, &arszUDNs);
            if(SUCCEEDED(hr))
            {
                // Fill with zeros
                ZeroMemory(arszUDNs, sizeof(wchar_t*) * nLength);
                // Fetch all of the UDNs
                long n = 0;
                while(SUCCEEDED(hr))
                {
                    IXMLDOMNodePtr pNode;
                    HRESULT hrTmp = S_OK;
                    // Fetch a node
                    hrTmp = pNodeListUDNs->nextNode(pNode.AddressOf());
                    if(S_OK != hrTmp)
                    {
                        break;
                    }
                    // Get the text
                    CUString strText;
                    hr = HrGetNodeText(pNode, strText);
                    if(SUCCEEDED(hr))
                    {
                        hr = strText.HrGetCOM(arszUDNs+n);
                    }
                    ++n;
                }
            }
        }
    }

    if(FAILED(hr))
    {
        if(arszUDNs)
        {
            // Free strings
            for(long n = 0; n < nLength; ++n)
            {
                if(arszUDNs[n])
                {
                    CoTaskMemFree(arszUDNs[n]);
                }
            }
            CoTaskMemFree(arszUDNs);
        }
        arszUDNs = NULL;
        nLength = 0;
    }

    // Copy to output parameters
    *pnUDNCount = nLength;
    *parszUDNs = arszUDNs;

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::GetUDNs");
    return hr;
}

STDMETHODIMP CDescriptionManager::GetUniqueDeviceName(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[in, string]*/ const wchar_t * szTemplateUDN,
    /*[out, string]*/ wchar_t ** pszUDN)
{
    CHECK_POINTER(szTemplateUDN);
    CHECK_POINTER(pszUDN);
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    if (FAILED(hr))
    {
        return hr;
    }

    // Only lock the replacement table
    CLock lock(m_critSecReplacementTable);

    *pszUDN = NULL;

    CUString strTemplateUDN;

    hr = strTemplateUDN.HrAssign(szTemplateUDN);

    if(SUCCEEDED(hr))
    {
        UDNReplacementTable * pudnReplacementTable = m_replacementTable.Lookup(guidPhysicalDeviceIdentifier);
        if(pudnReplacementTable)
        {
            CUString * pstrUDN = pudnReplacementTable->Lookup(strTemplateUDN);
            if(pstrUDN)
            {
                hr = pstrUDN->HrGetCOM(pszUDN);
            }
        }
    }
    // If we didn't find it in our tables then fail
    if(!*pszUDN && SUCCEEDED(hr))
    {
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::GetUniqueDeviceName");
    return hr;
}

STDMETHODIMP CDescriptionManager::GetSCPDText(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[in, string]*/ const wchar_t * szUDN,
    /*[in, string]*/ const wchar_t * szServiceId,
    /*[out, string]*/ wchar_t ** pszSCPDText,
    /*[out, string]*/ wchar_t ** pszServiceType)
{
    CHECK_POINTER(szUDN);
    CHECK_POINTER(szServiceId);
    CHECK_POINTER(pszSCPDText);
    CHECK_POINTER(pszServiceType);
    HRESULT hr = S_OK;

    IXMLDOMNodePtr pRootNode;
    IXMLDOMNodeListPtr pNodeListUDNs;
    CUString strSCPDURL;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        // Get the SCPDURL
        hr = HrLoadDocumentAndRootNode(guidPhysicalDeviceIdentifier, pRootNode);
    }

    if(SUCCEEDED(hr))
    {
        // Fetch the service node //service/SCPDURL[../serviceId = szServiceId]
        CUString strPattern;
        hr = strPattern.HrAssign(L"//service/SCPDURL[../serviceId = '");
        if(SUCCEEDED(hr))
        {
            hr = strPattern.HrAppend(szServiceId);
            if(SUCCEEDED(hr))
            {
                hr = strPattern.HrAppend(L"']");
                if(SUCCEEDED(hr))
                {
                    hr = HrSelectNodeText(strPattern, pRootNode, strSCPDURL);
                }
            }
        }
    }
    // Get the GUID out of the URL
    if(SUCCEEDED(hr))
    {
        UUID uuid;
        hr = HrContentURLToGUID(strSCPDURL, uuid);
        if(SUCCEEDED(hr))
        {
            // Fetch the content
            long nHeaderCount = 0;
            wchar_t ** arszHeaders = NULL;
            long nBytes = 0;
            byte * pBytes = NULL;
            hr = GetContent(uuid, &nHeaderCount, &arszHeaders, &nBytes, &pBytes);
            if(SUCCEEDED(hr))
            {
                // Content is not NULL terminate so reallocate with another character (yeah its cheesy)
                hr = HrCoTaskMemAllocArray(nBytes + 1, pszSCPDText);
                if(SUCCEEDED(hr))
                {
                    // Copy text and convert from UTF-8 to unicode
                    if(!MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<char*>(pBytes), nBytes, *pszSCPDText, nBytes))
                    {
                        hr = HrFromLastWin32Error();
                    }
                    if(SUCCEEDED(hr))
                    {
                        // Null terminate
                        (*pszSCPDText)[nBytes] = 0;
                    }
                }
                // Free everything
                CoTaskMemFree(pBytes);
                for(long n = 0; n < nHeaderCount; ++n)
                {
                    CoTaskMemFree(arszHeaders[n]);
                }
                CoTaskMemFree(arszHeaders);
            }
        }
    }

    // get the Service Type
    if (SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pServiceTypeNode;
        // Fetch the service type //service/SCPDURL[../serviceId = szServiceId]
        CUString strPattern;
        hr = strPattern.HrAssign(L"//service/serviceType[../serviceId = '");
        if(SUCCEEDED(hr))
        {
            hr = strPattern.HrAppend(szServiceId);
            if(SUCCEEDED(hr))
            {
                hr = strPattern.HrAppend(L"']");
                if(SUCCEEDED(hr))
                {
                    hr = HrSelectNode(strPattern, pRootNode, pServiceTypeNode);
                    if (SUCCEEDED(hr))
                    {
                        BSTR bstr = NULL;
                        hr = pServiceTypeNode->get_text(&bstr);
                        if(SUCCEEDED(hr))
                        {
                            *pszServiceType = (wchar_t*)CoTaskMemAlloc(CbOfSzAndTerm(bstr));
                            if (*pszServiceType)
                            {
                                lstrcpy(*pszServiceType, bstr);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            SysFreeString(bstr);
                        }
                    }
                }
            }
        }
    }


    TraceHr(ttidError, FAL, hr, FALSE, "CDescriptionManager::GetSCPDText");
    return hr;
}

HRESULT HrCreateOrOpenDescriptionKey(
    HKEY * phKeyDescription)
{
    CHECK_POINTER(phKeyDescription);
    HRESULT hr = S_OK;

    HKEY hKeyDeviceHost;
    hr = HrCreateOrOpenDeviceHostKey(&hKeyDeviceHost);
    if(SUCCEEDED(hr))
    {
        DWORD dwDisposition = 0;
        // Create / open description key
        hr = HrRegCreateKeyEx(hKeyDeviceHost, c_szDescription, 0, KEY_ALL_ACCESS, NULL, phKeyDescription, &dwDisposition);
        RegCloseKey(hKeyDeviceHost);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOpenDescriptionKey");
    return hr;
}

HRESULT HrOpenPhysicalDeviceDescriptionKey(
    const UUID & pdi,
    HKEY * phKeyPdi)
{
    CHECK_POINTER(phKeyPdi);
    HRESULT hr = S_OK;

    HKEY hKeyDescription;
    hr = HrCreateOrOpenDescriptionKey(&hKeyDescription);
    if(SUCCEEDED(hr))
    {
        CUString str;
        hr = str.HrInitFromGUID(pdi);
        if(SUCCEEDED(hr))
        {
            hr = HrRegOpenKeyEx(hKeyDescription, str, KEY_ALL_ACCESS, phKeyPdi);
        }
        RegCloseKey(hKeyDescription);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOpenPhysicalDeviceDescriptionKey");
    return hr;
}

HRESULT HrGetDescriptionDocumentPath(
    const UUID & pdi,
    CUString & strPath)
{
    HRESULT hr = S_OK;

    hr = HrGetUPnPHostPath(strPath);
    if(SUCCEEDED(hr))
    {
        hr = HrAddDirectoryToPath(strPath, c_szDescriptionDocuments);
        if(SUCCEEDED(hr))
        {
            CUString strGUID;
            hr = strGUID.HrInitFromGUID(pdi);
            if(SUCCEEDED(hr))
            {
                hr = strPath.HrAppend(strGUID);
                if(SUCCEEDED(hr))
                {
                    hr = strPath.HrAppend(L".xml");
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetDescriptionDocumentPath");
    return hr;
}

HRESULT HrRegisterServiceWithEventing(
    IXMLDOMNodePtr & pNodeService,
    const CUString & strUDN,
    BOOL bRegister)
{
    TraceTag(ttidDescMan, "HrRegisterServiceWithEventing");
    HRESULT hr = S_OK;

    // Register with eventing
    CUString strSid;
    hr = HrSelectNodeText(L"serviceId", pNodeService, strSid);
    if(SUCCEEDED(hr))
    {
        // Generate the event identifier
        CUString strESID;
        hr = strESID.HrAssign(strUDN);
        if(SUCCEEDED(hr))
        {
            hr = strESID.HrAppend(L"+");
            if(SUCCEEDED(hr))
            {
                hr = strESID.HrAppend(strSid);
                if(SUCCEEDED(hr))
                {
                    if(bRegister)
                    {
                        hr = HrRegisterEventSource(strESID);
                    }
                    else
                    {
                        hr = HrDeregisterEventSource(strESID);
                    }
                }
            }
        }
    }

    TraceHr(ttidDescMan, FAL, hr, FALSE, "HrRegisterServiceWithEventing");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\deviceinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E I N F O . H 
//
//  Contents:   Registrar representation of a device
//
//  Notes:      
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------


#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"
#include "UString.h"
#include "ComUtility.h"
#include "Table.h"
#include "RegDef.h"
#include "ServiceInfo.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CDeviceInfo
class CDeviceInfo 
{
public:
    CDeviceInfo();
    ~CDeviceInfo();

    HRESULT HrGetService(
        const PhysicalDeviceIdentifier & pdi,
        const wchar_t * szUDN,
        const wchar_t * szServiceId,
        const wchar_t * szContainerId,
        IUPnPDeviceControlPtr & pDeviceControl,
        CServiceInfo ** ppServiceInfo,
        BOOL bRunning);

    void Transfer(CDeviceInfo & ref);
    void Clear();
private:
    CDeviceInfo(const CDeviceInfo &);
    CDeviceInfo & operator=(const CDeviceInfo &);

    typedef CTable<Sid, CServiceInfo> ServiceTable;

    ServiceTable m_serviceTable;
};

inline void TypeTransfer(CDeviceInfo & dst, CDeviceInfo & src)
{
    dst.Transfer(src);
}

inline void TypeClear(CDeviceInfo & type)
{
    type.Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\deviceinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E I N F O . C P P 
//
//  Contents:   Registrar representation of a device
//
//  Notes:      
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "DeviceInfo.h"

CDeviceInfo::CDeviceInfo()
{
}

CDeviceInfo::~CDeviceInfo()
{
    Clear();
}

HRESULT CDeviceInfo::HrGetService(
    const PhysicalDeviceIdentifier & pdi,
    const wchar_t * szUDN,
    const wchar_t * szServiceId,
    const wchar_t * szContainerId,
    IUPnPDeviceControlPtr & pDeviceControl,
    CServiceInfo ** ppServiceInfo,
    BOOL bRunning)
{
    CHECK_POINTER(szUDN);
    CHECK_POINTER(szServiceId);
    CHECK_POINTER(ppServiceInfo);
    CHECK_POINTER(pDeviceControl.GetRawPointer());
    TraceTag(ttidRegistrar, "CDeviceInfo::HrGetService(UDN=%S, ServiceId=%S)", szUDN, szServiceId);
    HRESULT hr = S_OK;

    // Look it up in the service table first
    CUString strSid;
    hr = strSid.HrAssign(szServiceId);
    if(SUCCEEDED(hr))
    {
        *ppServiceInfo = m_serviceTable.Lookup(strSid);
        if(!*ppServiceInfo)
        {
            // It doesn't exist so create it
            CServiceInfo serviceInfo;
            hr = serviceInfo.HrInitialize(pdi, szUDN, szServiceId, szContainerId, pDeviceControl, bRunning);
            if(SUCCEEDED(hr))
            {
                // Put it into the table - !!! This wipes out strSid
                hr = m_serviceTable.HrInsertTransfer(strSid, serviceInfo);
                if(SUCCEEDED(hr))
                {
                    // Reinit strSid
                    hr = strSid.HrAssign(szServiceId);
                    if(SUCCEEDED(hr))
                    {
                        *ppServiceInfo = m_serviceTable.Lookup(strSid);
                    }
                }
            }
        }
    }
    if(SUCCEEDED(hr) && !*ppServiceInfo)
    {
        hr = E_INVALIDARG;
        TraceTag(ttidRegistrar, "CDeviceInfo::HrGetService- could not find ServiceId='%S'", 
                 static_cast<const wchar_t *>(strSid));
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CDeviceInfo::HrGetService");
    return hr;
}

void CDeviceInfo::Transfer(CDeviceInfo & ref)
{
    m_serviceTable.Swap(ref.m_serviceTable);
}

void CDeviceInfo::Clear()
{
    m_serviceTable.Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\devicemanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E M A N A G E R . H
//
//  Contents:   Registrar collection of physical devices and device information
//
//  Notes:
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"
#include "UString.h"
#include "ComUtility.h"
#include "Table.h"
#include "RegDef.h"
#include "PhysicalDeviceInfo.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CDeviceManager
class CDeviceManager
{
public:
    CDeviceManager();
    ~CDeviceManager();

    // Lifetime operations
    HRESULT HrShutdown();

    // Device registration
    HRESULT HrAddDevice(
        const PhysicalDeviceIdentifier & pdi,
        const wchar_t * szProgIdDeviceControlClass,
        const wchar_t * szInitString,
        const wchar_t * szContainerId,
        long nUDNs,
        wchar_t ** arszUDNs);
    HRESULT HrAddRunningDevice(
        const PhysicalDeviceIdentifier & pdi,
        IUnknown * pUnkDeviceControl,
        const wchar_t * szInitString,
        long nUDNs,
        wchar_t ** arszUDNs);
    HRESULT HrRemoveDevice(const PhysicalDeviceIdentifier & pdi);
    HRESULT HrGetService(
        const wchar_t * szUDN,
        const wchar_t * szServiceId,
        CServiceInfo ** ppServiceInfo);
    BOOL FHasDevice(const PhysicalDeviceIdentifier & pdi);
private:
    CDeviceManager(const CDeviceManager &);
    CDeviceManager & operator=(const CDeviceManager &);

    typedef CTable<PhysicalDeviceIdentifier, CPhysicalDeviceInfo> PhysicalDeviceTable;
    typedef CTable<UDN, PhysicalDeviceIdentifier> UDNMappingTable;

    PhysicalDeviceTable m_physicalDeviceTable;
    UDNMappingTable m_udnMappingTable;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\devicemanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E M A N A G E R . C P P
//
//  Contents:   Registrar collection of physical devices and device information
//
//  Notes:
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "DeviceManager.h"

CDeviceManager::CDeviceManager()
{
}

CDeviceManager::~CDeviceManager()
{
}

HRESULT CDeviceManager::HrShutdown()
{
    TraceTag(ttidRegistrar, "CDeviceManager::HrShutdown");
    HRESULT hr = S_OK;

    m_physicalDeviceTable.Clear();
    m_udnMappingTable.Clear();

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CDeviceManager::HrShutdown");
    return hr;
}

HRESULT CDeviceManager::HrAddDevice(
    const PhysicalDeviceIdentifier & pdi,
    const wchar_t * szProgIdDeviceControlClass,
    const wchar_t * szInitString,
    const wchar_t * szContainerId,
    long nUDNs,
    wchar_t ** arszUDNs)
{
    CHECK_POINTER(szProgIdDeviceControlClass);
    CHECK_POINTER(szInitString);
    CHECK_POINTER(szContainerId);
    TraceTag(ttidRegistrar, "CDeviceManager::HrAddDevice");
    HRESULT hr = S_OK;

    // Ensure we have a valid ProgID
    if (SUCCEEDED(hr))
    {
        CLSID   clsid;

        if (FAILED(CLSIDFromProgID(szProgIdDeviceControlClass, &clsid)))
        {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr))
    {
        // Create and initialize the device first
        CPhysicalDeviceInfo physicalDeviceInfo;
        hr = physicalDeviceInfo.HrInitialize(szProgIdDeviceControlClass,
                                             szInitString, szContainerId,
                                             nUDNs, arszUDNs);
        if(SUCCEEDED(hr))
        {
            // Now add to collection
            hr = m_physicalDeviceTable.HrInsertTransfer(
                                  const_cast<PhysicalDeviceIdentifier&>(pdi),
                                  physicalDeviceInfo);
            if(SUCCEEDED(hr))
            {
                // For each UDN, add a mapping back to the physical device identifier
                for(long n = 0; n < nUDNs && SUCCEEDED(hr); ++n)
                {
                    CUString strUDN;
                    hr = strUDN.HrAssign(arszUDNs[n]);
                    if(SUCCEEDED(hr))
                    {
                        hr = m_udnMappingTable.HrInsertTransfer(strUDN,
                                  const_cast<PhysicalDeviceIdentifier&>(pdi));
                    }
                }
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CDeviceManager::HrAddDevice");
    return hr;
}

HRESULT CDeviceManager::HrAddRunningDevice(
    const PhysicalDeviceIdentifier & pdi,
    IUnknown * pUnkDeviceControl,
    const wchar_t * szInitString,
    long nUDNs,
    wchar_t ** arszUDNs)
{
    CHECK_POINTER(pUnkDeviceControl);
    CHECK_POINTER(szInitString);
    TraceTag(ttidRegistrar, "CDeviceManager::HrAddRunningDevice");
    HRESULT hr = S_OK;

    // Create and initialize the device first
    CPhysicalDeviceInfo physicalDeviceInfo;
    hr = physicalDeviceInfo.HrInitializeRunning(pdi, pUnkDeviceControl, szInitString, nUDNs, arszUDNs);
    if(SUCCEEDED(hr))
    {
        // Now add to collection
        hr = m_physicalDeviceTable.HrInsertTransfer(const_cast<PhysicalDeviceIdentifier&>(pdi),
                                             physicalDeviceInfo);
        if(SUCCEEDED(hr))
        {
            // For each UDN, add a mapping back to the physical device identifier
            for(long n = 0; n < nUDNs && SUCCEEDED(hr); ++n)
            {
                CUString strUDN;
                hr = strUDN.HrAssign(arszUDNs[n]);
                if(SUCCEEDED(hr))
                {
                    hr = m_udnMappingTable.HrInsertTransfer(strUDN, const_cast<PhysicalDeviceIdentifier&>(pdi));
                }
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CDeviceManager::HrAddRunningDevice");
    return hr;
}

HRESULT CDeviceManager::HrRemoveDevice(const PhysicalDeviceIdentifier & pdi)
{
    TraceTag(ttidRegistrar, "CDeviceManager::HrRemoveDevice");
    HRESULT hr = S_OK;

    hr = m_physicalDeviceTable.HrErase(pdi);
    if(SUCCEEDED(hr))
    {
        while(SUCCEEDED(hr))
        {
            long nCount = m_udnMappingTable.Values().GetCount();
            for(long n = 0; n < nCount; ++n)
            {
                // Remove if we find a mapping for this pdi
                if(pdi == m_udnMappingTable.Values()[n])
                {
                    hr = m_udnMappingTable.HrErase(m_udnMappingTable.Keys()[n]);
                    break;
                }
            }
            if(n == nCount)
            {
                // We processed the whole array so there is nothing left to remove
                break;
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CDeviceManager::HrRemoveDevice");
    return hr;
}

HRESULT CDeviceManager::HrGetService(
    const wchar_t * szUDN,
    const wchar_t * szServiceId,
    CServiceInfo ** ppServiceInfo)
{
    CHECK_POINTER(szUDN);
    CHECK_POINTER(szServiceId);
    CHECK_POINTER(ppServiceInfo);
    TraceTag(ttidRegistrar, "CDeviceManager::HrGetService(UDN=%S, ServiceId=%S)", szUDN, szServiceId);
    HRESULT hr = S_OK;

    // See which PDI this refers to
    CUString strUDN;
    hr = strUDN.HrAssign(szUDN);
    if(SUCCEEDED(hr))
    {
        PhysicalDeviceIdentifier * pPdi = m_udnMappingTable.Lookup(strUDN);
        if(pPdi)
        {
            // Now find the physical device and forward to that
            CPhysicalDeviceInfo * pPhysicalDeviceInfo = m_physicalDeviceTable.Lookup(*pPdi);
            if(pPhysicalDeviceInfo)
            {
                hr = pPhysicalDeviceInfo->HrGetService(*pPdi, szUDN, szServiceId, ppServiceInfo);
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CDeviceManager::HrGetService");
    return hr;
}

BOOL CDeviceManager::FHasDevice(const PhysicalDeviceIdentifier & pdi)
{
    TraceTag(ttidRegistrar, "CDeviceManager::FHasDevice");
    HRESULT hr = S_OK;

    CPhysicalDeviceInfo* pphysicalDeviceInfo = NULL;
    hr = m_physicalDeviceTable.HrLookup(pdi, &pphysicalDeviceInfo);

    return (hr == S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\devicepersistencemanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E P E R S I S T E N C E M A N A G E R . H
//
//  Contents:   Persistence for UPnP device host registrar settings to registry
//
//  Notes:
//
//  Author:     mbend   6 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "hostp.h"
#include "UString.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// TestObject
class ATL_NO_VTABLE CDevicePersistenceManager :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CDevicePersistenceManager, &CLSID_UPnPDevicePersistenceManager>,
    public IUPnPDevicePersistenceManager
{
public:
    CDevicePersistenceManager();
    ~CDevicePersistenceManager();

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICE_PERSISTENCE_MANAGER)

DECLARE_NOT_AGGREGATABLE(CDevicePersistenceManager)
BEGIN_COM_MAP(CDevicePersistenceManager)
    COM_INTERFACE_ENTRY(IUPnPDevicePersistenceManager)
END_COM_MAP()

public:
    // IUPnPDevicePersistenceManager methods
    STDMETHOD(SavePhyisicalDevice)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[in, string]*/ const wchar_t * szProgIdDeviceControlClass,
        /*[in, string]*/ const wchar_t * szInitString,
        /*[in, string]*/ const wchar_t * szContainerId,
        /*[in, string]*/ const wchar_t * szResourcePath,
        /*[in]*/ long nLifeTime);
    STDMETHOD(LookupPhysicalDevice)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[out, string]*/ wchar_t ** pszProgIdDeviceControlClass,
        /*[out, string]*/ wchar_t ** pszInitString,
        /*[out, string]*/ wchar_t ** pszContainerId,
        /*[out, string]*/ wchar_t ** pszResourcePath,
        /*[out]*/ long * pnLifeTime);
    STDMETHOD(RemovePhysicalDevice)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier);
    STDMETHOD(GetPhysicalDevices)(
        /*[out]*/ long * pnDevices,
        /*[out, size_is(,*pnDevices)]*/
            GUID ** parguidPhysicalDeviceIdentifiers);
    STDMETHOD(SaveDeviceProvider)(
        /*[in, string]*/ const wchar_t * szProviderName,
        /*[in, string]*/ const wchar_t * szProgIdProviderClass,
        /*[in, string]*/ const wchar_t * szInitString,
        /*[in, string]*/ const wchar_t * szContainerId);
    STDMETHOD(LookupDeviceProvider)(
        /*[in, string]*/ const wchar_t * szProviderName,
        /*[out, string]*/ wchar_t ** pszProgIdProviderClass,
        /*[out, string]*/ wchar_t ** pszInitString,
        /*[out, string]*/ wchar_t ** pszContainerId);
    STDMETHOD(RemoveDeviceProvider)(
        /*[in, string]*/ const wchar_t * szProviderName);
    STDMETHOD(GetDeviceProviders)(
        /*[out]*/ long * pnProviders,
        /*[out, string, size_is(,*pnProviders,)]*/
            wchar_t *** parszProviderNames);
private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\devicepersistencemanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E P E R S I S T E N C E M A N A G E R . C P P 
//
//  Contents:   Persistence for UPnP device host registrar settings to registry
//
//  Notes:      
//
//  Author:     mbend   6 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "hostp.h"
#include "DevicePersistenceManager.h"
#include "uhsync.h"
#include "ncreg.h"
#include "Array.h"
#include "ComUtility.h"
#include "uhutil.h"
#include "uhcommon.h"

// String constants
const wchar_t c_szDevices[] = L"Devices";
const wchar_t c_szProviders[] = L"Providers";
const wchar_t c_szProgId[] = L"ProgId";
const wchar_t c_szInitString[] = L"Init String";
const wchar_t c_szContainerId[] = L"Container Id";
const wchar_t c_szResourcePath[] = L"Resource Path";
const wchar_t c_szLifeTime[] = L"Life Time";
const wchar_t c_szProgIdProviderClass[] = L"Provider ProgId";

// Helper functions

HRESULT HrCreateOrOpenDevicesKey(HKEY * phKeyDevices)
{
    CHECK_POINTER(phKeyDevices);
    HRESULT hr = S_OK;

    HKEY hKeyDeviceHost;
    hr = HrCreateOrOpenDeviceHostKey(&hKeyDeviceHost);
    if(SUCCEEDED(hr))
    {
        HKEY hKeyDevices;
        DWORD dwDisposition = 0;
        hr = HrRegCreateKeyEx(hKeyDeviceHost, c_szDevices, 0, KEY_ALL_ACCESS, NULL, &hKeyDevices, &dwDisposition);
        if(SUCCEEDED(hr))
        {
            *phKeyDevices = hKeyDevices;
        }
        RegCloseKey(hKeyDeviceHost);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateOrOpenDevicesKey");
    return hr;
}

HRESULT HrCreateOrOpenProvidersKey(HKEY * phKeyProviders)
{
    CHECK_POINTER(phKeyProviders);
    HRESULT hr = S_OK;

    HKEY hKeyDeviceHost;
    hr = HrCreateOrOpenDeviceHostKey(&hKeyDeviceHost);
    if(SUCCEEDED(hr))
    {
        HKEY hKeyProviders;
        DWORD dwDisposition = 0;
        hr = HrRegCreateKeyEx(hKeyDeviceHost, c_szProviders, 0, KEY_ALL_ACCESS, NULL, &hKeyProviders, &dwDisposition);
        if(SUCCEEDED(hr))
        {
            *phKeyProviders = hKeyProviders;
        }
        RegCloseKey(hKeyDeviceHost);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateOrOpenProvidersKey");
    return hr;
}

CDevicePersistenceManager::CDevicePersistenceManager()
{
}

CDevicePersistenceManager::~CDevicePersistenceManager()
{
}

STDMETHODIMP CDevicePersistenceManager::SavePhyisicalDevice(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[in, string]*/ const wchar_t * szProgIdDeviceControlClass,
    /*[in, string]*/ const wchar_t * szInitString,
    /*[in, string]*/ const wchar_t * szContainerId,
    /*[in, string]*/ const wchar_t * szResourcePath,
    /*[in]*/ long nLifeTime)
{
    HRESULT hr = S_OK;

    // Create the string to use
    CUString strUuid;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = strUuid.HrInitFromGUID(guidPhysicalDeviceIdentifier);
    }

    if(SUCCEEDED(hr))
    {
        HKEY hKeyDevices;
        hr = HrCreateOrOpenDevicesKey(&hKeyDevices);
        if(SUCCEEDED(hr))
        {
            // Create key to house values
            HKEY hKeyPid;
            DWORD dwDisposition = 0;
            hr = HrRegCreateKeyEx(hKeyDevices, strUuid, 0, KEY_ALL_ACCESS, NULL, &hKeyPid, &dwDisposition);
            if(SUCCEEDED(hr))
            {
                // Save all of the values
                hr = HrRegSetSz(hKeyPid, c_szProgId, szProgIdDeviceControlClass);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegSetSz(hKeyPid, c_szInitString, szInitString);
                    if(SUCCEEDED(hr))
                    {
                        hr = HrRegSetSz(hKeyPid, c_szContainerId, szContainerId);
                        if(SUCCEEDED(hr))
                        {
                            hr = HrRegSetSz(hKeyPid, c_szResourcePath, szResourcePath);
                            if(SUCCEEDED(hr))
                            {
                                hr = HrRegSetDword(hKeyPid, c_szLifeTime, nLifeTime);
                            }
                        }
                    }
                }
                RegCloseKey(hKeyPid);
                if(FAILED(hr))
                {
                    // If anything fails, remove the whole tree
                    HrRegDeleteKeyTree(hKeyDevices, strUuid);
                }
            }
            RegCloseKey(hKeyDevices);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::SavePhyisicalDevice");
    return hr;
}

STDMETHODIMP CDevicePersistenceManager::LookupPhysicalDevice(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[out, string]*/ wchar_t ** pszProgIdDeviceControlClass,
    /*[out, string]*/ wchar_t ** pszInitString,
    /*[out, string]*/ wchar_t ** pszContainerId,
    /*[out, string]*/ wchar_t ** pszResourcePath,
    /*[out]*/ long * pnLifeTime)
{
    CHECK_POINTER(pszProgIdDeviceControlClass);
    CHECK_POINTER(pszInitString);
    CHECK_POINTER(pszContainerId);
    CHECK_POINTER(pszResourcePath);
    CHECK_POINTER(pnLifeTime);
    HRESULT hr = S_OK;

    // Create the string to use
    CUString strUuid;
    CUString strProgIdDeviceControlClass;
    CUString strInitString;
    CUString strContainerId;
    CUString strResourcePath;
    DWORD dwLifeTime;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = strUuid.HrInitFromGUID(guidPhysicalDeviceIdentifier);
    }

    if(SUCCEEDED(hr))
    {
        HKEY hKeyDevices;
        hr = HrCreateOrOpenDevicesKey(&hKeyDevices);
        if(SUCCEEDED(hr))
        {
            // Open the key housing the values
            HKEY hKeyPid;
            DWORD dwDisposition = 0;
            hr = HrRegOpenKeyEx(hKeyDevices, strUuid, KEY_ALL_ACCESS, &hKeyPid);
            if(SUCCEEDED(hr))
            {
                // Load all of the values
                hr = HrRegQueryString(hKeyPid, c_szProgId, strProgIdDeviceControlClass);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegQueryString(hKeyPid, c_szInitString, strInitString);
                    if(SUCCEEDED(hr))
                    {
                        hr = HrRegQueryString(hKeyPid, c_szContainerId, strContainerId);
                        if(SUCCEEDED(hr))
                        {
                            hr = HrRegQueryString(hKeyPid, c_szResourcePath, strResourcePath);
                            if(SUCCEEDED(hr))
                            {
                                hr = HrRegQueryDword(hKeyPid, c_szLifeTime, &dwLifeTime);
                            }
                        }
                    }
                }
                RegCloseKey(hKeyPid);
            }
            RegCloseKey(hKeyDevices);
        }
    }
    // Set strings to NULL
    *pszProgIdDeviceControlClass = NULL;
    *pszInitString = NULL;
    *pszContainerId = NULL;
    *pszResourcePath = NULL;
    // On success set the out params
    if(SUCCEEDED(hr))
    {
        hr = strProgIdDeviceControlClass.HrGetCOM(pszProgIdDeviceControlClass);
        if(SUCCEEDED(hr))
        {
            hr = strInitString.HrGetCOM(pszInitString);
            if(SUCCEEDED(hr))
            {
                hr = strContainerId.HrGetCOM(pszContainerId);
                if(SUCCEEDED(hr))
                {
                    hr = strResourcePath.HrGetCOM(pszResourcePath);
                    if(SUCCEEDED(hr))
                    {
                        *pnLifeTime = dwLifeTime;
                    }
                }
            }
        }
        if(FAILED(hr))
        {
            // If one fails, they all fail
            if(pszInitString)
            {
                CoTaskMemFree(pszInitString);
                *pszInitString = NULL;
            }
            if(pszContainerId)
            {
                CoTaskMemFree(pszContainerId);
                *pszContainerId = NULL;
            }
            if(pszResourcePath)
            {
                CoTaskMemFree(pszResourcePath);
                *pszResourcePath = NULL;
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::LookupPhysicalDevice");
    return hr;
}

STDMETHODIMP CDevicePersistenceManager::RemovePhysicalDevice(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier)
{
    HRESULT hr = S_OK;

    // Create the string to use
    CUString strUuid;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = strUuid.HrInitFromGUID(guidPhysicalDeviceIdentifier);
    }

    if(SUCCEEDED(hr))
    {
        HKEY hKeyDevices;
        hr = HrCreateOrOpenDevicesKey(&hKeyDevices);
        if(SUCCEEDED(hr))
        {
            hr = HrRegDeleteKeyTree(hKeyDevices, strUuid);
            RegCloseKey(hKeyDevices);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::RemovePhysicalDevice");
    return hr;
}

STDMETHODIMP CDevicePersistenceManager::GetPhysicalDevices(
    /*[out]*/ long * pnDevices,
    /*[out, size_is(,*pnDevices)]*/
        GUID ** parguidPhysicalDeviceIdentifiers)
{
    CHECK_POINTER(pnDevices);
    CHECK_POINTER(parguidPhysicalDeviceIdentifiers);
    
    // Set this to NULL at the beginning
    *parguidPhysicalDeviceIdentifiers = NULL;

    HRESULT hr = S_OK;

    // Do work in an array
    CUArray<GUID> arPids;
    HKEY hKeyDevices;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        // Open devices key
        hr = HrCreateOrOpenDevicesKey(&hKeyDevices);
    }

    if(SUCCEEDED(hr))
    {
        DWORD dwSize;
        wchar_t szBuf[_MAX_PATH];
        FILETIME ft;
        DWORD dwIndex = 0;
        UUID uuid;
        while(SUCCEEDED(hr))
        {
            // Enumerate all of the keys
            dwSize = _MAX_PATH;
            hr = HrRegEnumKeyEx(hKeyDevices, dwIndex, szBuf, &dwSize, NULL, NULL, &ft);
            ++dwIndex;
            if(S_OK == hr)
            {
                hr = CLSIDFromString(szBuf, &uuid);
                if(SUCCEEDED(hr))
                {
                    hr = arPids.HrPushBack(uuid);
                }
                else
                {
                    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CDevicePersistenceManager::GetPhysicalDevices - CLSIDFromString failed!");
                    hr = S_OK;
                    // Ignore and skip it - this shouldn't happen
                    continue;
                }
            }
            else
            {
                // This is not an error, we are out of subkeys
                hr = S_OK;
                break;
            }
        }
        RegCloseKey(hKeyDevices);
    }

    // Attempt to copy to output parameters
    if(SUCCEEDED(hr))
    {
        long nCount = arPids.GetCount();
        if(nCount)
        {
            // Allocate output array
            HrCoTaskMemAllocArray(nCount, parguidPhysicalDeviceIdentifiers);
            // Fill in array
            for(long n = 0; n < nCount; ++n)
            {
                (*parguidPhysicalDeviceIdentifiers)[n] = arPids[n];
            }
        }
        else
        {
            *parguidPhysicalDeviceIdentifiers = NULL;
        }
        *pnDevices = nCount;
    }
    if(FAILED(hr))
    {
        *pnDevices = 0;
        if(*parguidPhysicalDeviceIdentifiers)
        {
            CoTaskMemFree(*parguidPhysicalDeviceIdentifiers);
        }
        *parguidPhysicalDeviceIdentifiers = NULL;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::GetPhysicalDevices");
    return hr;
}

STDMETHODIMP CDevicePersistenceManager::SaveDeviceProvider(
    /*[in, string]*/ const wchar_t * szProviderName,
    /*[in, string]*/ const wchar_t * szProgIdProviderClass,
    /*[in, string]*/ const wchar_t * szInitString,
    /*[in, string]*/ const wchar_t * szContainerId)
{
    CHECK_POINTER(szProviderName);
    CHECK_POINTER(szProgIdProviderClass);
    CHECK_POINTER(szInitString);
    CHECK_POINTER(szContainerId);

    HRESULT hr = S_OK;

    HKEY hKeyProviders;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = HrCreateOrOpenProvidersKey(&hKeyProviders);
    }

    if(SUCCEEDED(hr))
    {
        // Create key to house values
        HKEY hKeyProviderName;
        DWORD dwDisposition = 0;
        hr = HrRegCreateKeyEx(hKeyProviders, szProviderName, 0, KEY_ALL_ACCESS, NULL, &hKeyProviderName, &dwDisposition);
        if(SUCCEEDED(hr))
        {
            // Save all of the values
            hr = HrRegSetSz(hKeyProviderName, c_szProgIdProviderClass, szProgIdProviderClass);
            if(SUCCEEDED(hr))
            {
                hr = HrRegSetSz(hKeyProviderName, c_szInitString, szInitString);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegSetSz(hKeyProviderName, c_szContainerId, szContainerId);
                }
            }
            RegCloseKey(hKeyProviderName);
            if(FAILED(hr))
            {
                // If anything fails, remove the whole tree
                HrRegDeleteKeyTree(hKeyProviders, szProviderName);
            }
        }
        RegCloseKey(hKeyProviders);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::SaveDeviceProvider");
    return hr;
}

STDMETHODIMP CDevicePersistenceManager::LookupDeviceProvider(
    /*[in, string]*/ const wchar_t * szProviderName,
    /*[out, string]*/ wchar_t ** pszProgIdProviderClass,
    /*[out, string]*/ wchar_t ** pszInitString,
    /*[out, string]*/ wchar_t ** pszContainerId)
{
    CHECK_POINTER(szProviderName);
    CHECK_POINTER(pszProgIdProviderClass);
    CHECK_POINTER(pszInitString);
    CHECK_POINTER(pszContainerId);

    HRESULT hr = S_OK;

    CUString strProgIdProviderClass;
    CUString strInitString;
    CUString strContainerId;
        
    HKEY hKeyProviders;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = HrCreateOrOpenProvidersKey(&hKeyProviders);
    }

    if(SUCCEEDED(hr))
    {
        // Open the key housing the values
        HKEY hKeyProviderName;
        DWORD dwDisposition = 0;
        hr = HrRegOpenKeyEx(hKeyProviders, szProviderName, KEY_ALL_ACCESS, &hKeyProviderName);
        if(SUCCEEDED(hr))
        {
            // Load all of the values
            hr = HrRegQueryString(hKeyProviderName, c_szProgIdProviderClass, strProgIdProviderClass);
            if(SUCCEEDED(hr))
            {
                hr = HrRegQueryString(hKeyProviderName, c_szInitString, strInitString);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegQueryString(hKeyProviderName, c_szContainerId, strContainerId);
                }
            }
            RegCloseKey(hKeyProviderName);
        }
        RegCloseKey(hKeyProviders);
    }
    // Set strings to NULL
    *pszProgIdProviderClass = NULL;
    *pszInitString = NULL;
    *pszContainerId = NULL;
    // On success set the out params
    if(SUCCEEDED(hr))
    {
        hr = strProgIdProviderClass.HrGetCOM(pszProgIdProviderClass);
        if(SUCCEEDED(hr))
        {
            hr = strInitString.HrGetCOM(pszInitString);
            if(SUCCEEDED(hr))
            {
                hr = strContainerId.HrGetCOM(pszContainerId);
            }
        }
        if(FAILED(hr))
        {
            // If one fails, they all fail
            if(pszInitString)
            {
                CoTaskMemFree(pszInitString);
                *pszInitString = NULL;
            }
            if(pszContainerId)
            {
                CoTaskMemFree(pszContainerId);
                *pszContainerId = NULL;
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::LookupDeviceProvider");
    return hr;
}

STDMETHODIMP CDevicePersistenceManager::RemoveDeviceProvider(
    /*[in, string]*/ const wchar_t * szProviderName)
{
    HRESULT hr = S_OK;

    HKEY hKeyProviders;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = HrCreateOrOpenProvidersKey(&hKeyProviders);
    }

    if(SUCCEEDED(hr))
    {
        hr = HrRegDeleteKeyTree(hKeyProviders, szProviderName);
        RegCloseKey(hKeyProviders);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::RemoveDeviceProvider");
    return hr;
}

STDMETHODIMP CDevicePersistenceManager::GetDeviceProviders(
    /*[out]*/ long * pnProviders,
    /*[out, string, size_is(,*pnProviders,)]*/
        wchar_t *** parszProviderNames)
{
    CHECK_POINTER(pnProviders);
    CHECK_POINTER(parszProviderNames);
    
    // Set this to NULL at the beginning
    *parszProviderNames = NULL;

    HRESULT hr = S_OK;

    // Do work in an array
    CUArray<wchar_t*> arszProviders;
    HKEY hKeyProviders;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        // Open devices key
      
        hr = HrCreateOrOpenProvidersKey(&hKeyProviders);
    }

    if(SUCCEEDED(hr))
    {
        DWORD dwSize;
        wchar_t szBuf[_MAX_PATH];
        FILETIME ft;
        DWORD dwIndex = 0;
        while(SUCCEEDED(hr))
        {
            // Enumerate all of the keys
            dwSize = _MAX_PATH;
            hr = HrRegEnumKeyEx(hKeyProviders, dwIndex, szBuf, &dwSize, NULL, NULL, &ft);
            if(S_OK == hr)
            {
                wchar_t * sz = NULL;
                hr = HrCoTaskMemAllocString(szBuf, &sz);
                if(SUCCEEDED(hr))
                {
                    // Insert pointer to dynamically allocated string
                    hr = arszProviders.HrPushBack(sz);
                }
            }
            else
            {
                // This is not an error, we have no more subkeys
                hr = S_OK;
                break;
            }
            ++dwIndex;
        }
        RegCloseKey(hKeyProviders);
    }

    // Attempt to copy to output parameters
    if(SUCCEEDED(hr))
    {
        long nCount = arszProviders.GetCount();
        if(nCount)
        {
            // Allocate output array
            HrCoTaskMemAllocArray(nCount, parszProviderNames);
            // Fill in array
            for(long n = 0; n < nCount; ++n)
            {
                (*parszProviderNames)[n] = arszProviders[n];
            }
        }
        else
        {
            *parszProviderNames = NULL;
        }
        *pnProviders = nCount;
    }
    if(FAILED(hr))
    {
        *pnProviders = 0;
        if(*parszProviderNames)
        {
            CoTaskMemFree(*parszProviderNames);
        }
        *parszProviderNames = NULL;
        // Cleanup dynamically allocated strings
        long nCount = arszProviders.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            CoTaskMemFree(arszProviders[n]);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDevicePersistenceManager::GetDeviceProviders");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\dynamiccontentsource.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C D Y N A M I C C O N T E N T S O U R C E . C P P 
//
//  Contents:   
//
//  Notes:      
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "hostp.h"
#include "DynamicContentSource.h"
#include "uhsync.h"
#include "uhcommon.h"

CDynamicContentSource::CDynamicContentSource()
{
}

STDMETHODIMP CDynamicContentSource::GetContent(
    /*[in]*/ REFGUID guidContent,
    /*[out]*/ long * pnHeaderCount,
    /*[out, string, size_is(,*pnHeaderCount,)]*/ wchar_t *** parszHeaders,
    /*[out]*/ long * pnBytes,
    /*[out, size_is(,*pnBytes)]*/ byte ** parBytes)
{
    CHECK_POINTER(pnHeaderCount);
    CHECK_POINTER(parszHeaders);
    CHECK_POINTER(pnBytes);
    CHECK_POINTER(parBytes);
    
    CALock lock(*this);
    HRESULT hr = E_INVALIDARG;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        long nCount = m_providerArray.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            hr = m_providerArray[n]->GetContent(
                guidContent, 
                pnHeaderCount, 
                parszHeaders, 
                pnBytes, 
                parBytes);
            if(FAILED(hr) || S_OK == hr)
            {
                break;
            }
        }
        if(S_FALSE == hr)
        {
            TraceTag(ttidError, "CDynamicContentSource::GetContent - cannot find content");
            // We didn't find anything so convert to an error
            hr = E_INVALIDARG;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDynamicContentSource::GetContent");
    return hr;
}

STDMETHODIMP CDynamicContentSource::RegisterProvider(
    /*[in]*/ IUPnPDynamicContentProvider * pProvider)
{
    CHECK_POINTER(pProvider);
    CALock lock(*this);

    HRESULT hr = S_OK;
    IUPnPDynamicContentProviderPtr p;
    p = pProvider;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = m_providerArray.HrPushBack(p);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDynamicContentSource::RegisterProvider");
    return hr;
}

STDMETHODIMP CDynamicContentSource::UnregisterProvider(
    /*[in]*/ IUPnPDynamicContentProvider * pProvider)
{
    CHECK_POINTER(pProvider);
    CALock lock(*this);

    HRESULT hr = S_OK;
    IUPnPDynamicContentProviderPtr p;
    p = pProvider;
    long nIndex = 0;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = m_providerArray.HrFind(p, nIndex);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_providerArray.HrErase(nIndex);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CDynamicContentSource::UnregisterProvider");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\dynamiccontentsource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C D Y N A M I C C O N T E N T S O U R C E . H
//
//  Contents:
//
//  Notes:
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "ComUtility.h"
#include "Array.h"
#include "hostp.h"

/////////////////////////////////////////////////////////////////////////////
// TestObject
class ATL_NO_VTABLE CDynamicContentSource :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CDynamicContentSource, &CLSID_UPnPDynamicContentSource>,
    public IUPnPDynamicContentSource
{
public:
    CDynamicContentSource();

DECLARE_CLASSFACTORY_SINGLETON(CDynamicContentSource)

DECLARE_REGISTRY_RESOURCEID(IDR_DYNAMIC_CONTENT_SOURCE)

DECLARE_NOT_AGGREGATABLE(CDynamicContentSource)

BEGIN_COM_MAP(CDynamicContentSource)
    COM_INTERFACE_ENTRY(IUPnPDynamicContentSource)
END_COM_MAP()

public:
    // IUPnPDynamicContentSource methods
    STDMETHOD(GetContent)(
        /*[in]*/ REFGUID guidContent,
        /*[out]*/ long * pnHeaderCount,
        /*[out, string, size_is(,*pnHeaderCount,)]*/ wchar_t *** parszHeaders,
        /*[out]*/ long * pnBytes,
        /*[out, size_is(,*pnBytes)]*/ byte ** parBytes);
    STDMETHOD(RegisterProvider)(
        /*[in]*/ IUPnPDynamicContentProvider * pProvider);
    STDMETHOD(UnregisterProvider)(
        /*[in]*/ IUPnPDynamicContentProvider * pProvider);

private:
    typedef SmartComPtr<IUPnPDynamicContentProvider> IUPnPDynamicContentProviderPtr;
    typedef CUArray<IUPnPDynamicContentProviderPtr> ProviderArray;

    ProviderArray m_providerArray;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\providermanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       P R O V I D E R M A N A G E R . H 
//
//  Contents:   Registrar helper object for managing providers.
//
//  Notes:      
//
//  Author:     mbend   14 Sep 2000
//
//----------------------------------------------------------------------------


#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"
#include "UString.h"
#include "ComUtility.h"
#include "Table.h"
#include "RegDef.h"
#include "Provider.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CProviderManager
class CProviderManager 
{
public:
    CProviderManager();
    ~CProviderManager();

    // Lifetime operations
    HRESULT HrShutdown();

    // Provider registration
    HRESULT HrRegisterProvider(
        const wchar_t * szProviderName,
        const wchar_t * szProgIDProviderClass,
        const wchar_t * szInitString,
        const wchar_t * szContainerId);
    HRESULT UnegisterProvider(
        const wchar_t * szProviderName);
private:
    CProviderManager(const CProviderManager &);
    CProviderManager & operator=(const CProviderManager &);

    typedef CTable<CUString, CProvider> ProviderTable;

    ProviderTable m_providerTable;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\providermanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       P R O V I D E R M A N A G E R . C P P
//
//  Contents:   Registrar helper object for managing providers.
//
//  Notes:
//
//  Author:     mbend   14 Sep 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "ProviderManager.h"

CProviderManager::CProviderManager()
{
}

CProviderManager::~CProviderManager()
{
}

HRESULT CProviderManager::HrShutdown()
{
    TraceTag(ttidRegistrar, "CProviderManager::HrShutdown");
    HRESULT hr = S_OK;

    m_providerTable.Clear();

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CProviderManager::HrShutdown");
    return hr;
}

HRESULT CProviderManager::HrRegisterProvider(
    const wchar_t * szProviderName,
    const wchar_t * szProgIDProviderClass,
    const wchar_t * szInitString,
    const wchar_t * szContainerId)
{
    CHECK_POINTER(szProviderName);
    CHECK_POINTER(szProgIDProviderClass);
    CHECK_POINTER(szInitString);
    CHECK_POINTER(szContainerId);
    TraceTag(ttidRegistrar, "CProviderManager::HrRegisterProvider");
    HRESULT hr = S_OK;

    CLSID   clsid;

    // Ensure we have a valid ProgID
    hr = CLSIDFromProgID(szProgIDProviderClass, &clsid);
    if (SUCCEEDED(hr))
    {
        CUString strProviderName;
        hr = strProviderName.HrAssign(szProviderName);
        if(SUCCEEDED(hr))
        {
            CProvider * pProvider;

            // First check if the provider has already been registered and
            // continue only if we get back an error indicating it is not yet in
            // the table
            //
            hr = m_providerTable.HrLookup(strProviderName, &pProvider);
            if (FAILED(hr))
            {
                CProvider   provider;

                hr = provider.HrInitialize(szProgIDProviderClass, szInitString,
                                           szContainerId);
                if(SUCCEEDED(hr))
                {
                    hr = m_providerTable.HrInsertTransfer(strProviderName,
                                                          provider);
                }
            }
            else
            {
                hr = UPNP_E_DUPLICATE_NOT_ALLOWED;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }


    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CProviderManager::HrRegisterProvider");
    return hr;
}

HRESULT CProviderManager::UnegisterProvider(
    const wchar_t * szProviderName)
{
    CHECK_POINTER(szProviderName);
    TraceTag(ttidRegistrar, "CProviderManager::UnegisterDeviceProvider");
    HRESULT hr = S_OK;

    CUString strProviderName;
    hr = strProviderName.HrAssign(szProviderName);
    if(SUCCEEDED(hr))
    {
        hr = m_providerTable.HrErase(strProviderName);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CProviderManager::UnegisterDeviceProvider");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\physicaldeviceinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       P H Y S I C A L D E V I C E I N F O . C P P
//
//  Contents:   Manages an UPnP device assembly
//
//  Notes:
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "PhysicalDeviceInfo.h"
#include "uhutil.h"

CPhysicalDeviceInfo::CPhysicalDeviceInfo()
{
    m_bRunning = FALSE;
}

CPhysicalDeviceInfo::~CPhysicalDeviceInfo()
{
    Clear();
}

HRESULT CPhysicalDeviceInfo::HrInitialize(
    const wchar_t * szProgIdDeviceControlClass,
    const wchar_t * szInitString,
    const wchar_t * szContainerId,
    long nUDNs,
    wchar_t * arszUDNs[])
{
    CHECK_POINTER(szProgIdDeviceControlClass);
    CHECK_POINTER(szInitString);
    CHECK_POINTER(szContainerId);
    TraceTag(ttidRegistrar, "CPhysicalDeviceInfo::HrInitialize(ProgId=%S)", szProgIdDeviceControlClass);
    HRESULT hr = S_OK;

    hr = m_strProgIdDeviceControl.HrAssign(szProgIdDeviceControlClass);
    if(SUCCEEDED(hr))
    {
        hr = m_strInitString.HrAssign(szInitString);
        if(SUCCEEDED(hr))
        {
            hr = m_strContainerId.HrAssign(szContainerId);
            if(SUCCEEDED(hr))
            {
                for(long n = 0; n < nUDNs && SUCCEEDED(hr); ++n)
                {
                    CDeviceInfo deviceInfo;
                    CUString strUDN;
                    hr = strUDN.HrAssign(arszUDNs[n]);
                    if(SUCCEEDED(hr))
                    {
                        hr = m_deviceTable.HrInsertTransfer(strUDN, deviceInfo);
                    }
                }
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CPhysicalDeviceInfo::HrInitialize");
    return hr;
}

HRESULT CPhysicalDeviceInfo::HrInitializeRunning(
    const PhysicalDeviceIdentifier & pdi,
    IUnknown * pUnkDeviceControl,
    const wchar_t * szInitString,
    long nUDNs,
    wchar_t * arszUDNs[])
{
    CHECK_POINTER(pUnkDeviceControl);
    CHECK_POINTER(szInitString);
    TraceTag(ttidRegistrar, "CPhysicalDeviceInfo::HrInitializeRunning");
    HRESULT hr = S_OK;

    m_bRunning = TRUE;

    hr = m_strInitString.HrAssign(szInitString);
    if(SUCCEEDED(hr))
    {
        HrEnableStaticCloaking(pUnkDeviceControl);
        hr = m_pDeviceControl.HrAttach(pUnkDeviceControl);
        if(SUCCEEDED(hr))
        {
            hr = m_pDeviceControl.HrEnableStaticCloaking();
        }
        if(SUCCEEDED(hr))
        {
            CUString strPdi;
            hr = HrPhysicalDeviceIdentifierToString(pdi, strPdi);
            if(SUCCEEDED(hr))
            {
                // Convert to BSTRs
                BSTR bstrPdi = NULL;
                hr = strPdi.HrGetBSTR(&bstrPdi);
                if(SUCCEEDED(hr))
                {
                    BSTR bstrInitString = NULL;
                    hr = m_strInitString.HrGetBSTR(&bstrInitString);
                    if(SUCCEEDED(hr))
                    {
                        // Get description text
                        BSTR bstrDescriptionDocument = NULL;
                        IUPnPRegistrarPrivatePtr pPriv;
                        hr = pPriv.HrCreateInstanceInproc(CLSID_UPnPRegistrar);
                        if(SUCCEEDED(hr))
                        {
                            hr = pPriv->GetDescriptionText(pdi, &bstrDescriptionDocument);
                            if(SUCCEEDED(hr))
                            {
                                hr = m_pDeviceControl->Initialize(
                                    bstrDescriptionDocument, bstrPdi, bstrInitString);
                                SysFreeString(bstrDescriptionDocument);
                                TraceHr(ttidRegistrar, FAL, hr, FALSE, "CPhysicalDeviceInfo::HrInitializeRunning - IUPnPDeviceControl::Initialize failed!");
                            }
                        }
                        SysFreeString(bstrInitString);
                    }
                    SysFreeString(bstrPdi);
                }
            }
            for(long n = 0; n < nUDNs && SUCCEEDED(hr); ++n)
            {
                CDeviceInfo deviceInfo;
                CUString strUDN;
                hr = strUDN.HrAssign(arszUDNs[n]);
                if(SUCCEEDED(hr))
                {
                    hr = m_deviceTable.HrInsertTransfer(strUDN, deviceInfo);
                }
            }
        }
    }
    if(FAILED(hr) && m_pDeviceControl.GetRawPointer())
    {
        m_pDeviceControl.Release();
        HrDereferenceContainer(m_strContainerId);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CPhysicalDeviceInfo::HrInitializeRunning");
    return hr;
}

HRESULT CPhysicalDeviceInfo::HrGetService(
    const PhysicalDeviceIdentifier & pdi,
    const wchar_t * szUDN,
    const wchar_t * szServiceId,
    CServiceInfo ** ppServiceInfo)
{
    CHECK_POINTER(szUDN);
    CHECK_POINTER(szServiceId);
    CHECK_POINTER(ppServiceInfo);
    TraceTag(ttidRegistrar, "CPhysicalDeviceInfo::HrGetService(UDN=%S, ServiceId=%S)", szUDN, szServiceId);
    HRESULT hr = S_OK;

    // See if our device control object is running, create it if not
    if(!m_pDeviceControl)
    {
        // Create the device control object
        hr = HrCreateAndReferenceContainedObjectByProgId(m_strContainerId, m_strProgIdDeviceControl, SMART_QI(m_pDeviceControl));
        if(SUCCEEDED(hr))
        {
            CUString strPdi;
            hr = HrPhysicalDeviceIdentifierToString(pdi, strPdi);
            if(SUCCEEDED(hr))
            {
                // Convert to BSTRs
                BSTR bstrPdi = NULL;
                hr = strPdi.HrGetBSTR(&bstrPdi);
                if(SUCCEEDED(hr))
                {
                    BSTR bstrInitString = NULL;
                    hr = m_strInitString.HrGetBSTR(&bstrInitString);
                    if(SUCCEEDED(hr))
                    {
                        // Get description text
                        BSTR bstrDescriptionDocument = NULL;
                        IUPnPRegistrarPrivatePtr pPriv;
                        hr = pPriv.HrCreateInstanceInproc(CLSID_UPnPRegistrar);
                        if(SUCCEEDED(hr))
                        {
                            hr = pPriv->GetDescriptionText(pdi, &bstrDescriptionDocument);
                            if(SUCCEEDED(hr))
                            {
                                hr = m_pDeviceControl->Initialize(
                                    bstrDescriptionDocument, bstrPdi, bstrInitString);
                                SysFreeString(bstrDescriptionDocument);
                            }
                        }
                        SysFreeString(bstrInitString);
                    }
                    SysFreeString(bstrPdi);
                }
            }
        }
    }
    // Now fetch service from device object
    if(SUCCEEDED(hr))
    {
        CUString strUDN;
        hr = strUDN.HrAssign(szUDN);
        if(SUCCEEDED(hr))
        {
            CDeviceInfo * pDeviceInfo = m_deviceTable.Lookup(strUDN);
            if(pDeviceInfo)
            {
                hr = pDeviceInfo->HrGetService(pdi, szUDN, szServiceId, m_strContainerId, m_pDeviceControl, ppServiceInfo, m_bRunning);
            }
            else
            {
                hr = E_INVALIDARG;
                TraceTag(ttidRegistrar, "CPhysicalDeviceInfo::HrGetService - Unable to find UDN(%S)",
                         static_cast<const wchar_t *>(strUDN));
            }
        }
    }
    if(FAILED(hr) && m_pDeviceControl.GetRawPointer())
    {
        m_pDeviceControl.Release();
        HrDereferenceContainer(m_strContainerId);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CPhysicalDeviceInfo::HrGetService");
    return hr;
}

void CPhysicalDeviceInfo::Transfer(CPhysicalDeviceInfo & ref)
{
    // If we have a device object and a container id then deref container
    if(m_pDeviceControl.GetRawPointer() && m_strContainerId.GetLength())
    {
        HrDereferenceContainer(m_strContainerId);
    }

    m_deviceTable.Swap(ref.m_deviceTable);
    m_strProgIdDeviceControl.Transfer(ref.m_strProgIdDeviceControl);
    m_strInitString.Transfer(ref.m_strInitString);
    m_strContainerId.Transfer(ref.m_strContainerId);
    m_pDeviceControl.Swap(ref.m_pDeviceControl);
}

void CPhysicalDeviceInfo::Clear()
{
    // If we have a device object and a container id then deref container
    if(m_pDeviceControl.GetRawPointer() && m_strContainerId.GetLength())
    {
        HrDereferenceContainer(m_strContainerId);
    }

    m_deviceTable.Clear();
    m_strProgIdDeviceControl.Clear();
    m_strInitString.Clear();
    m_strContainerId.Clear();
    m_pDeviceControl.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\provider.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       P R O V I D E R . C P P
//
//  Contents:   Registrar abstraction for a provider.
//
//  Notes:
//
//  Author:     mbend   14 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "Provider.h"
#include "uhutil.h"
#include "uhthread.h"

class CProviderAsync : public CWorkItem
{
public:
    HRESULT HrInitStart(IUPnPDeviceProviderPtr pProvider, const wchar_t * szInitString);
    HRESULT HrInitStop(IUPnPDeviceProviderPtr pProvider);
    DWORD DwRun();
private:
    IUPnPDeviceProviderPtr m_pProvider;
    BOOL m_bStart;
    CUString m_strInitString;
};

HRESULT CProviderAsync::HrInitStart(IUPnPDeviceProviderPtr pProvider, const wchar_t * szInitString)
{
    HRESULT hr = S_OK;

    m_pProvider = pProvider;
    m_bStart = TRUE;

    hr = m_strInitString.HrAssign(szInitString);

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CProviderAsync::HrInitStart");
    return hr;
}

HRESULT CProviderAsync::HrInitStop(IUPnPDeviceProviderPtr pProvider)
{
    HRESULT hr = S_OK;

    m_pProvider = pProvider;
    m_bStart = FALSE;

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CProviderAsync::HrInitStop");
    return hr;
}

DWORD CProviderAsync::DwRun()
{
    TraceTag(ttidRegistrar, "CProviderAsync::DwRun(%x) - starting worker thread", this);
    HRESULT hr = S_OK;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if(SUCCEEDED(hr))
    {
        if(m_bStart)
        {
            BSTR bstrInitString = NULL;
            hr = m_strInitString.HrGetBSTR(&bstrInitString);
            if(SUCCEEDED(hr))
            {
                hr = m_pProvider->Start(bstrInitString);
                SysFreeString(bstrInitString);
            }
        }
        else
        {
            hr = m_pProvider->Stop();
        }
    }
    else
    {
        TraceTag(ttidError, "CProviderAsync::DwRun - CoInitializeEx failed!");
    }
    m_pProvider.Release();

    CoUninitialize();
    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CProviderAsync::DwRun(%x)", this);
    return hr;
}


CProvider::CProvider()
{
}

CProvider::~CProvider()
{
    Clear();
}

HRESULT CProvider::HrInitialize(
    const wchar_t * szProgIDProviderClass,
    const wchar_t * szInitString,
    const wchar_t * szContainerId)
{
    CHECK_POINTER(szProgIDProviderClass);
    CHECK_POINTER(szInitString);
    CHECK_POINTER(szContainerId);
    TraceTag(ttidRegistrar, "CProvider::HrInitialize(ProgId=%S)", szProgIDProviderClass);
    HRESULT hr = S_OK;

    hr = m_strContainerId.HrAssign(szContainerId);
    if(SUCCEEDED(hr))
    {
        hr = HrCreateAndReferenceContainedObjectByProgId(
            szContainerId, szProgIDProviderClass, SMART_QI(m_pDeviceProvider));
        if(SUCCEEDED(hr))
        {
            CProviderAsync * pAsync = new CProviderAsync;
            if(pAsync)
            {
                hr = pAsync->HrInitStart(m_pDeviceProvider, szInitString);
                if(SUCCEEDED(hr))
                {
                    hr = pAsync->HrStart(TRUE);
                }
                if(FAILED(hr))
                {
                    delete pAsync;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                HrDereferenceContainer(szContainerId);
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CProvider::HrInitialize");
    return hr;
}

void CProvider::Transfer(CProvider & ref)
{
    m_strContainerId.Transfer(ref.m_strContainerId);
    m_pDeviceProvider.Swap(ref.m_pDeviceProvider);
}

void CProvider::Clear()
{
    HRESULT hr = S_OK;
    HrDereferenceContainer(m_strContainerId);
    m_strContainerId.Clear();
    if(m_pDeviceProvider)
    {
        CProviderAsync * pAsync = new CProviderAsync;
        if(pAsync)
        {
            hr = pAsync->HrInitStop(m_pDeviceProvider);
            if(SUCCEEDED(hr))
            {
                hr = pAsync->HrStart(TRUE);
            }
            if(FAILED(hr))
            {
                delete pAsync;
            }
        }
    }
    m_pDeviceProvider.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\provider.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       P R O V I D E R . H 
//
//  Contents:   Registrar abstraction for a provider.
//
//  Notes:      
//
//  Author:     mbend   14 Sep 2000
//
//----------------------------------------------------------------------------


#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"
#include "UString.h"
#include "ComUtility.h"
#include "Table.h"
#include "RegDef.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CProvider
class CProvider 
{
public:
    CProvider();
    ~CProvider();

    HRESULT HrInitialize(
        const wchar_t * szProgIDProviderClass,
        const wchar_t * szInitString,
        const wchar_t * szContainerId);

    void Transfer(CProvider & ref);
    void Clear();
private:
    CProvider(const CProvider &);
    CProvider & operator=(const CProvider &);

    CUString m_strContainerId;
    IUPnPDeviceProviderPtr m_pDeviceProvider;
};

inline void TypeTransfer(CProvider & dst, CProvider & src)
{
    dst.Transfer(src);
}

inline void TypeClear(CProvider & type)
{
    type.Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\physicaldeviceinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       P H Y S I C A L D E V I C E I N F O . H 
//
//  Contents:   Manages an UPnP device assembly
//
//  Notes:      
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"
#include "UString.h"
#include "ComUtility.h"
#include "Table.h"
#include "RegDef.h"
#include "DeviceInfo.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CPhysicalDeviceInfo
class CPhysicalDeviceInfo 
{
public:
    CPhysicalDeviceInfo();
    ~CPhysicalDeviceInfo();

    HRESULT HrInitialize(
        const wchar_t * szProgIdDeviceControlClass,
        const wchar_t * szInitString,
        const wchar_t * szContainerId,
        long nUDNs,
        wchar_t * arszUDNs[]);
    HRESULT HrInitializeRunning(
        const PhysicalDeviceIdentifier & pdi,
        IUnknown * pUnkDeviceControl,
        const wchar_t * szInitString,
        long nUDNs,
        wchar_t * arszUDNs[]);
    HRESULT HrGetService(
        const PhysicalDeviceIdentifier & pdi,
        const wchar_t * szUDN,
        const wchar_t * szServiceId,
        CServiceInfo ** ppServiceInfo);

    void Transfer(CPhysicalDeviceInfo & ref);
    void Clear();
private:
    CPhysicalDeviceInfo(const CPhysicalDeviceInfo &);
    CPhysicalDeviceInfo & operator=(const CPhysicalDeviceInfo &);

    typedef CTable<UDN, CDeviceInfo> DeviceTable;

    DeviceTable m_deviceTable;
    CUString m_strProgIdDeviceControl;
    CUString m_strInitString;
    CUString m_strContainerId;
    IUPnPDeviceControlPtr m_pDeviceControl;
    BOOL m_bRunning;
};

inline void TypeTransfer(CPhysicalDeviceInfo & dst, CPhysicalDeviceInfo & src)
{
    dst.Transfer(src);
}

inline void TypeClear(CPhysicalDeviceInfo & type)
{
    type.Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\regdef.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E G D E F . H 
//
//  Contents:   Common definitions for the registrar
//
//  Notes:      
//
//  Author:     mbend   13 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "UString.h"
#include "ComUtility.h"
#include "upnphost.h"
#include "hostp.h"

// Typedefs
typedef CUString UDN;
typedef GUID PhysicalDeviceIdentifier;
typedef CUString Sid;

// COM Smart Pointers
typedef SmartComPtr<IUPnPEventingManager> IUPnPEventingManagerPtr;
typedef SmartComPtr<IUPnPContainer> IUPnPContainerPtr;
typedef SmartComPtr<IUPnPContainerManager> IUPnPContainerManagerPtr;
typedef SmartComPtr<IUPnPDynamicContentProvider> IUPnPDynamicContentProviderPtr;
typedef SmartComPtr<IUPnPDynamicContentSource> IUPnPDynamicContentSourcePtr;
typedef SmartComPtr<IUPnPDescriptionManager> IUPnPDescriptionManagerPtr;
typedef SmartComPtr<IUPnPDevicePersistenceManager> IUPnPDevicePersistenceManagerPtr;
typedef SmartComPtr<IUPnPRegistrarLookup> IUPnPRegistrarLookupPtr;
typedef SmartComPtr<IUPnPRegistrarPrivate> IUPnPRegistrarPrivatePtr;
typedef SmartComPtr<IUPnPAutomationProxy> IUPnPAutomationProxyPtr;
typedef SmartComPtr<IUPnPEventSource> IUPnPEventSourcePtr;
typedef SmartComPtr<IUPnPEventSink> IUPnPEventSinkPtr;
typedef SmartComPtr<IUPnPRegistrar> IUPnPRegistrarPtr;
typedef SmartComPtr<IUPnPReregistrar> IUPnPReregistrarPtr;
typedef SmartComPtr<IUPnPDeviceControl> IUPnPDeviceControlPtr;
typedef SmartComPtr<IUPnPDeviceProvider> IUPnPDeviceProviderPtr;
typedef SmartComPtr<IUPnPValidationManager> IUPnPValidationManagerPtr;
typedef SmartComPtr<IUnknown> IUnknownPtr;
typedef SmartComPtr<IDispatch> IDispatchPtr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\serviceinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S E R V I C E I N F O . H 
//
//  Contents:   Registrar representation on a service
//
//  Notes:      
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"
#include "UString.h"
#include "ComUtility.h"
#include "RegDef.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CServiceInfo
class CServiceInfo 
{
public:
    CServiceInfo();
    ~CServiceInfo();
    
    HRESULT HrInitialize(
        const PhysicalDeviceIdentifier & pdi,
        const wchar_t * szUDN,
        const wchar_t * szServiceId,
        const wchar_t * szContainerId,
        IUPnPDeviceControlPtr & pDeviceControl,
        BOOL bRunning);
    HRESULT HrGetEventingManager(IUPnPEventingManager ** ppEventingManager);
    HRESULT HrGetAutomationProxy(IUPnPAutomationProxy ** ppAutomationProxy);

    void Transfer(CServiceInfo & ref);
    void Clear();
private:
    CServiceInfo(const CServiceInfo &);
    CServiceInfo & operator=(const CServiceInfo &);

    CUString m_strContainerId;
    IDispatchPtr m_pDispService;
    IUPnPEventingManagerPtr m_pEventingManager;
    IUPnPAutomationProxyPtr m_pAutomationProxy;
};

inline void TypeTransfer(CServiceInfo & dst, CServiceInfo & src)
{
    dst.Transfer(src);
}

inline void TypeClear(CServiceInfo & type)
{
    type.Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\registrar.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E G I S T R A R . H
//
//  Contents:   Top level device host object
//
//  Notes:
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "upnphost.h"
#include "hostp.h"
#include "UString.h"
#include "DeviceManager.h"
#include "ProviderManager.h"

// Typedefs

/////////////////////////////////////////////////////////////////////////////
// CRegistrar
class ATL_NO_VTABLE CRegistrar :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CRegistrar, &CLSID_UPnPRegistrar>,
    public IUPnPRegistrarLookup,
    public IUPnPRegistrarPrivate,
    public IUPnPRegistrar,
    public IUPnPReregistrar,
    public ISupportErrorInfo,
    public IUPnPRegistrarICSSupport
{
public:
    CRegistrar();
    ~CRegistrar();

DECLARE_CLASSFACTORY_SINGLETON(CRegistrar)
DECLARE_REGISTRY_RESOURCEID(IDR_REGISTRAR)
DECLARE_NOT_AGGREGATABLE(CRegistrar)

BEGIN_COM_MAP(CRegistrar)
    COM_INTERFACE_ENTRY(IUPnPRegistrarLookup)
    COM_INTERFACE_ENTRY(IUPnPRegistrarPrivate)
    COM_INTERFACE_ENTRY(IUPnPRegistrar)
    COM_INTERFACE_ENTRY(IUPnPReregistrar)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IUPnPRegistrarICSSupport)
END_COM_MAP()

public:
    // ISupportErrorInfo methods
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IUPnPRegistrarLookup methods
    STDMETHOD(GetEventingManager)(
        /*[in, string]*/ const wchar_t * szUDN,
        /*[in, string]*/ const wchar_t * szServiceId,
        /*[out]*/ IUPnPEventingManager ** ppEventingManager);
    STDMETHOD(GetAutomationProxy)(
        /*[in, string]*/ const wchar_t * szUDN,
        /*[in, string]*/ const wchar_t * szServiceId,
        /*[out]*/ IUPnPAutomationProxy ** ppAutomationProxy);

    // IUPnPRegistrarPrivate methods
    STDMETHOD(Initialize)();
    STDMETHOD(Shutdown)();
    STDMETHOD(GetSCPDText)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[in, string]*/ const wchar_t * szUDN,
        /*[in, string]*/ const wchar_t * szServiceId,
        /*[out, string]*/ wchar_t ** pszSCPDText,
        /*[out, string]*/ wchar_t ** pszServiceType);
    STDMETHOD(GetDescriptionText)(
        /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
        /*[out]*/ BSTR * pbstrDescriptionDocument);

    // IUPnPRegistrar methods
    STDMETHOD(RegisterDevice)(
        /*[in]*/ BSTR     bstrXMLDesc,
        /*[in]*/ BSTR     bstrProgIDDeviceControlClass,
        /*[in]*/ BSTR     bstrInitString,
        /*[in]*/ BSTR     bstrContainerId,
        /*[in]*/ BSTR     bstrResourcePath,
        /*[in]*/ long     nLifeTime,
        /*[out, retval]*/ BSTR * pbstrDeviceIdentifier);
    STDMETHOD(RegisterRunningDevice)(
        /*[in]*/ BSTR     bstrXMLDesc,
        /*[in]*/ IUnknown * punkDeviceControl,
        /*[in]*/ BSTR     bstrInitString,
        /*[in]*/ BSTR     bstrResourcePath,
        /*[in]*/ long     nLifeTime,
        /*[out, retval]*/ BSTR * pbstrDeviceIdentifier);
    STDMETHOD(RegisterDeviceProvider)(
        /*[in]*/ BSTR     bstrProviderName,
        /*[in]*/ BSTR     bstrProgIDProviderClass,
        /*[in]*/ BSTR     bstrInitString,
        /*[in]*/ BSTR     bstrContainerId);
    STDMETHOD(GetUniqueDeviceName)(
        /*[in]*/          BSTR   bstrDeviceIdentifier,
        /*[in]*/          BSTR   bstrTemplateUDN,
        /*[out, retval]*/ BSTR * pbstrUDN);
    STDMETHOD(UnregisterDevice)(
        /*[in]*/ BSTR     bstrDeviceIdentifier,
        /*[in]*/ BOOL     fPermanent);
    STDMETHOD(UnregisterDeviceProvider)(
        /*[in]*/ BSTR     bstrProviderName);

    // IUPnPReregistrar methods
    STDMETHOD(ReregisterDevice)(
        /*[in]*/ BSTR     bstrDeviceIdentifier,
        /*[in]*/ BSTR     bstrXMLDesc,
        /*[in]*/ BSTR     bstrProgIDDeviceControlClass,
        /*[in]*/ BSTR     bstrInitString,
        /*[in]*/ BSTR     bstrContainerId,
        /*[in]*/ BSTR     bstrResourcePath,
        /*[in]*/ long     nLifeTime);
    STDMETHOD(ReregisterRunningDevice)(
        /*[in]*/ BSTR     bstrDeviceIdentifier,
        /*[in]*/ BSTR     bstrXMLDesc,
        /*[in]*/ IUnknown * punkDeviceControl,
        /*[in]*/ BSTR     bstrInitString,
        /*[in]*/ BSTR     bstrResourcePath,
        /*[in]*/ long     nLifeTime);

    // IUPnPRegistrarICSSupport methods
    STDMETHOD(SetICSInterfaces)(/*[in]*/ long nCount, /*[in, size_is(nCount)]*/ GUID * arPrivateInterfaceGuids);
    STDMETHOD(SetICSOff)();

private:
    HRESULT HrSetAutoStart();
    HRESULT HrUnregisterDeviceByPDI(PhysicalDeviceIdentifier & pdi, BOOL fPermanent);

    CDeviceManager m_deviceManager;
    CProviderManager m_providerManager;
    IUPnPDescriptionManagerPtr m_pDescriptionManager;
    IUPnPDevicePersistenceManagerPtr m_pDevicePersistenceManager;
    IUPnPValidationManagerPtr m_pValidationManager;
    IUPnPContainerManagerPtr m_pContainerManager;
    IUPnPDynamicContentSourcePtr m_pDynamicContentSource;
    BOOL m_bSetAutoStart;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\registrar.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E G I S T R A R . C P P
//
//  Contents:   Top level device host object
//
//  Notes:
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "hostp.h"
#include "Registrar.h"
#include "upsync.h"
#include "ComUtility.h"
#include "uhutil.h"
#include "ssdpapi.h"
#include "evtapi.h"
#include "InterfaceList.h"
#include "uhcommon.h"

static const int c_minLifeTime = 900;
static const int c_defLifeTime = 1800;

// Helper functions

HRESULT HrSetErrorInfo(
    const wchar_t * szErrorString,
    REFIID riid)
{
    HRESULT hr = S_OK;

    IErrorInfo * pErrorInfo = NULL;
    ICreateErrorInfo * pCreateErrorInfo = NULL;

    hr = CreateErrorInfo(&pCreateErrorInfo);
    if(SUCCEEDED(hr))
    {
        hr = pCreateErrorInfo->SetDescription(const_cast<wchar_t*>(szErrorString));
        if(SUCCEEDED(hr))
        {
            hr = pCreateErrorInfo->SetGUID(riid);
            if(SUCCEEDED(hr))
            {
                hr = pCreateErrorInfo->QueryInterface(&pErrorInfo);
                if(SUCCEEDED(hr))
                {
                    hr = SetErrorInfo(0, pErrorInfo);
                }
            }
        }
    }

    ReleaseObj(pErrorInfo);
    ReleaseObj(pCreateErrorInfo);

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "HrSetErrorInfo(%S)", szErrorString);
    return hr;
}

//
// Verify that the given resource path starts with X:\ where X is a drive
// letter
//
HRESULT HrValidateResourcePath(BSTR bstrPath)
{
    HRESULT     hr = E_INVALIDARG;

    if (!bstrPath)
    {
        hr = E_POINTER;
    }
    else
    {
        if (!FFileExists(bstrPath, TRUE))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
        else
        {
            if (isalpha(bstrPath[0]))
            {
                if (bstrPath[1] == L':')
                {
                    if (bstrPath[2] == L'\\')
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "HrValidateResourcePath");
    return hr;
}

// Constructors and destructors

CRegistrar::CRegistrar() : m_bSetAutoStart(FALSE)
{
}

CRegistrar::~CRegistrar()
{
}

// ISupportErrorInfo methods

STDMETHODIMP CRegistrar::InterfaceSupportsErrorInfo(REFIID riid)
{
    HRESULT hr = S_FALSE;

    if(riid == IID_IUPnPRegistrar || riid == IID_IUPnPReregistrar)
    {
        hr = S_OK;
    }

    return hr;
}

// IUPnPRegistrarLookup methods

STDMETHODIMP CRegistrar::GetEventingManager(
    /*[in, string]*/ const wchar_t * szUDN,
    /*[in, string]*/ const wchar_t * szServiceId,
    /*[out]*/ IUPnPEventingManager ** ppEventingManager)
{
    TraceTag(ttidRegistrar, "CRegistrar::GetEventingManager");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC );
    
    if ( SUCCEEDED( hr ) )
    {
        CServiceInfo * pServiceInfo = NULL;
        hr = m_deviceManager.HrGetService(szUDN, szServiceId, &pServiceInfo);
        if(SUCCEEDED(hr))
        {
            hr = pServiceInfo->HrGetEventingManager(ppEventingManager);
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::GetEventingManager");
    return hr;
}

STDMETHODIMP CRegistrar::GetAutomationProxy(
    /*[in, string]*/ const wchar_t * szUDN,
    /*[in, string]*/ const wchar_t * szServiceId,
    /*[out]*/ IUPnPAutomationProxy ** ppAutomationProxy)
{
    TraceTag(ttidRegistrar, "CRegistrar::GetAutomationProxy");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        CServiceInfo * pServiceInfo = NULL;
        hr = m_deviceManager.HrGetService(szUDN, szServiceId, &pServiceInfo);
        if(SUCCEEDED(hr))
        {
            hr = pServiceInfo->HrGetAutomationProxy(ppAutomationProxy);
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::GetAutomationProxy");
    return hr;
}

// IUPnPRegistrarPrivate methods

STDMETHODIMP CRegistrar::Initialize()
{
    TraceTag(ttidRegistrar,"CRegistrar::Initialize");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        hr = CUPnPInterfaceList::Instance().HrInitialize();
    }

    if(SUCCEEDED(hr))
    {
        hr = HrInitEventApi();
    }

    if (SUCCEEDED(hr))
    {
        SsdpStartup();

        hr = m_pDescriptionManager.HrCreateInstanceInproc(CLSID_UPnPDescriptionManager);
        if(SUCCEEDED(hr))
        {
            hr = m_pDevicePersistenceManager.HrCreateInstanceInproc(CLSID_UPnPDevicePersistenceManager);
            if(SUCCEEDED(hr))
            {
                IUPnPDynamicContentSourcePtr pDynamicContentSource;
                hr = pDynamicContentSource.HrCreateInstanceInproc(CLSID_UPnPDynamicContentSource);
                if(SUCCEEDED(hr))
                {
                    IUPnPDynamicContentProviderPtr pDynamicContentProvider;
                    hr = pDynamicContentProvider.HrAttach(m_pDescriptionManager);
                    if(SUCCEEDED(hr))
                    {
                        hr = pDynamicContentSource->RegisterProvider(pDynamicContentProvider);
                        if(SUCCEEDED(hr))
                        {
                            hr = m_pValidationManager.HrCreateInstanceInproc(CLSID_UPnPValidationManager);
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pContainerManager.HrCreateInstanceInproc(CLSID_UPnPContainerManager);
        if (SUCCEEDED(hr))
        {
            hr = m_pDynamicContentSource.HrCreateInstanceInproc(CLSID_UPnPDynamicContentSource);
        }
    }


    // Get the PDIs
    if(SUCCEEDED(hr))
    {
        long nDevices = 0;
        GUID * arPdi;
        hr = m_pDevicePersistenceManager->GetPhysicalDevices(&nDevices, &arPdi);
        if(SUCCEEDED(hr))
        {
            // Bring each persistent device to life
            for(long n = 0; n < nDevices; ++n)
            {
                // Use a temporary HRESULT because we don't want one thing to cause everything to fail
                HRESULT hrTemp = S_OK;
                wchar_t * szProgIdDeviceControlClass = NULL;
                wchar_t * szInitString = NULL;
                wchar_t * szContainerId = NULL;
                wchar_t * szResourcePath = NULL;
                long nLifetime = 0;
                hrTemp = m_pDevicePersistenceManager->LookupPhysicalDevice(
                    arPdi[n], &szProgIdDeviceControlClass, &szInitString, &szContainerId, &szResourcePath, &nLifetime);
                if(SUCCEEDED(hrTemp))
                {
                    // Load the description document
                    hrTemp = m_pDescriptionManager->LoadDescription(arPdi[n]);
                    if(SUCCEEDED(hrTemp))
                    {
                        // Get the UDNs
                        wchar_t ** arszUDNs = NULL;
                        long nUDNCount = 0;
                        hrTemp = m_pDescriptionManager->GetUDNs(arPdi[n], &nUDNCount, &arszUDNs);
                        if(SUCCEEDED(hrTemp))
                        {
                            // Add device
                            hrTemp = m_deviceManager.HrAddDevice(arPdi[n], szProgIdDeviceControlClass, szInitString,
                                                        szContainerId, nUDNCount, arszUDNs);
                            if(SUCCEEDED(hrTemp))
                            {
                                // Publish the device
                                hrTemp = m_pDescriptionManager->PublishDescription(arPdi[n], nLifetime);
                            }
                            // Free UDNs
                            for(long n = 0; n < nUDNCount; ++n)
                            {
                                CoTaskMemFree(arszUDNs[n]);
                            }
                            CoTaskMemFree(arszUDNs);
                        }
                    }
                    TraceHr(ttidError, FAL, hr, FALSE, "CRegistrar::Initialize - Failed to init device (ProgId=%S)",
                            szProgIdDeviceControlClass);
                    CoTaskMemFree(szProgIdDeviceControlClass);
                    CoTaskMemFree(szInitString);
                    CoTaskMemFree(szContainerId);
                    CoTaskMemFree(szResourcePath);
                }
            }
            CoTaskMemFree(arPdi);
        }
    }

    // Do the providers
    if(SUCCEEDED(hr))
    {
        long nProviders = 0;
        wchar_t ** arszProviderNames = NULL;
        hr = m_pDevicePersistenceManager->GetDeviceProviders(&nProviders, &arszProviderNames);
        if(SUCCEEDED(hr))
        {
            // Load each provider
            long n;
            for(n = 0; n < nProviders; ++n)
            {
                HRESULT hrTemp = S_OK;
                wchar_t * szProgIdProviderClass = NULL;
                wchar_t * szInitString = NULL;
                wchar_t * szContainerId = NULL;
                hrTemp = m_pDevicePersistenceManager->LookupDeviceProvider(
                    arszProviderNames[n], &szProgIdProviderClass, &szInitString, &szContainerId);
                if(SUCCEEDED(hrTemp))
                {
                    hrTemp = m_providerManager.HrRegisterProvider(
                        arszProviderNames[n], szProgIdProviderClass, szInitString, szContainerId);
                    TraceHr(ttidError, FAL, hr, FALSE, "CRegistrar::Initialize - Failed to load provider (%S)", arszProviderNames[n]);
                    CoTaskMemFree(szProgIdProviderClass);
                    CoTaskMemFree(szInitString);
                    CoTaskMemFree(szContainerId);
                }
            }
            for(n = 0; n < nProviders; ++n)
            {
                CoTaskMemFree(arszProviderNames[n]);
            }
            CoTaskMemFree(arszProviderNames);
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::Initialize");
    return hr;
}

STDMETHODIMP CRegistrar::Shutdown()
{
    TraceTag(ttidRegistrar, "CRegistrar::Shutdown");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        if (m_pDynamicContentSource)
        {
            IUPnPDynamicContentProviderPtr pDynamicContentProvider;
            hr = pDynamicContentProvider.HrAttach(m_pDescriptionManager);
            if(SUCCEEDED(hr))
            {
                hr = m_pDynamicContentSource->UnregisterProvider(pDynamicContentProvider);
            }
            m_pDynamicContentSource.Release();
        }
        
        m_pDescriptionManager.Release();
        m_pDevicePersistenceManager.Release();
        m_pValidationManager.Release();
        m_providerManager.HrShutdown();
        m_deviceManager.HrShutdown();
        if (m_pContainerManager)
        {
            m_pContainerManager->Shutdown();
        }
        m_pContainerManager.Release();
        SsdpCleanup();
        DeInitEventApi();
        CUPnPInterfaceList::Instance().HrShutdown();
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::Shutdown");
    return hr;
}

STDMETHODIMP CRegistrar::GetSCPDText(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[in, string]*/ const wchar_t * szUDN,
    /*[in, string]*/ const wchar_t * szServiceId,
    /*[out, string]*/ wchar_t ** pszSCPDText,
    /*[out, string]*/ wchar_t ** pszServiceType)
{
    TraceTag(ttidRegistrar, "CRegistrar::GetSCPDText(UDN=%S, ServiceId=%S)", szUDN, szServiceId);
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pDescriptionManager->GetSCPDText(guidPhysicalDeviceIdentifier, szUDN, 
                                                szServiceId, pszSCPDText, pszServiceType);

    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::GetSCPDText");
    return hr;
}

STDMETHODIMP CRegistrar::GetDescriptionText(
    /*[in]*/ REFGUID guidPhysicalDeviceIdentifier,
    /*[out]*/ BSTR * pbstrDescriptionDocument)
{
    TraceTag(ttidRegistrar, "CRegistrar::GetDescriptionText");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) CALL_LOCALITY_INPROC);
    
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pDescriptionManager->GetDescriptionText(guidPhysicalDeviceIdentifier, 
                                                       pbstrDescriptionDocument);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::GetDescriptionText");
    return hr;
}


// IUPnPRegistrar methods

STDMETHODIMP CRegistrar::RegisterDevice(
    /*[in]*/ BSTR     bstrXMLDesc,
    /*[in]*/ BSTR     bstrProgIDDeviceControlClass,
    /*[in]*/ BSTR     bstrInitString,
    /*[in]*/ BSTR     bstrContainerId,
    /*[in]*/ BSTR     bstrResourcePath,
    /*[in]*/ long     nLifeTime,
    /*[out, retval]*/ BSTR * pbstrDeviceIdentifier)
{
    TraceTag(ttidRegistrar,"CRegistrar::RegisterDevice");
    HRESULT hr = S_OK;
    BOOL fAllowed = FALSE;

    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));

    if(SUCCEEDED(hr))
    {
        hr = HrValidateResourcePath(bstrResourcePath);
    }
    
    if (SUCCEEDED(hr))
    {
        // Do validation
        wchar_t * szErrorString = NULL;
        hr = m_pValidationManager->ValidateDescriptionDocumentAndReferences(
            bstrXMLDesc, bstrResourcePath, &szErrorString);
        if(FAILED(hr))
        {
            HrSetErrorInfo(szErrorString, IID_IUPnPRegistrar);
            return hr;
        }
        if(szErrorString)
        {
            CoTaskMemFree(szErrorString);
            szErrorString = NULL;
        }

        if (!nLifeTime)
        {
            nLifeTime = c_defLifeTime;
        }
        else if (nLifeTime < c_minLifeTime)
        {
            hr = E_INVALIDARG;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HrSetAutoStart();
    }

    if (SUCCEEDED(hr))
    {
        // Process the description document
        PhysicalDeviceIdentifier pdi;
        hr = m_pDescriptionManager->ProcessDescriptionTemplate(
            bstrXMLDesc, bstrResourcePath, &pdi, TRUE, FALSE);
        if(SUCCEEDED(hr))
        {
            // Get the UDNs
            wchar_t ** arszUDNs = NULL;
            long nUDNCount = 0;
            hr = m_pDescriptionManager->GetUDNs(pdi, &nUDNCount, &arszUDNs);
            if(SUCCEEDED(hr))
            {
                // Add device
                hr = m_deviceManager.HrAddDevice(pdi, bstrProgIDDeviceControlClass, bstrInitString,
                                            bstrContainerId, nUDNCount, arszUDNs);
                if(SUCCEEDED(hr))
                {
                    // Save the device
                    hr = m_pDevicePersistenceManager->SavePhyisicalDevice(
                        pdi, bstrProgIDDeviceControlClass, bstrInitString, bstrContainerId, bstrResourcePath, nLifeTime);
                    if(SUCCEEDED(hr))
                    {
                        // Publish the device
                        hr = m_pDescriptionManager->PublishDescription(pdi, nLifeTime);
                        if(SUCCEEDED(hr))
                        {
                            CUString strPdi;
                            hr = HrPhysicalDeviceIdentifierToString(pdi, strPdi);
                            if(SUCCEEDED(hr))
                            {
                                hr = strPdi.HrGetBSTR(pbstrDeviceIdentifier);
                            }
                        }
                    }
                }
                // Free UDNs
                for(long n = 0; n < nUDNCount; ++n)
                {
                    CoTaskMemFree(arszUDNs[n]);
                }
                CoTaskMemFree(arszUDNs);
            }

            if (FAILED(hr))
            {
                HrUnregisterDeviceByPDI(pdi, TRUE);
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::RegisterDevice");
    return hr;
}

STDMETHODIMP CRegistrar::RegisterRunningDevice(
    /*[in]*/ BSTR     bstrXMLDesc,
    /*[in]*/ IUnknown * punkDeviceControl,
    /*[in]*/ BSTR     bstrInitString,
    /*[in]*/ BSTR     bstrResourcePath,
    /*[in]*/ long     nLifeTime,
    /*[out, retval]*/ BSTR * pbstrDeviceIdentifier)
{
    TraceTag(ttidRegistrar, "CRegistrar::RegisterRunningDevice");
    HRESULT hr = S_OK;

    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    if(SUCCEEDED(hr))
    {
        hr = HrValidateResourcePath(bstrResourcePath);
    }
    if (SUCCEEDED(hr))
    {
        // Do validation
        wchar_t * szErrorString = NULL;
        hr = m_pValidationManager->ValidateDescriptionDocumentAndReferences(
            bstrXMLDesc, bstrResourcePath, &szErrorString);
        if(FAILED(hr))
        {
            HrSetErrorInfo(szErrorString, IID_IUPnPRegistrar);
            return hr;
        }
        if(szErrorString)
        {
            CoTaskMemFree(szErrorString);
            szErrorString = NULL;
        }

        if (!nLifeTime)
        {
            nLifeTime = c_defLifeTime;
        }
        else if (nLifeTime < c_minLifeTime)
        {
            hr = E_INVALIDARG;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = CoImpersonateClient();
    }

    if (SUCCEEDED(hr))
    {
        // Process the description document
        PhysicalDeviceIdentifier pdi;
        hr = m_pDescriptionManager->ProcessDescriptionTemplate(
            bstrXMLDesc, bstrResourcePath, &pdi, FALSE, FALSE);
        if(SUCCEEDED(hr))
        {
            // Get the UDNs
            wchar_t ** arszUDNs = NULL;
            long nUDNCount = 0;
            hr = m_pDescriptionManager->GetUDNs(pdi, &nUDNCount, &arszUDNs);
            if(SUCCEEDED(hr))
            {
                // Add device
                hr = m_deviceManager.HrAddRunningDevice(
                    pdi, punkDeviceControl, bstrInitString, nUDNCount, arszUDNs);
                if(SUCCEEDED(hr))
                {
                    // Publish the device
                    hr = m_pDescriptionManager->PublishDescription(pdi, nLifeTime);
                    if(SUCCEEDED(hr))
                    {
                        CUString strPdi;
                        hr = HrPhysicalDeviceIdentifierToString(pdi, strPdi);
                        if(SUCCEEDED(hr))
                        {
                            hr = strPdi.HrGetBSTR(pbstrDeviceIdentifier);
                        }
                    }
                }

                // Free UDNs
                for(long n = 0; n < nUDNCount; ++n)
                {
                    CoTaskMemFree(arszUDNs[n]);
                }
                CoTaskMemFree(arszUDNs);
            }

            if (FAILED(hr))
            {
                HrUnregisterDeviceByPDI(pdi, TRUE);
            }
        }
    }

    CoRevertToSelf();

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::RegisterRunningDevice");
    return hr;
}

STDMETHODIMP CRegistrar::RegisterDeviceProvider(
    /*[in]*/ BSTR     bstrProviderName,
    /*[in]*/ BSTR     bstrProgIDProviderClass,
    /*[in]*/ BSTR     bstrInitString,
    /*[in]*/ BSTR     bstrContainerId)
{
    TraceTag(ttidRegistrar, "CRegistrar::RegisterDeviceProvider");
    HRESULT hr = S_OK;

    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    if(SUCCEEDED(hr))
    {
        hr = m_providerManager.HrRegisterProvider(
            bstrProviderName, bstrProgIDProviderClass, bstrInitString, bstrContainerId);
    }
    if(SUCCEEDED(hr))
    {
        hr = m_pDevicePersistenceManager->SaveDeviceProvider(
            bstrProviderName, bstrProgIDProviderClass, bstrInitString, bstrContainerId);
        if(SUCCEEDED(hr))
        {
            hr = HrSetAutoStart();
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::RegisterDeviceProvider");
    return hr;
}

STDMETHODIMP CRegistrar::GetUniqueDeviceName(
    /*[in]*/          BSTR   bstrDeviceIdentifier,
    /*[in]*/          BSTR   bstrTemplateUDN,
    /*[out, retval]*/ BSTR * pbstrUDN)
{
    TraceTag(ttidRegistrar, "CRegistrar::GetUniqueDeviceName");
    HRESULT hr = S_OK;
    // No locking here to allow for reentrant calls

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    if(SUCCEEDED(hr))
    {
        if (!bstrDeviceIdentifier || !pbstrUDN)
        {
            hr = E_POINTER;
        }
        else
        {
            PhysicalDeviceIdentifier pdi;
            hr = HrStringToPhysicalDeviceIdentifier(bstrDeviceIdentifier, pdi);
            if(SUCCEEDED(hr))
            {
                wchar_t * szUDN = NULL;
                hr = m_pDescriptionManager->GetUniqueDeviceName(pdi, bstrTemplateUDN, &szUDN);
                if(SUCCEEDED(hr))
                {
                    hr = HrSysAllocString(szUDN, pbstrUDN);
                    CoTaskMemFree(szUDN);
                }
            }
            else if (CO_E_CLASSSTRING == hr)
            {
                // remap this error to invalid argument error
                hr = E_INVALIDARG;
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::GetUniqueDeviceName");
    return hr;
}

HRESULT CRegistrar::HrUnregisterDeviceByPDI(PhysicalDeviceIdentifier & pdi, BOOL fPermanent)
{
    CALock lock(*this);

    HRESULT hr = S_OK;

    hr = m_pDescriptionManager->RemoveDescription(pdi, fPermanent);
    TraceHr(ttidError, FAL, hr, FALSE, "CRegistrar::UnregisterDeviceByPDI "
            "RemoveDescription failed!");

    if(SUCCEEDED(hr))
    {
        hr = m_pDevicePersistenceManager->RemovePhysicalDevice(pdi);
        if(FAILED(hr))
        {
            TraceTag(ttidRegistrar, "CRegistrar::UnregisterDeviceByPDI - "
                     "RemovePhysicalDevice failed. This is expected "
                     "for running devices.");
        }
        hr = m_deviceManager.HrRemoveDevice(pdi);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::UnregisterDeviceByPDI");
    return hr;
}

STDMETHODIMP CRegistrar::UnregisterDevice(
    /*[in]*/ BSTR     bstrDeviceIdentifier,
    /*[in]*/ BOOL     fPermanent)
{
    TraceTag(ttidRegistrar, "CRegistrar::UnregisterDevice");
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    if(SUCCEEDED(hr))
    {
        if (!bstrDeviceIdentifier)
        {
            hr = E_POINTER;
        }
        else
        {
            CALock lock(*this);

            PhysicalDeviceIdentifier pdi;
            hr = HrStringToPhysicalDeviceIdentifier(bstrDeviceIdentifier, pdi);
            if(SUCCEEDED(hr))
            {
                hr = HrUnregisterDeviceByPDI(pdi, fPermanent);
            }
            else if (CO_E_CLASSSTRING == hr)
            {
                // remap this error to invalid argument error
                hr = E_INVALIDARG;
            }
        }
    }
    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::UnregisterDevice");
    return hr;
}

STDMETHODIMP CRegistrar::UnregisterDeviceProvider(
    /*[in]*/ BSTR     bstrProviderName)
{
    TraceTag(ttidRegistrar, "CRegistrar::UnegisterDeviceProvider");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    if(SUCCEEDED(hr))
    {
        hr = m_providerManager.UnegisterProvider(bstrProviderName);
    }
    if(SUCCEEDED(hr))
    {
        hr = m_pDevicePersistenceManager->RemoveDeviceProvider(bstrProviderName);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::UnegisterDeviceProvider");
    return hr;
}

// IUPnPReregistrar methods

STDMETHODIMP CRegistrar::ReregisterDevice(
    /*[in]*/ BSTR     bstrDeviceIdentifier,
    /*[in]*/ BSTR     bstrXMLDesc,
    /*[in]*/ BSTR     bstrProgIDDeviceControlClass,
    /*[in]*/ BSTR     bstrInitString,
    /*[in]*/ BSTR     bstrContainerId,
    /*[in]*/ BSTR     bstrResourcePath,
    /*[in]*/ long     nLifeTime)
{
    TraceTag(ttidRegistrar, "CRegistrar::ReregisterDevice");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    if(SUCCEEDED(hr))
    {
        hr = HrValidateResourcePath(bstrResourcePath);
    }
    
    if (SUCCEEDED(hr))
    {
        // Do validation
        wchar_t * szErrorString = NULL;
        hr = m_pValidationManager->ValidateDescriptionDocumentAndReferences(
            bstrXMLDesc, bstrResourcePath, &szErrorString);
        if(FAILED(hr))
        {
            HrSetErrorInfo(szErrorString, IID_IUPnPReregistrar);
            return hr;
        }
        if(szErrorString)
        {
            CoTaskMemFree(szErrorString);
            szErrorString = NULL;
        }

        if (!nLifeTime)
        {
            nLifeTime = c_defLifeTime;
        }
        else if (nLifeTime < c_minLifeTime)
        {
            hr = E_INVALIDARG;
        }

        if (!bstrDeviceIdentifier)
        {
            hr = E_POINTER;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HrSetAutoStart();
    }

    if (SUCCEEDED(hr))
    {
        // Process the description document
        PhysicalDeviceIdentifier pdi;
        hr = HrStringToPhysicalDeviceIdentifier(bstrDeviceIdentifier, pdi);

        if(SUCCEEDED(hr))
        {
            if (m_deviceManager.FHasDevice(pdi))
            {
                hr = UPNP_E_DEVICE_RUNNING;
            }

            if (SUCCEEDED(hr))
            {
                hr = m_pDescriptionManager->ProcessDescriptionTemplate(
                    bstrXMLDesc, bstrResourcePath, &pdi, TRUE, TRUE);
            }

            if(SUCCEEDED(hr))
            {
                // Get the UDNs
                wchar_t ** arszUDNs = NULL;
                long nUDNCount = 0;
                hr = m_pDescriptionManager->GetUDNs(pdi, &nUDNCount, &arszUDNs);
                if(SUCCEEDED(hr))
                {
                    // Add device
                    hr = m_deviceManager.HrAddDevice(pdi, bstrProgIDDeviceControlClass, bstrInitString,
                                                bstrContainerId, nUDNCount, arszUDNs);
                    if(SUCCEEDED(hr))
                    {
                        // Save the device
                        hr = m_pDevicePersistenceManager->SavePhyisicalDevice(
                            pdi, bstrProgIDDeviceControlClass, bstrInitString, bstrContainerId, bstrResourcePath, nLifeTime);
                        if(SUCCEEDED(hr))
                        {
                            // Publish the device
                            hr = m_pDescriptionManager->PublishDescription(pdi, nLifeTime);
                        }
                    }
                    // Free UDNs
                    for(long n = 0; n < nUDNCount; ++n)
                    {
                        CoTaskMemFree(arszUDNs[n]);
                    }
                    CoTaskMemFree(arszUDNs);
                }

                if (FAILED(hr) && hr != UPNP_E_DEVICE_RUNNING)
                {
                    HrUnregisterDeviceByPDI(pdi, FALSE);
                }
            }
        }
        else if (CO_E_CLASSSTRING == hr)
        {
            // remap this error to invalid argument error
            hr = E_INVALIDARG;
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::ReregisterDevice");
    return hr;
}

STDMETHODIMP CRegistrar::ReregisterRunningDevice(
    /*[in]*/ BSTR     bstrDeviceIdentifier,
    /*[in]*/ BSTR     bstrXMLDesc,
    /*[in]*/ IUnknown * punkDeviceControl,
    /*[in]*/ BSTR     bstrInitString,
    /*[in]*/ BSTR     bstrResourcePath,
    /*[in]*/ long     nLifeTime)
{
    TraceTag(ttidRegistrar, "CRegistrar::ReregisterRunningDevice");
    HRESULT hr = S_OK;
    CALock lock(*this);

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    if(SUCCEEDED(hr))
    {
        hr = HrValidateResourcePath(bstrResourcePath);
    }
    if (SUCCEEDED(hr))
    {
        // Do validation
        wchar_t * szErrorString = NULL;
        hr = m_pValidationManager->ValidateDescriptionDocumentAndReferences(
            bstrXMLDesc, bstrResourcePath, &szErrorString);
        if(FAILED(hr))
        {
            HrSetErrorInfo(szErrorString, IID_IUPnPReregistrar);
            return hr;
        }
        if(szErrorString)
        {
            CoTaskMemFree(szErrorString);
            szErrorString = NULL;
        }

        if (!nLifeTime)
        {
            nLifeTime = c_defLifeTime;
        }
        else if (nLifeTime < c_minLifeTime)
        {
            hr = E_INVALIDARG;
        }

        if (!bstrDeviceIdentifier)
        {
            hr = E_POINTER;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = CoImpersonateClient();
    }

    if (SUCCEEDED(hr))
    {
        // Process the description document
        PhysicalDeviceIdentifier pdi;
        hr = HrStringToPhysicalDeviceIdentifier(bstrDeviceIdentifier, pdi);

        if(SUCCEEDED(hr))
        {
            if (m_deviceManager.FHasDevice(pdi))
            {
                hr = UPNP_E_DEVICE_RUNNING;
            }

            // Process the description document
            if (SUCCEEDED(hr))
            {
                hr = m_pDescriptionManager->ProcessDescriptionTemplate(
                    bstrXMLDesc, bstrResourcePath, &pdi, FALSE, TRUE);
            }

            if(SUCCEEDED(hr))
            {
                // Get the UDNs
                wchar_t ** arszUDNs = NULL;
                long nUDNCount = 0;
                hr = m_pDescriptionManager->GetUDNs(pdi, &nUDNCount, &arszUDNs);
                if(SUCCEEDED(hr))
                {
                    // Add device
                    hr = m_deviceManager.HrAddRunningDevice(
                        pdi, punkDeviceControl, bstrInitString, nUDNCount, arszUDNs);
                    if(SUCCEEDED(hr))
                    {
                        // Publish the device
                        hr = m_pDescriptionManager->PublishDescription(pdi, nLifeTime);
                    }

                    // Free UDNs
                    for(long n = 0; n < nUDNCount; ++n)
                    {
                        CoTaskMemFree(arszUDNs[n]);
                    }
                    CoTaskMemFree(arszUDNs);
                }

                if (FAILED(hr) && hr != UPNP_E_DEVICE_RUNNING)
                {
                    HrUnregisterDeviceByPDI(pdi, FALSE);
                }
            }
        }
        else if (CO_E_CLASSSTRING == hr)
        {
            // remap this error to invalid argument error
            hr = E_INVALIDARG;
        }
    }

    CoRevertToSelf();

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::ReregisterRunningDevice");
    return hr;
}

STDMETHODIMP CRegistrar::SetICSInterfaces(/*[in]*/ long nCount, /*[in, size_is(nCount)]*/ GUID * arPrivateInterfaceGuids)
{
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_INPROC | CALL_LOCALITY_LOCAL ));
    
    if ( SUCCEEDED( hr ) )
    {
        hr = CUPnPInterfaceList::Instance().HrSetICSInterfaces(nCount, arPrivateInterfaceGuids);
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::SetICSInterfaces");
    return hr;
}

STDMETHODIMP CRegistrar::SetICSOff()
{
    HRESULT hr = S_OK;

    hr = HrIsAllowedCOMCallLocality((CALL_LOCALITY) (CALL_LOCALITY_LOCAL | CALL_LOCALITY_INPROC));
    
    if ( SUCCEEDED( hr ) )
    {
        hr = CUPnPInterfaceList::Instance().HrSetICSOff();
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::SetICSOff");
    return hr;
}

HRESULT CRegistrar::HrSetAutoStart()
{
    HRESULT hr = S_OK;

    CALock lock(*this);

    if(!m_bSetAutoStart)
    {
        SC_HANDLE scm = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
        if(!scm)
        {
            hr = HrFromLastWin32Error();
        }
        if(SUCCEEDED(hr))
        {
            SC_HANDLE scUpnphost = OpenService(scm, L"upnphost", SERVICE_CHANGE_CONFIG);
            if(!scUpnphost)
            {
                hr = HrFromLastWin32Error();
            }
            if(SUCCEEDED(hr))
            {
                if(!ChangeServiceConfig(scUpnphost, SERVICE_NO_CHANGE, SERVICE_AUTO_START,
                                        SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, 
                                        NULL, NULL, NULL))
                {
                    hr = HrFromLastWin32Error();
                }
                CloseServiceHandle(scUpnphost);
            }
            CloseServiceHandle(scm);
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CRegistrar::HrSetAutoStart");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\uhutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U H U T I L . C P P
//
//  Contents:   Common routines and constants for UPnP Device Host
//
//  Notes:
//
//  Author:     mbend   6 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <shlobj.h>     // For SHGetFolderPath()

#include "uhbase.h"
#include "uhutil.h"
#include "ncreg.h"
#include "ComUtility.h"
#include "RegDef.h"
#include "httpcomn.h"

// Registry locations
const wchar_t c_szRegistryMicrosoft[] = L"SOFTWARE\\Microsoft\\UPnP Device Host";
const wchar_t c_szUPnPDeviceHost[] = L"UPnP Device Host";
const wchar_t c_szMicrosoft[] = L"Microsoft";
const wchar_t c_szRegistryShellFolders[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
const wchar_t c_szCommonAppData[] = L"Common AppData";
const wchar_t c_szUpnphost[] = L"upnphost";
const wchar_t c_szUdhisapiDll[] = L"udhisapi.dll";

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryString
//
//  Purpose:    Queries a string value from a registry key
//
//  Arguments:
//      hKey        [in]  Handle to key to query
//      szValueName [in]  Name of value to query
//      str         [out] String to return value in
//
//  Returns:    S_OK on success or COM error code on failure.
//
//  Author:     mbend   6 Sep 2000
//
//  Notes:
//
HRESULT HrRegQueryString(HKEY hKey, const wchar_t * szValueName, CUString & str)
{
    HRESULT hr = S_OK;

    DWORD dwType = 0;
    DWORD dwBytes = 0;
    LPBYTE pData = NULL;

    // Query size of buffer
    hr = HrRegQueryValueEx(hKey, szValueName, &dwType, NULL, &dwBytes);
    if(REG_SZ != dwType)
    {
        // Type mismatch
        hr = E_INVALIDARG;
    }
    if(SUCCEEDED(hr))
    {
        pData = new BYTE[dwBytes];
        if(pData)
        {
            if(SUCCEEDED(hr))
            {
                hr = HrRegQueryValueEx(hKey, szValueName, &dwType, pData, &dwBytes);
                if(SUCCEEDED(hr))
                {
                    hr = str.HrAssign(reinterpret_cast<wchar_t*>(pData));
                }
            }
            delete [] pData;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrRegQueryString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateOrOpenDeviceHostKey
//
//  Purpose:    Creates if not present or opens the device host root key in the registry.
//
//  Arguments:
//      phKeyDeviceHost [out] Pointer to Registry key handle on return.
//
//  Returns:    S_OK on success or COM error code on failure.
//
//  Author:     mbend   6 Sep 2000
//
//  Notes:
//
HRESULT HrCreateOrOpenDeviceHostKey(HKEY * phKeyDeviceHost)
{
    CHECK_POINTER(phKeyDeviceHost);
    HRESULT hr = S_OK;
    HKEY hKeyDeviceHost;

    // Open HKLM\SOFTWARE\Microsoft\UPnP Device Host
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegistryMicrosoft, KEY_ALL_ACCESS, &hKeyDeviceHost);
    if(SUCCEEDED(hr))
    {
        *phKeyDeviceHost = hKeyDeviceHost;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateOrOpenDeviceHostKey");
    return hr;
}

HRESULT HrCreateAndReferenceContainedObject(
    const wchar_t * szContainer,
    REFCLSID clsid,
    REFIID riid,
    void ** ppv)
{
    HRESULT hr = S_OK;

    // For no container, just use CoCreateInstance
    if(!szContainer)
    {
        hr = HrCoCreateInstanceInprocBase(clsid, riid, ppv);
    }
    else
    {
        // Create the container manager and use him to create object
        IUPnPContainerManagerPtr pContainerManager;
        hr = pContainerManager.HrCreateInstanceInproc(CLSID_UPnPContainerManager);
        if(SUCCEEDED(hr))
        {
            hr = pContainerManager->ReferenceContainer(szContainer);
            if(SUCCEEDED(hr))
            {
                hr = pContainerManager->CreateInstance(szContainer, clsid, riid, ppv);
                if(FAILED(hr))
                {
                    pContainerManager->UnreferenceContainer(szContainer);
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateAndReferenceContainedObject");
    return hr;
}

HRESULT HrCreateAndReferenceContainedObjectByProgId(
    const wchar_t * szContainer,
    const wchar_t * szProgId,
    REFIID riid,
    void ** ppv)
{
    HRESULT hr = S_OK;

    // Create the container manager and use him to create object
    IUPnPContainerManagerPtr pContainerManager;
    hr = pContainerManager.HrCreateInstanceInproc(CLSID_UPnPContainerManager);
    if(SUCCEEDED(hr))
    {
        hr = pContainerManager->ReferenceContainer(szContainer);
        if(SUCCEEDED(hr))
        {
            hr = pContainerManager->CreateInstanceWithProgId(szContainer, szProgId, riid, ppv);
            if(FAILED(hr))
            {
                pContainerManager->UnreferenceContainer(szContainer);
            }
        }
    }


    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateAndReferenceContainedObjectByProgId");
    return hr;
}

HRESULT HrDereferenceContainer(
    const wchar_t * szContainer)
{
    HRESULT hr = S_OK;

    // Create the container manager and unreference
    IUPnPContainerManagerPtr pContainerManager;
    hr = pContainerManager.HrCreateInstanceInproc(CLSID_UPnPContainerManager);
    if(SUCCEEDED(hr))
    {
        hr = pContainerManager->UnreferenceContainer(szContainer);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrDereferenceContainer");
    return hr;
}

HRESULT HrPhysicalDeviceIdentifierToString(const GUID & pdi, CUString & str)
{
    HRESULT hr = S_OK;

    hr = str.HrInitFromGUID(pdi);

    TraceHr(ttidError, FAL, hr, FALSE, "HrPhysicalDeviceIdentifierToString");
    return hr;
}

HRESULT HrStringToPhysicalDeviceIdentifier(const wchar_t * szStrPdi, GUID & pdi)
{
    HRESULT hr = S_OK;

    hr = CLSIDFromString(const_cast<wchar_t *>(szStrPdi), &pdi);

    TraceHr(ttidError, FAL, hr, FALSE, "HrStringToPhysicalDeviceIdentifier");
    return hr;
}

HRESULT HrGUIDToUDNString(const UUID & uuid, CUString & strUUID)
{
    HRESULT hr = S_OK;

    hr = strUUID.HrAssign(L"uuid:");
    if(SUCCEEDED(hr))
    {
        wchar_t * szUUID = NULL;
        RPC_STATUS status;
        status = UuidToString(const_cast<UUID*>(&uuid), (unsigned short **)&szUUID);
        if(RPC_S_OUT_OF_MEMORY == status)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            hr = strUUID.HrAppend(szUUID);
            RpcStringFree((unsigned short **)&szUUID);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGUIDToUDNString");
    return hr;
}

HRESULT HrMakeFullPath(
    const wchar_t * szPath,
    const wchar_t * szFile,
    CUString & strFullPath)
{
    HRESULT hr = S_OK;

    hr = strFullPath.HrAssign(szPath);
    if(SUCCEEDED(hr))
    {
        hr = HrEnsurePathBackslash(strFullPath);
        if(SUCCEEDED(hr))
        {
            hr = strFullPath.HrAppend(szFile);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrMakeFullPath");
    return hr;
}

HRESULT HrEnsurePathBackslash(CUString & strPath)
{
    HRESULT hr = S_OK;

    long nLength = strPath.GetLength();
    if(nLength)
    {
        if(L'\\' != strPath[nLength - 1])
        {
            hr = strPath.HrAppend(L"\\");
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrEnsurePathBackslash");
    return hr;
}

HRESULT HrAddDirectoryToPath(CUString & strPath, const wchar_t * szDir)
{
    HRESULT hr = S_OK;

    CUString strTemp;
    hr = strTemp.HrAssign(strPath);
    if(SUCCEEDED(hr))
    {
        hr = HrEnsurePathBackslash(strTemp);
        if(SUCCEEDED(hr))
        {
            hr = strTemp.HrAppend(szDir);
            if(SUCCEEDED(hr))
            {
                if(!CreateDirectory(strTemp, NULL))
                {
                    // Who cares if it already exists?
                    hr = HrFromLastWin32Error();
                    if(HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }
    if(SUCCEEDED(hr))
    {
        hr = HrEnsurePathBackslash(strTemp);
        if(SUCCEEDED(hr))
        {
            strPath.Transfer(strTemp);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrAddDirectoryToPath");
    return hr;
}

HRESULT HrGetUPnPHostPath(CUString & strPath)
{
    HRESULT     hr = S_OK;
    HANDLE      hToken = NULL;
    WCHAR       szPath[MAX_PATH + 1];
    CUString    strCommonAppData;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        hr = SHGetFolderPath(NULL, CSIDL_APPDATA, hToken, SHGFP_TYPE_CURRENT,
                             szPath);
        if (SUCCEEDED(hr))
        {
            hr = strCommonAppData.HrAssign(szPath);
            if(SUCCEEDED(hr))
            {
                // Create the directories
                hr = HrAddDirectoryToPath(strCommonAppData, c_szMicrosoft);
                if(SUCCEEDED(hr))
                {
                    hr = HrAddDirectoryToPath(strCommonAppData, c_szUPnPDeviceHost);
                    if(SUCCEEDED(hr))
                    {
                        strPath.Transfer(strCommonAppData);
                    }
                }
            }
        }

        CloseHandle(hToken);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetUPnPHostPath");
    return hr;
}

static const WCHAR c_szUrl[] = L"/upnphost";

HRESULT HrMakeIsapiExtensionDirectory()
{
    HRESULT hr = S_OK;
    WCHAR   szSysDir[MAX_PATH];

    // Create ISAPI extension directory and copy DLL there
    CUString strPath;
    CUString strSrcPath;

    if (GetSystemDirectory(szSysDir, MAX_PATH))
    {
        hr = strSrcPath.HrAssign(szSysDir);
        if (SUCCEEDED(hr))
        {
            hr = strSrcPath.HrAppend(L"\\");
            if (SUCCEEDED(hr))
            {
                hr = strSrcPath.HrAppend(c_szUdhisapiDll);
            }
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    if(SUCCEEDED(hr))
    {
        CUString strFile;
        hr = HrGetUPnPHostPath(strPath);
        if(SUCCEEDED(hr))
        {
            hr = HrAddDirectoryToPath(strPath, c_szUpnphost);
            if(SUCCEEDED(hr))
            {
                hr = strFile.HrAssign(strPath);
                if(SUCCEEDED(hr))
                {
                    hr = strFile.HrAppend(c_szUdhisapiDll);
                    if(SUCCEEDED(hr))
                    {
                        if(!CopyFile(strSrcPath, strFile, FALSE))
                        {
                            hr = HrFromLastWin32Error();
                        }
                    }
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        HKEY    hkeyVroot;
        HKEY    hkeyNew;

        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, RK_HTTPDVROOTS, KEY_ALL_ACCESS,
                            &hkeyVroot);
        if (SUCCEEDED(hr))
        {
            hr = HrRegCreateKeyEx(hkeyVroot, c_szUrl, 0, KEY_ALL_ACCESS, NULL,
                                  &hkeyNew, NULL);
            if (SUCCEEDED(hr))
            {
                // Pass NULL to set default value
                //
                hr = HrRegSetSz(hkeyNew, NULL, strPath.GetBuffer());

                RegCloseKey(hkeyNew);
            }

            RegCloseKey(hkeyVroot);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrMakeIsapiExtensionDirectory");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\validationmanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       V A L I D A T I O N M A N A G E R . H
//
//  Contents:   Validates device host inputs
//
//  Notes:
//
//  Author:     mbend   9 Oct 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "uhres.h"       // main symbols

#include "ComUtility.h"
#include "Array.h"
#include "hostp.h"
#include "Table.h"
#include "UString.h"
#include "RegDef.h"
#include "uhxml.h"

/////////////////////////////////////////////////////////////////////////////
// CValidationManager
class ATL_NO_VTABLE CValidationManager :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CValidationManager, &CLSID_UPnPValidationManager>,
    public IUPnPValidationManager
{
public:
    CValidationManager();
    ~CValidationManager();

DECLARE_REGISTRY_RESOURCEID(IDR_VALIDATION_MANAGER)

DECLARE_NOT_AGGREGATABLE(CValidationManager)

BEGIN_COM_MAP(CValidationManager)
    COM_INTERFACE_ENTRY(IUPnPValidationManager)
END_COM_MAP()

public:
    // IUPnPValidationManager methods
    STDMETHOD(ValidateDescriptionDocument)(
        /*[in]*/ BSTR bstrTemplate,
        /*[out, string]*/ wchar_t ** pszErrorString);
    STDMETHOD(ValidateServiceDescription)(
        /*[in, string]*/ const wchar_t * szFullPath,
        /*[out, string]*/ wchar_t ** pszErrorString);
    STDMETHOD(ValidateDescriptionDocumentAndReferences)(
        /*[in]*/ BSTR bstrTemplate,
        /*[in, string]*/ const wchar_t * szResourcePath,
        /*[out, string]*/ wchar_t ** pszErrorString);

private:

    HRESULT ValidateServiceDescriptions(const wchar_t * szResourcePath,
                                        IXMLDOMNodePtr pRootNode,
                                        wchar_t ** pszErrorString);
    HRESULT ValidateIconFiles(const wchar_t * szResourcePath,
                              IXMLDOMNodePtr pRootNode,
                              wchar_t ** pszErrorString);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\serviceinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S E R V I C E I N F O . C P P
//
//  Contents:   Registrar representation on a service
//
//  Notes:
//
//  Author:     mbend   12 Sep 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "ServiceInfo.h"
#include "uhutil.h"

CServiceInfo::CServiceInfo()
{
}

CServiceInfo::~CServiceInfo()
{
    Clear();
}

HRESULT CServiceInfo::HrInitialize(
    const PhysicalDeviceIdentifier & pdi,
    const wchar_t * szUDN,
    const wchar_t * szServiceId,
    const wchar_t * szContainerId,
    IUPnPDeviceControlPtr & pDeviceControl,
    BOOL bRunning)
{
    CHECK_POINTER(szUDN);
    CHECK_POINTER(szServiceId);
    CHECK_POINTER(pDeviceControl.GetRawPointer());
    TraceTag(ttidRegistrar, "CServiceInfo::HrInitialize(UDN=%S, ServiceId=%S)", szUDN, szServiceId);
    HRESULT hr = S_OK;

    if(szContainerId)
    {
        hr = m_strContainerId.HrAssign(szContainerId);
    }
    if(SUCCEEDED(hr))
    {
        BSTR bstrUDN = NULL;
        BSTR bstrServiceId = NULL;
        bstrUDN = SysAllocString(szUDN);
        bstrServiceId = SysAllocString(szServiceId);
        if(bstrUDN && bstrServiceId)
        {
            hr = pDeviceControl->GetServiceObject(bstrUDN, bstrServiceId, m_pDispService.AddressOf());
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        if(bstrUDN)
        {
            SysFreeString(bstrUDN);
        }
        if(bstrServiceId)
        {
            SysFreeString(bstrServiceId);
        }
        if(SUCCEEDED(hr))
        {
            if(bRunning)
            {
                hr = m_pDispService.HrCopyProxyIdentity(pDeviceControl.GetRawPointer());
            }
        }
        if(SUCCEEDED(hr))
        {
            hr = m_pEventingManager.HrCreateInstanceInproc(CLSID_UPnPEventingManager);
            if(SUCCEEDED(hr))
            {
                hr = m_pAutomationProxy.HrCreateInstanceInproc(CLSID_UPnPAutomationProxy);
                if(SUCCEEDED(hr))
                {
                    IUPnPRegistrarPrivatePtr pPriv;
                    hr = pPriv.HrCreateInstanceInproc(CLSID_UPnPRegistrar);
                    if(SUCCEEDED(hr))
                    {
                        // Get the service description text
                        wchar_t * szServiceText = NULL;
                        wchar_t * szServiceType = NULL;
                        hr = pPriv->GetSCPDText(pdi, szUDN, szServiceId, &szServiceText, &szServiceType);
                        if(SUCCEEDED(hr))
                        {
                            // Initialize the automation proxy
                            hr = m_pAutomationProxy->Initialize(m_pDispService, szServiceText, szServiceType, bRunning);
                            if(SUCCEEDED(hr))
                            {
                                // Intialize eventing manager
                                hr = m_pEventingManager->Initialize(
                                        const_cast<wchar_t*>(szUDN),
                                        const_cast<wchar_t*>(szServiceId),
                                        m_pAutomationProxy, m_pDispService, bRunning);
                                if (E_NOINTERFACE == hr)
                                {
                                    TraceTag(ttidRegistrar, "Eventing manager "
                                             "interface not supported on this "
                                             "service!");

                                    // Don't want to reference it anymore
                                    m_pEventingManager.Release();
                                    hr = S_OK;
                                }
                            }
                            CoTaskMemFree(szServiceText);
                            CoTaskMemFree(szServiceType);
                        }
                    }
                }
            }
        }
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CServiceInfo::HrInitialize");
    return hr;
}

HRESULT CServiceInfo::HrGetEventingManager(IUPnPEventingManager ** ppEventingManager)
{
    CHECK_POINTER(ppEventingManager);
    TraceTag(ttidRegistrar, "CServiceInfo::HrGetEventingManager");
    HRESULT hr = S_OK;

    if(m_pEventingManager)
    {
        *ppEventingManager = m_pEventingManager.GetPointer();
    }
    else
    {
        *ppEventingManager = NULL;
        hr = E_UNEXPECTED;
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CServiceInfo::HrGetEventingManager");
    return hr;
}

HRESULT CServiceInfo::HrGetAutomationProxy(IUPnPAutomationProxy ** ppAutomationProxy)
{
    CHECK_POINTER(ppAutomationProxy);
    TraceTag(ttidRegistrar, "CServiceInfo::HrGetAutomationProxy");
    HRESULT hr = S_OK;

    if(m_pAutomationProxy)
    {
        *ppAutomationProxy = m_pAutomationProxy.GetPointer();
    }
    else
    {
        *ppAutomationProxy = NULL;
        hr = E_UNEXPECTED;
    }

    TraceHr(ttidRegistrar, FAL, hr, FALSE, "CServiceInfo::HrGetAutomationProxy");
    return hr;
}

void CServiceInfo::Transfer(CServiceInfo & ref)
{
    m_strContainerId.Transfer(ref.m_strContainerId);
    m_pDispService.Swap(ref.m_pDispService);
    m_pEventingManager.Swap(ref.m_pEventingManager);
    m_pAutomationProxy.Swap(ref.m_pAutomationProxy);
}

void CServiceInfo::Clear()
{
    m_strContainerId.Clear();
    m_pDispService.Release();

    if (m_pEventingManager)
    {
        m_pEventingManager->Shutdown();
    }

    m_pEventingManager.Release();
    m_pAutomationProxy.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\registrar\validationmanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       V A L I D A T I O N M A N A G E R . C P P
//
//  Contents:   Validates device host inputs
//
//  Notes:
//
//  Author:     mbend   9 Oct 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "uhbase.h"
#include "ValidationManager.h"
#include "uhutil.h"
#include "ncstring.h"
#include "validate.h"
#include "uhcommon.h"

// Functions declarationc
HRESULT HrValidateDevice(
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strErrorString);

CValidationManager::CValidationManager ()
{
}

CValidationManager::~CValidationManager ()
{
}

HRESULT HrGetDocumentAndRootNode(
    BSTR bstrTemplate,
    IXMLDOMDocumentPtr & pDoc,
    IXMLDOMNodePtr & pRootNode)
{
    TraceTag(ttidValidate, "HrGetDocumentAndRootNode");
    HRESULT hr = S_OK;

    // Load document and fetch needed items
    hr = HrLoadDocument(bstrTemplate, pDoc);
    if(SUCCEEDED(hr))
    {
        hr = pRootNode.HrAttach(pDoc);
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrGetDocumentAndRootNode");
    return hr;
}

struct PresenceItem
{
    const wchar_t * m_szName;
    bool            m_bEmpty;
    bool            m_bSuffix;
    bool            m_bOptional;
    LONG            m_cchMax;
};

//    m_szName              EMPTY   SUFFIX  OPTONAL CCH
//    ----------------------------------------------------------
const PresenceItem g_arpiDeviceItems[] =
{
    {L"deviceType",         false,  true,   false,  64},
    {L"friendlyName",       false,  false,  false,  64},
    {L"manufacturer",       false,  false,  false,  64},
    {L"manufacturerURL",    false,  false,  true,   -1},
    {L"modelDescription",   false,  false,  true,   128},
    {L"modelName",          false,  false,  false,  32},
    {L"modelNumber",        false,  false,  true,   32},
    {L"modelURL",           false,  false,  true,   -1},
    {L"serialNumber",       false,  false,  true,   64},
    {L"UDN",                false,  false,  false,  -1},
    {L"UPC",                false,  false,  true,   12},
};

const long c_nDeviceItems = celems(g_arpiDeviceItems);

PresenceItem g_arpiServiceItems[] =
{
    {L"serviceType",        false,  true,   false,  64},
    {L"serviceId",          false,  true,   false,  64},
    {L"SCPDURL",            false,  false,  false,  -1},
    {L"controlURL",         true,   false,  false,  -1},
    {L"eventSubURL",        true,   false,  false,  -1},
};

const long c_nServiceItems = celems(g_arpiServiceItems);

PresenceItem g_arpiIconItems[] =
{
    {L"mimetype",           false,  false,  false,  -1},
    {L"width",              false,  false,  false,  -1},
    {L"height",             false,  false,  false,  -1},
    {L"depth",              false,  false,  false,  -1},
    {L"url",                false,  false,  false,  -1},
};

const long c_nIconItems = celems(g_arpiIconItems);

PresenceItem g_arpiRootItems[] =
{
    {L"/root/specVersion",  false,  false,  false,  -1},
};

const long c_nRootItems = celems(g_arpiRootItems);

HRESULT HrValidateSufixes(IXMLDOMNodePtr & pNode,
                          const wchar_t * szName,
                          LONG            cchMax,
                          CUString & strErrorString)
{
    HRESULT         hr = S_OK;
    DWORD           ctok = 0;
    LPCWSTR         pchText;
    CUString        strText;
    IXMLDOMNodePtr  pNodeItem;

    // This function validates the serviceType, deviceType, and serviceId
    // elements in the following way:
    // Each of these is of the form: urn:domain-name:keyword:SUFFIX:version
    // Since they all follow the same format (which currently we DO NOT
    // validate), we can make an assumption that the 4th token (SUFFIX) is the
    // one that we need to validate. The validation is strictly as according
    // to UPnP architecture 1.0 where this suffix must be <= 64 characters in
    // length.
    //

    hr = HrSelectNode(szName, pNode, pNodeItem);
    if (SUCCEEDED(hr))
    {
        hr = HrGetNodeText(pNodeItem, strText);
        if (SUCCEEDED(hr))
        {
            pchText = strText.GetBuffer();
            while (*pchText)
            {
                if (*pchText == L':')
                {
                    ctok++;
                    pchText++;

                    if (ctok == 3)
                    {
                        // Fourth token is the one we need to examine
                        LONG    cch = 0;

                        while (*pchText && *pchText != L':')
                        {
                            pchText++;
                            cch++;
                        }

                        // ISSUE-2000/11/29-danielwe: We don't yet
                        // validate the format of the suffix
                        //

                        if (cch > cchMax)
                        {
                            hr = strErrorString.HrPrintf(
                                WszLoadString(_Module.GetResourceInstance(),
                                              IDS_SUFFIX_TOO_LONG),
                                strText);
                            if (SUCCEEDED(hr))
                            {
                                hr = UPNP_E_SUFFIX_TOO_LONG;
                            }
                        }

                        break;
                    }
                }
                else
                {
                    pchText++;
                }
            }
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateSufixes(%S)",
            strErrorString.GetLength() ? strErrorString.GetBuffer(): L"Unspecified");
    return hr;
}

HRESULT HrValidatePresenceItems(
    IXMLDOMNodePtr & pNode,
    long nPresenceItems,
    const PresenceItem * arPresenceItems,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    for(long n = 0; n < nPresenceItems && SUCCEEDED(hr); ++n)
    {
        AssertSz(FImplies(arPresenceItems[n].m_bEmpty,
                          arPresenceItems[n].m_cchMax == -1),
                 "Empty elements mean there shouldn't be a size to verify "
                 "against! Fix the array above!");

        if(arPresenceItems[n].m_bEmpty)
        {
            hr = HrIsNodePresentOnceAndEmpty(arPresenceItems[n].m_szName, pNode);
            if(S_OK != hr)
            {
                hr = strErrorString.HrPrintf(
                    WszLoadString(_Module.GetResourceInstance(), IDS_EMPTY_NODE_NOT_PRESENT),
                    arPresenceItems[n].m_szName);
                if(SUCCEEDED(hr))
                {
                    hr = UPNP_E_REQUIRED_ELEMENT_ERROR;
                }
            }
        }
        else if (!arPresenceItems[n].m_bSuffix)
        {
            hr = HrIsNodePresentOnceAndNotEmpty(arPresenceItems[n].m_szName, pNode);
            if(S_OK != hr)
            {
                if (UPNP_E_DUPLICATE_NOT_ALLOWED == hr)
                {
                    // Didn't find the item and it's not optional
                    hr = strErrorString.HrPrintf(
                        WszLoadString(_Module.GetResourceInstance(),
                                      IDS_DUPLICATES_NOT_ALLOWED),
                        arPresenceItems[n].m_szName);
                    if(SUCCEEDED(hr))
                    {
                        hr = UPNP_E_DUPLICATE_NOT_ALLOWED;
                    }
                }
                else if (!arPresenceItems[n].m_bOptional)
                {
                    // Didn't find the item and it's not optional
                    hr = strErrorString.HrPrintf(
                        WszLoadString(_Module.GetResourceInstance(),
                                      IDS_NON_EMPTY_NODE_NOT_PRESENT),
                        arPresenceItems[n].m_szName);
                    if(SUCCEEDED(hr))
                    {
                        hr = UPNP_E_REQUIRED_ELEMENT_ERROR;
                    }
                }
                else
                {
                    // Element was optional
                    hr = S_OK;
                }
            }
            else if (arPresenceItems[n].m_cchMax != -1)
            {
                // Check length if one is specified
                //
                hr = HrIsNodeOfValidLength(arPresenceItems[n].m_szName, pNode,
                                           arPresenceItems[n].m_cchMax);
                if(S_FALSE == hr)
                {
                    hr = strErrorString.HrPrintf(
                        WszLoadString(_Module.GetResourceInstance(), IDS_ELEMENT_VALUE_TOO_LONG),
                        arPresenceItems[n].m_szName);
                    if(SUCCEEDED(hr))
                    {
                        hr = UPNP_E_VALUE_TOO_LONG;
                    }
                }
                else if (arPresenceItems[n].m_bOptional && (FAILED(hr)))
                {
                    // If item was optional, forget any errors
                    hr = S_OK;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            if (arPresenceItems[n].m_bSuffix && arPresenceItems[n].m_cchMax != -1)
            {
                hr = HrValidateSufixes(pNode, arPresenceItems[n].m_szName,
                                       arPresenceItems[n].m_cchMax,
                                       strErrorString);
            }
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidatePresenceItems(%S)",
            strErrorString.GetLength() ? strErrorString.GetBuffer(): L"Unspecified");
    return hr;
}

HRESULT HrValidateDeviceService(
    IXMLDOMNodePtr & pNodeService,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    hr = HrValidatePresenceItems(pNodeService, c_nServiceItems, g_arpiServiceItems, strErrorString);

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateDeviceService");
    return hr;
}

HRESULT HrCheckForDuplicatesInList(
    IXMLDOMNodeListPtr & pNodeList,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    CUArray<CUString> arstrValues;
    while(SUCCEEDED(hr))
    {
        IXMLDOMNodePtr pNode;
        HRESULT hrTemp = pNodeList->nextNode(pNode.AddressOf());
        if(S_OK != hrTemp)
        {
            break;
        }
        CUString strText;
        hr = HrGetNodeText(pNode, strText);
        if(SUCCEEDED(hr))
        {
            long nIndex = 0;
            hrTemp = arstrValues.HrFind(strText, nIndex);
            if(S_OK == hrTemp)
            {
                // We found a duplicate
                hr = strErrorString.HrPrintf(
                    WszLoadString(_Module.GetResourceInstance(), IDS_DUPLICATES_NOT_ALLOWED),
                    strText.GetBuffer());
                if(SUCCEEDED(hr))
                {
                    hr = UPNP_E_DUPLICATE_NOT_ALLOWED;
                }
            }
            else
            {
                hr = arstrValues.HrPushBack(strText);
            }
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrCheckForDuplicatesInList");
    return hr;
}

HRESULT HrValidateDeviceServices(
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    // serviceList is required and must contain a service
    BOOL bServiceNotPresent = TRUE;

    HRESULT hrTemp = HrIsNodePresentOnce(L"serviceList", pNodeDevice);
    if(S_OK == hrTemp)
    {
        IXMLDOMNodeListPtr pNodeList;
        hrTemp = HrSelectNodes(L"serviceList/service", pNodeDevice, pNodeList);
        if(S_OK == hrTemp)
        {
            while(SUCCEEDED(hr))
            {
                IXMLDOMNodePtr pNode;
                hrTemp = pNodeList->nextNode(pNode.AddressOf());
                if(S_OK != hrTemp)
                {
                    break;
                }

                // We have a service
                bServiceNotPresent = FALSE;

                hr = HrValidateDeviceService(pNode, strErrorString);
            }
        }

        // Make sure all ServiceId's are unique
        if(SUCCEEDED(hr))
        {
            pNodeList.Release();
            hrTemp = HrSelectNodes(L"serviceList/service/serviceId", pNodeDevice, pNodeList);
            if(S_OK == hrTemp)
            {
                hr = HrCheckForDuplicatesInList(pNodeList, strErrorString);
            }
        }
    }

    if(bServiceNotPresent)
    {
        hr = strErrorString.HrAssign(
            WszLoadString(_Module.GetResourceInstance(), IDS_SERVICE_MISSING));
        if(SUCCEEDED(hr))
        {
            hr = UPNP_E_INVALID_SERVICE;
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateDeviceServices");
    return hr;
}

HRESULT HrValidateDeviceIcon(
    IXMLDOMNodePtr & pNodeIcon,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    hr = HrValidatePresenceItems(pNodeIcon, c_nIconItems, g_arpiIconItems, strErrorString);

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateDeviceIcon");
    return hr;
}

HRESULT HrValidateDeviceIcons(
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    HRESULT hrTemp = HrIsNodePresentOnce(L"iconList", pNodeDevice);
    if(S_OK == hrTemp)
    {
        BOOL    fGotAnIcon = FALSE;

        IXMLDOMNodeListPtr pNodeList;
        hrTemp = HrSelectNodes(L"iconList/icon", pNodeDevice, pNodeList);
        if(S_OK == hrTemp)
        {
            while(SUCCEEDED(hr))
            {
                IXMLDOMNodePtr pNode;
                hrTemp = pNodeList->nextNode(pNode.AddressOf());
                if(S_OK != hrTemp)
                {
                    break;
                }

                fGotAnIcon = TRUE;
                hr = HrValidateDeviceIcon(pNode, strErrorString);
            }
        }

        if (!fGotAnIcon)
        {
            hr = strErrorString.HrAssign(
                WszLoadString(_Module.GetResourceInstance(), IDS_ICON_MISSING));
            if(SUCCEEDED(hr))
            {
                hr = UPNP_E_INVALID_ICON;
            }
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateDeviceIcons");
    return hr;
}

HRESULT HrValidateDeviceChildren(
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    BOOL    fGotADevice = FALSE;

    HRESULT hrTemp = HrIsNodePresentOnce(L"deviceList", pNodeDevice);
    if(S_OK == hrTemp)
    {
        IXMLDOMNodeListPtr pNodeList;
        hrTemp = HrSelectNodes(L"deviceList/device", pNodeDevice, pNodeList);
        if(S_OK == hrTemp)
        {
            while(SUCCEEDED(hr))
            {
                IXMLDOMNodePtr pNode;
                hrTemp = pNodeList->nextNode(pNode.AddressOf());
                if(S_OK != hrTemp)
                {
                    break;
                }

                fGotADevice = TRUE;
                hr = HrValidateDevice(pNode, strErrorString);
            }
        }

        if (!fGotADevice)
        {
            hr = strErrorString.HrAssign(
                WszLoadString(_Module.GetResourceInstance(), IDS_DEVICE_MISSING));
            if(SUCCEEDED(hr))
            {
                hr = UPNP_E_INVALID_DOCUMENT;
            }
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateDeviceChildren");
    return hr;
}

HRESULT HrValidateDevice(
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strErrorString)
{
    TraceTag(ttidValidate, "HrValidateDevice");
    HRESULT hr = S_OK;

    hr = HrValidatePresenceItems(pNodeDevice, c_nDeviceItems, g_arpiDeviceItems, strErrorString);
    if(SUCCEEDED(hr))
    {
        hr = HrValidateDeviceServices(pNodeDevice, strErrorString);
        if(SUCCEEDED(hr))
        {
            hr = HrValidateDeviceIcons(pNodeDevice, strErrorString);
            if(SUCCEEDED(hr))
            {
                hr = HrValidateDeviceChildren(pNodeDevice, strErrorString);
            }
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateDevice");
    return hr;
}

HRESULT HrValidateUDNs(
    IXMLDOMNodePtr & pNodeDevice,
    CUString & strErrorString)
{
    HRESULT hr = S_OK;

    IXMLDOMNodeListPtr pNodeList;
    hr = HrSelectNodes(L"//UDN", pNodeDevice, pNodeList);
    if(SUCCEEDED(hr))
    {
        hr = HrCheckForDuplicatesInList(pNodeList, strErrorString);
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "HrValidateUDNs");
    return hr;
}

/*
HRESULT HrValidateDevice(
    IXMLDOMNodePtr & pNodeDevice)
{
    TraceTag(ttidValidate, "");
    HRESULT hr = S_OK;

    TraceHr(ttidValidate, FAL, hr, FALSE, "");
    return hr;
}
*/

// IUPnPValidationManager methods

STDMETHODIMP CValidationManager::ValidateDescriptionDocument(
    /*[in]*/ BSTR bstrTemplate,
    /*[out, string]*/ wchar_t ** pszErrorString)
{
    CHECK_POINTER(bstrTemplate);
    CHECK_POINTER(pszErrorString);
    HRESULT hr = S_OK;
    CUString strErrorString;
    *pszErrorString = NULL;

    IXMLDOMDocumentPtr pDoc;
    IXMLDOMNodePtr pRootNode;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = HrGetDocumentAndRootNode(bstrTemplate, pDoc, pRootNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = HrValidatePresenceItems(pRootNode, c_nRootItems, g_arpiRootItems, strErrorString);
        if(SUCCEEDED(hr))
        {
            hr = HrIsNodePresentOnce(L"/root/device", pRootNode);
            if(S_OK == hr)
            {
                hr = HrIsNodePresentOnce(L"/root/URLBase", pRootNode);
                if (S_OK != hr)
                {
                    hr = HrValidateUDNs(pRootNode, strErrorString);
                    if(SUCCEEDED(hr))
                    {
                        IXMLDOMNodePtr pNodeDevice;
                        hr = HrSelectNode(L"/root/device", pRootNode, pNodeDevice);
                        if(SUCCEEDED(hr))
                        {
                            hr = HrValidateDevice(pNodeDevice, strErrorString);
                        }
                    }
                }
                else
                {
                    hr = strErrorString.HrAssign(
                        WszLoadString(_Module.GetResourceInstance(), IDS_URLBASE_PRESENT));
                    if(SUCCEEDED(hr))
                    {
                        hr = UPNP_E_REQUIRED_ELEMENT_ERROR;
                    }
                }
            }
            else
            {
                hr = strErrorString.HrAssign(
                    WszLoadString(_Module.GetResourceInstance(), IDS_ROOT_DEVICE_MISSING));
                if(SUCCEEDED(hr))
                {
                    hr = UPNP_E_REQUIRED_ELEMENT_ERROR;
                }
            }
        }
    }

    // Let's make sure the root namespace is according to spec
    //
    if (SUCCEEDED(hr))
    {
        IXMLDOMNodePtr  pNodeRootSub;

        hr = HrSelectNode(L"/root", pRootNode, pNodeRootSub);
        if (SUCCEEDED(hr))
        {
            BSTR    bstrUri;

            hr = pNodeRootSub->get_namespaceURI(&bstrUri);
            if (S_OK != hr || lstrcmpi(bstrUri,
                                       L"urn:schemas-upnp-org:device-1-0"))
            {
                hr = strErrorString.HrPrintf(
                    WszLoadString(_Module.GetResourceInstance(),
                                  IDS_INVALID_ROOT_NAMESPACE),
                    bstrUri);
                if(SUCCEEDED(hr))
                {
                    hr = UPNP_E_INVALID_ROOT_NAMESPACE;
                }
            }
        }
    }

    if(FAILED(hr))
    {
        if(strErrorString.GetLength())
        {
            strErrorString.HrGetCOM(pszErrorString);
        }
    }
    TraceHr(ttidValidate, FAL, hr, FALSE, "CValidationManager::ValidateDescriptionDocument(%S)",
            *pszErrorString ? *pszErrorString : L"Unspecified");
    return hr;
}

STDMETHODIMP CValidationManager::ValidateServiceDescription(
    /*[in, string]*/ const wchar_t * szFullPath,
    /*[out, string]*/ wchar_t ** pszErrorString)
{
    CHECK_POINTER(szFullPath);
    CHECK_POINTER(pszErrorString);
    HRESULT hr = S_OK;
    CUString strErrorString;
    *pszErrorString = NULL;

    BSTR                bstrPath;
    IXMLDOMDocumentPtr  pDoc;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        bstrPath = SysAllocString(szFullPath);
    }

    if (bstrPath)
    {
        hr = HrLoadDocumentFromFile(bstrPath, pDoc);
        if (SUCCEEDED(hr))
        {
            IXMLDOMElementPtr pxdeSDRoot;

            hr = pDoc->get_documentElement(pxdeSDRoot.AddressOf());
            if (S_OK == hr)
            {
                hr = HrValidateServiceDescription(pxdeSDRoot, pszErrorString);
            }
        }
        else
        {
            hr = strErrorString.HrPrintf(
                WszLoadString(_Module.GetResourceInstance(), IDS_INVALID_XML),
                szFullPath);
            if(SUCCEEDED(hr))
            {
                hr = UPNP_E_INVALID_XML;
            }
        }

        SysFreeString(bstrPath);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(FAILED(hr))
    {
        if(strErrorString.GetLength())
        {
            strErrorString.HrGetCOM(pszErrorString);
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "CValidationManager::ValidateServiceDescription(%S)",
            *pszErrorString ? *pszErrorString : L"Unspecified");
    return hr;
}

HRESULT CValidationManager::ValidateServiceDescriptions(const wchar_t * szResourcePath,
                                                        IXMLDOMNodePtr pRootNode,
                                                        wchar_t ** pszErrorString)
{
    HRESULT     hr = S_OK;

    IXMLDOMNodeListPtr pNodeList;

    // Select all of the SCPDURL nodes in the description document
    hr = HrSelectNodes(L"//device/serviceList/service/SCPDURL",
                       pRootNode, pNodeList);
    
    while (S_OK == hr)
    {
        IXMLDOMNodePtr  pNode;
        CUString        strUrl;
        
        hr = pNodeList->nextNode(pNode.AddressOf());
        if (S_OK == hr)
        {
            hr = HrGetNodeText(pNode, strUrl);
            if (SUCCEEDED(hr))
            {
                CUString    strFullPath;
                
                hr = HrMakeFullPath(szResourcePath, strUrl, strFullPath);
                if (SUCCEEDED(hr))
                {
                    hr = ValidateServiceDescription(strFullPath,
                                                    pszErrorString);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // normalize error code
        hr = S_OK;
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "CValidationManager::ValidateServiceDescriptions(%S)",
            *pszErrorString ? *pszErrorString : L"Unspecified");
    return hr;
}

HRESULT CValidationManager::ValidateIconFiles(const wchar_t * szResourcePath,
                                              IXMLDOMNodePtr pRootNode,
                                              wchar_t ** pszErrorString)
{
    HRESULT             hr = S_OK;
    IXMLDOMNodeListPtr  pNodeList;
    CUString            strErrorString;

    // Select all of the SCPDURL nodes in the description document
    hr = HrSelectNodes(L"//device/iconList/icon/url", pRootNode, pNodeList);
    while (S_OK == hr)
    {
        IXMLDOMNodePtr  pNode;
        CUString        strUrl;

        hr = pNodeList->nextNode(pNode.AddressOf());
        if (S_OK == hr)
        {
            hr = HrGetNodeText(pNode, strUrl);
            if (SUCCEEDED(hr))
            {
                CUString    strFullPath;

                hr = HrMakeFullPath(szResourcePath, strUrl, strFullPath);
                if (SUCCEEDED(hr))
                {
                    if (!FFileExists((LPTSTR)strFullPath.GetBuffer(), FALSE))
                    {
                        hr = strErrorString.HrPrintf(
                            WszLoadString(_Module.GetResourceInstance(), IDS_INVALID_ICON),
                            strFullPath);
                        if(SUCCEEDED(hr))
                        {
                            hr = UPNP_E_INVALID_ICON;
                        }
                    }
                }
            }
        }
    }

    if(FAILED(hr))
    {
        if(strErrorString.GetLength())
        {
            strErrorString.HrGetCOM(pszErrorString);
        }
    }

    if (SUCCEEDED(hr))
    {
        // normalize error code
        hr = S_OK;
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "CValidationManager::ValidateIconFiles(%S)",
            *pszErrorString ? *pszErrorString : L"Unspecified");
    return hr;
}

STDMETHODIMP CValidationManager::ValidateDescriptionDocumentAndReferences(
    /*[in]*/ BSTR bstrTemplate,
    /*[in, string]*/ const wchar_t * szResourcePath,
    /*[out, string]*/ wchar_t ** pszErrorString)
{
    CHECK_POINTER(bstrTemplate);
    CHECK_POINTER(szResourcePath);
    CHECK_POINTER(pszErrorString);
    HRESULT hr = S_OK;
    *pszErrorString = NULL;

    hr = HrIsAllowedCOMCallLocality(CALL_LOCALITY_INPROC);
    
    if (SUCCEEDED(hr))
    {
        hr = ValidateDescriptionDocument(bstrTemplate, pszErrorString);
    }

    if (SUCCEEDED(hr))
    {
        IXMLDOMDocumentPtr  pDoc;
        IXMLDOMNodePtr      pRootNode;

        hr = HrGetDocumentAndRootNode(bstrTemplate, pDoc, pRootNode);
        if (SUCCEEDED(hr))
        {
            hr = ValidateServiceDescriptions(szResourcePath, pRootNode,
                                             pszErrorString);
            if (SUCCEEDED(hr))
            {
                hr = ValidateIconFiles(szResourcePath, pRootNode,
                                       pszErrorString);
            }
        }
    }

    TraceHr(ttidValidate, FAL, hr, FALSE, "CValidationManager::ValidateDescriptionDocumentAndReferences(%S)",
            *pszErrorString ? *pszErrorString : L"Unspecified");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\asp.cpp ===
/*--
Copyright (c) 1995-1999 Microsoft Corporation
Module Name: asp.cpp
Author: John Spaith
Abstract: ASP Handler
--*/
#include "pch.h"
#pragma hdrstop

#include "httpd.h"


//****************************************************************
//  Called by httpd before running ASP
//****************************************************************


BOOL InitASP(SCRIPT_LANG *psl, UINT *plCodePage, LCID *plcid)
{
    CReg reg(HKEY_LOCAL_MACHINE, RK_ASP);
    PCWSTR pwszLanguage = NULL;     // don't free this, points to a buffer inside CReg

    if (NULL != (pwszLanguage = reg.ValueSZ(RV_ASP_LANGUAGE)) &&
        (0 == _wcsicmp(pwszLanguage,L"JSCRIPT") ||
         0 == _wcsicmp(pwszLanguage,L"JAVASCRIPT")))
    {
        *psl = JSCRIPT;
    }
    else
        *psl = VBSCRIPT;

    *plCodePage = (UINT) reg.ValueDW(RV_ASP_CODEPAGE,CP_ACP);
    *plcid      = (LCID) reg.ValueDW(RV_ASP_LCID,LOCALE_SYSTEM_DEFAULT);

    TraceTag(ttidWebServer, "ASP Registry defaults -- language = %s, lcid = %d, codepage = %d\r\n",
                       (*psl == JSCRIPT) ? L"JSCRIPT" : L"VBSCRIPT", *plCodePage, *plcid);
    return TRUE;
}


// This is the only fcn that httpd calls to get the ASP.dll loaded and running.

// NOTE:  The ASP dll is responsible for reporting all it's own error messages.
// The only time httpd does this is if the ASP AV'd or if the file wasn't found.
// ExecuteASP in asp.dll only returns FALSE if there was an AV.

BOOL CHttpRequest::ExecuteASP()
{
    DEBUG_CODE_INIT;
    DWORD dwRet = HSE_STATUS_ERROR;
    ASP_CONTROL_BLOCK ACB;
    CISAPI *pISAPI = NULL;
    HINSTANCE hInst = 0;

    // First make sure file exists.  If it doesn't, don't bother making the call
    // to the dll.
    if ( (DWORD)-1 == GetFileAttributes(m_wszPath))
    {
        m_rs = GLEtoStatus( GetLastError());
        myleave(620);
    }

    if (NULL==(hInst=g_pVars->m_pISAPICache->Load(ASP_DLL_NAME,&pISAPI,SCRIPT_TYPE_ASP)))
    {
        m_rs = STATUS_INTERNALERR;
        myleave(621);
    }

    if (! FillACB((void *) &ACB,hInst))
    {
        // FillACB does the right thing in this case, don't do anything here.
        myleave(0);
    }

    StartRemoveISAPICacheIfNeeded();

    __try
    {
        dwRet = pISAPI->CallASP(&ACB);
    }
    __except(1)
    {
        m_rs = STATUS_INTERNALERR;
        g_pVars->m_pLog->WriteEvent(IDS_HTTPD_EXT_EXCEPTION,L"asp.dll",GetExceptionCode(),"HttpExtensionProc",GetLastError());
        myleave(623);
    }

    m_fKeepAlive = (dwRet==HSE_STATUS_SUCCESS_AND_KEEP_CONN);


    done:
    // Don't free hInsnt.  The cache does this automatically.


    TraceTag(ttidWebServer, "ExecuteASP Failed, err = %d, GLE = %d",err,GetLastError());
    g_pVars->m_pISAPICache->Unload(pISAPI);

    return(dwRet!=HSE_STATUS_ERROR);
}

//**************************************************************
//  Callback fcns for ASP
//**************************************************************



//  Modifies headers in our extended header information for Response Put Methods.
BOOL WINAPI AddHeader (HCONN hConn, LPSTR lpszName, LPSTR lpszValue)
{
    CHECKHCONN(hConn);
    return((CHttpRequest*)hConn)->m_bufRespHeaders.AddHeader(lpszName, lpszValue,TRUE);
}


//  If there's a buffer, flush it to sock.
BOOL WINAPI Flush(HCONN hConn)
{
    CHECKHCONN(hConn);
    CHttpRequest *pRequest = (CHttpRequest*)hConn;

    // all these rules straight from docs
    if (FALSE == pRequest->m_fBufferedResponse)
        return FALSE;

    return pRequest->m_bufRespBody.SendBuffer(pRequest->m_socket,pRequest);
}


//  If there's a buffer, clear it.
BOOL WINAPI Clear(HCONN hConn)
{
    CHECKHCONN(hConn);
    CHttpRequest *pRequest = (CHttpRequest*)hConn;

    // all these rules straight from docs
    if (FALSE == pRequest->m_fBufferedResponse)
        return FALSE;

    pRequest->m_bufRespBody.Reset();
    return TRUE;
}


//  Toggles buffer.  Error checking on this done in ASP calling fnc.
BOOL WINAPI SetBuffer(HCONN hConn, BOOL fBuffer)
{
    CHECKHCONN(hConn);
    ((CHttpRequest*)hConn)->m_fBufferedResponse = fBuffer;

    return TRUE;
}


//  Setup struct for ASP dll
BOOL CHttpRequest::FillACB(void *p, HINSTANCE hInst)
{
    PASP_CONTROL_BLOCK pcb = (PASP_CONTROL_BLOCK) p;
    pcb->cbSize = sizeof(ASP_CONTROL_BLOCK);
    pcb->ConnID = (HCONN) this;

    pcb->cbTotalBytes = m_dwContentLength;
    pcb->wszFileName = m_wszPath;
    pcb->pszVirtualFileName = m_pszURL;


    if (m_dwContentLength)
    {
        // If we've received > m_dwPostReadSize bytes POST data, need to do ReadClient.
        // This is an unlikely scenario - if they want to do huge file uploads
        // we'll point them to ISAPI ReadClient.  We've read in 1st buf already.

        if (m_dwContentLength > g_pVars->m_dwPostReadSize)
        {
            HRINPUT hi = m_bufRequest.RecvBody(m_socket, m_dwContentLength - g_pVars->m_dwPostReadSize,TRUE);

            if (hi != INPUT_OK && hi != INPUT_NOCHANGE)
            {
                CHttpResponse resp(m_socket,m_rs = STATUS_BADREQ,CONN_CLOSE,this);
                resp.SendResponse();
                return FALSE;
            }

            if (g_pVars->m_fFilters  && hi != INPUT_NOCHANGE &&
                ! CallFilter(SF_NOTIFY_READ_RAW_DATA))
            {
                return FALSE;
            }
        }
        pcb->pszForm = (PSTR) m_bufRequest.Data();
    }
    else
        pcb->pszForm = NULL;

    pcb->pszQueryString = m_pszQueryString;
    pcb->pszCookie = m_pszCookie;
    pcb->scriptLang = g_pVars->m_ASPScriptLang;
    pcb->lcid = g_pVars->m_ASPlcid;
    pcb->lCodePage = g_pVars->m_lASPCodePage;
    pcb->hInst = hInst;

    pcb->GetServerVariable = ::GetServerVariable;
    pcb->WriteClient = ::WriteClient;
    pcb->ServerSupportFunction = ::ServerSupportFunction;
    pcb->AddHeader = ::AddHeader;
    pcb->Flush = ::Flush;
    pcb->Clear = ::Clear;
    pcb->SetBuffer = ::SetBuffer;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\buffio.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: BUFFIO.CPP
Author: Arul Menezes
Abstract: Buffer handling class & socket IO helpers
--*/
#include "pch.h"
#pragma hdrstop

#include "httpd.h"


// Wait for input on socket with timeout
int MySelect(SOCKET sock, DWORD dwMillisecs)
{
    fd_set set;
    struct timeval t;

    if (dwMillisecs != INFINITE)
    {
        t.tv_sec = (dwMillisecs / 1000);
        t.tv_usec = (dwMillisecs % 1000)*1000;
    }

    FD_ZERO(&set);
    FD_SET(sock, &set);

    TraceTag(ttidWebServer, "Calling select(%x). Timeout=%d", sock, dwMillisecs);
    int iRet = select(0, &set, NULL, NULL, ((dwMillisecs==INFINITE) ? NULL : (&t)));
    TraceTag(ttidWebServer, "Select(%x) got %d", sock, iRet);
    return iRet;
}

// Semi-blocking wait for input on a socket. This function will exit either
// when input is available or when the shutdown event has been set
//
int MySelect2(SOCKET sock, DWORD dwMillisecs)
{
    HANDLE  hEvent;
    int     iRet = 0;
    HANDLE  rgHandles[2];

    hEvent = WSACreateEvent();
    if (hEvent != WSA_INVALID_EVENT)
    {
        rgHandles[0] = hEvent;
        rgHandles[1] = g_pVars->m_hEventShutdown;

        iRet = WSAEventSelect(sock, hEvent, FD_READ);
        if (!iRet)
        {
            DWORD   dwRet;

            dwRet = WaitForMultipleObjects(2, rgHandles, FALSE, dwMillisecs);
            if (WAIT_OBJECT_0 == dwRet)
            {
                // iRet should be 1 if input is available
                iRet = 1;
            }
        }

        CloseHandle(hEvent);
    }

    return iRet;
}

// need space for iLen more data
BOOL CBuffer::AllocMem(DWORD dwLen)
{
    // figure out buffer size
    DWORD dwAlloc = max(MINBUFSIZE, dwLen);

    // allocate or reallocate buffer
    if (!m_pszBuf)
    {
        m_pszBuf = MyRgAllocZ(char, dwAlloc);
        TraceTag(ttidWebServer, "New buffer (data=%d size=%d buf=0x%08x)", dwLen, dwAlloc, m_pszBuf);
        m_iSize = dwAlloc;
    }
    else if ((m_iSize-m_iNextIn) <= (int)dwLen)
    {
        m_pszBuf = MyRgReAlloc(char, m_pszBuf, m_iSize, dwAlloc+m_iSize);
        TraceTag(ttidWebServer, "Realloc buffer (datasize=%d oldsize=%d size=%d buf=0x%08x)", dwLen, m_iSize, dwAlloc+m_iSize, m_pszBuf);
        m_iSize += dwAlloc;
    }
    if (!m_pszBuf)
    {
        TraceTag(ttidWebServer, "CBuffer:AllocMem(%d) failed. GLE=%d", dwLen, GetLastError());
        m_iNextInFollow = m_iSize = m_iNextOut = m_iNextIn = 0;
        m_chSaved = 0;
        return FALSE;
    }
    return TRUE;
}

// Pull in all white space before a request.  Note:  We techinally should let
// the filter get this too, but too much work.  Also note that we could read
// past a double CRLF if there was only white space before it, again this
// is a strange enough condition that we don't care about it.
BOOL CBuffer::TrimWhiteSpace()
{
    int i = 0, j = 0;

    while ( isspace(m_pszBuf[i]) && i < m_iNextIn)
    {
        i++;
    }

    if (i == 0)
        return TRUE;

    if (i == m_iNextIn)
        return FALSE;  // need to read more data, all white spaces so far.

    for (j = 0; j < m_iNextIn - i; j++)
        m_pszBuf[j] = m_pszBuf[j+i];

    m_iNextIn -= i;

    TraceTag(ttidWebServer, "HTTPD: TrimWhiteSpace removing first %d bytes from steam",i);
    return TRUE;
}


// This function reads eitehr request-headers from the socket
// terminated by a double CRLF, OR reads a post-body from the socket
// terminated by having read the right number of bytes
//
// We are keeping the really simple--we read the entire header
// into one contigous buffer before we do anything.
//
// dwLength is -1 for reading headers, or Content-Length for reading body
// or 0 is content-length is unknown, in which case it reads until EOF

HRINPUT CBuffer::RecvToBuf(SOCKET sock, DWORD dwLength, DWORD dwTimeout, BOOL fFromFilter)
{
    DEBUG_CODE_INIT;
    int iScan = 0;
    HRINPUT ret = INPUT_ERROR;
    DWORD dwBytesRemainingToBeRead;

    // Both IE and Netscape tack on a trailing \r\n to POST data but don't
    // count it as part of the Content-length.  IIS doesn't pass the \r\n
    // to the script engine, so we don't either.  To do this, we set
    // the \r to \0.  Also we reset m_iNextIn.  This \r\n code is only
    // relevant when RecvToBuf is called from HandleRequest, otherwise
    // we assume it's a filter calling us and don't interfere.

    if (dwLength != -1)
    {
        if (!fFromFilter && ((m_iNextIn-m_iNextOut) >= (int) dwLength))
        {
           if (((m_iNextIn-m_iNextOut) == (int) dwLength) ||
              ((m_iNextIn-m_iNextOut) == (int) dwLength+2))
           {
               m_iNextIn = m_iNextOut + dwLength;
               // This is reachable from HandleRequest, and
               myretleave(INPUT_NOCHANGE,0);
           }
           else
           {
               myretleave(INPUT_ERROR, 111);
           }
        }
        if (!fFromFilter)
        {
            dwLength = dwLength - (m_iNextIn - m_iNextOut);   // account for amount of POST data already in
        }
        m_iNextInFollow = m_iNextIn;

        // allocate or reallocate buffer.  Since we already know size we want, do it here rather than later.
        if (!AllocMem(dwLength+1))
            myretleave(INPUT_ERROR, 103);
    }
    dwBytesRemainingToBeRead = dwLength;

    for (;;)
    {
        // see if we got the double CRLF for HTTP Headers.
        if (dwLength == (DWORD)-1)
        {
            BOOL fScan = TRUE;
            if (iScan == 0 && m_iNextIn)
            {
                fScan = TrimWhiteSpace();
            }
            if (fScan)
            {
                while (iScan+3 < m_iNextIn)
                {
                    if (m_pszBuf[iScan]=='\r' && m_pszBuf[iScan+1]=='\n' && m_pszBuf[iScan+2]=='\r' && m_pszBuf[iScan+3]=='\n')
                    {
                        myretleave(INPUT_OK,0);
                    }
                    iScan++;
                }
            }
        }
        // else see if we have the number of bytes we want.
        // Browsers sometimes tack an extra \r\n to very end of POST data, even
        // though they don't include it in the Content-Length field.  IIS
        // never passes this extra \r\n to ISAPI extensions, neither do we.
        else if ((m_iNextIn-m_iNextInFollow) >= (int)dwLength)
        {
            DEBUGCHK((int)dwLength  + 2 == (m_iNextIn-m_iNextInFollow) ||
                     (int)dwLength == (m_iNextIn-m_iNextInFollow));

            DEBUGCHK(dwBytesRemainingToBeRead == 0);
            m_iNextIn = m_iNextInFollow+(int)dwLength;  // don't copy trailing \r\n
            myretleave(INPUT_OK,0);
        }

        // check if we have input. If we are waiting for subsequent input (i.e. not the start of a request)
        // then drop the timeout value lower, and if we timeout return ERROR, not TIMEOUT
        switch (MySelect2(sock, ((m_iNextIn ? RECVTIMEOUT : dwTimeout))))
        {
            case 0:             myretleave((m_iNextIn ? INPUT_ERROR : INPUT_TIMEOUT),100);
            case SOCKET_ERROR:  myretleave(INPUT_ERROR, 101);
        }

        // check how much input is waiting
        DWORD dwAvailable;
        if (ioctlsocket(sock, FIONREAD, &dwAvailable))
            myretleave(INPUT_ERROR, 102);

        DWORD dwBytesToRecv;

        if (dwLength == -1)         // Read in as much http header as we have.
        {
            dwBytesToRecv = dwAvailable;

            // allocate or reallocate buffer.  For headers, have to do it each pass.
            if (!AllocMem(dwAvailable+1))
                myretleave(INPUT_ERROR, 103);
        }
        else                        // Read in only requested amount of POST
            dwBytesToRecv = (dwAvailable < dwBytesRemainingToBeRead) ? dwAvailable : dwBytesRemainingToBeRead;


        DEBUGCHK((m_iSize-m_iNextIn) >= (int)dwBytesToRecv);
        DEBUGCHK(m_iNextIn >= m_iNextOut);
        DEBUGCHK(m_iNextIn >= m_iNextInFollow);

        // safe to call recv, because we know we have something. It will return immediately
        int iRecv = recv(sock, m_pszBuf+m_iNextIn, dwBytesToRecv, 0);
        TraceTag(ttidWebServer, "recv(%x) got %d", sock, iRecv);

        if (iRecv == 0)
        {
            myretleave((m_iNextIn ? INPUT_OK : INPUT_TIMEOUT), 0);
        } // got EOF. If we have any data return OK, else return TIMEOUT
        else if (iRecv == SOCKET_ERROR)
        {
            myretleave(((GetLastError()==WSAECONNRESET) ? INPUT_TIMEOUT : INPUT_ERROR), 104);
        }

        m_iNextIn += iRecv;
        dwBytesRemainingToBeRead -= iRecv;
        DEBUGCHK(m_iSize >= m_iNextIn);
    }
    DebugBreak(); // no fall through

    done:
    // Always make this buffer into a null terminated string
    if (m_pszBuf)
        m_pszBuf[m_iNextIn] = 0;

    TraceTag(ttidWebServer, "end RecvToBuf (ret=%d err=%d iGLE=%d)", ret, err, GLE(err));
    return ret;
}


// tokenize the input stream: We always skip leading white-space
// once we're in the token, we stop on whitespace or EOL, depending
// on the fWS param
BOOL CBuffer::NextToken(PSTR* ppszTok, int* piLen, BOOL fWS, BOOL fColon /*=FALSE*/)
{
    int i, j;
    // restore saved char, if any
    if (m_chSaved)
    {
        DEBUGCHK(m_pszBuf[m_iNextOut]==0);
        m_pszBuf[m_iNextOut] = m_chSaved;
        m_chSaved = 0;
    }

    for (i=m_iNextOut; i<m_iNextIn; i++)
    {
        // if not whitespace break
        if (! (m_pszBuf[i]==' ' || m_pszBuf[i]=='\t') )
            break;
    }
    for (j=i; j<m_iNextIn; j++)
    {
        // if we get an EOL, it's always end of token
        if (m_pszBuf[j]=='\r' || m_pszBuf[j]=='\n')
            break;
        // if fWS==TRUE and we got white-space, then end of token
        if (fWS && (m_pszBuf[j]==' ' || m_pszBuf[j]=='\t'))
            break;
        if (fColon && m_pszBuf[j]==':')
        {
            j++; // we want to return the colon
            break;
        }

    }
    m_iNextOut = j;
    *piLen = (int)(INT_PTR)((j-i));
    *ppszTok = &(m_pszBuf[i]);
    if (i==j)
    {
        TraceTag(ttidWebServer, "Got NULL token");
        return FALSE;
    }
    else
    {
        // save a char so we can null-terminate the current token
        m_chSaved = m_pszBuf[m_iNextOut];
        m_pszBuf[m_iNextOut] = 0;
        TraceTag(ttidWebServer, "Got token (%s) Len %d", *ppszTok, (*piLen));
        return TRUE;
    }
}

// skip rest of current line and CRLF
BOOL CBuffer::NextLine()
{
    int i, j;

    // restore saved char, if any
    if (m_chSaved)
    {
        DEBUGCHK(m_pszBuf[m_iNextOut]==0);
        m_pszBuf[m_iNextOut] = m_chSaved;
        m_chSaved = 0;
    }
    for (i=m_iNextOut, j=i+1; j<m_iNextIn; i++, j++)
    {
        if (m_pszBuf[i]=='\r' && m_pszBuf[j]=='\n')
        {
            m_iNextOut = j+1;
            TraceTag(ttidWebServer, "NextLine: OK");
            return TRUE;
        }
    }
    TraceTag(ttidWebServer, "NextLine: error");
    return FALSE;
}

// used only on output buffers by ASP
BOOL CBuffer::AppendData(PSTR pszData, int iLen)
{
    // make sure we have enough memory
    if (!AllocMem(iLen+1))
        return FALSE;

    DEBUGCHK((m_iSize-m_iNextIn) >= iLen);
    memcpy(m_pszBuf+m_iNextIn, pszData, iLen);
    m_iNextIn += iLen;
    return TRUE;
}



BOOL CBuffer::SendBuffer(SOCKET sock, CHttpRequest *pRequest)
{
    PSTR pszSendBuf = m_pszBuf;     // use temp ptrs in case filter changes them
    int cbSendBuf = m_iNextIn;
    DWORD fRet = FALSE;

    DEBUGCHK(m_iNextOut==0);
    DEBUGCHK(m_chSaved==0);
    if (!m_iNextIn)
    {
        TraceTag(ttidWebServer, "SendBuffer: empty");
        return TRUE;
    }

    if (g_pVars->m_fFilters &&
        ! pRequest->CallFilter(SF_NOTIFY_SEND_RAW_DATA, &pszSendBuf, &cbSendBuf))

        goto done;

    if (cbSendBuf != send(sock, pszSendBuf, cbSendBuf, 0))
    {
        TraceTag(ttidWebServer, "SendBuffer FAILED. GLE=%d", GetLastError());
        goto done;
    }

    fRet = TRUE;
    done:
    m_iNextIn = 0;
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\callback.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: filter.cpp
Author: John Spaith
Abstract: ISAPI Filter call back functions
--*/

// BUGBUG - don't support advanced header management on SF_NOTIFY_SEND_RESPONSE.
// IIS allows response headers to be deleted or set to different values after
// they are set with a call to SetHeader or AddHeader.
// Fix:  None.  This takes +300 lines of code, doesn't add much.  Instead we
// dump all header data in a buffer.
#include "pch.h"
#pragma hdrstop


#include "httpd.h"


//  Allocates and returns a buffer size cbSize.  This will be deleted at the
//  end of the session.

//  The MSDN docs on this claim this returns a BOOL.  Looking in httpfilt.h
//  shows that the actual implementation is a VOID *.

VOID* WINAPI AllocMem(PHTTP_FILTER_CONTEXT pfc, DWORD cbSize, DWORD dwReserved)
{
    CHECKPFC(pfc);
    //  NOTE:  alloc mem isn't directly related to connection, don't check m_pFINfo->fAccept like
    //  the other filters do

    return((CHttpRequest*)pfc->ServerContext)->m_pFInfo->AllocMem(cbSize,dwReserved);
}

VOID* CFilterInfo::AllocMem(DWORD cbSize, DWORD dwReserved)
{
    if (cbSize == 0)
        return NULL;

    if (NULL == m_pAllocMem)
    {
        m_pAllocMem = MyRgAllocZ(PVOID,VALUE_GROW_SIZE);
        if (! (m_pAllocMem))
        {
            TraceTag(ttidWebServer, "CFilterInfo::AllocMem failed on inital alloc, GLE=%d",GetLastError());
            return NULL;
        }
    }
    else if (m_nAllocBlocks % VALUE_GROW_SIZE == 0)
    {
        m_pAllocMem = MyRgReAlloc(PVOID,m_pAllocMem,m_nAllocBlocks,m_nAllocBlocks + VALUE_GROW_SIZE);
        if ( !m_pAllocMem)
        {
            TraceTag(ttidWebServer, "CFilterInfo::AllocMem failed on re-allocing for block %d, GLE=%d",m_nAllocBlocks+1,GetLastError());
            return NULL;
        }
    }

    if (! (m_pAllocMem[m_nAllocBlocks] = MyRgAllocNZ(PVOID,cbSize)))
    {
        TraceTag(ttidWebServer, "CFilterInfo::AllocMem failed on allocating block %d, GLE=%d",m_nAllocBlocks+1,GetLastError());
        return NULL;
    }

    m_nAllocBlocks++;
    return m_pAllocMem[m_nAllocBlocks-1];
}


void CFilterInfo::FreeAllocMem()
{
    DWORD dwI;

    if (0 == m_nAllocBlocks || ! (m_pAllocMem))
        return;

    for (dwI = 0; dwI < m_nAllocBlocks; dwI++)
    {
        MyFree(m_pAllocMem[dwI]);
    }
    MyFree(m_pAllocMem);
}


//   Adds httpd headers.
//   In effect this is identical to a call to SetHeader or AddHeader except that
//   the user formats the whole string (name and value) before caalling
//   AddResponseHeaders, in Add/Set Header they come in 2 seperate fields.

BOOL WINAPI AddResponseHeaders(PHTTP_FILTER_CONTEXT pfc,LPSTR lpszHeaders,DWORD dwReserved)
{
    CHECKPFC(pfc);
    CHECKPTR(lpszHeaders);
    CHECKFILTER(pfc);

    if (dwReserved != 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return((CHttpRequest*)pfc->ServerContext)->AddResponseHeaders(lpszHeaders,dwReserved);
}



BOOL CHttpRequest::AddResponseHeaders(LPSTR lpszHeaders,DWORD dwReserved)
{
    // Can't set response headers on 0.9 version.  Err code is like IIS.
    if (m_dwVersion <= MAKELONG(9, 0))
    {
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }


    // According to MSDN, it's invalid to use this fcn during or after
    // SEND_RESPONSE event.  However, IIS doesn't report an error if
    // this is called when it shouldn't be, so neither do we.
    if ( m_pFInfo->m_dwSFEvent & (SF_NOTIFY_END_OF_NET_SESSION | SF_NOTIFY_END_OF_REQUEST |
                                  SF_NOTIFY_LOG | SF_NOTIFY_SEND_RAW_DATA |
                                  SF_NOTIFY_SEND_RESPONSE))
        return TRUE;

    //  Note:  We don't use CBuffer::AddHeaders because it does formatting, we assume
    //  here filter alreadf formatted everything correctly.

    return m_bufRespHeaders.AppendData(lpszHeaders, strlen(lpszHeaders));
}

BOOL WINAPI GetServerVariable(PHTTP_FILTER_CONTEXT pfc, PSTR psz, PVOID pv, PDWORD pdw)
{
    CHECKPFC(pfc);
    CHECKPTRS3(psz, pv, pdw);

    // We don't check m_fFAccept here because this function is read only,
    // doesn't try and do anything across the network.  Like IIS.
    return((CHttpRequest*)pfc->ServerContext)->GetServerVariable(psz, pv, pdw, TRUE);
}

BOOL WINAPI WriteClient(PHTTP_FILTER_CONTEXT pfc, PVOID pv, PDWORD pdw, DWORD dwFlags)
{
    CHECKPFC(pfc);
    CHECKPTRS2(pv, pdw);
//  CHECKFILTER(pfc);    // IIS always accepts WriteClient, even if filter has returned an error at some point.

    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    return((CHttpRequest*)pfc->ServerContext)->WriteClient(pv,pdw,TRUE);
}

//  Misc Server features.  See MSDN for full docs.
BOOL WINAPI ServerSupportFunction(PHTTP_FILTER_CONTEXT pfc, enum SF_REQ_TYPE sfReq,
                                  PVOID pData, ULONG_PTR ul1, ULONG_PTR ul2)
{
    CHECKPFC(pfc);
    CHECKFILTER(pfc);

    return((CHttpRequest*)pfc->ServerContext)->ServerSupportFunction(sfReq, pData, ul1, ul2);
}



BOOL CHttpRequest::ServerSupportFunction(enum SF_REQ_TYPE sfReq,PVOID pData,
                                         ULONG_PTR ul1, ULONG_PTR ul2)
{
    switch (sfReq)
    {
        case SF_REQ_ADD_HEADERS_ON_DENIAL:
            {
                return MyStrCatA(&m_pFInfo->m_pszDenyHeader,(PSTR) pData);
            }

        case SF_REQ_DISABLE_NOTIFICATIONS:
            {
                // u11 has data as to which flags to deactivate for this session,

                // For example, setting u11 = SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_LOG
                // would disable notifications to the filter that called this fcn for
                // those events on this request only (per request, not per session!).
                // These values are reset to 1's at the end of each request in CHttpRequest::ReInit

                m_pFInfo->m_pdwEnable[m_pFInfo->m_iFIndex] &=  (m_pFInfo->m_pdwEnable[m_pFInfo->m_iFIndex] ^ ul1);
                return TRUE;
            }


        case SF_REQ_SEND_RESPONSE_HEADER:
            {
                // no Connection header...let ISAPI send one if it wants
                CHttpResponse resp(m_socket, STATUS_OK, CONN_CLOSE,this);
                m_rs = STATUS_OK;
                // no body, default or otherwise (leave that to the ISAPI), but add default headers
                resp.SendResponse((PSTR) ul1, (PSTR) pData, TRUE);


                // The reasons for doing this are documented in FilterNoResponse()
                // Note:  We don't check this sent headers here because IIS doesn't,
                // so it's possible to make multiple calls with this option even though it
                // doesn't make that much sense for a filter to do so.

                m_pFInfo->m_fSentHeaders = TRUE;
                m_fKeepAlive = FALSE;
                return TRUE;
            }

        case SF_REQ_SET_NEXT_READ_SIZE:
            {
                m_pFInfo->m_dwNextReadSize = (DWORD)ul1;
                return TRUE;
            }


            // BUGBUG -- unsupported flags.
//      case SF_REQ_NORMALIZE_URL:      // TBD
//      case SF_REQ_GET_CONNID:         // IIS doesn't support in versions 4+
//      case SF_REQ_GET_PROPERTY:       // Relates to meta database IIS uses but we don't
//      case SF_REQ_SET_PROXY_INFO:     // No proxy stuff in CE
        default:
            {
                TraceTag(ttidWebServer, "Unsupported or invald ServerSupportFcn request = 0x%08x",sfReq);
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
    }

    return TRUE;
}



//***************************************************************************
// Extended filter header options
//
// These fcns allow the filter to perform more advanced header fncs automatically,
// On PREPROC_HEADERS event, it's possible for the filter to change CHttpRequest
// state information through the SetHeaders and AddHeaders callback.  We support
// changing URL, Version, If-modified-since, and method through the preproc
// headers calls.

// In a SEND_RESPONSE event, it's possible for the filter to modify the response
// headers through SetHEaders or AddHeaders.

// Unlike IIS, we don't allow the filter to delete a header once it's set, or
// to overwrite a header's information with new info.  We only allow the header
// data to be appended to.

//***************************************************************************


BOOL WINAPI GetHeader(PHTTP_FILTER_CONTEXT pfc, LPSTR lpszName, LPVOID lpvBuffer, LPDWORD lpdwSize)
{
    CHECKPFC(pfc);
    CHECKPTRS3(lpszName, lpvBuffer, lpdwSize);
    CHECKFILTER(pfc);

    return((CHttpRequest*)pfc->ServerContext)->GetHeader(lpszName, lpvBuffer, lpdwSize);
}

BOOL WINAPI SetHeader(PHTTP_FILTER_CONTEXT pfc, LPSTR lpszName, LPSTR lpszValue)
{
    CHECKPFC(pfc);
    CHECKPTRS2(lpszName, lpszValue);
    CHECKFILTER(pfc);

    return((CHttpRequest*)pfc->ServerContext)->SetHeader(lpszName, lpszValue);
}


// Retrieves raw header value for specified name.
BOOL CHttpRequest::GetHeader(LPSTR lpszName, LPVOID lpvBuffer, LPDWORD lpdwSize)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    DWORD cbSizeNeeded;
    char szBuf[MAXHEADERS];
    PSTR pszRet = (PSTR)-1;
    PSTR pszTrav = NULL;
    PSTR pszEndOfHeaders = NULL;
    DWORD cbName;


    // this is the only event we allow this for.  This is like IIS, but not docced in MSDN.
    if (m_pFInfo->m_dwSFEvent != SF_NOTIFY_PREPROC_HEADERS)
    {
        SetLastError(ERROR_INVALID_INDEX);
        myleave(1405);
    }

    // For method, url, and version (from simple request line) we get the data
    // from CHttpRequest

    if (0==_stricmp(lpszName, "version"))
    {
        // There's no sprintf in older versions of CE.
        // sprintf(szBuf, "HTTP/%d.%d", HIWORD(m_dwVersion), LOWORD(m_dwVersion));

        WriteHTTPVersion(szBuf,m_dwVersion);
        pszRet = szBuf;
    }
    else if (0 == _stricmp(lpszName, "url"))
        pszRet = m_pszURL;
    else if (0 == _stricmp(lpszName, "method"))
        pszRet = m_pszMethod;
    else
    {
        // if it's not one of the 3 special values, we search through the raw
        // buffer for the header name.
        pszTrav = (PSTR) m_bufRequest.Headers();
        pszTrav = strstr(pszTrav,cszCRLF);  // skip past simple http header
        pszEndOfHeaders = pszTrav + m_bufRequest.GetINextOut();

        cbName = strlen(lpszName);

        for (; pszTrav; pszTrav = strstr(pszTrav,cszCRLF))
        {
            pszTrav += sizeof("\r\n") - 1;

            // reached end of headers, double CRLF
            if (*pszTrav == '\r')
                break;

            // Make sure we don't walk off the end of the buffer.
            if ((int) cbName > (pszEndOfHeaders - pszTrav))
                break;

            if (0 == _memicmp(pszTrav,lpszName,cbName))
            {
                pszTrav += cbName;
                if (' ' == *pszTrav)            // must be a space next for a match
                {
                    pszRet = pszTrav + 1;
                    pszTrav = strstr(pszTrav,cszCRLF);
                    DEBUGCHK(pszTrav != NULL);  // should catch improperly formatted headers in parser
                    *pszTrav = 0;  // make this the end of string temporarily
                    break;
                }
            }
        }
    }

    if ((PSTR)(-1) == pszRet)
    {
        // unknown var
        SetLastError(ERROR_INVALID_INDEX);
        myleave(1400);
    }

    if ((cbSizeNeeded = strlen(pszRet)+1) > *lpdwSize)
    {
        *lpdwSize = cbSizeNeeded;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        myleave(1401);
    }
    memcpy(lpvBuffer, pszRet, cbSizeNeeded);
    ret = TRUE;

    done:

    TraceTag(ttidWebServer, "HTTPD:GetHeader failed with variable name<<%s>>,err = %d ",lpszName,err);

    if (pszTrav)
        *pszTrav = '\r';    // reset the value
    return ret;
}


// BUGBUG:  SetHeader and AddHeader both use SetHeader fcn, breaks IIS spec.
// Fix:  None.  On IIS for a PREPROC_HEADER event, filter can call (for instance)
// an AddHeader("URL","url.htm"), which will append to the end of the existing URL.
// In this case, if the requested URL was "foo.htm", IIS would lookup foo.htm,url.htm
// This isn't worth the hassle (the code to do it is below, though).


BOOL CHttpRequest::SetHeader(LPSTR lpszName, LPSTR lpszValue)
{
    DEBUG_CODE_INIT;
    PSTR pszNew = NULL;
    BOOL ret = FALSE;


    TraceTag(ttidWebServer, "Servicing SetHeader request with name<<%s>>,value<<%s>> ",lpszName,lpszValue);
    if (0==_stricmp(lpszName, "version"))
    {
        SetHTTPVersion(lpszValue,&m_dwVersion);
        ret = TRUE;
    }
    else if (0 == _stricmp(lpszName, "url"))
    {
        pszNew = MySzDupA(lpszValue);
        if (!pszNew)
            myleave(256);

        MyFree(m_pszURL);
        m_pszURL = pszNew;
        ret = TRUE;
    }
    else if (0 == _stricmp(lpszName, "method"))
    {
        pszNew  = MySzDupA(lpszValue);
        if (!pszNew)
            myleave(257);

        MyFree(m_pszMethod);
        m_pszMethod = pszNew;
        ret = TRUE;
    }
    // BUGBUG - changing headers on the preproc event would require advanced
    // header management.
    // Fix: None.  If the filter writer wants to change the state that headers
    // set they'll have plenty of oppurtunity to do it in later events.
    else if (m_pFInfo->m_dwSFEvent == SF_NOTIFY_PREPROC_HEADERS)
    {
        myretleave(TRUE,0);
    }
    else   // custom response header, like "Content-length:" or whatever else
    {
        // Can't set response headers on 0.9 version.  Err code is like IIS.
        if (m_dwVersion <= MAKELONG(9, 0))
        {
            SetLastError(ERROR_NOT_SUPPORTED);
            myleave(258);
        }

        ret = m_bufRespHeaders.AddHeader(lpszName,lpszValue);
    }


    done:
    TraceTag(ttidWebServer, "SetHeader failed with request with name<<%s>>,value<<%s>>, GLE=%d ",lpszName,lpszValue,GetLastError());

    return ret;
}



//  This handles a special case for Filters / extensions.  IF a call is made
//  to ISAPI Extension ServerSupportFunction with HSE_REQ_MAP_URL_TO_PATH, then
//  a filter call to SF_NOTIFY_URL_MAP is performed.

//  We can't call the filter directly because SF_NOTIFY_URL_MAP usually gets
//  path info from the CHttpRequest class, but in this case it's getting it's
//  data from and writing out to a user buffer.

//  pszBuf is the original string passed into ServerSupportFunction by the ISAPI.
//      When the function begins it has a virtual path, on successful termination it has a physical path
//  pdwSize is it's size
//  wszPath is it's mapped virtual root path
//  dwBufNeeded is the size of the buffer required to the physical path.

BOOL CHttpRequest::FilterMapURL(PSTR pszBuf, WCHAR *wszPath, DWORD *pdwSize, DWORD dwBufNeeded, PSTR pszURLEx)
{
    DEBUG_CODE_INIT;
    PSTR pszPhysicalOrg;
    PSTR pszPhysicalNew;
    PSTR pszVirtual = pszURLEx ? pszURLEx : pszBuf;
    DWORD cbBufNew = dwBufNeeded;
    BOOL ret = FALSE;


    // Regardless of if buffer was big enough to hold the original data, we always
    // allocate a buf for the filter.  The filter may end up changing the data
    // so it's small enough to fit in the buffer.

    // Don't use MySzDupWtoA here because we alread know the length needed, MySzDupWtoA
    // would needlessly recompute it.

    if (NULL == (pszPhysicalOrg = MyRgAllocNZ(CHAR,dwBufNeeded)))
        myleave(710);
    MyW2A(wszPath, pszPhysicalOrg, dwBufNeeded);
    pszPhysicalNew = pszPhysicalOrg;    // Keep a copy of pointer for freeing, CallFilter may modify it

    if ( !CallFilter(SF_NOTIFY_URL_MAP,&pszVirtual,(int*) &cbBufNew,&pszPhysicalNew))
        myleave(711);

    //  Buffer isn't big enough
    if (*pdwSize < cbBufNew)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        myleave(712);
    }

    // Copy changes over.  pszPhysicalNew will be filter set or will be
    // the original wszPath converted to ASCII without filter.
    if (NULL != pszPhysicalNew)
    {
        memcpy(pszBuf,pszPhysicalNew,cbBufNew);
    }

    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "FilterMapURL failed, err = %d, GLE=%X",err,GetLastError());

    *pdwSize =  cbBufNew;
    MyFree(pszPhysicalOrg);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\extns.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: ISAPI.CPP
Author: Arul Menezes
Abstract: ISAPI handling code
--*/

#include "pch.h"
#pragma hdrstop

#include "httpd.h"


#define RK_OLE          L"SOFTWARE\\Microsoft\\Ole"
#define RK_FREETIMEOUT  L"FreeTimeout"

// Amount of time ISAPI cache timeout thread should sleep between firing.
#define CACHE_SLEEP_TIMEOUT 60000

BOOL InitExtensions(CISAPICache **ppISAPICache, DWORD *pdwCacheSleep)
{
    CReg reg(HKEY_LOCAL_MACHINE, RK_OLE);

    // We double the amount of time COM tells us it's using to be safe.
    *pdwCacheSleep = 3*reg.ValueDW(RK_FREETIMEOUT,600000);   // default is 30 minutes, 1800000
    *ppISAPICache = new CISAPICache();

    return(NULL != *ppISAPICache);
}


BOOL CHttpRequest::ExecuteISAPI(void)
{
    DWORD dwRet = HSE_STATUS_ERROR;
    EXTENSION_CONTROL_BLOCK ECB;
    CISAPI *pISAPIDLL = NULL;

// wrap all calls to the ISAPI in a _try--_except

    __try
    {
        if (! g_pVars->m_pISAPICache->Load(m_wszPath,&pISAPIDLL))
            return FALSE;

        // create an ECB (this allocates no memory)
        FillECB(&ECB);

        DEBUGCHK(m_hEvent == NULL);
        m_hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        m_pECB = &ECB;

        // call the ISAPI
        dwRet = pISAPIDLL->CallExtension(&ECB);

        // grab log data if any
        if (ECB.lpszLogData[0])
        {
            DEBUGCHK(!m_pszLogParam);
            m_pszLogParam = MySzDupA(ECB.lpszLogData);
        }
    }
    __except(1) // catch all exceptions
    {
        TraceTag(ttidWebServer, "ISAPI DLL caused exception 0x%08x and was terminated", GetExceptionCode());
        g_pVars->m_pLog->WriteEvent(IDS_HTTPD_EXT_EXCEPTION,m_wszPath,GetExceptionCode(),L"HttpExtensionProc",GetLastError());
    }

    // set keep-alive status based on return code
    m_fKeepAlive = (dwRet==HSE_STATUS_SUCCESS_AND_KEEP_CONN);

    TraceTag(ttidWebServer, "ISAPI ExtProc returned %d keep=%d", dwRet, m_fKeepAlive);

    if (dwRet == HSE_STATUS_PENDING)
    {
        DWORD dwRes = WAIT_ABANDONED;

        // Wait up to 5 minutes for the request to complete
        if (m_hEvent != NULL)
            dwRes = WaitForSingleObject (m_hEvent, 300000);

        AssertSz(dwRes == WAIT_OBJECT_0, "Pended request was timed out after 5 minutes");

        if (dwRes == WAIT_OBJECT_0)
            dwRet = m_dwStatus;
        else
            dwRet = HSE_STATUS_ERROR;
    }

    if (m_hEvent != NULL)
    {
        CloseHandle (m_hEvent);
        m_hEvent = NULL;
    }

    StartRemoveISAPICacheIfNeeded();
    g_pVars->m_pISAPICache->Unload(pISAPIDLL);

    return(dwRet!=HSE_STATUS_ERROR);
}

void CHttpRequest::FillECB(LPEXTENSION_CONTROL_BLOCK pECB)
{
    ZEROMEM(pECB);
    pECB->cbSize = sizeof(*pECB);
    pECB->dwVersion = HSE_VERSION;
    pECB->ConnID = (HCONN)this;

    DEBUGCHK(m_pszMethod);

    // BUGBUG 13244:  IIS examines dwHttpStatusCode if user doesn't send their own headers
    // and uses it.  However, there's a work around for this on CE (direct use to
    // ServerSupportFunction) and using the status code rather than m_rs would
    // be a rearchitecting problem.  Fix:  None for now.
    pECB->dwHttpStatusCode = 200;
    pECB->lpszMethod = m_pszMethod;
    pECB->lpszQueryString = (PSTR)(m_pszQueryString ? m_pszQueryString : cszEmpty);
    pECB->lpszContentType = (PSTR)(m_pszContentType ? m_pszContentType : cszEmpty);
    pECB->lpszPathInfo = (PSTR) (m_pszPathInfo ? m_pszPathInfo : cszEmpty);
    pECB->lpszPathTranslated = (PSTR) (m_pszPathTranslated ? m_pszPathTranslated : cszEmpty);

    pECB->cbTotalBytes = m_dwContentLength;
    pECB->cbAvailable = m_bufRequest.Count();
    pECB->lpbData = m_bufRequest.Data();

    pECB->GetServerVariable = ::GetServerVariable;
    pECB->WriteClient = ::WriteClient;
    pECB->ReadClient = ::ReadClient;
    pECB->ServerSupportFunction = ::ServerSupportFunction;
}


BOOL WINAPI GetServerVariable(HCONN hConn, PSTR psz, PVOID pv, PDWORD pdw)
{
    CHECKHCONN(hConn);
    CHECKPTRS2(psz, pdw);

    return((CHttpRequest*)hConn)->GetServerVariable(psz, pv, pdw, FALSE);
}

int RecvToBuf(SOCKET socket, PVOID pv, DWORD dwReadBufSize, DWORD dwTimeout)
{
    DEBUG_CODE_INIT;
    int iRecv = SOCKET_ERROR;
    DWORD dwAvailable;

    if (!MySelect(socket,dwTimeout))
    {
        SetLastError(WSAETIMEDOUT);
        myleave(1400);
    }

    if (ioctlsocket(socket, FIONREAD, &dwAvailable))
    {
        SetLastError(WSAETIMEDOUT);
        myleave(1401);
    }

    iRecv = recv(socket, (PSTR) pv, (dwAvailable < dwReadBufSize) ? dwAvailable : dwReadBufSize, 0);
    if (iRecv == 0)
    {
        SetLastError(WSAETIMEDOUT);
        myleave(1402);
    }
    if (iRecv == SOCKET_ERROR)
    {
        // recv() already has called SetLastError with appropriate message
        myleave(1403);
    }


    done:
    TraceTag(ttidWebServer, "RecvToBuf returns error err = %d, GLE = 0x%08x",err,GetLastError());
    return iRecv;
}

BOOL WINAPI ReadClient(HCONN hConn, PVOID pv, PDWORD pdw)
{
    CHECKHCONN(hConn);
    CHECKPTRS2(pv, pdw);
    if ( *pdw == 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return((CHttpRequest*)hConn)->ReadClient(pv,pdw);
}

BOOL CHttpRequest::ReadClient(PVOID pv, PDWORD pdw)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    PVOID pvFilterModify = pv;
    DWORD dwBytesReceived;
    DWORD dwBufferSize    = *pdw;

    dwBytesReceived = RecvToBuf(m_socket,pv,*pdw,RECVTIMEOUT);

    if (dwBytesReceived == 0 || dwBytesReceived == SOCKET_ERROR)
        myleave(1399);

    if (g_pVars->m_fFilters &&
        ! CallFilter(SF_NOTIFY_READ_RAW_DATA,(PSTR*) &pvFilterModify,(int*) &dwBytesReceived, NULL, (int *) &dwBufferSize))
    {
        myleave(1404);
    }

    // Check if filter modified pointer, copy if there's enough room for it.
    if (pvFilterModify != pv)
    {
        if (*pdw <= dwBufferSize)
        {
            memcpy(pv,pvFilterModify,dwBufferSize);
        }
        else
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            myleave(1405);
        }
    }

    *pdw = dwBytesReceived;
    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "HTTPD:ReadClient failed, GLE = 0x%08x, err = % err",GetLastError(), err);
    return ret;
}

BOOL WINAPI WriteClient(HCONN hConn, PVOID pv, PDWORD pdw, DWORD dwFlags)
{
    CHECKHCONN(hConn);
    CHECKPTRS2(pv, pdw);

    if (dwFlags & HSE_IO_ASYNC)
        return((CHttpRequest*)hConn)->WriteClientAsync(pv, pdw, FALSE);
    else
        return((CHttpRequest*)hConn)->WriteClient(pv, pdw,FALSE);
}
BOOL WINAPI ServerSupportFunction(HCONN hConn, DWORD dwReq, PVOID pvBuf, PDWORD pdwSize, PDWORD pdwType)
{
    CHECKHCONN(hConn);
    return((CHttpRequest*)hConn)->ServerSupportFunction(dwReq, pvBuf, pdwSize, pdwType);
}

BOOL CHttpRequest::ServerSupportFunction(DWORD dwReq, PVOID pvBuf, PDWORD pdwSize, PDWORD pdwType)
{
    switch (dwReq)
    {
        // Can never support these
        //case HSE_REQ_ABORTIVE_CLOSE:
        //case HSE_REQ_ASYNC_READ_CLIENT:
        //case HSE_REQ_GET_CERT_INFO_EX:
        //case HSE_REQ_GET_IMPERSONATION_TOKEN:
        //case HSE_REQ_GET_SSPI_INFO:
        //case HSE_REQ_REFRESH_ISAPI_ACL:
        //case HSE_REQ_TRANSMIT_FILE:

        default:
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

        case HSE_REQ_IS_KEEP_CONN:
            {
                CHECKPTR(pvBuf);
                *((BOOL *) pvBuf) = m_fKeepAlive;
                return TRUE;
            }

        case HSE_REQ_SEND_URL:
        case HSE_REQ_SEND_URL_REDIRECT_RESP:
            {

                // close connection, because ISAPI won't have a chance to add headers anyway
                CHttpResponse resp(m_socket, STATUS_MOVED, CONN_CLOSE,this);
                // m_rs = STATUS_MOVED;
                resp.SendRedirect((PSTR)pvBuf); // send a special redirect body
                m_fKeepAlive = FALSE;
                return TRUE;
            }

        case HSE_REQ_MAP_URL_TO_PATH_EX:
        case HSE_REQ_MAP_URL_TO_PATH:
            {
                CHECKPTRS2(pvBuf,pdwSize);

                if (dwReq == HSE_REQ_MAP_URL_TO_PATH_EX)
                {
                    if (!pdwType)
                    {
                        SetLastError(ERROR_INVALID_PARAMETER);
                        return FALSE;
                    }
                    return MapURLToPath((PSTR)pvBuf,pdwSize,(LPHSE_URL_MAPEX_INFO) pdwType);
                }
                else
                {
                    // IIS docs are misleading here, but even if a valid param is passed in non-EX
                    // case, ignore it.  (Like IIS.)
                    return MapURLToPath((PSTR)pvBuf,pdwSize);
                }
            }

        case HSE_REQ_SEND_RESPONSE_HEADER:
            {
                // no Connection header...let ISAPI send one if it wants
                CHttpResponse resp(m_socket, STATUS_OK, CONN_NONE,this);
                // no body, default or otherwise (leave that to the ISAPI), but add default headers
                m_rs = STATUS_OK;
                resp.SendResponse((PSTR) pdwType, (PSTR) pvBuf);
                return TRUE;
            }


        case HSE_REQ_SEND_RESPONSE_HEADER_EX:
            {
                // Note:  We ignore cchStatus and cchHeader members.
                CHECKPTR(pvBuf);
                HSE_SEND_HEADER_EX_INFO *pHeaderEx = (HSE_SEND_HEADER_EX_INFO *) pvBuf;

                // Connection header determined by fKeepConn of passed in struct
                CHttpResponse resp(m_socket, STATUS_OK,
                                   pHeaderEx->fKeepConn ? CONN_KEEP : CONN_CLOSE,
                                   this);

                m_fKeepAlive = pHeaderEx->fKeepConn;
                // no body, default or otherwise (leave that to the ISAPI), but add default headers
                m_rs = STATUS_OK;
                resp.SendResponse(pHeaderEx->pszHeader, pHeaderEx->pszStatus);
                return TRUE;
            }

        case HSE_APPEND_LOG_PARAMETER:
            {
                return MyStrCatA(&m_pszLogParam,(PSTR) pvBuf,",");
            }

        case HSE_REQ_CLOSE_CONNECTION:
            {
                // Per ISAPI documentation:
                //
                // Once you use the HSE_REQ_CLOSE_CONNECTION server
                // support function to close a connection, you must
                // wait for IIS to call the asynchronous I/O function
                // (specified by HSE_REQ_IO_COMPLETION) before you end
                // the session with HSE_REQ_DONE_WITH_SESSION.
                //
                // Since our async I/O calls are all really sync, we
                // will call the completion routine at the end of the
                // operation and get a HSE_REQ_DONE_WITH_SESSION to do
                // the rest of the cleanup.

                return TRUE;
            }

        case HSE_REQ_DONE_WITH_SESSION:
            {
                AssertSz (m_hEvent != NULL, "Call to end a non-pended session, treating as error");

                if (m_hEvent != NULL)
                {
                    m_dwStatus = *((DWORD *) pvBuf);
                    m_fKeepAlive = FALSE;
                    SetEvent (m_hEvent);
                    return TRUE;
                }
                else
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                    return FALSE;
                }
            }

        case HSE_REQ_IO_COMPLETION:
            {
                m_pfnCompletion = (PFN_HSE_IO_COMPLETION)pvBuf;
                m_pvContext = (PVOID) pdwType;
                return TRUE;
            }
    }
}

BOOL CHttpRequest::MapURLToPath(PSTR pszBuffer, PDWORD pdwSize, LPHSE_URL_MAPEX_INFO pUrlMapEx)
{
    DWORD dwPermissions;
    PWSTR wszPath;
    PSTR pszURL;
    DWORD dwBufNeeded = 0;
    BOOL ret;

    wszPath = g_pVars->m_pVroots->URLAtoPathW(pszBuffer,&dwPermissions);
    if (!wszPath)
    {
        // Assume failure on matching to virtual root, and not on mem alloc
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    dwBufNeeded = (DWORD) WideCharToMultiByte(CP_ACP,0, wszPath, -1, pszBuffer, 0 ,0,0);

    // For MAP_EX case, we set these vars from the passed structure, else we use the raw ptrs.
    if (pUrlMapEx)
    {
        pszURL = pUrlMapEx->lpszPath;
        *pdwSize = MAX_PATH;
    }
    else
    {
        pszURL = pszBuffer;
    }


    // To keep this like IIS, we translate "/" to "\".  We do the conversion
    // only if we're using filters or if there's enough space in the buffer.
    if (g_pVars->m_fFilters || *pdwSize >= dwBufNeeded)
    {
        for (int i = 0; i < (int) wcslen(wszPath); i++)
        {
            if ( wszPath[i] == L'/')
                wszPath[i] = L'\\';
        }
    }

    if (FALSE == g_pVars->m_fFilters)
    {
        // We check to make sure buffer is the right size because WideToMultyByte
        // will overwrite pieces of pszURL even on failure, leaving pszURL's
        // content invalid
        if (*pdwSize < dwBufNeeded)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            ret = FALSE;
        }
        else
        {
            MyW2A(wszPath, pszURL, *pdwSize);
            ret = TRUE;
        }
        *pdwSize = dwBufNeeded;
    }
    else
    {
        // for EX case, put original URL as optional 5th parameter.
        ret = FilterMapURL(pszURL, wszPath, pdwSize,dwBufNeeded, pUrlMapEx ? pszBuffer : NULL);
    }

    if (ret && pUrlMapEx)
    {
        pUrlMapEx->cchMatchingPath = *pdwSize - 1;      // don't count \0
        pUrlMapEx->cchMatchingURL  = strlen(pszBuffer);
        pUrlMapEx->dwFlags = dwPermissions;
    }

    MyFree(wszPath);
    return ret;
}


void CISAPI::Unload(PWSTR wszDLLName)
{
    if (m_pfnTerminate)
    {
        __try
        {
            if (SCRIPT_TYPE_FILTER == m_scriptType)
                ((PFN_TERMINATEFILTER)m_pfnTerminate)(HSE_TERM_MUST_UNLOAD);
            else if (SCRIPT_TYPE_EXTENSION == m_scriptType)
                ((PFN_TERMINATEEXTENSION)m_pfnTerminate)(HSE_TERM_MUST_UNLOAD);
            else if (SCRIPT_TYPE_ASP == m_scriptType)
                ((PFN_TERMINATEASP)m_pfnTerminate)();

        }
        __except(1)
        {
            DWORD dwExceptionCode = SCRIPT_TYPE_FILTER == m_scriptType ?
                                    IDS_HTTPD_FILT_EXCEPTION : IDS_HTTPD_EXT_EXCEPTION;
            PWSTR wszFunction =     SCRIPT_TYPE_FILTER == m_scriptType ?
                                    L"TerminateFilter" : L"TerminateExtension";

            TraceTag(ttidWebServer, "HTTPD: TerminateExtension faulted");
            g_pVars->m_pLog->WriteEvent(dwExceptionCode,wszDLLName ? wszDLLName : m_wszDLLName,
                                        GetExceptionCode(),wszFunction,GetLastError());
        }
    }
    MyFreeLib(m_hinst);
    m_hinst = NULL;
    m_pfnTerminate = NULL;
}


BOOL CISAPI::Load(PWSTR wszPath)
{
    m_hinst = LoadLibrary(wszPath);
    if (!m_hinst)
        return FALSE;

    if (SCRIPT_TYPE_ASP == m_scriptType)
    {
        if (! (m_pfnHttpProc = GetProcAddress(m_hinst, CE_STRING("ExecuteASP"))))
            goto error;
        if (! (m_pfnTerminate = GetProcAddress(m_hinst, CE_STRING("TerminateASP"))))
            goto error;

        return TRUE;
    }

    if (SCRIPT_TYPE_EXTENSION == m_scriptType)
    {
        m_pfnGetVersion = GetProcAddress(m_hinst, CE_STRING("GetExtensionVersion"));
        m_pfnHttpProc   = GetProcAddress(m_hinst, CE_STRING("HttpExtensionProc"));
        m_pfnTerminate  = GetProcAddress(m_hinst, CE_STRING("TerminateExtension"));
    }
    else if (SCRIPT_TYPE_FILTER == m_scriptType)
    {
        m_pfnGetVersion = GetProcAddress(m_hinst, CE_STRING("GetFilterVersion"));
        m_pfnHttpProc   = GetProcAddress(m_hinst, CE_STRING("HttpFilterProc"));
        m_pfnTerminate  = GetProcAddress(m_hinst, CE_STRING("TerminateFilter"));

    }

    if (!m_pfnHttpProc || !m_pfnGetVersion)
        goto error;

    __try
    {
        // call GetVersion immediately after load on extensions and Filters, but not ASP
        // if it's a filter we need to do some flags work first
        if (SCRIPT_TYPE_FILTER == m_scriptType)
        {
            HTTP_FILTER_VERSION vFilt;
            // IIS ignores ISAPI version info, so do we.
            ((PFN_GETFILTERVERSION)m_pfnGetVersion)(&vFilt);
            dwFilterFlags = vFilt.dwFlags;

            // client didn't set the prio flags, assign them to default
            // If they set more than one prio we use the highest + ignore others
            if (0 == (dwFilterFlags & SF_NOTIFY_ORDER_MASK))
            {
                dwFilterFlags |= SF_NOTIFY_ORDER_DEFAULT;
            }
        }
        else if (SCRIPT_TYPE_EXTENSION == m_scriptType)
        {
            HSE_VERSION_INFO    vExt;
            // IIS ignores ISAPI version info, so do we.
            ((PFN_GETEXTENSIONVERSION)m_pfnGetVersion)(&vExt);
        }

        return TRUE;
    }
    __except(1)
    {
        DWORD dwExceptionCode = SCRIPT_TYPE_FILTER == m_scriptType ?
                                IDS_HTTPD_FILT_EXCEPTION : IDS_HTTPD_EXT_EXCEPTION;
        PWSTR wszFunction =     SCRIPT_TYPE_FILTER == m_scriptType ?
                                L"GetFilterVersion" : L"GetExtensionVersion";

        TraceTag(ttidWebServer, "HTTPD: GetExtensionVersion faulted");
        g_pVars->m_pLog->WriteEvent(dwExceptionCode,wszPath,GetExceptionCode(),wszFunction,GetLastError());
    }
    // fall through to error

    error:
    m_pfnGetVersion = 0;
    m_pfnHttpProc = 0;
    m_pfnTerminate = 0;
    MyFreeLib(m_hinst);
    m_hinst = 0;
    return FALSE;
}


//**********************************************************************
// ISAPI Caching functions
//**********************************************************************



HINSTANCE CISAPICache::Load(PWSTR wszDLLName, CISAPI **ppISAPI, SCRIPT_TYPE st)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    PISAPINODE pTrav = NULL;

    EnterCriticalSection(&m_CritSec);

    for (pTrav = m_pHead; pTrav != NULL; pTrav = pTrav->m_pNext)
    {
        if ( 0 == lstrcmpi(pTrav->m_pISAPI->m_wszDLLName, wszDLLName))
        {
            TraceTag(ttidWebServer, "Found ISAPI dll in cache, name = %s, cur ref count = %d",
                                 wszDLLName, pTrav->m_pISAPI->m_cRef);
            break;
        }
    }

    if (NULL == pTrav)
    {
        TraceTag(ttidWebServer, "ISAPI dll name = %s not found in cache, creating new entry",wszDLLName);
        if (NULL == (pTrav = MyAllocNZ(ISAPINODE)))
            myleave(1200);

        if (NULL == (pTrav->m_pISAPI = new CISAPI(st)))
            myleave(1201);

        if (NULL == (pTrav->m_pISAPI->m_wszDLLName = MySzDupW(wszDLLName)))
            myleave(1202);

        if (! pTrav->m_pISAPI->Load(wszDLLName))
            myleave(1203);

        pTrav->m_pNext = m_pHead;
        m_pHead = pTrav;
    }
    pTrav->m_pISAPI->m_cRef++;


    *ppISAPI = pTrav->m_pISAPI;
    ret = TRUE;
    done:
    if (!ret)
    {
        if (pTrav && pTrav->m_pISAPI)
        {
            MyFree(pTrav->m_pISAPI->m_wszDLLName);
            delete pTrav->m_pISAPI;
        }

        MyFree(pTrav);
    }

    TraceTag(ttidWebServer, "CISAPICache::LoadISAPI failed, err = %d, GLE = 0x%08x",err,GetLastError());
    LeaveCriticalSection(&m_CritSec);

    if (ret)
        return pTrav->m_pISAPI->m_hinst;

    return NULL;
}

void CHttpRequest::StartRemoveISAPICacheIfNeeded()
{
    DEBUGCHK(g_pVars->m_fExtensions);
    if (InterlockedCompareExchange(&g_pVars->m_fISAPICacheRunning,1,0) == 0)
    {
        TraceTag(ttidWebServer, "HTTPD: ExecuteISAPI: Creating RemoveUnusedISAPIs timer");
        // We never stop the timer.  This is handled on call to Thread Pool Shutdown
        g_pVars->m_pThreadPool->StartTimer(RemoveUnusedISAPIs,0,CACHE_SLEEP_TIMEOUT);
    }
}

// lpv = 0 for thread that sleeps forever.
// lpv = 1 to remove all ISAPIs, called on shutdown.
DWORD WINAPI RemoveUnusedISAPIs(LPVOID lpv)
{
    // We set lpv to 1 if we want to unload all ISAPIs during shutdown.
    if (lpv)
    {
        g_pVars->m_pISAPICache->RemoveUnusedISAPIs(TRUE);
        return 0;
    }

    if (g_pVars->m_pISAPICache->m_pHead != NULL)
        g_pVars->m_pISAPICache->RemoveUnusedISAPIs(FALSE);

    g_pVars->m_pThreadPool->StartTimer(RemoveUnusedISAPIs,0,CACHE_SLEEP_TIMEOUT);
    return 0;
}

// to milliseconds (10 * 1000)
#define FILETIME_TO_MILLISECONDS  ((__int64)10000L)

// fRemoveAll = TRUE  ==> remove all ISAPI's, we're shutting down
//            = FALSE ==> only remove ones who aren't in use and whose time has expired

void CISAPICache::RemoveUnusedISAPIs(BOOL fRemoveAll)
{
    PISAPINODE pTrav   = NULL;
    PISAPINODE pFollow = NULL;
    PISAPINODE pDelete = NULL;
    SYSTEMTIME st;
    __int64 ft;

    EnterCriticalSection(&m_CritSec);
    GetSystemTime(&st);
    SystemTimeToFileTime(&st,(FILETIME*) &ft);

    // Figure out what time it was g_pVars->m_dwCacheSleep milliseconds ago.
    // Elements that haven't been used since then and that have no references
    // are deleted.

    ft -= FILETIME_TO_MILLISECONDS * g_pVars->m_dwCacheSleep;


    for (pTrav = m_pHead; pTrav != NULL; )
    {
        if (fRemoveAll ||
            (pTrav->m_pISAPI->m_cRef == 0 && pTrav->m_pISAPI->m_ftLastUsed < ft))
        {
            TraceTag(ttidWebServer, "Freeing unused ISAPI Dll %s",pTrav->m_pISAPI->m_wszDLLName);

            pTrav->m_pISAPI->Unload();
            delete pTrav->m_pISAPI;

            if (pFollow)
                pFollow->m_pNext = pTrav->m_pNext;
            else
                m_pHead = pTrav->m_pNext;

            pDelete = pTrav;
            pTrav = pTrav->m_pNext;
            MyFree(pDelete);
        }
        else
        {
            if (pTrav->m_pISAPI->m_cRef == 0)
                pTrav->m_pISAPI->CoFreeUnusedLibrariesIfASP();

            pFollow = pTrav;
            pTrav = pTrav->m_pNext;
        }
    }

    LeaveCriticalSection(&m_CritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\filters.cpp ===
/*--
Copyright (c) 1995-2000    Microsoft Corporation.  All Rights Reserved.
Module Name: filter.cpp
Abstract: ISAPI Filter handling classes
--*/

#include "pch.h"
#pragma hdrstop

#include "httpd.h"

CISAPIFilterCon* g_pFilterCon;


const LPCWSTR cwszFilterSep = L",";   // what seperates filter ids in the registry

//  Used to increment the filter, goes up 1 normally, down 1 for RAW DATA prio inversion
#define NEXTFILTER(dwNotifyType, i)     { (dwNotifyType == SF_NOTIFY_SEND_RAW_DATA) ? i-- : i++;}



void FreeLogParams(PHTTP_FILTER_LOG pLog);


//   Creates new filter info used globally
BOOL InitFilters()
{
    g_pFilterCon = new CISAPIFilterCon();

    if (g_pFilterCon)
    {
        return g_pFilterCon->m_nFilters!=0;
    }

    return FALSE;
}


//  Destroys the global filter information
void CleanupFilters()
{
    if (g_pFilterCon)
        delete g_pFilterCon;
    g_pFilterCon = 0;
}

CFilterInfo* CreateCFilterInfo(void)
{
    if (0 == g_pFilterCon->m_nFilters)
        return NULL;

    return new CFilterInfo;
}



//  CFilterInfo is an internal member of CHttpRequest.  Allocate buffers for it
CFilterInfo::CFilterInfo()
{
    ZEROMEM(this);


    m_pdwEnable = MyRgAllocNZ(DWORD,g_pFilterCon->m_nFilters);
    if (!m_pdwEnable)
    {
        TraceTag(ttidWebServer, "CFilterInfo::Init died on Alloc!");
        return;
    }

    m_ppvContext = MyRgAllocZ(PVOID,g_pFilterCon->m_nFilters);
    if (!m_ppvContext)
    {
        MyFree(m_pdwEnable);
        TraceTag(ttidWebServer, "CFilterInfo::Init died on Alloc!");
        return;
    }

    //  A filter can disable itself for events in a session, m_pdwEnable stores this.
    memset(m_pdwEnable,0xFFFF,g_pFilterCon->m_nFilters*sizeof(DWORD));  // all true at first

    m_dwStartTick = GetTickCount();
    m_fFAccept = TRUE;
    return;
}

//  Notes:  If http request is to be persisted, this is called.
//  Do NOT Free the Allocated Mem or the context structure here, these are persisted
//  across requests, delete at end of session.


BOOL CFilterInfo::ReInit()
{
    MyFree(m_pszDenyHeader);

    if (m_pFLog)
    {
        MyFree(m_pFLog);
    }

    //  Reset the enable structure to all 1's, starting over.
    memset(m_pdwEnable,0xFFFF,g_pFilterCon->m_nFilters*sizeof(DWORD));  // all true at first

    // The context struct and AllocMem data lasts through the session, not just a request.
    m_dwStartTick = GetTickCount();
    m_fFAccept = TRUE;
    m_dwNextReadSize = 0;
    m_dwBytesSent = 0;
    m_dwBytesReceived = 0;

    return TRUE;
}



CFilterInfo::~CFilterInfo()
{
    MyFree(m_pszDenyHeader);

    if (m_pFLog)
    {
        MyFree(m_pFLog);
    }
    MyFree(m_pdwEnable);
    MyFree(m_ppvContext);


    FreeAllocMem(); // frees m_pAllocBlock
}

//  Initilization routine for global filters.  This looks in the registry for the
//  filters, loads any dlls into memory, and puts them into a list that is
//  ordered from Highest prio filters to lowest.


BOOL CISAPIFilterCon::Init()
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    BOOL fChange = FALSE;
    CISAPI *pCISAPI = NULL;
    const WCHAR *wcszReg;
    WCHAR *wszFilterNames;
    DWORD dwFilterLen = 0;
    PWSTR wszToken = NULL;
    DWORD i;
    int j;


    CReg topreg(HKEY_LOCAL_MACHINE,RK_HTTPD);


    wcszReg = topreg.ValueSZ(RV_FILTER);
    wszFilterNames = MySzDupW(wcszReg);

    TraceTag(ttidWebServer, "Filter DLLs Reg Value <<%s>>",wszFilterNames);



    if (NULL == wszFilterNames || 0 == (dwFilterLen = wcslen(wszFilterNames)))
    {
        TraceTag(ttidWebServer, "No filters listed in registry");
        myleave(0);  // no values => no registered filters
    }

    // count # of commas to figure how many dlls there are
    m_nFilters = 1;   // there's at least 1 if we're this far

    for (i = 0; i < dwFilterLen && wszFilterNames[i] != L'\0'; i++)
    {
        if (wszFilterNames[i] == L',')
            m_nFilters++;
    }
    TraceTag(ttidWebServer, "# of filters = %d",m_nFilters);

    if (! (m_pFilters = MyRgAllocZ(FILTERINFO,m_nFilters)))
        myleave(203);

    // now tokenize the string and load filter libs as we do it
    j = 0;
    wszToken = wcstok(wszFilterNames,cwszFilterSep);
    while (wszToken != NULL)
    {
        SkipWWhiteSpace(wszToken);

        // Handles the case where there's a comma but nothing after it.
        if (*wszToken == L'\0')
        {
            m_nFilters--;
            break;
        }

        pCISAPI = m_pFilters[j].pCISAPI = new CISAPI(SCRIPT_TYPE_FILTER);
        TraceTag(ttidWebServer, "Initiating filter library %s",wszToken);
        if (!pCISAPI)
            myleave(204);


        if (TRUE == pCISAPI->Load(wszToken))
        {
            m_pFilters[j].wszDLLName = MySzDupW(wszToken);
            m_pFilters[j].dwFlags = pCISAPI->GetFilterFlags();
            j++;
        }
        else
        {
            TraceTag(ttidWebServer, "Filter <<%s>> failed to load!",wszToken);
            // only messed up this filter, others may work so keep on moving
            m_nFilters--;
            delete pCISAPI;
        }

        wszToken = wcstok(NULL,cwszFilterSep);
    }
    DEBUGCHK(j == m_nFilters);

    // Case where every filter fails to load
    if (0 == m_nFilters)
    {
        //  Cleanup();
        MyFree(m_pFilters);
        myleave(205);
    }

    // Now use a bubble sort to put the highest priority structures 1st in the
    // list.
    do
    {
        fChange = FALSE;
        for (j=0; j<m_nFilters-1; j++)
        {
            if ( (m_pFilters[j].dwFlags & SF_NOTIFY_ORDER_MASK) < (m_pFilters[j+1].dwFlags & SF_NOTIFY_ORDER_MASK))
            {
                // swap the 2 filter infos
                FILTERINFO ftemp = m_pFilters[j+1];
                m_pFilters[j+1] = m_pFilters[j];
                m_pFilters[j] = ftemp;
                fChange = TRUE;
            }
        }
    } while (fChange);

    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "CIsapiFilterCon::Init FAILED: GLE=%d err=%d\r\n",
             GetLastError(), err);

    MyFree(wszFilterNames);
    return ret;
}

void CISAPIFilterCon::Cleanup()
{
    if (0 == m_pFilters)
        return;

    for (int i = 0; i < m_nFilters; i++)
    {
        m_pFilters[i].pCISAPI->Unload(m_pFilters[i].wszDLLName);
        MyFree(m_pFilters[i].wszDLLName);

        delete m_pFilters[i].pCISAPI;
    }
    MyFree(m_pFilters);
}


//   This is only called when ith member of the filter list has an access
//   violation, we remove it from the executing queue globally
//   and unload the lib
void CISAPIFilterCon::Unload(int i)
{
    DEBUGCHK(i < m_nFilters && i >= 0);

    // NOTE:  Normally we need a CriticalSection but because we're only
    // setting it and since it's dead, we'll save ourselves the effort

    m_pFilters[i].pCISAPI->Unload();
    m_pFilters[i].dwFlags = 0;
}



// BOOL CHttpRequest::CallFilter

// Function:   Httpd calls this function on specified evetns, it's goes through
// the list and calls the registered filters for that event.

// PARAMETERS:
//      DWORD dwNotifyType - what SF_NOTIFIY type occured

//      The last 3 parameters are optional; only 3 filter calls use them.
//      They are used when extra data needs to be passed to the filter that isn't
//      part of the CHttpRequest structure.

//      PSTR *ppszBuf1  ---> SF_NOTIFY_SEND_RAW_DATA   --> The buffer about to be sent
//                      ---> SF_NOTIFY_URL_MAP         --> The virtual path (only
//                              on ServerSupportFunction with HSE_REQ_MAP_URL_TO_PATH,
//                              otherwise use CHttpRequest values.)
//                      ---> SF_NOTIFY_AUTHENTECATION  --> The remote user name
//                      ---> SF_NOTIFY_READ_RAW_DATA   --> Buffer about to be read

//      PSTR *ppszBuf2  ---> SF_NOTIFY_SEND_RAW_DATA   --> Unused
//                      ---> SF_NOTIFY_URL_MAP         --> The physical mapping
//                      ---> SF_NOTIFY_AUTHENTECATION  --> The user's password
//                      ---> SF_NOTIFY_READ_RAW_DATA   --> Buffer about to be read
//
//      int *pcbBuf     ---> SF_NOTIFY_SEND_RAW_DATA   --> Length of buffer to be sent
//                      ---> SF_NOTIFY_URL_MAP         --> Length of physical path buf
//                      ---> SF_NOTIFY_AUTHENTECATION  --> Unused
//                      ---> SF_NOTIFY_READ_RAW_DATA   --> Buffer about to be read

//      int *pcbBuf2    ---> SF_NOTIFY_READ_RAW_DATA   --> size of the buffer reading into

// return values
//      TRUE  tells calling fcn to continue normal execution
//      FALSE tells calling fcn to terminate this request.

// Notes:
// if FALSE is returned, m_pFilterInfo->m_fAccept is also set to false.  This
// helps the filter handle unwinding from nested filter calls.

// For example, the http server calls a filter with URL_MAP flags.  The filter
// then calls a WriteClient, which will call the filter again with event
// SF_NOTIFY_SEND_RAW_DATA.  If on the SEND_RAW_DATA call the filter returns a
// code to stop the session, we need to store it for the original MAP_URL call,
// so that it knows to stop the session too.


BOOL CHttpRequest::CallFilter(DWORD dwNotifyType, PSTR *ppszBuf1,
                              int *pcbBuf, PSTR *ppszBuf2, int *pcbBuf2)
{
    DEBUG_CODE_INIT;
    HTTP_FILTER_CONTEXT fc;
    LPVOID pStFilter;       // 3rd param passed on HttpFilterProc
    LPVOID pStFilterOrg;    // stores a copy of pStFilter, so we remember alloc'd mem, if any
    BOOL fFillStructs = TRUE;
    BOOL fReqReadNext;
    BOOL ret = FALSE;
    DWORD dwFilterCode;
    int i;


    if (0 == g_pFilterCon->m_nFilters)
        return TRUE;



    // m_pFInfo->m_fFAccept = FALSE implies no more filter calls, except on the "cleanup" calls
    TraceTag(ttidWebServer, "Filter notify type = 0x%08x",dwNotifyType);
    if ( (! m_pFInfo->m_fFAccept) &&
         ! (dwNotifyType & (SF_NOTIFY_END_OF_REQUEST | SF_NOTIFY_LOG | SF_NOTIFY_END_OF_NET_SESSION | SF_NOTIFY_SEND_RESPONSE | SF_NOTIFY_SEND_RAW_DATA)))
    {
        return FALSE;
    }
    m_pFInfo->m_dwSFEvent = dwNotifyType;

    do
    {
        pStFilter = pStFilterOrg = NULL;
        fReqReadNext = FALSE;

        // Filters implement priority inversion for SEND_RAW_DATA events.
        i = (dwNotifyType == SF_NOTIFY_SEND_RAW_DATA) ? g_pFilterCon->m_nFilters - 1 : 0;

        while ( (dwNotifyType == SF_NOTIFY_SEND_RAW_DATA) ? i >= 0 : i < g_pFilterCon->m_nFilters )
        {
            // we still reference g_pFilterCon just in case a filter crapped out in another request
            if (0 == ((dwNotifyType & g_pFilterCon->m_pFilters[i].dwFlags) & m_pFInfo->m_pdwEnable[i]))
            {
                // ith filter didn't request this notification, move along
                NEXTFILTER(dwNotifyType, i);
                continue;
            }

            m_pFInfo->m_iFIndex = i;
            if (fFillStructs && (!FillFC(&fc,dwNotifyType,&pStFilter,&pStFilterOrg,
                                         ppszBuf1, pcbBuf, ppszBuf2, pcbBuf2)))
                myretleave(FALSE,210);  // memory error on FillFC
            fFillStructs = FALSE;   // after structs or filled don't refill them

            fc.pFilterContext = m_pFInfo->m_ppvContext[i];


            __try
            {
                dwFilterCode =  g_pFilterCon->m_pFilters[i].pCISAPI->CallFilter(&fc,dwNotifyType,pStFilter);
            }
            __except(1)
            {
                TraceTag(ttidWebServer, "ISAPI Filter DLL <<%s>> caused exception 0x%08x",
                         g_pFilterCon->m_pFilters[i].wszDLLName, GetExceptionCode());

                g_pVars->m_pLog->WriteEvent(IDS_HTTPD_FILT_EXCEPTION,g_pFilterCon->m_pFilters[i].wszDLLName,GetExceptionCode(),L"HttpFilterProc",GetLastError());
                g_pFilterCon->Unload(i);
                m_fKeepAlive = FALSE;
                myleave(216);
            }

            // bail out if another filter call said to, but not on certain events (for compat with IIS)
            // This would happen if a filter triggered an event to occur which caused another filter call
            // to be made, and if that nested filter returned an error code indicating the end of session.
            if ( (! m_pFInfo->m_fFAccept) &&
                 ! (dwNotifyType & (SF_NOTIFY_END_OF_REQUEST | SF_NOTIFY_LOG | SF_NOTIFY_END_OF_NET_SESSION | SF_NOTIFY_SEND_RESPONSE | SF_NOTIFY_SEND_RAW_DATA)))
            {
                TraceTag(ttidWebServer, "Filter indirectly set us to end, ending CallFilter for event= %x,i=%d",dwNotifyType,i);
                myretleave(FALSE,0);
            }

            m_pFInfo->m_ppvContext[i] = fc.pFilterContext;

            TraceTag(ttidWebServer, "Filter returned response code of 0x%08x",dwFilterCode);
            switch (dwFilterCode)
            {
                // alert calling class that this request + net session is over
                case SF_STATUS_REQ_FINISHED:
                    m_fKeepAlive = FALSE;
                    m_pFInfo->m_fSentHeaders = TRUE;  // don't send back headers in these cases.
                    myretleave(FALSE,0);
                    break;

                    // alert calling class that this request but not the net session is over
                case SF_STATUS_REQ_FINISHED_KEEP_CONN:
                    m_fKeepAlive = TRUE;
                    m_pFInfo->m_fSentHeaders = TRUE;  // don't send back headers in these cases.
                    myretleave(FALSE,0);
                    break;


                    // goes to top of loop, handle next filter in line
                case SF_STATUS_REQ_NEXT_NOTIFICATION:
                    NEXTFILTER(dwNotifyType, i);
                    break;

                    // not an error, just done handling current httpd event
                case SF_STATUS_REQ_HANDLED_NOTIFICATION:
                    myretleave(TRUE,0);
                    break;

                    // alert calling class that this request is over
                case SF_STATUS_REQ_ERROR:
                    m_fKeepAlive = FALSE;
                    m_rs = STATUS_INTERNALERR;
                    myretleave(FALSE,214);
                    break;


                case SF_STATUS_REQ_READ_NEXT:
                    // only valid for read raw data events.  IIS ignores if returned by other filters
                    // Continue running through remaining filters before reading more data
                    if (dwNotifyType == SF_NOTIFY_READ_RAW_DATA)
                    {
                        fReqReadNext = TRUE;
                    }
                    NEXTFILTER(dwNotifyType, i);
                    break;

                default:    // treat like SF_STATUS_REQ_NEXT_NOTIFICATION
                    TraceTag(ttidWebServer, "Filter returned unknown/unhandled return code");
                    NEXTFILTER(dwNotifyType, i);
                    break;
            }
        }

        // Only after all filters have been serviced to we handle READ_NEXT event
        // Note that having a filter call SF_READ_REQ_NEXT during a call to an
        // ISAPI ext ReadClient is completly unsupported.  This has been docced.
        if (fReqReadNext)
        {
            PHTTP_FILTER_RAW_DATA pRaw = (PHTTP_FILTER_RAW_DATA) pStFilter;
            fFillStructs = TRUE; // set here in case we don't read any data and
                                 // exit loop, so we don't call CleanupFC 2 times.

            CleanupFC(dwNotifyType, &pStFilter,&pStFilterOrg,ppszBuf1, pcbBuf, ppszBuf2);
            m_bufRequest.RecvBody(m_socket,m_pFInfo->m_dwNextReadSize ? m_pFInfo->m_dwNextReadSize : g_pVars->m_dwPostReadSize,TRUE);

            // only stop reading if we didn't get any data.  Timeouts are OK, we'll call read filter again
            if (m_bufRequest.UnaccessedCount() == 0)
                fReqReadNext = FALSE;
            else
                m_pFInfo->m_dwBytesReceived += pRaw->cbInData; // from HTTP recv
        }

    } while (fReqReadNext);

    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "CIsapiFilterCon::CallFilter FAILED: GLE=%d err=%d",
             GetLastError(), err);


    // Udpate our bytes sent/received if need be.
    // Send bytes update must after we do our cleanup, Read bytes must happen before.
    if (dwNotifyType == SF_NOTIFY_READ_RAW_DATA)
    {
        // We only allocate pRaw if we need to (ie someone notified for read),
        // if this is so use that value for rx bytes.  If no one notefied for read filt, use
        // the value we were passed for bytes read by calling fcn.

        PHTTP_FILTER_RAW_DATA pRaw = (PHTTP_FILTER_RAW_DATA) pStFilter;
        if (pRaw)
            m_pFInfo->m_dwBytesReceived += pRaw->cbInData;
        else if (ppszBuf1)
            m_pFInfo->m_dwBytesReceived += *pcbBuf;  // from ISAPI ReadClient
        else
            m_pFInfo->m_dwBytesReceived += m_bufRequest.UnaccessedCount(); // from HTTP recv
    }

    //  fFillStructs will be false if no filter registered for this event, which means
    //  we have no cleanup
    if (FALSE == fFillStructs)
        CleanupFC(dwNotifyType, &pStFilter,&pStFilterOrg,ppszBuf1, pcbBuf, ppszBuf2);

    if (dwNotifyType == SF_NOTIFY_SEND_RAW_DATA)
        m_pFInfo->m_dwBytesSent += *pcbBuf;

    if (!ret)
    {
        m_pFInfo->m_fFAccept = FALSE;
    }
    return ret;
}

// sets up the FilterContext data structure so it makes sense to filterr being called.
// Only called once per filter event.

// ppStFilter is sent to filter dlls.
// ppStFilterOrg is a copy, it stores what we've allocated and is used to free up mem, as
// the filter would cause server mem leaks without it as a reference

// Last three parameters are the same as CallFilter

BOOL CHttpRequest::FillFC(PHTTP_FILTER_CONTEXT pfc, DWORD dwNotifyType,
                          LPVOID *ppStFilter, LPVOID *ppStFilterOrg,
                          PSTR *ppszBuf1, int *pcbBuf, PSTR *ppszBuf2, int *pcbBuf2)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;

    switch (dwNotifyType)
    {
        case SF_NOTIFY_END_OF_NET_SESSION:
        case SF_NOTIFY_END_OF_REQUEST:
            break;


        case SF_NOTIFY_READ_RAW_DATA:
            {
                PHTTP_FILTER_RAW_DATA pRawData = NULL;
                *ppStFilter = pRawData = MyAllocNZ(HTTP_FILTER_RAW_DATA);
                if (!pRawData)
                    myleave(220);

                // We use UnaccessedCount() rather than Count() member of Buffio class
                // because we want the entire buffer for the Filter to read.  For instance,
                // if we had http headers and POST data, Count would only return the size
                // of the headers, while UnaccessedCount returns the size of everything.
                // We give filter the whole buffer.  Yet another change to give IIS compatibility.

                if (!ppszBuf1)   // Use buffer in CHttpResponse class
                {
                    pRawData->cbInData =   m_bufRequest.UnaccessedCount();
                    pRawData->cbInBuffer = m_bufRequest.AvailableBufferSize();
                    pRawData->pvInData =   m_bufRequest.FilterRawData();
                }
                else  //  Called from ISAPI ReadClient()
                {
                    pRawData->cbInBuffer  = *pcbBuf2;
                    pRawData->cbInData = *pcbBuf;
                    pRawData->pvInData = (PVOID) *ppszBuf1;
                }

                pRawData->dwReserved = 0;
                *ppStFilterOrg = MyAllocNZ(HTTP_FILTER_RAW_DATA);
                if (!(*ppStFilterOrg))
                    myleave(240);
                memcpy(*ppStFilterOrg,*ppStFilter,sizeof(HTTP_FILTER_RAW_DATA));
            }
            break;

        case SF_NOTIFY_PREPROC_HEADERS:
            {
                PHTTP_FILTER_PREPROC_HEADERS pPreProc = NULL;
                *ppStFilter = pPreProc = MyAllocNZ(HTTP_FILTER_PREPROC_HEADERS);
                *ppStFilterOrg = NULL;

                if (!pPreProc)
                    myleave(221);
                pPreProc->GetHeader = ::GetHeader;
                pPreProc->SetHeader = ::SetHeader;
                pPreProc->AddHeader = ::SetHeader;
                pPreProc->HttpStatus = 0;       // no response status code this return
                pPreProc->dwReserved = 0;
            }
            break;

        case SF_NOTIFY_URL_MAP:
            {
                PHTTP_FILTER_URL_MAP pUrlMap = NULL;
                *ppStFilter = pUrlMap = MyAllocNZ(HTTP_FILTER_URL_MAP);

                if (!pUrlMap)
                    myleave(222);

                if (NULL == ppszBuf1)  // usual case, use data in CHttpRequest
                {
                    pUrlMap->pszURL = m_pszURL;
                    pUrlMap->pszPhysicalPath = MySzDupWtoA(m_wszPath);
                    pUrlMap->cbPathBuff = MyStrlenA(pUrlMap->pszPhysicalPath);
                }
                else        // called from ISAPI ext with HSE_REQ_MAP_URL_TO_PATH
                {
                    pUrlMap->pszURL = (PSTR) *ppszBuf1;
                    pUrlMap->pszPhysicalPath = (PSTR) *ppszBuf2;
                    pUrlMap->cbPathBuff = *pcbBuf;
                }

                if ( !pUrlMap->pszURL || ! pUrlMap->pszPhysicalPath)
                    myleave(320);

                *ppStFilterOrg = MyAllocNZ(HTTP_FILTER_URL_MAP);
                if (!(*ppStFilterOrg))
                    myleave(241);
                memcpy(*ppStFilterOrg,*ppStFilter,sizeof(HTTP_FILTER_URL_MAP));
            }
            break;

        case SF_NOTIFY_AUTHENTICATION:
            {
                DEBUGCHK(NULL != ppszBuf1 && NULL != ppszBuf2);

                PHTTP_FILTER_AUTHENT pAuth = NULL;
                *ppStFilter = pAuth = MyAllocNZ(HTTP_FILTER_AUTHENT);

                if (!pAuth)
                    myleave(223);

                // pszUser + pszPassword are static buffers made in AuthenticateFilter fcn
                pAuth->pszUser = (PSTR) *ppszBuf1;
                pAuth->cbUserBuff = SF_MAX_USERNAME;
                pAuth->pszPassword = (PSTR) *ppszBuf2;
                pAuth->cbPasswordBuff = SF_MAX_PASSWORD;
            }
            break;

        case SF_NOTIFY_ACCESS_DENIED:
            {
                PHTTP_FILTER_ACCESS_DENIED pDenied = NULL;
                *ppStFilter = pDenied = MyAllocNZ(HTTP_FILTER_ACCESS_DENIED);

                if (!pDenied)
                    myleave(224);

                pDenied->pszURL = m_pszURL;
                pDenied->pszPhysicalPath = MySzDupWtoA(m_wszPath);
                pDenied->dwReason = SF_DENIED_LOGON;

                if (! pDenied->pszURL || ! pDenied->pszPhysicalPath)
                    myleave(322);

                *ppStFilterOrg = MyAllocNZ(HTTP_FILTER_ACCESS_DENIED);
                if (!(*ppStFilterOrg))
                    myleave(243);
                memcpy(*ppStFilterOrg,*ppStFilter,sizeof(HTTP_FILTER_ACCESS_DENIED));
            }
            break;

        case SF_NOTIFY_SEND_RESPONSE:
            {
                PHTTP_FILTER_SEND_RESPONSE pSendRes = NULL;
                *ppStFilter = pSendRes = MyAllocNZ(HTTP_FILTER_PREPROC_HEADERS);

                if (!pSendRes)
                    myleave(225);

                pSendRes->GetHeader  = ::GetHeader;
                pSendRes->SetHeader  = ::SetHeader;
                pSendRes->AddHeader  = ::SetHeader;
                pSendRes->HttpStatus = rgStatus[m_rs].dwStatusNumber;
                pSendRes->dwReserved = 0;
            }
            break;


        case SF_NOTIFY_SEND_RAW_DATA:
            {
                PHTTP_FILTER_RAW_DATA pRawData = NULL;
                *ppStFilter = pRawData = MyAllocNZ(HTTP_FILTER_RAW_DATA);
                if (!pRawData)
                    myleave(220);

                pRawData->pvInData = *ppszBuf1;
                pRawData->cbInData = *pcbBuf;
                pRawData->cbInBuffer = *pcbBuf;
                pRawData->dwReserved = 0;

                *ppStFilterOrg = MyAllocNZ(HTTP_FILTER_RAW_DATA);
                if (!(*ppStFilterOrg))
                    myleave(244);
                memcpy(*ppStFilterOrg,*ppStFilter,sizeof(HTTP_FILTER_RAW_DATA));
            }
            break;

        case SF_NOTIFY_LOG:
            {
                PHTTP_FILTER_LOG pLog = NULL;
                CHAR szHostBuf[MAX_PATH];

                *ppStFilter = pLog = MyAllocNZ(HTTP_FILTER_LOG);
                if (!pLog)
                    myleave(226);

                pLog->pszClientHostName = MySzAllocA(48);
                GetRemoteAddress(m_socket,(PSTR) pLog->pszClientHostName);

                if ( 0 == gethostname(szHostBuf, sizeof(szHostBuf)))
                    pLog->pszServerName = MySzDupA(szHostBuf);
                else
                    pLog->pszServerName = cszEmpty;

                pLog->pszClientUserName = m_pszRemoteUser;
                pLog->pszOperation = m_pszMethod;
                pLog->pszTarget = m_pszURL;
                pLog->pszParameters = m_pszQueryString;
                pLog->dwWin32Status = GetLastError();
                pLog->dwBytesSent = m_pFInfo->m_dwBytesSent;
                pLog->dwBytesRecvd = m_pFInfo->m_dwBytesReceived;
                pLog->msTimeForProcessing = GetTickCount() - m_pFInfo->m_dwStartTick;

                pLog->dwHttpStatus = rgStatus[m_rs].dwStatusNumber;

                // don't pass NULL, give 'em empty string on certain cases
                if ( ! pLog->pszClientUserName)
                    pLog->pszClientUserName = cszEmpty;

                if ( ! pLog->pszParameters )
                    pLog->pszParameters = cszEmpty;

                if (    !pLog->pszClientUserName  || !pLog->pszServerName
                        ||  !pLog->pszOperation       || !pLog->pszTarget
                        ||  !pLog->pszParameters      || !pLog->pszClientHostName  )
                {
                    myleave(344);
                }

                *ppStFilterOrg = MyAllocNZ(HTTP_FILTER_LOG);
                if (!(*ppStFilterOrg))
                    myleave(245);
                memcpy(*ppStFilterOrg,*ppStFilter,sizeof(HTTP_FILTER_LOG));
            }
            break;

        default:
            TraceTag(ttidWebServer, "FillFC received unknown notification type = %d",dwNotifyType);
            *ppStFilterOrg = *ppStFilter = NULL;
            myleave(246);
            break;
    }

    // the pfc is always the same regardless of dwNotifyType
    pfc->cbSize = sizeof(*pfc);
    pfc->Revision = HTTP_FILTER_REVISION;
    pfc->ServerContext = (PVOID) this;
    pfc->ulReserved = 0;
    pfc->fIsSecurePort = 0;     // BUGBUG, no SSL support
    //  pfc->pFilterContext is filled in calling loop in CallFilter()
    pfc->GetServerVariable = ::GetServerVariable;
    pfc->AddResponseHeaders = ::AddResponseHeaders;
    pfc->WriteClient = ::WriteClient;
    pfc->AllocMem = ::AllocMem;
    pfc->ServerSupportFunction = ::ServerSupportFunction;

    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "FillFC failed on mem alloc, GLE = %d, err= %d",GetLastError(),err);

    return ret;
}




// Final fcn called in CallFilter, this frees any unneeded allocated memory
// and sets the last three values, if valid, to whatever the filter changed them to.

void CHttpRequest::CleanupFC(DWORD dwNotifyType, LPVOID* ppStFilter, LPVOID* ppStFilterOrg,
                             PSTR *ppszBuf1, int *pcbBuf, PSTR *ppszBuf2)

{

    switch (dwNotifyType)
    {
        case SF_NOTIFY_END_OF_NET_SESSION:
        case SF_NOTIFY_END_OF_REQUEST:
        case SF_NOTIFY_PREPROC_HEADERS:
        case SF_NOTIFY_SEND_RESPONSE:
            break;

        case SF_NOTIFY_READ_RAW_DATA:
            {
                PHTTP_FILTER_RAW_DATA pRawData = (PHTTP_FILTER_RAW_DATA) *ppStFilter;

                if (! ppszBuf1)  // Use buffer in CHttpResponse class
                {
                    m_bufRequest.FilterDataUpdate(pRawData->pvInData,pRawData->cbInData,pRawData->pvInData != m_bufRequest.FilterRawData());
                }
                else
                {
                    *ppszBuf1 = (PSTR) pRawData->pvInData;
                    *pcbBuf =   pRawData->cbInData;
                }
            }
            break;


        case SF_NOTIFY_AUTHENTICATION:
            {
                PHTTP_FILTER_AUTHENT pAuth = (PHTTP_FILTER_AUTHENT) *ppStFilter;

                *ppszBuf1 = pAuth->pszUser;
                *ppszBuf2 = pAuth->pszPassword;
            }
            break;

        case SF_NOTIFY_SEND_RAW_DATA:
            {
                PHTTP_FILTER_RAW_DATA pRawData = (PHTTP_FILTER_RAW_DATA) *ppStFilter;
                *ppszBuf1 = (PSTR) pRawData->pvInData;
                *pcbBuf  = pRawData->cbInData;
            }
            break;


        case SF_NOTIFY_URL_MAP:
            {
                PHTTP_FILTER_URL_MAP pUrlMap = (PHTTP_FILTER_URL_MAP) *ppStFilter ;
                PHTTP_FILTER_URL_MAP pUrlMapOrg = (PHTTP_FILTER_URL_MAP) *ppStFilterOrg;

                // Case when parsing http headers from a request.
                if (NULL == ppszBuf1)
                {
                    // since data can be modified in place, always re-copy
                    MyFree(m_wszPath);
                    m_wszPath = MySzDupAtoW(pUrlMap->pszPhysicalPath);

                    MyFree(pUrlMapOrg->pszPhysicalPath);
                }
                else        // ServerSupportFunction with HSE_MAP_URL call
                {
                    *ppszBuf1 = (PSTR) pUrlMap->pszURL;
                    *ppszBuf2 = pUrlMap->pszPhysicalPath;
                    *pcbBuf = pUrlMap->cbPathBuff;
                }
            }
            break;

        case SF_NOTIFY_ACCESS_DENIED:
            {
                PHTTP_FILTER_ACCESS_DENIED pDeniedOrg = (PHTTP_FILTER_ACCESS_DENIED) *ppStFilterOrg;
                // If they change pDenied->pszURL we ignore it.  Since the session
                // is coming to an end because of access problems, the only thing changing
                // pszURL could affect would be logging (which should be set through logging filter)
                MyFree(pDeniedOrg->pszPhysicalPath);
            }
            break;


            // We use m_pFInfo->m_pFLog to store changes to the log.  When
            // we write out the log, we use the web server value by default
            // unless a particular value is non-NULL; by default all values
            // are NULL in m_pFInfo->m_pFLog unless overwritten by this code.
        case SF_NOTIFY_LOG:
            {
                PHTTP_FILTER_LOG pLog = (PHTTP_FILTER_LOG) *ppStFilter;
                PHTTP_FILTER_LOG pLogOrg = (PHTTP_FILTER_LOG ) *ppStFilterOrg;
                PHTTP_FILTER_LOG pFLog;

                // Free dynamically allocated data.
                MyFreeNZ(pLogOrg->pszClientHostName);

                if (pLogOrg->pszServerName != cszEmpty)
                    MyFreeNZ(pLogOrg->pszServerName);

                // If no changes were made, break out early.
                if ( ! memcmp(pLog, pLogOrg, sizeof(HTTP_FILTER_LOG)))
                {
                    break;
                }

                if (NULL == (pFLog = m_pFInfo->m_pFLog = MyAllocZ(HTTP_FILTER_LOG)))
                {
                    // Memory errors just mean we won't bother doing logging, non-fatal.
                    break;
                }

                if (pLog->pszClientHostName != pLogOrg->pszClientHostName)
                    pFLog->pszClientHostName = pLog->pszClientHostName;

                if (pLog->pszServerName  != pLogOrg->pszServerName)
                    pFLog->pszServerName = pLog->pszServerName;

                if (pLog->pszClientUserName  != pLogOrg->pszClientUserName)
                    pFLog->pszClientUserName = pLog->pszClientUserName;

                if (pLog->pszOperation  != pLogOrg->pszOperation)
                    pFLog->pszOperation = pLog->pszOperation;

                if (pLog->pszTarget  != pLogOrg->pszTarget)
                    pFLog->pszTarget = pLog->pszTarget;

                if (pLog->pszParameters  != pLogOrg->pszParameters)
                    pFLog->pszParameters = pLog->pszParameters ;

                pFLog->dwHttpStatus        = pLog->dwHttpStatus;
                pFLog->dwWin32Status       = pLog->dwWin32Status;
                pFLog->dwBytesSent         = pLog->dwBytesSent;
                pFLog->dwBytesRecvd        = pLog->dwBytesRecvd ;
                pFLog->msTimeForProcessing = pLog->msTimeForProcessing;
            }

            break;

        default:
            TraceTag(ttidWebServer, "CleanupFCs received unknown code = %d",dwNotifyType);
            break;

    }

    MyFree(*ppStFilterOrg);
    MyFree(*ppStFilter);
    return;
}

//  Initializes buffers for CallFilter with SF_NOTIFY_AUTHENTICATION, and tries
//  to authenticate if the filter changes any data.

//  Note:  Even in the case where security isn't a component or is disabled in
//         registry, we make this call because filter may theoretically decide to end
//         the session based on the user information it receives.  This is
//         why this fcn isn't part of HandleBasicAuth.

BOOL CHttpRequest::AuthenticateFilter()
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;

    // IIS docs promise the filter minimum sized buffers to write password
    // and user name into, we provide them
    char szUserName[SF_MAX_USERNAME];
    char szPassword[SF_MAX_PASSWORD];

    PSTR pszNewUserName = szUserName;
    PSTR pszNewPassword = szPassword;

    // We only make notification if we're using Anonymous or BASIC auth,
    // otherwise we don't know how to decode the text/password.  Like IIS.
    if ( m_pszAuthType && 0 != _stricmp(m_pszAuthType,cszBasic))
        return TRUE;

    // write existing value, if any, into the new buffers

    //  In this case we've cracked the user name and password into ANSI already.
    if (m_pszRemoteUser)
    {
        strcpy(szUserName,m_pszRemoteUser);
        strcpy(szPassword,m_pszPassword);
    }
    //  We have user user name data but it hasn't been Base64 Decoded yet
    else if (m_pszRawRemoteUser)
    {
        DWORD dwLen = sizeof(szUserName);

        Base64Decode(m_pszRawRemoteUser, szUserName, &dwLen);

        PSTR pszDivider =  strchr(szUserName, ':');
        if (NULL == pszDivider)
            myleave(290);
        *pszDivider++ = 0;      // seperate user & pass

        //  We need copies of this data for later in the fcn
        m_pszRemoteUser = MySzDupA(szUserName, strlen(szUserName));
        if (NULL == m_pszRemoteUser)
            myleave(291);

        m_pszPassword = MySzDupA(pszDivider);
        if (NULL == m_pszPassword)
            myleave(292);

        strcpy(szPassword, m_pszPassword);
        strcpy(szUserName, m_pszRemoteUser);
    }
    // Otherwise the browser didn't set any user information.
    else
    {
        szUserName[0] = '\0';
        szPassword[0] = '\0';
    }


    if ( ! CallFilter(SF_NOTIFY_AUTHENTICATION,&pszNewUserName, NULL, &pszNewPassword))
        myleave(293);

    //  If the filter arbitrarily denied access, then we exit.
    //  Check if the filter has changed the user name ptr or modified it in place.

    if ( pszNewUserName != szUserName ||                            // changed ptr
         (m_pszRemoteUser == NULL  && szUserName[0] != '\0') ||     // modified in place
         (m_pszRemoteUser && strcmp(szUserName, m_pszRemoteUser) )  // modified in place
       )
    {
        // Update m_pszRemoteUser with what was set in filter because GetServerVariable
        // may need it.
        ResetString(m_pszRemoteUser, pszNewUserName);
        if (! m_pszRemoteUser)
            myleave(294);
    }

    if ( pszNewPassword != szPassword ||
         (m_pszPassword == NULL  && szPassword[0] != '\0') ||
         (m_pszPassword && strcmp(szPassword, m_pszPassword))
       )
    {
        // GetServerVariables with AUTH_PASSWORD might request this.
        ResetString(m_pszPassword, pszNewPassword);
        if (! m_pszPassword)
            myleave(295);
    }
    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "Authentication for filters failed, err = %d, GLE = %d",err,GetLastError());
    return ret;
}


//  Called on updating data from an ISAPI filter, resets internal structures.
//  fModifiedPtr is TRUE when

BOOL CBuffer::FilterDataUpdate(PVOID pvData, DWORD cbData, BOOL fModifiedPtr)
{
    if (fModifiedPtr)
    {
        if ((int) (cbData - UnaccessedCount()) > 0)
            AllocMem(cbData - UnaccessedCount() + 1);

        memcpy(m_pszBuf + m_iNextInFollow, pvData, cbData);
    }
    // It's possible we modified data in place, so we always update the size
    // information that the filter passed us in case it changed the # of bytes
    // in the request.

    m_iNextIn = (int)cbData + m_iNextInFollow;
    m_iNextInFollow = m_iNextIn;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\httpexe.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: LISTENER.CPP
Author: Arul Menezes
Abstract: HTTP server initialization & listener thread
--*/


#include "pch.h"
#pragma hdrstop

#include "httpd.h"
typedef void  (WINAPI *PFN_EXECUTE)();

#ifdef UNDER_NT
extern "C" int WINAPI HttpInitializeFromExe();
#endif

int
WINAPI
WinMain(HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
#ifdef UNDER_NT
        LPSTR     lpCmdLine,
#else
        LPWSTR    lpCmdLine,
#endif
        int       nCmdShow)
{

#ifdef UNDER_NT

    // On NT builds, we statically link everything together.
    HttpInitializeFromExe();
#else
    PFN_EXECUTE pFunc = NULL;
    HINSTANCE hLib = LoadLibrary(L"HTTPD.DLL");

    if (!hLib)
    {
        RETAILMSG(1,(L"HTTPDEXE:  Httpd.dll not loaded on device, aborting execution\r\n"));
        return 1;
    }

    pFunc = (PFN_EXECUTE) GetProcAddress(hLib,L"HttpInitializeFromExe");
    if (!pFunc)
    {
        RETAILMSG(1,(L"HTTPDEXE:  Httpd.dll corrupt or old version, aborting execution\r\n"));
        return 1;
    }

    ((PFN_EXECUTE) pFunc)();

#endif

    Sleep(INFINITE);  // don't ever stop, must kp to end us.
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\httpmain.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: LISTENER.CPP
Author: Arul Menezes
Abstract: HTTP server initialization & listener thread
--*/


#include "pch.h"
#pragma hdrstop


#include "httpd.h"
#include "uhbase.h"
#include "interfacelist.h"
#include "uhutil.h"


//
//-------------------- Global data --------------
//

CGlobalVariables *g_pVars;
HANDLE    g_hListenThread;      // handle to the main thread
HINSTANCE g_hInst;
CRITICAL_SECTION  g_csConnection;   // Used to keep track # of connections under the maximum
BOOL            g_fRegistered;

//------------- Const data -----------------------
//

const char cszTextHtml[] = "text/html";
const char cszEmpty[] = "";
const char cszMaxConnectionHeader[] =  "HTTP/1.1 503\r\n\r\n";
LONG g_fState;
BOOL g_fFromExe;    // Did the executable start us?

//
//------------- Debug data -----------------------
//
#if defined(UNDER_CE) && !defined(OLD_CE_BUILD)
    #ifdef DEBUG
DBGPARAM dpCurSettings = {
    TEXT("HTTPD"), {
        TEXT("Error"),TEXT("Init"),TEXT("Listen"),TEXT("Socket"),
        TEXT("Request"),TEXT("Response"),TEXT("ISAPI"),
        TEXT("VROOTS"),TEXT("ASP"),TEXT(""),TEXT(""),
        TEXT(""),TEXT(""),TEXT("Mem"),TEXT("Parser"),TEXT("Tokens")},
    0x0003
};
    #endif
#endif



//
//------------- Prototypes -----------------------
//
PWSTR MassageMultiString(PCWSTR wszIn, PCWSTR wszDefault=NULL);

//
//------------- Startup functions -----------------------
//

HRESULT HrHttpInitialize()
{
    HRESULT     hr = S_OK;
    int         err=0, iGLE=0;
    SOCKET      sockConnection = 0;
    SOCKADDR_IN addrListen;
    WSADATA     wsadata;
    CHAR        szMaxConnectionMsg[256];        // message sent to client if server is too busy

    // Note this will cause the ISAPI DLL to be copied every time the web
    // server starts
    //
    hr = HrMakeIsapiExtensionDirectory();
    if (FAILED(hr))
    {
        myleave(112);
    }

    TraceTag(ttidWebServer, "HTTPD: Creating Listener thread\r\n");

    g_fState = SERVICE_STATE_STARTING_UP;
    g_fRegistered = FALSE;
    g_hInst = _Module.GetResourceInstance();

    InitializeCriticalSection(&g_csConnection);

    svsutil_Initialize();
    DEBUGCHK (g_fState == SERVICE_STATE_STARTING_UP);

    g_pVars = new CGlobalVariables();

    // by design, only 1 HttpListenThread can be instantiated at once, and
    // it's only thread that can modify g_fState
    if (NULL == g_pVars || NULL ==  g_pVars->m_pVroots || NULL == g_pVars->m_pThreadPool)
    {
        g_fState = SERVICE_STATE_OFF;
        myleave(11);
    }
    g_pVars->m_fFilters = InitFilters();  // Filters may make reference to logging global var, so
                                          // make call to filters outside constructor.

    g_fState = SERVICE_STATE_ON;

    strcpy(szMaxConnectionMsg,cszMaxConnectionHeader);
    WCHAR wszMaxConnectionMsg[256];

    LoadString(g_hInst,IDS_SERVER_BUSY,wszMaxConnectionMsg,celems(wszMaxConnectionMsg));
    MyW2A(wszMaxConnectionMsg,szMaxConnectionMsg + sizeof(cszMaxConnectionHeader) - 1,
          sizeof(szMaxConnectionMsg) - sizeof(cszMaxConnectionHeader));

    if (g_pVars->m_pszStatusBodyBuf)
        InitializeResponseCodes(g_pVars->m_pszStatusBodyBuf);

    if (iGLE = WSAStartup(MAKEWORD(1,1), &wsadata))
        goto done;

    if (INVALID_SOCKET == (g_pVars->m_sockListen = socket(AF_INET, SOCK_STREAM, 0)))
        myleave(2);

    memset(&addrListen, 0, sizeof(addrListen));
    addrListen.sin_family = AF_INET;
    addrListen.sin_port = htons((WORD)g_pVars->m_dwListenPort);

    addrListen.sin_addr.s_addr = INADDR_ANY;

    if (bind(g_pVars->m_sockListen, (PSOCKADDR)&addrListen, sizeof(addrListen)))
        myleave(3);

    if (listen(g_pVars->m_sockListen, SOMAXCONN))
        myleave(4);

    if (!WSAEventSelect(g_pVars->m_sockListen, g_pVars->m_hEventSelect, FD_ACCEPT))
    {
        g_hListenThread = MyCreateThread(HandleAccept, 0);
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

done:

    TraceError("HrHttpInitialize", hr);
    return hr;
}

HRESULT HrHttpShutdown()
{
    HRESULT     hr = S_OK;

    TraceTag(ttidWebServer, "Shutting down web server...");

    g_fState = SERVICE_STATE_SHUTTING_DOWN;

    g_pVars->m_fAcceptConnections = FALSE;

    //  BUGBUG, 11168.  It's possible ASP pages or ISAPI extns may have an
    //  infinite loop in them, in which case we never decrement this value and
    //  never get to stop the server.
    //  Fix:  None.  This behavior has been documented, too much of a pain for us
    //  to fix.

    TraceTag(ttidWebServer, "Wating for %d HTTP threads to come to a halt", g_pVars->m_nConnections);
    g_pVars->m_pLog->WriteEvent(IDS_HTTPD_SHUTDOWN_START);

    g_pVars->m_pThreadPool->Shutdown();

    TraceTag(ttidWebServer, "Signalling accept thread to stop");
    SetEvent(g_pVars->m_hEventShutdown);

    // Wait until all connections have been closed before shutting down
    while (TRUE)
    {
        DWORD   cConnections;

        EnterCriticalSection(&g_csConnection);
        cConnections = g_pVars->m_nConnections;
        LeaveCriticalSection(&g_csConnection);

        if (!cConnections)
        {
            break;
        }

        // wait a bit
        Sleep(100);
    }

    TraceTag(ttidWebServer, "All HTTPD threads have come to halt, shutting down server");

    if (g_hListenThread)
    {
        TraceTag(ttidWebServer, "Waiting for accept thread to exit");

        // Wait for thread to exit
        WaitForSingleObject(g_hListenThread, INFINITE);

        TraceTag(ttidWebServer, "Accept thread has exited. Closing handle.");

        CloseHandle(g_hListenThread);

        g_hListenThread = 0;  // signifies that we exited normally, don't do a TerminateThread on this.
    }

    if (g_pVars)
    {
        closesocket(g_pVars->m_sockListen);
        delete g_pVars;
    }

    DeleteCriticalSection(&g_csConnection);

    return hr;
}

HRESULT HrAddVroot(LPWSTR szUrl, LPWSTR szPath)
{
    HRESULT     hr = S_OK;

    if (!g_pVars->m_pVroots->AddVRoot(szUrl, szPath))
    {
        hr = E_FAIL;
    }

    TraceError("HrAddVroot", hr);
    return hr;
}

HRESULT HrRemoveVroot(LPWSTR szUrl)
{
    HRESULT     hr = S_OK;

    if (!g_pVars->m_pVroots->RemoveVRoot(szUrl))
    {
        hr = E_FAIL;
    }

    TraceError("HrRemoveVroot", hr);
    return hr;
}

CGlobalVariables::CGlobalVariables()
{
    DWORD dwMaxLogSize;
    WCHAR     wszLogDir[MAX_PATH + 1];
    ZEROMEM(this);
    m_sockListen = INVALID_SOCKET;
    m_pszServerID = NULL;

    CReg reg(HKEY_LOCAL_MACHINE, RK_HTTPD);

    if ( (HKEY) reg == 0)
    {
        CLog cLog(4096,L"\\windows\\www");
        cLog.WriteEvent(IDS_HTTPD_NO_REGKEY);
        TraceTag(ttidWebServer, "HTTPD:  No registry key setup, will not handle requests");
        return;
    }

    dwMaxLogSize = reg.ValueDW(RV_MAXLOGSIZE);
    if ( ! reg.ValueSZ(RV_LOGDIR,wszLogDir,MAX_PATH+1))
    {
        wcscpy(wszLogDir,L"\\windows\\www");
    }

    m_pLog = new CLog(dwMaxLogSize,wszLogDir);

    if (!g_fFromExe && (0 == reg.ValueDW(RV_ISENABLED,1)))
    {
        m_pLog->WriteEvent(IDS_HTTPD_DISABLED);
        TraceTag(ttidWebServer, "HTTPD: IsEnable = 0, won't start web server");
        return;
    }

    m_dwListenPort = reg.ValueDW(RV_PORT, IPPORT_HTTP);
    DEBUGCHK(m_dwListenPort);

    m_dwPostReadSize = reg.ValueDW(RV_POSTREADSIZE, 48*1024);  // 48 K default

    m_fExtensions = InitExtensions(&m_pISAPICache,&m_dwCacheSleep);
    m_fASP = InitASP(&m_ASPScriptLang,&m_lASPCodePage,&m_ASPlcid);

    m_fDirBrowse   = reg.ValueDW(RV_DIRBROWSE, HTTPD_ALLOW_DIR_BROWSE);

    m_wszDefaultPages = MassageMultiString(reg.ValueSZ(RV_DEFAULTPAGE),HTTPD_DEFAULT_PAGES);
    m_wszAdminUsers   = MassageMultiString(reg.ValueSZ(RV_ADMINUSERS));
    m_wszAdminGroups  = MassageMultiString(reg.ValueSZ(RV_ADMINGROUPS));


    AuthInitialize(&reg,&m_fBasicAuth, &m_fNTLMAuth);

    m_pVroots = new CVRoots();
    if (!m_pVroots)
    {
        return;
    }

    // vroot table must be initialized or web server can't return files.  Warn
    // user if this is not the case
    if (m_pVroots->Count() == 0)
        m_pLog->WriteEvent(IDS_HTTPD_NO_VROOTS);


    if (NULL == (m_pszStatusBodyBuf = MyRgAllocNZ(CHAR,BODYSTRINGSIZE)))
        return;

    if (NULL == (m_pszServerID = MyRgAllocNZ(CHAR, 256)))
        return;

    if (WSA_INVALID_EVENT == (m_hEventSelect = WSACreateEvent()))
        return;

    if (INVALID_HANDLE_VALUE == (m_hEventShutdown = CreateEvent(NULL, TRUE, FALSE, NULL)))
        return;

    lstrcpyA(m_pszServerID, "Microsoft-Windows-NT/5.1 UPnP/1.0 UPnP-Device-Host/1.0");

    m_nMaxConnections = reg.ValueDW(RV_MAXCONNECTIONS,10);

    m_pThreadPool = new SVSThreadPool(m_nMaxConnections + 1);  // +1 for ISAPI Cache removal thread
    if (!m_pThreadPool)
    {
        delete m_pVroots;
        m_pVroots = NULL;

        MyFree(m_pszStatusBodyBuf);
        m_pszStatusBodyBuf = NULL;

        return;
    }

    m_fAcceptConnections = TRUE;
}


CGlobalVariables::~CGlobalVariables()
{
    MyFree(m_wszDefaultPages);
    MyFree(m_wszAdminUsers);
    MyFree(m_wszAdminGroups);
    MyFree(m_pszStatusBodyBuf);
    MyFree(m_pszServerID);

    CleanupFilters();

    if (m_pVroots)
        delete m_pVroots;

    if (m_pISAPICache)
    {
        RemoveUnusedISAPIs((void*)1);       // Tell it to flush all ISAPIs.  This will blocks until everyoen's unloaded.
        delete m_pISAPICache;
    }

    if (m_pLog)
        delete m_pLog;

    if (m_pThreadPool)
        delete m_pThreadPool;

    if (m_hEventSelect != NULL && m_hEventSelect != WSA_INVALID_EVENT)
    {
        WSACloseEvent(m_hEventSelect);
    }

    if (m_hEventShutdown != NULL && m_hEventShutdown != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hEventShutdown);
    }

    MyFreeLib(m_hNTLMLib);
}

//
// Main HTTP listener thread. Launched from HTTPInitialize
// or called directly by main() in test mode
//
DWORD WINAPI HandleAccept(LPVOID lpv)
{
    SOCKET              sockConnection = 0;
    CHAR                szMaxConnectionMsg[256];        // message sent to client if server is too busy
    HANDLE              rgHandles[2];
    DWORD               dwRet;
    WSANETWORKEVENTS    wsaNetEvents = {0};

    rgHandles[0] = g_pVars->m_hEventSelect;
    rgHandles[1] = g_pVars->m_hEventShutdown;

    while (TRUE)
    {
        dwRet = WaitForMultipleObjects(2, rgHandles, FALSE, INFINITE);
        if (dwRet == WAIT_OBJECT_0)
        {
            wsaNetEvents.lNetworkEvents = 0;
            if (WSAEnumNetworkEvents(g_pVars->m_sockListen,
                                     g_pVars->m_hEventSelect,
                                     &wsaNetEvents) == SOCKET_ERROR)
            {
                 TraceError("HandleAccept",
                            HRESULT_FROM_WIN32(WSAGetLastError()));
                 break;
            }
            else if (wsaNetEvents.lNetworkEvents & FD_ACCEPT)
            {
                TraceTag(ttidWebServer, "HTTPD: Calling ACCEPT....");
                sockConnection = WSAAccept(g_pVars->m_sockListen, NULL, NULL,
                                           NULL ,NULL);
                if (sockConnection != INVALID_SOCKET)
                {
                    int cb = sizeof(SOCKADDR_IN);
                    SOCKADDR_IN     sockLocal;

                    getsockname(sockConnection, (SOCKADDR *)&sockLocal, &cb);
                    TraceTag(ttidWebServer, "HTTPD: Received Connection on address, "
                             "addr = %s!!", inet_ntoa(sockLocal.sin_addr));

                    if (g_pVars->m_fAcceptConnections)
                    {
                        // We decide whether to handle the request based on the number of connections
                        // We NEVER put a thread into the thread pool wait list because we want
                        // the web server to respond immediatly to browser if it's too busy.

                        EnterCriticalSection(&g_csConnection);

                        DEBUGCHK(g_pVars->m_nConnections <= g_pVars->m_nMaxConnections);

                        if (g_pVars->m_nConnections >= g_pVars->m_nMaxConnections)
                        {
                            LeaveCriticalSection(&g_csConnection);

                            TraceTag(ttidWebServer, "HTTPD: Connection Count -- Reached "
                                     "maximum # of connections, won't accept current request.");

                            send(sockConnection,szMaxConnectionMsg,
                                 lstrlenA(szMaxConnectionMsg),0);
                            closesocket(sockConnection);
                        }
                        else if (!CUPnPInterfaceList::Instance().FShouldSendOnInterface(sockLocal.sin_addr.S_un.S_addr))
                        {
                            LeaveCriticalSection(&g_csConnection);

                            TraceTag(ttidWebServer, "HTTPD: We should not be "
                                     "responding to requests that come in on local "
                                     "address %s!", inet_ntoa(sockLocal.sin_addr));

                            // ISSUE-2000/12/28-danielwe: What to send in response?
                            //send(sockConnection,szMaxConnectionMsg, lstrlenA(szMaxConnectionMsg),0);
                            closesocket(sockConnection);
                        }
                        else
                        {
                            g_pVars->m_nConnections++;

                            LeaveCriticalSection(&g_csConnection);

                            QueueUserWorkItem(HttpConnectionThread,
                                              (LPVOID) sockConnection,
                                              WT_EXECUTELONGFUNCTION);
                        }
                    }
                }
                else if (GetLastError() == WSAEWOULDBLOCK)
                {
                    AssertSz(FALSE, "WSAAccept failed with WSAEWOULDBLOCK!");
                    WSASetEvent(g_pVars->m_hEventSelect);
                }
                else
                {
                    AssertSz(FALSE, "WSAAccept failed for some other reason!");
                }
            }
            else
            {
                AssertSz(FALSE, "Did not get an ACCEPT network event!");
            }
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            // Shutting down
            Assert(g_fState == SERVICE_STATE_SHUTTING_DOWN);
            break;
        }
        else
        {
            TraceError("HandleAccept - WaitForMultipleObjects "
                       "failed! Thread is exiting", HrFromLastWin32Error());

            AssertSz(FALSE, "HandleAccept - Wait failed!");
            break;
        }
    }

    return 0;
}

DWORD WINAPI HttpConnectionThread(LPVOID lpv)
{
    SOCKET  sock = (SOCKET) lpv;
   
    // this socket is non blocking and send and recv fucntion is not implemented to take case of non blocking sockets
    // This must be changed.

    
    // this outer _try--_except is to catch crashes in the destructor
    __try
    {
           
        CHttpRequest* pRequest = new CHttpRequest((SOCKET) sock);
        if (pRequest)
        {
            __try
            {
                // This loops as long the the socket is being kept alive
                for (;;)
                {
                    pRequest->HandleRequest();

                        // figure out if we must keep this connection alive,
                        // Either session is over through this request's actions or
                        // globally set to accept no more connections.

                        // We do the global g_pVars->m_fAcceptConnections check
                        // because it's possible that we may be in the process of
                        // shutting down the web server, in which case we want to
                        // exit even if we're performing a keep alive.

                    if (! (g_pVars->m_fAcceptConnections  && pRequest->m_fKeepAlive))
                    {
                        if (g_pVars->m_fFilters)
                            pRequest->CallFilter(SF_NOTIFY_END_OF_NET_SESSION);
                            break;
                    }


                        // If we're continuing the session don't delete all data, just request specific data
                    if ( ! pRequest->ReInit())
                        break;
                }
            }
            __finally
            {
                    // Note:  To get this to compile under Visual Studio, the /Gx- compile line option is set
                delete pRequest;
                pRequest = 0;
            }
        }
    }
    __except(1)
    {
        RETAILMSG(1, (L"HTTP Server got an exception!!!\r\n"));
        g_pVars->m_pLog->WriteEvent(IDS_HTTPD_EXCEPTION,GetExceptionCode(),GetLastError());
    }

    EnterCriticalSection(&g_csConnection);
    g_pVars->m_nConnections--;
    LeaveCriticalSection(&g_csConnection);

    shutdown(sock, 1);
    closesocket(sock);
    return 0;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//
//  UTILITY FUNCTIONS
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//

PWSTR MassageMultiString(PCWSTR wszIn, PCWSTR wszDefault)
{
    if (!wszIn) wszIn = wszDefault;
    if (!wszIn) return NULL;

    PWSTR wszOut = MyRgAllocNZ(WCHAR, 2+wcslen(wszIn)); // +2 for dbl-null term
    if (!wszOut)
        return NULL;

    for (PWSTR wszNext=wszOut; *wszIn; wszIn++, wszNext++)
    {
        *wszNext = (*wszIn==L';' ? L'\0' : *wszIn);

        // Ignore space between ";" and next non-space
        if ( L';' == *wszIn)
        {
            wszIn++;
            SkipWWhiteSpace(wszIn);
            wszIn--;        // otherwise we skip first char of new string.
        }
    }
    wszNext[0] = wszNext[1] = 0; // dbl-null
    return wszOut;
}


void GetRemoteAddress(SOCKET sock, PSTR pszBuf)
{
    SOCKADDR_IN sockaddr;
    int iLen = sizeof(sockaddr);
    PSTR pszTemp;

    *pszBuf=0;
    if (getpeername(sock, (PSOCKADDR)&sockaddr, &iLen))
    {
        TraceTag(ttidWebServer, "getpeername failed GLE=%d", GetLastError());
        return;
    }
    if (!(pszTemp = inet_ntoa(sockaddr.sin_addr)))
    {
        TraceTag(ttidWebServer, "inet_ntoa failed GLE=%d", GetLastError());
        return;
    }
    strcpy(pszBuf, pszTemp);
}

void GetLocalAddress(SOCKET sock, PSTR pszBuf)
{
    SOCKADDR_IN sockaddr;
    int iLen = sizeof(sockaddr);
    PSTR pszTemp;

    *pszBuf=0;
    if (getsockname(sock, (PSOCKADDR)&sockaddr, &iLen))
    {
        TraceTag(ttidWebServer, "getsockname failed GLE=%d", GetLastError());
        return;
    }
    if (!(pszTemp = inet_ntoa(sockaddr.sin_addr)))
    {
        TraceTag(ttidWebServer, "inet_ntoa failed GLE=%d", GetLastError());
        return;
    }
    strcpy(pszBuf, pszTemp);
}

PSTR MySzDupA(PCSTR pszIn, int iLen)
{
    if (!pszIn) return NULL;
    if (!iLen) iLen = strlen(pszIn);
    PSTR pszOut=MySzAllocA(iLen);
    if (pszOut)
    {
        memcpy(pszOut, pszIn, iLen);
        pszOut[iLen] = 0;
    }
    return pszOut;
}

PWSTR MySzDupW(PCWSTR wszIn, int iLen)
{
    if (!wszIn) return NULL;
    if (!iLen) iLen = wcslen(wszIn);
    PWSTR wszOut=MySzAllocW(iLen);
    if (wszOut)
    {
        memcpy(wszOut, wszIn, sizeof(WCHAR)*iLen);
        wszOut[iLen] = 0;
    }
    return wszOut;
}

PWSTR MySzDupAtoW(PCSTR pszIn, int iInLen)
{
    PWSTR pwszOut = 0;
    int   iOutLen = MultiByteToWideChar(CP_ACP, 0, pszIn, iInLen, 0, 0);
    if (!iOutLen)
        goto error;
    pwszOut = MySzAllocW(iOutLen);
    if (!pwszOut)
        goto error;
    if (MultiByteToWideChar(CP_ACP, 0, pszIn, iInLen, pwszOut, iOutLen))
        return pwszOut;

    error:
    TraceTag(ttidWebServer, "MySzDupAtoW(%s, %d) failed. pOut=%0x08x GLE=%d", pszIn, iInLen, pwszOut, GetLastError());
    MyFree(pwszOut);
    return FALSE;
}

PSTR MySzDupWtoA(PCWSTR wszIn, int iInLen)
{
    PSTR pszOut = 0;
    int   iOutLen = WideCharToMultiByte(CP_ACP, 0, wszIn, iInLen, 0, 0, 0, 0);
    if (!iOutLen)
        goto error;
    pszOut = MySzAllocA(iOutLen);
    if (!pszOut)
        goto error;
    if (WideCharToMultiByte(CP_ACP, 0, wszIn, iInLen, pszOut, iOutLen, 0, 0))
        return pszOut;

    error:
    TraceTag(ttidWebServer, "MySzDupWtoA(%s, %d) failed. pOut=%0x08x GLE=%d", wszIn, iInLen, pszOut, GetLastError());
    MyFree(pszOut);
    return FALSE;
}

BOOL MyStrCatA(PSTR *ppszDest, PSTR pszSource, PSTR pszDivider)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    PSTR pszNew = *ppszDest;  // protect orignal ptr should realloc fail
    PSTR pszTrav;
    DWORD dwSrcLen = MyStrlenA(pszSource);
    DWORD dwDestLen = MyStrlenA(*ppszDest);
    DWORD dwDivLen = MyStrlenA(pszDivider);


    if (!pszNew)   // do an alloc first time, ignore divider
    {
        if (NULL == (pszNew = MySzDupA(pszSource,dwSrcLen)))
            myleave(260);
    }
    else
    {
        if (NULL == (pszNew = MyRgReAlloc(char,pszNew,dwDestLen,dwSrcLen + dwDestLen + dwDivLen + 1)))
            myleave(261);

        pszTrav = pszNew + dwDestLen;
        if (pszDivider)
        {
            memcpy(pszTrav, pszDivider, dwDivLen);
            pszTrav += dwDivLen;
        }

        strcpy(pszTrav, pszSource);
    }

    *ppszDest = pszNew;
    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "MyStrCat err = %d",GetLastError());

    return ret;
}

//**************************************************************************
//  Component Notes

//  This is used by Filters and by Authentication components.  The only common
//  component they both rest on is core, so we include it here.
//**************************************************************************

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//
//  BASE64 ENCODE/DECODE FUNCTIONS from sicily.c
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//

const int base642six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

const char six2base64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

//-----------------------------------------------------------------------------
// Function:  encode()
//-----------------------------------------------------------------------------
BOOL Base64Encode(
                 BYTE *   bufin,          // in
                 DWORD    nbytes,         // in
                 char *   pbuffEncoded)   // out
{
    unsigned char *outptr;
    unsigned int   i;
    const char    *rgchDict = six2base64;

    outptr = (unsigned char *)pbuffEncoded;

    for (i=0; i < nbytes; i += 3)
    {
        *(outptr++) = rgchDict[*bufin >> 2];            /* c1 */
        *(outptr++) = rgchDict[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
        *(outptr++) = rgchDict[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
        *(outptr++) = rgchDict[bufin[2] & 077];         /* c4 */

        bufin += 3;
    }

    /* If nbytes was not a multiple of 3, then we have encoded too
     * many characters.  Adjust appropriately.
     */
    if (i == nbytes+1)
    {
        /* There were only 2 bytes in that last group */
        outptr[-1] = '=';
    }
    else if (i == nbytes+2)
    {
        /* There was only 1 byte in that last group */
        outptr[-1] = '=';
        outptr[-2] = '=';
    }

    *outptr = '\0';

    return TRUE;
}


//-----------------------------------------------------------------------------
// Function:  decode()
//-----------------------------------------------------------------------------
BOOL Base64Decode(
                 char   * bufcoded,       // in
                 char   * pbuffdecoded,   // out
                 DWORD  * pcbDecoded)     // in out
{
    INT_PTR        nbytesdecoded;
    char          *bufin;
    unsigned char *bufout;
    INT_PTR        nprbytes;
    const int     *rgiDict = base642six;

    /* Strip leading whitespace. */

    while (*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while (rgiDict[*(bufin++)] <= 63);
    nprbytes = bufin - bufcoded - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( pcbDecoded )
        *pcbDecoded = (DWORD)nbytesdecoded;

    bufout = (unsigned char *)pbuffdecoded;

    bufin = bufcoded;

    while (nprbytes > 0)
    {
        *(bufout++) =
        (unsigned char) (rgiDict[*bufin] << 2 | rgiDict[bufin[1]] >> 4);
        *(bufout++) =
        (unsigned char) (rgiDict[bufin[1]] << 4 | rgiDict[bufin[2]] >> 2);
        *(bufout++) =
        (unsigned char) (rgiDict[bufin[2]] << 6 | rgiDict[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if (nprbytes & 03)
    {
        if (rgiDict[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded)[nbytesdecoded] = '\0';

    return TRUE;
}

//  Gets version info from the pszVersion string
//  HTTP version string come in the following form:  HTTP/Major.Minor,
//  where Major and Minor are integers.

BOOL SetHTTPVersion(PSTR pszVersion, DWORD *pdwVersion)
{
    int iMajor, iMinor;
    DWORD cbVer = strlen(cszHTTPVER);
    PSTR pszTemp;

    if (_memicmp(pszVersion,cszHTTPVER, min(strlen(pszVersion), cbVer)))
    {
        return FALSE;
    }
    iMajor = atoi(pszVersion+cbVer);
    if (NULL == (pszTemp = strchr(pszVersion+cbVer,'.')))
        return FALSE;

    iMinor = atoi(pszTemp+1);
    *pdwVersion = MAKELONG(iMinor,iMajor);
    return TRUE;
}


//  Writes http version info in dwVersion into pszVersion
//  Substitutes for:  sprintf(szBuf, "HTTP/%d.%d", HIWORD(m_dwVersion), LOWORD(m_dwVersion));

void WriteHTTPVersion(PSTR pszVersion, DWORD dwVersion)
{
    PSTR pszTrav =  strcpyEx(pszVersion,cszHTTPVER);

    _itoa(HIWORD(dwVersion),pszTrav, 10);
    pszTrav = strchr(pszTrav,'\0');
    *pszTrav++ = '.';
    _itoa(LOWORD(dwVersion),pszTrav, 10);
}

//  Replaces
//  i = sscanf(pszTok, cszDateParseFmt, &st.wDay, &szMonth, &st.wYear, &st.wHour, &st.wMinute, &st.wSecond, &m_dwIfModifiedLength);
//  const char cszDateParseFmt[] = " %*3s, %02hd %3s %04hd %02hd:%02hd:%02hd GMT; length=%d";


//  This macro advance psz n characters ahead.  However, if there is a \0 in between
//  psz[0] and psz[n-1], it will return FALSE.
//  We do this \0 check rathern than psz += n because even
//  though we're throwing out the input, we want to make sure we don't walk past the
//  end of a buffer.

#define SKIP_INPUT(psz, n)  { int j; for (j = 0; j <= (n); j++) { if (! (psz)[j]) return FALSE; } (psz) += (n); }


BOOL SetHTTPDate(PSTR pszDate, PSTR pszMonth, SYSTEMTIME *pst, PDWORD pdwModifiedLength)
{
    PSTR pszTrav = pszDate;
    int i;

    // Skip past day of week (Sun/Mon/...), comma, space.  We don't
    // do this with pszTrav += 5 because we could have an ilformatted string
    // that is too short,

    SKIP_INPUT(pszTrav,5);

    pst->wDay = (WORD)atoi(pszTrav);
    SKIP_INPUT(pszTrav,3);

    // Copy month data into pszMonth.  Again, don't do memcpy.
    for (i = 0; i < 3; i++)
    {
        if (pszTrav[i] == '\0')
            return FALSE;

        pszMonth[i] = pszTrav[i];
    }
    pszMonth[i] = 0;

    pszTrav += 4;
    if (! (*pszTrav))
        return FALSE;

    pst->wYear = (WORD)atoi(pszTrav);
    SKIP_INPUT(pszTrav,5);

    pst->wHour = (WORD)atoi(pszTrav);
    pszTrav += 2;
    if (':' != *pszTrav)
        return FALSE;
    pszTrav++;

    pst->wMinute = (WORD)atoi(pszTrav);
    pszTrav += 2;
    if (':' != *pszTrav)
        return FALSE;
    pszTrav++;


    pst->wSecond = (WORD)atoi(pszTrav);
    pszTrav += 2;

    // NT Port:  On NT, two files could have the same date, but using GetFileTime will
    // put a non-zero # of milliseconds in the file time value, so the file time
    // comparison will think the file is older than the one we're comparing against
    // by a few milliseconds.
    pst->wMilliseconds = 999;


    SKIP_INPUT(pszTrav,sizeof(" GMT; length=") -1);

    *pdwModifiedLength = atoi(pszTrav);

    return TRUE;
}

//  Does the following
// sprintf(szBuffer + i, cszDateOutputFmt,rgWkday[st.wDayOfWeek], st.wDay, rgMonth[st.wMonth], st.wYear, st.wHour, st.wMinute, st.wSecond);

PSTR WriteHTTPDate(PSTR pszDateBuf, SYSTEMTIME *pst, BOOL fAddGMT)
{
    PSTR pszTrav;

    // Day of week
    pszTrav = strcpyEx(pszDateBuf,rgWkday[pst->wDayOfWeek]);
    *pszTrav++ = ',';
    *pszTrav++ = ' ';


    // Day number.  Write 0 out if there isn't one already.
    if (pst->wDay < 10)
    {
        _itoa(0,pszTrav,10);
        _itoa(pst->wDay,pszTrav+1,10);
    }
    else
    {
        _itoa(pst->wDay,pszTrav,10);
    }
    pszTrav += 2;
    *pszTrav++ = ' ';

    // Month
    pszTrav = strcpyEx(pszTrav,rgMonth[pst->wMonth]);
    *pszTrav++ = ' ';

    // Year
    _itoa(pst->wYear,pszTrav,10);
    pszTrav += 4;
    *pszTrav++ = ' ';

    // Hour
    if (pst->wHour < 10)
    {
        _itoa(0,pszTrav,10);
        _itoa(pst->wHour,pszTrav+1,10);
    }
    else
    {
        _itoa(pst->wHour,pszTrav,10);
    }
    pszTrav += 2;
    *pszTrav++ = ':';

    // Minute
    if (pst->wMinute < 10)
    {
        _itoa(0,pszTrav,10);
        _itoa(pst->wMinute,pszTrav+1,10);
    }
    else
    {
        _itoa(pst->wMinute,pszTrav,10);
    }
    pszTrav += 2;
    *pszTrav++ = ':';

    // Second
    if (pst->wSecond < 10)
    {
        _itoa(0,pszTrav,10);
        _itoa(pst->wSecond,pszTrav+1,10);
    }
    else
    {
        _itoa(pst->wSecond,pszTrav,10);
    }
    pszTrav += 2;


    if (fAddGMT)
        pszTrav = strcpyEx(pszTrav," GMT\r\n");
    else
    {
        *pszTrav++ = ' ';
        *pszTrav = '\0';
    }

    return pszTrav;
}


/*===================================================================
strcpyEx

Copy one string to another, returning a pointer to the NUL character
in the destination

Parameters:
    szDest - pointer to the destination string
    szSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *strcpyEx(char *szDest, const char *szSrc)
{
    while (*szDest++ = *szSrc++)
        ;

    return szDest - 1;
}

#if defined(OLD_CE_BUILD)
    #if (_WIN32_WCE < 210)
VOID GetCurrentFT(LPFILETIME lpFileTime)  {
    SYSTEMTIME st;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st,lpFileTime);
    LocalFileTimeToFileTime(lpFileTime,lpFileTime);
}
    #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\auth.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: AUTH.CPP
Author: Arul Menezes
Abstract: Authentication
--*/
#include "pch.h"
#pragma hdrstop

#include "httpd.h"

#define IsAccessAllowed(a,b,c,d) TRUE

#define NTLM_DOMAIN TEXT("Domain")  // dummy data.
#define SEC_SUCCESS(Status) ((Status) >= 0)

#ifndef OLD_CE_BUILD
BOOL NTLMServerContext(
                      PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,
                      PAUTH_NTLM pAS,BYTE *pIn, DWORD cbIn, BYTE *pOut,
                      DWORD *pcbOut, BOOL *pfDone
                      );

BOOL NTLMClientContext(
                      PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,
                      PAUTH_NTLM pAS, BYTE *pIn, DWORD cbIn,
                      BYTE *pOut, DWORD *pcbOut
                      );
#endif


AUTHLEVEL GetAuthFromACL(PAUTH_NTLM pAuth, PWSTR wszUser, PWSTR wszVRootUserList);

void AuthInitialize(CReg *pReg, BOOL * pfBasicAuth, BOOL * pfNTLMAuth)
{
    *pfBasicAuth   =  pReg->ValueDW(RV_BASIC);
#ifdef OLD_CE_BUILD

    // No passthrough Auth on CE 2.11 devices, set it to 0 to avoid misconfigurations
    *pfNTLMAuth    = 0;
#else
    *pfNTLMAuth    =  pReg->ValueDW(RV_NTLM);
#endif
}

// For calls to Basic Authentication, only called during the parsing stage.
BOOL HandleBasicAuth(PSTR pszData, PSTR* ppszUser, PSTR *ppszPassword,
                     AUTHLEVEL* pAuth, PAUTH_NTLM pNTLMState, WCHAR *wszVRootUserList)
{
    char szUserName[MAXUSERPASS];
    DWORD dwLen = sizeof(szUserName);

    *pAuth = AUTH_PUBLIC;
    *ppszUser = NULL;

    // decode the base64
    Base64Decode(pszData, szUserName, &dwLen);

    // find the password
    PSTR pszPassword = strchr(szUserName, ':');
    if (!pszPassword)
    {
        TraceTag(ttidWebServer, "Bad Format for Basic userpass(%s)-->(%s)", pszData, szUserName);
        return FALSE;
    }
    *pszPassword++ = 0; // seperate user & pass



    WCHAR wszPassword[MAXUSERPASS];
    MyA2W(pszPassword, wszPassword, CCHSIZEOF(wszPassword));

    WCHAR wszUserName[MAXUSERPASS];
    MyA2W(szUserName,wszUserName, CCHSIZEOF(wszUserName));

    //  We save the data no matter what, for logging purposes and for possible
    //  GetServerVariable call.
    *ppszUser = MySzDupA(szUserName);
    *ppszPassword = MySzDupA(pszPassword);


    // If AUTH_USER has been granted, check to see if they're an administrator.
    // In BASIC we can only check against the name (no NTLM group info)
#ifdef UNDER_CE
    if (CheckPassword(wszPassword))
    {
        *pAuth = GetAuthFromACL(NULL,wszUserName,wszVRootUserList);
        return TRUE;
    }
#endif

#ifndef OLD_CE_BUILD
    if (g_pVars->m_fNTLMAuth && BasicToNTLM(pNTLMState, wszPassword,wszUserName,pAuth,wszVRootUserList))
    {
        return TRUE;
    }
#endif

    TraceTag(ttidWebServer, "Failed logon with Basic userpass(%s)-->(%s)(%s)", pszData, szUserName, pszPassword);
    return FALSE;
}

#ifdef OLD_CE_BUILD
// The web server beta doesn't have NTLM, but it uses this file so we
// don't use AuthStub.cpp here

BOOL CHttpRequest::HandleNTLMAuth(PSTR pszNTLMData)
{
    return FALSE;
}

BOOL NTLMInitLib(PAUTH_NTLM pNTLMState)
{
    return FALSE;
}

void FreeNTLMHandles(PAUTH_NTLM pNTLMState)
{
    ;
}
#else

// This function is called 2 times during an NTLM auth session.  The first
// time it has the Client user name, domain,... which it forwards to DC or
// looks in registry for (this NTLM detail is transparent to httpd)
// On 2nd time it has the client's response, which either is or is not
// enough to grant access to page.  On 2nd pass, free up all NTLM context data.

// FILTER NOTES:  On IIS no user name or password info is given to the filter
// on NTLM calls, so neither do we.  (WinCE does give BASIC data, though).
// The main reason this is is that


BOOL CHttpRequest::HandleNTLMAuth(PSTR pszNTLMData)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    DWORD dwIn;
    DWORD dwOut;
    BOOL fDone = FALSE;
    PBYTE pOutBuf = NULL;
    PBYTE pInBuf = NULL;   // Base64 decoded data from pszNTLMData


    // Are the NTLM libs loaded already?
    if (NTLM_NO_INIT_LIB == m_NTLMState.m_Conversation)
    {
        if ( ! NTLMInitLib(&m_NTLMState))
            myretleave(FALSE,94);
    }

    dwOut = g_pVars->m_cbNTLMMax;
    if (NULL == (pOutBuf = MyRgAllocNZ(BYTE,dwOut)))
        myleave(360);

    if (NULL == m_pszNTLMOutBuf)
    {
        // We will later Base64Encode pOutBuf later, encoding writes 4 outbut bytes
        // for every 3 input bytes
        if (NULL == (m_pszNTLMOutBuf = MyRgAllocNZ(CHAR,dwOut*(4/3) + 1)))
            myleave(361);
    }

    dwIn = strlen(pszNTLMData) + 1;
    if (NULL == (pInBuf = MyRgAllocNZ(BYTE,dwIn)))
        myleave(363);


    Base64Decode(pszNTLMData,(PSTR) pInBuf,&dwIn);

    //  On the 1st pass this gets a data blob to be sent back to the client
    //  broweser in pOutBuf, which is encoded to m_pszNTLMOutBuf.  On the 2nd
    //  pass it either authenticates or fails.


    if (! NTLMServerContext(NULL, &m_NTLMState, pInBuf,
                            dwIn,pOutBuf,&dwOut,&fDone))
    {
        // Note:  We MUST free the m_pszNTMLOutBuf on 2nd pass failure.  If the
        // client recieves the blob on a failure
        // it will consider the web server to be malfunctioning and will not send
        // another set of data, and will not prompt the user for a password.
        MyFree(m_pszNTLMOutBuf);


        // Setting to DONE will cause the local structs to be freed; they must
        // be fresh in case browser attempts to do NTLM again with new user name/
        // password on same session.  Don't bother unloading the lib.
        m_NTLMState.m_Conversation = NTLM_DONE;
        myleave(362);
    }

    if (fDone)
    {
        TraceTag(ttidWebServer, "NTLM Successfully authenticated user");
        m_AuthLevelGranted = GetAuthFromACL(&m_NTLMState,NULL,m_wszVRootUserList);

        m_dwAuthFlags |= m_AuthLevelGranted;
        m_NTLMState.m_Conversation = NTLM_DONE;
        MyFree(m_pszNTLMOutBuf);

        myretleave(TRUE,0);
    }
    Base64Encode(pOutBuf,dwOut,m_pszNTLMOutBuf);

    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "HandleNTLMAuthent died, err = %d, gle = %d",err,GetLastError());

    MyFree(pOutBuf);
    MyFree(pInBuf);
    return ret;
}


//  Sets up NTLM info in the passed data structure.  This fcn loads the library,
//  gets the function table, and determines the maximum buffer size.

//  stolen from osinternal\comm\test\security\sockauth\security.c
BOOL NTLMInitLib(PAUTH_NTLM pNTLMState)
{
    DEBUG_CODE_INIT;
    FARPROC pInit;
    SECURITY_STATUS ss;
    PSecPkgInfo pkgInfo;
    BOOL ret = FALSE;
    PSecurityFunctionTable pLocal = NULL;

    // load and initialize the ntlm ssp
    //

    if (g_pVars->m_pNTLMFuncs)
    {
        pNTLMState->m_Conversation  = NTLM_NO_INIT_CONTEXT;
        return TRUE;
    }

    g_pVars->m_hNTLMLib = LoadLibrary (NTLM_DLL_NAME);
    if (NULL == g_pVars->m_hNTLMLib)
        myleave(700);

    pInit = (FARPROC) GetProcAddress (g_pVars->m_hNTLMLib, SECURITY_ENTRYPOINT_CE);
    if (NULL == pInit)
        myleave(701);

    pLocal = (PSecurityFunctionTable) pInit ();
    if (NULL == pLocal)
        myleave(702);

    // Query for the package we're interested in
    //
    ss = pLocal->QuerySecurityPackageInfo (NTLM_PACKAGE_NAME, &pkgInfo);
    if (!SEC_SUCCESS(ss))
        myleave(703);

    g_pVars->m_cbNTLMMax = pkgInfo->cbMaxToken;
    pLocal->FreeContextBuffer (pkgInfo);


    //  The libraries have been set, but pNTLMState's structures are still empty
    pNTLMState->m_Conversation  = NTLM_NO_INIT_CONTEXT;

    TraceTag(ttidWebServer, "NTLM Libs successfully initialized");

    ret = TRUE;
    done:
    if (FALSE == ret)
    {
        // Don't worry about freeing pkgInfo, it was freed right after creation
        // anyway - no chance to go wrong
        MyFreeLib (g_pVars->m_hNTLMLib);

        // Set everything to false so httpd doesn't think we have legit data later.
        memset(pNTLMState, 0 , sizeof(AUTH_NTLM));
    }
    else
    {
        g_pVars->m_pNTLMFuncs = pLocal;     // Flag that shows we've initialized
    }

    TraceTag(ttidWebServer, "NTLMInitLib failed, err = %d, GLE = 0x%08x",err,
             GetLastError());
    return ret;
}


//  Unload the contexts.  The library is NOT freed in this call, only freed
//  in CHttpRequest destructor.
void FreeNTLMHandles(PAUTH_NTLM pNTLMState)
{
    if (NULL == pNTLMState || NULL == g_pVars->m_pNTLMFuncs)
        return;

    if (pNTLMState->m_fHaveCtxtHandle)
        g_pVars->m_pNTLMFuncs->DeleteSecurityContext (&pNTLMState->m_hctxt);

    if (pNTLMState->m_fHaveCredHandle)
        g_pVars->m_pNTLMFuncs->FreeCredentialHandle (&pNTLMState->m_hcred);

    pNTLMState->m_fHaveCredHandle = FALSE;
    pNTLMState->m_fHaveCtxtHandle = FALSE;
}




//  Given Basic authentication data, we try to "forge" and NTLM request
//  This fcn simulates a client+server talking to each other, though it's in the
//  same proc.  The client is "virtual," doesn't refer to the http client

//  pNTLMState is CHttpRequest::m_NTLMState


BOOL BasicToNTLM(PAUTH_NTLM pNTLMState, WCHAR * wszPassword, WCHAR * wszRemoteUser,
                 AUTHLEVEL *pAuth, WCHAR *wszVRootUserList)
{
    DEBUG_CODE_INIT;

    AUTH_NTLM  ClientState;         // forges the client role
    AUTH_NTLM  ServerState;         // forges the server role
    BOOL fDone = FALSE;
    PBYTE pClientOutBuf = NULL;
    PBYTE pServerOutBuf = NULL;
    DWORD cbServerBuf;
    DWORD cbClientBuf;

    DEBUGCHK(wszPassword != NULL && wszRemoteUser != NULL && pNTLMState != NULL);


    SEC_WINNT_AUTH_IDENTITY AuthIdentityClient = {
        (unsigned short *)wszRemoteUser, wcslen(wszRemoteUser),
        (unsigned short *)NTLM_DOMAIN,sizeof(NTLM_DOMAIN)/sizeof(TCHAR) - 1,
        (unsigned short *)wszPassword, wcslen(wszPassword),
        0};     // dummy domain needed

    memset(&ServerState,0,sizeof(AUTH_NTLM));
    memset(&ClientState,0,sizeof(AUTH_NTLM));


    // 1st pass through, load up library.
    if (NTLM_NO_INIT_LIB  == pNTLMState->m_Conversation)
    {
        if ( ! NTLMInitLib(pNTLMState))
            myleave(369);

        pNTLMState->m_Conversation = NTLM_NO_INIT_CONTEXT;
    }

    // NTLM auth functions seem to expect that these buffer will be zeroed.
    pClientOutBuf = MyRgAllocZ(BYTE,g_pVars->m_cbNTLMMax);
    if (NULL == pClientOutBuf)
        myleave(370);

    pServerOutBuf = MyRgAllocZ(BYTE,g_pVars->m_cbNTLMMax);
    if (NULL == pServerOutBuf)
        myleave(371);


    ServerState.m_Conversation = NTLM_NO_INIT_CONTEXT;
    ClientState.m_Conversation = NTLM_NO_INIT_CONTEXT;

    cbClientBuf = cbServerBuf = g_pVars->m_cbNTLMMax;

    //  Main loop that forges client and server talking.
    while (!fDone)
    {
        cbClientBuf = g_pVars->m_cbNTLMMax;
        if (! NTLMClientContext(&AuthIdentityClient,&ClientState,pServerOutBuf,
                                cbServerBuf, pClientOutBuf, &cbClientBuf))
        {
            myleave(372);
        }

        cbServerBuf = g_pVars->m_cbNTLMMax;
        if (! NTLMServerContext(&AuthIdentityClient,&ServerState, pClientOutBuf,
                                cbClientBuf, pServerOutBuf, &cbServerBuf, &fDone))
        {
            myleave(373);
        }
    }

    done:
    TraceTag(ttidWebServer, "Unable to convert Basic Auth to NTLM Auth, err = %d",err);

    if (fDone)
    {
        *pAuth = GetAuthFromACL(&ServerState,wszRemoteUser,wszVRootUserList);
    }

    MyFree(pClientOutBuf);
    MyFree(pServerOutBuf);

    FreeNTLMHandles(&ServerState);
    FreeNTLMHandles(&ClientState);

    return fDone;
}

//  This calls the DC (or goes to registry in local case), either getting a
//  data blob to return to client or granting auth or denying.

//  stolen from osinternal\comm\test\security\sockauth\security.c
BOOL NTLMServerContext(
                      PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,
                      PAUTH_NTLM pAS,     // NTLM state info
                      BYTE *pIn,
                      DWORD cbIn,
                      BYTE *pOut,
                      DWORD *pcbOut,
                      BOOL *pfDone)
{
    SECURITY_STATUS ss;
    TimeStamp       Lifetime;
    SecBufferDesc   OutBuffDesc;
    SecBuffer       OutSecBuff;
    SecBufferDesc   InBuffDesc;
    SecBuffer       InSecBuff;
    ULONG           ContextAttributes;


    if (NTLM_NO_INIT_CONTEXT == pAS->m_Conversation)
    {
        ss = g_pVars->m_pNTLMFuncs->AcquireCredentialsHandle (
                                                             NULL,   // principal
                                                             NTLM_PACKAGE_NAME,
                                                             SECPKG_CRED_INBOUND,
                                                             NULL,   // LOGON id
                                                             pAuthIdentity,
                                                             NULL,   // get key fn
                                                             NULL,   // get key arg
                                                             &pAS->m_hcred,
                                                             &Lifetime
                                                             );
        if (SEC_SUCCESS (ss))
            pAS->m_fHaveCredHandle = TRUE;
        else
        {
            TraceTag(ttidWebServer, "NTLM AcquireCreds failed: %X", ss);
            return(FALSE);
        }
    }

    // prepare output buffer
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers = 1;
    OutBuffDesc.pBuffers = &OutSecBuff;

    OutSecBuff.cbBuffer = *pcbOut;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer = pOut;

    // prepare input buffer
    //
    InBuffDesc.ulVersion = 0;
    InBuffDesc.cBuffers = 1;
    InBuffDesc.pBuffers = &InSecBuff;

    InSecBuff.cbBuffer = cbIn;
    InSecBuff.BufferType = SECBUFFER_TOKEN;
    InSecBuff.pvBuffer = pIn;

    ss = g_pVars->m_pNTLMFuncs->AcceptSecurityContext (
                                                      &pAS->m_hcred,
                                                      (pAS->m_Conversation == NTLM_PROCESSING) ?  &pAS->m_hctxt : NULL,
                                                      &InBuffDesc,
                                                      0,  // context requirements
                                                      SECURITY_NATIVE_DREP,
                                                      &pAS->m_hctxt,
                                                      &OutBuffDesc,
                                                      &ContextAttributes,
                                                      &Lifetime
                                                      );
    if (!SEC_SUCCESS (ss))
    {
        TraceTag(ttidWebServer, "NTLM init context failed: %X", ss);
        return FALSE;
    }

    pAS->m_fHaveCtxtHandle = TRUE;

    // Complete token -- if applicable
    //
    if ((SEC_I_COMPLETE_NEEDED == ss) || (SEC_I_COMPLETE_AND_CONTINUE == ss))
    {
        if (g_pVars->m_pNTLMFuncs->CompleteAuthToken)
        {
            ss = g_pVars->m_pNTLMFuncs->CompleteAuthToken (&pAS->m_hctxt, &OutBuffDesc);
            if (!SEC_SUCCESS(ss))
            {
                TraceTag(ttidWebServer, " NTLM complete failed: %X", ss);
                return FALSE;
            }
        }
        else
        {
            TraceTag(ttidWebServer, "Complete not supported.");
            return FALSE;
        }
    }

    *pcbOut = OutSecBuff.cbBuffer;
    pAS->m_Conversation = NTLM_PROCESSING;

    *pfDone = !((SEC_I_CONTINUE_NEEDED == ss) ||
                (SEC_I_COMPLETE_AND_CONTINUE == ss));

    return TRUE;
}


//  Forges the client browser's part in NTLM communication if the browser
//  sent a Basic request.  This is used primarily for Netscape clients, which only
//  supports Basic.

//  stolen from osinternal\comm\test\security\sockauth\security.c

BOOL NTLMClientContext(
                      PSEC_WINNT_AUTH_IDENTITY pAuthIdentity,
                      PAUTH_NTLM pAS,     // NTLM state info
                      BYTE *pIn,
                      DWORD cbIn,
                      BYTE *pOut,
                      DWORD *pcbOut)
{
    SECURITY_STATUS ss;
    TimeStamp       Lifetime;
    SecBufferDesc   OutBuffDesc;
    SecBuffer       OutSecBuff;
    SecBufferDesc   InBuffDesc;
    SecBuffer       InSecBuff;
    ULONG           ContextAttributes;

    if (NTLM_NO_INIT_CONTEXT == pAS->m_Conversation)
    {
        ss = g_pVars->m_pNTLMFuncs->AcquireCredentialsHandle (
                                                             NULL,   // principal
                                                             NTLM_PACKAGE_NAME,
                                                             SECPKG_CRED_OUTBOUND,
                                                             NULL,   // LOGON id
                                                             pAuthIdentity,  // auth data
                                                             NULL,   // get key fn
                                                             NULL,   // get key arg
                                                             &pAS->m_hcred,
                                                             &Lifetime
                                                             );
        if (SEC_SUCCESS (ss))
            pAS->m_fHaveCredHandle = TRUE;
        else
        {
            TraceTag(ttidWebServer, "AcquireCreds failed: %X", ss);
            return(FALSE);
        }
    }

    // prepare output buffer
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers = 1;
    OutBuffDesc.pBuffers = &OutSecBuff;

    OutSecBuff.cbBuffer = *pcbOut;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer = pOut;

    // prepare input buffer

    if (NTLM_NO_INIT_CONTEXT != pAS->m_Conversation)
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers = 1;
        InBuffDesc.pBuffers = &InSecBuff;

        InSecBuff.cbBuffer = cbIn;
        InSecBuff.BufferType = SECBUFFER_TOKEN;
        InSecBuff.pvBuffer = pIn;
    }

    ss = g_pVars->m_pNTLMFuncs->InitializeSecurityContext (
                                                          &pAS->m_hcred,
                                                          (pAS->m_Conversation == NTLM_PROCESSING) ? &pAS->m_hctxt : NULL,
                                                          NULL,
                                                          0,  // context requirements
                                                          0,  // reserved1
                                                          SECURITY_NATIVE_DREP,
                                                          (pAS->m_Conversation == NTLM_PROCESSING) ?  &InBuffDesc : NULL,
                                                          0,  // reserved2
                                                          &pAS->m_hctxt,
                                                          &OutBuffDesc,
                                                          &ContextAttributes,
                                                          &Lifetime
                                                          );
    if (!SEC_SUCCESS (ss))
    {
        TraceTag(ttidWebServer, "init context failed: %X", ss);
        return FALSE;
    }

    pAS->m_fHaveCtxtHandle = TRUE;

    // Complete token -- if applicable
    //
    if ((SEC_I_COMPLETE_NEEDED == ss) || (SEC_I_COMPLETE_AND_CONTINUE == ss))
    {
        if (g_pVars->m_pNTLMFuncs->CompleteAuthToken)
        {
            ss = g_pVars->m_pNTLMFuncs->CompleteAuthToken (&pAS->m_hctxt, &OutBuffDesc);
            if (!SEC_SUCCESS(ss))
            {
                TraceTag(ttidWebServer, "complete failed: %X", ss);
                return FALSE;
            }
        }
        else
        {
            TraceTag(ttidWebServer, "Complete not supported.");
            return FALSE;
        }
    }

    *pcbOut = OutSecBuff.cbBuffer;
    pAS->m_Conversation = NTLM_PROCESSING;

    return TRUE;
}
#endif // OLD_CE_BUILD


// Called after a user has been successfully authenticated with either BASIC or NTLM.
// See \winceos\comm\security\authhlp to see ACL algorithm function/description.

// Our algorithm: AdminUsers reg value is set and user is a member, always grant
// Admin auth.  If no AdminUser key is set always grant Admin auth level,
// UNLESS this vroot has a UserList set.  If user is a member, then grant
// ADMIN_USER, otherwise set to AUTH_PUBLIC (no auth).
// If user is not in admin list but in UserList for vroot, grant AUTH_USER.

AUTHLEVEL GetAuthFromACL(PAUTH_NTLM pAuth, PWSTR wszUser, PWSTR wszVRootUserList)
{
    AUTHLEVEL AuthGranted = AUTH_USER;
    PWSTR wsz = NULL;       // User (in function)
    PWSTR wszGroup = NULL;
    SecPkgContext_Names pkgName;

#if defined(UNDER_CE) && !defined (OLD_CE_BUILD)
    SecPkgContext_GroupNames ContextGroups;
    ContextGroups.msGroupNames = NULL;
#endif

    pkgName.sUserName = NULL;


    // If we're called from NTLM request (pAuth != NULL) then we need
    // to get the user name if we don't have it.  On BASIC request, we
    // have wszUser name already.
    if (pAuth && !wszUser)
    {
        if ( SEC_SUCCESS(g_pVars->m_pNTLMFuncs->QueryContextAttributes(&(pAuth->m_hctxt),
                                                                       SECPKG_ATTR_NAMES, &pkgName)))
        {
            wsz = pkgName.sUserName;
        }
        else
            goto done;  // If we can't get user name, don't bother continuing
    }
    else
    {
        wsz = wszUser;
    }


#if defined(UNDER_CE) && !defined (OLD_CE_BUILD)
    if (pAuth)
        g_pVars->m_pNTLMFuncs->QueryContextAttributes(&(pAuth->m_hctxt),SECPKG_ATTR_GROUP_NAMES,&ContextGroups);

    wszGroup = ContextGroups.msGroupNames;
#endif


    TraceTag(ttidWebServer, "ADmin Users = %s, wsz = %s, pkgName.sUserName = %s, group name = %s\r\n",
                           g_pVars->m_wszAdminUsers,wsz,pkgName.sUserName,wszGroup);

    // Administrators always get admin access and access to the page, even if
    // they're barred in the VRoot list.  If there is a vroot list and we fail
    // the IsAccessAllowed test, we set the auth granted to 0 - this
    // will deny access.  If no VRoot user list is set, keep us at AUTH_USER.

    if ( !g_pVars->m_wszAdminUsers && !wszVRootUserList)
        AuthGranted = AUTH_ADMIN;
    else if (g_pVars->m_wszAdminUsers && IsAccessAllowed(wsz,wszGroup,g_pVars->m_wszAdminUsers,FALSE))
        AuthGranted = AUTH_ADMIN;
    else if (wszVRootUserList && IsAccessAllowed(wsz,wszGroup,wszVRootUserList,FALSE))
    {
        // If there is no Admin list set, grant admin
        if (!g_pVars->m_wszAdminUsers)
            AuthGranted = AUTH_ADMIN;
        else
            AuthGranted = AUTH_USER;
    }
    else if (wszVRootUserList)
        AuthGranted = AUTH_PUBLIC;

    done:
    if (pkgName.sUserName)
        g_pVars->m_pNTLMFuncs->FreeContextBuffer(pkgName.sUserName);

#if defined(UNDER_CE) && !defined (OLD_CE_BUILD)
    if (ContextGroups.msGroupNames)
        g_pVars->m_pNTLMFuncs->FreeContextBuffer(ContextGroups.msGroupNames);
#endif

    TraceTag(ttidWebServer, "HTTPD: GetAuthFromACL Admin Priveleges granted = %d",AuthGranted);
    return AuthGranted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\isapi.cpp ===
/*--
Copyright (c) 1999-2000 Microsoft Corporation.  All rights reserved.
Module Name: ISAPI.CPP
Abstract: ISAPI handling code
--*/

#include "pch.h"
#pragma hdrstop

#include "httpd.h"


// Prefix for GetServerVariable for generic HTTP header retrieval, so "HTTPD_FOOBAR" gets HTTP header FOOBAR.
static const char cszHTTP[] = "HTTP_";
static const DWORD dwHTTP   = CONSTSIZEOF(cszHTTP);


// This function is used when looking through HTTP headers for HTTP_VARIABLE.  We
// can't use strcmp because headers (for most part) have words separated by "-",
// the pszVar format has vars separated by "_".  IE pszVar=HTTP_ACCEPT_LANGUAGE
// should return for us HTTP header "ACCEPT-LANGUAGE"
BOOL GetVariableStrCmp(PSTR pszHeader, PSTR pszVar, DWORD_PTR dwLen)
{
    BOOL fRet = FALSE;

    for (DWORD i = 0; i < dwLen; i++)
    {
        if ( (tolower(*pszHeader) != tolower(*pszVar)) &&
             (*pszVar != '_' && *pszHeader != '-'))
        {
            goto done;
        }
        pszHeader++;
        pszVar++;
    }
    fRet = (*pszHeader == ':');

    done:
    return fRet;
}

BOOL CHttpRequest::GetServerVariable(PSTR pszVar, PVOID pvOutBuf, PDWORD pdwOutSize, BOOL fFromFilter)
{
    DWORD dwLen;
    char szBuf[MAXHEADERS];
    PSTR pszRet = (PSTR)-1;
    PSTR pszTrav = NULL;
    CHAR chSave;

    if (0==_stricmp(pszVar, "APPL_MD_PATH"))
        pszRet = "/LM/W3SVC/1/ROOT/";
    else if (0==_stricmp(pszVar, "APPL_PHYSICAL_PATH"))
    {
        strcpy (szBuf, "/");
        dwLen = sizeof(szBuf);

        if (MapURLToPath (szBuf, &dwLen))
            pszRet = szBuf;
    }
    else if (0==_stricmp(pszVar, "SERVER_PORT"))
    {
        _itoa (g_pVars->m_dwListenPort, szBuf, 10);
        pszRet = szBuf;
    }
    else if (0==_stricmp(pszVar, "AUTH_TYPE"))
        pszRet = m_pszAuthType;
    else if (0 == _stricmp(pszVar, "AUTH_USER"))
        pszRet = m_pszRemoteUser;
    else if (0 == _stricmp(pszVar, "AUTH_PASSWORD"))
        pszRet = m_pszPassword;
    else if (0==_stricmp(pszVar, "CONTENT_LENGTH"))
    {
        sprintf(szBuf, "%d", m_dwContentLength);
        pszRet = szBuf;
    }
    else if (0==_stricmp(pszVar, "CONTENT_TYPE"))
        pszRet = m_pszContentType;
    else if (0==_stricmp(pszVar, "PATH_INFO"))
        pszRet = m_pszPathInfo;
    else if (0==_stricmp(pszVar, "PATH_TRANSLATED"))
        pszRet = m_pszPathTranslated;
    else if (0==_stricmp(pszVar, "QUERY_STRING"))
        pszRet = m_pszQueryString;
    else if (0==_stricmp(pszVar, "REMOTE_ADDR") || 0==_stricmp(pszVar, "REMOTE_HOST"))
    {
        GetRemoteAddress(m_socket, szBuf);
        pszRet = szBuf;
    }
    // Note: The following is a non-standard ISAPI variable
    //
    else if (0==_stricmp(pszVar, "LOCAL_ADDR"))
    {
        GetLocalAddress(m_socket, szBuf);
        pszRet = szBuf;
    }
    // ----End note
    else if (0==_stricmp(pszVar, "REMOTE_USER"))
        pszRet = m_pszRemoteUser;
    else if (0==_stricmp(pszVar, "UNMAPPED_REMOTE_USER"))
        pszRet = m_pszRemoteUser; /*m_pszRawRemoteUser; BUBUG: what is rawremoteuser?*/
    else if (0==_stricmp(pszVar, "REQUEST_METHOD"))
        pszRet = m_pszMethod;
    else if (0==_stricmp(pszVar, "URL"))
    {
        pszRet = m_pszURL;
    }
    else if (0==_stricmp(pszVar, "SCRIPT_NAME"))
    {
        if (fFromFilter)
            pszRet = NULL;
        else
            pszRet = m_pszURL;
    }
    else if (0==_stricmp(pszVar, "SERVER_NAME"))
    {
        if (0 != gethostname(szBuf, sizeof(szBuf)))
            szBuf[0] = '\0';

        pszRet = szBuf;
    }

    // HTTP_VERSION is version info as received from the client
    else if (0==_stricmp(pszVar, "HTTP_VERSION"))
    {
        sprintf(szBuf, cszHTTPVER, HIWORD(m_dwVersion), LOWORD(m_dwVersion));
        pszRet = szBuf;
    }

    // SERVER_PROTOCOL is the version of http server supports, currently 1.0
    else if (0==_stricmp(pszVar, "SERVER_PROTOCOL"))
    {
        strcpy(szBuf,"HTTP/1.1");
        pszRet = szBuf;
    }
    else if (0==_stricmp(pszVar, "SERVER_SOFTWARE"))
        pszRet = (PSTR)g_pVars->m_pszServerID;
    else if (0==_stricmp(pszVar, "ALL_HTTP"))
        pszRet = 0;

    // ALL_RAW return http headers, other than the simple request line.  (fixes BUG 11991)
    // The way our buffer is set up, we can have POST data immediatly following
    // header data.  So the client doesn't get confused, we have to set a \0 to it.
    else if (0 == _stricmp(pszVar, "ALL_RAW"))
    {
        pszRet = m_bufRequest.Headers();
        // skip past simple request line.
        pszRet = strstr(pszRet,"\r\n");
        pszRet += 2;

        // If there's unaccessed data, buffer has POST data in it
        if (m_bufRequest.HasPostData())
        {
            pszTrav = strstr(pszRet,("\r\n\r\n")) + 4;
            chSave = *pszTrav; *pszTrav = 0;
        }
    }
    else if (0==_stricmp(pszVar, "HTTP_ACCEPT"))
        pszRet = m_pszAccept;
    else if (0==_strnicmp(pszVar,cszHTTP,dwHTTP))
    {
        PSTR  pszStart = pszVar + dwHTTP;
        PSTR  pszEnd   = strchr(pszStart,'\0');
        DWORD_PTR dwLen    = pszEnd - pszStart;
        if (dwLen > 1)
        {
            DWORD dwOutLen = 0;
            PSTR pszHeader = m_bufRequest.Headers();
            do
            {
                if (GetVariableStrCmp(pszHeader,pszStart,dwLen))
                {
                    pszHeader += dwLen+1;  // skip past header + ':'
                    while ( (pszHeader)[0] != '\0' && ((pszHeader[0] == ' ') ||
                                                       (pszHeader[0] == '\t')))
                    {
                        ++(pszHeader);
                    }

                    pszTrav = strstr(pszHeader,"\r\n");
                    if (pszTrav)
                    {
                        chSave = '\r';
                        *pszTrav = 0;
                        pszRet = pszHeader;
                    }
                    break;
                }

                pszHeader = strstr(pszHeader,"\r\n")+2;
                if (*pszHeader == '\r')
                {
                    DEBUGCHK(*(pszHeader+1) == '\n');
                    break;
                }
            } while (1);
        }
    }

// end of pseudo-case stmnt
    if ((PSTR)(-1) == pszRet)
    {
        // unknown var
        SetLastError(ERROR_INVALID_INDEX);
        return FALSE;
    }
    // no such header/value. return empty (not NULL!) string
    if (!pszRet)
        pszRet = (PSTR)cszEmpty;

    if ((dwLen = strlen(pszRet)+1) > *pdwOutSize)
    {
        *pdwOutSize = dwLen;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        if (pszTrav)
            *pszTrav = chSave;
        return FALSE;
    }
    // Change: Check is done here, not in ::GetServerVariable.  Lets us get size
    // with out buf = NULL
    if (NULL == pvOutBuf)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    memcpy(pvOutBuf, pszRet, dwLen);
    if (pszTrav)
        *pszTrav = chSave;
    return TRUE;
}

BOOL CHttpRequest::WriteClientAsync(PVOID pvBuf, PDWORD pdwSize, BOOL fFromFilter)
{
    BOOL ret = WriteClient(pvBuf, pdwSize, fFromFilter);

    if (m_pfnCompletion != NULL)
    {
        DWORD dwStatus;

        if (ret)
            dwStatus = ERROR_SUCCESS;
        else
            dwStatus = GetLastError();

        __try
        {
            (*m_pfnCompletion)(m_pECB, m_pvContext, *pdwSize, dwStatus);
        }
        __except(1) // catch all errors
        {
            TraceTag(ttidWebServer, "ISAPI I/O completion callback caused exception 0x%08x and was terminated", GetExceptionCode());
            g_pVars->m_pLog->WriteEvent(IDS_HTTPD_EXT_EXCEPTION,m_wszPath,GetExceptionCode(),L"IOCompletionProc",GetLastError());
        }
    }

    return ret;
}

BOOL CHttpRequest::WriteClient(PVOID pvBuf, PDWORD pdwSize, BOOL fFromFilter)
{
    int cbSendBuf = *pdwSize;
    PSTR pszSendBuf = (PSTR) pvBuf;
    BOOL ret = FALSE;

    // On a HEAD request to an ASP page or ISAPI extension results in no data
    // being sent back, however for filters we do send data back when they
    // tell us to with WriteClient call.
    if (m_idMethod == TOK_HEAD && !fFromFilter)
    {
        ret = TRUE;
        goto done;
    }

    // are we buffering?  Note:  Only ASP can set this
    if (m_fBufferedResponse)
    {
        return m_bufRespBody.AppendData((PSTR) pvBuf, (int) *pdwSize);
    }

    if (g_pVars->m_fFilters &&
        ! CallFilter(SF_NOTIFY_SEND_RAW_DATA, &pszSendBuf, &cbSendBuf))
        goto done;

    if (cbSendBuf != send(m_socket, pszSendBuf, cbSendBuf, 0))
    {
        TraceTag(ttidWebServer, "HTTPD: SendBuffer FAILED. GLE=%d", GetLastError());
        goto done;
    }

    ret = TRUE;
    done:
    return ret;
}


//  Acts as the custom header class (for Filters call to AddHeader, SetHeader
//  and for ASP Call to AddHeader and for ASP Cookie handler.

//  We made this function part of the class because there's no reason to memcpy
//  data into a temp buffer before memcpy'ing it into the real buffer.

BOOL CBuffer::AddHeader(PSTR pszName, PSTR pszValue, BOOL fAddColon)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    PSTR pszTrav;

    if (!pszName || !pszValue)
    {
        DEBUGCHK(0);
        return FALSE;
    }

    int cbName  = strlen(pszName);
    int cbValue = strlen(pszValue);

    //  we need a buffer size of pszName + pszValue, a space, a trailing \r\n, and \0
    int cbTotal = cbName + cbValue + sizeof("\r\n") + (fAddColon ? 1 : 0);

    if ( ! AllocMem( cbTotal ))
        myleave(900);

    pszTrav = m_pszBuf + m_iNextIn;
    memcpy(pszTrav, pszName, cbName);
    pszTrav += cbName;

    // put space between name and value and colon if needed.
    if (fAddColon)
        *pszTrav++ = ':';

    *pszTrav++ = ' ';

    memcpy(pszTrav, pszValue, cbValue);
    memcpy(pszTrav + cbValue,"\r\n", sizeof("\r\n"));

    m_iNextIn += cbTotal;
    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "HTTPD: CBuffer::AddHeader failed, err = %d",err);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\svsutil.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    svsutil.cxx

Abstract:

    Miscellaneous useful utilities

Author:

    Sergey Solyanik (SergeyS)

--*/
#include "pch.h"
#pragma hdrstop


#include <svsutil.hxx>

//
//  Assert and debug sector
//
static int svsutil_DebugOut (void *pvPtr, TCHAR *lpszFormat, ...) {
    va_list lArgs;
    va_start (lArgs, lpszFormat);

#if defined (UNDER_CE)
    TCHAR szBuffer[128];
    int iRet = wvsprintf (szBuffer, lpszFormat, lArgs);
    OutputDebugString (szBuffer);
#else
    int iRet = vwprintf (lpszFormat, lArgs);
#endif

    va_end(lArgs);

    return iRet;
}

FuncDebugOut    g_funcDebugOut = svsutil_DebugOut;
void            *g_pvDebugData = NULL;

int svsutil_AssertBroken (TCHAR *lpszFileName, int iLine) {
    g_funcDebugOut (g_pvDebugData, TEXT("Assert broken in %s line %d\n"), lpszFileName, iLine);
    DebugBreak ();

    return TRUE;
}

wchar_t *svsutil_wcsdup (wchar_t *lpwszString) {
    int iSz = (wcslen (lpwszString) + 1) * sizeof(wchar_t);

    wchar_t *lpwszDup = (wchar_t *)g_funcAlloc (iSz, g_pvAllocData);

    if (! lpwszDup)
    {
        SVSUTIL_ASSERT (0);
        return NULL;
    }

    memcpy (lpwszDup, lpwszString, iSz);

    return lpwszDup;
}

char *svsutil_strdup (char *lpszString) {
    int iSz = strlen (lpszString) + 1;

    char *lpszDup = (char *)g_funcAlloc (iSz, g_pvAllocData);

    if (! lpszDup)
    {
        SVSUTIL_ASSERT (0);
        return NULL;
    }

    memcpy (lpszDup, lpszString, iSz);

    return lpszDup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\utilmem.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utilmem.cxx

Abstract:

    Miscellaneous useful utilities

Author:

    Sergey Solyanik (SergeyS)

--*/

#include "pch.h"
#pragma hdrstop


#include <svsutil.hxx>
//
//  Allocation sector
//
FuncAlloc   g_funcAlloc    = svsutil_Alloc;
FuncFree    g_funcFree     = svsutil_Free;

void        *g_pvAllocData = NULL;
void        *g_pvFreeData  = NULL;

#if (defined (_WINDOWS_) || defined (_WINDOWS_CE_)) && defined (SVSUTIL_DEBUG_HEAP)
class MemAllocChunk
{
public:
    unsigned int    uiSignature1;
    unsigned int    uiSignature2;
    unsigned int    uiSize;
    unsigned int    uiCalledFrom;
    MemAllocChunk   *pPrev;
    MemAllocChunk   *pNext;
    unsigned char   data[8];
};

static CRITICAL_SECTION csGlobalAlloc;
static unsigned int     uiMemAllocated = 0;
static MemAllocChunk    *pAllocBlocks = NULL;

#endif

void svsutil_Initialize (void) {
#if (defined (_WINDOWS_) || defined (_WINDOWS_CE_)) && defined (SVSUTIL_DEBUG_HEAP)
    InitializeCriticalSection (&csGlobalAlloc);
#endif
}

unsigned int svsutil_TotalAlloc (void) {
#if (defined (_WINDOWS_) || defined (_WINDOWS_CE_)) && defined (SVSUTIL_DEBUG_HEAP)
    return uiMemAllocated;
#else
    return 0;
#endif
}

void *svsutil_Alloc (int iSize, void *pvData) {
    SVSUTIL_ASSERT (iSize > 0);
    SVSUTIL_ASSERT (pvData == g_pvAllocData);

#if (defined (_WINDOWS_) || defined (_WINDOWS_CE_)) && defined (SVSUTIL_DEBUG_HEAP)
    int iTotalSize = iSize + offsetof (MemAllocChunk, data);
    MemAllocChunk *pAlloc = (MemAllocChunk *)malloc(iTotalSize); //(unsigned int *)LocalAlloc (LMEM_FIXED, iSize + 8);

    if (! pAlloc)
    {
        SVSUTIL_ASSERT (0);
        return NULL;
    }

    unsigned int __RetAddr = 0;

#if defined (_X86_)
    __asm {
        mov eax, [ebp+4]
        mov __RetAddr, eax
    };
#endif

    pAlloc->uiSignature1 = 'SVSA';
    pAlloc->uiSignature2 = 'LLOC';
    pAlloc->uiSize       = (unsigned int)iSize;
    pAlloc->uiCalledFrom = __RetAddr;
    pAlloc->pPrev        = NULL;

    EnterCriticalSection (&csGlobalAlloc);
    if (pAllocBlocks)
        pAllocBlocks->pPrev = pAlloc;

    pAlloc->pNext        = pAllocBlocks;
    pAllocBlocks         = pAlloc;
    uiMemAllocated       += iSize;
    LeaveCriticalSection (&csGlobalAlloc);

    return(void *)pAlloc->data;
#else
    return  malloc (iSize); // LocalAlloc (LMEM_FIXED, iSize);
#endif
}

void svsutil_Free (void *pvPtr, void *pvData) {
    SVSUTIL_ASSERT (pvPtr);
    SVSUTIL_ASSERT (pvData == g_pvFreeData);

#if (defined (_WINDOWS_) || defined (_WINDOWS_CE_)) && defined (SVSUTIL_DEBUG_HEAP)
    MemAllocChunk   *pAlloc = (MemAllocChunk *)((unsigned char *)pvPtr - offsetof(MemAllocChunk, data));

    SVSUTIL_ASSERT (pAlloc->uiSignature1 == 'SVSA');
    SVSUTIL_ASSERT (pAlloc->uiSignature2 == 'LLOC');
    EnterCriticalSection (&csGlobalAlloc);
    if (! pAlloc->pPrev)
    {
        SVSUTIL_ASSERT (pAlloc == pAllocBlocks);
        pAllocBlocks = pAlloc->pNext;
        if (pAllocBlocks)
            pAllocBlocks->pPrev = NULL;
    }
    else
    {
        SVSUTIL_ASSERT (pAlloc != pAllocBlocks);
        pAlloc->pPrev->pNext = pAlloc->pNext;
        if (pAlloc->pNext)
            pAlloc->pNext->pPrev = pAlloc->pPrev;
    }

    unsigned int __RetAddr = 0;

#if defined (_X86_)
    __asm {
        mov eax, [ebp+4]
        mov __RetAddr, eax
    };
#endif

    uiMemAllocated -= pAlloc->uiSize;
    LeaveCriticalSection (&csGlobalAlloc);
    pAlloc->pNext = NULL;
    pAlloc->pPrev = NULL;
    pAlloc->uiSignature1 = 0;
    pAlloc->uiSignature2 = 0;
    pAlloc->uiCalledFrom = __RetAddr;

    pvPtr = (void *)pAlloc;
#endif


//  HLOCAL hres = LocalFree (pvPtr);
//  SVSUTIL_ASSERT (! hres);
    free (pvPtr);
}

void svsutil_SetAlloc (FuncAlloc a_funcAlloc, FuncFree a_funcFree) {
    g_funcAlloc = a_funcAlloc ? a_funcAlloc : svsutil_Alloc;
    g_funcFree  = a_funcFree  ? a_funcFree  : svsutil_Free;
}

void svsutil_SetAllocData (void *a_pvAllocData, void *a_pvFreeData) {
    g_pvAllocData = a_pvAllocData;
    g_pvFreeData  = a_pvFreeData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\request.cpp ===
/*--
Copyright (c) 1995-2000    Microsoft Corporation.  All Rights Reserved.
Module Name: request.CPP
Abstract: per-Connection thread
--*/

#include "pch.h"
#pragma hdrstop

#include "httpd.h"


BOOL IsLocalFile(PWSTR wszFile);


void CHttpRequest::HandleRequest()
{
    int err = 1;
    RESPONSESTATUS ret = STATUS_BADREQ;
    DWORD dwLength = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwAttrib;
    HRINPUT hi;
    BOOL fSendDirectoryList = FALSE;

    m_rs = STATUS_OK;

    TraceTag(ttidWebServer, "HandleRequest: entry.  Current Authorization Level = %d",m_AuthLevelGranted);

    hi = m_bufRequest.RecvHeaders(m_socket);

    // Even if we get an error, continue processing, because we may have read in
    // binary data and have a filter installed that can convert it for us.
    if (hi == INPUT_TIMEOUT)
    {
        // Either we have no data, or there's no filter to read in data, return
        if (!g_pVars->m_fFilters || m_bufRequest.Count() == 0)
        {
            m_fKeepAlive = FALSE;
            return;  // don't send any data across socket, just close it.
        }
    }
    if (hi == INPUT_ERROR)
    {
        if (!g_pVars->m_fFilters || m_bufRequest.Count() == 0)
        {
            m_fKeepAlive = FALSE;
            myretleave(m_rs = STATUS_BADREQ,61);
        }
    }

    if (g_pVars->m_fFilters &&
        ! CallFilter(SF_NOTIFY_READ_RAW_DATA))
        myleave(231);

// parse the request headers
    if (!ParseHeaders())
        myleave(50);

//  There were numerous filter calls in ParseHeaders, make sure none requested end of connection
    if (m_pFInfo && m_pFInfo->m_fFAccept==FALSE)
        myleave(63);  // don't change m_rs, filter set it as appropriate

    if (m_dwVersion >= MAKELONG(0, 2))
        myretleave(m_rs = STATUS_NOTSUPP, 111);

// read body of request, if any
    if (!ReadPostData(g_pVars->m_dwPostReadSize,TRUE))
        myleave(233);

//  if we're in middle of authenticating, jump past other stuff to end
    if (m_NTLMState.m_Conversation == NTLM_PROCESSING)
        myretleave(m_rs = STATUS_UNAUTHORIZED, 65);

// check if we successfully mapped the VRoot
    if (!m_wszPath)
        myretleave(m_rs = STATUS_NOTFOUND, 59);

    if (m_wszExt && wcsstr(m_wszExt, L"::"))
    {
        // infamous ::$DATA bug. Don't allow extensions with :: in them

        myretleave(m_rs = STATUS_NOTFOUND, 74);
    }

    if ( !CheckAuth())
    {
        if (g_pVars->m_fFilters)
            CallFilter(SF_NOTIFY_ACCESS_DENIED);
        myretleave(m_rs = STATUS_UNAUTHORIZED, 52);
    }

    if ((-1) == (dwAttrib = GetFileAttributes(m_wszPath)))
        myretleave(m_rs = GLEtoStatus(GetLastError()), 60);

    if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
    {
        // if it doesn't end in '/' send a redirect
        int iLen = strlen(m_pszURL);
        if (m_pszURL[iLen-1]!='/' && m_pszURL[iLen-1]!='\\')
        {
            // SPECIAL HACK: we have allocated one extra char in m_pszURL already in case
            // we needed to send a redirect back (see parser.cpp)
            m_pszURL[iLen]='/';
            m_pszURL[iLen+1]=0;

            CHttpResponse resp(m_socket, STATUS_MOVED, GetConnHeader(), this);
            m_rs = STATUS_MOVED;
            resp.SendRedirect(m_pszURL); // send a special redirect body
            m_pszURL[iLen]=0; // restore m_pszURL
            err = 0;
            goto done;
        }
        // If there's no default page then we send dir list (later, after some
        // extra checking).  If there is a default page match m_wszPath is
        // updated appropriatly.  This must be done before script processing.
        fSendDirectoryList = !MapDirToDefaultPage();
    }

        // Set the socket to be a blocking one 
        // Our web server implementaion for send and recv assumes it to be a blocking socket
        // This is only a temp fix...

     int nErrorVal = 0;
     u_long ulSockBlock = 0;
     if((nErrorVal = WSAEventSelect(m_socket, NULL, 0)) == SOCKET_ERROR)
     {
        TraceTag(ttidWebServer, "Disabling non blocking sock WSAEventSelect() failed - %d ",WSAGetLastError());         
     }
     if(nErrorVal == 0 ) 
     {
        TraceTag(ttidWebServer, "Disabled non blocking sock WSAEventSelect() Succeeded");     
        if ((nErrorVal = ioctlsocket(m_socket, FIONBIO, &ulSockBlock)) == SOCKET_ERROR)
        {   
            TraceTag(ttidWebServer, "ioctlsocket() - Setting the blocking socket failed - %d ",WSAGetLastError());           
        }
        else
        {
            TraceTag(ttidWebServer, "ioctlsocket() - Setting the blocking socket Succeeded");
        }
    }
        // Attempt to send even if its non blocking socket ;;; must be changed later !!

    // HandleScript returns true if page maps to ASP or ISAPI DLL, regardless of whether
    // we have correct permissions, component was included, there was an error, etc.
    // HandleScript sets its own errors.

    if ( !fSendDirectoryList && HandleScript() )
    {
        err = (m_rs != STATUS_OK);      // Only send message on internal error.
        goto done;
    }

// if it's not an ISAPI or ASP, we cant handle anything but GET and HEAD
    if (m_idMethod == TOK_UNKNOWN_VERB)
        myretleave(m_rs = STATUS_NOTIMPLEM, 54);


// check permissions
    if (!(m_dwPermissions & HSE_URL_FLAGS_READ))
    {
        if (g_pVars->m_fFilters)
            CallFilter(SF_NOTIFY_ACCESS_DENIED);
        myretleave(m_rs = STATUS_FORBIDDEN, 55);
    }

    if (fSendDirectoryList)
    {
        // In this case there's no default page but directory browsing is turned
        // off.  Return same error code IIS does.
        if (FALSE == g_pVars->m_fDirBrowse)
        {
            if (g_pVars->m_fFilters)
                CallFilter(SF_NOTIFY_ACCESS_DENIED);
            myretleave(m_rs = STATUS_FORBIDDEN,78);
        }

        if (!EmitDirListing())
            myretleave(m_rs = STATUS_INTERNALERR, 53);
        err=0;
        goto done;
    }

// If we get to here then we're just sending a plain old static file.
// try to open the file & get the length
    if (INVALID_HANDLE_VALUE == (hFile = MyOpenReadFile(m_wszPath)))
        myretleave(m_rs = GLEtoStatus(GetLastError()), 56);

// get the size
    if (((DWORD)-1) == (dwLength = GetFileSize(hFile, 0)))
        myretleave(m_rs = GLEtoStatus(GetLastError()), 57);

// if it's a GET check if-modified-since
    if ((m_idMethod==TOK_GET) && IsNotModified(hFile, dwLength))
        myretleave(m_rs = STATUS_NOTMODIFIED, 58);

// if it's a HTTP/0.9 request, just send back the body. NO headers
    if (m_dwVersion <= MAKELONG(9, 0))
    {
        TraceTag(ttidWebServer, "Sending HTTP/0.9 response with NO headers");
        SendFile(m_socket, hFile, this);
    }
    else
    {
// create a response object & send response
// if it's a head request, skip the actual body

        CHttpResponse resp(m_socket, STATUS_OK, GetConnHeader(),this);
        m_rs = STATUS_OK;
        resp.SetBody(((m_idMethod==TOK_HEAD) ? NULL : hFile), m_wszExt, dwLength);
        resp.SendResponse();
    }
    TraceTag(ttidWebServer, "HTTP Request SUCCEEDED");

    err  = 0;
    ret = m_rs = STATUS_OK;
    done:
    MyCloseHandle(hFile);

    if (err)
    {
        // end this session ASAP if we've encountered an error.
        if (m_rs == STATUS_INTERNALERR)
        {
            m_fKeepAlive = FALSE;
        }

        // if there's been an error but we're doing keep-alives, it's possible
        // there's POST data we haven't read in.  We need to read this
        // before sending response, or next time we recv() HTTP headers we'll
        // start in middle of POST rather than in the new request.
        if (m_fKeepAlive)
        {
            DEBUGCHK(m_dwContentLength >= m_bufRequest.Count());
            TraceTag(ttidWebServer, "HTTP: HandleRequest: Error occured on keepalive, reading %d POST bytes now",m_dwContentLength - m_bufRequest.Count());
            ReadPostData(m_dwContentLength - m_bufRequest.Count(),FALSE);
        }

        CHttpResponse resp(m_socket, m_rs, GetConnHeader(),this);
        resp.SetDefaultBody();
        resp.SendResponse();
        TraceTag(ttidWebServer, "HTTP Request FAILED: GLE=%d err=%d status=%d (%d, %s)",GetLastError(), err, ret, rgStatus[ret].dwStatusNumber, rgStatus[ret].pszStatusText);
    }

    // if in middle of NTLM request, don't do this stuff
    if (m_NTLMState.m_fHaveCtxtHandle != NTLM_PROCESSING)
    {
        if (g_pVars->m_fFilters)
        {
            CallFilter(SF_NOTIFY_END_OF_REQUEST);
            CallFilter(SF_NOTIFY_LOG);
        }
        g_pVars->m_pLog->WriteLog(this);
    }

    return;
}

BOOL CHttpRequest::IsNotModified(HANDLE hFile, DWORD dwLength)
{
    if (m_ftIfModifiedSince.dwLowDateTime || m_ftIfModifiedSince.dwHighDateTime)
    {
        FILETIME ftModified;
        int iTemp;
        if (!GetFileTime(hFile, NULL, NULL, &ftModified))
        {
            TraceTag(ttidWebServer, "GetFileTime(%08x) failed", hFile);
            return FALSE; // assume it is modified
        }
        iTemp = CompareFileTime(&m_ftIfModifiedSince, &ftModified);

        TraceTag(ttidWebServer, "IfModFT=%08x:%08x  ModFT=%08x:%08x "
                 "IfModLen=%d Len=%d Compare=%d",
                 m_ftIfModifiedSince.dwHighDateTime,
                 m_ftIfModifiedSince.dwLowDateTime ,
                 ftModified.dwHighDateTime,
                 ftModified.dwLowDateTime,
                 m_dwIfModifiedLength, dwLength, iTemp);

        if ((iTemp >= 0) && (m_dwIfModifiedLength==0 || (dwLength==m_dwIfModifiedLength)))
            return TRUE; // not modified
    }
    return FALSE; // assume modified
}

RESPONSESTATUS CHttpRequest::GLEtoStatus(int iGLE)
{
    switch (iGLE)
    {
        case ERROR_PATH_NOT_FOUND:
        case ERROR_FILE_NOT_FOUND:
        case ERROR_INVALID_NAME:
            return STATUS_NOTFOUND;
        case ERROR_ACCESS_DENIED:
            return STATUS_FORBIDDEN;
        default:
            return STATUS_INTERNALERR;
    }
}

BOOL CHttpRequest::MapDirToDefaultPage(void)
{
    WCHAR wszTemp[MAX_PATH];

    // make temp copy of dir path. append \ if reqd
    wcscpy(wszTemp, m_wszPath);
    int iLen = wcslen(wszTemp);
    // if we get here we have a trailing \ or / (otherwise we sent a redirect instead)
    DEBUGCHK(wszTemp[iLen-1]=='/' || wszTemp[iLen-1]=='\\');

    if (!g_pVars->m_wszDefaultPages)
        return FALSE;

    for (PWSTR wszNext=g_pVars->m_wszDefaultPages; *wszNext; wszNext+=(1+wcslen(wszNext)))
    {
        wcscpy(wszTemp+iLen, wszNext);
        if ((-1) != GetFileAttributes(wszTemp))
        {
            PWSTR pwsz;
            // found something
            TraceTag(ttidWebServer, "Converting dir path (%s) to default page(%s)", m_wszPath, wszTemp);
            MyFree(m_wszPath);
            m_wszPath = MySzDupW(wszTemp);

            MyFree(m_wszExt);
            if (pwsz = wcsrchr(m_wszPath, '.'))
                m_wszExt = MySzDupW(pwsz);

            return TRUE;
        }
    }
    TraceTag(ttidWebServer, "No default page found in dir path (%s)", m_wszPath);
    return FALSE;
}

// const char cszDirHeader1[] = "<head><title>%s - %s</title></head><body><H1>%s - %s</H1><hr>";
// const char cszDirHeader2[] = "<pre><A HREF=\"%s\">%S</A><br><br>";
// const char cszDirEntry[]   = "%12S  %10S  %12d <A HREF=\"%S\">%S</A><br>";
const char cszDirFooter[]  = "</pre><hr></body>";

const char cszDirHeader3[] = "<head><title>";
const char cszDirHeader4[] = "</title></head><body><H1>";
const char cszDirHeader5[] = "</H1><hr><pre>";

const char cszDirHeader6[] = "<A HREF=\"";
const char cszDirHeader7[] = "</A><br>";

const char cszDirEntry1[]   = "<A HREF=\"";
const char cszDirEntry2[]   = "</A><br>";

#define MAXENTRYSIZE    150+MAX_PATH+MAX_PATH

BOOL CHttpRequest::EmitDirListing(void)
{
    WCHAR wszBuf1[MAX_PATH+10];
    WCHAR wszBuf2[MAX_PATH];
    char szHostBuf[MAX_PATH];
    char szBuf[MAX_PATH+1]; // holds temp values

    // generate listing into a buffer
    int  iSize = DIRBUFSIZE;
    int  iLen;
    PSTR pszBuf = MyRgAllocNZ(CHAR, iSize);
    int  iUsed = 0;
    PSTR pszTrav = pszBuf;
    if (!pszBuf)
        return FALSE;

    // we know have enough space for the headers
    if ( 0 != gethostname(szHostBuf, sizeof(szHostBuf)))
        szHostBuf[0] = '\0';

    //  iNext += sprintf(pszBuf+iNext, cszDirHeader1, szHostBuf, m_pszURL, szHostBuf, m_pszURL);
    pszTrav = strcpyEx(pszTrav,cszDirHeader3);

    pszTrav = strcpyEx(pszTrav,szHostBuf);
    *pszTrav++ = ' ';   *pszTrav++ = '-';  *pszTrav++ = ' ';
    pszTrav = strcpyEx(pszTrav,m_pszURL);

    pszTrav = strcpyEx(pszTrav,cszDirHeader4);

    pszTrav = strcpyEx(pszTrav,szHostBuf);
    *pszTrav++ = ' ';   *pszTrav++ = '-';  *pszTrav++ = ' ';

    pszTrav = strcpyEx(pszTrav,m_pszURL);
    pszTrav = strcpyEx(pszTrav,cszDirHeader5);
    // end sprintf replacement


    // find the parent path ignore the trailing slash (always present)

    char chSave = 0;
    for (int i=strlen(m_pszURL)-2; i>=0; i--)
    {
        if (m_pszURL[i]=='/' || m_pszURL[i]=='\\')
        {
            // Holds the string [Link to parent directory], which is displayed to users
            // (who would probably like the message to come in their native language and not necessarily English)
            WCHAR wszParentDirectory[128];
            CHAR szParentDirectory[128];

            // save & restore one char to temporarily truncate the URL at the parent path (incl slash)
            char chSave=m_pszURL[i+1];
            m_pszURL[i+1] = 0;
            // iNext += sprintf(pszBuf+iNext, cszDirHeader2, m_pszURL, CELOADSZ(IDS_LINKTOPARENTDIR));
            pszTrav = strcpyEx(pszTrav,cszDirHeader6);
            pszTrav = strcpyEx(pszTrav,m_pszURL);

            *pszTrav++ = '"'; *pszTrav++ = '>';

            LoadString(g_hInst,IDS_LINKTOPARENTDIR,wszParentDirectory,celems(wszParentDirectory));
            MyW2A(wszParentDirectory,szParentDirectory,sizeof(szParentDirectory));


            pszTrav = strcpyEx(pszTrav,szParentDirectory);
            pszTrav = strcpyEx(pszTrav,cszDirHeader7);
            // End sprintf replacement

            m_pszURL[i+1] = chSave;
            break;
        }
    }

    // create Find pattern
    DEBUGCHK(m_wszPath[wcslen(m_wszPath)-1]=='/' || m_wszPath[wcslen(m_wszPath)-1]=='\\');
    WIN32_FIND_DATA fd;
    wcscpy(wszBuf1, m_wszPath);
    wcscat(wszBuf1, L"*");

    // now iterate the files & subdirs (if any)
    HANDLE hFile = FindFirstFile(wszBuf1, &fd);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        do
        {
            // check for space
            iUsed = (int)((INT_PTR)(pszTrav - pszBuf));
            if ((iSize-iUsed) < MAXENTRYSIZE)
            {
                if (!(pszBuf = MyRgReAlloc(CHAR, pszBuf, iSize, iSize+DIRBUFSIZE)))
                    return FALSE;
                iSize += DIRBUFSIZE;
                pszTrav = pszBuf + iUsed;
            }
            // convert date
            FILETIME   ftLocal;
            SYSTEMTIME stLocal;
            FileTimeToLocalFileTime(&fd.ftLastAccessTime, &ftLocal);
            FileTimeToSystemTime(&ftLocal, &stLocal);
            // format date
            GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, &stLocal, NULL, wszBuf1, CCHSIZEOF(wszBuf1));
            GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_NOSECONDS, &stLocal, NULL, wszBuf2, CCHSIZEOF(wszBuf2));
            // generate HTML entry
            // iNext += sprintf(pszBuf+iNext, cszDirEntry, wszBuf1, wszBuf2, fd.nFileSizeLow, fd.cFileName, fd.cFileName);
            // const char cszDirEntry[]   = "%12S  %10S  %12d <A HREF=\"%S\">%S</A><br>";

            // Copy the Date.  We right justify it and put 2 spaces between it and beginning of time info
            iLen = MyW2A(wszBuf1,szBuf,12) - 1;
            memset(pszTrav,' ',12 - iLen);
            memcpy(pszTrav + 12 - iLen,szBuf,iLen);
            memset(pszTrav+12,' ',2);
            pszTrav += 14;


            // Copy the time.
            iLen = MyW2A(wszBuf2,szBuf,10) - 1;
            memset(pszTrav,' ',10 - iLen);
            memcpy(pszTrav + 10 - iLen,szBuf,iLen);
            memset(pszTrav+10,' ',2);
            pszTrav += 12;

            // The file length.
            _itoa(fd.nFileSizeLow,szBuf,10);
            iLen = strlen(szBuf);
            memset(pszTrav,' ',12 - iLen);
            memcpy(pszTrav + 12 - iLen,szBuf,iLen);
            memset(pszTrav+12,' ',2);
            pszTrav += 14;

            pszTrav = strcpyEx(pszTrav,cszDirEntry1);

            // Copy the file name to be displayed
            MyW2A(fd.cFileName,szBuf,sizeof(szBuf));
            pszTrav = strcpyEx(pszTrav,szBuf);
            *pszTrav++ = '\"';  *pszTrav++ = '>';

            // Copy the file name again, this time in the <A HREF..> statement.
            pszTrav = strcpyEx(pszTrav,szBuf);

            pszTrav = strcpyEx(pszTrav,cszDirEntry2);
            // End sprintf replacement
        }
        while (FindNextFile(hFile, &fd));
        // CloseHandle(hFile);  // This throws an exception on WinNT, use FindClose instead
        FindClose(hFile);
    }
    // emit footer
    pszTrav = strcpyEx(pszTrav, cszDirFooter);

    // create a response object & attach this body, then send headers & body
    CHttpResponse resp(m_socket, STATUS_OK, (m_fKeepAlive ? CONN_KEEP : CONN_CLOSE),this);
    m_rs = STATUS_OK;
    resp.SetBody(pszBuf, cszTextHtml);
    resp.SendResponse();
    // free the buffer
    MyFree(pszBuf);
    return TRUE;
}


void CHttpRequest::Init()
{
    memset(this, 0, sizeof(*this));
    m_dwSig = CHTTPREQUEST_SIG;
    m_pFInfo = CreateCFilterInfo();   // even if we have 0 filters allocate this, filter stuff assume it exists
}

//  Handle info must stay valid between net requests
//  Fcn is called if we successully authenticate (don't need them anymore) or
//  when the net session ends, to prevent a mem leak.


CHttpRequest::~CHttpRequest()
{
    TraceTag(ttidWebServer, "Calling CHttpRequest destructor");

    FreeHeaders();
    FreeAuth();

    if (m_pFInfo)
    {
        delete m_pFInfo;
        m_pFInfo = 0;
    }

    // only now do we free the NTLM library, assuming it made it past the
    // NTLM_NO_INIT_LIB stage.

    if (m_NTLMState.m_Conversation != NTLM_NO_INIT_LIB)
    {
        FreeNTLMHandles(&m_NTLMState);
    }
}


//  Called right before each HTTP Request (multiple times for a persisted session)
//  Frees request specific data, like destructor but keeps session data
//  (Filter alloc'd mem, NTLM state) in place.

BOOL CHttpRequest::ReInit()
{
    TraceTag(ttidWebServer, "Calling CHttpRequest ReInit (between requests)");
    FreeHeaders();
    FreeAuth();

    m_bufRequest.Reset();
    m_bufRespHeaders.Reset();
    m_bufRespBody.Reset();

    if (m_pFInfo)
    {
        if ( !m_pFInfo->ReInit() )
            return FALSE;
    }

    // NTLM stuff.  If we're in middle of conversation, don't delete NTLM state info
    // We never free the library here, only in the destructor.
    if (g_pVars->m_fNTLMAuth && m_NTLMState.m_Conversation == NTLM_DONE)
    {
        FreeNTLMHandles(&m_NTLMState);

        //  Set the flags so that we know the context isn't initialized.  This
        //  would be relevent if user typed the wrong password.
        m_NTLMState.m_Conversation = NTLM_NO_INIT_CONTEXT;
    }


    // Certain values need to be re-zeroed
    m_dwContentLength = m_dwIfModifiedLength = m_dwVersion = 0;
    m_fKeepAlive = FALSE;

    return TRUE;
}


//  If a filter makes a call to ServerSupportFunction to SEND_RESPONSE_HEADERS,
//  the http engine no longer directly display the requested page.  In this
//  case the filter acts like an ISAPI extension, it's responsible for returning
//  it's own content.  (Like IIS).

//  This isn't the same as ASP's concept of having sent headers.  ASP's sent headers
//  stops script from doing other calls to send headers.  If Filter wants to send
//  more headers (which will appear in client browser window) fine, we copy IIS.

//  This is small enough that it's not worth putting into a stub.
BOOL CHttpRequest::FilterNoResponse(void)
{
    if (m_pFInfo && m_pFInfo->m_fSentHeaders)
    {
        return TRUE;
    }
    return FALSE;
}

// Note:  This has not been made part of the ISAPI component because we need
// to do checking as to whether the requested operation is valid given our current
// component set.


BOOL CHttpRequest::HandleScript()
{
    DEBUG_CODE_INIT;
    BOOL ret = TRUE;        // Is page a ASP/ISAPI?
    CHAR szBuf[MAX_PATH + 1];
    DWORD dwLen = sizeof(szBuf);
    PWSTR wszPath;

    // Check if this path points at a VROOT with extension mapping
    // enabled.  If so, we need to treat this as an extension, so we
    // update the script type for the VROOT and modify the dll path.

    if (wszPath = g_pVars->m_pVroots->MapExtToPath (m_pszURL, NULL))
    {
        if (m_wszPath != NULL)
            MyFree(m_wszPath);

        m_wszPath = MySzDupW(wszPath);
        m_VRootScriptType = SCRIPT_TYPE_EXTENSION;
    }

    // Set path translated here.
    if (m_pszPathInfo)
        strcpy(szBuf,m_pszPathInfo);
    else
    {
        // Fixes BUG 11270.  On IIS, if no PATH_INFO variable is used,
        // PATH_TRANSLATED is set to the mapping of the "/" directory, no matter
        // what directory the isapi was called from.
        strcpy(szBuf,"/");
    }

    if ( !g_pVars->m_fExtensions || !ServerSupportFunction(HSE_REQ_MAP_URL_TO_PATH,szBuf,&dwLen,0))
        m_pszPathTranslated = NULL;
    else
        m_pszPathTranslated = MySzDupA(szBuf);

    // check if it's an executable ISAPI
    // If the VRoot was not executable we would download the dll, regardless of whether
    // Extensions are a component or not.  This is the way IIS does it, so we follow suit.


    // If the file extension is .dll but the permissions flags don't have
    // HSE_URL_FLAGS_EXECUTE, we send the dll as a file.  Like IIS.

    if (m_VRootScriptType == SCRIPT_TYPE_EXTENSION ||
        (m_dwPermissions & HSE_URL_FLAGS_EXECUTE) &&
        (m_wszExt && (0==_wcsicmp(m_wszExt, L".DLL"))))
    {
        if (FALSE == g_pVars->m_fExtensions)
        {
            m_rs = STATUS_NOTIMPLEM;
            myleave(88);
        }

        if (!ExecuteISAPI())
        {
            m_rs = STATUS_INTERNALERR;
            myleave(53);
        }
    }

    // check if it's an executable ASP.  If the appropriate permissions aren't set,
    // we send an access denied message.  Never download an ASP file's source
    // code under any conditions.

    else if (m_VRootScriptType == SCRIPT_TYPE_ASP ||
             m_wszExt && (0==_wcsicmp(m_wszExt, L".ASP")))
    {
        if ( ! (m_dwPermissions & (HSE_URL_FLAGS_EXECUTE | HSE_URL_FLAGS_SCRIPT)))
        {
            m_rs = STATUS_FORBIDDEN;

            if (g_pVars->m_fFilters)
                CallFilter(SF_NOTIFY_ACCESS_DENIED);
            myleave(79);
        }

        if (FALSE == g_pVars->m_fASP)
        {
            m_rs = STATUS_NOTIMPLEM;
            myleave(89);
        }

        if (!IsLocalFile(m_wszPath))
        {
            m_rs = STATUS_FORBIDDEN;

            if (g_pVars->m_fFilters)
                CallFilter(SF_NOTIFY_ACCESS_DENIED);
            myleave(87);
        }

        if (!ExecuteASP())
        {
            // ExecuteASP sets m_rs on error.
            myleave(92);
        }
    }
    else    // Neither an ASP or ISAPI.
    {
        ret = FALSE;
    }

done:
    TraceTag(ttidWebServer, "HandleScript returned:, err = %d, m_rs = %d",err,m_rs);

    return ret;
}


//  wszFile is the physical file we're going to try to load.  Function returns
//  true if file is local and false if it is on a network drive.

//  The only ways a file can be non-local on CE are if it has a UNC name
//  (\\machineshare\share\file) or if it is mapped under the NETWORK directory.
//  However, the Network folder doesn't have to be named "network", so we
//  use the offical method to get the name


BOOL IsLocalFile(PWSTR wszFile)
{
    // Are we requested a UNC name
    if ( wcslen(wszFile) >= 2)
    {
        if ( (wszFile[0] == '\\' || wszFile[0] == '/') &&
             (wszFile[1] == '\\' || wszFile[1] == '/'))
        {
            TraceTag(ttidWebServer, "Extension or ASP requested is not on local file system, access denied");
            return FALSE;
        }
    }

#if defined  (UNDER_CE) && !defined (OLD_CE_BUILD)
    CEOIDINFO ceOidInfo;
    DWORD dwNetworkLen;


    if (!CeOidGetInfo(OIDFROMAFS(AFS_ROOTNUM_NETWORK), &ceOidInfo))
    {
        return TRUE;    // if we can't load it assume that it's not supported in general, so it is local file
    }

    dwNetworkLen =  wcslen(ceOidInfo.infDirectory.szDirName);
    if (0 == wcsnicmp(ceOidInfo.infDirectory.szDirName,wszFile,dwNetworkLen))
    {
        TraceTag(ttidWebServer, "Extension or ASP requested is not on local file system, access denied");
        return FALSE;
    }
#endif

    return TRUE;
}



// dwMaxSizeToRead is HKLM\Comm\Httpd\PostReadSize in typcilac case, or
// is unread data if fInitialPostRead=0, which means that we're handling
// an error condition on keep-alive and need to read remaining post data.

// Note that we do NOT pull in remaining POST data if an ISAPI extension
// ran and had more data than was initially read in because it's the ISAPI's
// job to read all this data off the wire using ReadClient if they're going
// to do a keep-alive; if they don't do this then HTTPD will get parse errors,
// like IIS.

BOOL CHttpRequest::ReadPostData(DWORD dwMaxSizeToRead, BOOL fInitialPostRead)
{
    BOOL ret = TRUE;
    HRINPUT hi;

    if (m_dwContentLength && dwMaxSizeToRead)
    {
        DWORD dwRead;
        if (m_dwContentLength > dwMaxSizeToRead)
            dwRead = dwMaxSizeToRead;
        else
            dwRead = m_dwContentLength;

        hi = m_bufRequest.RecvBody(m_socket, dwRead, !fInitialPostRead);
        if (hi != INPUT_OK && hi != INPUT_NOCHANGE)
        {
            m_rs = STATUS_BADREQ;
            ret = FALSE;
        }
        // If no new data was read (hi = INPUT_NOCHANGE) don't call filter.
        else if (g_pVars->m_fFilters  &&
                 hi != INPUT_NOCHANGE &&
                 ! CallFilter(SF_NOTIFY_READ_RAW_DATA))
        {
            // let filter set error code.
            ret = FALSE;
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\utiltree.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    svsutil.cxx

Abstract:

    Miscellaneous useful utilities

Author:

    Sergey Solyanik (SergeyS)

--*/
#include "pch.h"
#pragma hdrstop


#include <svsutil.hxx>

//
//  Tree support, C-style interface
//
SVSTree  *svsutil_GetTree (unsigned int uiChunkSize) {
    SVSTree *pTree = new SVSTree(uiChunkSize > 0 ? uiChunkSize : SVSUTIL_TREE_INITIAL);

    SVSUTIL_ASSERT(pTree);

    return pTree;
}

void svsutil_EmptyTree (SVSTree *pTree) {
    SVSUTIL_ASSERT (pTree);
    pTree->Empty ();
}

void svsutil_EmptyTreeWithCallback (SVSTree *pTree, void (*pfuncFree)(void *pvData, void *pvArg), void *a_pvArg) {
    SVSUTIL_ASSERT (pTree && pfuncFree);
    pTree->Empty (pfuncFree, a_pvArg);
}

void svsutil_DestroyTree (SVSTree *pTree) {
    SVSUTIL_ASSERT (pTree);

    delete pTree;
}

SVSTNode *svsutil_NextTreeNode (SVSTree *pTree, SVSTNode *pNode) {
    SVSUTIL_ASSERT (pTree && pNode);

    return pTree->Next (pNode);
}

SVSTNode *svsutil_PrevTreeNode (SVSTree *pTree, SVSTNode *pNode) {
    SVSUTIL_ASSERT (pTree && pNode);

    return pTree->Prev (pNode);
}

SVSTNode *svsutil_MinTreeNode (SVSTree *pTree) {
    SVSUTIL_ASSERT (pTree);

    return pTree->Min();
}

SVSTNode *svsutil_MaxTreeNode (SVSTree *pTree) {
    SVSUTIL_ASSERT (pTree);

    return pTree->Max ();
}

SVSTNode *svsutil_LocateTreeNode (SVSTree *pTree, SVSCKey cKey) {
    SVSUTIL_ASSERT (pTree);

    return pTree->Locate (cKey);
}

SVSTNode *svsutil_LocateLeftNeighborNode (SVSTree *pTree, SVSCKey cKey) {
    SVSUTIL_ASSERT (pTree);

    return pTree->LocateLeftNeighbor (cKey);
}

SVSTNode *svsutil_LocateRightNeighborNode (SVSTree *pTree, SVSCKey cKey) {
    SVSUTIL_ASSERT (pTree);

    return pTree->LocateRightNeighbor (cKey);
}

unsigned int svsutil_TreeToArray (SVSTree *pTree, void **appv) {
    SVSUTIL_ASSERT (pTree);

    return pTree->ToArray(appv);
}

unsigned int svsutil_GetTreeSize (SVSTree *pTree) {
    SVSUTIL_ASSERT (pTree);

    return pTree->Size();
}

SVSTNode *svsutil_InsertTreeNode (SVSTree *pTree, SVSCKey cKey, void *pvData) {
    SVSUTIL_ASSERT (pTree);

    return pTree->Insert (cKey, pvData);
}

void *svsutil_DeleteTreeNode (SVSTree *pTree, SVSTNode *pNode) {
    SVSUTIL_ASSERT (pTree && pNode);

    return pTree->Delete (pNode);
}

void *svsutil_GetTreeNodeData (SVSTNode *pNode) {
    SVSUTIL_ASSERT (pNode);

    return SVSTree::GetData (pNode);
}

SVSCKey svsutil_GetTreeNodeKey (SVSTNode *pNode) {
    SVSUTIL_ASSERT (pNode);

    return SVSTree::GetKey (pNode);
}

void svsutil_CompactTree (SVSTree *pTree) {
    SVSUTIL_ASSERT (pTree);

    pTree->Compact ();
}

//
//  Tree support, class
//
SVSTNode *SVSTree::Insert (SVSCKey cKey, void *pvData) {
#if defined (SVSUTIL_DEBUG_TREE)
    RBTreeIntegrity();
#endif
    SVSTNode *x = (SVSTNode *)svsutil_GetFixed (pNodeMem);
    SVSTNode *pNode = x;

    if (! x)
    {
        SVSUTIL_ASSERT (0);
        return NULL;
    }

    x->pLeft  = x->pRight
                = x->pParent = pNil;
    x->cKey   = cKey;
    x->pvData = pvData;
    x->iColor = SVSUTIL_COLOR_RED;

    TreeInsert (x);

    while ((x != pRoot) && (x->pParent->iColor == SVSUTIL_COLOR_RED))
    {
        if (x->pParent == x->pParent->pParent->pLeft)
        {
            SVSTNode *y = x->pParent->pParent->pRight;
            if (y->iColor == SVSUTIL_COLOR_RED)
            {
                x->pParent->iColor = SVSUTIL_COLOR_BLACK;
                y->iColor = SVSUTIL_COLOR_BLACK;
                x = x->pParent->pParent;
                x->iColor = SVSUTIL_COLOR_RED;
            }
            else
            {
                if (x == x->pParent->pRight)
                {
                    x = x->pParent;
                    LeftRotate (x);
                }

                x->pParent->iColor = SVSUTIL_COLOR_BLACK;
                x->pParent->pParent->iColor = SVSUTIL_COLOR_RED;
                RightRotate (x->pParent->pParent);
            }
        }
        else
        {
            SVSTNode *y = x->pParent->pParent->pLeft;
            if (y->iColor == SVSUTIL_COLOR_RED)
            {
                x->pParent->iColor = SVSUTIL_COLOR_BLACK;
                y->iColor = SVSUTIL_COLOR_BLACK;
                x = x->pParent->pParent;
                x->iColor = SVSUTIL_COLOR_RED;
            }
            else
            {
                if (x == x->pParent->pLeft)
                {
                    x = x->pParent;
                    RightRotate (x);
                }

                x->pParent->iColor = SVSUTIL_COLOR_BLACK;
                x->pParent->pParent->iColor = SVSUTIL_COLOR_RED;
                LeftRotate (x->pParent->pParent);
            }
        }
    }

    pRoot->iColor = SVSUTIL_COLOR_BLACK;

#if defined (SVSUTIL_DEBUG_TREE)
    RBTreeIntegrity();
#endif

    return pNode;
}

void SVSTree::DeleteFixup (SVSTNode *x) {
    while ((x != pRoot) && (x->iColor == SVSUTIL_COLOR_BLACK))
    {
        if (x == x->pParent->pLeft)
        {
            SVSTNode *w = x->pParent->pRight;
            if (w->iColor == SVSUTIL_COLOR_RED)
            {
                w->iColor = SVSUTIL_COLOR_BLACK;
                x->pParent->iColor = SVSUTIL_COLOR_RED;
                LeftRotate (x->pParent);
                w = x->pParent->pRight;
            }

            if ((w->pLeft->iColor == SVSUTIL_COLOR_BLACK) && (w->pRight->iColor == SVSUTIL_COLOR_BLACK))
            {
                w->iColor = SVSUTIL_COLOR_RED;
                x = x->pParent;
            }
            else
            {
                if (w->pRight->iColor == SVSUTIL_COLOR_BLACK)
                {
                    w->pLeft->iColor = SVSUTIL_COLOR_BLACK;
                    w->iColor = SVSUTIL_COLOR_RED;
                    RightRotate (w);
                    w = x->pParent->pRight;
                }
                w->iColor = x->pParent->iColor;
                x->pParent->iColor = SVSUTIL_COLOR_BLACK;
                w->pRight->iColor  = SVSUTIL_COLOR_BLACK;
                LeftRotate (x->pParent);
                x = pRoot;
            }
        }
        else
        {
            SVSTNode *w = x->pParent->pLeft;
            if (w->iColor == SVSUTIL_COLOR_RED)
            {
                w->iColor = SVSUTIL_COLOR_BLACK;
                x->pParent->iColor = SVSUTIL_COLOR_RED;
                RightRotate (x->pParent);
                w = x->pParent->pLeft;
            }

            if ((w->pLeft->iColor == SVSUTIL_COLOR_BLACK) && (w->pRight->iColor == SVSUTIL_COLOR_BLACK))
            {
                w->iColor = SVSUTIL_COLOR_RED;
                x = x->pParent;
            }
            else
            {
                if (w->pLeft->iColor == SVSUTIL_COLOR_BLACK)
                {
                    w->pRight->iColor = SVSUTIL_COLOR_BLACK;
                    w->iColor = SVSUTIL_COLOR_RED;
                    LeftRotate (w);
                    w = x->pParent->pLeft;
                }
                w->iColor = x->pParent->iColor;
                x->pParent->iColor = SVSUTIL_COLOR_BLACK;
                w->pLeft->iColor  = SVSUTIL_COLOR_BLACK;
                RightRotate (x->pParent);
                x = pRoot;
            }
        }
    }

    x->iColor = SVSUTIL_COLOR_BLACK;
}

void *SVSTree::Delete (SVSTNode *z) {
#if defined (SVSUTIL_DEBUG_TREE)
    RBTreeIntegrity();
    SVSUTIL_ASSERT (InTree(z));
#endif

    void     *pvData = z->pvData;

    SVSTNode *y = ((z->pLeft == pNil) || (z->pRight == pNil)) ? z : Next(z);
    SVSTNode *x = (y->pLeft != pNil) ? y->pLeft : y->pRight;

    x->pParent = y->pParent;

    if (y->pParent == pNil)
        pRoot = x;
    else if (y == y->pParent->pLeft)
        y->pParent->pLeft  = x;
    else
        y->pParent->pRight = x;

    int iColor = y->iColor;

    if (y != z)
    {
        //  Insert y in z's place in the tree.
        //  Note: this is longer than the standard data
        //  exchange
        //      z->cKey   = y->cKey;
        //      z->pvData = y->pvData;
        //  but preserves pointer stability, so that
        //  pointers to node can be kept outside...
        //
        if (z->pParent != pNil)
        {
            if (z == z->pParent->pRight)
                z->pParent->pRight = y;
            else
                z->pParent->pLeft  = y;
        }
        y->pParent = z->pParent;

        if (z->pLeft != pNil)
            z->pLeft->pParent = y;
        y->pLeft = z->pLeft;

        if (z->pRight != pNil)
            z->pRight->pParent = y;
        y->pRight = z->pRight;

        y->iColor = z->iColor;

        if (x->pParent == z)
            x->pParent = y;

        if (pRoot == z)
            pRoot = y;
    }

    svsutil_FreeFixed (z, pNodeMem);

    if (iColor == SVSUTIL_COLOR_BLACK)
        DeleteFixup (x);

    pNil->pParent = pNil;

    iSize -= 1;

#if defined (SVSUTIL_DEBUG_TREE)
    RBTreeIntegrity();
#endif

    return pvData;
}

#if defined (SVSUTIL_DEBUG_TREE)
//
//  This is only debug check for the tree
//
void SVSTree::RBTreeIntegrity (void) {
    SVSUTIL_ASSERT (iSize >= 0);
    SVSUTIL_ASSERT (pRoot && pNil && pNodeMem);

    SVSUTIL_ASSERT (pNil->pParent == pNil);
    SVSUTIL_ASSERT (pNil->pLeft   == pNil);
    SVSUTIL_ASSERT (pNil->pRight  == pNil);
    SVSUTIL_ASSERT (pNil->cKey    == 0);
    SVSUTIL_ASSERT (pNil->pvData  == NULL);
    SVSUTIL_ASSERT (pNil->iColor  == SVSUTIL_COLOR_BLACK);

    static HANDLE s_hCurrentThread;
    HANDLE hCurrentThread = GetCurrentThread();

    SVSTNode *pMin = Min();

    if (! pMin)
        SVSUTIL_ASSERT ((pRoot == pNil) && (iSize == 0));
    else
    {
        unsigned int iCompSize = 0;

        while (pMin)
        {
            ++iCompSize;
            pMin = Next(pMin);
        }

        SVSUTIL_ASSERT (iCompSize == iSize);
    }

    if (pRoot != pNil)
    {
        SVSUTIL_ASSERT (pRoot->pParent == pNil);
        SVSUTIL_ASSERT (pRoot->iColor == SVSUTIL_COLOR_BLACK);
        CheckBlackHeight (pRoot);
    }

    s_hCurrentThread = hCurrentThread;
}

int SVSTree::CheckBlackHeight (SVSTNode *pNode) {
    if (pNode == pNil)
        return 1;

    int iBlackHeightLeft  = CheckBlackHeight (pNode->pLeft);
    int iBlackHeightRight = CheckBlackHeight (pNode->pRight);

    SVSUTIL_ASSERT (iBlackHeightLeft == iBlackHeightRight);

    if (pNode->iColor == SVSUTIL_COLOR_RED)
    {
        SVSUTIL_ASSERT (pNode->pLeft->iColor == SVSUTIL_COLOR_BLACK);
        SVSUTIL_ASSERT (pNode->pRight->iColor == SVSUTIL_COLOR_BLACK);
    }

    if (pNode->pLeft != pNil)
        SVSUTIL_ASSERT (pNode->pLeft->pParent == pNode);

    if (pNode->pRight != pNil)
        SVSUTIL_ASSERT (pNode->pRight->pParent == pNode);

    return pNode->iColor == SVSUTIL_COLOR_BLACK ? iBlackHeightRight + 1 : iBlackHeightRight;
}

int SVSTree::InTree (SVSTNode *pNode) {
    SVSTNode *pMin = Min();

    if (! pMin)
        return FALSE;

    while (pMin)
    {
        if (pMin == pNode)
            return TRUE;

        pMin = Next(pMin);
    }

    return FALSE;
}

#endif /* SVSUTIL_DEBUG_TREE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\parser.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: PARSER.CPP
Author: Arul Menezes
Abstract: HTTP request parser
--*/
#include "pch.h"
#pragma hdrstop

#include "httpd.h"

// This could be written as a state-machine parser, but for now I'm
// keeping it simple and slow :-(

// Methods
const char cszGET[] = "GET";
const char cszHEAD[] = "HEAD";
const char cszPOST[] = "POST";
// General headers
const char cszConnection[] = "Connection:";
//const char cszDate[] = "Date:";
//const char cszPragma[] = "Pragma:";
// Request headers
const char cszAuthorization[] = "Authorization:";
const char cszIfModifiedSince[] = "If-Modified-Since:";
//const char cszReferer[] = "Referer:";
//const char cszUserAgent[] = "User-Agent:";
const char cszCookie[] = "Cookie:";
const char cszAccept[] = "Accept:";
// Entity Headers
const char cszContentLength[] = "Content-Length:";
const char cszContentType[] = "Content-Type:";

// other Header tokens
// const char cszHTTPVER[] = "HTTP/%d.%d"; //
const char cszHTTPVER[] = "HTTP/";
const char cszBasic[] = "Basic";
const char cszNTLM[] = "NTLM";

#define PFNPARSE(x) &(CHttpRequest::Parse##x)
#define TABLEENTRY(csz, id, pfn)    { csz, sizeof(csz)-1, id, PFNPARSE(pfn) }
#define AUTH_FILTER_DONE     0x1000     // no more filter calls to SF_AUTH after the 1st one in a session

typedef (CHttpRequest::*PFNPARSEPROC)(PCSTR pszTok, TOKEN idHeader);

typedef struct tagHeaderDesc
{
    const char*     sz;
    int             iLen;
    TOKEN           id;
    PFNPARSEPROC    pfn;
} HEADERDESC;


const HEADERDESC rgHeaders[] =
{
    //{ cszGET, sizeof(cszGET), TOK_GET, &CHttpRequest::ParseMethod },
// Methods
//  TABLEENTRY(cszGET,  TOK_GET,  Method),
//  TABLEENTRY(cszHEAD, TOK_HEAD, Method),
//  TABLEENTRY(cszPOST, TOK_POST, Method),
// General headers
    TABLEENTRY(cszConnection, TOK_CONNECTION, Connection),
    //TABLEENTRY(cszDate,     TOK_DATE,   Date),
    //TABLEENTRY(cszPragma, TOK_PRAGMA, Pragma),
// Request headers
    TABLEENTRY(cszCookie,   TOK_COOKIE, Cookie),
    TABLEENTRY(cszAccept,   TOK_ACCEPT, Accept),
    //TABLEENTRY(cszReferer,  TOK_REFERER Referer),
    //TABLEENTRY(cszUserAgent,TOK_UAGENT, UserAgent),
    TABLEENTRY(cszAuthorization,  TOK_AUTH,  Authorization),
    TABLEENTRY(cszIfModifiedSince,TOK_IFMOD, IfModifiedSince),
// Entity Headers
    //TABLEENTRY(cszContentEncoding, TOK_ENCODING Encoding),
    TABLEENTRY(cszContentType,  TOK_TYPE,    ContentType),
    TABLEENTRY(cszContentLength,TOK_LENGTH,  ContentLength),
    { 0, 0, (TOKEN)0, 0}
};

// Parse all the headers, line by line
BOOL CHttpRequest::ParseHeaders()
{
    DEBUG_CODE_INIT;
    PSTR pszTok;
    PWSTR pwszTemp;
    PSTR pszPathInfo = NULL;
    int i, iLen;
    BOOL ret = FALSE;


    if (!m_bufRequest.NextTokenWS(&pszTok, &iLen))
    {
        m_rs = STATUS_BADREQ;
        myleave(287);
    }

    if (! ParseMethod(pszTok,iLen))
    {
        m_rs = STATUS_BADREQ;
        myleave(288);
    }

    if (!m_bufRequest.NextLine())
    {
        m_rs = STATUS_BADREQ;
        myleave(290);
    }

    // outer-loop. one header per iteration
    while (m_bufRequest.NextTokenColon(&pszTok, &iLen))
    {
        // compare token with tokens in table
        for (i=0; rgHeaders[i].sz; i++)
        {
            //TraceTag(ttidWebServer, "Comparing %s %d %d", rgHeaders[i].sz, rgHeaders[i].iLen, rgHeaders[i].pfn);
            if ( (rgHeaders[i].iLen == iLen) &&
                 0==_memicmp(rgHeaders[i].sz, pszTok, iLen) )
                break;
        }
        if (rgHeaders[i].pfn)
        {
            TraceTag(ttidWebServer, "Parsing %s", rgHeaders[i].sz);
            // call the specific function to parse this header.
            if (! ((this->*(rgHeaders[i].pfn))(pszTok, rgHeaders[i].id)) )
            {
                TraceTag(ttidWebServer, "Parser: failed to parse %s -- IGNORING", rgHeaders[i].sz);
            }
        }
        else
        {
            TraceTag(ttidWebServer, "Ignoring header %s", pszTok);
        }
        if (!m_bufRequest.NextLine())
        {
            m_rs = STATUS_BADREQ;
            myleave(290);
        }
    }

    if (!m_bufRequest.NextLine()) // eat the blank line
    {
        m_rs = STATUS_BADREQ;
        myleave(290);
    }
    TraceTag(ttidWebServer, "Parser: DONE");

    // check what we got
    if (!m_pszMethod || !m_idMethod)
    {
        TraceTag(ttidWebServer, "Parser: missing URL or method, illformatted Request-line");
        m_rs = STATUS_BADREQ;
        myleave(291);
    }

    // Once we've read the request line, give filter shot at modifying the
    // remaining headers.
    if (g_pVars->m_fFilters &&
        ! CallFilter(SF_NOTIFY_PREPROC_HEADERS))
        myleave(292);


    m_wszPath = g_pVars->m_pVroots->URLAtoPathW(m_pszURL, &m_dwPermissions, &m_AuthLevelReqd,&m_VRootScriptType,&m_pszPathInfo,&m_wszVRootUserList);

    if (g_pVars->m_fFilters &&
        ! CallFilter(SF_NOTIFY_URL_MAP))
        myleave(293);

    // get extension
    if (m_wszPath && (pwszTemp = wcsrchr(m_wszPath, '.')))
        m_wszExt = MySzDupW(pwszTemp);


    // As per the docs, the filter gets ONLY 1 call per session to notify
    // it of this event.  m_dwAuthFlags is remembered from session to session.

    // Like IIS, it always is called, even if Vroots is AUTH_PUBLIC already and
    // even if no security has been enabled.

    if ( g_pVars->m_fFilters && ! (m_dwAuthFlags & AUTH_FILTER_DONE))
    {
        if ( ! AuthenticateFilter())
            myleave(294);
    }
    m_dwAuthFlags |= AUTH_FILTER_DONE;

    ret = TRUE;
    done:
    TraceTag(ttidWebServer, "Parse headers failed, err = %d",err);
    return ret;
}

BOOL CHttpRequest::ParseMethod(PCSTR pszMethod, int cbMethod)
{
    DEBUG_CODE_INIT;
    PSTR pszTok, pszTok2;
    int iLen;
    BOOL ret;

// save method
    m_pszMethod = MySzDupA(pszMethod);

    if (0 == memcmp(cszGET,pszMethod,cbMethod))
        m_idMethod = TOK_GET;
    else if (0 == memcmp(cszHEAD,pszMethod,cbMethod))
        m_idMethod = TOK_HEAD;
    else if (0 == memcmp(cszPOST,pszMethod,cbMethod))
        m_idMethod = TOK_POST;
    else
        m_idMethod = TOK_UNKNOWN_VERB;

// get URL and HTTP/x.y together (allows for spaces in URL like Netscape sends)
    if (!m_bufRequest.NextTokenEOL(&pszTok, &iLen))
        myretleave(FALSE, 201);

// seperate out the HTTP/x.y
    if (pszTok2 = strrchr(pszTok, ' '))
    {
        *pszTok2 = 0;
        iLen = (INT)((INT_PTR)(pszTok2-pszTok));
        pszTok2++;
    }

// clean up & parse the URL
    MyCrackURL(pszTok, iLen);

// get version (optional. HTTP 0.9 wont have this)
    if (!pszTok2)
        m_dwVersion = MAKELONG(9, 0);
    else
    {
        //  int iMajor, iMinor;
        //  sscanf(pszTok2, cszHTTPVER, &iMajor, &iMinor);
        //  m_dwVersion = MAKELONG(iMinor, iMajor);
        SetHTTPVersion(pszTok2, &m_dwVersion);

        pszTok2[-1] = ' ';  // reset this to a space
    }
    ret = TRUE;

    done:
    TraceTag(ttidWebServer, "end ParseMethod (iGLE=%d iErr=%d)", GLE(err),err);
    return ret;
}

// We assume a raw URL in the form that we receive in the HTTP headers (no scheme, port number etc)
// We extract the path, extra-path, and query
BOOL CHttpRequest::MyCrackURL(PSTR pszRawURL, int iLen)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    PSTR  pszDecodedURL=0, pszTemp=0, pszPartiallyDecodedURL=0;
    int iLen2;
    DWORD cchDecodedURL = iLen + 1; // including the NULL terminator
    DWORD cchPartiallyDecodedURL = iLen + 1;

    // decode URL (convert escape sequences etc)
    if (NULL == (pszPartiallyDecodedURL = MyRgAllocNZ(CHAR, cchDecodedURL)))
        myleave(382);
    if (NULL == (pszDecodedURL = MyRgAllocNZ(CHAR, cchPartiallyDecodedURL)))
        myleave(382);

    // BUG FIX 393235 - When InternetCanonicalizeUrlA() is told to decode a URL and process the meta
    // directories, it does them in the wrong order. Passing it:
    // http://localhost:2869/upnphost/%2e./%2e./%2e./%2e./%2e./%2e./boot.ini
    // results in:
    // http://localhost:2869/upnphost/../../../../../../boot.ini
    // which is clearly not safe. To work around this, we call it twice - once to decode the URL, and
    // a second time to process the meta directories.

    // First, decode the URL
    if (!InternetCanonicalizeUrlA(pszRawURL,
                                  pszPartiallyDecodedURL,
                                  (DWORD*)&cchPartiallyDecodedURL,
                                  ICU_NO_ENCODE | ICU_DECODE | ICU_BROWSER_MODE | ICU_NO_META))
    {
        TraceTag(ttidWebServer, "CHttpRequest::MyCrackURL - InternetCanonicalizeUrlA failed with GLE=%d\n", GetLastError());
        myleave(383);
    }

    // Second, process the meta directories
    if (!InternetCanonicalizeUrlA(pszPartiallyDecodedURL,
                                  pszDecodedURL,
                                  (DWORD*)&cchDecodedURL,
                                  ICU_NO_ENCODE | ICU_BROWSER_MODE))
    {
        TraceTag(ttidWebServer, "CHttpRequest::MyCrackURL - InternetCanonicalizeUrlA failed with GLE=%d\n", GetLastError());
        myleave(384);
    }


    // get query string
    if (pszTemp = strchr(pszDecodedURL, '?'))
    {
        m_pszQueryString = MySzDupA(pszTemp+1);
        *pszTemp = 0;
    }


    // Searching for an embedded ISAPI dll name, ie /wwww/isapi.dll/a/b.
    // We load the file /www/isapi.dll and set PATH_INFO to /a/b
    // Emebbed ASP file names are handled similiarly.
    if (g_pVars->m_fExtensions)
    {
        if (pszTemp = strstr(pszDecodedURL,".dll/"))
        {
            m_pszPathInfo = MySzDupA(pszTemp + sizeof(".dll/") - 2);
            pszTemp[sizeof(".dll/") - 2] = 0;
        }
        else if (pszTemp = strstr(pszDecodedURL,".asp/"))
        {
            m_pszPathInfo = MySzDupA(pszTemp + sizeof(".asp/") - 2);
            pszTemp[sizeof(".asp/") - 2] = 0;
        }
    }

    // save a copy of the cleaned up URL (MINUS query!)
    // SPECIAL HACK: alloc one extra char in case we have to send a redirect back (see request.cpp)

    iLen2 = strlen(pszDecodedURL);
    m_pszURL = MySzAllocA(1+iLen2);
    Nstrcpy(m_pszURL, pszDecodedURL, iLen2); // copy null-term too.

    ret = TRUE;
    done:
    MyFree(pszDecodedURL);
    MyFree(pszPartiallyDecodedURL);
    TraceTag(ttidWebServer, "end MyCrackURL(%s) path=%s ext=%s query=%s (iGLE=%d iErr=%d)\r\n",
                               pszRawURL, m_wszPath, m_wszExt, m_pszQueryString, GLE(err), err);

    return ret;

}

BOOL CHttpRequest::ParseContentLength(PCSTR pszMethod, TOKEN id)
{
    PSTR pszTok = 0;
    int iLen = 0;

// get length (first token after "Content-Type;")
    if (m_bufRequest.NextTokenWS(&pszTok, &iLen) && pszTok && iLen)
    {
        m_dwContentLength = atoi(pszTok);
    }

    return TRUE;

}

BOOL CHttpRequest::ParseCookie(PCSTR pszMethod, TOKEN id)
{
    PSTR pszTok = 0;
    int iLen = 0;

// get cookie (upto \r\n after "Cookies;")
    if (m_bufRequest.NextTokenEOL(&pszTok, &iLen) && pszTok && iLen)
    {
        m_pszCookie = MySzDupA(pszTok);
    }
    return TRUE;

}

BOOL CHttpRequest::ParseAccept(PCSTR pszMethod, TOKEN id)
{
    PSTR pszTok = 0;
    int iLen = 0;

// get cookie (upto \r\n after "Cookies;")
    if (m_bufRequest.NextTokenEOL(&pszTok, &iLen) && pszTok && iLen)
    {
        m_pszAccept = MySzDupA(pszTok);
    }
    return TRUE;

}


BOOL CHttpRequest::ParseContentType(PCSTR pszMethod, TOKEN id)
{
    PSTR pszTok = 0;
    int iLen = 0;

// get type (first token after "Content-Type;")
    if (m_bufRequest.NextTokenWS(&pszTok, &iLen) && pszTok && iLen)
    {
        m_pszContentType = MySzDupA(pszTok);
    }
    return TRUE;
}

const char cszDateParseFmt[] = " %*3s, %02hd %3s %04hd %02hd:%02hd:%02hd GMT; length=%d";

BOOL CHttpRequest::ParseIfModifiedSince(PCSTR pszMethod, TOKEN id)
{
    PSTR pszTok = 0;
    int iLen = 0;
    int i = 0;
    char szMonth[10];
    SYSTEMTIME st;
    ZEROMEM(&st);

// get the date (rest of line after If-Modified-Since)
// BUGBUG: Note we are handling only one date format (the "reccomended" one)
    if (m_bufRequest.NextTokenEOL(&pszTok, &iLen) && pszTok && iLen)
    {
        //  i = sscanf(pszTok, cszDateParseFmt, &st.wDay, &szMonth, &st.wYear, &st.wHour, &st.wMinute, &st.wSecond, &m_dwIfModifiedLength);
        if ( SetHTTPDate(pszTok,szMonth,&st,&m_dwIfModifiedLength))
        {
            // try to match month
            for (i=0; rgMonth[i]; i++)
            {
                if (0==strcmpi(szMonth, rgMonth[i]))
                {
                    st.wMonth = (WORD)i;
                    // convert to filetime & store
                    SystemTimeToFileTime(&st, &m_ftIfModifiedSince);
                    return TRUE;
                }
            }
        }
        TraceTag(ttidWebServer, "Failed to parse If-Modified-Since(%s) Parsed: day=%02d month=%s(%d) year=%04d time=%02d:%02d:%02d len=%d\r\n",
                              pszTok, st.wDay, szMonth, i, st.wYear, st.wHour, st.wMinute, st.wSecond, m_dwIfModifiedLength);
    }
    return FALSE;
}



// Note:  No filter calls to SF_NOTIFY_AUTHENT in this fcn
BOOL CHttpRequest::ParseAuthorization(PCSTR pszMethod, TOKEN id)
{
    DEBUG_CODE_INIT;
    BOOL ret = FALSE;
    PSTR pszTok=0;
    int iLen=0;

// get the auth scheme (first token after "Authorization;")
    if (!m_bufRequest.NextTokenWS(&pszTok, &iLen) || !pszTok || !iLen)
        myretleave(FALSE, 91);

    m_pszAuthType = MySzDupA(pszTok);

    if (g_pVars->m_fBasicAuth && 0==strcmpi(pszTok, cszBasic))
    {
        // get the scheme auth data (second token) [NOTE: cant get 2 tokens at once!!]
        if (!m_bufRequest.NextTokenWS(&pszTok, &iLen) || !pszTok || !iLen)
            myretleave(FALSE, 92);


        if (!HandleBasicAuth(pszTok, &m_pszRemoteUser, &m_pszPassword,
                             &m_AuthLevelGranted, &m_NTLMState,m_wszVRootUserList))
            myretleave(TRUE, 93);

        TraceTag(ttidWebServer, "Basic Auth SUCCESS");
        m_dwAuthFlags |= m_AuthLevelGranted;
        ret = TRUE;
    }

    else if (g_pVars->m_fNTLMAuth && 0==strcmpi(pszTok, cszNTLM))
    {
        // get the scheme auth data (second token) [NOTE: cant get 2 tokens at once!!]
        if (!m_bufRequest.NextTokenWS(&pszTok, &iLen) || !pszTok || !iLen)
            myretleave(FALSE, 95);

        if (!HandleNTLMAuth(pszTok))
            myretleave(TRUE, 96);

        TraceTag(ttidWebServer, "NTLM Auth SUCCESS");
        ret = TRUE;
    }

    // We read in this data anyway.  A filter could theoretically set an Access-denied
    // even if neither NTLM or basic weren't set.  AuthenticateFilter will handle
    // this data later in that case.
    // We store data in m_pszRawRemoteUser because it hasn't been Base64 decoded yet
    else
    {
        // get the scheme auth data (second token) [NOTE: cant get 2 tokens at once!!]
        if (!m_bufRequest.NextTokenWS(&pszTok, &iLen) || !pszTok || !iLen)
            myretleave(FALSE, 97);


        m_pszRawRemoteUser = MySzDupA(pszTok);
        if (NULL == m_pszRemoteUser)
            myretleave(FALSE, 98);

        TraceTag(ttidWebServer, "Unknown authorization type requested OR requested type not enabled");
    }

    done:
    TraceTag(ttidWebServer, "Auth FAILED (err=%d ret=%d)", err, ret);

    return ret;
}

BOOL CHttpRequest::ParseConnection(PCSTR pszMethod, TOKEN id)
{
    PSTR pszTok = 0;
    int iLen = 0;

// get first token after "Connnection;"
    if (m_bufRequest.NextTokenWS(&pszTok, &iLen) && pszTok && iLen)
    {
        if (0==strcmpi(pszTok, cszKeepAlive))
            m_fKeepAlive = TRUE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\utilmemf.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utilmemf.cxx

Abstract:

    Miscellaneous useful utilities

Author:

    Sergey Solyanik (SergeyS)

--*/
#include "pch.h"
#pragma hdrstop


#include <svsutil.hxx>

//
//  Fixed memory sector
//
struct FixedMemList
{
    union
    {
        unsigned char ucaPlaceholder[SVSUTIL_MAX_ALIGNMENT];
        struct FixedMemList *pfmlNext;
    } u;

    unsigned char bData[1];
};

struct FixedMemDescr
{
    void                **ppvFreeList;
    FixedMemList        *pfml;

    CRITICAL_SECTION    *pcs;

    unsigned int        uiBlockSize;
    unsigned int        uiBlockIncr;
    unsigned int        uiListSize;
};

FixedMemDescr *svsutil_AllocFixedMemDescr (unsigned int a_uiBlockSize, unsigned int a_uiBlockIncr) {
    SVSUTIL_ASSERT (a_uiBlockSize);
    SVSUTIL_ASSERT (a_uiBlockIncr);

    if (a_uiBlockSize < sizeof(void *))
        a_uiBlockSize = sizeof (void *);

    FixedMemDescr *pfmd = (FixedMemDescr *)g_funcAlloc (sizeof(FixedMemDescr), g_pvAllocData);

    if (! pfmd)
        return NULL;

    pfmd->ppvFreeList = NULL;
    pfmd->pfml        = NULL;
    pfmd->pcs         = NULL;
    pfmd->uiBlockSize = a_uiBlockSize;
    pfmd->uiBlockIncr = a_uiBlockIncr;

    pfmd->uiListSize  = offsetof (FixedMemList, bData) + a_uiBlockSize * a_uiBlockIncr;

    return pfmd;
}

FixedMemDescr *svsutil_AllocFixedMemDescrSynch (unsigned int a_uiBlockSize, unsigned int a_uiBlockIncr, CRITICAL_SECTION *a_pcs) {
    SVSUTIL_ASSERT (a_uiBlockSize);
    SVSUTIL_ASSERT (a_uiBlockIncr);
    SVSUTIL_ASSERT (a_pcs);

    if (a_uiBlockSize < sizeof(void *))
        a_uiBlockSize = sizeof (void *);

    FixedMemDescr *pfmd = (FixedMemDescr *)g_funcAlloc (sizeof(FixedMemDescr), g_pvAllocData);

    if (! pfmd)
        return NULL;

    pfmd->ppvFreeList = NULL;
    pfmd->pfml        = NULL;
    pfmd->pcs         = a_pcs;
    pfmd->uiBlockSize = a_uiBlockSize;
    pfmd->uiBlockIncr = a_uiBlockIncr;

    pfmd->uiListSize  = offsetof (FixedMemList, bData) + a_uiBlockSize * a_uiBlockIncr;

    return pfmd;
}

int svsutil_IsFixedEmpty (FixedMemDescr *a_pfmd) {
    return a_pfmd->pfml == NULL;
}

int svsutil_FixedBlockSize (FixedMemDescr *a_pfmd) {
    return a_pfmd->uiBlockSize;
}

void *svsutil_GetFixed (FixedMemDescr *a_pfmd) {
    if (a_pfmd->pcs)
        EnterCriticalSection (a_pfmd->pcs);

    if (! a_pfmd->ppvFreeList)
    {
        FixedMemList *pfml = (FixedMemList *)g_funcAlloc (a_pfmd->uiListSize, g_pvAllocData);
        pfml->u.pfmlNext = a_pfmd->pfml;
        a_pfmd->pfml = pfml;

        a_pfmd->ppvFreeList = (void **)&pfml->bData[0];

        unsigned char *pucRunner = (unsigned char *)a_pfmd->ppvFreeList;
        unsigned char *pucEndRun = ((unsigned char *)pfml) + a_pfmd->uiListSize;

        for ( ; ; )
        {
            unsigned char *pucRunnerNext = pucRunner + a_pfmd->uiBlockSize;

            if (pucRunnerNext >= pucEndRun)
            {
                *(void **)pucRunner = NULL;
                break;
            }

            *(void **)pucRunner = (void *)pucRunnerNext;
            pucRunner = pucRunnerNext;
        }
    }

    void *pvPtr = (void *)a_pfmd->ppvFreeList;
    a_pfmd->ppvFreeList = (void **)*a_pfmd->ppvFreeList;

    if (a_pfmd->pcs)
        LeaveCriticalSection (a_pfmd->pcs);

    return pvPtr;
}

void svsutil_FreeFixed (void *pvData, FixedMemDescr *a_pfmd) {
    if (a_pfmd->pcs)
        EnterCriticalSection (a_pfmd->pcs);

#if defined (SVSUTIL_DEBUG_HEAP)
    void **ppvFreeList = a_pfmd->ppvFreeList;

    while (ppvFreeList)
    {
        SVSUTIL_ASSERT(pvData != ppvFreeList);          // Otherwise has already been freed
        ppvFreeList = (void **)*ppvFreeList;
    }

    FixedMemList *pfml = a_pfmd->pfml;
    while (pfml)
    {
        if ((pvData > pfml) && (pvData < ((unsigned char *)pfml + a_pfmd->uiListSize)))
            break;

        pfml = pfml->u.pfmlNext;
    }

    SVSUTIL_ASSERT (pfml);                              // Otherwise not part of any block!

    memset (pvData, 0xff, a_pfmd->uiBlockSize);

#endif
    *(void **)pvData = (void *)a_pfmd->ppvFreeList;
    a_pfmd->ppvFreeList = (void **)pvData;

    if (a_pfmd->pcs)
        LeaveCriticalSection (a_pfmd->pcs);
}

void svsutil_ReleaseFixedNonEmpty (FixedMemDescr *a_pfmd) {
    if (a_pfmd->pcs)
        EnterCriticalSection (a_pfmd->pcs);

    FixedMemList *pfml = a_pfmd->pfml;

    while (pfml)
    {
        FixedMemList *pfmlNext = pfml->u.pfmlNext;

        g_funcFree (pfml, g_pvFreeData);

        pfml = pfmlNext;
    }

    if (a_pfmd->pcs)
        LeaveCriticalSection (a_pfmd->pcs);

    g_funcFree (a_pfmd, g_pvFreeData);
}

void svsutil_ReleaseFixedEmpty (FixedMemDescr *a_pfmd) {
    if (a_pfmd->pcs)
        EnterCriticalSection (a_pfmd->pcs);

#if defined (SVSUTIL_DEBUG_HEAP)
    unsigned int uiBlockCount = 0;
    void **ppvRunner = a_pfmd->ppvFreeList;

    while (ppvRunner)
    {
        ++uiBlockCount;
        ppvRunner = (void **)*ppvRunner;
    }

    unsigned int uiBlockCount2 = 0;

    FixedMemList *pfmlRunner = a_pfmd->pfml;
    while (pfmlRunner)
    {
        uiBlockCount2 += a_pfmd->uiBlockIncr;
        pfmlRunner = pfmlRunner->u.pfmlNext;
    }

    SVSUTIL_ASSERT (uiBlockCount == uiBlockCount2);
#endif
    if (a_pfmd->pcs)
        LeaveCriticalSection (a_pfmd->pcs);

    svsutil_ReleaseFixedNonEmpty (a_pfmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\log.cpp ===
/*--
Copyright (c) 1999  Microsoft Corporation
Module Name: LOG.CPP
Author: John Spaith
Abstract: Logging functions
--*/

#include "pch.h"
#pragma hdrstop


//  Responsible for log handling functions.
//  A curhttpd.log and prvhttpd.log keep track of current and the previous
//  changes.  The format for each line is stolen from IIS, except that we
//  include the date in each line; they create a new log for each day.


#include "httpd.h"

#ifdef WEB_SERVER_LOGGING

// const char cszDateOutputFmt[]     = "%3s, %02d %3s %04d %02d:%02d:%02d ";

#define CURRENT_LOG_NAME L"\\current-httpd.log"
#define PREVIOUS_LOG_NAME L"\\previous-httpd.log"
#define LOG_REMOTE_ADDR_SIZE 50
#define LOG_EXTRA_BUFFER_LEN 100

void CLog::WriteEvent(DWORD dwEvent,...)
{
    CHAR szOutput[MINBUFSIZE];
    WCHAR wszFormat[512];
    WCHAR wszOutput[512];
    PSTR pszTrav = szOutput;
    SYSTEMTIME st;
    va_list ap;

    if (!LoadString(g_hInst,dwEvent,wszFormat,celems(wszFormat)))
        return;

    va_start(ap,dwEvent);
    wvsprintf(wszOutput,wszFormat,ap);
    va_end (ap);

    GetSystemTime(&st);
    pszTrav = WriteHTTPDate(szOutput,&st,FALSE);

    pszTrav += MyW2A(wszOutput,pszTrav,MINBUFSIZE - (pszTrav - szOutput)) - 1;
    WriteData(szOutput,pszTrav - szOutput);
}

CLog::~CLog()
{
    WriteEvent(IDS_HTTPD_SHUTDOWN_COMPLETE);
    MyCloseHandle(m_hLog);
    DeleteCriticalSection(&m_CritSection);
}

#define MAX_LOG_OPEN_ATTEMPTS  15

CLog::CLog(DWORD_PTR dwMaxFileLen, WCHAR * lpszLogDir)
{
    int i;

    memset(this, 0, sizeof(*this));
    if (0 == dwMaxFileLen || NULL == lpszLogDir)
    {
        TraceTag(ttidWebServer, "HTTPD: No logging to be performed, because of on registry settings");
        m_hLog = INVALID_HANDLE_VALUE;
        return;
    }

    m_dwMaxFileSize = dwMaxFileLen;
    InitializeCriticalSection(&m_CritSection);
    TraceTag(ttidWebServer, "HTTPD: Initializing log files");


    // remove trailing "\" if log file dir entry ends in it
    if ( lpszLogDir[wcslen(lpszLogDir) - 1] == L'\\')
        lpszLogDir[wcslen(lpszLogDir) - 1] = L'\0';


    wsprintf(lpszCurrentLog,L"%s%s",lpszLogDir, CURRENT_LOG_NAME);
    wsprintf(lpszPrevLog,L"%s%s",lpszLogDir,PREVIOUS_LOG_NAME);


    // Note:  It's possible that the log file is being written to a flash
    // drive, in which case the web server initialization routines would
    // be called before the drive is ready during boot time, in which
    // case we get an INVALID_HANDLE_VALUE.  To make sure the drive has
    // time to initialize, we go through this loop before failing.
    for (i = 0; i < MAX_LOG_OPEN_ATTEMPTS; i++)
    {
        if (INVALID_HANDLE_VALUE != (m_hLog = MyOpenAppendFile(lpszCurrentLog)))
        {
            break;
        }
        Sleep(1000);
    }

    if (INVALID_HANDLE_VALUE == m_hLog)
    {
        TraceTag(ttidWebServer, "HTTPD: CreateFile fails for log <<%s>>, no logging will be done, GLE=0x%08x",lpszCurrentLog,GetLastError());
        return;
    }

    m_dwFileSize = GetFileSize(m_hLog,NULL);
    if ((DWORD)-1 == m_dwFileSize)
    {
        TraceTag(ttidWebServer, "HTTPD: Get file size on log <<%s>> failed, err = %d",lpszCurrentLog,GetLastError());
        m_hLog = INVALID_HANDLE_VALUE;
        return;
    }

    if (m_dwFileSize != 0)          // This moves filePtr to append log file
    {
        if ((DWORD)-1 == SetFilePointer(m_hLog, (DWORD)m_dwFileSize, NULL, FILE_BEGIN))
        {
            TraceTag(ttidWebServer, "HTTPD: Get file size on log %s failed, err = %d",lpszCurrentLog,GetLastError());
            m_hLog = INVALID_HANDLE_VALUE;
            return;
        }
    }

    WriteEvent(IDS_HTTPD_STARTUP);
}



//  The log written has the following format
//  (DATE) (TIME) (IP of requester) (Method) (Request-URI) (Status returned)

//  DATE is in the same format as the recommended one for httpd headers
//  TIME is GMT

void CLog::WriteLog(CHttpRequest* pRequest)
{
    CHAR szBuffer[MINBUFSIZE];
    PSTR psz = szBuffer;
    DWORD_PTR dwToWrite = 0;

    DEBUGCHK(pRequest != NULL);

    if (INVALID_HANDLE_VALUE == m_hLog)  // no logging setup in reg, or prev failure
        return;

    // Make sure that buffer is big enough for filter additions, append if not so
    // We add LOG_EXTRA_BUFFER_LEN to account for date, spaces, and HTTP status code.
    DWORD cbNeeded = LOG_EXTRA_BUFFER_LEN + pRequest->GetLogBufferSize();

    if (cbNeeded > MINBUFSIZE)
    {
        psz = MyRgAllocNZ(CHAR,cbNeeded);
        if (!psz)
            return;
    }

    pRequest->GenerateLog(psz,&dwToWrite);
    WriteData(psz,dwToWrite);

    if (szBuffer != psz)
        MyFree(psz);
}

void CLog::WriteData(PSTR szBuffer, DWORD_PTR dwToWrite)
{
    DWORD dwWritten = 0;

    EnterCriticalSection(&m_CritSection);
    {
        m_dwFileSize += dwToWrite;
        // roll over the logs once the maximum size has been reached.
        if (m_dwFileSize > m_dwMaxFileSize)
        {
            MyCloseHandle(m_hLog);
            DeleteFile(lpszPrevLog);
            MoveFile(lpszCurrentLog,lpszPrevLog);
            m_hLog = MyOpenAppendFile(lpszCurrentLog);
            m_dwFileSize = dwToWrite;
        }

        if (m_hLog != INVALID_HANDLE_VALUE)
        {
            WriteFile(m_hLog,(LPCVOID) szBuffer,(DWORD)dwToWrite,&dwWritten,NULL);
            TraceTag(ttidWebServer, "HTTPD: Wrote log out to file");
        }
    }
    LeaveCriticalSection(&m_CritSection);
}


// Returns the size of the buffer we'll need.
DWORD CHttpRequest::GetLogBufferSize()
{
    PHTTP_FILTER_LOG pFLog = m_pFInfo ? m_pFInfo->m_pFLog : NULL;
    DWORD cbNeeded;

    // remotehost
    if (pFLog && pFLog->pszClientHostName)
        cbNeeded = strlen(pFLog->pszClientHostName);
    else
        cbNeeded = LOG_REMOTE_ADDR_SIZE;

    if (pFLog && pFLog->pszOperation)
        cbNeeded += strlen(pFLog->pszOperation);
    else if (m_pszMethod)
        cbNeeded += strlen(m_pszMethod);

    if (pFLog && pFLog->pszTarget)
        cbNeeded += strlen(pFLog->pszTarget);
    else if (m_pszURL)
        cbNeeded += strlen(m_pszURL);

    if (m_pszLogParam)
        cbNeeded += strlen(m_pszLogParam);

    return cbNeeded;
}



//  Generates the log.  First this fcn sees if a filter has created a new
//  logging structure, in which case valid data in pFLog will override actual
//  server data.  In the typical case we just use CHttpRequest info.

void CHttpRequest::GenerateLog(PSTR szBuffer, DWORD_PTR *pdwToWrite)
{
    SYSTEMTIME st;
    PSTR pszTarget = NULL;
    PSTR pszTrav = szBuffer;
    int i = 0;


    GetSystemTime(&st);     // Use GMT time for the log, too

    PHTTP_FILTER_LOG pFLog = m_pFInfo ? m_pFInfo->m_pFLog : NULL;

    // date and time
    pszTrav = WriteHTTPDate(pszTrav,&st,FALSE);

//  i += sprintf(szBuffer + i, cszDateOutputFmt,
//         rgWkday[st.wDayOfWeek], st.wDay, rgMonth[st.wMonth], st.wYear, st.wHour, st.wMinute, st.wSecond);

    // remotehost
    if (pFLog && pFLog->pszClientHostName)
    {
        pszTrav = strcpyEx(pszTrav,pFLog->pszClientHostName);
    }
    else
    {
        CHAR szAddress[LOG_REMOTE_ADDR_SIZE];
        GetRemoteAddress(m_socket,szAddress);
        pszTrav = strcpyEx(pszTrav,szAddress);
    }
    *pszTrav++ = ' ';

    //  The method (GET, POST, ...)
    if (pFLog && pFLog->pszOperation)
        pszTrav = strcpyEx(pszTrav,pFLog->pszOperation);
    else if (m_pszMethod)
        pszTrav = strcpyEx(pszTrav,m_pszMethod);
    else
        *pszTrav++ = '\t';  // If we get a bad request from browser, m_pszMethod may be NULL.

    *pszTrav++ = ' ';

    // target (URI)
    if (pFLog && pFLog->pszTarget)
        pszTarget = (PSTR) pFLog->pszTarget;
    else
        pszTarget = m_pszURL;


    // like IIS, we convert any spaces in here into "+" signs.
    // NOTES:   IIS does this for both filter changed targets and URLS.
    // It only does it with spaces, doesn't convert \r\n, tabs, or any other escape
    // characters

    if (pszTarget)      // on a bad request, m_pszURL may = NULL.  Check.
    {
        while ( *pszTarget)
        {
            if ( *pszTarget == ' ')
                *pszTrav++ = '+';
            else
                *pszTrav++ = *pszTarget;
            pszTarget++;
        }
    }
    *pszTrav++ = ' ';


    // status
    if (pFLog)
        _itoa(pFLog->dwHttpStatus,pszTrav,10);
    else
        _itoa(rgStatus[m_rs].dwStatusNumber,pszTrav,10);
    pszTrav = strchr(pszTrav,'\0');
    *pszTrav++ = ' ';

    if (m_pszLogParam)    // ISAPI Extension logging has modified something
        pszTrav = strcpyEx(pszTrav,m_pszLogParam);
    *pszTrav++ = '\r';
    *pszTrav++ = '\n';
    *pszTrav= '\0';


    *pdwToWrite = pszTrav - szBuffer;
    return;
}

#endif //!WEB_SERVER_LOGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\response.cpp ===
/*--
Copyright (c) 1995-1998  Microsoft Corporation
Module Name: CONNECT.CPP
Author: Arul Menezes
Abstract: All the constant data used by the HTTP daemon
--*/
#include "pch.h"
#pragma hdrstop

#include "httpd.h"

const char* rgWkday[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", 0};
const char* rgMonth[] = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", 0};

const char cszServerID[]    = "UPnP/1.0";
const char cszProductID[]   = "UPnP Device Host/1.0";
// const char cszRespStatus[]  = "HTTP/1.0 %d %s\r\n";
const char cszRespStatus[]  = "HTTP/1.0 ";

// const char cszRespServer[]  = "Server: %s\r\n";
const char cszRespServer2[]  = "Server: ";
// const char cszRespType[]    = "Content-Type: %s\r\n";
const char cszRespType2[]    = "Content-Type: ";
// const char cszRespLength[]  = "Content-Length: %d\r\n";
const char cszRespLength2[]  = "Content-Length: ";

// const char cszRespWWWAuthBasic[] = "WWW-Authenticate: Basic\r\n";
const char cszRespWWWAuthBasic2[] = "WWW-Authenticate: Basic";
const char cszRespWWWAuthNTLM[] = "WWW-Authenticate: NTLM";
// const char cszDateFmt[]     = "%3s, %02d %3s %04d %02d:%02d:%02d GMT\r\n";
const char cszRespDate[]    = "Date: ";
// const char cszRespLocation[]="Location: %s\r\n";
const char cszRespLocation2[]="Location: ";

// const char cszConnection[]  = "Connection: %s\r\n";
const char cszConnection2[]  = "Connection: ";
const char cszKeepAlive[]   = "keep-alive";
const char cszClose[]       = "close";
const char cszCRLF[]        = "\r\n";
const char cszRespLastMod[] = "Last-Modified: ";


#define APPENDCRLF(psz)     { *psz++ = '\r';  *psz++ = '\n'; }





// The order of items in this table must match that in enum RESPONSESTATUS

// This is not international safe!  In new version, we fill the table on
// httpd initialization with string from the rc file.
/*
STATUSINFO rgStatus[STATUS_MAX] = {
{ 200, "OK", NULL },
{ 302, "Object Moved", "<head><title>Object Moved</title></head><body><h1>Object Moved</h1>This object has moved to "},
{ 304, "Not Modified", NULL }, // body not allowed for 304
{ 400, "Bad Request", "The request was not understood" },
{ 401, "Unauthorized", "Access denied" },
{ 403, "Forbidden", "Access denied" },
{ 404, "Object Not Found", "The requested URL was not found" },
{ 500, "Internal Server Error", "The server encountered an error" },
{ 501, "Not Implemented", "This method is not implemented" },
};
*/


STATUSINFO rgStatus[STATUS_MAX] = {
    { 200, "OK", NULL},                    // no body!
    { 301, "Object Moved", NULL},
    { 304, "Not Modified", NULL},          // body not allowed for 304
    { 400, "Bad Request", NULL},
    { 401, "Unauthorized", NULL},
    { 403, "Forbidden", NULL},
    { 404, "Object Not Found", NULL},
    { 500, "Internal Server Error", NULL},
    { 501, "Not Implemented", NULL},
    { 505, "HTTP Version Not Supported", NULL},
};

#define LCID_USA    MAKELANGID(LAND_ENGLISH, SUBLANG_ENGLISH_US);


int SendData(SOCKET sock, const char FAR *pszBuffData, int cbBuffLen, int flags)
{
    // assumption - sock is a blocking one
    char FAR *pszTempBuff ;
    int nBytesSent = 0;
    int retVal = cbBuffLen ;

    pszTempBuff = (char FAR*)pszBuffData ;
    
    while ( cbBuffLen > 0 )
    {
        if((nBytesSent = send(sock, pszTempBuff, cbBuffLen, flags)) == SOCKET_ERROR)
        {
            retVal = SOCKET_ERROR; 
            TraceTag(ttidWebServer, "Send RESPONSE Data failed! - %d",WSAGetLastError());
            break;
        }
        if( nBytesSent <= 0 )
        {   // XXX it may be that nBytesSent is zero. There is no simple solution other than
            // doing a select until the socket becomes writeable. For now, we want to make
            // sure that we make progress in the loop and ensure termination, so we will
            // just break out if this happens.
            retVal = SOCKET_ERROR; 
            TraceTag(ttidWebServer, "Send RESPONSE Data failed! zero bytes sent - %d",WSAGetLastError());
            break;
        }
        
        cbBuffLen -= nBytesSent;
        pszTempBuff += nBytesSent;
    }

    return retVal;
}

void CHttpResponse::SendHeaders(PCSTR pszExtraHeaders, PCSTR pszNewRespStatus)
{
    DEBUG_CODE_INIT;
    CHAR szBuf[HEADERBUFSIZE];
    PSTR pszBuf = szBuf;

    PSTR pszTrav;
    int iLen;
    DWORD cbNeeded ;

    PSTR pszFilterHeaders = NULL;

    if ( g_pVars->m_fFilters &&
         ! m_pRequest->CallFilter(SF_NOTIFY_SEND_RESPONSE))
        myleave(97);

    // For HTTP 0.9, we don't send headers back.
    if (m_pRequest->m_dwVersion <= MAKELONG(9, 0))
        myleave(0);


    // We do calculation up front to see if we need a allocate a buffer or not.
    // Certain may be set by an ISAPI Extension, Filter, or ASP
    // and we must do the check to make sure their sum plus http headers server
    // uses will be less than buffer we created.
    cbNeeded = m_pRequest->m_bufRespHeaders.Count()     +
               MyStrlenA(pszExtraHeaders)                 +
               MyStrlenA(pszNewRespStatus)                +
               MyStrlenA(m_pszRedirect)                   +
               MyStrlenA(m_pRequest->m_pszNTLMOutBuf)     +
               ((m_pRequest->m_pFInfo && m_rs == STATUS_UNAUTHORIZED) ?
                MyStrlenA(m_pRequest->m_pFInfo->m_pszDenyHeader) : 0);


    // If what we need for extra + 1000 bytes (for the regular Http headers) is
    // > our buf, allocate a new one

    if (cbNeeded + 1000 > HEADERBUFSIZE)
    {
        if (!(pszBuf = MyRgAllocNZ(CHAR,cbNeeded+1000)))
            myleave(98);
    }
    pszTrav = pszBuf;


//  if (pszNewRespStatus)
//      iLen = sprintf(szBuf,"HTTP/1.0 %s\r\n",pszNewRespStatus);
//  else
//      iLen = sprintf(szBuf, cszRespStatus, rgStatus[m_rs].dwStatusNumber, rgStatus[m_rs].pszStatusText);

// the status line
// ServerSupportFunction on SEND_RESPONSE_HEADER can override the server value
    pszTrav = strcpyEx(pszTrav,cszRespStatus);
    if (pszNewRespStatus)
    {
        pszTrav = strcpyEx(pszTrav,pszNewRespStatus);
    }
    else    // copy the number and value over
    {
        _itoa(rgStatus[m_rs].dwStatusNumber,pszTrav,10);
        pszTrav = strchr(pszTrav,'\0');
        *pszTrav++ = ' ';
        pszTrav = strcpyEx(pszTrav,rgStatus[m_rs].pszStatusText);
    }
    APPENDCRLF(pszTrav);



// GENERAL HEADERS
// the Date line
    SYSTEMTIME st;
    GetSystemTime(&st); // NOTE: Must be GMT!

//  iLen += sprintf(szBuf+iLen, cszDateFmt, rgWkday[st.wDayOfWeek], st.wDay, rgMonth[st.wMonth], st.wYear, st.wHour, st.wMinute, st.wSecond);
    pszTrav = strcpyEx(pszTrav, cszRespDate);
    pszTrav = WriteHTTPDate(pszTrav,&st,TRUE);
//  APPENDCRLF(pszTrav);


// Connection: header
    if (m_connhdr != CONN_NONE)
    {
        //  iLen += sprintf(szBuf+iLen, cszConnection, (m_connhdr==CONN_KEEP ? cszKeepAlive : cszClose));
        pszTrav = strcpyEx(pszTrav,cszConnection2);
        pszTrav = strcpyEx(pszTrav,(m_connhdr==CONN_KEEP ? cszKeepAlive : cszClose));
        APPENDCRLF(pszTrav);
    }

// RESPONSE HEADERS
// the server line
//  iLen += sprintf(szBuf+iLen, cszRespServer, cszServerID);
    pszTrav = strcpyEx(pszTrav,cszRespServer2);
    pszTrav = strcpyEx(pszTrav,g_pVars->m_pszServerID);
    APPENDCRLF(pszTrav);


// the Location header (for redirects)
    if (m_pszRedirect)
    {
        DEBUGCHK(m_rs == STATUS_MOVED);
        // iLen += sprintf(szBuf+iLen, cszRespLocation, m_pszRedirect);
        pszTrav = strcpyEx(pszTrav,cszRespLocation2);
        pszTrav = strcpyEx(pszTrav,m_pszRedirect);
        APPENDCRLF(pszTrav);
    }

// the WWW-Authenticate line
    if (m_rs == STATUS_UNAUTHORIZED)
    {
        // In the middle of an NTLM authentication session
        if (g_pVars->m_fNTLMAuth && m_pRequest->m_pszNTLMOutBuf)
        {
            // iLen += sprintf(szBuf+iLen,"%s %s\r\n",cszRespWWWAuthNTLM,m_pRequest->m_pszNTLMOutBuf);
            pszTrav = strcpyEx(pszTrav,cszRespWWWAuthNTLM);
            *pszTrav++ = ' ';
            pszTrav = strcpyEx(pszTrav,m_pRequest->m_pszNTLMOutBuf);
            APPENDCRLF(pszTrav);
        }
        // If both schemes are enabled, send both back to client and let the browser decide which to use
        else if (g_pVars->m_fBasicAuth && g_pVars->m_fNTLMAuth)
        {
            // iLen += sprintf(szBuf+iLen,"%s\r\n%s",cszRespWWWAuthNTLM,cszRespWWWAuthBasic);
            pszTrav = strcpyEx(pszTrav,cszRespWWWAuthNTLM);
            APPENDCRLF(pszTrav);
            pszTrav = strcpyEx(pszTrav,cszRespWWWAuthBasic2);
            APPENDCRLF(pszTrav);
        }
        else if (g_pVars->m_fBasicAuth)
        {
            // iLen += sprintf(szBuf+iLen, cszRespWWWAuthBasic);
            pszTrav = strcpyEx(pszTrav,cszRespWWWAuthBasic2);
            APPENDCRLF(pszTrav);
        }
        else if (g_pVars->m_fNTLMAuth)
        {
            // iLen += sprintf(szBuf+iLen,"%s\r\n",cszRespWWWAuthNTLM);
            pszTrav = strcpyEx(pszTrav,cszRespWWWAuthNTLM);
            APPENDCRLF(pszTrav);
        }
    }

// ENTITY HEADERS
// the Last-Modified line
    if (m_hFile)
    {
        FILETIME   ft;
        SYSTEMTIME st;
        if ( GetFileTime(m_hFile, NULL, NULL, &ft) &&    // gets filetime in GMT
             FileTimeToSystemTime(&ft, &st) )            // converts GMT filetime to GMT systemtime
        {
            //  iLen += sprintf(szBuf+iLen, cszDateFmt, rgWkday[st.wDayOfWeek], st.wDay, rgMonth[st.wMonth], st.wYear, st.wHour, st.wMinute, st.wSecond);
            pszTrav = strcpyEx(pszTrav, cszRespLastMod);
            pszTrav = WriteHTTPDate(pszTrav,&st,TRUE);
        }
    }


// the Content-Type line

    if (m_pszType)
    {
        //  iLen += sprintf(szBuf+iLen, cszRespType, m_pszType);
        pszTrav = strcpyEx(pszTrav,cszRespType2);
        pszTrav = strcpyEx(pszTrav,m_pszType);
        APPENDCRLF(pszTrav);
    }
// the Content-Length line
    if (m_dwLength)
    {
        // If we have a file that is 0 length, it is set to -1.
        if (m_dwLength == -1)
            m_dwLength = 0;
        //  iLen += sprintf(szBuf+iLen, cszRespLength, m_dwLength);
        pszTrav = strcpyEx(pszTrav,cszRespLength2);
        _itoa(m_dwLength,pszTrav,10);
        pszTrav = strchr(pszTrav,'\0');
        APPENDCRLF(pszTrav);
    }

    if ((m_rs == STATUS_UNAUTHORIZED) && m_pRequest->m_pFInfo && m_pRequest->m_pFInfo->m_pszDenyHeader)
    {
        pszTrav = strcpyEx(pszTrav,m_pRequest->m_pFInfo->m_pszDenyHeader);
        // It's the script's responsibility to add any \r\n to the headers.
    }

    if (m_pRequest->m_bufRespHeaders.Data())
    {
        memcpy(pszTrav,m_pRequest->m_bufRespHeaders.Data(),m_pRequest->m_bufRespHeaders.Count());
        pszTrav += m_pRequest->m_bufRespHeaders.Count();
    }
    // APPENDCRLF(pszTrav);


    if (pszExtraHeaders)
    {
        pszTrav = strcpyEx(pszTrav,pszExtraHeaders);
        // It's the script's responsibility to add any \r\n to the headers.
    }
    else
    {
        APPENDCRLF(pszTrav);    // the double CRLF signifies that header data is at an end
    }

    *pszTrav = 0;

    pszFilterHeaders = pszBuf;      // pointer may be modified, don't loose original pszBuf ptr

    iLen = (int)((INT_PTR)(pszTrav - pszBuf));
    if (g_pVars->m_fFilters &&
        ! m_pRequest->CallFilter(SF_NOTIFY_SEND_RAW_DATA, &pszFilterHeaders, &iLen))
        myleave(99);

    iLen = SendData(m_socket,pszFilterHeaders,iLen,0);
   
    done:
    TraceTag(ttidWebServer, "Sending RESPONSE HEADER<<%s>>", pszFilterHeaders);

    if (pszBuf != szBuf)
        MyFree(pszBuf);
}


void CHttpResponse::SendBody(void)
{
    if (TOK_HEAD == m_pRequest->m_idMethod)
        return;

    if (m_hFile)
        SendFile(m_socket, m_hFile, m_pRequest);
    else if (m_pszBody)
    {
        PSTR pszSendBuf = (PSTR) m_pszBody;
        int cbSendBuf = m_dwLength;

        if (g_pVars->m_fFilters &&
            ! m_pRequest->CallFilter(SF_NOTIFY_SEND_RAW_DATA, &pszSendBuf, &cbSendBuf))
        {
            ;
        }
        else  
        {   // send if there's no filters or if filter call succeeded
            SendData(m_socket, pszSendBuf, cbSendBuf, 0);           
        }

        TraceTag(ttidWebServer, "Sending RESPONSE BODY<<%s>> len=%d", pszSendBuf, cbSendBuf);
    }
}

void SendFile(SOCKET sock, HANDLE hFile, CHttpRequest *pRequest)
{
    BYTE bBuf[4096];
    DWORD dwRead;
    PBYTE pszSendBuf;
    int cbSendBuf;
    int nBytesSent = 0;

    while (ReadFile(hFile, bBuf, sizeof(bBuf), &dwRead, 0) && dwRead)
    {
        pszSendBuf = bBuf;
        cbSendBuf = dwRead;

        if (g_pVars->m_fFilters &&
            ! pRequest->CallFilter(SF_NOTIFY_SEND_RAW_DATA, (PSTR*) &pszSendBuf, &cbSendBuf))
        {
            ;
        }
        else  
        {    // send if there's no filters or if filter call succeeded
            if((nBytesSent = SendData(sock, (PSTR) pszSendBuf, cbSendBuf, 0)) == SOCKET_ERROR)
            {
                TraceTag(ttidWebServer, "Send RESPONSE Data failed! - %d",WSAGetLastError());
                break;
            }
            else
            {
                TraceTag(ttidWebServer, "Sending RESPONSE Data - Bytes to be sent = %d bytes sent = %d", dwRead, nBytesSent );
            }
        }
    }

    return;
}


//  This function used to display the message "Object moved
void CHttpResponse::SendRedirect(PCSTR pszRedirect, BOOL fFromFilter)
{
    if (!fFromFilter && m_pRequest->FilterNoResponse())
        return;

    DEBUGCHK(!m_hFile);
    DEBUGCHK(m_rs==STATUS_MOVED);
    // create a body
    PSTR pszBody = MySzAllocA(strlen(rgStatus[m_rs].pszStatusBody)+2*strlen(pszRedirect)+30);
    DWORD dwLen = 0;
    if (pszBody)
    {
        // originally used this string set -- "Moved Permanently", "<head><title>Object Moved</title></head><body><h1>Object Moved</h1>This object has moved to <a HREF=\"%s\">%s</a></body>" },
//          sprintf(pszBody, rgStatus[m_rs].pszStatusBody, pszRedirect, pszRedirect);
        PSTR pszTrav = strcpyEx(pszBody,rgStatus[m_rs].pszStatusBody);
        pszTrav = strcpyEx(pszTrav,"<a href=\"");
        pszTrav = strcpyEx(pszTrav,pszRedirect);
        pszTrav = strcpyEx(pszTrav,"\">");
        pszTrav = strcpyEx(pszTrav,pszRedirect);
        pszTrav = strcpyEx(pszTrav,"</a></body>");
        SetBody(pszBody, cszTextHtml);
    }
    // set redirect header & send all headers, then the synthetic body
    m_pszRedirect = pszRedirect;
    SendHeaders(NULL,NULL);
    SendBody();
    MyFree(pszBody);
}


//  Read strings of the bodies to send on web server errors ("Object not found",
//  "Server Error",...) using load string.  These strings are in wide character
//  format, so we first convert them to regular strings, marching along
//  pszBodyCodes (which is a buffer size BODYSTRINGSIZE).  After the conversion,
//  we set each rgStatus[i].pszStatusBody to the pointer in the buffer.

void InitializeResponseCodes(PSTR pszStatusBodyBuf)
{
    PSTR pszTrav = pszStatusBodyBuf;
    UINT i;
    int iLen;
    WCHAR wszBuf[256];

    for (i = 0; i < ARRAYSIZEOF(rgStatus); i++)
    {
        // no bodies for these
        if (i == STATUS_OK || i == STATUS_NOTMODIFIED)
            continue;

        LoadString(g_hInst,RESBASE_body + i,wszBuf,celems(wszBuf));

        iLen = MyW2A(wszBuf, pszTrav, BODYSTRINGSIZE - (int)((INT_PTR)((pszTrav - pszStatusBodyBuf))));
        if (!iLen)
            return;

        rgStatus[i].pszStatusBody = pszTrav;
        pszTrav += iLen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnphost\udhhttp\vroots.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       V R O O T S . C P P
//
//  Contents:   Implements the virtual root system for the HTTP server
//
//  Notes:
//
//  Author:     danielwe   2000/11/6
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "httpd.h"
#include "ncreg.h"

// Used to split a URL and Path Translated apart for ISAPI/ASP scripts
inline void SetPathInfo(PSTR *ppszPathInfo,PSTR pszInputURL,int iURLLen)
{
    int  iLen = strlen(pszInputURL+iURLLen) + 2;


    // If we've mapped the virtual root "/" to a script, need an extra "/" for the path
    // (normally we use the origial trailing "/", but in this case the "/" is the URL
    // BUGBUG:  Probably should rewrite the Virtual roots parsing
    // mechanism so that it's cleaner.
    *ppszPathInfo = MySzAllocA((iURLLen == 1) ? iLen + 1 : iLen);
    if (! (*ppszPathInfo))
        goto done;

    if (iURLLen == 1)
    {
        (*ppszPathInfo)[0] = '/';
        memcpy( (*ppszPathInfo) +1, pszInputURL + iURLLen, iLen);
    }
    else
        memcpy(*ppszPathInfo, pszInputURL + iURLLen, iLen);


done:
    // URL shouldn't contain path info, break it apart
    pszInputURL[iURLLen] = 0;
}


PVROOTINFO CVRoots::MatchVRoot(PCSTR pszInputURL, int iInputLen)
{
    int i, iMatch;

    // If there was an error on setting up the vroots, m_pVRoots = NULL.
    if (!m_pVRoots)
        return NULL;

    for(i=0, iMatch=-1; i<m_nVRoots; i++)
    {
        int iLen = m_pVRoots[i].iURLLen;

        // If this root maps to physical path "\", special case.
        // In general we store pszURL without trailing "/", however we have
        // to store trailing "/" for root directory.

        if (m_pVRoots[i].bRootDir && iLen != 1)
            iLen--;

        if(iLen && iInputLen >= iLen)
        {
            if(0 == _memicmp(pszInputURL, m_pVRoots[i].pszURL, iLen))
            {
                // If it's not root dir, always matched.  Otherwise it's possible
                // there wasn't a match.  For root dirs, pszURL[iLen] is always "/"

                if (!m_pVRoots[i].bRootDir || m_pVRoots[i].iURLLen == 1 || pszInputURL[iLen] == '/' || pszInputURL[iLen] == '\0')
                {
                    TraceTag(ttidWebServer, "URL %s matched VRoot %s (path %S, perm=%d, auth=%d)",
                             pszInputURL, m_pVRoots[i].pszURL,
                             m_pVRoots[i].wszPath,
                             m_pVRoots[i].dwPermissions,
                             m_pVRoots[i].AuthLevel);
                    return &(m_pVRoots[i]);
                }
            }
        }
    }
    TraceTag(ttidWebServer, "URL %s did not matched any VRoot", pszInputURL);
    return NULL;
}

BOOL CVRoots::FillVRoot(PVROOTINFO pvr, LPWSTR wszURL, LPWSTR wszPath)
{
    int err  = 0;       //  err variable is used in non-Debug mode
    const char cszDLL[] = ".dll";
    const char cszASP[] = ".asp";

    CHAR pszURL[MAX_PATH+1];
    CHAR pszPath[MAX_PATH+1];
    // convert URL to MBCS
    int iLen = pvr->iURLLen = MyW2A(wszURL, pszURL, sizeof(pszURL));
    if(!iLen)
        { myleave(83); }

    pvr->iURLLen--; // -1 for null-term

    pvr->iPathLen = wcslen(wszPath);
    MyW2A(wszPath, pszPath, sizeof(pszPath));


    // check to see if Vroot ends in .dll or .asp, in this case we send
    // client not to the directory but to the script page.
    if  (pvr->iPathLen >= sizeof(cszDLL) &&
         0 == strcmpi(pszPath + pvr->iPathLen - sizeof(cszDLL) +1,cszDLL))
    {
        pvr->ScriptType = SCRIPT_TYPE_EXTENSION;
    }
    else if (pvr->iPathLen >= sizeof(cszASP) &&
         0 == strcmpi(pszPath + pvr->iPathLen - sizeof(cszASP) +1,cszASP))
    {
        pvr->ScriptType = SCRIPT_TYPE_ASP;
    }
    else
    {
        pvr->ScriptType = SCRIPT_TYPE_NONE;
    }

    // If one of URL or path ends in a slash, the other must too.
    // If either the URL ends in a "/" or when the path ends in "\", we remove
    // the extra symbol.  However, in the case where either URL or path is
    // root we don't do this.

    if (pvr->iURLLen != 1 && pszURL[pvr->iURLLen-1]=='/')
    {
        pszURL[pvr->iURLLen-1] = L'\0';
        pvr->iURLLen--;
    }
    else if (pvr->iURLLen == 1 && pszURL[0]=='/' && pvr->ScriptType == SCRIPT_TYPE_NONE)
    {
        // if it's the root URL, make sure correspinding path ends with "\"
        // (if it's a directory only, leave ASP + ISAPI's alone)
        if (wszPath[pvr->iPathLen-1] != L'\\')
        {
            wszPath[pvr->iPathLen] = L'\\';
            pvr->iPathLen++;
            wszPath[pvr->iPathLen] = L'\0';
        }
    }

    // If Path ends in "\" (and it's not the root path or root virtual root)
    // remove the "\"
    if (pvr->iURLLen != 1 && pvr->iPathLen != 1 && wszPath[pvr->iPathLen-1]==L'\\')
    {
        wszPath[pvr->iPathLen-1] = L'\0';
        pvr->iPathLen--;
    }
    else if (pvr->iPathLen == 1 && wszPath[0]==L'\\')
    {
        // Trailing "/" must match "\".  However, we need a slight HACK to make this work
        if (pszURL[pvr->iURLLen-1] != '/')
        {
            pszURL[pvr->iURLLen] = '/';
            pvr->iURLLen++;
            pszURL[pvr->iURLLen] = '\0';
        }
        pvr->bRootDir = TRUE;
    }

    pvr->pszURL = MySzDupA(pszURL);
    pvr->wszPath = MySzDupW(wszPath);

    // Fill in defaults for these
    pvr->wszUserList = NULL;
    pvr->dwPermissions = HTTP_DEFAULTP_PERMISSIONS;
    pvr->AuthLevel = AUTH_PUBLIC;

    TraceTag(ttidWebServer, "VROOT: (%s)=>(%s) perm=%d auth=%d ScriptType=%d",
             pvr->pszURL, pvr->wszPath, pvr->dwPermissions,
             pvr->AuthLevel,pvr->ScriptType);

done:
    if(err)
    {
        return FALSE;
    }
    return TRUE;
}

VOID CVRoots::Sort()
{
    BOOL fChange;
    int i=0;

    // We now want to sort the VRoots in descending order of URL-length so
    // that when we match we'll find the longest match first!!
    // Using a slow bubble-sort :-(
    do {
        fChange = FALSE;
        for(i=0; i<m_nVRoots-1; i++)
        {
            if(m_pVRoots[i].iURLLen < m_pVRoots[i+1].iURLLen)
            {
                // swap the 2 vroots
                VROOTINFO vtemp = m_pVRoots[i+1];
                m_pVRoots[i+1] = m_pVRoots[i];
                m_pVRoots[i] = vtemp;
                fChange = TRUE;
            }
        }
    } while(fChange);
}

static const WCHAR c_szPrefix[] = L"\\\\?\\";
static const int   c_cchPrefix = celems(c_szPrefix);

BOOL CVRoots::Init()
{
    int err  = 0;       //  err variable is used in non-Debug mode
    int i=0;

    InitializeCriticalSection(&m_csVroot);

    // Registry doesnt allow keynames longer than MAX_PATH so we won't map URL prefixes longer than MAX_PATH
    WCHAR wszURL[MAX_PATH+1];
    WCHAR wszPath[MAX_PATH+1];
    WCHAR   wszPathReal[MAX_PATH + 1] = {0};
    wszURL[0]=wszPath[0]=0;

    // open the VRoots key
    CReg topreg(HKEY_LOCAL_MACHINE, RK_HTTPDVROOTS);

    // allocate space for as many VRoots as we have subkeys
    m_nVRoots = topreg.NumSubkeys();
    if(!m_nVRoots)
        myleave(80);
    // Zero the memory so we know what to deallocate and what not to.
    if(!(m_pVRoots = MyRgAllocZ(VROOTINFO, m_nVRoots)))
        myleave(81);

    // enumerate all subkeys. Their names are URLs, their default value is the corresponding path
    // Note: EnumKey takes sizes in chars, not bytes!
    for(i=0; i<m_nVRoots && topreg.EnumKey(wszURL, CCHSIZEOF(wszURL)); i++)
    {
        CReg subreg(topreg, wszURL);

        // get the unnamed value. Again size is in chars, not bytes.
        if(!subreg.ValueSZ(NULL, wszPath, CCHSIZEOF(wszPath)))
        {
            // iURLLen and iPathLen set to 0 already, so no case of corruption in MatchVRoot
            subreg.Reset();
            continue;
        }
        else
        {
            // Prepend the \\?\ prefix
            //
            lstrcpy(wszPathReal, c_szPrefix);
            lstrcat(wszPathReal, wszPath);

            if (!FillVRoot(&m_pVRoots[i], wszURL, wszPathReal))
                myleave(121);

            m_pVRoots[i].wszUserList = MySzDupW( subreg.ValueSZ(RV_USERLIST));

            // default permissions is Read & Execute
            m_pVRoots[i].dwPermissions = subreg.ValueDW(RV_PERM, HTTP_DEFAULTP_PERMISSIONS);
            // default authentication is public
            m_pVRoots[i].AuthLevel = (AUTHLEVEL)subreg.ValueDW(RV_AUTH, (DWORD)AUTH_PUBLIC);

            // we don't fail if we can't load an extension map
            LoadExtensionMap (&m_pVRoots[i], subreg);
        }

        subreg.Reset();
    }

    Sort();

done:
    if(err)
    {
        TraceTag(ttidWebServer, "CVRoots::ctor FAILED due to err=%d GLE=%d "
                 "(num=%d i=%d pVRoots=0x%08x url=%s path=%s)",
                 err, GetLastError(), m_nVRoots, i, m_pVRoots, wszURL, wszPath);
        return FALSE;
    }
    return TRUE;
}

void CVRoots::Cleanup()
{
    if(!m_pVRoots)
        return;
    for(int i=0; i<m_nVRoots; i++)
    {
        MyFree(m_pVRoots[i].pszURL);
        MyFree(m_pVRoots[i].wszPath);
        MyFree(m_pVRoots[i].wszUserList);
        FreeExtensionMap (&m_pVRoots[i]);
    }
    MyFree(m_pVRoots);

    DeleteCriticalSection(&m_csVroot);
}

BOOL CVRoots::AddVRoot(LPWSTR szUrl, LPWSTR szPath)
{
    PVROOTINFO  pvrNew;
    int         err = 0;
    LPSTR       szaUrl = NULL;
    int         iInputLen;

    szaUrl = SzFromWsz(szUrl);
    if (!szaUrl)
    {
        // Can't use myleave since we don't have the critsec here
        //
        err = 400;
        goto err;
    }

    iInputLen = strlen(szaUrl);

    EnterCriticalSection(&m_csVroot);

    pvrNew = MatchVRoot(szaUrl, iInputLen);
    if(pvrNew)
    {
        TraceError("CVRoots::AddVRoot - already present", E_FAIL);
        myleave(10);
    }

    m_pVRoots = MyRgReAlloc(VROOTINFO, m_pVRoots, m_nVRoots, m_nVRoots + 1);
    if(!m_nVRoots)
        myleave(100);

    pvrNew = &m_pVRoots[m_nVRoots];

    if (!FillVRoot(pvrNew, szUrl, szPath))
    {
        myleave(101);
    }

    m_nVRoots++;

    HKEY    hkeyVroot;
    HKEY    hkeyNew;
    HRESULT hr;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, RK_HTTPDVROOTS, KEY_ALL_ACCESS,
                        &hkeyVroot);
    if (SUCCEEDED(hr))
    {
        hr = HrRegCreateKeyEx(hkeyVroot, szUrl, 0, KEY_ALL_ACCESS, NULL,
                              &hkeyNew, NULL);
        if (SUCCEEDED(hr))
        {
            // Pass NULL to set default value
            //
            hr = HrRegSetSz(hkeyNew, NULL, szPath);

            RegCloseKey(hkeyNew);
        }
        RegCloseKey(hkeyVroot);
    }

    if (FAILED(hr))
    {
        TraceError("CVRoots::AddVRoot", hr);
        myleave(111);
    }
    else
    {
        Sort();
    }

done:

    delete [] szaUrl;

    LeaveCriticalSection(&m_csVroot);

err:
    if(err)
    {
        return FALSE;
    }
    return TRUE;
}

BOOL CVRoots::RemoveVRoot(LPWSTR szwUrl)
{
    int         ivr;
    LPSTR       szUrl = NULL;
    PVROOTINFO  pvr;
    int         iInputLen;
    int         err = 0;
    BOOL        fFound = FALSE;

    szUrl = SzFromWsz(szwUrl);
    if (!szUrl)
    {
        myleave(100);
    }

    iInputLen = strlen(szUrl);

    EnterCriticalSection(&m_csVroot);

    pvr = MatchVRoot(szUrl, iInputLen);
    if(!pvr)
    {
        myleave(140);
    }

    for (ivr = 0; ivr < m_nVRoots; ivr++)
    {
        if (&m_pVRoots[ivr] == pvr)
        {
            // Found the one to remove. So now let's shift the rest down by
            // one
            //
            MoveMemory(&m_pVRoots[ivr], &m_pVRoots[ivr + 1],
                       sizeof(VROOTINFO) * (m_nVRoots - ivr - 1));
            m_nVRoots--;
            fFound = TRUE;
            break;
        }
    }

    AssertSz(fFound, "How come it was there a minute ago??");

    HKEY    hkeyVroot;
    HKEY    hkeyNew;
    HRESULT hr;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, RK_HTTPDVROOTS, KEY_ALL_ACCESS,
                        &hkeyVroot);
    if (SUCCEEDED(hr))
    {
        hr = HrRegDeleteKey(hkeyVroot, szwUrl);

        RegCloseKey(hkeyVroot);
    }

    if (FAILED(hr))
    {
        TraceError("CVRoots::RemoveVRoot", hr);
        myleave(111);
    }

    // No need to re-sort since we moved everything down by one

done:
    LeaveCriticalSection(&m_csVroot);

    delete [] szUrl;

    if(err)
    {
        return FALSE;
    }
    return TRUE;
}

PWSTR CVRoots::URLAtoPathW(PSTR pszInputURL, PDWORD pdwPerm /*=0*/,
                           AUTHLEVEL* pAuthLevel /* =0 */,
                           SCRIPT_TYPE *pScriptType /*=0 */,
                           PSTR *ppszPathInfo /* =0 */,
                           WCHAR **ppwszUserList /*=0 */)
{
    PSTR pszEndOfURL;
    WCHAR *wszTemp = NULL;
    int iInputLen = strlen(pszInputURL);

    EnterCriticalSection(&m_csVroot);

    PVROOTINFO pVRoot = MatchVRoot(pszInputURL, iInputLen);
    if(!pVRoot)
    {
        LeaveCriticalSection(&m_csVroot);
        return NULL;
    }

    // Do a lookup to see if the current URL contains and extension
    // that is in the extension map for the VROOT.  If so, this call
    // will truncate the URL after the extension.  Since the URL may
    // have changed, the length is re-obtained on a successfull call.

    if (MapExtToPath (pszInputURL, &pszEndOfURL))
    {
        if (ppszPathInfo && *ppszPathInfo == NULL)
            *ppszPathInfo = MySzDupA (pszInputURL);

        if (*pszEndOfURL != '\0')
        {
            *pszEndOfURL = 0;
            iInputLen = strlen(pszInputURL);
        }
    }

    // in computing the buffersize here we are assuming that an MBCS string of length N
    // cannot produce a unicode string of length greater than N
    int iOutLen = 1 + pVRoot->iPathLen + (iInputLen - pVRoot->iURLLen);
    PWSTR wszOutPath = MyRgAllocNZ(WCHAR, iOutLen);
    if (!wszOutPath)
    {
        LeaveCriticalSection(&m_csVroot);
        return NULL;
    }

    // assemble the path. First, the mapped base path
    memcpy(wszOutPath, pVRoot->wszPath, sizeof(WCHAR)*pVRoot->iPathLen);

    if(pdwPerm)
        *pdwPerm = pVRoot->dwPermissions;
    if(pAuthLevel)
        *pAuthLevel = pVRoot->AuthLevel;
    if (pScriptType)
        *pScriptType = pVRoot->ScriptType;
    if (ppwszUserList)
        *ppwszUserList = pVRoot->wszUserList;

    // If the vroot specifies an ISAPI dll or ASP page don't copy path info over.
    if (pVRoot->ScriptType != SCRIPT_TYPE_NONE)
    {
        if ( ppszPathInfo && pszInputURL[pVRoot->iURLLen] != 0)
        {
            SetPathInfo(ppszPathInfo,pszInputURL,pVRoot->iURLLen);
        }
        wszOutPath[pVRoot->iPathLen] = L'\0';
        LeaveCriticalSection(&m_csVroot);
        return wszOutPath;
    }

    // next the remainder of the URL, converted to wide
    if (iOutLen-pVRoot->iPathLen == 0)
    {
        wszOutPath[pVRoot->iPathLen] = L'\0';
    }
    else
    {
        int iRet = MyA2W(pszInputURL+pVRoot->iURLLen, wszOutPath+pVRoot->iPathLen, iOutLen-pVRoot->iPathLen);
        DEBUGCHK(iRet);
    }

    LeaveCriticalSection(&m_csVroot);

    // Flip forward slashes around to backslashes

    LPWSTR  pchFlip = wszOutPath;

    while (*pchFlip)
    {
        if (*pchFlip == '/')
        {
            *pchFlip = '\\';
        }

        pchFlip++;
    }

    return wszOutPath;
}

BOOL CVRoots::LoadExtensionMap(PVROOTINFO pvr, HKEY rootreg)
{
    BOOL bWildCard;
    WCHAR wszExt[MAX_PATH+1];
    WCHAR wszPath[MAX_PATH+1];

    CReg mapreg(rootreg, RV_EXTENSIONMAP);

    if (!mapreg.IsOK())
    {
        pvr->nExtensions = 0;
        return FALSE;
    }

    if (bWildCard = mapreg.ValueSZ(NULL, wszPath, CCHSIZEOF(wszPath)))
        pvr->nExtensions = 1;
    else
        pvr->nExtensions = mapreg.NumValues();

    if ((pvr->pExtMap = MyRgAllocZ(EXTMAP, pvr->nExtensions)) == NULL)
        return FALSE;

    if (bWildCard)
    {
        pvr->pExtMap[0].wszExt = MySzDupW(L"*");
        pvr->pExtMap[0].wszPath = MySzDupW(wszPath);
        return TRUE;
    }

    for (int i = 0; i < pvr->nExtensions; i++)
    {
        if (mapreg.EnumValue(wszExt, CCHSIZEOF(wszExt),
                             wszPath, CCHSIZEOF(wszPath)))
        {
            if (wszExt[0] != 0 && wszPath[0] != 0)
            {
                pvr->pExtMap[i].wszExt = MySzDupW(wszExt);
                pvr->pExtMap[i].wszPath = MySzDupW(wszPath);
            }
            else
            {
                pvr->pExtMap[i].wszExt = MySzDupW(L"");
                pvr->pExtMap[i].wszPath = MySzDupW(L"");
            }
        }
    }

    return TRUE;
}

void CVRoots::FreeExtensionMap (PVROOTINFO pvr)
{
    if (pvr->pExtMap == NULL) return;

    for (int i=0; i < pvr->nExtensions; i++)
    {
        MyFree(pvr->pExtMap[i].wszExt);
        MyFree(pvr->pExtMap[i].wszPath);
    }

    MyFree(pvr->pExtMap);
    pvr->pExtMap = NULL;
}

PWSTR CVRoots::MapExtToPath (PSTR pszInputURL, PSTR *ppszEndOfURL)
{
    PSTR pszTemp, pszStart, pszEnd;
    PWSTR wszPath = NULL;
    WCHAR wszExt[MAX_PATH+1];
    PVROOTINFO pvr;
    int iInputLen = strlen(pszInputURL);

    if (!FindExtInURL (pszInputURL, &pszStart, &pszEnd))
        return NULL;

    MyA2W (pszStart, wszExt, (int)((INT_PTR)(pszEnd - pszStart)));
    wszExt [pszEnd - pszStart] = L'\0';

    EnterCriticalSection(&m_csVroot);

    if (!(pvr = MatchVRoot(pszInputURL, iInputLen)))
    {
        LeaveCriticalSection(&m_csVroot);
        return NULL;
    }

    for (int i = 0; i < pvr->nExtensions; i++)
    {
        if ((i == 0 && pvr->pExtMap[i].wszExt[0] == L'*') ||
            0 == _wcsicmp (pvr->pExtMap[i].wszExt, wszExt))
        {
            wszPath = pvr->pExtMap[i].wszPath;

            if (ppszEndOfURL != NULL)
                *ppszEndOfURL = pszEnd;

            break;
        }
    }

    LeaveCriticalSection(&m_csVroot);
    return wszPath;
}

BOOL CVRoots::FindExtInURL (PSTR pszInputURL, PSTR *ppszStart, PSTR *ppszEnd)
{
    *ppszStart = strrchr (pszInputURL, '.');

    if ((*ppszEnd = *ppszStart) == NULL)
        return FALSE;

    while (**ppszEnd != '/' && **ppszEnd != '\0')
        *ppszEnd = *ppszEnd + 1;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpreg\upnpreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P N P R E G . C P P
//
//  Contents:   Device host registration command line tool
//
//  Notes:
//
//  Author:     danielwe   30 Jun 2000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "stdio.h"
#include "hostp.h"
#include "hostp_i.c"
#include "ncstring.h"
#include "ncbase.h"
#include "upnphost.h"

// These are defined in registrar.cpp as well. Make sure they are in sync
//
static const DWORD c_csecDefaultLifetime = 1800;
static const DWORD c_csecMinLifetime = 900;

enum COMMAND
{
    CMD_NONE,
    CMD_REGISTER,
    CMD_REREGISTER,
    CMD_UNREGISTER,
};

struct PARAMS
{
    LPWSTR      szXmlDescFile;
    BSTR        bstrProgId;
    BSTR        bstrInitString;
    LPWSTR      szInitStringFile;
    BSTR        bstrContainerId;
    BSTR        bstrResourceDir;
    DWORD       csecLifetime;
    LPWSTR      szOutputFile;
    BSTR        bstrDeviceId;
    BOOL        fPermanent;
};

VOID Usage()
{

    fprintf(stderr, "UPNPREG: A command line tool used to register, unregister and re-register static UPnP devices.\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "The syntax of this command is:\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "UPNPREG register /F device-description /P ProgID [/I init-string | /T init-string] /C container-id /R resource-path /L lifetime [/O device-identifier-out]\n");
    fprintf(stderr, "UPNPREG unregister /D device-identifier /K permanent\n");
    fprintf(stderr, "UPNPREG reregister /D device-identifier /F device-description /P ProgID [/I init-string | /T init-string] /C container-id /R resource-path /L lifetime\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "/F  File containing the XML device description.\n");
    fprintf(stderr, "/P  ProgID of the device object that implements IUPnPDeviceControl. This must be an in-proc COM server.\n");
    fprintf(stderr, "/I  File containing device specific initialization string [Optional]\n");
    fprintf(stderr, "/T  Device specific initialization string [Optional]\n");
    fprintf(stderr, "/C  String identifying the process group in which the device belongs.\n");
    fprintf(stderr, "/R  Location of the resource directory of the device that contains the icons and the service descriptions\n");
    fprintf(stderr, "/L  Lifetime, in seconds, of the device (minimum = 15, default = 30).\n");
    fprintf(stderr, "/O  File that the tool will write the device identifier to (if unspecified, it will write to stdout)\n");
    fprintf(stderr, "/D  Device identifier returned from a call to UPNPREG register, or a call to IUPnPRegistrar::RegisterDevice()\n");
    fprintf(stderr, "/K  Flag to determine if the device should be deleted permanently (TRUE if present)\n");

    exit(0);
}

VOID WriteIdentifierToFile(BSTR bstrId, LPCWSTR szFile)
{
    HANDLE  hFile;
    LPSTR   szaId;
    DWORD   cbWritten = 0;

    CharLowerBuff(bstrId, SysStringLen(bstrId));

    hFile = CreateFile(szFile, GENERIC_WRITE,
                       FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "Failed to open the output file: '%S'. Error = %d\n",
               szFile, GetLastError());

        fprintf(stdout, "%S\n", bstrId);

        return;
    }

    szaId = SzFromWsz(bstrId);

    if (!WriteFile(hFile, (LPVOID)szaId, lstrlenA(szaId), &cbWritten, NULL))
    {
        fprintf(stderr, "Failed to write the output file: '%S'. Error = %d\n",
               szFile, GetLastError());
    }

    delete [] szaId;

    CloseHandle(hFile);
}

BSTR BstrLoadXmlFromFile(LPCWSTR szFile)
{
    HANDLE  hFile;
    HANDLE  hMap;
    LPWSTR  szData;
    DWORD   cbFile;
    LPVOID  pvData;
    BSTR    bstrRet = NULL;

    hFile = CreateFile(szFile, GENERIC_READ,
                       FILE_SHARE_READ, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "Failed to open the file: '%S'. Error = %d\n",
               szFile, GetLastError());
        exit(0);
    }

    cbFile = GetFileSize(hFile, NULL);

    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "Failed to create file mapping for file: '%S'. Error = %d\n",
               szFile, GetLastError());
        exit(0);
    }

    szData = new WCHAR[cbFile + 1];
    if (!szData)
    {
        fprintf(stderr, "Out of memory!\n");
        exit(0);
    }

    pvData = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvData)
    {
        fprintf(stderr, "Failed to map the file: '%S'. Error = %d\n",
               szFile, GetLastError());
        exit(0);
    }

    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, reinterpret_cast<char*>(pvData),
                        cbFile, szData, cbFile);
    szData[cbFile] = 0;

    UnmapViewOfFile(pvData);
    CloseHandle(hMap);
    CloseHandle(hFile);

    bstrRet = SysAllocString(szData);

    delete [] szData;

    return bstrRet;
}

VOID Execute(COMMAND cmd, PARAMS *pparams)
{
    HRESULT             hr;

    switch (cmd)
    {
        case CMD_REGISTER:
            IUPnPRegistrar *    preg;

            hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_LOCAL_SERVER,
                                  IID_IUPnPRegistrar, (LPVOID *)&preg);
            if (SUCCEEDED(hr))
            {
                BSTR    bstrId;
                BSTR    bstrData;
                LPWSTR  szData;

                bstrData = BstrLoadXmlFromFile(pparams->szXmlDescFile);
                if (bstrData)
                {
                    hr = preg->RegisterDevice(bstrData, pparams->bstrProgId,
                                              pparams->bstrInitString,
                                              pparams->bstrContainerId,
                                              pparams->bstrResourceDir,
                                              pparams->csecLifetime, &bstrId);
                    if (SUCCEEDED(hr))
                    {
                        fprintf(stdout, "Successfully registered the device.\n");
                        if (!pparams->szOutputFile)
                        {
                            CharLowerBuff(bstrId, SysStringLen(bstrId));
                            fprintf(stdout, "Device identifier is: %S\n", bstrId);
                        }
                        else
                        {
                            WriteIdentifierToFile(bstrId, pparams->szOutputFile);
                        }

                        SysFreeString(bstrId);
                    }
                    else
                    {
                        fprintf(stderr, "Failed to register the device. "
                               "Error = %08X\n", hr);
                    }
                }
                else
                {
                    fprintf(stderr, "Out of memory!\n");
                    exit(0);
                }

                preg->Release();
            }
            else
            {
                fprintf(stderr, "Failed to create the registrar object! Error = %08X\n",
                       hr);
            }

            break;

        case CMD_REREGISTER:
            IUPnPReregistrar *    prereg;

            hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_LOCAL_SERVER,
                                  IID_IUPnPReregistrar, (LPVOID *)&prereg);
            if (SUCCEEDED(hr))
            {
                BSTR    bstrData;

                bstrData = BstrLoadXmlFromFile(pparams->szXmlDescFile);
                if (bstrData)
                {
                    hr = prereg->ReregisterDevice(pparams->bstrDeviceId,
                                                  bstrData,
                                                  pparams->bstrProgId,
                                                  pparams->bstrInitString,
                                                  pparams->bstrContainerId,
                                                  pparams->bstrResourceDir,
                                                  pparams->csecLifetime);
                    if (SUCCEEDED(hr))
                    {
                        fprintf(stdout, "Successfully re-registered the device.\n");
                    }
                    else
                    {
                        fprintf(stderr, "Failed to re-register the device with ID: %S. "
                               "Error = %08X\n", pparams->bstrDeviceId, hr);
                    }
                }

                prereg->Release();
            }
            else
            {
                fprintf(stderr, "Failed to create the re-registrar object! Error = %08X\n",
                       hr);
            }
            break;

        case CMD_UNREGISTER:
            IUPnPRegistrar *    punreg;

            hr = CoCreateInstance(CLSID_UPnPRegistrar, NULL, CLSCTX_LOCAL_SERVER,
                                  IID_IUPnPRegistrar, (LPVOID *)&punreg);
            if (SUCCEEDED(hr))
            {
                hr = punreg->UnregisterDevice(pparams->bstrDeviceId,
                                              pparams->fPermanent);
                if (SUCCEEDED(hr))
                {
                    fprintf(stdout, "Successfully unregistered the device %S.\n",
                           pparams->bstrDeviceId);
                }
                else
                {
                    fprintf(stderr, "Failed to unregister the device %S. "
                           "Error = %08X\n", pparams->bstrDeviceId, hr);
                }

                punreg->Release();
            }
            else
            {
                fprintf(stderr, "Failed to create the unregistrar object! Error = %08X\n",
                       hr);
            }
            break;

        default:
            AssertSz(FALSE, "Unknown command!");
            break;
    }
}

EXTERN_C
VOID
__cdecl
wmain (
      IN INT     argc,
      IN PCWSTR argv[])
{
    INT         iarg;
    COMMAND     cmd = CMD_NONE;
    PARAMS      params = {0};

    // Quick short-circuit. Any valid command must have at least 4 args
    //
    if (argc < 4)
    {
        Usage();
    }

    if (!lstrcmpi(argv[1], L"register"))
    {
        cmd = CMD_REGISTER;
    }
    else if (!lstrcmpi(argv[1], L"reregister"))
    {
        cmd = CMD_REREGISTER;
    }
    else if (!lstrcmpi(argv[1], L"unregister"))
    {
        cmd = CMD_UNREGISTER;
    }
    else
    {
        Usage();
    }

    Assert(cmd != CMD_NONE);

    params.csecLifetime = c_csecDefaultLifetime;

    for (iarg = 2; iarg < argc; )
    {
        if ((argv[iarg][0] != '-') && (argv[iarg][0] != '/'))
        {
            // Flag prefix is missing
            //
            Usage();
        }

        switch (argv[iarg][1])
        {
            case 'F':
            case 'f':
                if ((argc >= iarg + 2) && (cmd == CMD_REGISTER || cmd == CMD_REREGISTER))
                {
                    params.szXmlDescFile = WszDupWsz(argv[iarg + 1]);
                    fprintf(stdout, "Got description file: %S\n", params.szXmlDescFile);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'P':
            case 'p':
                if ((argc >= iarg + 2) && (cmd == CMD_REGISTER || cmd == CMD_REREGISTER))
                {
                    params.bstrProgId = SysAllocString(argv[iarg + 1]);
                    fprintf(stdout, "Got prog ID: %S\n", params.bstrProgId);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'I':
            case 'i':
                if ((argc >= iarg + 2) &&
                    (cmd == CMD_REGISTER || cmd == CMD_REREGISTER) &&
                    (!params.bstrInitString))
                {
                    params.szInitStringFile = WszDupWsz(argv[iarg + 1]);
                    fprintf(stdout, "Got init string file: %S\n", params.szInitStringFile);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'T':
            case 't':
                if ((argc >= iarg + 2) &&
                    (cmd == CMD_REGISTER || cmd == CMD_REREGISTER) &&
                    (!params.szInitStringFile))
                {
                    params.bstrInitString = SysAllocString(argv[iarg + 1]);
                    fprintf(stdout, "Got init string: %S\n", params.bstrInitString);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'C':
            case 'c':
                if ((argc >= iarg + 2) && (cmd == CMD_REGISTER || cmd == CMD_REREGISTER))
                {
                    params.bstrContainerId = SysAllocString(argv[iarg + 1]);
                    fprintf(stdout, "Got container ID: %S\n", params.bstrContainerId);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'R':
            case 'r':
                if ((argc >= iarg + 2) && (cmd == CMD_REGISTER || cmd == CMD_REREGISTER))
                {
                    params.bstrResourceDir = SysAllocString(argv[iarg + 1]);
                    fprintf(stdout, "Got resource dir: %S\n", params.bstrResourceDir);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'L':
            case 'l':
                if ((argc >= iarg + 2) && (cmd == CMD_REGISTER || cmd == CMD_REREGISTER))
                {
                    params.csecLifetime = wcstoul(argv[iarg + 1], NULL, 10);
                    params.csecLifetime = max(params.csecLifetime, c_csecMinLifetime);
                    fprintf(stdout, "Got lifetime: %d\n", params.csecLifetime);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'O':
            case 'o':
                if ((argc >= iarg + 2) && (cmd == CMD_REGISTER))
                {
                    params.szOutputFile = WszDupWsz(argv[iarg + 1]);
                    fprintf(stdout, "Got output file: %S\n", params.szOutputFile);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'D':
            case 'd':
                if ((argc >= iarg + 2) && (cmd == CMD_UNREGISTER || cmd == CMD_REREGISTER))
                {
                    params.bstrDeviceId = SysAllocString(argv[iarg + 1]);
                    fprintf(stdout, "Got device ID: %S\n", params.bstrDeviceId);
                    iarg += 2;
                }
                else
                {
                    Usage();
                }
                break;

            case 'K':
            case 'k':
                if (cmd == CMD_UNREGISTER)
                {
                    params.fPermanent = TRUE;
                    fprintf(stdout, "Got permanent = TRUE\n");
                    iarg++;
                }
                else
                {
                    Usage();
                }
                break;

            default:
                Usage();
                break;
        }
    }

    fprintf(stdout, "Got all params.. Now validating...\n");

    // Now validate params
    //

    switch (cmd)
    {
        case CMD_REGISTER:
            if ((!params.szXmlDescFile) ||
                (!params.bstrProgId) ||
                (!params.bstrContainerId) ||
                ((!params.szInitStringFile) && (!params.bstrInitString)) ||
                (!params.bstrResourceDir))
            {
                Usage();
            }

            if (!FFileExists(params.szXmlDescFile, FALSE))
            {
                fprintf(stderr, "Description file '%S' does not exist!\n",
                       params.szXmlDescFile);
                exit(0);
            }

            if (!FFileExists(params.bstrResourceDir, TRUE))
            {
                fprintf(stderr, "Resource directory '%S' does not exist!\n",
                       params.bstrResourceDir);
                exit(0);
            }

            // Load the init string from a file if specified
            //
            if (params.szInitStringFile)
            {

                if (!FFileExists(params.szInitStringFile, TRUE))
                {
                    fprintf(stderr, "Init string file '%S' does not exist!\n",
                           params.szInitStringFile);
                    exit(0);
                }

                params.bstrInitString = BstrLoadXmlFromFile(params.szInitStringFile);
                if (!params.bstrInitString)
                {
                    fprintf(stderr, "Out of memory!\n");
                    exit(0);
                }
            }

            break;

        case CMD_REREGISTER:
            if ((!params.szXmlDescFile) ||
                (!params.bstrDeviceId) ||
                (!params.bstrProgId) ||
                ((!params.szInitStringFile) && (!params.bstrInitString)) ||
                (!params.bstrContainerId) ||
                (!params.bstrResourceDir))
            {
                Usage();
            }

            if (!FFileExists(params.szXmlDescFile, FALSE))
            {
                fprintf(stderr, "Description file '%S' does not exist!\n",
                       params.szXmlDescFile);
                exit(0);
            }

            if (!FFileExists(params.bstrResourceDir, TRUE))
            {
                fprintf(stderr, "Resource directory '%S' does not exist!\n",
                       params.bstrResourceDir);
                exit(0);
            }

            // Load the init string from a file if specified
            //
            if (params.szInitStringFile)
            {

                if (!FFileExists(params.szInitStringFile, TRUE))
                {
                    fprintf(stderr, "Init string file '%S' does not exist!\n",
                           params.szInitStringFile);
                    exit(0);
                }

                params.bstrInitString = BstrLoadXmlFromFile(params.szInitStringFile);
                if (!params.bstrInitString)
                {
                    fprintf(stderr, "Out of memory!\n");
                    exit(0);
                }
            }

            break;

        case CMD_UNREGISTER:
            if (!params.bstrDeviceId)
            {
                Usage();
            }
            break;
    }

    fprintf(stdout, "All params are valid.\n");

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                         RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 0, NULL);

    Execute(cmd, &params);

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\upnpreg\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Device Host Registration Tool"
#define VER_INTERNALNAME_STR            "upnpreg.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\utl2idl\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "<UTL To IDL Translator>"
#define VER_INTERNALNAME_STR            "utl2idl.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\clist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C L I S T . H 
//
//  Contents:   Very simple templatized CList. Yes, we could import and use
//              the STL stuff, but that's a real pain for this one class.
//
//  Notes:      
//
//  Author:     jeffspr   9 Dec 1999
//
//----------------------------------------------------------------------------

#ifndef _CLIST_H_
#define _CLIST_H_

#pragma once

// T is the type stored in the list
// K is a type used to search for elements of type T
template<class T, class K> class CList
{
    struct TNode
    {
        TNode * pNext;
        TNode * pPrev;
        T Data;
    };

public:
    inline CList() { m_pRootNode = NULL; m_pCurrentNode = NULL; m_pLastNode = NULL; m_iElements = 0; };
    inline ~CList();
    inline BOOL FAdd(T pNew);
    inline BOOL FDelete(K keyDelete);
    inline BOOL FFirst(T * pItem);
    inline BOOL FNext(T * pItem);
    inline VOID Flush();
    inline int GetCount() { return m_iElements; };
    inline BOOL FFind(K key, T * pItem);

protected:
    inline BOOL FInternalDelete(TNode * pItem);
    virtual BOOL FCompare(T pNode, K key) = 0;
    inline BOOL FInternalFind(K key, TNode ** ppItem);

protected:
    TNode * m_pRootNode;
    TNode * m_pCurrentNode;
    TNode * m_pLastNode;

    int     m_iElements;
};

template <class T, class K> BOOL CList< T, K >::FInternalDelete(TNode * pItem)
{
    Assert(pItem);

    if (pItem->pPrev)
    {
        pItem->pPrev->pNext = pItem->pNext;
    }

    if (pItem->pNext)
    {
        pItem->pNext->pPrev = pItem->pPrev;
    }

    if (m_pRootNode == pItem)
    {
        m_pRootNode = pItem->pNext;
    }

    if (m_pLastNode == pItem)
    {
        m_pLastNode = pItem->pPrev;
    }

    if (m_pCurrentNode == pItem)
    {
        m_pCurrentNode = pItem->pNext;
    }

    delete pItem->Data;
    delete pItem;
    m_iElements--;

    return TRUE;
}

template <class T, class K> CList< T, K >::~CList()
{
    m_pCurrentNode = m_pRootNode;

    while (m_pCurrentNode)
    {
        TNode *pNextNode = m_pCurrentNode->pNext;

        delete m_pCurrentNode;
        m_pCurrentNode = pNextNode;
        m_iElements--;
    }
}

template <class T, class K> BOOL CList< T, K >::FFirst( T * pItem )
{
    m_pCurrentNode = m_pRootNode;
    return FNext(pItem);
}

template <class T, class K> BOOL CList< T, K >::FNext( T * pItem )
{
    BOOL fReturn = FALSE;

    if (m_pCurrentNode)
    {
        *pItem = m_pCurrentNode->Data;
        m_pCurrentNode = m_pCurrentNode->pNext;
        fReturn = TRUE;
    }

    return fReturn;
}

template <class T, class K> BOOL CList< T, K >::FAdd( T ItemToAdd )
{
    TNode * pNewNode = new TNode;
    if (!pNewNode)
    {
        return FALSE;
    }
    else
    {
        pNewNode->Data = ItemToAdd;
        pNewNode->pNext = NULL;
        if (m_pLastNode)
        {
            m_pLastNode->pNext = pNewNode;
            pNewNode->pPrev = m_pLastNode;
        }
        else
        {
            pNewNode->pPrev = NULL;
        }

        m_pLastNode = pNewNode;

        if (!m_pRootNode)
            m_pRootNode = m_pLastNode;

        m_iElements++;
    }

    return TRUE;
}

template <class T, class K> VOID CList< T, K >::Flush()
{
    TNode * pLast = m_pLastNode;

    while (pLast)
    {
        FInternalDelete(pLast);
        pLast = m_pLastNode;
    }

    Assert(m_iElements == 0);
}

template <class T, class K> BOOL CList< T, K >::FDelete(K key)
{
    BOOL    fReturn = FALSE;
    BOOL    fFound  = FALSE;
    TNode * pNode   = NULL;

    fFound = FInternalFind(key, &pNode);
    if (fFound)
    {
        fReturn = FInternalDelete(pNode);
    }

    return fReturn;
}


template <class T, class K> BOOL CList< T, K >::FFind(K key, T * pItem)
{
    BOOL    fReturn     = FALSE;
    TNode * pSearch     = NULL;

    fReturn = FInternalFind(key, &pSearch);
    if (fReturn)
    {
        Assert(pSearch);

        if (pItem)
        {
            *pItem = pSearch->Data;
        }
    }

    return fReturn;
}

template <class T, class K> BOOL CList< T, K >::FInternalFind(K Key, TNode ** ppNode)
{
    BOOL    fReturn     = FALSE;
    BOOL    fFound      = FALSE;
    TNode * pSearch     = NULL;

    pSearch = m_pRootNode;
    while (!fFound && pSearch)
    {
        if (FCompare(pSearch->Data, Key))
        {
            fFound = TRUE;
        }
        else
        {
            pSearch = pSearch->pNext;
        }
    }

    if (fFound)
    {
        fReturn = TRUE;
        if (ppNode)
        {
            *ppNode = pSearch;
        }
    }

    return fReturn;
}

#endif // _CLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\array.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       A R R A Y . H 
//
//  Contents:   Simple array class
//
//  Notes:      
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

template <class Type>
HRESULT HrTypeAssign(Type & dst, const Type & src)
{
    dst = src;
    return S_OK;
}

template <class Type>
void TypeTransfer(Type & dst, Type & src)
{
    dst = src;
}

template <class Type>
void TypeClear(Type & type)
{
    type = Type();
}

const long CUA_NOT_FOUND = -1;

template <class Type>
class CUArray
{
public:
    CUArray() : m_pData(NULL), m_nCount(0), m_nReserve(0) {}
    ~CUArray() 
    {
        Clear();
    }

    // Sizing functions

    HRESULT HrSetReserve(long nReserve)
    {
        // Can't ever shrink
        if(nReserve < m_nReserve || 0 == nReserve)
        {
            return E_INVALIDARG;
        }
        Type * pData = new Type[nReserve];
        if(!pData)
        {
            return E_OUTOFMEMORY;
        }
        // Copy old data
        for(long n = 0; n < m_nCount; ++n)
        {
            TypeTransfer(pData[n], m_pData[n]);
        }
        delete [] m_pData;
        m_pData = pData;
        m_nReserve = nReserve;
        return S_OK;
    }
    HRESULT HrSetCount(long nCount)
    {
        // Can't ever shrink
        if(nCount < m_nCount || 0 == nCount)
        {
            return E_INVALIDARG;
        }
        if(nCount > m_nReserve)
        {
            HRESULT hr = HrSetReserve(nCount);
            if(FAILED(hr))
            {
                return hr;
            }
        }
        m_nCount = nCount;
        return S_OK;
    }
    long GetCount() const
    {
        return m_nCount;
    }
    void Clear()
    {
        delete [] m_pData;
        m_pData = NULL;
        m_nCount = 0;
        m_nReserve = 0;
    }

    // Data access functions

    Type & operator[](long nIndex)
    {
        Assert(nIndex < m_nCount && nIndex >= 0);

        return m_pData[nIndex];
    }
    const Type & operator[](long nIndex) const
    {
        Assert(nIndex < m_nCount && nIndex >= 0);

        return m_pData[nIndex];
    }
    Type * GetData()
    {
        return m_pData;
    }

    // Insertion function

    HRESULT HrPushBack(const Type & type)
    {
        if(m_nCount == m_nReserve)
        {
            // Don't thrash on inserts
            HRESULT hr = HrSetReserve(m_nReserve + 50);
            if(FAILED(hr))
            {
                return hr;
            }
        }
        HRESULT hr = HrTypeAssign(m_pData[m_nCount], type);
        if(SUCCEEDED(hr))
        {
            ++m_nCount;
        }
        return hr;
    }
    HRESULT HrPushBackDefault()
    {
        HRESULT hr = S_OK;
        if(m_nCount == m_nReserve)
        {
            // Don't thrash on inserts
            hr = HrSetReserve(m_nReserve + 50);
        }
        if(SUCCEEDED(hr))
        {
            ++m_nCount;
        }
        return hr;
    }
    Type & Back()
    {
        Assert(m_nCount);
        return m_pData[0];
    }

    HRESULT HrPushBackTransfer(Type & type)
    {
        if(m_nCount == m_nReserve)
        {
            // Don't thrash on inserts
            HRESULT hr = HrSetReserve(m_nReserve + 50);
            if(FAILED(hr))
            {
                return hr;
            }
        }
        TypeTransfer(m_pData[m_nCount], type);
        ++m_nCount;
        return S_OK;
    }

    // Removal

    HRESULT HrPopBack()
    {
        if(!m_nCount)
        {
            return E_UNEXPECTED;
        }
        --m_nCount;
        TypeClear(m_pData[m_nCount]);
        return S_OK;
    }
    HRESULT HrErase(long nIndex)
    {
        if(nIndex < 0 || nIndex >= m_nCount)
        {
            return E_INVALIDARG;
        }
        for(long n = nIndex; n < (m_nCount-1); ++n)
        {
            TypeTransfer(m_pData[n], m_pData[n+1]);
        }
        return HrPopBack();
    }

    // Search

    HRESULT HrFind(const Type & type, long & nIndex) const
    {
        HRESULT hr = E_INVALIDARG;
        for(long n = 0; n < m_nCount; ++n)
        {
            if(type == m_pData[n])
            {
                nIndex = n;
                hr = S_OK;
                break;
            }
        }
        return hr;
    }

    void Swap(CUArray & ref)
    {
        Type * pData = m_pData;
        m_pData = ref.m_pData;
        ref.m_pData = pData;
        long nCount = m_nCount;
        m_nCount = ref.m_nCount;
        ref.m_nCount = nCount;
        long nReserve = m_nReserve;
        m_nReserve = ref.m_nReserve;
        ref.m_nReserve = nReserve;
    }
private:
    CUArray(const CUArray &);
    CUArray & operator=(const CUArray &);

    Type * m_pData;
    long m_nCount;
    long m_nReserve;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\commui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C U I . H
//
//  Contents:   Common user interface routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCUI_H_
#define _NCUI_H_

#include "ncbase.h"

inline
HCURSOR
BeginWaitCursor ()
{
    return SetCursor(LoadCursor(NULL, IDC_WAIT));
}

inline
VOID
EndWaitCursor (
    HCURSOR hcurPrev)
{
    // BeginWaitCursor may return a NULL cursor.  This is just
    // a saftey net.
    //
    if (!hcurPrev)
    {
        hcurPrev = LoadCursor(NULL, IDC_ARROW);
    }
    SetCursor(hcurPrev);
}

// To get an automatic wait cursor, simply declare an instance
// of CWaitCursor.  The cursor will be restored when the instance is
// destroyed.  (i.e. declare it on the stack.)
//
class CWaitCursor
{
private:
    HCURSOR m_hcurPrev;

public:
    CWaitCursor  ()  { m_hcurPrev = BeginWaitCursor (); }
    ~CWaitCursor ()  { EndWaitCursor (m_hcurPrev); }
};


//
// Enables or disables a set of controls in a dialog.
//
// Use this when you're enabling/disabling more than about two controls.
// Be sure to declare the array of control ids as 'static const' if you can.
//
NOTHROW
VOID
EnableOrDisableDialogControls (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    BOOL fEnable);


//
// Map back and forth between a set of radio buttons and a DWORD value.
//
// Be sure to declare the array as 'static const' if you can.
//
struct RADIO_BUTTON_MAP
{
    INT     cid;        // control id of radio button
    DWORD   dwValue;    // value associated with this radio button
};

NOTHROW
BOOL
FMapRadioButtonToValue (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD*		    pdwValue);

NOTHROW
BOOL
FMapValueToRadioButton (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD                   dwValue,
    INT*		    pncid);

#ifdef _INC_SHELLAPI

HRESULT
HrShell_NotifyIcon (
    DWORD dwMessage,
    PNOTIFYICONDATA pData);

#endif // _INC_SHELLAPI

NOTHROW
LRESULT
LresFromHr (
    HRESULT hr);

NOTHROW
INT
WINAPIV
NcMsgBox (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);


NOTHROW
INT
WINAPIV
NcMsgBoxWithVarCaption (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    PCWSTR     szCaptionParam,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);

NOTHROW
INT
WINAPIV
NcMsgBoxWithWin32ErrorText (
    DWORD       dwError,
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdCombineFormat,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);


VOID
SendDlgItemsMessage (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    UINT        unMsg,
    WPARAM      wParam,
    LPARAM      lParam);

VOID
SetDefaultButton(
    HWND hdlg,
    INT iddef);

struct CONTEXTIDMAP
{
    INT     idControl;
    DWORD   dwContextId;
    DWORD   dwContextIdJapan;
};
typedef const CONTEXTIDMAP * PCCONTEXTIDMAP;

VOID OnHelpGeneric(
    HWND hwnd, 
    LPHELPINFO lphi,
    PCCONTEXTIDMAP pContextMap,
    BOOL bJpn, 
    PCWSTR pszHelpFile);

#endif // _NCUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\host\utl2idl\utl2idl.cpp ===
/* utl2idl.cpp
*
* UTL2IDL Tool translates the Service Description of a device to IDL interface.
*
* Owner: Guru
*
* Copyright 1986-2000 Microsoft Corporation, All Rights Reserved.
*/

#include "pch.h"
#pragma hdrstop

#include <msxml2.h>

#include "stdio.h"
#include "Rpcdce.h"

#define MAXSTRLEN 2048
#define MAXSTATEVARIABLES 1024
#define MAXALLOWEDRETVAL  1
#define XMLSTATEVARIABLETAG  "stateVariable"

#define CHECKHR(x) {hr = x; if (FAILED(hr)) {callAbort();}}
#define CHECKHRTRACE(x,ERRORMSG) { hr = x ; if ( FAILED(hr) ) { TraceError(ERRORMSG,hr);/*HrPrintError(ERRORMSG,hr);*/ return hr ;} }
#define CHECKNULL(x,ERRORMSG) { if ( x == NULL ) { hr = E_FAIL; TraceError(ERRORMSG,hr);/*HrPrintError(ERRORMSG,hr);*/ return hr ; }}

#define SAFERELEASE(p) {if (p) {(p)->Release(); p = NULL;}}

// struct definition for XML to IDL DataType mapping
typedef struct {
        BSTR m_XMLDataType ;
        BSTR m_IDLDataType ;
} DTMAPPING ;

// struct definition for maintaing State Variables and its DataType
typedef struct {
        BSTR m_StVarName ;
        BSTR m_StVarType ;
} STATEVARIABLE ;

typedef STATEVARIABLE* PSTATEVARIABLE;

typedef struct {
    STATEVARIABLE **rgStateVariable ;
    long cStVars ;
} STATEVARIABLEINFO ;


STATEVARIABLEINFO g_StateVariableInfo ;

PCWSTR g_pszOutFileName = NULL;
PCWSTR g_pszInputFileName = NULL ;
HANDLE g_hOutFileHandle = NULL;
char g_pszdumpStr[MAXSTRLEN];

unsigned long g_methodID = 0 ;

// XML to IDL DataType Mapping
// XML datatypes are sorted in ascending order

static CONST DTMAPPING g_dataTypeConvtTable[] =
{
    {OLESTR("bin.base64"),OLESTR("SAFEARRAY")}, // check this data type
    {OLESTR("bin.hex"),OLESTR("SAFEARRAY")},
    {OLESTR("boolean"),OLESTR("VARIANT_BOOL")},
    {OLESTR("char"),OLESTR("wchar_t")},
    {OLESTR("date"),OLESTR("DATE")},
    {OLESTR("dateTime"),OLESTR("DATE")},
    {OLESTR("dateTime.tz"),OLESTR("DATE")},
    {OLESTR("fixed.14.4"),OLESTR("CY")},
    {OLESTR("float"),OLESTR("float")},
    {OLESTR("i1"),OLESTR("char")},
    {OLESTR("i2"),OLESTR("short")},
    {OLESTR("i4"),OLESTR("long")},
    {OLESTR("int"),OLESTR("long")},
    {OLESTR("number"),OLESTR("BSTR")},
    {OLESTR("r4"),OLESTR("float")},
    {OLESTR("r8"),OLESTR("double")},
    {OLESTR("string"),OLESTR("BSTR")},
    {OLESTR("time"),OLESTR("DATE")},
    {OLESTR("time.tz"),OLESTR("DATE")},
    {OLESTR("ui1"),OLESTR("unsigned char")},
    {OLESTR("ui2"),OLESTR("unsigned short")},
    {OLESTR("ui4"),OLESTR("unsigned long")},
    {OLESTR("uri"),OLESTR("BSTR")},
    {OLESTR("uuid"),OLESTR("BSTR")}
} ;

HRESULT HrInit(IXMLDOMDocument *pXDMDoc)
{
	HRESULT hr = S_OK;
	long cNumStateVariables = 0 ;
	BSTR bstrStVar = NULL;
	IXMLDOMNodeList *pXDNLStVars = NULL;

	bstrStVar = SysAllocString(OLESTR("stateVariable"));

	if( bstrStVar )
	{
		CHECKHRTRACE(pXDMDoc->getElementsByTagName(bstrStVar,&pXDNLStVars),"HrInit() :" );
    	CHECKHRTRACE(pXDNLStVars->get_length(&cNumStateVariables),"HrInit() : get_length() Failed");
		g_StateVariableInfo.rgStateVariable = new PSTATEVARIABLE[cNumStateVariables];
    	g_StateVariableInfo.cStVars = 0 ;
	}
    else 
    	hr = E_FAIL;
    
	return hr;
}

/*
* Function:    HrPrintError()
*
* Description:  Helper function to print errors
*
* Arguments:  [in] char* - error msg
*             [in] HRESULT
*
* Returns:    HRESULT
*/
HRESULT HrPrintError(char *err, HRESULT hr ) 
{
	fprintf(stderr,"Error - %s\n",err);
    return hr ;
}

// Aborts the program
void callAbort()
{

	DWORD pLen = 0;

    printf("ERROR: Aborting !!\n");
    sprintf(g_pszdumpStr,"// UTL2IDL generation failed !!\r\n");
    WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL);
    CloseHandle(g_hOutFileHandle);
    CoUninitialize();
    exit(0);
}

// Error report helper function
HRESULT HrReportError(IXMLDOMParseError *pXMLError)
{
    long line, linePos;
    LONG errorCode;
    BSTR pBURL, pBReason;
    HRESULT hr;

    CHECKHR(pXMLError->get_line(&line));
    CHECKHR(pXMLError->get_linepos(&linePos));
    CHECKHR(pXMLError->get_errorCode(&errorCode));
    CHECKHR(pXMLError->get_url(&pBURL));
    CHECKHR(pXMLError->get_reason(&pBReason));

    fprintf(stderr, "%S", pBReason);
    if (line > 0)
    {
        fprintf(stderr, "Error on line %d, position %d in \"%S\".\n",
              line, linePos, pBURL);
    }

    SysFreeString(pBURL);
    SysFreeString(pBReason);

    return E_FAIL;
}


HRESULT HrGetElementValue(IXMLDOMNode *pXDNNode , VARIANT **vNodeValue ) 
{
    IXMLDOMNode *pXDNCldNode ;

    HRESULT hr = S_OK ;

    CHECKHRTRACE(pXDNNode->get_firstChild(&pXDNCldNode),"HrGetElementValue() : failed");
    CHECKHRTRACE(pXDNCldNode->get_nodeValue(*vNodeValue),"HrGetElementValue() : failed");

    return hr ;
}

HRESULT HrGenEnumTags(IXMLDOMDocument *pXDMDoc, PCWSTR pszEnumName) 
{
        HRESULT hr = S_OK ;
        IXMLDOMNodeList *pXDNLStVarTable = NULL ;
        IXMLDOMNode *pXDNStVarNode = NULL ;
        IXMLDOMNodeList *pXDNLActionList = NULL ;
        IXMLDOMNode *pXDNActionListNode = NULL ;

        IXMLDOMNodeList *pXDNLAllStVars = NULL ;
        IXMLDOMNode *pXDNStVar = NULL ;
        long nLen = 0 ;
        BSTR pszbStVarName = SysAllocString(OLESTR("serviceStateTable"));

        IXMLDOMNodeList *pXDNLAllActions = NULL ;
        IXMLDOMNode *pXDNAction = NULL ;
        BSTR pszActionName = SysAllocString(OLESTR("actionList"));
       
        BOOL first = true ;
        DWORD pLen = 0 ;
        WCHAR *pszwTmpName = new WCHAR[wcslen(pszEnumName) + 1];
        if ( pszwTmpName == NULL )
                callAbort();
        wcscpy(pszwTmpName,pszEnumName);

        CHECKHRTRACE(pXDMDoc->getElementsByTagName(pszbStVarName,&pXDNLStVarTable),"HrGenEnumTags() : failed");
        CHECKHRTRACE(pXDNLStVarTable->get_item(0,&pXDNStVarNode),"HrGenEnumTags() : failed");
        CHECKNULL(pXDNStVarNode,"HrGenEnumTags() : failed");

        CHECKHRTRACE(pXDNStVarNode->selectNodes(OLESTR("stateVariable/name"),&pXDNLAllStVars),"HrGenEnumTags() : failed");
        CHECKHRTRACE(pXDNLAllStVars->get_length(&nLen),"HrGenEnumTags() : failed");

        sprintf(g_pszdumpStr,"typedef [v1_enum] enum %S_DISPIDS\r\n{\r\n\t",_wcsupr((wchar_t *)pszwTmpName));
        CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");

        for( int i = 0 ; i < nLen ; i++ ) 
        {
         	VARIANT vNodeName ;
            VARIANT *pvName = NULL ;
            VariantInit(&vNodeName);
            pvName = &vNodeName ;

            CHECKHRTRACE(pXDNLAllStVars->get_item(i,&pXDNStVar),"HrGenEnumTags() : failed");
            CHECKHRTRACE(HrGetElementValue(pXDNStVar,&pvName),"HrGenEnumTags() : failed");

            sprintf(g_pszdumpStr," DISPID_%S",_wcsupr(V_BSTR(&vNodeName)));
            CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
            if ( first ) 
            {
            	sprintf(g_pszdumpStr," = 1");
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
                first = false ;
            }
            if ( i < nLen-1 ) 
            {
            	sprintf(g_pszdumpStr,",\r\n\t");
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
            }
            VariantClear(&vNodeName);
        }

	    CHECKHRTRACE(pXDMDoc->getElementsByTagName(pszActionName,&pXDNLActionList),"HrGenEnumTags() : failed");
        CHECKHRTRACE(pXDNLActionList->get_item(0,&pXDNActionListNode),"HrGenEnumTags() : failed");
        nLen = 0 ;
        if ( pXDNActionListNode ) 
        {
        	CHECKNULL(pXDNActionListNode,"HrGenEnumTags() : failed");
        	CHECKHRTRACE(pXDNActionListNode->selectNodes(OLESTR("action/name"),&pXDNLAllActions),"HrGenEnumTags() : 4 failed");
           	CHECKHRTRACE(pXDNLAllActions->get_length(&nLen),"HrGenEnumTags() : failed");
        }
        if ( nLen ) 
        {
        	sprintf(g_pszdumpStr,",\r\n\t");
            CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
        }
        for( int i = 0 ; i < nLen ; i++ ) 
        {
            VARIANT vActionName ;
            VARIANT *pvActName = NULL ;
            VariantInit(&vActionName);
            pvActName = &vActionName;

            CHECKHRTRACE(pXDNLAllActions->get_item(i,&pXDNAction),"HrGenEnumTags() : failed");
            CHECKHRTRACE(HrGetElementValue(pXDNAction,&pvActName),"HrGenEnumTags() : failed");

            sprintf(g_pszdumpStr," DISPID_%S",_wcsupr(V_BSTR(&vActionName)));
            CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
            if ( first ) 
            {
            	sprintf(g_pszdumpStr," = 1");
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
                first = false ;
            }
            if ( i < nLen-1 ) 
            {
            	sprintf(g_pszdumpStr,",\r\n\t");
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
            }
            VariantClear(&vActionName);
        }
        sprintf(g_pszdumpStr,"\r\n\r\n} %S_DISPIDS;\r\n\r\n",_wcsupr((wchar_t *)pszwTmpName));
        CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenEnumTags() : Write to File failed");
       
        delete pszwTmpName ;
        SysFreeString(pszActionName);
        SysFreeString(pszbStVarName);

        return hr ;
}


/*
* Function:    HrgenGUIDHDR()
*
* Description:  Generates the IDL interface Header
*
* Arguments:  [in] PCWSTR - Help String for the interface
*
* Returns:    HRESULT
*/
HRESULT HrgenGUIDHDR(PCWSTR pszHelpStr, BOOL fDual) {
        HRESULT hr = S_OK ;
        UUID pUUID ;
        unsigned char *arUUID ;
        DWORD pLen = 0 ;
        RPC_STATUS status ;

        status = UuidCreate(&pUUID);
        if ( status != RPC_S_OK )
                callAbort();
        status = UuidToString(&pUUID,(unsigned short **)&arUUID);
        if ( status != RPC_S_OK )
                callAbort();

        sprintf(g_pszdumpStr,"[\r\n\t uuid(%S),\r\n\t %S,\r\n\t pointer_default(unique)\r\n]\r\n",arUUID,(fDual)?OLESTR("dual"):OLESTR("oleautomation"));
        CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrgenGUIDHDR() : Write to File failed");

        RpcStringFree((unsigned short **)&arUUID);
        return hr ;
}

/*
* Function:    HrCheckLoad()
*
* Description:  Cheks if the XML document is loaded successfully
*
* Arguments:  [in] IXMLDOMDocument* - XML document handle
*
* Returns:    HRESULT
*/
HRESULT HrCheckLoad(IXMLDOMDocument* pXDMDoc)
{
    IXMLDOMParseError  *pXMLError = NULL;
    LONG errorCode = E_FAIL;
    HRESULT hr;

    CHECKHR(pXDMDoc->get_parseError(&pXMLError));
    CHECKHR(pXMLError->get_errorCode(&errorCode));
    if (errorCode != 0)
    {
        hr = HrReportError(pXMLError);
        SAFERELEASE(pXMLError);
    }
    else
    {
        fprintf(stderr, "XML document loaded successfully\n");
    }

        SAFERELEASE(pXMLError);
    return errorCode;
}

/*
* Function:    HrLoadDocument()
*
* Description:  Loads XML Document
*
* Arguments:  [in] IXMLDOMDocument* - XML document handle
*             [in] BSTR  - the location of XML file
*
* Returns:    HRESULT
*/
HRESULT HrLoadDocument(IXMLDOMDocument *pXDMDoc, BSTR pBURL)
{
    VARIANT         vURL;
    VARIANT_BOOL    vb;
    HRESULT         hr;

    CHECKHR(pXDMDoc->put_async(VARIANT_FALSE));

    // Load xml document from the given URL or file path
    VariantInit(&vURL);
    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = pBURL;
    CHECKHR(pXDMDoc->load(vURL, &vb));
    CHECKHR(HrCheckLoad(pXDMDoc));

    return hr;
}

/*
* Function:    getRelatedDataType()
*
* Description:  The data types of the action arguments is specified in terms of its related state variable
*             This function gets the data type of the action argument from the related state variable
*
* Arguments:   [in] BSTR  - related state variable
*
* Returns:    [retval] BSTR - data type of the state variable
*                   NULL if there is no corresponding state variable
*/
BSTR getRelatedDataType(BSTR relatedStateVariable ) 
{
	for(int i = 0 ; i < g_StateVariableInfo.cStVars ; i++ ) 
	{ 
    	if( wcscmp(relatedStateVariable,g_StateVariableInfo.rgStateVariable[i]->m_StVarName) == 0 )
        	return SysAllocString(g_StateVariableInfo.rgStateVariable[i]->m_StVarType);
    }
    return NULL ;
}

/*
* Function:    getIDLDataType()
*
* Description:  This functions maps the XML data type to the equivalent IDL data type
*
* Arguments:   [in] BSTR  - XML data type
*
* Returns:    [retval] BSTR - IDL data type
*                   NULL - if the XML data type is invalid
*/
BSTR getIDLDataType(BSTR xmlDataType) 
{
    CONST int nSize = celems(g_dataTypeConvtTable);
    int i ;

    for( i = 0 ; i < nSize ; i++ ) 
    {  
    	if ( _wcsicmp(xmlDataType , g_dataTypeConvtTable[i].m_XMLDataType) == 0 )
        	return g_dataTypeConvtTable[i].m_IDLDataType ;
    }
    return NULL ;
}

// prints the command line usage
void PrintUsage(PCWSTR exe)
{
    fprintf(stderr, "\n\nUsage: %S [<options>] inputfilename [outputfilename] \n",exe);
        fprintf(stderr, "\nOptions are:\n");
        fprintf(stderr,"-i InterfaceName  ..... Input interface name for generating IDL interface\n");
        fprintf(stderr,"-d               ..... Generate dual interface\n");
        fprintf(stderr,"-h HelpString     ..... Input Help String\n\n");
        exit(0);
}

// input file assumed to have extension !!
// if PATH is specified, again prun it !!

// truncates the extension from the input string and creates a new truncated string
WCHAR* PrunFileExt(PCWSTR fileName ) 
{
        WCHAR *rgTmpName = NULL ;
        WCHAR *pFileName = NULL ;

        rgTmpName = new WCHAR[wcslen(fileName)+10] ; // +10 -just in case the file doesn't have extension and we are appending some ext !!
        if ( rgTmpName == NULL )
                callAbort();
        pFileName = wcsrchr(fileName,'\\');

        if ( pFileName == NULL )
        {
        	wcscpy(rgTmpName,fileName);
            pFileName = wcsrchr(rgTmpName,'.');
            if ( pFileName )
            	*pFileName = NULL ;
        }
        else
        {
            wcscpy(rgTmpName,pFileName+1);
            pFileName = wcsrchr(rgTmpName,'.');
            if ( pFileName )
            	*pFileName = NULL ;
        }

        return rgTmpName ;
}

void ValidateString(WCHAR *fileName) 
{
	int nLen ;
	int i;
    nLen = wcslen(fileName);

    for( i=0; i < nLen ; i++ ) 
    {
		switch(fileName[i])
		{
			case '-':
			case '!':
			case '@':
			case '#':
			case '$':
			case '%':
			case '^':
			case '&':
			case '*':
			case '+':
			case ' ':
			case '(':
			case ')':
				fileName[i] = '_' ;
				break;
			default:
				;
		}
    }
    
}
/*
* Function:    HrGenStateVariableIDLFn()
*
* Description:  Generates the propget IDL function for the state variable
*
* Arguments:  [in] IXMLDOMNode* - state variable node
*
* Returns:    HRESULT
*/
HRESULT HrGenStateVariableIDLFn(IXMLDOMNode *pXDNStVar ) 
{
    HRESULT hr = S_OK ;
    VARIANT vName, vDataType ;

    IXMLDOMNodeList *pXDNLchildNodes = NULL  ;
    IXMLDOMNode *pXDNStVarTags= NULL ;
    IXMLDOMNode *pXDNStVarData = NULL ;

    BSTR pszbName = SysAllocString(OLESTR("name"));
    BSTR pszbDataType = SysAllocString(OLESTR("dataType"));
    BSTR pszbNodeName ;
    long lLength ;
    DWORD pLen = 0 ;

    VariantInit(&vName);
    VariantInit(&vDataType);

    CHECKHRTRACE(pXDNStVar->get_childNodes(&pXDNLchildNodes),"HrGenStateVariableFn() - Failed");
    CHECKHRTRACE(pXDNLchildNodes->get_length(&lLength),"HrGenStateVariableFn() - Failed");

    for(int i = 0 ; i < lLength ; i++ ) 
    {
    	CHECKHRTRACE(pXDNLchildNodes->get_item(i,&pXDNStVarTags),"HrGenStateVariableFn() - Failed") ;
        CHECKHRTRACE(pXDNStVarTags->get_firstChild(&pXDNStVarData),"HrGenStateVariableFn() - Failed") ;
        //CHECKNULL(pXDNStVarData,"HrGenStateVariableFn() - XML DataValue Missing");
        CHECKHRTRACE(pXDNStVarTags->get_nodeName(&pszbNodeName), "HrGenStateVariableFn() - Failed");

        if ( wcscmp(pszbNodeName,pszbName) == 0 )
        { // TAGS are case sensitive !!
        	CHECKNULL(pXDNStVarData,"HrGenStateVariableFn() - XML DataValue Missing");
            CHECKHRTRACE(pXDNStVarData->get_nodeValue(&vName),"HrGenStateVariableFn() - Failed");
        }
        else if ( wcscmp(pszbNodeName,pszbDataType) == 0 )
        {
        	CHECKNULL(pXDNStVarData,"HrGenStateVariableFn() - XML DataValue Missing");
            CHECKHRTRACE(pXDNStVarData->get_nodeValue(&vDataType),"HrGenStateVariableFn() - Failed");
        }
        SysFreeString(pszbNodeName);
    }

    BSTR pszbIDLDataType = getIDLDataType(V_BSTR(&vDataType));
    CHECKNULL(pszbIDLDataType,"HrGenStateVariable() : INVALID Data Type");
    g_StateVariableInfo.rgStateVariable[g_StateVariableInfo.cStVars] = new STATEVARIABLE ; // check for error
    CHECKNULL(g_StateVariableInfo.rgStateVariable[g_StateVariableInfo.cStVars],"HrGenStateVariable() : STATEVARIABLE Allocation Failed");
    g_StateVariableInfo.rgStateVariable[g_StateVariableInfo.cStVars]->m_StVarName = SysAllocString(V_BSTR(&vName));
    g_StateVariableInfo.rgStateVariable[g_StateVariableInfo.cStVars]->m_StVarType = SysAllocString(pszbIDLDataType);

    g_StateVariableInfo.cStVars++ ;

    WCHAR *pszwTmp = new WCHAR[wcslen(V_BSTR(&vName))+1] ;
    if ( pszwTmp == NULL )
    	callAbort();
    wcscpy(pszwTmp,V_BSTR(&vName));
    sprintf(g_pszdumpStr,"\t[propget, id(DISPID_%S), helpstring(\"Property %S\")]\r\n\tHRESULT %S(\r\n\t\t[out, retval] %S *p%S);\r\n\r\n",_wcsupr(pszwTmp),V_BSTR(&vName),V_BSTR(&vName),/*V_BSTR(&vDataType)*/pszbIDLDataType , V_BSTR(&vName));
    CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"Write to File failed");

    delete pszwTmp ;
    g_methodID++;
    VariantClear(&vName);
    VariantClear(&vDataType);

    return hr ;
}

/*
* Function:    HrProcessStateVariables()
*
* Description:  Process all the state variables form the XML document
*
* Arguments:  [in] IXMLDOMDocument* - Service Description XML document
*
* Returns:    HRESULT
*/
HRESULT HrProcessStateVariables(IXMLDOMDocument *pXDMDoc )
{
	BSTR pBStVar = SysAllocString(OLESTR("stateVariable"));
    IXMLDOMNodeList *pXDNLStVars = NULL;
    IXMLDOMNode *pXDNStVar = NULL;
    long clistLen = 0 ;
    HRESULT hr = S_OK ;

    CHECKHRTRACE(pXDMDoc->getElementsByTagName(pBStVar,&pXDNLStVars),"HrProcessStateVariables() : NoStateVariables");
    CHECKHRTRACE(pXDNLStVars->get_length(&clistLen),"HrProcessStateVariables() : get_length() Failed");
    for( int i = 0 ; i < clistLen ; i++)
    {
    	CHECKHRTRACE(pXDNLStVars->get_item(i,&pXDNStVar),"HrProcessStateVariables() : Failed");
        CHECKHRTRACE(HrGenStateVariableIDLFn(pXDNStVar),"HrProcessStateVariables() : Failed");
    }

    SysFreeString(pBStVar);

    return hr ;
}

/*
* Function:    HrProcessArguments()
*
* Description:  Parses the argument and generates the arguments for the IDL function
*
* Arguments:  [in] IXMLDOMNode* - argument node
*            [out] BOOL* - indicates if the argument is a return value
*
* Returns:    HRESULT
*/
HRESULT HrProcessArguments(IXMLDOMNode *pXDNArgument, BOOL *fretVal, BSTR *pszbrelDT, BSTR *pszargName ) 
{
        HRESULT hr = S_OK ;
        IXMLDOMNodeList *pXDNLParams = NULL ;
        IXMLDOMNode *pXDNParamNode = NULL ;
        BSTR pszbParamNodeName ;
        VARIANT vargName ;
        VARIANT vargDataType ;
        VARIANT vargDirection ;
        BSTR pszbrelatedDataType = NULL ;
        long nNumParams = 0 ;
        DWORD pLen = 0 ;
        BOOL retVal = false ;

        VariantInit(&vargName);
        VariantInit(&vargDataType);
        VariantInit(&vargDirection);

        CHECKHRTRACE(pXDNArgument->get_childNodes(&pXDNLParams),"HrProcessArguments() : failed");
        CHECKHRTRACE(pXDNLParams->get_length(&nNumParams),"HrProcessArguments() : failed");

        for( int i = 0 ; i < nNumParams ; i++ ) 
        {
        	CHECKHRTRACE(pXDNLParams->get_item(i,&pXDNParamNode),"HrProcessArguments() : failed");
            pszbParamNodeName = NULL ;
            CHECKHRTRACE(pXDNParamNode->get_nodeName(&pszbParamNodeName),"HrProcessArguments() : failed");
            CHECKNULL(pszbParamNodeName,"HrProcessArguments() : INVALID Arguments");

            if ( wcscmp(pszbParamNodeName,OLESTR("name")) == 0) 
            {
            	IXMLDOMNode *pXDNargNameNode = NULL ;
                CHECKHRTRACE(pXDNParamNode->get_firstChild(&pXDNargNameNode),"HrProcessArguments() : failed");
                CHECKNULL( pXDNargNameNode,"HrProcessArguments() : Arguments not specified");
                CHECKHRTRACE(pXDNargNameNode->get_nodeValue(&vargName),"HrProcessArguments() : failed");
            }
            else if ( wcscmp(pszbParamNodeName,OLESTR("relatedStateVariable")) == 0 ) {
            	IXMLDOMNode *pXDNargRelatedNode = NULL ;
                CHECKHRTRACE(pXDNParamNode->get_firstChild(&pXDNargRelatedNode),"HrProcessArguments() : failed");
                CHECKNULL(pXDNargRelatedNode,"HrProcessArguments() : Related StateVariable not specified");
                CHECKHRTRACE(pXDNargRelatedNode->get_nodeValue(&vargDataType),"HrProcessArguments() : failed");
                pszbrelatedDataType = getRelatedDataType(V_BSTR(&vargDataType));
                CHECKNULL(pszbrelatedDataType,"HrProcessArguments() : INVALID Related State Variable") ;
            }
            else if ( wcscmp(pszbParamNodeName,OLESTR("direction")) == 0 ) 
            {
            	IXMLDOMNode *pXDNargDirectionNode = NULL ;
                CHECKHRTRACE(pXDNParamNode->get_firstChild(&pXDNargDirectionNode),"HrProcessArguments() : failed");
                CHECKNULL(pXDNargDirectionNode,"HrProcessArguments() : Direction not specified");
                CHECKHRTRACE(pXDNargDirectionNode->get_nodeValue(&vargDirection),"HrProcessArguments() : failed");

                if ( (_wcsicmp(V_BSTR(&vargDirection),OLESTR("in")) != 0 ) &&
                	(_wcsicmp(V_BSTR(&vargDirection),OLESTR("out")) != 0 ) ) {
                    hr = E_FAIL ;
                    CHECKHRTRACE(hr,"HrProcessArguments() : Direction must be either \"in\" or \"out\"")
                }
            }
            else if ( wcscmp(pszbParamNodeName,OLESTR("retval")) == 0) 
            {
            	retVal = true ;
            }
            else
            	hr = HrPrintError("INVALID XML Document !!", hr );

            SysFreeString(pszbParamNodeName);

      	}

        if ( retVal ) 
        {
        	if ( _wcsicmp(V_BSTR(&vargDirection),OLESTR("in")) == 0 )
        	{
        		hr = HrPrintError("INVALID ARGUMENT DIRECTION", hr);
        		callAbort();
        	}
        	*pszargName = SysAllocString(V_BSTR(&vargName));
            *pszbrelDT = SysAllocString(pszbrelatedDataType);          
        }
        else
        	if ( _wcsicmp(V_BSTR(&vargDirection),OLESTR("out")) == 0 )
        	{
            	sprintf(g_pszdumpStr,"\r\n\t\t[in, %S] %S *p%S",V_BSTR(&vargDirection),pszbrelatedDataType,V_BSTR(&vargName));
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessArguments() : Write to File failed");
            }
            else 
            {
                 sprintf(g_pszdumpStr,"\r\n\t\t[%S] %S %S",V_BSTR(&vargDirection),pszbrelatedDataType,V_BSTR(&vargName));
                 CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessArguments() : Write to File failed");
            }

        SysFreeString(pszbrelatedDataType);
        VariantClear(&vargName);
        VariantClear(&vargDirection);
        VariantClear(&vargDataType);

        *fretVal = retVal ;
        return hr ;
}

/*
* Function:    HrProcessArgumentList()
*
* Description:  Parses all the arguments for a given arguement list
*
* Arguments:  [in] IXMLDOMNode* - argument list node
*
* Returns:    HRESULT
*/

// assumption: the retval must always be specified as the last argument in the XML document
HRESULT HrProcessArgumentList(IXMLDOMNode *pXDNArgsNode ) 
{
        HRESULT hr = S_OK ;
        IXMLDOMNodeList *pXDNLArgsList = NULL ;
        IXMLDOMNode *pXDNArguments = NULL ;
        BSTR pszbrelatedDataType = NULL ;
        BSTR pszbArgName = NULL ;

        long nNumArgs = 0 ;
        BOOL fchkRetVal = false ;
        int cretValCount = 0 ;
        int nretValIndex = 0 ; // do :-initialize correctly
        DWORD pLen = 0 ;

        // multiple return Values not allowed 
        CHECKHRTRACE(pXDNArgsNode->get_childNodes(&pXDNLArgsList),"HrProcessArgumentList() : failed");
        CHECKHRTRACE(pXDNLArgsList->get_length(&nNumArgs),"HrProcessArgumentList() : failed");

        for(int i = 0 ; i < nNumArgs ; i++ ) 
        {
        	CHECKHRTRACE(pXDNLArgsList->get_item(i,&pXDNArguments),"HrProcessArgumentList() : failed");
            CHECKHRTRACE(HrProcessArguments(pXDNArguments,&fchkRetVal,&pszbrelatedDataType,&pszbArgName),"HrProcessArgumentList() : failed") ;
            if ( (i < (nNumArgs-1)) && !fchkRetVal )
            {
            	sprintf(g_pszdumpStr,",");
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessArgumentList() : Write to File failed");
            }
            if ( fchkRetVal ) 
            {
            	fchkRetVal = false ;
                nretValIndex = i ;
                cretValCount++ ;
                if ( cretValCount > MAXALLOWEDRETVAL )
                {
                	HrPrintError("Maximum of 1 retval allowed",hr) ;
                    callAbort();
                }
            }
        }
        if ( cretValCount ) 
        {
                if ( nNumArgs > 1 && nretValIndex < (nNumArgs-1) )
                {
                	sprintf(g_pszdumpStr,",");
                    CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessArgumentList() : Write to File failed");
                }
                sprintf(g_pszdumpStr,"\r\n\t\t[out, retval] %S *p%S",pszbrelatedDataType,pszbArgName);
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessArgumentList() : Write to File failed");
        }

        SysFreeString(pszbrelatedDataType);
        SysFreeString(pszbArgName);
        return hr ;
}

/*
* Function:    HrProcessAction()
*
* Description:  Parses each action node and generates the IDL action functions
*
* Arguments:  [in] IXMLDOMNode* - action node
*
* Returns:    HRESULT
*/
HRESULT HrProcessAction(IXMLDOMNode *pXDNAction) 
{
        HRESULT hr = S_OK ;
        VARIANT vActionName ;
        IXMLDOMNode *pXDNActionNode = NULL ;
        IXMLDOMNode *pXDNArgsNode = NULL ;
        IXMLDOMNode *pXDNActionNameNode = NULL ;
        DWORD pLen = 0 ;

        VariantInit(&vActionName);

        CHECKHRTRACE(pXDNAction->selectSingleNode(OLESTR("name"),&pXDNActionNode),"HrProcessAction() : failed");
        CHECKNULL(pXDNActionNode,"HrProcessAction() : Not able to retrieve Action Node");
        CHECKHRTRACE(pXDNAction->selectSingleNode(OLESTR("argumentList"),&pXDNArgsNode),"HrProcessAction() : failed");
       
        CHECKHRTRACE(pXDNActionNode->get_firstChild(&pXDNActionNameNode),"HrProcessAction() : failed");
        CHECKNULL(pXDNActionNameNode,"HrProcessAction() : Not able to retrieve Action Name");
        CHECKHRTRACE(pXDNActionNameNode->get_nodeValue(&vActionName),"HrProcessAction() : failed");

        WCHAR *pszwTmp = new WCHAR[wcslen(V_BSTR(&vActionName))+1] ;
        if ( pszwTmp == NULL )
                callAbort();
        wcscpy(pszwTmp,V_BSTR(&vActionName));
        sprintf(g_pszdumpStr,"\r\n\t[ id(DISPID_%S), helpstring(\"Method %S\")]\r\n",_wcsupr(pszwTmp),V_BSTR(&vActionName));
        CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessAction() : Write to File failed");
        delete pszwTmp ;
        g_methodID++;

        if ( pXDNArgsNode == NULL ) 
        {
                sprintf(g_pszdumpStr,"\tHRESULT %S();\r\n",V_BSTR(&vActionName));
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessAction() : Write to File failed");
        }
        else
        {
                sprintf(g_pszdumpStr,"\tHRESULT %S(",V_BSTR(&vActionName));
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessAction() : Write to File failed");
                CHECKHRTRACE(HrProcessArgumentList(pXDNArgsNode),"HrProcessAction() : failed");
             
                sprintf(g_pszdumpStr,");\r\n");
                CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrProcessAction() : Write to File failed");
        }

        VariantClear(&vActionName);

        return hr ;
}

/*
* Function:    HrProcessActionList()
*
* Description:  Parses action list and generates the IDL functions
*
* Arguments:  [in] IXMLDOMNode* - action list node
*
* Returns:    HRESULT
*/
HRESULT HrProcessActionList(IXMLDOMDocument *pXDMDoc ) 
{
        BSTR pBAction = SysAllocString(OLESTR("action"));
        IXMLDOMNodeList *pXDNLActionList = NULL;
        IXMLDOMNode *pXDNActionItem = NULL;
        long clistLen = 0 ;
        HRESULT hr = S_OK ;

        // can be with out actions 
        CHECKHRTRACE(pXDMDoc->getElementsByTagName(pBAction,&pXDNLActionList),"HrProcessActionList(): NoActions");
        CHECKHRTRACE(pXDNLActionList->get_length(&clistLen),"HrProcessActionList() : failed");
        for( int i = 0 ; i < clistLen ; i++)
        {
        	pXDNLActionList->get_item(i,&pXDNActionItem);
            CHECKHRTRACE(HrProcessAction(pXDNActionItem),"HrProcessActionList() : failed") ;
        }

        SysFreeString(pBAction);

        return hr ;

}


/*
* Function:    HrGenIDLInterface()
*
* Description:  Parses the XML document and generates the IDL interface for the Service Description in XML
*
* Arguments:  [in] IXMLDOMDocument* - XML Service Description Document
*            [in] PCWSTR - HelpString for the interface
*            [in] PCWSTR - Interface name for the Service Description
* Returns:    HRESULT
*/
HRESULT HrGenIDLInterface(IXMLDOMDocument *pXDMDoc, PCWSTR pszHelpString, PCWSTR pszInterfaceName, BOOL fDual )
{
        HRESULT hr = S_OK ;
        DWORD pLen = 0 ;

        
        CHECKHRTRACE(HrgenGUIDHDR(pszHelpString,fDual),"HrGenIDLInterface() : failed");

        sprintf(g_pszdumpStr,"interface IUPnPService_%S%S : %S {\r\n",pszInterfaceName,fDual?OLESTR("Dual"):L"",fDual?OLESTR("IDispatch"):OLESTR("IUnknown"));
        CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenIDLInterface() : Write to File failed");

        CHECKHRTRACE(HrProcessStateVariables(pXDMDoc),"HrGenIDLInterface() : failed");

        CHECKHRTRACE(HrProcessActionList(pXDMDoc),"HrGenIDLInterface() : failed");

        sprintf(g_pszdumpStr,"};\r\n");
        CHECKNULL(WriteFile(g_hOutFileHandle,g_pszdumpStr,strlen(g_pszdumpStr),&pLen,NULL),"HrGenIDLInterface() : Write to File failed");
       
        return hr ;
}

// Creates a new file for generating IDL interfaces
HANDLE CreateIDLFile() 
{

    HANDLE hOutFile ;
    hOutFile = CreateFile(g_pszOutFileName,GENERIC_WRITE,NULL,NULL,CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    while ( hOutFile == INVALID_HANDLE_VALUE ) {
        printf("\n\t The file %S already exists !!\n\t Do you want to OVERWRITE ? [y/n] : ",g_pszOutFileName);
        wchar_t wch ;
        while( ( (wch = towlower(getwchar()) )  != 'y' ) && (wch != 'n') ) 
        {
                fflush(stdout);
                printf("\n\t The file %S already exists !!\n\t Do you want to OVERWRITE ? [y/n] : ",g_pszOutFileName);
        }
        if ( wch == 'y' )
                hOutFile = CreateFile(g_pszOutFileName,GENERIC_WRITE,NULL,NULL,CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        else
                callAbort();
    }

    return hOutFile ;
}


/*
* Function:    wmain()
*
* Description:  utl2idl.cpp main function. parses the command line arguments and loads the XML document
*                         Generates the IDL interface from the XML DOM document which has the service description
*             Usage: utl3idl.exe [<options> SpecName] inputfilename [outputfilename]
*             The input file is required.
*                         Options:
*               -i - specify the interface name
*               -h - specify the helpstring.
*
* Arguments:  [i] int - argc
*             [i] PCWSTR - argv[]
* Returns:    int
*/

EXTERN_C
int
__cdecl
wmain ( IN INT     argc,
          IN PCWSTR argv[])
{

HRESULT hr = S_OK;
    IXMLDOMDocument *pXDMDoc = NULL;
    IXMLDOMNode *pXDNNode = NULL;
    BSTR pBURL = NULL;
    PCWSTR pszHelpString = NULL ;
    PCWSTR pszInterfaceName = NULL ;
    int i;
    BOOL fIName = false ;
    BOOL fDual = false ;
    DWORD pLen = 0 ;

    g_StateVariableInfo.cStVars = 0 ;

    CHECKHR(CoInitialize(NULL));

    // Create an empty XML document
    CHECKHR(CoCreateInstance(CLSID_DOMDocument30, NULL, CLSCTX_INPROC_SERVER,
                                IID_IXMLDOMDocument, (void**)&pXDMDoc));

    if (argc == 1)
    {
        PrintUsage(argv[0]);
    }

    i = 1 ;
    while ( i < argc )
    {
        PCWSTR arg = argv[i];
        if ((arg[0] == '-') || (arg[0] == '/'))
        {
            switch (arg[1])
            {
            case 'i':
                fIName = true;
                i++ ;
                pszInterfaceName = argv[i++] ;
                break;
            case 'h':
                i++;
                pszHelpString = argv[i++] ;
                break;
            case 'd':
                fDual = true ;
                i++;
                break ;
            case '?':
            	PrintUsage(argv[0]);
            	break;
            default:
                PrintUsage(argv[0]);
            }
        }
        else
        {
            g_pszInputFileName = arg ;
            i++;
            if ( i < argc )
                g_pszOutFileName = argv[i] ;
            i++ ;
            break ;
        }
    }
    if ( (g_pszInputFileName != NULL) && (g_pszOutFileName != NULL) )
    {
        if ( wcscmp(g_pszInputFileName,g_pszOutFileName) == 0 )
	    {
		    fprintf(stderr,"\nERROR - Input and Output file must be different\n");
		    PrintUsage(argv[0]) ;
	    }
    }
    // assumes a .xml extension !! change it to generic
    if ( g_pszInputFileName == NULL )
    	PrintUsage(argv[0]) ;
    if ( g_pszOutFileName == NULL ) 
    {
       	g_pszOutFileName = PrunFileExt(g_pszInputFileName) ;
        wcscat((WCHAR *)g_pszOutFileName,L".idl");
    }
    if ( pszHelpString == NULL )
        pszHelpString = PrunFileExt(g_pszInputFileName) ;
    if ( pszInterfaceName == NULL ) 
    {
        pszInterfaceName = PrunFileExt(g_pszInputFileName) ;
        ValidateString((WCHAR*)pszInterfaceName);
    }

    pBURL = SysAllocString(g_pszInputFileName);
    hr = HrLoadDocument(pXDMDoc, pBURL);
    if(hr == S_OK ) 
    {
    	HrInit(pXDMDoc);
    	g_hOutFileHandle = CreateIDLFile();
    	CHECKHR(HrGenEnumTags(pXDMDoc,pszInterfaceName));
    	CHECKHR(HrGenIDLInterface(pXDMDoc,pszHelpString, pszInterfaceName,fDual));
    	printf("\n\tTranslation Done. Check %S file\n",g_pszOutFileName);
    	SAFERELEASE(pXDMDoc);
    }
	
    SAFERELEASE(pXDMDoc);
    // free file names !!!!
    CloseHandle(g_hOutFileHandle);
    CoUninitialize();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\comutility.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O M U T I L I T Y . H
//
//  Contents:   COM support classes and functions
//
//  Notes:
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "ncbase.h"

// Macro to make the validation of COM pointers easier
#ifndef CHECK_POINTER
#define CHECK_POINTER( p ) if(!p) {return E_POINTER;}
#endif // CHECK_POINTER

// Macros for use with iid_is style functions

// For regular COM pointers
#define SAFE_QI( p ) __uuidof( p ), reinterpret_cast<void**>(&p)
// For smart com pointers
#define SMART_QI( p ) p.IID(), p.VoidAddressOf()

// String routines
HRESULT HrCoTaskMemAllocArray(long nNumber, long nElemSize, void ** ppv);
HRESULT HrCoTaskMemAllocString(long nChars, wchar_t ** psz);
HRESULT HrCoTaskMemAllocString(wchar_t * sz, wchar_t ** psz);

template<class Type>
inline HRESULT HrCoTaskMemAllocArray(long nNumber, Type ** parType)
{
    return HrCoTaskMemAllocArray(nNumber, sizeof(Type), reinterpret_cast<void**>(parType));
}

HRESULT HrCoCreateInstanceBase(
    REFCLSID clsid,
    DWORD dwClsContext,
    REFIID riid,
    void ** ppv);

HRESULT HrCoCreateInstanceInprocBase(
    REFCLSID clsid,
    REFIID riid,
    void ** ppv);

HRESULT HrCoCreateInstanceLocalBase(
    REFCLSID clsid,
    REFIID riid,
    void ** ppv);

HRESULT HrCoCreateInstanceServerBase(
    REFCLSID clsid,
    REFIID riid,
    void ** ppv);


template <class Inter>
HRESULT HrCoCreateInstance(
    const CLSID & clsid,
    DWORD dwClsContext,
    Inter ** ppInter)
{
    return HrCoCreateInstanceBase(
        clsid,
        dwClsContext,
        __uuidof(Inter),
        reinterpret_cast<void**>(ppInter));
}

template <class Inter>
HRESULT HrCoCreateInstanceInproc(
    const CLSID & clsid,
    Inter ** ppInter)
{
    return HrCoCreateInstanceInprocBase(
        clsid,
        __uuidof(Inter),
        reinterpret_cast<void**>(ppInter));
}

template <class Inter>
HRESULT HrCoCreateInstanceLocal(
    const CLSID & clsid,
    Inter ** ppInter)
{
    return HrCoCreateInstanceLocalBase(
        clsid,
        __uuidof(Inter),
        reinterpret_cast<void**>(ppInter));
}

template <class Inter>
HRESULT HrCoCreateInstanceServer(
    const CLSID & clsid,
    Inter ** ppInter)
{
    return HrCoCreateInstanceServerBase(
        clsid,
        __uuidof(Inter),
        reinterpret_cast<void**>(ppInter));
}

HRESULT HrIsSameObject(const IUnknown * pUnk1, const IUnknown * pUnk2);

HRESULT HrSetProxyBlanket(
    IUnknown * pUnkProxy,
    DWORD dwAuthnLevel,
    DWORD dwImpLevel,
    DWORD dwCapabilities);
HRESULT HrEnableStaticCloaking(IUnknown * pUnkProxy);
HRESULT HrCopyProxyIdentity(IUnknown * pUnkDest, IUnknown * pUnkSrc);

template <class Inter>
class HideAddRefAndRelease : public Inter {
    STDMETHOD_(ULONG, AddRef)()=0;
    STDMETHOD_(ULONG, Release)()=0;
};

template <class Type> class SmartComPtr
{
    typedef SmartComPtr<Type> SmartComPtrType;
    typedef Type * PType;
    typedef const Type * CPType;
public:
    // Default Constructor
    SmartComPtr() : m_pType(NULL) {}
    // Copy Constructor
    SmartComPtr(const SmartComPtrType & ref) : m_pType(NULL)
    {
        Init(ref.m_pType);
    }
    // Assignment operators
    SmartComPtrType & operator=(const SmartComPtrType & ref)
    {
        if(this != &ref) {
            Release();
            Init(ref.m_pType);
        }
        return *this;
    }
    SmartComPtrType & operator=(CPType pType)
    {
        Release();
        Init(pType);
        return *this;
    }
    HRESULT HrAttach(const IUnknown * pUnk)
    {
        Release();
        return InitUnknown(pUnk);
    }
    template <class Inter>
    HRESULT HrAttach(const SmartComPtr<Inter> & ref)
    {
        return HrAttach(ref.GetRawPointer());
    }
    ~SmartComPtr()
    {
        Release();
    }
    // Conversion operators
    // Bypass const for COM compatibility
    operator PType() const
    {
        return const_cast<PType>(m_pType);
    }
    // Smart pointer accessor
    HideAddRefAndRelease<Type>* operator->() const
    {
        return reinterpret_cast<HideAddRefAndRelease<Type>*>(m_pType);
    }
    // Address of operator (should only be used to pass a NULL void** to a QI like function)
    PType * AddressOf()
    {
        // It is probably a bug if m_pType is not NULL
        Assert(!m_pType);
        Release();
        m_pType = NULL;
        return &m_pType;
    }
    const IID & IID() const
    {
        return __uuidof(PType);
    }
    PType GetPointer()
    {
        PType pType = m_pType;
        if(pType) pType->AddRef();
        return pType;
    }
    PType GetRawPointer()
    {
        return m_pType;
    }
    CPType GetRawPointer() const
    {
        return m_pType;
    }
    void ** VoidAddressOf()
    {
        return reinterpret_cast<void**>(AddressOf());
    }
    // Pointer comparison - uses COM notion of identity
    template <class Inter>
    HRESULT HrIsEqual(const SmartComPtr<Inter> & ref) const
    {
        return HrIsSameObject(m_pType, ref.m_pType);
    }
    HRESULT HrIsEqual(const IUnknown * pUnk) const
    {
        return HrIsSameObject(m_pType, pUnk);
    }
    template <class Inter>
    bool operator==(const SmartComPtr<Inter> & ref) const
    {
        return S_OK == HrIsSameObject(m_pType, ref.m_pType);
    }
    bool operator==(const IUnknown * pUnk) const
    {
        return S_OK == HrIsSameObject(m_pType, pUnk);
    }
    operator bool() const
    {
        return !!m_pType;
    }
    bool operator!() const
    {
        return !m_pType;
    }
    HRESULT HrCreateInstance(const CLSID & clsid, DWORD clsctx)
    {
        Release();
        return HrCoCreateInstance(clsid, clsctx, &m_pType);
    }
    HRESULT HrCreateInstanceInproc(const CLSID & clsid)
    {
        Release();
        return HrCoCreateInstanceInproc(clsid, &m_pType);
    }
    HRESULT HrCreateInstanceLocal(const CLSID & clsid)
    {
        Release();
        return HrCoCreateInstanceLocal(clsid, &m_pType);
    }
    HRESULT HrCreateInstanceServer(const CLSID & clsid)
    {
        Release();
        return HrCoCreateInstanceServer(clsid, &m_pType);
    }
    HRESULT HrSetProxyBlanket(
        DWORD dwAuthnLevel,
        DWORD dwImpLevel,
        DWORD dwCapabilities)
    {
        return ::HrSetProxyBlanket(m_pType, dwAuthnLevel, dwImpLevel, dwCapabilities);
    }
    HRESULT HrEnableStaticCloaking()
    {
        return ::HrEnableStaticCloaking(m_pType);
    }

    HRESULT HrCopyProxyIdentity(IUnknown * pUnkSrc)
    {
        return ::HrCopyProxyIdentity(m_pType, pUnkSrc);
    }

    void Release()
    {
        ReleaseObj(m_pType);
        m_pType = NULL;
    }
    void Swap(SmartComPtrType & ref)
    {
        PType pType = m_pType;
        m_pType = ref.m_pType;
        ref.m_pType = pType;
    }
private:
    PType m_pType;

    void Init(CPType pType)
    {
        Assert(!m_pType);
        m_pType = const_cast<PType>(pType);
        AddRefObj(m_pType);
    }
    HRESULT InitUnknown(const IUnknown * pUnk)
    {
        Assert(!m_pType);
        HRESULT hRes = E_POINTER;
        if(pUnk)
        {
            hRes = const_cast<IUnknown*>(pUnk)->QueryInterface(&m_pType);
        }
        return hRes;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\interfacelist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E L I S T . H 
//
//  Contents:   Common code to manage the list of network interfaces
//
//  Notes:      
//
//  Author:     mbend   29 Dec 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "upsync.h"
#include "ulist.h"
#include "InterfaceManager.h"

class CUPnPInterfaceChange
{
public:
    virtual void OnInterfaceChange(const InterfaceMappingList & interfaceMappingList) = 0;
};

class CUPnPInterfaceList
{
public:
    ~CUPnPInterfaceList();

    static CUPnPInterfaceList & Instance();

    HRESULT HrInitialize();
    HRESULT HrShutdown();
    BOOL FShouldSendOnInterface(DWORD dwIpAddr);
    BOOL FShouldSendOnIndex(DWORD dwIndex);
    HRESULT HrSetGlobalEnable();
    HRESULT HrClearGlobalEnable();
    HRESULT HrSetICSInterfaces(long nCount, GUID * arInterfaceGuidsToAllow);
    HRESULT HrSetICSOff();
    HRESULT HrRegisterInterfaceChange(CUPnPInterfaceChange * pInterfaceChange);
private:
    CUPnPInterfaceList();
    CUPnPInterfaceList(const CUPnPInterfaceList &);
    CUPnPInterfaceList & operator=(const CUPnPInterfaceList &);

    typedef CUArray<CUPnPInterfaceChange*> InterfaceChangeList;

    static CUPnPInterfaceList s_instance;

    static void CALLBACK InterfaceChangeCallback(void *, BOOLEAN);

    HRESULT HrBuildIPAddressList();
    
    CUCriticalSection m_critSec;
    IpAddressList m_ipAddressList;
    IndexList m_indexList;
    InterfaceList m_interfaceList;
    InterfaceChangeList m_interfaceChangeList;
    BOOL m_bGlobalEnable;
    BOOL m_bICSEnabled;
    HANDLE m_hInterfaceChangeWait;
    OVERLAPPED m_olInterfaceChangeEvent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\dbgflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D B G F L A G S . H
//
//  Contents:   Debug Flag definitions for the Netcfg project
//
//  Notes:
//
//  Author:     jeffspr   27 May 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _DBGFLAGS_H_
#define _DBGFLAGS_H_

// None of this should get compiled in unless we're in the debug version
// or we need to enable tracing code.
//

//+---------------------------------------------------------------------------
//
// DBG (checked) or ENABLETRACE build
//
#if defined(DBG) || defined(ENABLETRACE)


// DebugFlagIds are the identifiers for debug flags, and are used in calls
// to FIsDebugFlagSet()
//
// Hungarian == dfid
//
enum DebugFlagId
{
    dfidBreakOnAddLegacy = 0,
    dfidBreakOnAlloc,
    dfidBreakOnDoUnattend,
    dfidBreakOnError,
    dfidBreakOnHr,
    dfidBreakOnHrIteration,
    dfidBreakOnIteration,
    dfidBreakOnNetInstall,
    dfidBreakOnPrematureDllUnload,
    dfidBreakOnWizard,
    dfidBreakOnStartOfUpgrade,
    dfidBreakOnEndOfUpgrade,
    dfidDisableShellThreading,
    dfidDisableTray,
    dfidExtremeTracing,
    dfidNetShellBreakOnInit,
    dfidNoErrorText,
    dfidShowIgnoredErrors,
    dfidShowProcessAndThreadIds,
    dfidSkipLanEnum,
    dfidTracingTimeStamps,
    dfidShowIdsInHex
};

// Just for kicks
//
typedef enum DebugFlagId    DEBUGFLAGID;

// Maximum sizes for the trace tag elements.
const int c_iMaxDebugFlagShortName      = 32;
const int c_iMaxDebugFlagDescription    = 128;

// For each element in the debug flag list
//
struct DebugFlagElement
{
    DEBUGFLAGID dfid;
    CHAR        szShortName[c_iMaxDebugFlagShortName+1];
    CHAR        szDescription[c_iMaxDebugFlagDescription+1];
    DWORD       dwValue;
};

typedef struct DebugFlagElement DEBUGFLAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern DEBUGFLAGELEMENT g_DebugFlags[];
extern const INT        g_nDebugFlagCount;

BOOL    FIsDebugFlagSet( DEBUGFLAGID    dfid );
DWORD   DwReturnDebugFlagValue( DEBUGFLAGID dfid );

//+---------------------------------------------------------------------------
//
// !DBG (retail) and !ENABLETRACE build
//
#else

#define FIsDebugFlagSet(dfid)           0
#define DwReturnDebugFlagValue(dfid)    0

#endif //! DBG || ENABLETRACE

#endif  // _DBGFLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\imports.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Ting Cai May 1999

Revision History:


--*/


#include <windef.h>
#include <winbase.h>

#ifdef MIDL_PASS
#define RPC_BOOL DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\interfacetable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E T A B L E . H 
//
//  Contents:   Builds a mapping from IP addresses to interface guids
//
//  Notes:      
//
//  Author:     mbend   7 Feb 2001
//
//----------------------------------------------------------------------------

#pragma once

#include "array.h"

struct InterfaceMapping
{
    GUID m_guidInterface;
    DWORD m_dwIpAddress;
    DWORD m_dwIndex;
};

typedef CUArray<GUID> InterfaceList;
typedef CUArray<DWORD> IpAddressList;
typedef CUArray<DWORD> IndexList;
typedef CUArray<InterfaceMapping> InterfaceMappingList;

class CInterfaceTable
{
public:
    CInterfaceTable();
    ~CInterfaceTable();

    HRESULT HrInitialize();
    HRESULT HrMapIpAddressToGuid(DWORD dwIpAddress, GUID & guidInterface);
    HRESULT HrGetMappingList(InterfaceMappingList & interfaceMappingList);
private:
    CInterfaceTable(const CInterfaceTable &);
    CInterfaceTable & operator=(const CInterfaceTable &);

    InterfaceMappingList m_interfaceMappingList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\eventsrv.h ===
#include <winsock2.h>
#include "ssdpparser.h"
#include "ssdpfunc.h"

#define EVENT_PORT 5000

#ifdef  __cplusplus
extern "C" {
#endif

#define OPEN_TCP_CONN_SIGNATURE 0x1972
#define MAX_EVENT_BUF_THROTTLE_SIZE    200000
#define MAX_EVENT_NOTIFY_HEADER_THROTTLE_SIZE  8192

typedef enum _CONNECTION_STATE
{
    CONNECTION_INIT,

    CONNECTION_HEADERS_READY,

    CONNECTION_ERROR_CLOSING,

    CONNECTION_ERROR_FORCED_CLOSE

} CONNECTION_STATE;

typedef struct _OPEN_TCP_CONN {

    LIST_ENTRY linkage;

    INT iType;

    SOCKET socketPeer;

    CONNECTION_STATE state;

    SSDP_REQUEST ssdpRequest;

    CHAR *szData;

    DWORD cbData;

    DWORD cbHeaders;

} OPEN_TCP_CONN, *POPEN_TCP_CONN;


SOCKET CreateHttpSocket();

BOOL StartHttpServer(SOCKET HttpSocket, HWND hWnd, u_int wMsg);

VOID InitializeListOpenConn();

VOID CleanupListOpenConn();

VOID HandleAccept(SOCKET socket);

VOID CleanupHttpSocket();

DWORD WINAPI LookupListOpenConn(LPVOID pvData);

VOID RemoveOpenConn(SOCKET socket);

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\list.h ===
//  copied from winnt.h and wdm.h in winnt platform sdk

#ifndef _SSDPLIST_
#define _SSDPLIST_
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

//  LIST_ENTRY and SINGLE_LIST_ENTRY are defined in winnt.h
/*
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
*/

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

/*
typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
*/

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // _SSDPLIST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\interfacemanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E M A N A G E R . H 
//
//  Contents:   Manages building the list of IP addresses
//
//  Notes:      
//
//  Author:     mbend   3 Jan 2001
//
//----------------------------------------------------------------------------

#pragma once

#include "InterfaceTable.h"

class CInterfaceManager
{
public:
    CInterfaceManager();
    ~CInterfaceManager();

    HRESULT HrInitializeWithAllInterfaces();
    HRESULT HrInitializeWithIncludedInterfaces(const InterfaceList & interfaceList);
    HRESULT HrGetValidIpAddresses(IpAddressList & ipAddressList);
    HRESULT HrGetValidIndices(IndexList & indexList);
    HRESULT HrGetMappingList(InterfaceMappingList & interfaceMappingList);
private:
    CInterfaceManager(const CInterfaceManager &);
    CInterfaceManager & operator=(const CInterfaceManager &);

    HRESULT HrAddInterfaceMappingIfPresent(DWORD dwIpAddress, DWORD dwIndex, const GUID & guidInterface);
    HRESULT HrProcessIpAddresses();

    BOOL m_bAllInterfaces;
    InterfaceMappingList m_interfaceMappingList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncatl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L . H
//
//  Contents:   Common code for use with ATL.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   22 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATL_H_
#define _NCATL_H_

#include "ncbase.h"
#include "ncstring.h"

//
// This file should be included *after* your standard ATL include sequence.
//
//      #include <atlbase.h>
//      extern CComModule _Module;
//      #include <atlcom.h>
//      #include "ncatl.h"      <------
//
// We cannot directly include that sequence here because _Module may be
// derived from CComModule as opposed to an instance of it.
//

class CExceptionSafeComObjectLock
{
public:
    CExceptionSafeComObjectLock (CComObjectRootEx <CComMultiThreadModel>* pObj)
    {
        AssertH (pObj);
        m_pObj = pObj;
        TraceTag (ttidEsLock,
            "Entered critical section object of COM object 0x%08x",
            &m_pObj);
        pObj->Lock ();
    }

    ~CExceptionSafeComObjectLock ()
    {
        TraceTag (ttidEsLock,
            "Leaving critical section object of COM object 0x%08x",
            &m_pObj);

        m_pObj->Unlock ();
    }

protected:
    CComObjectRootEx <CComMultiThreadModel>* m_pObj;
};


//+---------------------------------------------------------------------------
//
//  Function:   HrCopyIUnknownArrayWhileLocked
//
//  Purpose:    Allocate and copy an array of IUnknown pointers from an ATL
//              CComDynamicUnkArray while holding the object which controls
//              the CComDynamicUnkArray locked.  This is needed by objects
//              which dispatch calls on a connection point's advise sink
//              to prevent the CComDynamicUnkArray from being modified (via
//              calls to Advise/Unadvise on other threads) while they are
//              dispatching.  An atomic copy is made so the dispatcher can
//              then make the lengthy callbacks without the need to hold
//              the owner object locked.
//
//  Arguments:
//      pObj  [in]  Pointer to object which has Lock/Unlock methods.
//      pVec  [in]  ATL array of IUnknown's to copy.
//      pcUnk [out] Address of returned count of IUnknown pointerss
//                  in *paUnk.
//      paUnk [out] Address of allocated pointer to the array of IUnknown
//                  pointers.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   3 Dec 1998
//
//  Notes:      The returned count and array may be NULL when no IUnknowns
//              existed in the input array.  S_OK will be returned for this
//              case too, so be sure to check *pcUnk and *paUnk too.
//
inline
HRESULT
HrCopyIUnknownArrayWhileLocked (
    IN  CComObjectRootEx <CComMultiThreadModel>* pObj,
    IN  CComDynamicUnkArray* pVec,
    OUT ULONG* pcpUnk,
    OUT IUnknown*** papUnk)
{
    HRESULT hr = S_OK;
    IUnknown** ppUnkSrc;
    IUnknown** ppUnkDst;

    // Initialize the output parameters.
    //
    *pcpUnk = 0;
    *papUnk = NULL;

    pObj->Lock();

    // First, count the number of IUnknown's we need to copy.
    //
    ULONG cpUnk = 0;
    for (ppUnkSrc = pVec->begin(); ppUnkSrc < pVec->end(); ppUnkSrc++)
    {
        if (ppUnkSrc && *ppUnkSrc)
        {
            cpUnk++;
        }
    }

    // Allocate space and copy the IUnknown's.  (Be sure to AddRef them.)
    //
    if (cpUnk)
    {
        hr = E_OUTOFMEMORY;
        ppUnkDst = (IUnknown**)MemAlloc (cpUnk * sizeof(IUnknown*));
        if (ppUnkDst)
        {
            hr = S_OK;

            *pcpUnk = cpUnk;
            *papUnk = ppUnkDst;

            for (ppUnkSrc = pVec->begin(); ppUnkSrc < pVec->end(); ppUnkSrc++)
            {
                if (ppUnkSrc && *ppUnkSrc)
                {
                    *ppUnkDst = *ppUnkSrc;
                    AddRefObj(*ppUnkDst);
                    ppUnkDst++;
                    cpUnk--;
                }
            }

            // We should have copied what we counted.
            //
            AssertH(0 == cpUnk);
        }
    }

    pObj->Unlock();

    TraceHr (ttidError, FAL, hr, FALSE, "HrCopyIUnknownArrayWhileLocked");
    return hr;
}


#define DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactoryDeferredSingleton<obj>)

//+---------------------------------------------------------------------------
// Deferred Singleton Class Factory
//
template <class T>
class CComClassFactoryDeferredSingleton : public CComClassFactory
{
public:
    CComClassFactoryDeferredSingleton () : m_pObj(NULL) {}
    ~CComClassFactoryDeferredSingleton() { delete m_pObj; }

    // IClassFactory
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
    {
        HRESULT hr = E_POINTER;
        if (ppvObj != NULL)
        {
            // can't ask for anything other than IUnknown when aggregating
            //
            AssertH(!pUnkOuter || InlineIsEqualUnknown(riid));
            if (pUnkOuter && !InlineIsEqualUnknown(riid))
            {
                hr = CLASS_E_NOAGGREGATION;
            }
            else
            {
                // Need to protect m_pObj from being created more than once
                // by multiple threads calling this method simultaneously.
                // (I've seen this happen on multi-proc machines.)
                //
                Lock ();

                if (m_pObj)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    m_pObj = new CComObjectGlobal<T>;
                    if (m_pObj)
                    {
                        hr = m_pObj->m_hResFinalConstruct;
                    }
                }

                Unlock ();

                if (SUCCEEDED(hr))
                {
                    hr = m_pObj->QueryInterface(riid, ppvObj);
                }
            }
        }
        return hr;
    }
    CComObjectGlobal<T>* m_pObj;
};

// We have our own version of AtlModuleRegisterServer coded here
// because the former brings in oleaut32.dll so it can register
// type libraries.  We don't care to have a type library registered
// so we can avoid the whole the mess associated with oleaut32.dll.
//
inline
HRESULT
NcAtlModuleRegisterServer(
    _ATL_MODULE* pM
    )
{
    AssertH (pM);
    AssertH(pM->m_hInst);
    AssertH(pM->m_pObjMap);

    HRESULT hr = S_OK;

    for (_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
         pEntry->pclsid;
         pEntry++)
    {
        if (pEntry->pfnGetObjectDescription() != NULL)
        {
            continue;
        }

        hr = pEntry->pfnUpdateRegistry(TRUE);
        if (FAILED(hr))
        {
            break;
        }
    }

    TraceError ("NcAtlModuleRegisterServer", hr);
    return hr;
}

#ifdef __ATLCOM_H__
//+---------------------------------------------------------------------------
//
//  Function:   WszLoadIds
//
//  Purpose:    Loads the given string ID from the resource file.
//
//  Arguments:
//      unId [in]   ID of string resource to load.
//
//  Returns:    Read-only version of resource string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      1) You must be compiling with ATL support to use this function.
//              2) The returned string CANNOT be modified.
//              3) You must compile your RC file with the -N option for this
//                 to work properly.
//
inline
PCWSTR
WszLoadIds (
        UINT    unId)
{
    return WszLoadString (_Module.GetResourceInstance(), unId);
}
#endif  //!__ATLCOM_H__

#endif // _NCATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\nccom.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O M . H
//
//  Contents:   Helper functions for doing COM things
//
//  Notes:
//
//----------------------------------------------------------------------------


#pragma once
#ifndef _NCCOM_H_
#define _NCCOM_H_


HRESULT HrMyWaitForMultipleHandles(DWORD dwFlags, DWORD dwTimeout, ULONG cHandles,
                                   LPHANDLE pHandles, LPDWORD pldwIndex);

BOOL    FSupportsInterface(IUnknown * punk, REFIID piid);

#endif // _NCCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncdebug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D E B U G . H
//
//  Contents:   Debug routines.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCDEBUG_H_
#define _NCDEBUG_H_

#include "dbgflags.h"       // For debugflags id definitions
#include "trace.h"

NOTHROW void InitializeDebugging ();
NOTHROW void UnInitializeDebugging ();


//
//  Useful macros to use with Asserts.
//  Eg,     Assert(FImplies(sz, !*sz));
//          Assert(FIff(sz, cch));
//
#define FImplies(a,b)       (!(a) || (b))
#define FIff(a,b)           (!(a) == !(b))


//
//  "Normal" assertion checking.  Provided for compatibility with
//  imported code.
//
//      Assert(a)       Displays a message indicating the file and line number
//                      of this Assert() if a == 0.
//      AssertSz(a,b)   As Assert(); also displays the message b (which should
//                      be a string literal.)
//      SideAssert(a)   As Assert(); the expression a is evaluated even if
//                      asserts are disabled.
//
#undef AssertSz
#undef Assert


//+---------------------------------------------------------------------------
//
// DBG (checked) build
//
#ifdef DBG

VOID
DbgCheckPrematureDllUnload (
    PCSTR pszaDllName,
    UINT ModuleLockCount);

typedef VOID     (CALLBACK * PFNASSERTHOOK)(PCSTR, PCSTR, int);
VOID    WINAPI   SetAssertFn           (PFNASSERTHOOK);
BOOL    WINAPI   FInAssert             (VOID);
VOID    WINAPI   AssertSzFn            (PCSTR pszaMsg, PCSTR pszaFile, int nLine);
VOID    CALLBACK DefAssertSzFn         (PCSTR pszaMsg, PCSTR pszaFile, int nLine);

#define Assert(a)       AssertSz(a, "Assert(" #a ")\r\n")
#define AssertSz(a,b)   if (!(a)) AssertSzFn(b, __FILE__, __LINE__);

#define AssertH         Assert
#define AssertSzH       AssertSz

void WINAPIV AssertFmt(BOOL fExp, PCSTR pszaFile, int nLine, PCSTR pszaFmt, ...);

#define AssertValidReadPtrSz(p,msg)     AssertSz(!IsBadReadPtr(p, sizeof(*p)),  msg)
#define AssertValidWritePtrSz(p,msg)    AssertSz(!IsBadWritePtr(p, sizeof(*p)), msg)
#define AssertValidReadPtr(p)           AssertValidReadPtrSz(p,"Bad read pointer:" #p)
#define AssertValidWritePtr(p)          AssertValidWritePtrSz(p,"Bad write pointer:" #p)

#define SideAssert(a)                   Assert(a)
#define SideAssertH(a)                  AssertH(a)
#define SideAssertSz(a,b)               AssertSz(a,b)
#define SideAssertSzH(a,b)              AssertSzH(a,b)
#define NYI(a)                          AssertSz(FALSE, "NYI: " a)
#define NYIH(a)                         AssertSzH(FALSE, "NYI: " a)


//+---------------------------------------------------------------------------
//
// !DBG (retail) build
//
#else

#define DbgCheckPrematureDllUnload(a,b) NOP_FUNCTION

#define AssertH(a)
#define AssertSzH(a,b)
#define Assert(a)
#define AssertSz(a,b)
#define AssertFmt                       NOP_FUNCTION
#define AssertValidReadPtrSz(p,msg)     NOP_FUNCTION
#define AssertValidWritePtrSz(p,msg)    NOP_FUNCTION
#define AssertValidReadPtr(p)           NOP_FUNCTION
#define AssertValidWritePtr(p)          NOP_FUNCTION

#define SideAssert(a)                   (a)
#define SideAssertH(a)                  (a)
#define SideAssertSz(a,b)               (a)
#define SideAssertSzH(a,b)              (a)
#define NYI(a)                          NOP_FUNCTION

#endif  // DBG


#endif // _NCDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncatlps.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L P S . H
//
//  Contents:   Class definition for ATL-like property sheet page object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATLPS_H_
#define _NCATLPS_H_

#include <prsht.h>

class CPropSheetPage : public CWindow, public CMessageMap
{
public:
    virtual ~CPropSheetPage();

    VOID SetChangedFlag() const
    {
        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
    }
    VOID SetUnchangedFlag() const
    {
        ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0);
    }

    virtual UINT UCreatePageCallbackHandler()
    {
        return TRUE;
    }

    virtual VOID DestroyPageCallbackHandler() {}


    HPROPSHEETPAGE  CreatePage(UINT unId, DWORD dwFlags,
                               PCTSTR pszHeaderTitle = NULL,
                               PCTSTR pszHeaderSubTitle = NULL,
                               PCTSTR pszTitle = NULL);

    static LRESULT CALLBACK DialogProc(HWND hWnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam);

    static UINT CALLBACK PropSheetPageProc(HWND hWnd, UINT uMsg,
                                           LPPROPSHEETPAGE ppsp);
};

#endif // _NCATLPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C B A S E . H
//
//  Contents:   Basic common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCBASE_H_
#define _NCBASE_H_

#include "ncdefine.h"   // for NOTHROW
#include "ncstring.h"   // For string functions
#include <unknwn.h>     // For IUnknown

NOTHROW
ULONG
AddRefObj (
    IUnknown* punk);

NOTHROW
ULONG
ReleaseObj (
    IUnknown* punk);

#define SAFE_RELEASE(pObject) \
    if ((pObject) != NULL) \
    { \
        (pObject)->Release(); \
        (pObject) = NULL; \
    }

NOTHROW
DWORD
DwWin32ErrorFromHr (
    HRESULT hr);


inline
BOOL
FDwordWithinRange (
    DWORD   dwLower,
    DWORD   dw,
    DWORD   dwUpper)
{
    return ((dw >= dwLower) && (dw <= dwUpper));
}

NOTHROW
HRESULT
HrFromLastWin32Error ();


HRESULT
HrGetProcAddress (
    HMODULE     hModule,
    PCSTR       pszaFunction,
    FARPROC*    ppfn);

HRESULT
HrLoadLibAndGetProcs (
    PCTSTR          pszLibPath,
    UINT            cFunctions,
    const PCSTR*    apszaFunctionNames,
    HMODULE*        phmod,
    FARPROC*        apfn);

inline
HRESULT
HrLoadLibAndGetProc (
    PCTSTR      pszLibPath,
    PCSTR       pszaFunctionName,
    HMODULE*    phmod,
    FARPROC*    ppfn)
{
    return HrLoadLibAndGetProcs (pszLibPath, 1, &pszaFunctionName, phmod, ppfn);
}

HRESULT
HrGetProcAddressesV(
    HMODULE hModule, ...);

HRESULT
HrLoadLibAndGetProcsV(
    PCTSTR      pszLibPath,
    HMODULE*    phModule,
    ...);

HRESULT
HrCreateEventWithWorldAccess(PCWSTR pszName, BOOL fManualReset,
        BOOL fInitialState, BOOL* pfAlreadyExists, HANDLE* phEvent);

HRESULT
HrCreateMutexWithWorldAccess(PCWSTR pszName, BOOL fInitialOwner,
        BOOL* pfAlreadyExists, HANDLE* phMutex);

BOOL FFileExists(LPTSTR pszFileName, BOOL fDirectory);


#endif // _NCBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncfile.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C F I L E . H
//
//  Contents:   Really useful file functions that are implemented in shlwapi
//              but which aren't exported.
//
//  Notes:      Stolen from shell32\path.c
//
//----------------------------------------------------------------------------


#pragma once
#ifndef _NCFILE_H_
#define _NCFILE_H_


STDAPI_(BOOL) PathTruncateKeepExtension( LPCTSTR pszDir, LPTSTR pszSpec, int iTruncLimit );

STDAPI_(int) PathCleanupSpec2(LPCTSTR pszDir, LPTSTR pszSpec);

// note: this is the stolen implementation of PathCleanupSpecEx, which is
//       defined in shlobjp.h but not exported in shell32...
//
STDAPI_(int) PathCleanupSpecEx2(LPCTSTR pszDir, LPTSTR pszSpec);

BOOL fFileExistsAtPath(LPCTSTR pszFile, LPCTSTR pszPath);

#endif // _NCFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncdefine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       U P D E F I N E . H
//
//  Contents:   Very generic defines. Don't throw non-generic crap
//              in here!
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     jeffspr   20 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _UPDEFINE_H_
#define _UPDEFINE_H_

#define BEGIN_CONST_SECTION     data_seg(".rdata")
#define END_CONST_SECTION       data_seg()

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))


#if defined(_M_IA64) || defined(_M_ALPHA) || defined(_M_MRX000) || defined(_M_PPC)

#ifdef NOTHROW
#undef NOTHROW
#endif
#define NOTHROW

#else

#ifdef NOTHROW
#undef NOTHROW
#endif
#define NOTHROW __declspec(nothrow)

#endif

// Defines for C source files including us.
//
#ifndef __cplusplus
#ifndef inline
#define inline  __inline
#endif
#endif

#endif // _NCDEFINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncmem.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M E M . H
//
//  Contents:   Common memory management routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMEM_H_
#define _NCMEM_H_

#include <malloc.h>

VOID*
MemAlloc (
    size_t cb);

VOID*
MemAllocRaiseException (
    size_t  cb);

VOID
MemFree (
    VOID* pv);


// A simple wrapper around malloc that returns E_OUTOFMEMORY if the
// allocation fails.  Avoids having to explicitly do this at each
// call site of malloc.
//
HRESULT
HrMalloc (
    size_t  cb,
    PVOID*  ppv);


// This CANNOT be an inline function.  If it is ever not inlined,
// the memory allocated will be destroyed.  (We're dealing with the stack
// here.)
//
#define PvAllocOnStack(_st)  _alloca(_st)


// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct raiseexception_t {};
extern const raiseexception_t raiseexception;

VOID*
__cdecl
operator new (
    size_t cb,
    const raiseexception_t&
    );


// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct extrabytes_t {};
extern const extrabytes_t extrabytes;

VOID*
__cdecl
operator new (
    size_t cb,
    const extrabytes_t&,
    size_t cbExtra);



#ifdef USE_HEAP_ALLOC

inline
void *  Nccalloc(size_t n, size_t s)
{
    return HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (n * s));
}

inline
void Ncfree(void * p)
{
    HeapFree (GetProcessHeap(), 0, p);
}

inline
void * Ncmalloc(size_t n)
{
    return HeapAlloc (GetProcessHeap(), 0, n);
}

inline
void * Ncrealloc(void * p, size_t n)
{
    return (NULL == p)
        ? HeapAlloc (GetProcessHeap(), 0, n)
        : HeapReAlloc (GetProcessHeap(), 0, p, n);
}

#define calloc  Nccalloc
#define free    Ncfree
#define malloc  Ncmalloc
#define realloc Ncrealloc

#endif // USE_HEAP_ALLOC

#endif // _NCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncinet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I N E T . H
//
//  Contents:   Wrappers for the WinInet APIs so they return HRESULTs
//
//  Notes:
//
//  Author:     danielwe   11 Oct 1999
//
//----------------------------------------------------------------------------

#include <wininet.h>

HRESULT HrLoadWinInetDll();

HRESULT HrInternetCloseHandle(HINTERNET hInternet);

HINTERNET HinInternetOpenA(IN LPCSTR lpszAgent, IN DWORD dwAccessType,
                           IN LPCSTR lpszProxyName, IN LPCSTR lpszProxyBypass,
                           IN DWORD dwFlags);

HRESULT HrInternetCrackUrlA(IN LPCSTR lpszUrl, IN DWORD dwUrlLength,
                            IN DWORD dwFlags,
                            IN OUT LPURL_COMPONENTSA lpUrlComponents);

HINTERNET HinInternetConnectA(IN HINTERNET hInternet, IN LPCSTR lpszServerName,
                              IN INTERNET_PORT nServerPort,
                              IN LPCSTR lpszUserName OPTIONAL,
                              IN LPCSTR lpszPassword OPTIONAL,
                              IN DWORD dwService, IN DWORD dwFlags,
                              IN DWORD_PTR dwContext);

HINTERNET HinHttpOpenRequestA(IN HINTERNET hConnect, IN LPCSTR lpszVerb,
                              IN LPCSTR lpszObjectName, IN LPCSTR lpszVersion,
                              IN LPCSTR lpszReferrer OPTIONAL,
                              IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
                              IN DWORD dwFlags, IN DWORD_PTR dwContext);

HRESULT HrHttpAddRequestHeadersA(IN HINTERNET hRequest, IN LPCSTR lpszHeaders,
                                 IN DWORD dwHeadersLength, IN DWORD dwModifiers);

HRESULT HrHttpSendRequestA(IN HINTERNET hRequest, IN LPCSTR lpszHeaders OPTIONAL,
                          IN DWORD dwHeadersLength, IN LPVOID lpOptional OPTIONAL,
                          IN DWORD dwOptionalLength);

HRESULT HrHttpSendRequestExA(IN HINTERNET hRequest,
                             IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
                             OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
                             IN DWORD dwFlags, IN DWORD_PTR dwContext);

HRESULT HrInternetWriteFile(IN HINTERNET hFile, IN LPCVOID lpBuffer,
                            IN DWORD dwNumberOfBytesToWrite,
                            OUT LPDWORD lpdwNumberOfBytesWritten);

HRESULT HrHttpEndRequest(IN HINTERNET hRequest,
                         OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
                         IN DWORD dwFlags, IN DWORD_PTR dwContext);

HRESULT HrHttpQueryInfo(IN HINTERNET hRequest, IN DWORD dwInfoLevel,
                        IN OUT LPVOID lpBuffer OPTIONAL,
                        IN OUT LPDWORD lpdwBufferLength,
                        IN OUT LPDWORD lpdwIndex OPTIONAL);

HRESULT HrInternetSetStatusCallback(IN HINTERNET hInternet,
                                 IN INTERNET_STATUS_CALLBACK lpfnInternetCallback);

HRESULT HrGetRequestUriA(LPCSTR szUrl, DWORD cbUri, LPSTR szUri);

VOID InitializeNcInet(VOID);
VOID UnInitializeNcInet(VOID);
HRESULT HrFreeWinInetDll(VOID);
HRESULT HrEnsureWinInetLoaded(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncinet2.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ncinet2.h
//
//  Contents:   Wrappers to do useful things with the Urlmon APIs
//
//  Notes:
//
//----------------------------------------------------------------------------


// note: this uses Urlmon, where the other methods only pull in
//       wininet
HRESULT HrCombineUrl(LPCWSTR pszBaseUrl,
                     LPCWSTR pszRelativeUrl,
                     LPWSTR * ppszResult);

HRESULT HrCopyAndValidateUrl(LPCWSTR pszUrl,
                             LPWSTR * ppszResult);

HRESULT HrGetSecurityDomainOfUrl(LPCWSTR pszUrl,
                                 LPWSTR * ppszResult);

BOOL FIsHttpUrl(LPCWSTR pszUrl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G . H
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCREG_H_
#define _NCREG_H_

#include "ncstring.h"
#include "ncmsz.h"

// constants for HrRegQueryStringAsUlong
const int c_nBase10 = 10;
const int c_nBase16 = 16;
const int c_cchMaxRegKeyLengthWithNull = 257;

HRESULT
HrRegAddStringToMultiSz (
    IN PCTSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCTSTR  pszKeySubPath,
    IN PCTSTR  pszValueName,
    IN DWORD   dwFlags,
    IN DWORD   dwIndex);

HRESULT
HrRegAddStringToSz (
    IN PCTSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCTSTR  pszKeySubPath,
    IN PCTSTR  pszValueName,
    IN WCHAR   chDelimiter,
    IN DWORD   dwFlags,
    IN DWORD   dwStringIndex);

HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCTSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition);

HRESULT
HrRegDeleteKey (
    IN HKEY hkey,
    IN PCTSTR pszSubkey);

HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCTSTR pszRemoveKey);

HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCTSTR pszValueName);

HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PTSTR  pszSubkeyName,
    OUT LPDWORD pcchSubkeyName,
    OUT PTSTR  pszClass,
    OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime);

HRESULT
HrRegEnumValue (
    HKEY hkey,
    DWORD dwIndex,
    PTSTR  pszValueName,
    LPDWORD pcbValueName,
    LPDWORD pdwType,
    LPBYTE  pbData,
    LPDWORD pcbData);

HRESULT
HrRegOpenKeyEx (
    HKEY hkey,
    PCTSTR pszSubkey,
    REGSAM samDesired,
    PHKEY phkResult);

HRESULT
HrRegOpenKeyBestAccess (
    HKEY hkey,
    PCTSTR pszSubkey,
    PHKEY phkResult);

HRESULT
HrRegDuplicateKeyEx (
    HKEY hkey,
    REGSAM samDesired,
    PHKEY phkResult);



HRESULT
HrRegQueryBinaryWithAlloc (
    HKEY    hkey,
    PCTSTR  pszValueName,
    LPBYTE* ppbValue,
    DWORD*  pcbValue);

HRESULT
HrRegQueryDword (
    HKEY    hkey,
    PCTSTR  pszValueName,
    LPDWORD pdwValue);

#if 0
HRESULT
HrRegQueryExpandString (
    HKEY        hkey,
    PCTSTR      pszValueName,
    tstring*    pstrValue);
#endif

HRESULT
HrRegQueryInfoKey (
    HKEY        hkey,
    PTSTR       pszClass,
    LPDWORD     pcbClass,
    LPDWORD     pcSubKeys,
    LPDWORD     pcbMaxSubKeyLen,
    LPDWORD     pcbMaxClassLen,
    LPDWORD     pcValues,
    LPDWORD     pcbMaxValueNameLen,
    LPDWORD     pcbMaxValueLen,
    LPDWORD     pcbSecurityDescriptor,
    PFILETIME   pftLastWriteTime);

HRESULT
HrRegQueryStringAsUlong (
    HKEY        hkey,
    PCTSTR      pszValueName,
    int         nBase,
    ULONG*      pulValue);

#if 0
HRESULT
HrRegQueryTypeString (
    HKEY        hkey,
    PCTSTR      pszValueName,
    DWORD       dwType,
    tstring*    pstr);
#endif

HRESULT
HrRegQueryTypeSzBuffer (
    HKEY    hkey,
    PCTSTR  pszValueName,
    DWORD   dwType,
    PTSTR   pszData,
    DWORD*  pcbData);

HRESULT
HrRegQueryValueEx (
    HKEY        hkey,
    PCTSTR      pszValueName,
    LPDWORD     pdwType,
    LPBYTE      pbData,
    LPDWORD     pcbData);

HRESULT
HrRegQueryValueWithAlloc (
    HKEY        hkey,
    PCTSTR      pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize);


#if 0
inline
HRESULT
HrRegQueryString (
    HKEY        hkey,
    PCTSTR      pszValueName,
    tstring*    pstr)
{
    return HrRegQueryTypeString (hkey, pszValueName, REG_SZ, pstr);
}
#endif


HRESULT
HrRegQueryTypeWithAlloc (
    HKEY        hkey,
    PCTSTR      pszValueName,
    DWORD       dwType,
    LPBYTE*     ppbValue,
    DWORD*      pcbValue);

inline
HRESULT
HrRegQueryBinaryWithAlloc (
    HKEY    hkey,
    PCTSTR  pszValueName,
    LPBYTE* ppbValue,
    DWORD*  pcbValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_BINARY,
                ppbValue, pcbValue);
}


inline
HRESULT
HrRegQueryMultiSzWithAlloc (
    HKEY        hkey,
    PCTSTR      pszValueName,
    PTSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_MULTI_SZ,
                (LPBYTE*)pszValue, NULL);
}

inline
HRESULT
HrRegQuerySzWithAlloc (
    HKEY        hkey,
    PCTSTR      pszValueName,
    PTSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_SZ,
                (LPBYTE*)pszValue, NULL);
}

inline
HRESULT
HrRegQueryExpandSzBuffer (
    HKEY        hkey,
    PCTSTR      pszValueName,
    PTSTR       pszData,
    DWORD*      pcbData)
{
    return HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_EXPAND_SZ,
                pszData, pcbData);
}

inline
HRESULT
HrRegQuerySzBuffer (
    HKEY        hkey,
    PCTSTR      pszValueName,
    PTSTR       pszData,
    DWORD*      pcbData)
{
    return HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_SZ,
                pszData, pcbData);
}





HRESULT HrRegSaveKey(HKEY hkey, PCTSTR szFileName,
                     LPSECURITY_ATTRIBUTES psa);

HRESULT HrRegSetValueEx (HKEY hkey,
                         PCTSTR szValueName,
                         DWORD dwType,
                         const BYTE *pbData,
                         DWORD cbData);

HRESULT HrRegRemoveStringFromSz(    PCTSTR      pszRemoveString,
                                    HKEY        hkeyRoot,
                                    PCTSTR      pszKeySubPath,
                                    PCTSTR      pszValueName,
                                    WCHAR       chDelimiter,
                                    DWORD       dwFlags );

HRESULT HrRegRemoveStringFromMultiSz (PCTSTR pszRemoveString,
                                      HKEY   hkeyRoot,
                                      PCTSTR pszKeySubPath,
                                      PCTSTR pszValueName,
                                      DWORD  dwFlags);

HRESULT HrRegRestoreKey(HKEY hkey, PCTSTR pszFileName, DWORD dwFlags);


HRESULT HrRegOpenAdapterKey(
        PCTSTR pszComponentName,
        BOOL fCreate,
        HKEY* phkey);

HRESULT
HrRegSetBool (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN BOOL fValue);

HRESULT
HrRegSetDword (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN DWORD dwValue);

HRESULT
HrRegSetGuidAsSz (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN const GUID& guid);

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetMultiSz
//
//  Purpose:    Sets a multi-sz in the registry.  Assures that its type and
//              size are correct.  Easier to read than HrRegSetValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      pszValue     [in]    The multi-sz to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetMultiSz (HKEY hkey, PCTSTR pszValueName, PCTSTR pszValue)
{
    return HrRegSetValueEx (
                hkey,
                pszValueName,
                REG_MULTI_SZ,
                (LPBYTE)pszValue,
                (CchOfMultiSzAndTermSafe (pszValue) * sizeof(WCHAR)));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetSz, HrRegSetString
//
//  Purpose:    Sets a string in the registry.  Assures that its type and
//              size are correct.  Easier to read than HrRegSetValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey          [in]   The registry key.
//      pszValueName  [in]   The name of the value to set.
//      pszValue, str [in]   The string to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetSz (HKEY hkey, PCTSTR pszValueName, PCTSTR pszValue)
{
    return HrRegSetValueEx (hkey, pszValueName, REG_SZ,
                            (LPBYTE)pszValue,
                            CbOfTSzAndTermSafe (pszValue));
}

#if 0
inline HRESULT HrRegSetString (HKEY hkey, PCTSTR pszValueName, const tstring& str)
{
    return HrRegSetSz (hkey, pszValueName, str.c_str());
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetBinary
//
//  Purpose:    Sets a binary value into the registry. Assures the type is
//              correct.
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      pbData       [in]    Buffer containing binary data to write.
//      cbData       [in]    Size of buffer in bytes.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   16 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetBinary(HKEY hkey, PCTSTR pszValueName,
                              const BYTE *pbData, DWORD cbData)
{
    return HrRegSetValueEx(hkey, pszValueName, REG_BINARY,
                           pbData, cbData);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetSzAsUlong
//
//  Purpose:    Writes the given ulong to the given registry value as a
//              REG_SZ.
//
//  Arguments:
//      hkey         [in] See Win32 docs.
//      pszValueName [in] See Win32 docs.
//      ulValue      [in] The value to write as a string
//      nBase        [in] The radix to convert the ulong from
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     billbe   14 Jun 1997
//
//  Notes:
//
inline
HRESULT
HrRegSetSzAsUlong (
    IN HKEY hkey,
    IN PCTSTR pszValueName,
    IN ULONG ulValue,
    IN int nBase)
{
    TCHAR szBuffer[20];

    // convert the value to a string using the specified base
    _ultot(ulValue, szBuffer, nBase);

    return HrRegSetSz(hkey, pszValueName, szBuffer);
}



//
//  Data structures
//

const HKEY      HKLM_SVCS       = (HKEY)(INT_PTR)(int)(0x80000007);

const DWORD     REG_MIN         = REG_QWORD;
const DWORD     REG_CREATE      = (REG_MIN + 1);
const DWORD     REG_BOOL        = (REG_MIN + 2);
const DWORD     REG_IP          = (REG_MIN + 3);
const DWORD     REG_FILE        = (REG_MIN + 4);
const DWORD     REG_HEX         = (REG_MIN + 5);

struct VALUETABLE
{
    // Name of value key
    PCTSTR          pszValueName;

    // Data and offset location
    DWORD           dwType;
    INT             cbOffset;

    // Default values
    BYTE*           pbDefault;
};

struct REGBATCH
{
    // Location of the registry entry
    HKEY            hkey;
    PCTSTR          pszSubkey;
    PCTSTR          pszValueName;

    // Data and offset location
    DWORD           dwType;
    INT             cbOffset;

    // Default values
    BYTE*           pbDefault;
};

VOID
RegReadValues (
    IN INT crvc,
    IN const REGBATCH* arb,
    OUT const BYTE* pbUserData,
    IN REGSAM samDesired);

HRESULT
HrRegWriteValues (
    IN INT crvc,
    IN const REGBATCH* arb,
    IN const BYTE* pbUserData,
    IN DWORD dwOptions,
    IN REGSAM samDesired);

HRESULT
HrRegWriteValueTable(
    IN HKEY hkeyRoot,
    IN INT cvt,
    IN const VALUETABLE* avt,
    IN const BYTE* pbUserData,
    IN DWORD dwOptions,
    IN REGSAM samDesired);

VOID
RegSafeCloseKey (
    IN HKEY hkey);

#endif // _NCREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G . H
//
//  Contents:   Common string routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "ncdebug.h"
#include <tchar.h>
#include <oleauto.h>

const int c_cchGuidWithTerm = 39; // includes terminating null
const int c_cbGuidWithTerm   = c_cchGuidWithTerm * sizeof(WCHAR);

char *stristr(const char *string1, const char *string2);

inline ULONG CbOfSz         (PCWSTR psz)   { AssertH(psz); return wcslen (psz) * sizeof(WCHAR); }
inline ULONG CbOfSza        (PCSTR  psza)  { AssertH(psza); return strlen (psza) * sizeof(CHAR); }
inline ULONG CbOfTSz        (PCTSTR psz)   { AssertH(psz); return _tcslen (psz) * sizeof(TCHAR); }

inline ULONG CbOfSzAndTerm  (PCWSTR psz)   { AssertH(psz); return (wcslen (psz) + 1) * sizeof(WCHAR); }
inline ULONG CbOfSzaAndTerm (PCSTR  psza)  { AssertH(psza); return (strlen (psza) + 1) * sizeof(CHAR); }
inline ULONG CbOfTSzAndTerm (PCTSTR psz)   { AssertH(psz); return (_tcslen (psz) + 1) * sizeof(TCHAR); }

ULONG CbOfSzSafe            (PCWSTR psz);
ULONG CbOfSzaSafe           (PCSTR  psza);
ULONG CbOfTSzSafe           (PCTSTR psz);

ULONG CbOfSzAndTermSafe     (PCWSTR psz);
ULONG CbOfSzaAndTermSafe    (PCSTR  psza);
ULONG CbOfTSzAndTermSafe    (PCTSTR psz);

ULONG
CchOfSzSafe (
    PCWSTR psz);

inline ULONG CchToCb        (ULONG cch)     { return cch * sizeof(WCHAR); }


struct MAP_SZ_DWORD
{
    PCWSTR pszValue;
    DWORD  dwValue;
};


PWSTR
WszAllocateAndCopyWsz (
    PCWSTR pszSrc);

DWORD
WINAPIV
DwFormatString (
    PCWSTR pszFmt,
    PWSTR  pszBuf,
    DWORD   cchBuf,
    ...);

DWORD
WINAPIV
DwFormatStringWithLocalAlloc (
    PCWSTR pszFmt,
    PWSTR* ppszBuf,
    ...);

//+---------------------------------------------------------------------------
//
//  Function:   FIsStrEmpty
//
//  Purpose:    Determines if the given PCWSTR is "empty" meaning the pointer
//              is NULL or the string is 0-length.
//
//  Arguments:
//      bstr [in]   BSTR to check.
//
//  Returns:    TRUE if the BSTR is empty, FALSE if not.
//
//  Author:     danielwe   20 May 1997
//
//  Notes:
//
inline
BOOL
FIsStrEmpty (
    PCWSTR    psz)
{
    return !(psz && *psz);
}

PCWSTR
WszLoadStringPcch (
    HINSTANCE   hinst,
    UINT        unId,
    int*        pcch);

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadString
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      See SzLoadStringPcch()
//
inline
PCWSTR
WszLoadString (
    HINSTANCE   hinst,
    UINT        unId)
{
    int cch;
    return WszLoadStringPcch(hinst, unId, &cch);
}

PSTR
SzaDupSza (
    IN PCSTR  pszaSrc);

PTSTR
TszDupTsz (
    IN PCTSTR pszSrc);

LPWSTR WszFromSz(LPCSTR szAnsi);
LPWSTR WszFromUtf8(LPCSTR szUtf8);
LPSTR SzFromWsz(LPCWSTR szWide);
LPSTR Utf8FromWsz(LPCWSTR szWide);

LPWSTR WszDupWsz(LPCWSTR szOld);

LPWSTR WszFromTsz(LPCTSTR pszInputString);
LPTSTR TszFromWsz(LPCWSTR szWide);

LPTSTR TszFromSz(LPCSTR szAnsi);
LPSTR SzFromTsz(LPCTSTR pszInputString);

inline VOID SzToWszBuf(LPWSTR wszDest, LPCSTR szAnsiSrc, DWORD cch)
{
    MultiByteToWideChar(CP_ACP, 0, szAnsiSrc, -1, wszDest, cch);
}

inline VOID WszToSzBuf(LPSTR szAnsiDest, LPCWSTR wszSrc, DWORD cch)
{
    WideCharToMultiByte(CP_ACP, 0, wszSrc, -1, szAnsiDest, cch, NULL, NULL);
}

inline VOID WszToWszBuf(LPWSTR wszDest, LPCWSTR wszSrc, DWORD cch)
{
    wcsncpy(wszDest, wszSrc, cch - 1);
    wszDest[cch - 1] = UNICODE_NULL;
}

inline VOID SzToSzBuf(LPSTR szDest, LPCSTR szSrc, DWORD cch)
{
    strncpy(szDest, szSrc, cch - 1);
    szDest[cch - 1] = '\0';
}

#ifdef UNICODE
#define SzToTszBuf SzToWszBuf
#else
#define SzToTszBuf SzToSzBuf
#endif // UNICODE

#ifdef UNICODE
#define WszToTszBuf WszToWszBuf
#else
#define WszToTszBuf WszToSzBuf
#endif // UNICODE

#ifdef UNICODE
#define TszToSzBuf WszToSzBuf
#else
#define TszToSzBuf SzToSzBuf
#endif // UNICODE

#ifdef UNICODE
#define TszToWszBuf WszToWszBuf
#else
#define TszToWszBuf SzToWszBuf
#endif // UNICODE


HRESULT
HrAddStringToDelimitedSz (
    PCTSTR pszAddString,
    PCTSTR pszIn,
    TCHAR chDelimiter,
    DWORD dwFlags,
    DWORD dwStringIndex,
    PTSTR* ppszOut);

HRESULT
HrRemoveStringFromDelimitedSz (
    PCTSTR pszRemove,
    PCTSTR pszIn,
    TCHAR chDelimiter,
    DWORD dwFlags,
    PTSTR* ppszOut);

HRESULT
HrReallocAndCopyString(/* IN */ LPCWSTR pszSrc, /* INOUT */ LPWSTR * ppszDest);

LPWSTR COMSzFromWsz(LPCWSTR szOld);

HRESULT HrCopyString(const char * szSrc, char ** pszDest);
HRESULT HrCopyString(const wchar_t * szSrc, wchar_t ** pszDest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncutil.h ===
HRESULT HrGetProperty(IDispatch * lpObject, OLECHAR *lpszProperty, VARIANT * lpResult);
HRESULT HrJScriptArrayToSafeArray(IDispatch *JScriptArray, VARIANT * pVtResult);
HRESULT HrConvertStringToLong(IN    LPWSTR  pwsz, OUT   LONG    * plValue);
HRESULT HrBytesToVariantArray(IN LPBYTE   pbData, IN ULONG    cbData, OUT VARIANT *pVariant);
HRESULT HrGetGITPointer(IGlobalInterfaceTable ** ppgit);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncmsz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M S Z . H
//
//  Contents:   Common multi-sz routines.
//
//  Notes:      Split out from ncstring.h and included by ncstring.h
//
//  Author:     shaunco   7 Jun 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMSZ_H_
#define _NCMSZ_H_

ULONG
CchOfMultiSzSafe (
    IN PCTSTR pmsz);

ULONG
CchOfMultiSzAndTermSafe (
    IN PCTSTR pmsz);

inline ULONG
CbOfMultiSzAndTermSafe (
    IN PCTSTR pmsz)
{
    return CchOfMultiSzAndTermSafe (pmsz) * sizeof(WCHAR);
}


BOOL
FGetSzPositionInMultiSzSafe (
    IN PCTSTR psz,
    IN PCTSTR pmsz,
    OUT DWORD* pdwIndex,
    OUT BOOL *pfDuplicatePresent,
    OUT DWORD* pcStrings);

BOOL
FIsSzInMultiSzSafe (
    IN PCTSTR psz,
    IN PCTSTR pmsz);

// flags for HrAddSzToMultiSz and RemoveSzFromMultiSz
const   DWORD   STRING_FLAG_ALLOW_DUPLICATES       =   0x00000001;
const   DWORD   STRING_FLAG_ENSURE_AT_FRONT        =   0x00000002;
const   DWORD   STRING_FLAG_ENSURE_AT_END          =   0x00000004;
const   DWORD   STRING_FLAG_ENSURE_AT_INDEX        =   0x00000008;
const   DWORD   STRING_FLAG_DONT_MODIFY_IF_PRESENT =   0x00000010;
const   DWORD   STRING_FLAG_REMOVE_SINGLE          =   0x00000020;
const   DWORD   STRING_FLAG_REMOVE_ALL             =   0x00000040;

HRESULT
HrAddSzToMultiSz (
    IN PCTSTR pszAddString,
    IN PCTSTR pmszIn,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PTSTR* ppmszOut,
    OUT BOOL* pfChanged);


HRESULT
HrCreateArrayOfStringPointersIntoMultiSz (
    IN PCTSTR     pmszSrc,
    OUT UINT*       pcStrings,
    OUT PCTSTR**   papsz);

VOID
RemoveSzFromMultiSz (
    IN PCTSTR psz,
    IN OUT PTSTR  pmsz,
    IN DWORD   dwFlags,
    OUT BOOL*   pfRemoved);

VOID
SzListToMultiSz (
    IN PCTSTR psz,
    OUT DWORD*  pcb,
    OUT PTSTR* ppszOut);


#endif // _NCMSZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C U I . H
//
//  Contents:   Common user interface routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCUI_H_
#define _NCUI_H_

#include "ncbase.h"

inline
HCURSOR
BeginWaitCursor ()
{
    return SetCursor(LoadCursor(NULL, IDC_WAIT));
}

inline
VOID
EndWaitCursor (
    HCURSOR hcurPrev)
{
    // BeginWaitCursor may return a NULL cursor.  This is just
    // a saftey net.
    //
    if (!hcurPrev)
    {
        hcurPrev = LoadCursor(NULL, IDC_ARROW);
    }
    SetCursor(hcurPrev);
}

// To get an automatic wait cursor, simply declare an instance
// of CWaitCursor.  The cursor will be restored when the instance is
// destroyed.  (i.e. declare it on the stack.)
//
class CWaitCursor
{
private:
    HCURSOR m_hcurPrev;

public:
    CWaitCursor  ()  { m_hcurPrev = BeginWaitCursor (); }
    ~CWaitCursor ()  { EndWaitCursor (m_hcurPrev); }
};


//
// Enables or disables a set of controls in a dialog.
//
// Use this when you're enabling/disabling more than about two controls.
// Be sure to declare the array of control ids as 'static const' if you can.
//
NOTHROW
VOID
EnableOrDisableDialogControls (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    BOOL fEnable);


//
// Map back and forth between a set of radio buttons and a DWORD value.
//
// Be sure to declare the array as 'static const' if you can.
//
struct RADIO_BUTTON_MAP
{
    INT     cid;        // control id of radio button
    DWORD   dwValue;    // value associated with this radio button
};

NOTHROW
BOOL
FMapRadioButtonToValue (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD*		    pdwValue);

NOTHROW
BOOL
FMapValueToRadioButton (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD                   dwValue,
    INT*		    pncid);

INT
GetIntegerFormat (
    LCID    Locale,
    PCWSTR pszValue,
    PWSTR  pszFormattedValue,
    INT     cchFormattedValue);

INT
Format32bitInteger (
    UINT32  unValue,
    BOOL    fSigned,
    PWSTR  pszFormattedValue,
    INT     cchFormattedValue);

INT
Format64bitInteger (
    UINT64   ulValue,
    BOOL     fSigned,
    PWSTR   pszFormattedValue,
    INT      cchFormattedValue);

BOOL
SetDlgItemFormatted32bitInteger (
    HWND    hDlg,
    INT     nIdDlgItem,
    UINT32  unValue,
    BOOL    fSigned);

BOOL
SetDlgItemFormatted64bitInteger (
    HWND    hDlg,
    INT     nIdDlgItem,
    UINT64  ulValue,
    BOOL    fSigned);

// dwFlags for HrNcQueryUserForRebootEx
//
// Combine both to get original behavior, or do one at a time to first prompt
// then second, actually reboot.
//
//#define QUFR_PROMPT 0x00000001
//#define QUFR_REBOOT 0x00000002

HRESULT
HrNcQueryUserForRebootEx (
    HWND        hwndParent,
    PCWSTR     pszCaption,
    PCWSTR     pszText,
    DWORD       dwFlags);

HRESULT
HrNcQueryUserForReboot (
    HINSTANCE   hinst,
    HWND        hwndParent,
    UINT        unIdCaption,
    UINT        unIdText,
    DWORD       dwFlags);

#ifdef _INC_SHELLAPI

HRESULT
HrShell_NotifyIcon (
    DWORD dwMessage,
    PNOTIFYICONDATA pData);

#endif // _INC_SHELLAPI

NOTHROW
LRESULT
LresFromHr (
    HRESULT hr);

NOTHROW
INT
WINAPIV
NcMsgBox (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);

NOTHROW
INT
WINAPIV
NcMsgBoxWithVarCaption (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    PCWSTR     szCaptionParam,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);

NOTHROW
INT
WINAPIV
NcMsgBoxWithWin32ErrorText (
    DWORD       dwError,
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdCombineFormat,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);


VOID
SendDlgItemsMessage (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    UINT        unMsg,
    WPARAM      wParam,
    LPARAM      lParam);

VOID
SetDefaultButton(
    HWND hdlg,
    INT iddef);

struct CONTEXTIDMAP
{
    INT     idControl;
    DWORD   dwContextId;
    DWORD   dwContextIdJapan;
};
typedef const CONTEXTIDMAP * PCCONTEXTIDMAP;

VOID OnHelpGeneric(
    HWND hwnd, 
    LPHELPINFO lphi,
    PCCONTEXTIDMAP pContextMap,
    BOOL bJpn, 
    PCWSTR pszHelpFile);

#endif // _NCUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\pch.h ===
#pragma once

//#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
//#define NOCOMM
#define NOCRYPT
//#define NOGDI
//#define NOICONS
#define NOIME
//#define NOMCX
//#define NOMDI
//#define NOMENUS
//#define NOMETAFILE
#define NOSOUND
//#define NOSYSPARAMSINFO
//#define NOWH
//#define NOWINABLE
//#define NOWINRES

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include <windows.h>
#include <objbase.h>

#include <devguid.h>
#include <wchar.h>
#include <tchar.h>

#include <upnp.h>
#include <upnpp.h>

#include "ncmem.h"
//#include "ncbase.h"
#include "ncdefine.h"
#include "ncdebug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ssdperror.h ===
#define SSDP_ERROR_BASE 18000
#define ERROR_NO_MORE_SERVICES SSDP_ERROR_BASE+1
#define ERROR_TIMER_START_FAILED SSDP_ERROR_BASE+2
#define ERROR_DUPLICATE_SERVICE SSDP_ERROR_BASE+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ncxml.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       ncxml.h
//
//  Contents:   helper functions for doing remarkably simple things
//              with the XML DOM.
//
//----------------------------------------------------------------------------


#ifndef __NCXML_H_
#define __NCXML_H_

/*
 * Enum SST_DATA_TYPE
 *
 * Possible types of state variables
 */

enum SST_DATA_TYPE              // Type returned by msxml
{                               // ----------------------
    SDT_STRING = 0,             // VT_BSTR
    SDT_NUMBER,                 // VT_BSTR
    SDT_INT,                    // VT_I4
    SDT_FIXED_14_4,             // VT_CY
    SDT_BOOLEAN,                // VT_BOOL
    SDT_DATETIME_ISO8601,       // VT_DATE
    SDT_DATETIME_ISO8601TZ,     // VT_DATE
    SDT_DATE_ISO8601,           // VT_DATE
    SDT_TIME_ISO8601,           // VT_DATE
    SDT_TIME_ISO8601TZ,         // VT_DATE
    SDT_I1,                     // VT_I1
    SDT_I2,                     // VT_I2
    SDT_I4,                     // VT_I4
    SDT_UI1,                    // VT_UI1
    SDT_UI2,                    // VT_UI2
    SDT_UI4,                    // VT_UI4
    SDT_R4,                     // VT_FLOAT
    SDT_R8,                     // VT_DOUBLE
    SDT_FLOAT,                  // VT_DOUBLE
    SDT_UUID,                   // VT_BSTR
    SDT_BIN_BASE64,             // VT_ARRAY
    SDT_BIN_HEX,                // VT_ARRAY
    SDT_CHAR,                   // VT_UI2 (a wchar)
    SDT_URI,                    // VT_BSTR
    //
    // note(cmr): ADD NEW VALUES IMMEDIATELY BEFORE THIS COMMENT
    //
    SDT_INVALID
};

// Reading values from elements

HRESULT HrGetTypedValueFromElement(IXMLDOMNode * pxdn,
                                   CONST LPCWSTR pszDataType,
                                   VARIANT * pvarOut);

HRESULT HrGetTypedValueFromChildElement(IXMLDOMNode * pxdn,
                                        CONST LPCWSTR * arypszTokens,
                                        CONST ULONG cTokens,
                                        CONST LPCWSTR pszDataType,
                                        VARIANT * pvarOut);

HRESULT HrGetTextValueFromElement(IXMLDOMNode * pxdn,
                                  BSTR * pbstrOut);

HRESULT HrGetTextValueFromChildElement(IXMLDOMNode * pxde,
                                       const LPCWSTR * arypszTokens,
                                       const ULONG cTokens,
                                       BSTR * pbstrOut);


// Navigating the tree

BOOL FIsThisTheNodeName(IXMLDOMNode * pxdn,
                        LPCWSTR pszNodeName);

BOOL
FIsThisTheNodeNameWithNamespace(IXMLDOMNode * pxdn,
                                LPCWSTR pszNodeName,
                                LPCWSTR pszNamespaceURI);

BOOL
FIsThisTheNodeTextValue(
    IN IXMLDOMNode * pxdn,
    IN LPCWSTR     cszTextValue);

BOOL
FAreNodeValuesEqual(
    IN IXMLDOMNode * pxdn1,
    IN IXMLDOMNode * pxdn2);

HRESULT
HrAreThereDuplicatesInChildNodeTextValues(
    IN  IXMLDOMNode * pxdn,
    IN  LPCWSTR     cszXSLPattern,
    IN  BOOL        fCaseSensitive,
    OUT BOOL        * pfDuplicatesExist);


HRESULT HrGetFirstChildElement(IXMLDOMNode * pxdn,
                               LPCWSTR pszNodeName,
                               IXMLDOMNode ** ppxdn);

HRESULT HrGetNextChildElement(IXMLDOMNode * pxdnLastChild,
                              LPCWSTR pszNodeName,
                              IXMLDOMNode ** ppxde);

HRESULT HrGetNestedChildElement(IXMLDOMNode * pxdeRoot,
                                const LPCWSTR * arypszTokens,
                                const ULONG cTokens,
                                IXMLDOMNode ** ppxde);


// Parsing nodes

struct DevicePropertiesParsingStruct
{
	BOOL    m_fOptional;
	BOOL    m_fIsUrl;
	BOOL	m_fValidateUrl;
	LPCWSTR m_pszTagName;
};

HRESULT HrAreElementTagsValid(IXMLDOMNode *pxdnRoot,
                                     const ULONG cElems,
                                     const DevicePropertiesParsingStruct dppsInfo []);

HRESULT HrIsElementPresentOnce(IXMLDOMNode * pxdnRoot,
                                LPCWSTR pszNodeName );

HRESULT HrCheckForDuplicateElement(IXMLDOMNode * pxdnRoot,
                                            LPCWSTR pszNodeName );

HRESULT HrReadElementWithParseData (IXMLDOMNode * pxdn,
                             const ULONG cElems,
                             const DevicePropertiesParsingStruct dppsInfo [],
                             LPCWSTR pszBaseUrl,
                             LPWSTR arypszReadValues []);

BOOL fAreReadValuesComplete (const ULONG cElems,
                             const DevicePropertiesParsingStruct dppsInfo [],
                             const LPCWSTR arypszReadValues []);


HRESULT
HrGetTextValueFromAttribute(
    IN  IXMLDOMNode    * pxdn,
    IN  LPCWSTR        szAttrName,
    OUT BSTR           * pbstrAttrValue);


// Creating nodes

HRESULT HrSetTextAttribute(IXMLDOMElement * pElement,
                           LPCWSTR        pcwszAttrName,
                           LPCWSTR        pcwszValue);

HRESULT HrCreateElementWithType(IN   IXMLDOMDocument *     pDoc,
                                IN   LPCWSTR               pcwszElementName,
                                IN   LPCWSTR               pszDataType,
                                IN   VARIANT               varData,
                                OUT  IXMLDOMElement **     ppElement);


HRESULT HrCreateElementWithTextValue(IN   IXMLDOMDocument * pDoc,
                                     IN   LPCWSTR         pcwszElementName,
                                     IN   LPCWSTR         pcwszTextValue,
                                     OUT  IXMLDOMElement  ** ppElement);

HRESULT HrCreateElement(
    IN  IXMLDOMDocument    * pxdd,
    IN  LPCWSTR            pcwszElementName,
    IN  LPCWSTR            pcwszNamespaceURI,
    OUT IXMLDOMNode        ** ppxdnNewElt);

HRESULT HrAppendProcessingInstruction(
    IN  IXMLDOMDocument * pxdd,
    IN  LPCWSTR         pcwszName,
    IN  LPCWSTR         pcwszValue);

extern
LPCWSTR
GetStringFromType(CONST SST_DATA_TYPE sdt);

extern
SST_DATA_TYPE
GetTypeFromString(LPCWSTR pszTypeString);

extern
VARTYPE
GetVarTypeFromString(LPCWSTR pszTypeString);



#endif // __NCXML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ssdpapi.h ===
#ifndef _SSDPAPI_H
#define _SSDPAPI_H

#include <windows.h>
#include "ssdp.h"
#include "ssdperror.h"

#ifdef  __cplusplus
extern "C" {
#endif

// DO NOT REORDER THIS ENUMERATION.  ADD NEW VALUES TO THE END.
//   if you do, change the necessary code in upnpdevicefinder.cpp
typedef enum _SSDP_CALLBACK_TYPE {
    SSDP_FOUND = 0,
    SSDP_ALIVE = 1,
    SSDP_BYEBYE = 2,
    SSDP_DONE = 3,
    SSDP_EVENT = 4,
    SSDP_DEAD = 5,
} SSDP_CALLBACK_TYPE, *PSSDP_CALLBACK_TYPE;

const TCHAR c_szReplaceGuid[] = TEXT("5479f6b6-71ac-44fc-9164-7e901a557f81");
const DWORD c_cchReplaceGuid = (sizeof(c_szReplaceGuid) / sizeof(TCHAR)) - 1;

typedef void (WINAPI *SERVICE_CALLBACK_FUNC)(SSDP_CALLBACK_TYPE CallbackType,
                                      CONST SSDP_MESSAGE *pSsdpService,
                                      void *pContext);

VOID WINAPI FreeSsdpMessage(PSSDP_MESSAGE pSsdpMessage);

HANDLE WINAPI RegisterService(PSSDP_MESSAGE pSsdpMessage, DWORD flags);

BOOL WINAPI DeregisterService(HANDLE hRegister, BOOL fByebye);

BOOL WINAPI DeregisterServiceByUSN(char * szUSN, BOOL fByebye);

HANDLE WINAPI RegisterNotification (NOTIFY_TYPE nt, char * szType, char *szEventUrl, SERVICE_CALLBACK_FUNC fnCallback,void *pContext);

BOOL WINAPI DeregisterNotification(HANDLE hNotification);

BOOL WINAPI RegisterUpnpEventSource(LPCSTR szRequestUri, DWORD cProps,
                                    UPNP_PROPERTY *rgProps);
BOOL WINAPI DeregisterUpnpEventSource(LPCSTR szRequestUri);

BOOL WINAPI SubmitUpnpPropertyEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                                    DWORD cProps, UPNP_PROPERTY *rgProps);

BOOL WINAPI SubmitEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                        LPCSTR szHeaders, LPCSTR szEventBody);

BOOL WINAPI GetEventSourceInfo(LPCSTR szEventSourceUri, EVTSRC_INFO **ppinfo);

HANDLE WINAPI FindServices (char* szType, void *pReserved , BOOL fForceSearch);

HANDLE WINAPI FindServicesCallback (char * szType,
                             void * pReserved ,
                             BOOL fForceSearch,
                             SERVICE_CALLBACK_FUNC fnCallback,
                             void *Context
                             );

BOOL WINAPI GetFirstService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI GetNextService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI FindServicesClose(HANDLE hSearch);

BOOL WINAPI FindServicesCancel(HANDLE hSearch);

BOOL WINAPI CleanupCache();

BOOL WINAPI SsdpStartup();

void WINAPI SsdpCleanup();

void WINAPI DHEnableDeviceHost();
void WINAPI DHDisableDeviceHost();
void WINAPI DHSetICSInterfaces(long nCount, GUID * arInterfaces);
void WINAPI DHSetICSOff();

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif // _SSDPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\trace.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E . H
//
//  Contents:   Class definition for CTracing
//
//  Notes:
//
//  Author:     jeffspr   15 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "tracetag.h"

#ifdef ENABLETRACE

// This is needed for TraceHr, since we can't use a macro (vargs), but we
// need to get the file and line from the source.
#define FAL __FILE__,__LINE__

// Trace error functions. The leaading _ is to establish the real function,
// while adding a new macro so we can add __FILE__ and __LINE__ to the output.
//
VOID    WINAPI   TraceErrorFn           (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr);
VOID    WINAPI   TraceResultFn          (PCSTR pszaFile, INT nLine, PCSTR psza, BOOL f);
VOID    WINAPI   TraceErrorOptionalFn   (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, BOOL fOpt);
VOID    WINAPI   TraceErrorSkipFn       (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, UINT c, ...);
VOID    WINAPIV  TraceLastWin32ErrorFn  (PCSTR pszaFile, INT nLine, PCSTR psza);

#define TraceError(sz, hr)                      TraceErrorFn(__FILE__, __LINE__, sz, hr);
#define TraceResult(sz, f)                      TraceResultFn(__FILE__, __LINE__, sz, f);
#define TraceErrorOptional(sz, hr, _bool)       TraceErrorOptionalFn(__FILE__, __LINE__, sz, hr, _bool);
#define TraceErrorSkip1(sz, hr, hr1)            TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 1, hr1);
#define TraceErrorSkip2(sz, hr, hr1, hr2)       TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 2, hr1, hr2);
#define TraceErrorSkip3(sz, hr, hr1, hr2, hr3)  TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 3, hr1, hr2, hr3);
#define TraceLastWin32Error(sz)                 TraceLastWin32ErrorFn(__FILE__,__LINE__, sz);

VOID
WINAPIV
TraceHr (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    HRESULT     hr,
    BOOL        fIgnore,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceTag (
    TRACETAGID  ttid,
    PCSTR       pszaFmt,
    ...);


#else   // !ENABLETRACE

#define FAL                                         (void)0
#define TraceError(_sz, _hr)
#define TraceResult(_sz, _f)
#define TraceErrorOptional(_sz, _hr, _bool)
#define TraceErrorSkip1(_sz, _hr, _hr1)
#define TraceErrorSkip2(_sz, _hr, _hr1, _hr2)
#define TraceErrorSkip3(_sz, _hr, _hr1, _hr2, _hr3)
#define TraceLastWin32Error(_sz)
#define TraceHr                                     NOP_FUNCTION
#define TraceTag                                    NOP_FUNCTION


#endif  // ENABLETRACE

#ifdef ENABLETRACE


//---[ Initialization stuff ]-------------------------------------------------

HRESULT HrInitTracing();
HRESULT HrUnInitTracing();

#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\upfile.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U P F I L E . H 
//
//  Contents:   File utility functions.
//
//  Notes:      This is separate from ncfile.h so we don't bring the shell
//              dependencies into upnphost.
//
//  Author:     mbend   18 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

HRESULT HrCreateFile(
    const wchar_t * szFilename,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE * phandle);

HRESULT HrLoadFileFromDisk(
    const wchar_t * szFilename, 
    long * pnFileSize, byte ** parBytes);

const long UH_MAX_EXTENSION = 5;

HRESULT HrGetFileExtension(const wchar_t * szFilename, wchar_t szExt[UH_MAX_EXTENSION]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\tracetag.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E T A G . H
//
//  Contents:   Trace tag definitions for the Netcfg project
//
//  Notes:      B-flat, C-sharp
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _TRACETAG_H_
#define _TRACETAG_H_


// TraceTagIds are the identifiers for tracing areas, and are used in calls
// to TraceTag.  We need this defined outside of of ENABLETRACE so that
// calls to the TraceTag macro don't break when ENABLETRACE is not defined.
//
// Hungarian == ttid
//
enum TraceTagId
{
    ttidDefault         = 0,
    ttidDescMan,
    ttidError,
    ttidEsLock,
    ttidEvents,
    ttidEventServer,
    ttidIsapiCtl,
    ttidIsapiEvt,
    ttidMedia,
    ttidRegistrar,
    ttidShellEnum,
    ttidShellFolder,
    ttidShellFolderIface,
    ttidShellTray,
    ttidShellViewMsgs,
    ttidSsdpAnnounce,
    ttidSsdpRpcInit,
    ttidSsdpRpcStop,
    ttidSsdpRpcIf,
    ttidSsdpSocket,
    ttidSsdpRecv,
    ttidSsdpNetwork,
    ttidSsdpParser,
    ttidSsdpSearchResp,
    ttidSsdpSysSvc,
    ttidSsdpCache,
    ttidSsdpNotify,
    ttidSsdpCRpcInit,
    ttidSsdpCNotify,
    ttidSsdpCSearch,
    ttidSsdpCPublish,
    ttidSsdpTimer,
    ttidUPnPBase,
    ttidUPnPHost,
    ttidUpdiag,
    ttidUPnPDescriptionDoc,
    ttidUPnPDeviceFinder,
    ttidRehydrator,
    ttidUPnPService,
    ttidUPnPDocument,
    ttidUPnPEnum,
    ttidUPnPSampleDevice,
    ttidSOAPRequest,
    ttidUDHISAPI,
    ttidAutomationProxy,
    ttidWebServer,
    ttidValidate
};


// Just for kicks
//
typedef enum TraceTagId TRACETAGID;

#ifdef ENABLETRACE

// Maximum sizes for the trace tag elements.
const int c_iMaxTraceTagShortName   = 16;
const int c_iMaxTraceTagDescription = 128;

// For each element in the tracetag list
//
struct TraceTagElement
{
    TRACETAGID  ttid;
    CHAR        szShortName[c_iMaxTraceTagShortName+1];
    CHAR        szDescription[c_iMaxTraceTagDescription+1];
    BOOL        fOutputDebugString;
    BOOL        fOutputToFile;
    BOOL        fVerboseOnly;
};

typedef struct TraceTagElement  TRACETAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern TRACETAGELEMENT      g_TraceTags[];
extern const INT            g_nTraceTagCount;

#endif // ENABLETRACE

#endif  // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ulist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U L I S T . H 
//
//  Contents:   Simple list class
//
//  Notes:      
//
//  Author:     mbend   1 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "array.h"

template <class Type>
class CUList
{
    class Node
    {
    public:
        Node() : m_pNext(NULL)
        {
        }
        ~Node()
        {
            Node * pNode = m_pNext;
            while(pNode)
            {
                Node * pNodeDel = pNode;
                pNode = pNodeDel->m_pNext;
                pNodeDel->m_pNext = NULL;
                delete pNodeDel;
            }
            m_pNext = NULL;
        }

        Node * m_pNext;
        Type m_type;
    private:
        Node(const Node &);
        Node & operator=(const Node &);
    };

public:
    CUList() : m_pList(NULL) {}
    ~CUList() 
    {
        Clear();
    }

    class Iterator
    {
        friend CUList<Type>;
    public:
        Iterator() : m_ppNode(NULL) {}
        HRESULT HrGetItem(Type ** ppItem)
        {
            if(!m_ppNode || !*m_ppNode)
            {
                return E_UNEXPECTED;
            }
            *ppItem = &(*m_ppNode)->m_type;
            return S_OK;
        }
        BOOL FIsItem() const
        {
            return NULL != m_ppNode && NULL != *m_ppNode;
        }

        // Return S_FALSE at the end of the list

        HRESULT HrNext()
        {
            if(!m_ppNode || !*m_ppNode)
            {
                return E_UNEXPECTED;
            }
            m_ppNode = &(*m_ppNode)->m_pNext;
            if(!*m_ppNode)
            {
                return S_FALSE;
            }
            return S_OK;
        }
        HRESULT HrErase()
        {
            if(!m_ppNode || !*m_ppNode)
            {
                return E_UNEXPECTED;
            }
            CUList<Type>::Node * pNode = *m_ppNode;
            *m_ppNode = (*m_ppNode)->m_pNext;
            pNode->m_pNext = NULL;
            delete pNode;
            if(!*m_ppNode)
            {
                return S_FALSE;
            }
            return S_OK;
        }
        HRESULT HrRemoveTransfer(Type & type)
        {
            if(!m_ppNode || !*m_ppNode)
            {
                return E_UNEXPECTED;
            }
            CUList<Type>::Node * pNode = *m_ppNode;
            *m_ppNode = (*m_ppNode)->m_pNext;
            pNode->m_pNext = NULL;
            TypeTransfer(type, pNode->m_type);
            delete pNode;
            if(!*m_ppNode)
            {
                return S_FALSE;
            }
            return S_OK;
        }
        HRESULT HrMoveToList(CUList<Type> & list)
        {
            if(!m_ppNode || !*m_ppNode)
            {
                return E_UNEXPECTED;
            }
            CUList<Type>::Node * pNode = *m_ppNode;
            *m_ppNode = (*m_ppNode)->m_pNext;
            pNode->m_pNext = list.m_pList;
            list.m_pList = pNode;
            if(!*m_ppNode)
            {
                return S_FALSE;
            }
            return S_OK;
        }
    private:
        Iterator(const Iterator &);
        Iterator & operator=(const Iterator &);
        void Init(CUList<Type>::Node ** ppNode)
        {
            m_ppNode = ppNode;
        }
        CUList<Type>::Node ** m_ppNode;
    };

    friend class CUList<Type>::Iterator;

    HRESULT GetIterator(Iterator & iterator)
    {
        iterator.Init(&m_pList);
        return m_pList ? S_OK : S_FALSE;
    }

    // Sizing functions

    long GetCount() const
    {
        Node * pNode = m_pList;
        for(long n = 0; NULL != pNode; ++n, pNode = pNode->m_pNext);
        return n;
    }
    BOOL IsEmpty() const
    {
        return NULL == m_pList;
    }
    void Clear()
    {
        delete m_pList;
        m_pList = NULL;
    }

    // Insertion function

    HRESULT HrPushFrontDefault()
    {
        HRESULT hr = S_OK;
        Node * pNode = new Node;
        if(pNode)
        {
            pNode->m_pNext = m_pList;
            m_pList = pNode;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        return hr;
    }

    HRESULT HrPushFront(const Type & type)
    {
        HRESULT hr = S_OK;
        Node * pNode = new Node;
        if(pNode)
        {
            hr = HrTypeAssign(pNode->m_type, type);
            if(SUCCEEDED(hr))
            {
                pNode->m_pNext = m_pList;
                m_pList = pNode;
            }
            if(FAILED(hr))
            {
                delete pNode;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        return hr;
    }

    HRESULT HrPushFrontTransfer(Type & type)
    {
        HRESULT hr = S_OK;
        Node * pNode = new Node;
        if(pNode)
        {
            TypeTransfer(pNode->m_type, type);
            pNode->m_pNext = m_pList;
            m_pList = pNode;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        return hr;
    }

    Type & Front()
    {
        Assert(m_pList);
        return m_pList->m_type;
    }

    // Removal

    HRESULT HrPopFrontTransfer(Type & type)
    {
        if(!m_pList)
        {
            return E_UNEXPECTED;
        }
        TypeTransfer(type, m_pList->m_type);
        Node * pNode = m_pList;
        m_pList = pNode->m_pNext;
        pNode->m_pNext = NULL;
        delete pNode;
        return S_OK;
    }

    void Swap(CUList & ref)
    {
        Node * pNode = ref.m_pList;
        ref.m_pList = m_pList;
        m_pList = pNode;
    }

    // List manipulation

    void Append(CUList<Type> & list)
    {
        // Find end of list
        Node ** ppNode = &m_pList;
        while(*ppNode != NULL)
        {
            ppNode = &(*ppNode)->m_pNext;
        }
        *ppNode = list.m_pList;
        list.m_pList = NULL;
    }
    void Prepend(CUList<Type> & list)
    {
        // Find end of list
        Node ** ppNode = &list.m_pList;
        while(*ppNode != NULL)
        {
            ppNode = &(*ppNode)->m_pNext;
        }
        *ppNode = m_pList;
        m_pList = list.m_pList;
        list.m_pList = NULL;
    }

private:
    CUList(const CUList &);
    CUList & operator=(const CUList &);

    Node * m_pList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\upnpatl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P N P A T L . H 
//
//  Contents:   Common includes for upnp ATL usage
//
//  Notes:      
//
//  Author:     jeffspr   15 Sep 1999
//
//----------------------------------------------------------------------------

#ifndef _UPNPATL_H_
#define _UPNPATL_H_
#pragma once

#include <atldef.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#pragma warning(disable : 4530)     // disable warnings about exception handling
#include <vector>
#include <comdef.h>
using namespace std;

#endif // _UPNPATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\table.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       T A B L E . H 
//
//  Contents:   Simple templated table class
//
//  Notes:      
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "Array.h"

template <class Key, class Value>
class CTable
{
public:
    typedef CUArray<Key> KeyArray;
    typedef CUArray<Value> ValueArray;

    CTable() {}
    ~CTable() {}

    // Insertion

    HRESULT HrInsert(const Key & key, const Value & value)
    {
        Value * pValue = Lookup(key);
        if(pValue)
        {
            return HrTypeAssign(*pValue, value);
        }
        HRESULT hr;
        
        hr = m_keys.HrPushBack(key);
        if(SUCCEEDED(hr))
        {
            hr = m_values.HrPushBack(value);
            if(FAILED(hr))
            {
                m_keys.HrPopBack();
            }
        }
        return hr;
    }

    HRESULT HrInsertTransfer(Key & key, Value & value)
    {
        HRESULT hr = S_OK;
        Value * pValue = Lookup(key);
        if(pValue)
        {
            TypeTransfer(*pValue, value);
            return hr;
        }
        hr = m_keys.HrPushBackTransfer(key);
        if(SUCCEEDED(hr))
        {
            hr = m_values.HrPushBackTransfer(value);
            if(FAILED(hr))
            {
                m_keys.HrPopBack();
            }
        }
        return hr;
    }

    HRESULT HrAppendTableTransfer(CTable<Key, Value> & table)
    {
        HRESULT hr = S_OK;
        long n;
        long nCount = table.Keys().GetCount();
        // Transfer items
        for(n = 0; n < nCount && SUCCEEDED(hr); ++n)
        {
            hr = HrInsertTransfer(table.m_keys[n], table.m_values[n]);
        }
        // Remove items if we failed
        if(FAILED(hr))
        {
            nCount = n;
            for(n = 0; n < nCount; ++n)
            {
                m_keys.HrPopBack();
                m_values.HrPopBack();
            }
        }
        // Clear the passed in table
        table.Clear();
        return hr;
    }

    // Data access

    Value * Lookup(const Key & key)
    {
        long nCount = m_keys.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            if(key == m_keys[n])
            {
                return &m_values[n];
            }
        }
        return NULL;
    }
    const Value * Lookup(const Key & key) const
    {
        long nCount = m_keys.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            if(key == m_keys[n])
            {
                return &m_values[n];
            }
        }
        return NULL;
    }
    HRESULT HrLookup(const Key & key, Value ** ppValue)
    {
        if(!ppValue)
        {
            return E_POINTER;
        }
        HRESULT hr = E_INVALIDARG;
        *ppValue = Lookup(key);
        if(*ppValue)
        {
            hr = S_OK;
        }
        return hr;
    }
    HRESULT HrLookup(const Key & key, const Value ** ppValue) const
    {
        if(!ppValue)
        {
            return E_POINTER;
        }
        HRESULT hr = E_INVALIDARG;
        *ppValue = Lookup(key);
        if(*ppValue)
        {
            hr = S_OK;
        }
        return hr;
    }

    // Cleanup

    void Clear()
    {
        m_keys.Clear();
        m_values.Clear();
    }

    // Removal
    
    HRESULT HrErase(const Key & key)
    {
        long nCount = m_keys.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            if(key == m_keys[n])
            {
                HRESULT hr;
                hr = m_keys.HrErase(n);
                Assert(SUCCEEDED(hr));
                if(SUCCEEDED(hr))
                {
                    hr = m_values.HrErase(n);
                }
                return hr;
            }
        }
        return E_INVALIDARG;
    }

    // Iteration

    const KeyArray & Keys() const
    {
        return m_keys;
    }
    const ValueArray & Values() const
    {
        return m_values;
    }

    // Special

    void Swap(CTable<Key, Value> & table)
    {
        m_keys.Swap(table.m_keys);
        m_values.Swap(table.m_values);
    }
private:
    CTable(const CTable &);
    CTable & operator=(const CTable &);

    KeyArray m_keys;
    ValueArray m_values;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\upnpdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P N P D E F S . H 
//
//  Contents:   UPnP Common defines
//
//  Notes:      
//
//  Author:     jeffspr   8 Nov 1999
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _UPNPDEFS_H_
#define _UPNPDEFS_H_

// These are somewhat arbitrary, in that they just have to be less than 64K
// (for XML's sake, probably), but better to start low and grow if needed
//
#define MAX_UDN_SZ      256
#define MAX_USN_SZ      (MAX_UDN_SZ + 32)

#endif // _UPNPDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\upthread.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U P T H R E A D . H 
//
//  Contents:   Threading support code
//
//  Notes:      
//
//  Author:     mbend   29 Sep 2000
//
//----------------------------------------------------------------------------

#pragma once

class CWorkItem
{
public:
    CWorkItem();
    virtual ~CWorkItem();

    HRESULT HrStart(BOOL bDeleteOnComplete);
protected:
    virtual DWORD DwRun() = 0;
    virtual ULONG GetFlags();
private:
    CWorkItem(const CWorkItem &);
    CWorkItem & operator=(const CWorkItem &);

    BOOL m_bDeleteOnComplete;

    static DWORD WINAPI DwThreadProc(void * pvParam);
};

class CThreadBase
{
public:
    CThreadBase();
    virtual ~CThreadBase();

    HRESULT HrStart(BOOL bDeleteOnComplete, BOOL bCreateSuspended);

    HRESULT HrGetExitCodeThread(DWORD * pdwExitCode);
    HRESULT HrResumeThread();
    HRESULT HrSuspendThread();
    HANDLE GetThreadHandle();
    DWORD GetThreadId();
    HRESULT HrWait(DWORD dwTimeoutInMillis, BOOL * pbTimedOut);
protected:
    virtual DWORD DwRun() = 0;
private:
    CThreadBase(const CThreadBase &);
    CThreadBase & operator=(const CThreadBase &);

    HANDLE m_hThread;
    DWORD m_dwThreadId;
    BOOL m_bDeleteOnComplete;

    static DWORD WINAPI DwThreadProc(void * pvParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\upnpdid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************



#define DISPID_XOBJ_MIN                 0x60020000
#define DISPID_XOBJ_MAX                 0x6002FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN
// why do we have space at the beginning?  why do the dispids all need to/should be different?
#define DISPID_UPNPFINDDEVICES          (DISPID_XOBJ_BASE               + 1000)
#define DISPID_UPNPFINDDEVICESCALLBACK  (DISPID_UPNPFINDDEVICES         + 500)
#define DISPID_UPNPSERVICES             (DISPID_UPNPFINDDEVICESCALLBACK + 500)
#define DISPID_UPNPSERVICE              (DISPID_UPNPSERVICES            + 500)
#define DISPID_UPNPDEVICES              (DISPID_UPNPSERVICE             + 1000)
#define DISPID_UPNPDEVICE               (DISPID_UPNPDEVICES             + 500)
#define DISPID_UPNPDESCRIPTIONDOC       (DISPID_UPNPDEVICE              + 500)

#define DISPID_UPNPFINDDEVICES_FINDBYTYPE        (DISPID_UPNPFINDDEVICES + 1)
#define DISPID_UPNPFINDDEVICES_FINDBYDCPI        (DISPID_UPNPFINDDEVICES + 2)
#define DISPID_UPNPFINDDEVICES_FINDBYUDN         (DISPID_UPNPFINDDEVICES + 3)
#define DISPID_UPNPFINDDEVICES_CREATEASYNCFIND   (DISPID_UPNPFINDDEVICES + 4) 
#define DISPID_UPNPFINDDEVICES_STARTASYNCFIND    (DISPID_UPNPFINDDEVICES + 5) 
#define DISPID_UPNPFINDDEVICES_CANCELASYNCFIND   (DISPID_UPNPFINDDEVICES + 6) 

#define DISPID_UPNPFINDDEVICESCALLBACK_NEWDEVICE        (DISPID_UPNPFINDDEVICESCALLBACK + 1)
#define DISPID_UPNPFINDDEVICESCALLBACK_SEARCHCOMPLETE   (DISPID_UPNPFINDDEVICESCALLBACK + 2) 

#define DISPID_UPNPSERVICES_COUNT                (DISPID_UPNPSERVICES + 1)

#define DISPID_UPNPSERVICE_QUERYSTATEVARIABLE    (DISPID_UPNPSERVICE  + 1)
#define DISPID_UPNPSERVICE_INVOKEACTION          (DISPID_UPNPSERVICE  + 2)
#define DISPID_UPNPSERVICE_SERVICETYPEIDENTIFIER (DISPID_UPNPSERVICE  + 3)
#define DISPID_UPNPSERVICE_ADDSTATECHANGECALLBACK   (DISPID_UPNPSERVICE  + 4)
#define DISPID_UPNPSERVICE_SERVICEID             (DISPID_UPNPSERVICE  + 5)
#define DISPID_UPNPSERVICE_LASTTRANSPORTSTATUS   (DISPID_UPNPSERVICE  + 6)

#define DISPID_UPNPDEVICES_COUNT                 (DISPID_UPNPDEVICES  + 1)

#define DISPID_UPNPDEVICE_ISROOTDEVICE           (DISPID_UPNPDEVICE   + 1)
#define DISPID_UPNPDEVICE_ROOT                   (DISPID_UPNPDEVICE   + 2)
#define DISPID_UPNPDEVICE_PARENT                 (DISPID_UPNPDEVICE   + 3)
#define DISPID_UPNPDEVICE_HASCHILDREN            (DISPID_UPNPDEVICE   + 4)
#define DISPID_UPNPDEVICE_CHILDREN               (DISPID_UPNPDEVICE   + 5)
#define DISPID_UPNPDEVICE_UDN                    (DISPID_UPNPDEVICE   + 6)
#define DISPID_UPNPDEVICE_FRIENDLYNAME           (DISPID_UPNPDEVICE   + 7)
#define DISPID_UPNPDEVICE_DEVICETYPE             (DISPID_UPNPDEVICE   + 8)
#define DISPID_UPNPDEVICE_PRESENTATIONURL        (DISPID_UPNPDEVICE   + 9)
#define DISPID_UPNPDEVICE_MANUFACTURERNAME       (DISPID_UPNPDEVICE   + 10)
#define DISPID_UPNPDEVICE_MANUFACTURERURL        (DISPID_UPNPDEVICE   + 11)
#define DISPID_UPNPDEVICE_MODELNAME              (DISPID_UPNPDEVICE   + 12)
#define DISPID_UPNPDEVICE_MODELNUMBER            (DISPID_UPNPDEVICE   + 13)
#define DISPID_UPNPDEVICE_DESCRIPTION            (DISPID_UPNPDEVICE   + 14)
#define DISPID_UPNPDEVICE_MODELURL               (DISPID_UPNPDEVICE   + 15)
#define DISPID_UPNPDEVICE_UPC                    (DISPID_UPNPDEVICE   + 16)
#define DISPID_UPNPDEVICE_SERIALNUMBER           (DISPID_UPNPDEVICE   + 17)
#define DISPID_UPNPDEVICE_LOADSMALLICON          (DISPID_UPNPDEVICE   + 18)
#define DISPID_UPNPDEVICE_LOADICON               (DISPID_UPNPDEVICE   + 19)
#define DISPID_UPNPDEVICE_SERVICES               (DISPID_UPNPDEVICE   + 20)

#define DISPID_UPNPDESCRIPTIONDOC_LOAD           (DISPID_UPNPDESCRIPTIONDOC + 1)
#define DISPID_UPNPDESCRIPTIONDOC_LOADASYNC      (DISPID_UPNPDESCRIPTIONDOC + 2)
#define DISPID_UPNPDESCRIPTIONDOC_LOADERROR      (DISPID_UPNPDESCRIPTIONDOC + 3)
#define DISPID_UPNPDESCRIPTIONDOC_ABORT          (DISPID_UPNPDESCRIPTIONDOC + 4)
#define DISPID_UPNPDESCRIPTIONDOC_ROOTDEVICE     (DISPID_UPNPDESCRIPTIONDOC + 5)
#define DISPID_UPNPDESCRIPTIONDOC_DEVICEBYUDN    (DISPID_UPNPDESCRIPTIONDOC + 6)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\upsync.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U P S Y N C . H 
//
//  Contents:   Synchronization classes
//
//  Notes:      
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "ncbase.h"

//+---------------------------------------------------------------------------
//
//  Class:      CUCriticalSection
//
//  Purpose:    Wrapper for Win32 critical sections
//
//  Author:     mbend   17 Aug 2000
//
//  Notes:      
//    The most important and lightweight Windows NT synchronization primitive.
//    Allows only one thread to enter itself at a single time.
//    An important property of critical sections is that they are 
//    thread reentrant which means that if a thread owns a critical
//    section and tries to enter it again, the thread is allowed to 
//    do so. When exiting the lock, the lock is not freed until it is
//    exited once for each time that it was entered.
//
//    Critical sections are lightweight because they are not kernel
//    objects. Instead they are implemented through a simple in
//    memory structure CRITICAL_SECTION. If there is no thread
//    contention, they are implemented by simple memory operations
//    and spin locks that are hundreds of times faster than
//    alternative kernel object solutions such as mutexes. However,
//    if there is thread contention, critical sections degraded into
//    kernel objects.
//
class CUCriticalSection
{
public:
    CUCriticalSection() 
    {
        InitializeCriticalSection(&m_critsec);
    }
    ~CUCriticalSection() 
    {
        DeleteCriticalSection(&m_critsec);
    }
    void Enter()
    {
        EnterCriticalSection(&m_critsec);
    }
    BOOL FTryEnter()
    {
        return TryEnterCriticalSection(&m_critsec);
    }
    void Leave()
    {
        LeaveCriticalSection(&m_critsec);
    }
    DWORD DwSetSpinCount(DWORD dwSpinCount)
    {
        return SetCriticalSectionSpinCount(&m_critsec, dwSpinCount);
    }
private:
    CUCriticalSection(const CUCriticalSection &);
    CUCriticalSection & operator=(const CUCriticalSection &);
    CRITICAL_SECTION m_critsec;
};

//+---------------------------------------------------------------------------
//
//  Class:      CLock
//
//  Purpose:    Used to place an auto lock on a critical section
//
//  Author:     mbend   17 Aug 2000
//
//  Notes:      
//    Typically this class is used in an class object methods like so:
//
//     class SynchronizedExample {
//     public:
//        void LockedMethod() {
//            CLock lock(m_critSec);
//            ...
//        }
//     private:
//        CUCriticalSection m_critSec;
//     };
class CLock {
public:
    // Not attached
    CLock(CUCriticalSection & critsec) : m_critsec(critsec) 
    {   
        m_critsec.Enter();
    }
    ~CLock() 
    {
        m_critsec.Leave();
    }
private:
    CLock(const CLock &);
    CLock & operator=(const CLock &);
    CUCriticalSection & m_critsec;
};

#ifdef __ATLCOM_H__

//+---------------------------------------------------------------------------
//
//  Class:      CALock
//
//  Purpose:    Used to place an auto lock on a CComObjectRootEx<CComMultiThreadModel> derived class
//
//  Author:     mbend   17 Aug 2000
//
//  Notes:      
//    Typically this class is used in an class object methods like so:
//
//     class SynchronizedExample : public CComObjectRootEx<CComMultiThreadModel> {
//     public:
//        void LockedMethod() {
//            CALock lock(*this);
//            ...
//        }
//     };
class CALock {
public:
    // Not attached
    CALock(CComObjectRootEx<CComMultiThreadModel> & object) : m_object(object) 
    {   
        m_object.Lock();
    }
    ~CALock() 
    {
        m_object.Unlock();
    }
private:
    CALock(const CLock &);
    CALock & operator=(const CLock &);
    CComObjectRootEx<CComMultiThreadModel> & m_object;
};

#endif // __ATLCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\proto\ssdp\network\networkmanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       N E T W O R K M A N A G E R . H 
//
//  Contents:   Fetches list of available networks
//
//  Notes:      
//
//  Author:     mbend   24 Oct 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "upsync.h"
#include "Array.h"
#include "Socket.h"

class CNetworkManager
{
public:
    CNetworkManager();
    ~CNetworkManager();
private:
    CNetworkManager(const CNetworkManager &);
    CNetworkManager & operator=(const CNetworkManager &);

    CUCriticalSection m_critSec;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\proto\ssdp\network\networkmanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       N E T W O R K M A N A G E R . C P P 
//
//  Contents:   Fetches list of available networks
//
//  Notes:      
//
//  Author:     mbend   24 Oct 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "NetworkManager.h"


CNetworkManager::CNetworkManager()
{
}

CNetworkManager::~CNetworkManager()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\validate.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       V A L I D A T E . H 
//
//  Contents:   Header file for the UPnP XML document validation routines.
//
//  Notes:      
//
//  Author:     spather   2000/10/17
//
//----------------------------------------------------------------------------

#ifndef __VALIDATE_H
#define __VALIDATE_H

#pragma once

extern
HRESULT 
HrValidateServiceDescription(
    IXMLDOMElement * pxdeRoot,
    LPWSTR         * pszError);

#endif // __VALIDATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpnetwork\network.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

File Name:

    network.cpp

Abstract:

    This file contains code implements the per-network state matrix.

Author: Ting Cai

Created: 07/20/1999

--*/

#include <pch.h>
#pragma hdrstop

#include "ssdpfunc.h"
#include "ssdptypes.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#include "ssdpnetwork.h"
#include "InterfaceList.h"
#include "iphlpapi.h"

#define INET_NTOA(a)    inet_ntoa(*(struct in_addr*)&(a))

static LONG bStop;

// a list of distinct networks hosted on this machine
static LIST_ENTRY listNetwork;
static CRITICAL_SECTION CSListNetwork;

extern SOCKET g_socketTcp;

// ip helper function pointer
// typedef DWORD (GETIFTABLE_FUNC_TYPE)(PMIB_IFTABLE, PULONG, BOOL);
// typedef DWORD (GETIPADDRTABLE_FUNC_TYPE)(PMIB_IPADDRTABLE, PULONG,BOOL);

// GETIFTABLE_FUNC_TYPE *SsdpGetIfTable;
// GETIPADDRTABLE_FUNC_TYPE *SsdpGetIpAddrTable;


// prototypes
PSSDPNetwork AddToListNetwork(PSOCKADDR_IN IpAddress);
VOID FreeSSDPNetwork(SSDPNetwork *pSSDPNetwork);
VOID RemoveFromListNetwork(SSDPNetwork *pssdpNetwork);


// functions

VOID GetNetworkLock()
{
    EnterCriticalSection(&CSListNetwork);
}

VOID FreeNetworkLock()
{
    LeaveCriticalSection(&CSListNetwork);
}

VOID ResetNetworkList(HWND hwnd)
{
    INT     nResult;

    TraceTag(ttidSsdpNetwork, "Restting network list...");

    EnterCriticalSection(&CSListNetwork);

    CleanupListNetwork(TRUE);

    nResult = GetNetworks();

    TraceTag(ttidSsdpNetwork, "GetNetworks() returned 0x%08X", nResult);

    ListenOnAllNetworks(hwnd);

    LeaveCriticalSection(&CSListNetwork);
}

DWORD DwGetIpAddress(PIP_ADAPTER_INFO pip)
{
    DWORD dwRet = 0;
    PIP_ADDR_STRING paddrIter = &pip->IpAddressList;
    while(paddrIter)
    {
        DWORD dwAddr = inet_addr(paddrIter->IpAddress.String);
        if(dwAddr)
        {
            dwRet = dwAddr;
            break;
        }
        paddrIter = paddrIter->Next;
    }
    return dwRet;
}

INT GetNetworks()
{
    HRESULT hr = S_OK;

    sockaddr_in saddr;
    ZeroMemory(&saddr, sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(SSDP_PORT);
    PIP_ADAPTER_INFO pip = NULL;
    ULONG ulSize = 0;
    GetAdaptersInfo(NULL, &ulSize);
    if(ulSize)
    {
        pip = reinterpret_cast<PIP_ADAPTER_INFO>(malloc(ulSize));

        DWORD dwRet = GetAdaptersInfo(pip, &ulSize);
        hr = HRESULT_FROM_WIN32(dwRet);
        if(SUCCEEDED(hr))
        {
            PIP_ADAPTER_INFO pipIter = pip;
            while(pipIter && SUCCEEDED(hr))
            {
                SSDPNetwork * pSsdpNetwork = NULL;
                // Get the first IP address for the adapter
                DWORD dwAddr = DwGetIpAddress(pipIter);
                if(dwAddr)
                {
                    saddr.sin_addr.s_addr = dwAddr;
                    pSsdpNetwork = AddToListNetwork(&saddr);

                    if (pSsdpNetwork != NULL)
                    {
                        if (SocketOpen(&pSsdpNetwork->socket,
                                       &saddr,
                                       htonl(pipIter->Index),
                                       TRUE) == FALSE)
                        {
                            RemoveFromListNetwork(pSsdpNetwork);
                            FreeSSDPNetwork(pSsdpNetwork);
                        }
                        else
                        {
                            pSsdpNetwork->dwIndex = htonl(pipIter->Index);
                            TraceTag(ttidSsdpNetwork, "GetNetworks: Added "
                                     "0x%x to network list",
                                     pSsdpNetwork->socket);
                        }
                    }
                }
                pipIter = pipIter->Next;
            }
        }

        free(pip);
    }

    // Explicitly bind to loopback address

    SOCKADDR_IN sockaddrLoopback;
    PSSDPNetwork pSsdpNetworkLoopback;

    sockaddrLoopback.sin_family = AF_INET;
    sockaddrLoopback.sin_addr.s_addr = inet_addr("127.0.0.1");
    sockaddrLoopback.sin_port = htons(SSDP_PORT);

    pSsdpNetworkLoopback = AddToListNetwork((PSOCKADDR_IN) &sockaddrLoopback);

    if (pSsdpNetworkLoopback != NULL)
    {
        if (SocketOpen(&pSsdpNetworkLoopback->socket,
                       (PSOCKADDR_IN) &sockaddrLoopback,
                       sockaddrLoopback.sin_addr.s_addr,
                       TRUE) == FALSE)
        {
            RemoveFromListNetwork(pSsdpNetworkLoopback);
            FreeSSDPNetwork(pSsdpNetworkLoopback);
        }
        else
        {            
            TraceTag(ttidSsdpNetwork, "GetNetworks: Added "
                     "0x%x (loopback) to network list",
                     pSsdpNetworkLoopback->socket);
        }
    }

    return 0;
}

VOID InitializeListNetwork()
{
    InitializeCriticalSection(&CSListNetwork);
    EnterCriticalSection(&CSListNetwork);
    InitializeListHead(&listNetwork);
    LeaveCriticalSection(&CSListNetwork);
}


PSSDPNetwork AddToListNetwork(PSOCKADDR_IN IpAddress)
{
    SSDPNetwork *pssdpNetwork;

    // Create SSDPNetwork from SSDPMessage

    pssdpNetwork = (SSDPNetwork *) malloc (sizeof(SSDPNetwork));

    if (pssdpNetwork == NULL)
    {
        return NULL;
    }

    pssdpNetwork->IpAddress = *IpAddress;
    pssdpNetwork->Type = SSDP_NETWORK_SIGNATURE;
    pssdpNetwork->cRef = 1;

    // To-Do: Query Per Network State Matrix state
    pssdpNetwork->state = NETWORK_INIT;

    EnterCriticalSection(&CSListNetwork);
    InsertHeadList(&listNetwork, &(pssdpNetwork->linkage));
    LeaveCriticalSection(&CSListNetwork);

    return pssdpNetwork;
}

VOID FreeSSDPNetwork(SSDPNetwork *pSSDPNetwork)
{
    free(pSSDPNetwork);
}

// Merge with RemoveFromListAnnounce?

VOID RemoveFromListNetwork(SSDPNetwork *pssdpNetwork)
{
    EnterCriticalSection(&CSListNetwork);
    RemoveEntryList(&(pssdpNetwork->linkage));
    LeaveCriticalSection(&CSListNetwork);
}

VOID CleanupListNetwork(BOOL fReset)
{
    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &listNetwork;

    TraceTag(ttidSsdpNetwork, "----- Cleanup SSDP Network List -----");

    EnterCriticalSection(&CSListNetwork);
    for (p = pListHead->Flink; p != pListHead;)
    {
        SSDPNetwork *pssdpNetwork;

        pssdpNetwork = CONTAINING_RECORD (p, SSDPNetwork, linkage);

        p = p->Flink;

        pssdpNetwork->cRef--;

        TraceTag(ttidSsdpNetwork, "CleanupListNetwork: Network ref count "
                 "on 0x%x was %d, now %d", pssdpNetwork->socket,
                 pssdpNetwork->cRef + 1, pssdpNetwork->cRef);

        if (!pssdpNetwork->cRef)
        {
            TraceTag(ttidSsdpNetwork, "CleanupListNetwork: Refcount on 0x%x is 0. "
                     "Removing and closing socket...", pssdpNetwork->socket);

            RemoveEntryList(&(pssdpNetwork->linkage));
            SocketClose(pssdpNetwork->socket);
            FreeSSDPNetwork(pssdpNetwork);
        }
        else
        {
            // Mark state as cleaning up so we don't try to use this somewhere
            // else again.
            //
            pssdpNetwork->state = NETWORK_CLEANUP;
        }
    }

    LeaveCriticalSection(&CSListNetwork);

    if (!fReset)
    {
        DeleteCriticalSection(&CSListNetwork);
    }
}

BOOL FReferenceSocket(SOCKET s)
{
    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &listNetwork;
    BOOL        fRet = FALSE;

    EnterCriticalSection(&CSListNetwork);

    // First check if the socket is in the list. If not, return FALSE
    //
    for (p = pListHead->Flink; p != pListHead;p = p->Flink)
    {
        SSDPNetwork *pssdpNetwork;

        pssdpNetwork = CONTAINING_RECORD (p, SSDPNetwork, linkage);

        if(s == pssdpNetwork->socket && pssdpNetwork->state != NETWORK_CLEANUP)
        {
            // Bump the ref count on the socket
            pssdpNetwork->cRef++;
            fRet = TRUE;

            TraceTag(ttidSsdpNetwork, "FReferenceSocket: Network ref count "
                     "on 0x%x was %d, now %d", s, pssdpNetwork->cRef - 1,
                     pssdpNetwork->cRef);
        }
    }

    LeaveCriticalSection(&CSListNetwork);

#if DBG
    if (!fRet)
    {
        TraceTag(ttidSsdpNetwork, "FReferenceSocket: Socket 0x%x not found "
                 "in list", s);
    }
#endif

    return fRet;
}

VOID UnreferenceSocket(SOCKET s)
{
    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &listNetwork;
    BOOL        fFound = FALSE;

    EnterCriticalSection(&CSListNetwork);

    // Assert that the socket is in the list. Its refcount MUST be > 0 and it
    // must be in the list
    //
    for (p = pListHead->Flink; p != pListHead;)
    {
        SSDPNetwork *pssdpNetwork;

        pssdpNetwork = CONTAINING_RECORD (p, SSDPNetwork, linkage);

        p = p->Flink;

        if(s == pssdpNetwork->socket)
        {
            fFound = TRUE;

            TraceTag(ttidSsdpNetwork, "UnreferenceSocket: Checking socket 0x%x", s);

            AssertSz(pssdpNetwork->cRef > 0, "Socket's ref count is <= 0!");

            // Lower the ref count on the socket. If it is at 0, remove the
            // item from the list and close the socket.
            //
            pssdpNetwork->cRef--;

            TraceTag(ttidSsdpNetwork, "UnreferenceSocket: Network ref count "
                     "on 0x%x was %d, now %d", pssdpNetwork->socket,
                     pssdpNetwork->cRef + 1, pssdpNetwork->cRef);

            if (!pssdpNetwork->cRef)
            {
                TraceTag(ttidSsdpNetwork, "UnreferenceSocket: Refcount on 0x%x is 0. "
                         "Removing and closing socket...", pssdpNetwork->socket);

                RemoveEntryList(&(pssdpNetwork->linkage));
                SocketClose(pssdpNetwork->socket);
                FreeSSDPNetwork(pssdpNetwork);
            }
        }
    }

    LeaveCriticalSection(&CSListNetwork);

    AssertSz(fFound, "Socket MUST have been in the list!");
}

BOOL FIsSocketValid(SOCKET s)
{
    BOOL bRet = FALSE;

    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &listNetwork;

    EnterCriticalSection(&CSListNetwork);

    for (p = pListHead->Flink; p != pListHead;p = p->Flink)
    {
        SSDPNetwork *pssdpNetwork;

        pssdpNetwork = CONTAINING_RECORD (p, SSDPNetwork, linkage);

        if(s == pssdpNetwork->socket && pssdpNetwork->state != NETWORK_CLEANUP)
        {
            // Loopback socket is valid to send our response  
            if( pssdpNetwork->IpAddress.sin_addr.s_addr == inet_addr("127.0.0.1") )
            {
                bRet = TRUE;
                break;
            }
            else 
            {
                bRet = CUPnPInterfaceList::Instance().FShouldSendOnIndex(pssdpNetwork->dwIndex);
                if(bRet)
                    break;
            }
        }
    }

    LeaveCriticalSection(&CSListNetwork);

    return bRet;
}

VOID SendOnAllNetworks(CHAR *szBytes, SOCKADDR_IN *RemoteAddress)
{
    PLIST_ENTRY     p;
    PLIST_ENTRY     pListHead = &listNetwork;

    EnterCriticalSection(&CSListNetwork);

    for (p = pListHead->Flink; p != pListHead;p = p->Flink)
    {
        SSDPNetwork *   pssdpNetwork;
        ULONG           nAddr;
        CHAR *          szBytesNew;

        pssdpNetwork = CONTAINING_RECORD (p, SSDPNetwork, linkage);

        if (pssdpNetwork->state != NETWORK_CLEANUP)
        {
            nAddr = pssdpNetwork->IpAddress.sin_addr.s_addr;

            Assert(nAddr);

            if (CUPnPInterfaceList::Instance().FShouldSendOnIndex(pssdpNetwork->dwIndex) || 
                nAddr == inet_addr("127.0.0.1") )
            {
                if (FReplaceTokenInLocation(szBytes, INET_NTOA(nAddr),
                                            &szBytesNew))
                {
                    if (szBytesNew)
                    {
                        SocketSend(szBytesNew, pssdpNetwork->socket, RemoteAddress);
                        free(szBytesNew);
                    }
                    else
                    {
                        SocketSend(szBytes, pssdpNetwork->socket, RemoteAddress);
                    }
                }
            }
        }
    }

    LeaveCriticalSection(&CSListNetwork);
}

VOID SocketSendWithReplacement(CHAR *szBytes, SOCKET * pSockLocal,
                               SOCKADDR_IN *pSockRemote)
{
    ULONG       nAddr;
    CHAR *      szBytesNew;
    SOCKADDR_IN sockAddrIn;
    int         nAddrInSize = sizeof(sockAddrIn);

    if (SOCKET_ERROR != getsockname(*pSockLocal,
                                    reinterpret_cast<sockaddr*>(&sockAddrIn),
                                    &nAddrInSize))
    {
        nAddr = sockAddrIn.sin_addr.s_addr;

        Assert(nAddr);

        if (CUPnPInterfaceList::Instance().FShouldSendOnInterface(nAddr))
        {
            if (FReplaceTokenInLocation(szBytes, INET_NTOA(nAddr),
                                        &szBytesNew))
            {
                if (szBytesNew)
                {
                    SocketSend(szBytesNew, *pSockLocal, pSockRemote);
                    free(szBytesNew);
                }
                else
                {
                    SocketSend(szBytes, *pSockLocal, pSockRemote);
                }
            }
        }
    }
    else
    {
        TraceError("SocketSendWithReplacement",
                   HRESULT_FROM_WIN32(WSAGetLastError()));
    }
}

INT ListenOnAllNetworks(HWND hWnd)
{
    PLIST_ENTRY p;
    INT ReturnValue;
    BOOL bSucceeded = FALSE;
    PLIST_ENTRY pListHead = &listNetwork;

    EnterCriticalSection(&CSListNetwork);

    for (p = pListHead->Flink; p != pListHead;p = p->Flink)
    {
        SSDPNetwork *pssdpNetwork;

        pssdpNetwork = CONTAINING_RECORD (p, SSDPNetwork, linkage);

        if (pssdpNetwork->state != NETWORK_CLEANUP)
        {
            ReturnValue = WSAAsyncSelect(pssdpNetwork->socket, hWnd,
                                         SM_SSDP, FD_READ);

            if (ReturnValue == SOCKET_ERROR)
            {
                TraceTag(ttidSsdpNetwork, "----- select failed with error code "
                         "%d -----", GetLastError());
            }
            else
            {
                bSucceeded = TRUE;
            }
        }
    }

    LeaveCriticalSection(&CSListNetwork);

    if (bSucceeded)
    {
        return 0;
    }
    else
    {
        TraceTag(ttidSsdpNetwork, "----- No socket to listen or "
                 "WSAAsyncSelect failed.");
        return GetLastError();
    }
}

HRESULT GetIpAddress(CHAR * szName, SOCKADDR_IN *psinLocal)
{
    LPHOSTENT   lpHostEnt;
    SOCKET socketName;

    socketName = socket(AF_INET, SOCK_STREAM, 0);

    if (socketName == INVALID_SOCKET)
    {
        TraceTag(ttidSsdpNetwork, "Failed to create socket. Error %d.", GetLastError());
        return HrFromLastWin32Error();
    }

    lpHostEnt = gethostbyname(szName);
    if (lpHostEnt == NULL)
    {
        TraceTag(ttidSsdpNetwork, "gethostbyname returned error %d.", GetLastError());
        closesocket(socketName);
        return HrFromLastWin32Error();
    } else
    {
        SOCKADDR_IN sinRemote;
        DWORD dwBytes;
        INT status;

        ZeroMemory(&sinRemote, sizeof(SOCKADDR_IN));
        sinRemote.sin_family = AF_INET;
        CopyMemory (&sinRemote.sin_addr, lpHostEnt->h_addr_list[0], lpHostEnt->h_length);

#ifdef DBG
        {
            ULONG IpAddress = sinRemote.sin_addr.s_addr;
            TraceTag(ttidSsdpNetwork, "IP Address of remote host [%s] is [%s]", szName, INET_NTOA(IpAddress));
        }
#endif // DBG

        status = WSAIoctl ( socketName,
                            SIO_ROUTING_INTERFACE_QUERY,
                            (PSOCKADDR)&sinRemote,
                            sizeof(SOCKADDR),
                            (PSOCKADDR)psinLocal,
                            sizeof(SOCKADDR),
                            &dwBytes,
                            NULL,
                            NULL);

        if (status != SOCKET_ERROR) {
            Assert(dwBytes == sizeof(SOCKADDR));
#ifdef DBG
            {
                ULONG IpAddress = psinLocal->sin_addr.s_addr;
                TraceTag(ttidSsdpNetwork, "Local IP [%s] to remote host [%s]", INET_NTOA(IpAddress), szName);
            }
#endif // DBG

            closesocket(socketName);

            return S_OK;

        } else {
            TraceTag(ttidSsdpNetwork, "Failed to get local ip error %d", GetLastError());
            closesocket(socketName);
            return HrFromLastWin32Error();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpparser\parser.cpp ===
/*++

Copyright (c) 1999 - 2000  Microsoft Corporation

Module Name:

    parser.c

Abstract:

    This module encode and decode ssdp notify and search messages.

Author:

    Ting Cai (tingcai) creation-date-07-25-99

--*/

/* Note:

  Use midl memory routines for SSDP_REQUEST

*/


#include <pch.h>
#pragma hdrstop

#include "ssdpparserp.h"
#include "ssdpapi.h"
#include "limits.h"
#include "ncstring.h"

#define HTTP_VERSION "HTTP/1.1"

#define END_HEADERS_SIZE 3
const char * szEndOfHeaders = "\n\r\n";

#define HEADER_END_SIZE 4
const char * szHeaderEnd = "\r\n\r\n";

BOOL IsStrDigits(LPSTR pszStr);
VOID strtrim(CHAR ** pszStr);

static const CHAR c_szMaxAge[] = "max-age";
static const DWORD c_cchMaxAge = celems(c_szMaxAge) - 1;

// Keep in sync with SSDP_METHOD in ssdp.idl
CHAR *SsdpMethodStr[] =
{
    "NOTIFY",
    "M-SEARCH",
    "SUBSCRIBE",
    "UNSUBSCRIBE",
    "INVALID",
};


// Keep in sync with SSDP_HEADER in ssdp.idl
CHAR *SsdpHeaderStr[] =
{
    "Host",
    "NT",
    "NTS",
    "ST",
    "Man",
    "MX",
    "Location",
    "AL",
    "USN",
    "Cache-Control",
    "Callback",
    "Timeout",
    "Scope",
    "SID",
    "SEQ",
    "Content-Length",
    "Content-Type",
    "Server",
    "Ext",
};
/*

  NOTIFY * HTTP/1.1
  Host: reservedSSDPmulticastaddress
  NT: blenderassociation:blender
  NTS: ssdp:alive
  USN: someunique:idscheme3
  AL: <blender:ixl><http://foo/bar>
  Cache-Control: max-age = 7393

  To-do: HTTP headers are all ascii, the API may accept unicode, but convert to ascii before
  calling the rpc interface. The server keeps ascii version only.

  To-do: Support arbitrary content.

  */

// Compose an SSDP alive message from the a SSDP Message structure, caller should
// free the memory when done.

BOOL ComposeSsdpResponse(const SSDP_REQUEST *Source, CHAR **pszBytes)
{
    CHAR ResponseHeader[40] = "HTTP/1.1 200 OK";
    INT iLength = 0;
    INT iNumOfBytes = 0;
    CHAR * szBytes;
    INT i;

    iLength = strlen(ResponseHeader) + strlen(CRLF);

    if (Source->Headers[SSDP_NT] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[SSDP_ST]) +
            strlen(COLON) +
            strlen(Source->Headers[SSDP_NT]) +
            strlen(CRLF);
    }

    if (Source->Headers[SSDP_LOCATION] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[SSDP_LOCATION]) +
            strlen(COLON) +
            strlen(Source->Headers[SSDP_LOCATION]) +
            strlen(CRLF);
    }

    if (Source->Headers[SSDP_AL] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[SSDP_AL]) +
            strlen(COLON) +
            strlen(Source->Headers[SSDP_AL]) +
            strlen(CRLF);
    }
    if (Source->Headers[SSDP_USN] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[SSDP_USN]) +
            strlen(COLON) +
            strlen(Source->Headers[SSDP_USN]) +
            strlen(CRLF);
    }

    if (Source->Headers[SSDP_CACHECONTROL] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[SSDP_CACHECONTROL]) +
            strlen(COLON) +
            strlen(Source->Headers[SSDP_CACHECONTROL]) +
            strlen(CRLF);
    }

    if (Source->Headers[GENA_SID] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[GENA_SID]) +
            strlen(COLON) +
            strlen(Source->Headers[GENA_SID]) +
            strlen(CRLF);
    }

    if (Source->Headers[GENA_TIMEOUT] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[GENA_TIMEOUT]) +
            strlen(COLON) +
            strlen(Source->Headers[GENA_TIMEOUT]) +
            strlen(CRLF);
    }

    if (Source->Headers[SSDP_SERVER] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[SSDP_SERVER]) +
            strlen(COLON) +
            strlen(Source->Headers[SSDP_SERVER]) +
            strlen(CRLF);
    }

    if (Source->Headers[SSDP_EXT] != NULL)
    {
        iLength += strlen(SsdpHeaderStr[SSDP_EXT]) +
            strlen(COLON) +
            strlen(Source->Headers[SSDP_EXT]) +
            strlen(CRLF);
    }

    iLength += strlen(CRLF);

    szBytes = (CHAR *) midl_user_allocate(sizeof(CHAR) * iLength + 1);

    if (szBytes == NULL)
    {
        TraceTag(ttidSsdpParser, "Faled to allocate memory for the ssdp message.");
        return FALSE;
    }

    iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s", ResponseHeader, CRLF);

    if (Source->Headers[SSDP_NT] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[SSDP_ST], COLON,
                               Source->Headers[SSDP_NT],CRLF);
    }


    if (Source->Headers[SSDP_USN] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[SSDP_USN], COLON,
                               Source->Headers[SSDP_USN],CRLF);
    }


    if (Source->Headers[SSDP_LOCATION] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[SSDP_LOCATION], COLON,
                               Source->Headers[SSDP_LOCATION],CRLF);
    }


    if (Source->Headers[SSDP_AL] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[SSDP_AL], COLON,
                               Source->Headers[SSDP_AL],CRLF);
    }

    if (Source->Headers[SSDP_CACHECONTROL] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[SSDP_CACHECONTROL], COLON,
                               Source->Headers[SSDP_CACHECONTROL],CRLF);
    }

    if (Source->Headers[GENA_SID] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[GENA_SID], COLON,
                               Source->Headers[GENA_SID],CRLF);
    }

    if (Source->Headers[GENA_TIMEOUT] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[GENA_TIMEOUT], COLON,
                               Source->Headers[GENA_TIMEOUT],CRLF);
    }

    if (Source->Headers[SSDP_SERVER] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[SSDP_SERVER], COLON,
                               Source->Headers[SSDP_SERVER],CRLF);
    }

    if (Source->Headers[SSDP_EXT] != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                               SsdpHeaderStr[SSDP_EXT], COLON,
                               Source->Headers[SSDP_EXT],CRLF);
    }

    iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s",CRLF);

    *pszBytes = szBytes;

    return TRUE;
}

// To-do: optimize, cache does not care about the request/response line
BOOL ComposeSsdpRequest(const SSDP_REQUEST *Source, CHAR **pszBytes)
{
    INT iLength = 0;
    INT iNumOfBytes = 0;
    CHAR iLifeTime[10];
    CHAR * szBytes;
    INT i;

    if (Source->Method != SSDP_INVALID && Source->RequestUri != NULL)
    {
        iLength += strlen(SsdpMethodStr[Source->Method]) + strlen(SP) +
            strlen(Source->RequestUri) + strlen(SP) +
            strlen(HTTP_VERSION) + strlen(CRLF);
    }

    for (i = 0; i < NUM_OF_HEADERS; i++)
    {
        if (Source->Headers[i] != NULL)
        {
                iLength += strlen(SsdpHeaderStr[i]) + strlen(COLON) +
                    strlen(Source->Headers[i]) + strlen(CRLF);
            }
        }

    iLength += strlen(CRLF);

    szBytes = (CHAR *) malloc(sizeof(CHAR) * iLength + 1);

    if (szBytes == NULL)
    {
        TraceTag(ttidSsdpParser, "Faled to allocate memory for the ssdp message.");
        return FALSE;
    }

    if (Source->Method != SSDP_INVALID && Source->RequestUri != NULL)
    {
        iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s%s%s",
                               SsdpMethodStr[Source->Method], SP,
                               Source->RequestUri, SP, HTTP_VERSION, CRLF);
    }

    for (i = 0; i < NUM_OF_HEADERS; i++)
    {
        if (Source->Headers[i] != NULL)
        {
                iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s%s%s%s",
                                       SsdpHeaderStr[i], COLON,
                                       Source->Headers[i],CRLF);
            }
        }

    iNumOfBytes += wsprintf(szBytes + iNumOfBytes, "%s",CRLF);

    *pszBytes = szBytes;

    return TRUE;
}

BOOL FReplaceTokenInLocation(LPCSTR szIn, LPSTR szReplace, LPSTR *pszOut)
{
    CHAR *  pch;

    Assert(pszOut);

    *pszOut = NULL;

    if (pch = strstr(szIn, c_szReplaceGuid))
    {
        LPSTR   szOut;
        DWORD   cbOut;

        cbOut = (lstrlen(szIn) - c_cchReplaceGuid + lstrlen(szReplace) + 1) *
            sizeof(CHAR);

        szOut = (LPSTR)malloc(cbOut);
        if (szOut)
        {
            lstrcpyn(szOut, szIn, (int)(pch - szIn + 1));
            lstrcat(szOut, szReplace);

            pch += c_cchReplaceGuid;

            lstrcat(szOut, pch);

            *pszOut = szOut;
        }
        else
        {
            return FALSE;
        }

    }

    return TRUE;
}

// Pre-Conditions:
// Result->Headers[CONTENT_LENGTH] contains only digits.
// pContent points to the first char "\r\n\r\n".
// Return szValue:
// returns FALSE if there not enough content.

BOOL ParseContent(const char *pContent, DWORD cbContent, SSDP_REQUEST *Result)
{
    if(!Result->Headers[CONTENT_LENGTH])
    {
        return TRUE;
    }

    DWORD dwContentLength = strtoul(Result->Headers[CONTENT_LENGTH], NULL, 10);
    if (dwContentLength == 0)
    {
        // If it can't be conver to a number or it is 0.
        TraceTag(ttidSsdpParser, "Content-Length is 0.");
        return TRUE;
    }
    else if ((cbContent == (DWORD)(-1)) || (cbContent == dwContentLength))
    {
        Result->Content = (CHAR*) midl_user_allocate(dwContentLength + 1);
        if (Result->Content == NULL)
        {
            TraceTag(ttidSsdpParser, "Failed to allocate memory for Content");
            return FALSE;
        }
        else
        {
            lstrcpyn(Result->Content,pContent, dwContentLength + 1);

            return TRUE;
        }
    }

    return FALSE;
}

CHAR * ParseRequestLine(CHAR * szMessage, SSDP_REQUEST *Result)
{
    CHAR *token;
    INT i;

    Assert(NULL != szMessage);
    
    // Make sure we don't go past the end of the buffer
    CHAR * pchEnd = szMessage + lstrlen(szMessage);

    //  Get the HTTP method
    token = strtok(szMessage," \t\n");
    if (token == NULL)
    {
        TraceTag(ttidSsdpParser, "Parser could not locate the seperator, "
                 "space, tab or eol");
        return NULL;
    }

    for (i = 0; i < NUM_OF_METHODS; i++)
    {
        if (_stricmp(SsdpMethodStr[i],token) == 0)
        {
            Result->Method = (SSDP_METHOD)i;
            break;
        }
    }

    if (i == NUM_OF_METHODS)
    {
        TraceTag(ttidSsdpParser, "Parser could not find method . "
                 "Received %s", token);
        return NULL;
    }

    // Get the Request-URI
    token = strtok(NULL," ");
    if (token == NULL)
    {
        TraceTag(ttidSsdpParser, "Parser could not find the url in the "
                 "message.");
        return NULL;
    }

    // Ingore the name space parsing for now, get the string after the last '/'.

    Result->RequestUri = (CHAR*) midl_user_allocate(strlen(token) + 1);

    if (Result->RequestUri == NULL)
    {
        TraceTag(ttidSsdpParser, "Parser could not allocate memory for url.");
        return NULL;
    }

    // Record the service.
    strcpy(Result->RequestUri, token);

    // Get the version number
    token = strtok(NULL,"  \t\r");

    // To-Do: Record the version number when necessary.

    if (token == NULL)
    {
        TraceTag(ttidSsdpParser, "Failed to get the version in the request "
                 "header.");
        FreeSsdpRequest(Result);
        return NULL;
    }

    if (_stricmp(token, "HTTP/1.1") != 0)
    {
        TraceTag(ttidSsdpParser, "The version specified in the request "
                 "message is not HTTP/1.1");
        FreeSsdpRequest(Result);
        return NULL;
    }

    // point to the rest of the header data, after the current token
    token += lstrlen(token) + 1;
    if (token >= pchEnd)
    {
        TraceTag(ttidSsdpParser, "no data following HTTP/1.1 in the request");
        FreeSsdpRequest(Result);
        return NULL;
    }
    return token;
}

BOOL VerifySsdpHeaders(SSDP_REQUEST *Result)
{
    if (Result->Method == SSDP_M_SEARCH)
    {
        if (Result->Headers[SSDP_ST] == NULL ||
            Result->Headers[SSDP_MX] == NULL ||
            *Result->Headers[SSDP_MX] == L'\0' ||
            *Result->Headers[SSDP_ST] == L'\0')
        {
            TraceTag(ttidSsdpParser, "ST and MX header should not be NULL for M-SEARCH");
            return FALSE;
        }

        if (Result->Headers[SSDP_MAN] == NULL || lstrcmpi(Result->Headers[SSDP_MAN], "\"ssdp:discover\""))
        {
            TraceTag(ttidSsdpParser, "MAN header for M-SEARCH must be \"ssdp:discover\"");
            return FALSE;
        }

        if (Result->Headers[SSDP_HOST] == NULL || lstrcmpi(Result->Headers[SSDP_HOST], SSDP_ADDR_PORT))
        {
            TraceTag(ttidSsdpParser, "HOST must be 239.255.255.250:1900"
                     "for n M-SEARCH message.");
            return FALSE;
        }
    }

    if (Result->Headers[SSDP_MX] != NULL &&
        IsStrDigits(Result->Headers[SSDP_MX]) == FALSE)
    {
        TraceTag(ttidSsdpParser, "MX header should be all digits");
        return FALSE;
    }


    if (Result->Method == SSDP_NOTIFY)
    {
        if (Result->Headers[SSDP_NT] == NULL ||
            Result->Headers[SSDP_NTS] == NULL)
        {
            TraceTag(ttidSsdpParser, "NT and NTS headers should not be NULL for a NOTIFY message.");
            return FALSE;
        }

        // Assume NOTIFY other than upnp:propchange requires USN header.
        // Currently, ssdp:alive and ssdp:byebye

        if (lstrcmpi(Result->Headers[SSDP_NTS], "upnp:propchange"))
        {
            if (Result->Headers[SSDP_USN] == NULL)
            {
                TraceTag(ttidSsdpParser, "USN headers should not be NULL for "
                         "a NOTIFY message.");
                return FALSE;
            }

            if (!lstrcmpi(Result->Headers[SSDP_NTS], "ssdp:alive"))
            {
                // ssdp:alive messages must have a location header
                if (Result->Headers[SSDP_LOCATION] == NULL)
                {
                    TraceTag(ttidSsdpParser, "LOCATION header can not be NULL "
                             "for a NOTIFY message.");
                    return FALSE;
                }

                // ssdp:alive messages must have a SERVER header
                if (Result->Headers[SSDP_SERVER] == NULL)
                {
                    TraceTag(ttidSsdpParser, "SERVER header can not be NULL "
                             "for a NOTIFY message.");
                    return FALSE;
                }
                if (Result->Headers[SSDP_HOST] == NULL || lstrcmpi(Result->Headers[SSDP_HOST], SSDP_ADDR_PORT))
                {
                    TraceTag(ttidSsdpParser, "HOST must be 239.255.255.250:1900"
                             "for a NOTIFY message.");
                    return FALSE;
                }
            }
            else if (!lstrcmpi(Result->Headers[SSDP_NTS], "ssdp:byebye"))
            {
                if (Result->Headers[SSDP_HOST] == NULL || lstrcmpi(Result->Headers[SSDP_HOST], SSDP_ADDR_PORT))
                {
                    TraceTag(ttidSsdpParser, "HOST must be 239.255.255.250:1900"
                             "for a NOTIFY message.");
                    return FALSE;
                }
            }
        }
    }

    if (Result->Headers[CONTENT_LENGTH] != NULL &&
        IsStrDigits(Result->Headers[CONTENT_LENGTH]) == FALSE )
    {
        TraceTag(ttidSsdpParser, "Content length header should be all digits");
        return FALSE;
    }

    return TRUE;
}

BOOL HasContentBody(PSSDP_REQUEST Result)
{
    return (Result->Headers[CONTENT_LENGTH] != NULL);
}

BOOL ParseSsdpRequest(CHAR * szMessage, PSSDP_REQUEST Result)
{
    CHAR *szHeaders;

    szHeaders = ParseRequestLine(szMessage, Result);

    if (szHeaders == NULL)
    {
        return FALSE;
    }

    char *pContent = ParseHeaders(szHeaders, Result);
    if ( pContent == NULL)
    {
        return FALSE;
    }
    else
    {
        if (VerifySsdpHeaders(Result) == FALSE)
        {
            return FALSE;
        }

        // Headers are OK.

        if (Result->Headers[CONTENT_LENGTH] != NULL)
        {
            // To-Do: Maybe we can share the this routine with those
            // in ProcessTcpReceiveData();
            // In that case, we need catch the return szValue of ParseContent
            // and probably return a more meaningful error code.
            ParseContent(pContent, (DWORD)(-1), Result);
        }
        return TRUE;
    }
}


// Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
// Returns a pointer to the first CHAR after the status line
// Returns NULL if fail to parse status line

BOOL ParseSsdpResponse(CHAR *szMessage, SSDP_REQUEST *Result)
{
    CHAR *token;
    CHAR *szHeaders;

    Assert(NULL != szMessage);

    // Make sure we don't go past the end of the buffer
    CHAR * pchEnd = szMessage + lstrlen(szMessage);

    //  get the version
    token = strtok(szMessage," \t\n");
    if (token == NULL)
    {
        TraceTag(ttidSsdpParser, "Response: Parser could not locate the "
                 "seperator, space, tab or eol");
        return FALSE;
    }

    if (_stricmp(token, "HTTP/1.1") != 0)
    {
        TraceTag(ttidSsdpParser, "The version specified in the response "
                 "message is not HTTP/1.1");
        return FALSE;
    }

    // get the response code
    token = strtok(NULL," ");
    if (token == NULL)
    {
        TraceTag(ttidSsdpParser, "Parser could not find the url in the "
                 "message.");
        return FALSE;
    }

    if (_stricmp(token, "200") != 0)
    {
        TraceTag(ttidSsdpParser, "The response code in the response message "
                 "is not HTTP/1.1");
        return FALSE;
    }


    // get the response message, no need for now.
    token = strtok(NULL,"  \t\r");

    if (token == NULL)
    {
        TraceTag(ttidSsdpParser, "Failed to get the version in the request "
                 "header.");
        return FALSE;
    }

    szHeaders = token + strlen(token) + 1;
    if (szHeaders >= pchEnd)
    {
        TraceTag(ttidSsdpParser, "no data following HTTP/1.1 200 in the request");
        return FALSE;
    }

    char *pContent = ParseHeaders(szHeaders, Result);

    if (pContent == NULL || Result->Headers[SSDP_USN] == NULL)
    {
        return FALSE;
    } else
    {
        if (Result->Headers[CONTENT_LENGTH] != NULL)
        {
            ParseContent(pContent, (DWORD)(-1), Result);
        }
        return TRUE;
    }
}

BOOL ParseCacheControlHeader(SSDP_REQUEST *Result)
{
    if (Result->Headers[SSDP_CACHECONTROL])
    {
        // Further parse the cache-control header
        //
        CHAR * szValue = strstr(Result->Headers[SSDP_CACHECONTROL], c_szMaxAge);
        if (szValue)
        {
            CHAR *  szTemp = szValue + c_cchMaxAge;

            strtrim(&szTemp);
            if (*szTemp != '=')
            {
                TraceTag(ttidSsdpParser, "Invalid max-age directive"
                         " in cache-control header.");
                return FALSE;
            }
            else
            {
                szTemp++;
                memcpy(Result->Headers[SSDP_CACHECONTROL], c_szMaxAge, c_cchMaxAge);
                Result->Headers[SSDP_CACHECONTROL][c_cchMaxAge] = '=';

                strtrim(&szTemp);
                szValue = szTemp;
                while (isdigit(*szTemp))
                {
                    szTemp++;
                }
                if (szTemp == szValue)
                {
                    // no digits found
                    TraceTag(ttidSsdpParser, "Invalid max-age directive"
                             " in cache-control header.");
                    return FALSE;
                }

                memcpy(Result->Headers[SSDP_CACHECONTROL] + c_cchMaxAge+1,
                       szValue, (size_t)(szTemp - szValue));

                // Nul term the string so the cache-control
                // header should now be "max-age=398733" and
                // nothing more or less
                size_t cch = c_cchMaxAge + 1 + (szTemp - szValue);
                Result->Headers[SSDP_CACHECONTROL][cch] = 0;
            }
        }
        else
        {
            TraceTag(ttidSsdpParser, "Cache-control header"
                     "did not include max-age directive.");
            return TRUE;
        }
    }
    return TRUE;
}

char * ParseHeaders(CHAR *szMessage, SSDP_REQUEST *Result)
{
    CHAR *token;
    INT i = NUM_OF_HEADERS;
    INT iPrevHeader = NUM_OF_HEADERS;

    Assert(NULL != szMessage);
    if (NULL == strstr(szMessage, szHeaderEnd))
    {
        TraceTag(ttidSsdpParser, "Invalid header - does not end with double CRLF");
        return NULL;
    }

    // Get the next header
    token = strtok(szMessage, "\r\n");

    while (token != NULL)
    {
        CHAR * pHeaderSep; // points to the ':' that seperates the header and its content.
        CHAR * pHeaderCopy;
        CHAR * pBeyondTokenEnd;

        pBeyondTokenEnd = token + strlen(token) + 1;

        if ((*token == ' ' || *token == '\t') && iPrevHeader != NUM_OF_HEADERS)
        {
            // this is a continuation of the last line
            strtrim(&token);
            if (Result->Headers[iPrevHeader])
            {
                // we already have this header, so add this data to it.
                CHAR* szTemp = (CHAR*)midl_user_allocate(
                    sizeof(CHAR) * (strlen(token) + strlen(Result->Headers[iPrevHeader]) + 3));
                if (szTemp)
                {
                    strcpy(szTemp, Result->Headers[iPrevHeader]);
                    strcat(szTemp, " ");
                    strcat(szTemp, token);
                    midl_user_free(Result->Headers[iPrevHeader]);
                    Result->Headers[iPrevHeader] = szTemp;
                }
                else
                {
                    TraceTag(ttidSsdpParser, "Failed to allocate memory "
                             "for token %s", token);
                    FreeSsdpRequest(Result);
                    return NULL;
                }

            }
            else
            {
                TraceTag(ttidSsdpParser, "Memory not already allocated for header %s",
                         SsdpHeaderStr[iPrevHeader]);
                FreeSsdpRequest(Result);
                return NULL;
            }

        }
        else
        {
        pHeaderSep = strchr( token, ':' );
        if (pHeaderSep == NULL)
        {
            TraceTag(ttidSsdpParser, "Token %s does not have a ':', ignored.",
                     token);
        }
        else
        {
            *pHeaderSep = '\0';

            strtrim(&token);

                // determine which header we are looking at
            for (i = 0; i < NUM_OF_HEADERS; i++)
            {
                if (_stricmp(SsdpHeaderStr[i],token) == 0)
                        break;
                }

                if (i < NUM_OF_HEADERS)
                {
                    CHAR *szValue;

                    szValue = pHeaderSep + 1;
                    strtrim(&szValue);

                    if (Result->Headers[i])
                    {
                        // we already have this header, so add this data to it.
                        CHAR* szTemp = (CHAR*)midl_user_allocate(
                            sizeof(CHAR) * (strlen(szValue) + strlen(Result->Headers[i]) + 3));
                        if (szTemp)
                        {
                            strcpy(szTemp, Result->Headers[i]);
                            strcat(szTemp, ", ");
                            strcat(szTemp, szValue);
                            midl_user_free(Result->Headers[i]);
                            Result->Headers[i] = szTemp;
                        }
                            else
                            {
                            midl_user_free(Result->Headers[i]);
                            Result->Headers[i] = NULL;
                        }
                    }
                        else
                        {
                    Result->Headers[i] = (CHAR *) midl_user_allocate(
                        sizeof(CHAR) * (strlen(szValue) + 1));
                        if (Result->Headers[i])
                        {
                            strcpy(Result->Headers[i], szValue);
                        }
                    }
                    if (Result->Headers[i] == NULL)
                    {
                        TraceTag(ttidSsdpParser, "Failed to allocate memory "
                                 "for szValue %s",szValue);
                        FreeSsdpRequest(Result);
                        return NULL;
                    }
                }
                else
                {
                // Ignore not recognized header
                TraceTag(ttidSsdpParser, "Token %s does not match any SSDP "
                         "headers",token);
            }
        }
        }

        // Get the next header
        if (!strncmp(pBeyondTokenEnd, szEndOfHeaders, END_HEADERS_SIZE))
        {
            // no more headers. parse what we have
            if (!ParseCacheControlHeader(Result))
            {
                FreeSsdpRequest(Result);
                return NULL;
            }
            return (pBeyondTokenEnd + END_HEADERS_SIZE);
        }
        else
        {
            token = strtok(NULL, "\r\n");
            iPrevHeader = i;
        }
    }

    // We should always have a "\r\n\r\n" in any legal message.
    TraceTag(ttidSsdpParser, "Received message does not contain \\r\\n\\r\\n. Ignored. ");
    FreeSsdpRequest(Result);

    return NULL;
}

BOOL InitializeSsdpRequest(SSDP_REQUEST *pRequest)
{
    INT i;

    pRequest->Method = SSDP_INVALID;
    pRequest->RequestUri = NULL;

    for (i = 0; i < NUM_OF_HEADERS; i++)
    {
        pRequest->Headers[i] = NULL;
    }

    pRequest->ContentType = NULL;

    pRequest->Content = NULL;

    return TRUE;
}


VOID FreeSsdpRequest(SSDP_REQUEST *pSsdpRequest)
{
    INT i = 0;

    if (pSsdpRequest->Content != NULL)
    {
        midl_user_free(pSsdpRequest->Content);
        pSsdpRequest->Content = NULL;
    }

    if (pSsdpRequest->ContentType != NULL)
    {
        midl_user_free(pSsdpRequest->ContentType);
        pSsdpRequest->ContentType = NULL;
    }

    if (pSsdpRequest->RequestUri != NULL)
    {
        midl_user_free(pSsdpRequest->RequestUri);
        pSsdpRequest->RequestUri = NULL;
    }

    for (i = 0; i < NUM_OF_HEADERS; i++)
    {
        if (pSsdpRequest->Headers[i] != NULL)
        {
            midl_user_free(pSsdpRequest->Headers[i]);
            pSsdpRequest->Headers[i] = NULL;
        }
    }
}
// Get rid of leading or trailing white space or tab.

VOID PrintSsdpRequest(const SSDP_REQUEST *pssdpRequest)
{
    INT i;

    for (i = 0; i < NUM_OF_HEADERS; i++)
    {
        if (pssdpRequest->Headers[i] == NULL)
        {
            TraceTag(ttidSsdpParser, "%s = (NULL) ",SsdpHeaderStr[i],
                     pssdpRequest->Headers[i]);
        }
        else
        {
            TraceTag(ttidSsdpParser, "%s = (%s) ",SsdpHeaderStr[i],
                     pssdpRequest->Headers[i]);
        }
    }
}

// Assume szValue does not have beginning or trailing spaces.

INT GetMaxAgeFromCacheControl(const CHAR *szValue)
{
    CHAR * pEqual;
    _int64 Temp;

    if (szValue == NULL)
    {
        return -1;
    }

    pEqual = strchr(szValue, '=');
    if (pEqual == NULL)
    {
        return -1;
    }

    Temp = _atoi64(pEqual+1);

    if (Temp > UINT_MAX / 1000)
    {

        TraceTag(ttidSsdpAnnounce, "Life time exceeded the UINT limit. "
                 "Set to limit");

        Temp = UINT_MAX;
    }

    return (UINT)Temp;
}

BOOL ConvertToByebyeNotify(PSSDP_REQUEST pSsdpRequest)
{
    CHAR * szTemp = "ssdp:byebye";

    free(pSsdpRequest->Headers[SSDP_NTS]);
    pSsdpRequest->Headers[SSDP_NTS] = NULL;

    pSsdpRequest->Headers[SSDP_NTS] = SzaDupSza(szTemp);

    if (pSsdpRequest->Headers[SSDP_NTS] == NULL)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL ConvertToAliveNotify(PSSDP_REQUEST pSsdpRequest)
{
    CHAR * szTemp = "ssdp:alive";

    Assert(pSsdpRequest->Headers[SSDP_ST] != NULL);
    Assert(pSsdpRequest->Headers[SSDP_NTS] == NULL);
    pSsdpRequest->Headers[SSDP_NTS] = SzaDupSza(szTemp);

    if (pSsdpRequest->Headers[SSDP_NTS] == NULL)
    {
        return FALSE;
    }
    else
    {
        pSsdpRequest->Headers[SSDP_NT] = pSsdpRequest->Headers[SSDP_ST];
        pSsdpRequest->Headers[SSDP_ST] = NULL;
        return TRUE;
    }
}

BOOL CompareSsdpRequest(const SSDP_REQUEST * pRequestA, const SSDP_REQUEST * pRequestB)
{
    INT i;

    for (i = 0; i < NUM_OF_HEADERS; i++)
    {
        if ((pRequestA->Headers[i] == NULL &&
             pRequestB->Headers[i]!= NULL) ||
            (pRequestA->Headers[i] != NULL &&
             pRequestB->Headers[i]== NULL))
        {
            return FALSE;
        }
        else if (pRequestA->Headers[i] != NULL &&
                 pRequestB->Headers[i] != NULL)
        {
            if (strcmp(pRequestA->Headers[i], pRequestB->Headers[i]) != 0)
            {
                TraceTag(ttidSsdpParser, "Different headers index %d",i);
                return FALSE;
            }
        }
    }

    Assert(pRequestA->Content == NULL && pRequestB->Content == NULL);

    Assert(pRequestA->ContentType == NULL && pRequestB->ContentType == NULL);

    // We ignore Request URI, as they should always be * for alive and byebye.

    return TRUE;

}

// Deep copy

BOOL CopySsdpRequest(PSSDP_REQUEST Destination, const SSDP_REQUEST * Source)
{
    INT i;

    ZeroMemory(Destination, sizeof(*Destination));

    Destination->Method = Source->Method ;

    for (i = 0; i < NUM_OF_HEADERS; i++)
    {
        if (Source->Headers[i] != NULL)
        {
            Destination->Headers[i] = (CHAR *) midl_user_allocate(
                strlen(Source->Headers[i]) + 1);
            if (Destination->Headers[i] == NULL)
            {
                goto cleanup;
            }
            else
            {
                strcpy(Destination->Headers[i], Source->Headers[i]);
            }
        }
    }

    if (Source->Content != NULL)
    {
        Destination->Content = (CHAR *) midl_user_allocate(
            strlen(Source->Content) + 1);
        if (Destination->Content == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(Destination->Content, Source->Content);
        }
    }

    if (Source->ContentType != NULL)
    {
        Destination->ContentType = (CHAR *) midl_user_allocate(
            strlen(Source->ContentType) + 1);
        if (Destination->ContentType == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(Destination->ContentType, Source->ContentType);
        }
    }

    if (Source->RequestUri != NULL)
    {
        Destination->RequestUri = (CHAR *) midl_user_allocate(
            strlen(Source->RequestUri) + 1);
        if (Destination->RequestUri == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(Destination->RequestUri, Source->RequestUri);
        }
    }

    Destination->guidInterface = Source->guidInterface;

    return TRUE;

cleanup:

    FreeSsdpRequest(Destination);
    return FALSE;
}

BOOL IsStrDigits(LPSTR pszStr)
{
    int i = 0;
    while (pszStr[i] != '\0')
    {
        if (isdigit(pszStr[i++]) == 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}
VOID strtrim(CHAR ** pszStr)
{

    CHAR *end;
    CHAR *begin;

    // Empty string. Nothing to do.
    //
    if (!(**pszStr))
    {
        return;
    }

    begin = *pszStr;
    end = begin + strlen(*pszStr) - 1;

    while (*begin == ' ' || *begin == '\t')
    {
        begin++;
    }

    *pszStr = begin;

    while ((end > begin) && (*end == ' ' || *end == '\t'))
    {
        end--;
    }

    *(end+1) = '\0';
}

CHAR* IsHeadersComplete(const CHAR *szHeaders)
{
    return strstr(szHeaders, szHeaderEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\eventsrv\eventsrv.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       E V E N T S R V . C P P
//
//  Contents:   UPnP GENA server.
//
//  Notes:
//
//  Author:     Ting Cai   Dec. 1999
//
//  Email:      tingcai@microsoft.com
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <winsock2.h>
#include "wininet.h"
#include "eventsrv.h"
#include "ssdpfunc.h"
#include "ssdptypes.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#define LISTEN_BACKLOG  5


VOID ProcessSsdpRequest(PSSDP_REQUEST pSsdpRequest, RECEIVE_DATA *pData);

static LIST_ENTRY g_listOpenConn;
static CRITICAL_SECTION g_csListOpenConn;

static int  g_cOpenConnections;
static long g_cMaxOpenConnections = 150;

static const long c_cMaxOpenDefault = 150;          // default maximum
static const long c_cMaxOpenMin = 5;                // absolute minimum
static const long c_cMaxOpenMax = 1500;             // absolute maximum

static long  cQueuedAccepts = 0;


static SOCKET HttpSocket;
LONG bCreated = 0;

VOID InitializeListOpenConn()
{

    HKEY    hkey;
    DWORD dwMaxConns = c_cMaxOpenDefault;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      "SYSTEM\\CurrentControlSet\\Services"
                                      "\\SSDPSRV\\Parameters", 0,
                                      KEY_READ, &hkey))
    {
        DWORD   cbSize = sizeof(DWORD);

        // ignore failure. In that case, we'll use default
        (VOID) RegQueryValueEx(hkey, "MaxEventConnects", NULL, NULL, (BYTE *)&dwMaxConns, &cbSize);

        RegCloseKey(hkey);
    }

    dwMaxConns = max(dwMaxConns, c_cMaxOpenMin);
    dwMaxConns = min(dwMaxConns, c_cMaxOpenMax);
    g_cMaxOpenConnections = dwMaxConns;

    InitializeCriticalSection(&g_csListOpenConn);
    EnterCriticalSection(&g_csListOpenConn);
    InitializeListHead(&g_listOpenConn);
    g_cOpenConnections = 0;
    LeaveCriticalSection(&g_csListOpenConn);

    TraceTag(ttidEventServer, "Initializing Max Connections %d ", g_cOpenConnections);
}

VOID FreeOpenConnection(POPEN_TCP_CONN pOpenConn)
{
    Assert(OPEN_TCP_CONN_SIGNATURE == (pOpenConn->iType));

    FreeSsdpRequest(&pOpenConn->ssdpRequest);
    free(pOpenConn->szData);
    pOpenConn->szData = NULL;
    pOpenConn->state = CONNECTION_INIT;
    pOpenConn->cbData = 0;
    pOpenConn->cbHeaders = 0;
}

VOID CloseOpenConnection(SOCKET socketPeer)
{
    closesocket(socketPeer);
    RemoveOpenConn(socketPeer);
    
}
POPEN_TCP_CONN CreateOpenConnection(SOCKET socketPeer)
{
    POPEN_TCP_CONN pOpenConn = (POPEN_TCP_CONN) malloc(sizeof(OPEN_TCP_CONN));

    if (pOpenConn == NULL)
    {
        TraceTag(ttidEventServer, "Couldn't allocate memory for %d", socketPeer);
        return NULL;
    }
    pOpenConn->iType = OPEN_TCP_CONN_SIGNATURE;
    pOpenConn->socketPeer = socketPeer;
    pOpenConn->szData = NULL;
    pOpenConn->state = CONNECTION_INIT;
    pOpenConn->cbData = 0;
    pOpenConn->cbHeaders = 0;

    InitializeSsdpRequest(&pOpenConn->ssdpRequest);

    return pOpenConn;
}

VOID AddToListOpenConn(POPEN_TCP_CONN pOpenConn)
{
    EnterCriticalSection(&g_csListOpenConn);
    InsertHeadList(&g_listOpenConn, &(pOpenConn->linkage));
    g_cOpenConnections++;
    LeaveCriticalSection(&g_csListOpenConn);
    TraceTag(ttidEventServer, "AddToListOpenConn - Connections %d ", g_cOpenConnections);
}

VOID CleanupListOpenConn()
{
    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &g_listOpenConn;

    TraceTag(ttidEventServer, "----- Cleanup Open Connection List -----");

    EnterCriticalSection(&g_csListOpenConn);
    for (p = pListHead->Flink; p != pListHead;)
    {

        POPEN_TCP_CONN pOpenConn;

        pOpenConn = CONTAINING_RECORD (p, OPEN_TCP_CONN, linkage);

        p = p->Flink;

        TraceTag(ttidEventServer, "Removing Open Conn %x -----", pOpenConn);

        RemoveEntryList(&(pOpenConn->linkage));
        g_cOpenConnections--;
        TraceTag(ttidEventServer, "CleanupListOpenConn - Connections %d ", g_cOpenConnections);
        closesocket(pOpenConn->socketPeer);

        FreeOpenConnection(pOpenConn);

        // just to be sure we don't use this again
        pOpenConn->iType = -1;

        free(pOpenConn);
    }

    LeaveCriticalSection(&g_csListOpenConn);
    DeleteCriticalSection(&g_csListOpenConn);

    TraceTag(ttidEventServer, "----- Finished Cleanup Open Connection List -----");
}

// Pre-condition: WSAStartup was successful.
// Post-Condtion: HttpSocket is created. GetNetworks can proceed.

SOCKET CreateHttpSocket()
{
    SOCKADDR_IN sockaddrLocal;
    int iRet;

    HttpSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (HttpSocket == INVALID_SOCKET)
    {
        TraceTag(ttidEventServer, "Failed to create http socket. Error code (%d).", GetLastError());
        return INVALID_SOCKET;
    }

    // Bind

    sockaddrLocal.sin_family = AF_INET;
    sockaddrLocal.sin_addr.s_addr = INADDR_ANY;
    sockaddrLocal.sin_port = htons(EVENT_PORT);

    iRet = bind(HttpSocket, (struct sockaddr *)&sockaddrLocal, sizeof(sockaddrLocal));
    if (iRet == SOCKET_ERROR)
    {
        TraceTag(ttidEventServer, "Failed to bind http socket. Error code (%d).", GetLastError());
        closesocket(HttpSocket);
        HttpSocket = INVALID_SOCKET;
        return INVALID_SOCKET;
    }

    InterlockedIncrement(&bCreated);

    return HttpSocket;
}

INT StartHttpServer(SOCKET HttpSocket, HWND hWnd, u_int wMsg)
{
    INT iRet;

    iRet = listen(HttpSocket, LISTEN_BACKLOG);
    if (iRet == SOCKET_ERROR)
    {
        iRet = GetLastError();
        closesocket(HttpSocket);
        HttpSocket = INVALID_SOCKET;
        TraceTag(ttidEventServer, "Failed to listen on http socket.  Error code (%d).", iRet);
        return iRet;
    }

    iRet = WSAAsyncSelect(HttpSocket, hWnd, wMsg, FD_ACCEPT | FD_CONNECT | FD_READ | FD_CLOSE);

    if (iRet == SOCKET_ERROR)
    {
        iRet = GetLastError();
        closesocket(HttpSocket);
        HttpSocket = INVALID_SOCKET;
        TraceTag(ttidEventServer, "----- select failed with error code %d -----", iRet);
        return iRet;
    }
    else
    {
        TraceTag(ttidEventServer, "Ready to accept tcp connections.");
        return 0;
    }
}

VOID CleanupHttpSocket()
{
    if (InterlockedExchange(&bCreated, bCreated) != 0)
    {
        if (HttpSocket != INVALID_SOCKET)
        {
            closesocket(HttpSocket);
        }
    }
}

VOID DoAccept(SOCKET socket)
{
    SOCKADDR_IN sockaddrFrom;
    SOCKET socketPeer;
    int iLen;
    POPEN_TCP_CONN pOpenTcpConn;

    iLen = sizeof(SOCKADDR_IN);

    Assert(socket == HttpSocket);

    // AcceptEx
    socketPeer = accept(socket, (LPSOCKADDR)&sockaddrFrom, &iLen);
    TraceTag(ttidEventServer, "DoAccept - Before Adding to List Connections %d ", g_cOpenConnections);
    if (socketPeer == SOCKET_ERROR)
    {
        TraceTag(ttidEventServer, "----- accept failed with error code %d -----", GetLastError());
        return;
    }

    pOpenTcpConn = CreateOpenConnection(socketPeer);

    if (pOpenTcpConn)
    {
        AddToListOpenConn(pOpenTcpConn);
    }
    else
    {
        TraceError("Couldn't add new connection. Out of memory!",
                   E_OUTOFMEMORY);
    }
}

VOID DelayAccept()
{
    InterlockedIncrement(&cQueuedAccepts);
    TraceTag(ttidEventServer, "----- DelayAccept %d -----", cQueuedAccepts);
}
VOID DoDelayedAccept()
{
    InterlockedDecrement(&cQueuedAccepts);
    TraceTag(ttidEventServer, "----- DoDelayedAccept %d -----", cQueuedAccepts);

    DoAccept(HttpSocket);
}


VOID HandleAccept(SOCKET socket)
{
    if ((g_cOpenConnections > g_cMaxOpenConnections) && (socket == HttpSocket))
    {
        DelayAccept();
    }
    else
    {
        DoAccept(socket);
    }
}


// Pre-Condition:
// The cs for open connection list is held

BOOL FProcessTcpReceiveBuffer(POPEN_TCP_CONN pOpenConn, RECEIVE_DATA *pData)
{
    Assert(pOpenConn);
    Assert(pData);
    Assert(pData->szBuffer);
    Assert(OPEN_TCP_CONN_SIGNATURE == (pOpenConn->iType));

    int iLen = 1;
    CHAR *szBuf = NULL;
    CHAR *pCurrent;
    CHAR *szHeaders;
    BOOL fNeedToLeave = TRUE;

   TraceTag(ttidEventServer, "Partying on pOpenConn 0x%08X, pData->szBuffer='%s'", pOpenConn, pData->szBuffer);


    if ( pOpenConn->cbData > MAX_EVENT_BUF_THROTTLE_SIZE ) {
        
        pOpenConn->state = CONNECTION_ERROR_FORCED_CLOSE;

        SocketSendErrorResponse(pData->socket, HTTP_STATUS_BAD_REQUEST);
         // Gracefully shutdown. Open Conn will be removed in FD_CLOSe
        shutdown(pData->socket, SD_SEND);  
        TraceTag(ttidEventServer, "FProcessTcpReceiveBuffer - Exceeds MAX_EVENT_BUF_THROTTLE_SIZE");
        
         // Try to tear down the connection..
    }
    else {
    // Accumulate data
    iLen += strlen(pData->szBuffer);

    if (pOpenConn->szData != NULL)
    {
        iLen += strlen(pOpenConn->szData);
    }

    szBuf = (CHAR *) malloc(iLen * sizeof(CHAR));

    if (!szBuf)
    {
        TraceError("FProcessTcpReceiveBuffer", E_OUTOFMEMORY);
        return FALSE;
    }

    szBuf[0] = '\0';

    if (pOpenConn->szData)
    {
        strcpy(szBuf, pOpenConn->szData);
        free(pOpenConn->szData);
    }
    strcat(szBuf, pData->szBuffer);

    pOpenConn->cbData += pData->cbBuffer;

    pOpenConn->szData = szBuf;

    }
       TraceTag(ttidEventServer, "FProcessTcpReceiveBuffer - Buff Recv %d",pOpenConn->cbData);
    switch (pOpenConn->state)
    {
    case CONNECTION_INIT:
        pCurrent = IsHeadersComplete(pOpenConn->szData);
        if((pCurrent == NULL) && pOpenConn->cbData > MAX_EVENT_NOTIFY_HEADER_THROTTLE_SIZE )
        {
            pOpenConn->state = CONNECTION_ERROR_FORCED_CLOSE;

            SocketSendErrorResponse(pData->socket, HTTP_STATUS_BAD_REQUEST);
            // Gracefully shutdown. Open Conn will be removed in FD_CLOSe
            shutdown(pData->socket, SD_SEND);  
            TraceTag(ttidEventServer, "FProcessTcpReceiveBuffer - Exceeds MAX_EVENT_NOTIFY_HEADER_THROTTLE_SIZE");
        
         // Try to tear down the connection..    
        }
        if ( pCurrent != NULL)
        {
            pOpenConn->cbHeaders = (DWORD)(pCurrent - (pOpenConn->szData)) + 4;

            szHeaders = ParseRequestLine(pOpenConn->szData, &(pOpenConn->ssdpRequest));
            if ((szHeaders != NULL) && ( pOpenConn->ssdpRequest.Method == SSDP_NOTIFY ))
            {
                CHAR *szContent;

                szContent = ParseHeaders(szHeaders, &(pOpenConn->ssdpRequest));
                if (szContent == NULL)
                {
                     TraceTag(ttidEventServer, "ParseHeaders returned NULL for socket %d",
                              pOpenConn->socketPeer);

                    // We've reached a terminal error.  Since there might be
                    // other received data for this connection already in the
                    // queue, transition to this error state, so that we know
                    // not to process any more data.
                    pOpenConn->state = CONNECTION_ERROR_CLOSING;

                    FreeOpenConnection(pOpenConn);

                    SocketSendErrorResponse(pData->socket, HTTP_STATUS_BAD_REQUEST);
                    // Gracefully shutdown. Open Conn will be removed in FD_CLOSe
                    shutdown(pData->socket, SD_SEND);
                }
                else
                {
                    if (VerifySsdpHeaders(&(pOpenConn->ssdpRequest)) == FALSE)
                    {
                        TraceTag(ttidEventServer, "Verified headers returned false for %d",
                                 pOpenConn->socketPeer);

                        pOpenConn->state = CONNECTION_ERROR_CLOSING;

                        SocketSendErrorResponse(pData->socket, HTTP_STATUS_BAD_REQUEST);
                        // Gracefully shutdown. Open Conn will be removed in FD_CLOSe
                        shutdown(pData->socket, SD_SEND);

                        return TRUE;
                    }

                    // else

                    if (ParseContent(szContent,
                                     (pOpenConn->cbData - pOpenConn->cbHeaders),
                                      &(pOpenConn->ssdpRequest)) == TRUE)
                    {
                        PSSDP_REQUEST pRequest;

                        pRequest = (PSSDP_REQUEST) malloc(sizeof(SSDP_REQUEST));

                        if (pRequest != NULL &&
                            CopySsdpRequest(pRequest, &(pOpenConn->ssdpRequest)) != FALSE)
                        {
                            fNeedToLeave = FALSE;
                            FreeOpenConnection(pOpenConn);
                            LeaveCriticalSection(&g_csListOpenConn);
                            ProcessSsdpRequest(pRequest, pData);
                            free(pRequest);
                        }
                        else
                        {
                            FreeOpenConnection(pOpenConn);
                            if (pRequest)
                            {
                                FreeSsdpRequest(pRequest);
                                free(pRequest);
                            }
                        }
                    }
                    else
                    {
                        // HTTP request not complete

                        CHAR *szTemp;

                        szTemp = SzaDupSza(szContent);
                        free(pOpenConn->szData);
                        pOpenConn->szData = szTemp;

                        pOpenConn->state = CONNECTION_HEADERS_READY;

                        // Done for now, wait for more data
                    }
                }
            }
            else
            {
                pOpenConn->state = CONNECTION_ERROR_FORCED_CLOSE; 
                SocketSendErrorResponse(pData->socket, HTTP_STATUS_BAD_REQUEST);

                // Gracefully shutdown. Open Conn will be removed in FD_CLOSe
                shutdown(pData->socket, SD_SEND);
            }
        }
        break;

    case CONNECTION_HEADERS_READY:
        if (ParseContent(pOpenConn->szData,
                         (pOpenConn->cbData - pOpenConn->cbHeaders),
                          &(pOpenConn->ssdpRequest)) == TRUE)
        {
            SSDP_REQUEST ssdpRequest;

            if (CopySsdpRequest(&ssdpRequest, &(pOpenConn->ssdpRequest)) != FALSE)
            {
                fNeedToLeave = FALSE;
                FreeOpenConnection(pOpenConn);
                LeaveCriticalSection(&g_csListOpenConn);
                ProcessSsdpRequest(&ssdpRequest, pData);
            }
            else
            {
                FreeOpenConnection(pOpenConn);
                FreeSsdpRequest(&ssdpRequest);
            }
        }
        else
        {
            TraceTag(ttidEventServer, "ParseContent failed!");
        }
        break;

    case CONNECTION_ERROR_CLOSING:
        // we've already failed to process this socket but it hasn't yet
        // been closed.  Don't do anything here.
        //
        TraceTag(ttidEventServer,
                 "FProcessTcpReceiveBuffer: "
                 "connection closing from error, ignoring pData->szBuffer");
        break;
    }

    TraceTag(ttidEventServer, "Done partying on pOpenConn 0x%08X", pOpenConn);

    return fNeedToLeave;
}

DWORD LookupListOpenConn(LPVOID pvData)
{
    PLIST_ENTRY     p;
    PLIST_ENTRY     pListHead = &g_listOpenConn;
    BOOL            fLeave = TRUE;
    BOOL            fCloseConn = FALSE;
    RECEIVE_DATA *  pData = (RECEIVE_DATA *)pvData;

    Assert(pData);

    TraceTag(ttidEventServer, "----- Search Open Connections List -----");

    AssertSz(pData->szBuffer != NULL, "SocketReceive should have allocated the buffer");

    EnterCriticalSection(&g_csListOpenConn);
    for (p = pListHead->Flink; p != pListHead;)
    {
        POPEN_TCP_CONN pOpenConn;

        pOpenConn = CONTAINING_RECORD (p, OPEN_TCP_CONN, linkage);

        p = p->Flink;

        if (pOpenConn->socketPeer == pData->socket)
        {
            fLeave = FProcessTcpReceiveBuffer(pOpenConn, pData);
            fCloseConn = (pOpenConn->state == CONNECTION_ERROR_FORCED_CLOSE)?TRUE:FALSE;
            break;
        }
    }

    if (fLeave)
    {
        LeaveCriticalSection(&g_csListOpenConn);
    }

    if(fCloseConn)
    {
        CloseOpenConnection(pData->socket);            
    }
  
    
    free(pData->szBuffer);
    free(pData);

    return 0;
}

VOID RemoveOpenConn(SOCKET socket)
{
    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &g_listOpenConn;
    int     cFound = 0;

    TraceTag(ttidEventServer, "----- Search Open Connections List to remove -----");

    EnterCriticalSection(&g_csListOpenConn);
    for (p = pListHead->Flink; p != pListHead;)
    {

        POPEN_TCP_CONN pOpenConn;

        pOpenConn = CONTAINING_RECORD (p, OPEN_TCP_CONN, linkage);

        p = p->Flink;

        if (pOpenConn->socketPeer == socket)
        {
            RemoveEntryList(&pOpenConn->linkage);
            g_cOpenConnections--;
            
            FreeOpenConnection(pOpenConn);
            free(pOpenConn);

            cFound++;
        }
    }

    LeaveCriticalSection(&g_csListOpenConn);
    TraceTag(ttidEventServer, "RemoveOpenConn - Found %d",cFound);
    while (cFound > 0)
    {
        if (InterlockedExchange(&cQueuedAccepts, cQueuedAccepts) > 0)
        {
            DoDelayedAccept();
        }
        cFound--;
    }
    
    TraceTag(ttidEventServer, "RemoveOpenConn - Num of Connections %d",g_cOpenConnections);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpnetwork\socket.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

File Name:

    socket.c

Abstract:

    This file contains code which opens and close ssdp socket, send and receive over the socket.

Author: Ting Cai

Created: 07/10/1999

--*/

#include <pch.h>
#pragma hdrstop

#include <winsock2.h>
#include <ws2tcpip.h>
#include "wininet.h"
#include "ssdpfunc.h"
#include "ssdptypes.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#include "ssdpnetwork.h"
#include "mswsock.h"

#define WSA_MAX_MAJOR 0x02
#define WSA_MAX_MINOR 0x00
#define WSA_MIN_MAJOR 0x01
#define WSA_MIN_MINOR 0x01

#define RECEIVE_BUFFER_SIZE 256

#ifndef CLASSD_ADDR
#define CLASSD_ADDR(a)      (( (*((unsigned char *)&(a))) & 0xf0) == 0xe0)
#endif

static SOCKADDR_IN ToAddress;
static BOOLEAN bStopRecv = FALSE;
static LONG bStartup = 0;

// Default TTL value for SSDP
const DWORD c_dwTtlDefault = 1;
const DWORD c_dwTtlMin = 1;
const DWORD c_dwTtlMax = 255;

LPFN_WSARECVMSG g_WSARecvMsgFuncPtr=NULL;

// SocketInit() returns 0 on success, and places failure codes in
// GetLastError()

INT SocketInit()
{
    INT iRet;
    WSADATA wsadata;
    WORD wVersionRequested = MAKEWORD(WSA_MAX_MAJOR, WSA_MIN_MINOR);
    BOOL bVersion20 = FALSE;

    // WinSock version negotiation. Use 2.0 if available. 1.1 is the minimum.
    iRet = WSAStartup(wVersionRequested,&wsadata);
    if ( iRet != 0)
    {
        if (iRet == WSAVERNOTSUPPORTED)
        {
            TraceTag(ttidSsdpSocket, "WSAStartup failed with error %d. DLL "
                     "supports version higher than 2.0, but not also 2.0.",
                     GetLastError());
            return -1;
        }
        else
        {
            TraceTag(ttidSsdpSocket, "WSAStartup failed with error %d.",
                     GetLastError());
            return -1;
        }
    }

    if (wVersionRequested == wsadata.wVersion)
    {
        bVersion20 = TRUE;
    }
    else if ((LOWORD(wsadata.wHighVersion)) >= WSA_MIN_MAJOR)
    {
        // Supported version is at least 1.* and < 2.0
        if ((HIWORD(wsadata.wHighVersion)) < WSA_MIN_MINOR)
        {
            TraceTag(ttidSsdpSocket, "Minor version supported is below our "
                     "min. requirement.");

            int result = WSACleanup();

            if (0 == result)
            {
                ::SetLastError(WSAVERNOTSUPPORTED);
            }

            return -1;
        }
    }
    else
    {
        TraceTag(ttidSsdpSocket, "Major version supported is below our "
                 "min. requirement.");

        int result = WSACleanup();

        if (0 == result)
        {
            ::SetLastError(WSAVERNOTSUPPORTED);
        }

        return -1;
    }

    ToAddress.sin_family = AF_INET;
    ToAddress.sin_addr.s_addr = inet_addr(SSDP_ADDR);
    ToAddress.sin_port = htons(SSDP_PORT);

    InterlockedIncrement(&bStartup);

    TraceTag(ttidSsdpSocket, "WSAStartup suceeded.");

    return 0;
}

BOOL SocketClose(SOCKET socketToClose);

// Pre-Conditon: SocketInit was succesful.
// Post-Conditon: Create a socket on a given interface.
BOOL SocketOpen(SOCKET *psocketToOpen, PSOCKADDR_IN IpAddress, DWORD dwMulticastInterfaceIndex, BOOL fRecvMcast)
{
    struct ip_mreq mreq;
    INT iRet;
    DWORD dwTtl = c_dwTtlDefault;
    SOCKET socketSSDP;
    HKEY    hkey;

    // Create a socket to listen on the multicast channel

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      "SYSTEM\\CurrentControlSet\\Services"
                                      "\\SSDPSRV\\Parameters", 0,
                                      KEY_READ, &hkey))
    {
        DWORD   cbSize = sizeof(DWORD);

        // ignore failure. In that case, we'll use default
        (VOID) RegQueryValueEx(hkey, "TTL", NULL, NULL, (BYTE *)&dwTtl, &cbSize);

        RegCloseKey(hkey);
    }

    dwTtl = max(dwTtl, c_dwTtlMin);
    dwTtl = min(dwTtl, c_dwTtlMax);

    TraceTag(ttidSsdpSocket, "TTL is %d", dwTtl);

    socketSSDP = socket(AF_INET, SOCK_DGRAM, 0);
    if (socketSSDP == INVALID_SOCKET)
    {
        TraceTag(ttidSsdpSocket, "Failed to create socket (%d)",
                 GetLastError());
        return FALSE;
    }

    // Bind
    iRet = bind(socketSSDP, (struct sockaddr *)IpAddress, sizeof(*IpAddress));
    if (iRet == SOCKET_ERROR)
    {
        TraceTag(ttidSsdpSocket, "bind failed with error (%d)",
                 GetLastError());
        SocketClose(socketSSDP);
        *psocketToOpen = INVALID_SOCKET;
        return FALSE;
    }

    TraceTag(ttidSsdpSocket, "bound to address succesfully");

    if (fRecvMcast)
    {
        // Join the multicast group
        mreq.imr_multiaddr.s_addr = inet_addr(SSDP_ADDR);
        mreq.imr_interface.s_addr = dwMulticastInterfaceIndex;
        iRet = setsockopt(socketSSDP, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                          (CHAR*)&mreq, sizeof(mreq));
        if (iRet == SOCKET_ERROR)
        {
            TraceTag(ttidSsdpSocket, "Join mulitcast group failed with error "
                     "%d.",GetLastError());
            SocketClose(socketSSDP);
            *psocketToOpen = INVALID_SOCKET;
            return FALSE;
        }
        TraceTag(ttidSsdpSocket, "Ready to listen on multicast channel.");

        int on = 1;
        if (setsockopt(socketSSDP, IPPROTO_IP, IP_PKTINFO, (char *)&on, sizeof(on))) 
        {
            TraceTag(ttidSsdpSocket, "Can not enable IP_PKTINFO %d..",GetLastError());
            SocketClose(socketSSDP);
            *psocketToOpen = INVALID_SOCKET;
            return FALSE;
        }

        if (g_WSARecvMsgFuncPtr == NULL)
        {
            GUID WSARecvGuid=WSAID_WSARECVMSG;
            DWORD   cbReturned;
            int status=WSAIoctl(
                                    socketSSDP,
                                    SIO_GET_EXTENSION_FUNCTION_POINTER,
                                    (void*)&WSARecvGuid,
                                    sizeof(GUID),
                                    (void*)&g_WSARecvMsgFuncPtr,
                                    sizeof(LPFN_WSARECVMSG),
                                    &cbReturned,
                                    NULL,
                                    NULL
                                    );

            if (status != ERROR_SUCCESS) 
            {
                g_WSARecvMsgFuncPtr = NULL;
            }
        }

    }

    // set the interface to send multicast packets from

    if (setsockopt(socketSSDP, IPPROTO_IP, IP_MULTICAST_IF,
                   (CHAR *)&dwMulticastInterfaceIndex,
                   sizeof(dwMulticastInterfaceIndex)) == SOCKET_ERROR)
    {
        TraceTag(ttidSsdpSocket, "Error %d occured in setting"
                 "IP_MULTICAST_IF option", GetLastError());
        SocketClose(socketSSDP);
        *psocketToOpen = INVALID_SOCKET;
        return FALSE;
    }

    if (setsockopt(socketSSDP, IPPROTO_IP, IP_MULTICAST_TTL,
                   (CHAR *)&dwTtl, sizeof(dwTtl)) == SOCKET_ERROR)
    {
        TraceTag(ttidSsdpSocket, "Error %d occured in setting  "
                 "IP_MULTICAST_TTL option with value %d.", GetLastError(),
                 dwTtl);
        SocketClose(socketSSDP);
        *psocketToOpen = INVALID_SOCKET;
        return FALSE;
    }

    // use TTL for responses as well
    if (setsockopt(socketSSDP, IPPROTO_IP, IP_TTL,
                   (CHAR *)&dwTtl, sizeof(dwTtl)) == SOCKET_ERROR)
    {
        TraceTag(ttidSsdpSocket, "Error %d occured in setting  "
                 "IP_TTL option with value %d.", GetLastError(),
                 dwTtl);
        SocketClose(socketSSDP);
        *psocketToOpen = INVALID_SOCKET;
        return FALSE;
    }

    if(inet_addr("127.0.0.1") != IpAddress->sin_addr.S_un.S_addr)
    {
        BOOL bVal = FALSE;
        DWORD dwBytesReturned = 0;
        if (WSAIoctl(socketSSDP, SIO_MULTIPOINT_LOOPBACK, &bVal, sizeof(bVal), NULL, 0, &dwBytesReturned, NULL, NULL) == SOCKET_ERROR)
        {
            TraceTag(ttidSsdpSocket, "Error %d occured in setting  "
                     "SIO_MULTIPOINT_LOOPBACK option with value %d.", GetLastError(),
                     bVal);
            SocketClose(socketSSDP);
            *psocketToOpen = INVALID_SOCKET;
            return FALSE;
        }
    }
    /*
    announceAddr.sin_family = AF_INET;
    announceAddr.sin_addr.s_addr = inet_addr(SSDP_ANNOUNCE_ADDR);
    announceAddr.sin_port = htons(SSDP_ANNOUNCE_PORT);
    */

    TraceTag(ttidSsdpSocket, "Ready to send on multicast channel.");

    *psocketToOpen = socketSSDP;

    return TRUE;
}

BOOL SocketClose(SOCKET socketToClose)
{
    closesocket(socketToClose);
    return TRUE;
}

VOID SocketFinish()
{
    if (InterlockedExchange(&bStartup, bStartup) != 0)
    {
        WSACleanup();
    }
}

VOID SocketSend(const CHAR *szBytes, SOCKET socket, SOCKADDR_IN *RemoteAddress)
{
    INT iBytesToSend, iBytesSent;

    TraceTag(ttidSsdpSocket, "Sending ssdp message");

    if (RemoteAddress == NULL)
    {
        RemoteAddress = &ToAddress;
    }

    iBytesToSend = strlen(szBytes);
    // To-Do: make sure the size is no larger than the UDP limit.
    iBytesSent = sendto(socket, szBytes, iBytesToSend, 0,
                        (struct sockaddr *) RemoteAddress, sizeof(ToAddress));
    if (iBytesSent == SOCKET_ERROR)
    {
        TraceTag(ttidSsdpSocket, "Failed to send announcement, (%d)",
                 GetLastError());
    }
    else if (iBytesSent != iBytesToSend)
    {
        TraceTag(ttidSsdpSocket, "Only sent %d bytes instead of %d bytes.",
                 iBytesSent, iBytesToSend);
    }
    else
    {
        TraceTag(ttidSsdpSocket, "SSDP message was sent successfully.");
    }
}

VOID SocketSendErrorResponse(SOCKET socket, DWORD dwErr)
{
    LPCSTR  szError;
    CHAR    szResponse[256];

    switch (dwErr)
    {
        case HTTP_STATUS_NOT_FOUND:
            szError = "Not Found";
            break;

        case HTTP_STATUS_PRECOND_FAILED:
            szError = "Pre-condition Failed";
            break;

        case HTTP_STATUS_BAD_REQUEST:
            szError = "Bad Request";
            break;

        case HTTP_STATUS_OK:
            szError = "OK";
            break;

        default:
            szError = "Error";
            break;
    }

    wsprintf(szResponse, "HTTP/1.1 %d %s\r\n\r\n", dwErr, szError);
    SocketSend(szResponse, socket, NULL);
}

BOOL SocketReceive(SOCKET socket, CHAR **pszData, DWORD *pcbBuffer,
                   SOCKADDR_IN *fromSocket, BOOL fRecvMCast, BOOL *pfGotMCast)
{
    u_long BufferSize;
    u_long BytesReceived;
    CHAR *ReceiveBuffer;
    SOCKADDR_IN RemoteSocket;
    INT SocketSize = sizeof(RemoteSocket);
    int status;

    if (pcbBuffer)
    {
        *pcbBuffer = 0;
    }

    ioctlsocket(socket, FIONREAD, &BufferSize);

    ReceiveBuffer = (CHAR *) malloc(sizeof(CHAR) * (BufferSize+1));
    if (ReceiveBuffer == NULL)
    {
        TraceTag(ttidSsdpSocket, "Error: failed to allocate LargeBuffer of "
                 "(%d) bytes",BufferSize + 1);
        return FALSE;
    }

    if (fRecvMCast && g_WSARecvMsgFuncPtr != NULL)
    {
        Assert (pfGotMCast != NULL);
        WSAMSG                          Msg;
        WSABUF                          buf;
        const DWORD                     dwCtlSize = WSA_CMSG_SPACE(sizeof(struct in_pktinfo));
        char                            Controls[dwCtlSize];

        *pfGotMCast = FALSE;
        ZeroMemory (&Msg, sizeof(Msg));
        Msg.name = (struct sockaddr *)&RemoteSocket;
        Msg.namelen = SocketSize;
        buf.len = BufferSize;
        buf.buf = ReceiveBuffer;
        Msg.lpBuffers = &buf;
        Msg.dwBufferCount = 1;
        ZeroMemory (Controls, sizeof(Controls));
        Msg.Control.len = dwCtlSize;
        Msg.Control.buf = Controls;
        status = g_WSARecvMsgFuncPtr(
                                            socket,
                                            &Msg,
                                            &BytesReceived,
                                            NULL,
                                            NULL
                                            );
        if (status == SOCKET_ERROR)
        {
            BytesReceived = SOCKET_ERROR;
        }
        else
        {
            SocketSize = Msg.namelen;
            WSACMSGHDR *Hdr=WSA_CMSG_FIRSTHDR(&Msg);
            struct in_pktinfo *pktinfo;

            if (Hdr == NULL) 
            {
                BytesReceived = SOCKET_ERROR;
            }
            else
            {
                pktinfo=(struct in_pktinfo *)WSA_CMSG_DATA(Hdr);
                if (pktinfo == NULL) 
                {
                    BytesReceived = SOCKET_ERROR;
                }
                else
                {
                    if (Msg.dwFlags & (MSG_MCAST))
                        *pfGotMCast = TRUE;
                    else  // This else is here to work around a socket bug (509919)
                        *pfGotMCast = CLASSD_ADDR(pktinfo->ipi_addr.s_addr) ? TRUE : FALSE;
                }
            }
        }
    }
    else
    {
        BytesReceived = recvfrom(socket, ReceiveBuffer, BufferSize, 0,
                             (struct sockaddr *) &RemoteSocket, &SocketSize);
    }

    if (BytesReceived == SOCKET_ERROR)
    {
        free(ReceiveBuffer);
        TraceTag(ttidSsdpSocket, "Error: recvfrom failed with error code (%d)",
                 WSAGetLastError());
        return FALSE;
    }
    else
    {
        ReceiveBuffer[BytesReceived] = '\0';

        TraceTag(ttidSsdpRecv, "Received packet: \n%s\n", ReceiveBuffer);
        TraceTag(ttidSsdpRecv, "\nReceived packet Size: %d \n",BytesReceived);

        *pszData = ReceiveBuffer;

        *fromSocket = RemoteSocket;

        if (pcbBuffer)
        {
            *pcbBuffer = BufferSize;
        }

        return TRUE;
    }
}


LPSTR GetSourceAddress(SOCKADDR_IN fromSocket)
{
    return inet_ntoa(fromSocket.sin_addr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\inc\ustring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U S T R I N G . H
//
//  Contents:   Simple string class
//
//  Notes:
//
//  Author:     mbend   17 Aug 2000
//
//----------------------------------------------------------------------------

#pragma once

class CUString
{
public:
    CUString() : m_sz(NULL) {}
    ~CUString()
    {
        Clear();
    }

    long GetLength() const
    {
        return m_sz ? lstrlenW(m_sz) : 0;
    }
    const wchar_t * GetBuffer() const
    {
        return m_sz;
    }
    operator const wchar_t *() const
    {
        return m_sz;
    }
    wchar_t & operator[](long nIndex)
    {
        Assert(m_sz && GetLength() > nIndex && nIndex >= 0);
        return m_sz[nIndex];
    }
    wchar_t operator[](long nIndex) const
    {
        Assert(m_sz && GetLength() > nIndex && nIndex >= 0);
        return m_sz[nIndex];
    }
    bool operator==(const CUString & ref) const
    {
        return !Cmp(ref);
    }
    bool operator==(const wchar_t * sz) const
    {
        return !Cmp(sz);
    }
    bool operator<(const CUString & ref) const
    {
        return Cmp(ref) < 0;
    }
    bool operator<(const wchar_t * sz) const
    {
        return Cmp(sz) < 0;
    }
    bool operator>(const CUString & ref) const
    {
        return Cmp(ref) > 0;
    }
    bool operator>(const wchar_t * sz) const
    {
        return Cmp(sz) > 0;
    }
    bool operator<=(const CUString & ref) const
    {
        return Cmp(ref) <= 0;
    }
    bool operator<=(const wchar_t * sz) const
    {
        return Cmp(sz) <= 0;
    }
    bool operator>=(const CUString & ref) const
    {
        return Cmp(ref) >= 0;
    }
    bool operator>=(const wchar_t * sz) const
    {
        return Cmp(sz) >= 0;
    }

    HRESULT HrAssign(const CUString & ref)
    {
        if(&ref == this)
        {
            return S_OK;
        }
        return HrAssign(ref.m_sz);
    }
    HRESULT HrAssign(const wchar_t * sz);
    HRESULT HrAssign(const char * sz);
    HRESULT HrAppend(const CUString & ref)
    {
        return HrAppend(ref.m_sz);

    }
    HRESULT HrAppend(const wchar_t * sz);
    void Clear()
    {
        delete [] m_sz;
        m_sz = NULL;
    }
    void Transfer(CUString & ref)
    {
        delete [] m_sz;
        m_sz = ref.m_sz;
        ref.m_sz = NULL;
    }

    HRESULT HrPrintf(const wchar_t * szFormat, ...);

#ifndef _UPNP_SSDP
    HRESULT HrGetBSTR(BSTR * pbstr) const;
    HRESULT HrGetCOM(wchar_t ** psz) const;
    HRESULT HrInitFromGUID(const GUID & guid);
#endif

    // Multibyte helper routines
    long CcbGetMultiByteLength() const;
    HRESULT HrGetMultiByte(char * szBuf, long ccbLength) const;
    HRESULT HrGetMultiByteWithAlloc(char ** pszBuf) const;
private:
    long Cmp(const wchar_t * sz) const
    {
        if(!m_sz && !sz)
        {
            return 0;
        }
        if(!m_sz)
        {
            return -1;
        }
        if(!sz)
        {
            return 1;
        }
        return lstrcmpW(m_sz, sz);
    }
    long Cmp(const CUString & ref) const
    {
        return Cmp(ref.m_sz);
    }
    wchar_t * m_sz;
};

inline HRESULT HrTypeAssign(CUString & dst, const CUString & src)
{
    return dst.HrAssign(src);
}

inline void TypeTransfer(CUString & dst, CUString & src)
{
    dst.Transfer(src);
}

inline void TypeClear(CUString & type)
{
    type.Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpparser\ssdpparserp.h ===
#include <windef.h>
#include "ssdpparser.h"
#include "common.h"

#define CRLF "\r\n"
#define SP " "
#define COLON ":"

#define NOTIFY_HEADER "NOTIFY * HTTP/1.1"
#define HOST_HEADER SSDP_ADDR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\announce.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       A N N O U N C E . H
//
//  Contents:   SSDP Announcement list
//
//  Notes:
//
//  Author:     mbend   8 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "ulist.h"
#include "upsync.h"
#include "timer.h"
#include "rundown.h"
#include "ssdptypes.h"
#include "ustring.h"

class CSsdpService
{
public:
    CSsdpService();
    ~CSsdpService();

    PCONTEXT_HANDLE_TYPE * GetContext();
    BOOL FIsUsn(const char * szUsn);

    // RPC rundown support
    static void OnRundown(CSsdpService * pService);

    // Timer callback methods
    void TimerFired();
    BOOL TimerTryToLock();
    void TimerUnlock();

    HRESULT HrInitialize(
        SSDP_MESSAGE * pssdpMsg,
        DWORD dwFlags,
        PCONTEXT_HANDLE_TYPE * ppContextHandle);
    HRESULT HrStartTimer();

    HRESULT HrAddSearchResponse(SSDP_REQUEST * pSsdpRequest,
                                SOCKET * pSocket,
                                SOCKADDR_IN * pRemoteSocket);
    HRESULT HrCleanup(BOOL bByebye);
    BOOL FIsPersistent();
private:
    CSsdpService(const CSsdpService &);
    CSsdpService & operator=(const CSsdpService &);

    CTimer<CSsdpService>    m_timer;
    long        m_nRetryCount;
    long        m_nLifetime;
    SSDP_REQUEST m_ssdpRequest;
    CUString    m_strAlive;
    CUString    m_strByebye;
    CUString    m_strResponse;
    CUCriticalSection m_critSec;
    DWORD       m_dwFlags;
    PCONTEXT_HANDLE_TYPE * m_ppContextHandle;
};

class CSsdpServiceManager
{
public:
    ~CSsdpServiceManager();

    static CSsdpServiceManager & Instance();

    HRESULT HrAddService(
        SSDP_MESSAGE * pssdpMsg,
        DWORD dwFlags,
        PCONTEXT_HANDLE_TYPE * ppContextHandle);
    CSsdpService * FindServiceByUsn(char * szUSN);
    HRESULT HrAddSearchResponse(SSDP_REQUEST * pSsdpRequest,
                                SOCKET * pSocket,
                                SOCKADDR_IN * pRemoteSocket);
    HRESULT HrRemoveService(CSsdpService * pService, BOOL bByebye);
    HRESULT HrServiceRundown(CSsdpService * pService);
    HRESULT HrCleanupAnouncements();
private:
    CSsdpServiceManager();
    CSsdpServiceManager(const CSsdpServiceManager &);
    CSsdpServiceManager & operator=(const CSsdpServiceManager &);

    HRESULT HrRemoveServiceInternal(CSsdpService * pService, BOOL bByebye, BOOL bRundown);

    typedef CUList<CSsdpService> ServiceList;

    CUCriticalSection m_critSec;
    ServiceList m_serviceList;

    static CSsdpServiceManager s_instance;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\announce.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       A N N O U N C E . C P P
//
//  Contents:   SSDP Announcement list
//
//  Notes:
//
//  Author:     mbend   8 Nov 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "announce.h"
#include "search.h"
#include "ssdpfunc.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#include "upthread.h"

#define BUF_SIZE 40

HRESULT HrInitializeSsdpRequestFromMessage(
    SSDP_REQUEST * pRequest,
    const SSDP_MESSAGE *pMsg);

static LIST_ENTRY listAnnounce;
CRITICAL_SECTION CSListAnnounce;
static CHAR *AliveHeader = "ssdp:alive";
static CHAR *ByebyeHeader = "ssdp:byebye";
static CHAR *MulticastUri = "*";

static const DWORD c_dwUPnPMajorVersion = 1;
static const DWORD c_dwUPnPMinorVersion = 0;
static const DWORD c_dwHostMajorVersion = 1;
static const DWORD c_dwHostMinorVersion = 0;

CSsdpService::CSsdpService() : m_timer(*this)
{
    ZeroMemory(&m_ssdpRequest, sizeof(m_ssdpRequest));
}

CSsdpService::~CSsdpService()
{
    FreeSsdpRequest(&m_ssdpRequest);
}

PCONTEXT_HANDLE_TYPE * CSsdpService::GetContext()
{
    return m_ppContextHandle;
}

BOOL CSsdpService::FIsUsn(const char * szUsn)
{
    BOOL bMatch = FALSE;
    if(m_ssdpRequest.Headers[SSDP_USN])
    {
        if(0 == lstrcmpA(m_ssdpRequest.Headers[SSDP_USN], szUsn))
        {
            bMatch = TRUE;
        }
    }
    return bMatch;
}

void CSsdpService::OnRundown(CSsdpService * pService)
{
    CSsdpServiceManager::Instance().HrServiceRundown(pService);
}

void CSsdpService::TimerFired()
{
    HRESULT hr = S_OK;

    char * szAlive = NULL;
    hr = m_strAlive.HrGetMultiByteWithAlloc(&szAlive);
    if(SUCCEEDED(hr))
    {
        GetNetworkLock();
        SendOnAllNetworks(szAlive, NULL);
        FreeNetworkLock();
        delete [] szAlive;

        // Repeat three times
        --m_nRetryCount;
        if(0 == m_nRetryCount)
        {
            // To-Do: The current limit on life time is 49.7 days.  (32 bits in milliseconds)
            // 32 bit in seconds should be enough.
            // Need to add field remaining time ...

            m_nRetryCount = 3;

            long nTimeout = m_nLifetime * 1000/2 - 2 * (RETRY_INTERVAL * (NUM_RETRIES - 1));

            hr = m_timer.HrSetTimerInFired(nTimeout);
        }
        else
        {
            hr = m_timer.HrSetTimerInFired(RETRY_INTERVAL);
        }
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::TimerFired");
}

BOOL CSsdpService::TimerTryToLock()
{
    return m_critSec.FTryEnter();
}

void CSsdpService::TimerUnlock()
{
    m_critSec.Leave();
}

HRESULT CSsdpService::HrInitialize(
    SSDP_MESSAGE * pssdpMsg,
    DWORD dwFlags,
    PCONTEXT_HANDLE_TYPE * ppContextHandle)
{
    HRESULT hr = S_OK;

    hr = HrInitializeSsdpRequestFromMessage(&m_ssdpRequest, pssdpMsg);
    if(SUCCEEDED(hr))
    {
        m_nLifetime = pssdpMsg->iLifeTime;
        m_nRetryCount = 3;
        m_dwFlags = dwFlags;
        m_ppContextHandle = ppContextHandle;
        *m_ppContextHandle = NULL;
        m_ssdpRequest.RequestUri = MulticastUri;

        OSVERSIONINFO   osvi = {0};

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if(!GetVersionEx(&osvi))
        {
            hr = HrFromLastWin32Error();
        }
        if(SUCCEEDED(hr))
        {
            // Yes this is a constant but it is just used temporarily
            m_ssdpRequest.Headers[SSDP_SERVER] = "Microsoft-Windows-NT/5.1 UPnP/1.0 UPnP-Device-Host/1.0";
            char * szAlive = NULL;
            if(SUCCEEDED(hr))
            {
                m_ssdpRequest.Headers[SSDP_NTS] = AliveHeader;
                if (!ComposeSsdpRequest(&m_ssdpRequest, &szAlive))
                {
                    hr = E_FAIL;
                    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::HrInitialize - ComposeSsdpRequest failed!");
                }
                else
                {
                    hr = m_strAlive.HrAssign(szAlive);
                    delete [] szAlive;
                }
            }

            if(SUCCEEDED(hr))
            {
                char * szByebye = NULL;
                if(SUCCEEDED(hr))
                {
                    m_ssdpRequest.Headers[SSDP_NTS] = ByebyeHeader;
                    if(!ComposeSsdpRequest(&m_ssdpRequest, &szByebye))
                    {
                        hr = E_FAIL;
                        TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::HrInitialize - ComposeSsdpRequest failed!");
                    }
                    else
                    {
                        hr = m_strByebye.HrAssign(szByebye);
                        delete [] szByebye;
                    }
                }
            }

            if(SUCCEEDED(hr))
            {
                // Generate an empty Ext header on the response to M-SEARCH
                m_ssdpRequest.Headers[SSDP_EXT] = "";
                char * szResponse = NULL;

                if (!ComposeSsdpResponse(&m_ssdpRequest, &szResponse))
                {
                    hr = E_FAIL;
                    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::HrInitialize - ComposeSsdpResponse failed!");
                }
                else
                {
                    hr = m_strResponse.HrAssign(szResponse);
                    delete [] szResponse;
                }
            }
        }
    }

    // Important: Set to NULL to prevent freeing memory.
    m_ssdpRequest.Headers[SSDP_NTS] = NULL;
    m_ssdpRequest.RequestUri = NULL;
    // Important: Set to NULL to prevent freeing memory.
    m_ssdpRequest.Headers[SSDP_EXT] = NULL;
    m_ssdpRequest.Headers[SSDP_SERVER] = NULL;


    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::HrInitialize");
    return hr;
}
HRESULT CSsdpService::HrStartTimer()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    hr = m_timer.HrSetTimer(0);
    if(SUCCEEDED(hr))
    {
        *m_ppContextHandle = this;
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::HrStartTimer");
    return hr;
}

long CalcMX (SSDP_REQUEST * pSsdpRequest)
{
    LONG                lMin, lMX;

#define MINIMUM_MX_UUID                 1
#define MINIMUM_MX_DST                  2
#define MINIMUM_MX_ROOT                 3
#define MAXIMUM_MX              12
#define UUID_COLON "uuid:"
#define URN_SERVICE "urn:schemas-upnp-org:service:"
#define URN_DEVICE  "urn:schemas-upnp-org:device:"

    Assert (pSsdpRequest != NULL);
    if (strncmp (pSsdpRequest->Headers[SSDP_ST], UUID_COLON, sizeof(UUID_COLON) - 1) == 0)
        lMin = MINIMUM_MX_UUID;
    else if (strcmp(pSsdpRequest->Headers[SSDP_ST], "upnp:rootdevice") == 0)
        lMin = MINIMUM_MX_ROOT;
    else if (strcmp(pSsdpRequest->Headers[SSDP_ST], "ssdp:all") == 0)
        lMin = MINIMUM_MX_ROOT;
    else if (
        strncmp (pSsdpRequest->Headers[SSDP_ST], URN_SERVICE, sizeof(URN_SERVICE) - 1) == 0 ||
        strncmp (pSsdpRequest->Headers[SSDP_ST], URN_DEVICE, sizeof(URN_DEVICE) - 1) == 0 )
        lMin = MINIMUM_MX_DST;
    else
        lMin = MINIMUM_MX_UUID;
    lMX = atol(pSsdpRequest->Headers[SSDP_MX]);
    if (lMX > MAXIMUM_MX) lMX = MAXIMUM_MX;
    else if (lMX < lMin) lMX = lMin;
    return lMX;
}

HRESULT CSsdpService::HrAddSearchResponse(SSDP_REQUEST * pSsdpRequest,
                                          SOCKET * pSocket,
                                          SOCKADDR_IN * pRemoteSocket)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    BOOL bSendRequest = FALSE;

    if(pSsdpRequest->Headers[SSDP_ST])
    {
        if(0 == lstrcmpA(pSsdpRequest->Headers[SSDP_ST], "ssdp:all"))
        {
            bSendRequest = TRUE;
        }
        if(!bSendRequest && 0 == lstrcmpA(pSsdpRequest->Headers[SSDP_ST], m_ssdpRequest.Headers[SSDP_NT]))
        {
            bSendRequest = TRUE;
        }
    }

    if(bSendRequest)
    {
        TraceTag(ttidSsdpAnnounce, "Adding search response for %s", m_ssdpRequest.Headers[SSDP_NT]);

        char * szResponse = NULL;
        hr = m_strResponse.HrGetMultiByteWithAlloc(&szResponse);
        if(SUCCEEDED(hr))
        {
            // Takes ownership of string
            hr = CSsdpSearchResponse::HrCreate(pSocket, pRemoteSocket,
                                               szResponse,
                                               CalcMX(pSsdpRequest));
        }
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::HrAddSearchResponse");
    return hr;
}

class CSsdpByebye : public CWorkItem
{
public:
    static HRESULT Create(char * szByebye);

    void TimerFired();
    BOOL TimerTryToLock()
    {
        return m_critSec.FTryEnter();
    }
    void TimerUnlock()
    {
        m_critSec.Leave();
    }
private:
    CSsdpByebye(char * szByebye);
    ~CSsdpByebye();
    CSsdpByebye(const CSsdpByebye &);
    CSsdpByebye & operator=(const CSsdpByebye &);

    DWORD DwRun();

    char * m_szByebye;
    long m_nRetryCount;
    CTimer<CSsdpByebye> m_timer;
    CUCriticalSection m_critSec;
};

CSsdpByebye::CSsdpByebye(char * szByebye)
: m_szByebye(szByebye), m_nRetryCount(3), m_timer(*this)
{
}

CSsdpByebye::~CSsdpByebye()
{
    delete [] m_szByebye;
}

HRESULT CSsdpByebye::Create(char * szByebye)
{
    HRESULT hr = S_OK;

    CSsdpByebye * pByebye = new CSsdpByebye(szByebye);
    if(!pByebye)
    {
        hr = E_OUTOFMEMORY;
        delete [] szByebye;
    }
    if(SUCCEEDED(hr))
    {
        hr = pByebye->m_timer.HrSetTimer(0);
        if(FAILED(hr))
        {
            delete pByebye;
        }
    }
    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpByebye::Create");
    return hr;
}

void CSsdpByebye::TimerFired()
{
    HRESULT hr = S_OK;

    GetNetworkLock();

    SendOnAllNetworks(m_szByebye, NULL);

    FreeNetworkLock();

    --m_nRetryCount;

    // We do this three times and then we kill ourselves
    if(0 == m_nRetryCount)
    {
        // This will queue ourselves to autodelete
        HrStart(true);
    }
    else
    {
        hr = m_timer.HrSetTimerInFired(RETRY_INTERVAL);
        if(FAILED(hr))
        {
            // This will queue ourselves to autodelete
            HrStart(true);
        }
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpByebye::TimerFired");
}

DWORD CSsdpByebye::DwRun()
{
    // Wait for timer to exit before allowing this function to return (which causes delete this to happen)
    CLock lock(m_critSec);
    m_timer.HrDelete(INVALID_HANDLE_VALUE);
    return 0;
}

HRESULT CSsdpService::HrCleanup(BOOL bByebye)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);
    hr = m_timer.HrDelete(INVALID_HANDLE_VALUE);

    if(SUCCEEDED(hr))
    {
        if(bByebye)
        {
            char * szByebye = NULL;
            hr = m_strByebye.HrGetMultiByteWithAlloc(&szByebye);
            if(SUCCEEDED(hr))
            {
                // This takes ownership of memory
                CSsdpByebye::Create(szByebye);
            }
        }
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpService::HrCleanup");
    return hr;
}

BOOL CSsdpService::FIsPersistent()
{
    return (SSDP_SERVICE_PERSISTENT & m_dwFlags) != 0;
}

CSsdpServiceManager CSsdpServiceManager::s_instance;

CSsdpServiceManager::CSsdpServiceManager()
{
}

CSsdpServiceManager::~CSsdpServiceManager()
{
}

CSsdpServiceManager & CSsdpServiceManager::Instance()
{
    return s_instance;
}

HRESULT CSsdpServiceManager::HrAddService(
    SSDP_MESSAGE * pssdpMsg,
    DWORD dwFlags,
    PCONTEXT_HANDLE_TYPE * ppContextHandle)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    if(pssdpMsg && FindServiceByUsn(pssdpMsg->szUSN))
    {
        hr = E_INVALIDARG;
        TraceTag(ttidSsdpAnnounce, "CSsdpServiceManager::HrAddService - attempting to add duplicate USN");
    }

    CSsdpService * pService = NULL;

    if(SUCCEEDED(hr))
    {
        ServiceList serviceList;
        hr = serviceList.HrPushFrontDefault();
        if(SUCCEEDED(hr))
        {
            hr = serviceList.Front().HrInitialize(pssdpMsg, dwFlags, ppContextHandle);
            if(SUCCEEDED(hr))
            {
                hr = serviceList.Front().HrStartTimer();
                if(SUCCEEDED(hr))
                {
                    m_serviceList.Prepend(serviceList);
                    pService = &m_serviceList.Front();
                }
            }
        }
    }

    if(pService)
    {
        hr = CSsdpRundownSupport::Instance().HrAddRundownItem(pService);
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpServiceManager::HrAddService");
    return hr;
}

CSsdpService * CSsdpServiceManager::FindServiceByUsn(char * szUSN)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    CSsdpService * pService = NULL;

    ServiceList::Iterator iter;
    if(S_OK == m_serviceList.GetIterator(iter))
    {
        CSsdpService * pServiceIter = NULL;
        while(S_OK == iter.HrGetItem(&pServiceIter))
        {
            if(pServiceIter->FIsUsn(szUSN))
            {
                pService = pServiceIter;
                break;
            }
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }
    if(!pService)
    {
        TraceTag(ttidSsdpAnnounce, "CSsdpServiceManager::FindServiceByUsn(%s) - not found!", szUSN);
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpServiceManager::FindServiceByUsn");
    return pService;
}

HRESULT CSsdpServiceManager::HrAddSearchResponse(SSDP_REQUEST * pSsdpRequest,
                                                 SOCKET * pSocket,
                                                 SOCKADDR_IN * pRemoteSocket)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    ServiceList::Iterator iter;
    if(S_OK == m_serviceList.GetIterator(iter))
    {
        CSsdpService * pService = NULL;
        while(S_OK == iter.HrGetItem(&pService))
        {
            pService->HrAddSearchResponse(pSsdpRequest, pSocket, pRemoteSocket);

            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpServiceManager::HrAddSearchResponse");
    return hr;
}

HRESULT CSsdpServiceManager::HrRemoveService(CSsdpService * pService, BOOL bByebye)
{
    HRESULT hr = S_OK;

    hr = HrRemoveServiceInternal(pService, bByebye, FALSE);

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpServiceManager::HrRemoveService");
    return hr;
}

HRESULT CSsdpServiceManager::HrServiceRundown(CSsdpService * pService)
{
    HRESULT hr = S_OK;

    hr = HrRemoveServiceInternal(pService, TRUE, TRUE);

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpServiceManager::HrCleanupAnouncements");
    return hr;
}

HRESULT CSsdpServiceManager::HrCleanupAnouncements()
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    // TODO: Implement this!!!!!!!!!!!!!!!!!!!!!!

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpServiceManager::HrCleanupAnouncements");
    return hr;
}

HRESULT CSsdpServiceManager::HrRemoveServiceInternal(CSsdpService * pService, BOOL bByebye, BOOL bRundown)
{
    HRESULT hr = S_OK;

    BOOL bFound = FALSE;

    ServiceList serviceList;

    {
        CLock lock(m_critSec);

        ServiceList::Iterator iter;
        if(S_OK == m_serviceList.GetIterator(iter))
        {
            CSsdpService * pServiceIter = NULL;
            while(S_OK == iter.HrGetItem(&pServiceIter))
            {
                if(pServiceIter == pService)
                {
                    if(!bRundown || !pService->FIsPersistent())
                    {
                        iter.HrMoveToList(serviceList);
                        bFound = TRUE;
                    }
                    break;
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    if(bFound)
    {
        ServiceList::Iterator iter;
        if(S_OK == serviceList.GetIterator(iter))
        {
            CSsdpService * pServiceIter = NULL;
            while(S_OK == iter.HrGetItem(&pServiceIter))
            {
                if(!bRundown)
                {
                    CSsdpRundownSupport::Instance().RemoveRundownItem(pServiceIter);
                }
                hr = pServiceIter->HrCleanup(bByebye);
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "CSsdpServiceManager::HrRemoveServiceInternal");
    return hr;
}

HRESULT HrInitializeSsdpRequestFromMessage(
    SSDP_REQUEST * pRequest,
    const SSDP_MESSAGE *pMsg)
{
    HRESULT hr = S_OK;

    ZeroMemory(pRequest, sizeof(*pRequest));

    pRequest->Method = SSDP_NOTIFY;

    pRequest->Headers[SSDP_HOST] = reinterpret_cast<char*>(
        midl_user_allocate(sizeof(CHAR) * (
            lstrlenA(SSDP_ADDR) +
            1 + // colon
            6 + // port number
            1)));
    if (!pRequest->Headers[SSDP_HOST])
    {
        hr = E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        wsprintfA(pRequest->Headers[SSDP_HOST], "%s:%d", SSDP_ADDR, SSDP_PORT);

        hr = HrCopyString(pMsg->szType, &pRequest->Headers[SSDP_NT]);
        if(SUCCEEDED(hr) || !pMsg->szType)
        {
            hr = HrCopyString(pMsg->szUSN, &pRequest->Headers[SSDP_USN]);
            if(SUCCEEDED(hr) || !pMsg->szUSN)
            {
                hr = HrCopyString(pMsg->szAltHeaders, &pRequest->Headers[SSDP_AL]);
                if(SUCCEEDED(hr) || !pMsg->szAltHeaders)
                {
                    hr = HrCopyString(pMsg->szLocHeader, &pRequest->Headers[SSDP_LOCATION]);
                    if(SUCCEEDED(hr) || pMsg->szLocHeader)
                    {
                        char szBuf[256];
                        wsprintfA(szBuf, "max-age=%d", pMsg->iLifeTime);
                        hr = HrCopyString(szBuf, &pRequest->Headers[SSDP_CACHECONTROL]);
                    }
                }
            }
        }
    }

    if(FAILED(hr))
    {
        FreeSsdpRequest(pRequest);
        ZeroMemory(pRequest, sizeof(*pRequest));
    }

    TraceHr(ttidSsdpAnnounce, FAL, hr, FALSE, "HrInitializeSsdpRequestFromMessage");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\cache.cpp ===
#include <pch.h>
#pragma hdrstop

#include <limits.h>
#include "ssdpfunc.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#include "cache.h"
#include "upthread.h"
#include "notify.h"

#define BUF_SIZE 100
#define CACHE_RESULT_SIZE 2

static const int g_cMaxCacheDefault = 1000;	    // default max size of SSDP cache
static const int g_cMaxCacheMin = 10;           // min allowed max size of SSDP cache
static const int g_cMaxCacheMax = 30000;        // max allowed max size of SSDP cache

CSsdpCacheEntry::CSsdpCacheEntry() : m_timer(*this), m_bTimerFired(FALSE)
{
    ZeroMemory(&m_ssdpRequest, sizeof(m_ssdpRequest));
}

CSsdpCacheEntry::~CSsdpCacheEntry()
{
    FreeSsdpRequest(&m_ssdpRequest);
}

class CSsdpCacheEntryByebye : public CWorkItem
{
public:
    static HRESULT HrCreate(CSsdpCacheEntry * pEntry);
private:
    CSsdpCacheEntryByebye(CSsdpCacheEntry * pEntry);
    ~CSsdpCacheEntryByebye();
    CSsdpCacheEntryByebye(const CSsdpCacheEntryByebye &);
    CSsdpCacheEntryByebye & operator=(const CSsdpCacheEntryByebye &);

    DWORD DwRun();

    CSsdpCacheEntry * m_pEntry;
};

CSsdpCacheEntryByebye::CSsdpCacheEntryByebye(CSsdpCacheEntry * pEntry)
: m_pEntry(pEntry)
{
}

CSsdpCacheEntryByebye::~CSsdpCacheEntryByebye()
{
}

HRESULT CSsdpCacheEntryByebye::HrCreate(CSsdpCacheEntry * pEntry)
{
    HRESULT hr = S_OK;

    CSsdpCacheEntryByebye * pByebye = new CSsdpCacheEntryByebye(pEntry);
    if(!pByebye)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pByebye->HrStart(TRUE);
        if(FAILED(hr))
        {
            delete pByebye;
        }
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryByebye::HrCreate");
    return hr;
}

DWORD CSsdpCacheEntryByebye::DwRun()
{
    HRESULT hr = S_OK;

    hr = CSsdpCacheEntryManager::Instance().HrRemoveEntry(m_pEntry);

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryByebye::DwRun");
    return 0;
}


void CSsdpCacheEntry::TimerFired()
{
    HRESULT hr = S_OK;

    if(!ConvertToByebyeNotify(&m_ssdpRequest))
    {
        hr = E_FAIL;
        TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::TimerFired - ConvertToByebyeNotify failed!");
    }

    // Mark that the timer has fired in case a renew comes in
    m_bTimerFired = TRUE;

    if(SUCCEEDED(hr))
    {
        // Queue the delete to happen later
        hr = CSsdpCacheEntryByebye::HrCreate(this);
    }
}

BOOL CSsdpCacheEntry::TimerTryToLock()
{
    return m_critSec.FTryEnter();
}

void CSsdpCacheEntry::TimerUnlock()
{
    m_critSec.Leave();
}

HRESULT CSsdpCacheEntry::HrInitialize(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;

    if(!CopySsdpRequest(&m_ssdpRequest, pRequest))
    {
        hr = E_FAIL;
        TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrInitialize - CopySsdpRequest failed!");
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrInitialize");
    return hr;
}

HRESULT CSsdpCacheEntry::HrStartTimer(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;

    hr = HrUpdateExpireTime(pRequest);

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrStartTimer");
    return hr;
}

BOOL CSsdpCacheEntry::FTimerFired()
{
    CLock lock(m_critSec);
    return m_bTimerFired;
}

HRESULT CSsdpCacheEntry::HrShutdown(BOOL bExpired)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    Assert(FImplies(bExpired, m_bTimerFired));
    hr = m_timer.HrDelete(INVALID_HANDLE_VALUE);
    if(bExpired)
    {
        hr = CSsdpNotifyRequestManager::Instance().HrCheckListNotifyForAliveOrByebye(&m_ssdpRequest);
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrShutdown");
    return hr;
}

HRESULT CSsdpCacheEntry::HrUpdateExpireTime(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    if(!pRequest->Headers[SSDP_CACHECONTROL])
    {
        hr = E_INVALIDARG;
        TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrUpdateExpireTime - No cache-control header");
    }
    if(SUCCEEDED(hr))
    {
        DWORD dwTimeout = GetMaxAgeFromCacheControl(pRequest->Headers[SSDP_CACHECONTROL]);

        hr = m_timer.HrResetTimer(dwTimeout * 1000);

        m_bTimerFired = FALSE;
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrUpdateExpireTime");
    return hr;
}

HRESULT CSsdpCacheEntry::HrUpdateEntry(const SSDP_REQUEST * pRequest, BOOL * pbCheckListNotify)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    hr = HrUpdateExpireTime(pRequest);
    if(S_OK == hr)
    {
        if(!CompareSsdpRequest(&m_ssdpRequest, pRequest))
        {
            *pbCheckListNotify = TRUE;

            // Requests don't match. Check location headers. If different,
            // then we need to fake a byebye then allow the new alive to be
            // notified

            if (lstrcmpi(m_ssdpRequest.Headers[SSDP_LOCATION],
                         pRequest->Headers[SSDP_LOCATION]))
            {
                if(!ConvertToByebyeNotify(&m_ssdpRequest))
                {
                    hr = E_FAIL;
                    TraceHr(ttidSsdpCache, FAL, hr, FALSE,
                            "CSsdpCacheEntry::HrUpdateEntry - "
                            "ConvertToByebyeNotify failed!");
                }
                else
                {
                    hr = CSsdpNotifyRequestManager::Instance().HrCheckListNotifyForAliveOrByebye(&m_ssdpRequest);
                }
            }
        }
        FreeSsdpRequest(&m_ssdpRequest);
        if(!CopySsdpRequest(&m_ssdpRequest, pRequest))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrUpdateEntry");
    return hr;
}

BOOL CSsdpCacheEntry::FIsMatchUSN(const char * szUSN)
{
    CLock lock(m_critSec);
    return 0 == lstrcmpA(m_ssdpRequest.Headers[SSDP_USN], szUSN);
}

BOOL CSsdpCacheEntry::FIsSearchMatch(const char * szType)
{
    CLock lock(m_critSec);
    if(0 == lstrcmpiA(szType, "ssdp:all"))
    {
        return TRUE;
    }
    if(m_ssdpRequest.Headers[SSDP_NT] &&
       0 == lstrcmpiA(m_ssdpRequest.Headers[SSDP_NT], szType))
    {
        return TRUE;
    }
    if(m_ssdpRequest.Headers[SSDP_ST] &&
       0 == lstrcmpiA(m_ssdpRequest.Headers[SSDP_ST], szType))
    {
        return TRUE;
    }
    return FALSE;
}

HRESULT CSsdpCacheEntry::HrGetRequest(SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    if(!CopySsdpRequest(pRequest, &m_ssdpRequest))
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::HrCacheEntryExpired");
    return hr;
}

void CSsdpCacheEntry::PrintItem()
{
    TraceTag(ttidSsdpCache, "  %s - %s - %s", 
             m_ssdpRequest.Headers[SSDP_USN],
             m_ssdpRequest.Headers[SSDP_NT],
             m_ssdpRequest.Headers[SSDP_LOCATION]);
}

BOOL CSsdpCacheEntry::FCheckForDirtyInterfaceGuids(long nCount, GUID * arGuidInterfaces)
{
    BOOL bDirty = FALSE;

    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    for(long n = 0; n < nCount; ++n)
    {
        if(arGuidInterfaces[n] == m_ssdpRequest.guidInterface)
        {
            bDirty = TRUE;

            if(ConvertToByebyeNotify(&m_ssdpRequest))
            {
                hr = CSsdpNotifyRequestManager::Instance().HrCheckListNotifyForAliveOrByebye(&m_ssdpRequest);
            }
            else
            {
                TraceTag(ttidError, "CSsdpCacheEntry::FCheckForDirtyInterfaceGuids - ConvertToByebyeNotify failed");
            }

            break;
        }
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntry::FCheckForDirtyInterfaceGuids");
    return bDirty;
}

CSsdpCacheEntryManager CSsdpCacheEntryManager::s_instance;

CSsdpCacheEntryManager::CSsdpCacheEntryManager():m_cCacheEntries(0), m_cMaxCacheEntries(1000)
{
}

CSsdpCacheEntryManager::~CSsdpCacheEntryManager()
{
}

HRESULT CSsdpCacheEntryManager::HrInitialize()
{
    HRESULT hr = S_OK;

    HKEY    hkey;
    DWORD   dwMaxCache = g_cMaxCacheDefault;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      "SYSTEM\\CurrentControlSet\\Services"
                                      "\\SSDPSRV\\Parameters", 0,
                                      KEY_READ, &hkey))
    {
        DWORD   cbSize = sizeof(DWORD);

        // ignore failure. In that case, we'll use default
        (VOID) RegQueryValueEx(hkey, "MaxCache", NULL, NULL, (BYTE *)&dwMaxCache, &cbSize);

        RegCloseKey(hkey);
    }

    dwMaxCache = max(dwMaxCache, g_cMaxCacheMin);
    dwMaxCache = min(dwMaxCache, g_cMaxCacheMax);
    m_cMaxCacheEntries = dwMaxCache;

    m_cCacheEntries = 0;

    TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrInitialize - Max Cache %d",m_cMaxCacheEntries);

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryManager::HrInitialize");
    return hr;
    
}

CSsdpCacheEntryManager & CSsdpCacheEntryManager::Instance()
{
    return s_instance;
}

BOOL CSsdpCacheEntryManager::IsCacheListNotFull()
{  
    CLock lock(m_critSec);

    if (m_cCacheEntries < m_cMaxCacheEntries)
		return TRUE;
	else
		return FALSE;    
}

HRESULT CSsdpCacheEntryManager::HrShutdown()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    CacheEntryList::Iterator iter;
    if(S_OK == m_cacheEntryList.GetIterator(iter))
    {
        CSsdpCacheEntry * pEntryIter = NULL;
        while(S_OK == iter.HrGetItem(&pEntryIter))
        {
            hr = pEntryIter->HrShutdown(FALSE);
            if(S_OK != iter.HrErase())
            {
                break;
            }
        }
    }
    
    m_cCacheEntries = 0;
    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryManager::HrShutdown");
    return hr;
}

HRESULT CSsdpCacheEntryManager::HrRemoveEntry(CSsdpCacheEntry * pEntry)
{
    HRESULT hr = S_OK;

    CacheEntryList cacheEntryListRemove;

    {
        CLock lock(m_critSec);
        CacheEntryList::Iterator iter;
        if(S_OK == m_cacheEntryList.GetIterator(iter))
        {
            CSsdpCacheEntry * pEntryIter = NULL;
            while(S_OK == iter.HrGetItem(&pEntryIter))
            {
                if(pEntryIter == pEntry)
                {
                    if(pEntry->FTimerFired())
                    {
                        iter.HrMoveToList(cacheEntryListRemove);
                        m_cCacheEntries--;
                        TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrRemoveEntry - Cache Entries %d", m_cCacheEntries);
                    }
                    break;
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    // Remove outside of lock
    CacheEntryList::Iterator iter;
    if(S_OK == cacheEntryListRemove.GetIterator(iter))
    {
        CSsdpCacheEntry * pEntryIter = NULL;
        while(S_OK == iter.HrGetItem(&pEntryIter))
        {
            hr = pEntryIter->HrShutdown(TRUE);
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryManager::HrRemoveEntry");
    return hr;
}

#ifdef DBG
#define CACHECONTENTTRACE DBG
#endif // DBG

HRESULT CSsdpCacheEntryManager::HrUpdateCacheList(const SSDP_REQUEST * pRequest, BOOL bIsSubscribed)
{
    HRESULT hr = S_OK;

    BOOL bIsByebye = FALSE;
    BOOL bFound = FALSE;

    // Debugging only
#if CACHECONTENTTRACE
    BOOL bAdded = FALSE;
    BOOL bRemoved = FALSE;
#endif //CACHECONTENTTRACE

    BOOL bCheckListNotify = FALSE;

    CacheEntryList cacheEntryListRemove;

    if(pRequest->Headers[SSDP_NTS] &&
       0 == lstrcmpA(pRequest->Headers[SSDP_NTS], "ssdp:byebye"))
    {
        bIsByebye = TRUE;
    }

    if(!bIsByebye && !pRequest->Headers[SSDP_CACHECONTROL])
    {
        // Not cacheable
        hr = S_FALSE;

        if(S_OK == hr)
        {
            if(!bIsByebye && !pRequest->Headers[SSDP_SERVER])
            {
                // No server header
                hr = S_FALSE;
            }
        }
    }

    {
        CLock lock(m_critSec);
        if(S_OK == hr)
        {
            CacheEntryList::Iterator iter;
            if(S_OK == m_cacheEntryList.GetIterator(iter))
            {
                CSsdpCacheEntry * pEntryIter = NULL;
                while(S_OK == iter.HrGetItem(&pEntryIter))
                {
                    if(pEntryIter->FIsMatchUSN(pRequest->Headers[SSDP_USN]))
                    {
                        bFound = TRUE;

                        if(bIsByebye)
                        {
                            bCheckListNotify = TRUE;
                            iter.HrMoveToList(cacheEntryListRemove);
                            m_cCacheEntries--;
                            TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrUpdateCacheList - Bye Bye - Cache Entries %d", m_cCacheEntries);
#if CACHECONTENTTRACE
                            bRemoved = TRUE;
#endif //CACHECONTENTTRACE
                        }
                        else
                        {
                            hr = pEntryIter->HrUpdateEntry(pRequest, &bCheckListNotify);
                        }

                        break;
                    }
                    if(S_OK != iter.HrNext())
                    {
                        break;
                    }
                }
            }
        }

        if(S_OK == hr && !bFound && ! bIsByebye && bIsSubscribed)
        {
            if(IsCacheListNotFull())
            {
                CacheEntryList cacheEntryList;
                hr = cacheEntryList.HrPushFrontDefault();
                if(SUCCEEDED(hr))
                {
                    hr = cacheEntryList.Front().HrInitialize(pRequest);
                    if(SUCCEEDED(hr))
                    {
                        bCheckListNotify = TRUE;
                        hr = cacheEntryList.Front().HrStartTimer(pRequest);
                        if(SUCCEEDED(hr))
                        {
                            m_cacheEntryList.Prepend(cacheEntryList);
                            m_cCacheEntries++;
                            TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrUpdateCacheList - Cache Entries %d", m_cCacheEntries);
#if CACHECONTENTTRACE
                            bAdded = TRUE;
#endif //CACHECONTENTTRACE
                        }
                    }
                }
            }
            else
            {
                TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrUpdateCacheList - Cache Entries Reached MAX");    
            }
        }

#if CACHECONTENTTRACE
        if(bAdded || bRemoved)
        {
            TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrUpdateCacheList - Cache Contents");
            long nCount = 0;

            CacheEntryList::Iterator iter;
            if(S_OK == m_cacheEntryList.GetIterator(iter))
            {
                CSsdpCacheEntry * pEntryIter = NULL;
                while(S_OK == iter.HrGetItem(&pEntryIter))
                {
                    pEntryIter->PrintItem();
                    ++nCount;

                    if(S_OK != iter.HrNext())
                    {
                        break;
                    }
                }
            }           
        
            TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrUpdateCacheList - Cache Content Count: %d", nCount);
            if(bAdded)
            {
                TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrUpdateCacheList - Added: %s", pRequest->Headers[SSDP_USN]);
            }
            if(bRemoved)
            {
                TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrUpdateCacheList - Removed: %s", pRequest->Headers[SSDP_USN]);
            }
        }
#endif // CACHECONTENTTRACE
    }

    if(bCheckListNotify)
    {
        CSsdpNotifyRequestManager::Instance().HrCheckListNotifyForAliveOrByebye(pRequest);
    }

    // Remove outside of lock
    CacheEntryList::Iterator iter;
    if(S_OK == cacheEntryListRemove.GetIterator(iter))
    {
        CSsdpCacheEntry * pEntryIter = NULL;
        while(S_OK == iter.HrGetItem(&pEntryIter))
        {
            hr = pEntryIter->HrShutdown(FALSE);
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryManager::HrUpdateCacheList");
    return hr;
}

HRESULT CSsdpCacheEntryManager::HrSearchListCache(char * szType, MessageList ** ppSvcList)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    *ppSvcList = NULL;

    typedef CUList<SSDP_REQUEST> RequestList;
    RequestList requestList;
    SSDP_REQUEST ssdpRequest;
    long nItems = 0;

    CacheEntryList::Iterator iter;
    if(S_OK == m_cacheEntryList.GetIterator(iter))
    {
        CSsdpCacheEntry * pEntryIter = NULL;
        while(S_OK == iter.HrGetItem(&pEntryIter))
        {
            if(pEntryIter->FIsSearchMatch(szType))
            {
                hr = pEntryIter->HrGetRequest(&ssdpRequest);
                if(SUCCEEDED(hr))
                {
                    hr = requestList.HrPushFront(ssdpRequest);
                    if(SUCCEEDED(hr))
                    {
                        ++nItems;
                    }
                    if(FAILED(hr))
                    {
                        FreeSsdpRequest(&ssdpRequest);
                    }
                }
                if(FAILED(hr))
                {
                    break;
                }
            }
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        MessageList * pSvcList = new MessageList;
        if(!pSvcList)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            if(nItems)
            {
                pSvcList->list = new SSDP_REQUEST[nItems];
                if(!pSvcList->list)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    ZeroMemory(pSvcList->list, sizeof(SSDP_REQUEST) * nItems);
                }
            }
            else
            {
                pSvcList->list = NULL;
            }
            pSvcList->size = nItems;
            if(SUCCEEDED(hr))
            {
                RequestList::Iterator iter;
                if(S_OK == requestList.GetIterator(iter))
                {
                    SSDP_REQUEST * pRequestDst = pSvcList->list;
                    SSDP_REQUEST * pRequest = NULL;
                    while(S_OK == iter.HrGetItem(&pRequest))
                    {
                        CopyMemory(pRequestDst, pRequest, sizeof(SSDP_REQUEST));
                        ++pRequestDst;
                        if(S_OK != iter.HrNext())
                        {
                            break;
                        }
                    }
                }
                *ppSvcList = pSvcList;
            }
        }
    }

    if(FAILED(hr))
    {
        RequestList::Iterator iter;
        if(S_OK == requestList.GetIterator(iter))
        {
            SSDP_REQUEST * pRequest = NULL;
            while(S_OK == iter.HrGetItem(&pRequest))
            {
                FreeSsdpRequest(pRequest);
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryManager::HrSearchListCache");
    return hr;
}

HRESULT CSsdpCacheEntryManager::HrClearDirtyInterfaceGuids(long nCount, GUID * arGuidInterfaces)
{
    HRESULT hr = S_OK;

    CacheEntryList cacheEntryListRemove;

    {
        CLock lock(m_critSec);
        CacheEntryList::Iterator iter;
        if(S_OK == m_cacheEntryList.GetIterator(iter))
        {
            CSsdpCacheEntry * pEntryIter = NULL;
            while(S_OK == iter.HrGetItem(&pEntryIter))
            {
                if(pEntryIter->FCheckForDirtyInterfaceGuids(nCount, arGuidInterfaces))
                {
                    m_cCacheEntries--;
                    TraceTag(ttidSsdpCache, "CSsdpCacheEntryManager::HrClearDirtyInterfaceGuids - Cache Entries %d", m_cCacheEntries);
                    if(S_OK != iter.HrMoveToList(cacheEntryListRemove))
                    {
                        break;
                    }
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    // Remove outside of lock
    CacheEntryList::Iterator iter;
    if(S_OK == cacheEntryListRemove.GetIterator(iter))
    {
        CSsdpCacheEntry * pEntryIter = NULL;
        while(S_OK == iter.HrGetItem(&pEntryIter))
        {
            hr = pEntryIter->HrShutdown(FALSE);
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidSsdpCache, FAL, hr, FALSE, "CSsdpCacheEntryManager::HrClearDirtyInterfaceGuids");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\interfacehelper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E H E L P E R . H 
//
//  Contents:   Manages dealing with multiple interfaces and interface changes
//
//  Notes:      
//
//  Author:     mbend   6 Feb 2001
//
//----------------------------------------------------------------------------

#pragma once

#include "upsync.h"
#include "ulist.h"
#include "InterfaceList.h"

class CInterfaceHelper : public CUPnPInterfaceChange
{
public:
    ~CInterfaceHelper();

    static CInterfaceHelper & Instance();

    void OnInterfaceChange(const InterfaceMappingList & interfaceMappingList);

    HRESULT HrInitialize();
    HRESULT HrShutdown();

    HRESULT HrResolveAddress(DWORD dwIpAddress, GUID & guidInterface);
private:
    CInterfaceHelper();
    CInterfaceHelper(const CInterfaceHelper &);
    CInterfaceHelper & operator=(const CInterfaceHelper &);

    static CInterfaceHelper s_instance;

    HRESULT HrGenerateDirtyGuidList(
        const InterfaceMappingList & interfaceMappingListOld,
        const InterfaceMappingList & interfaceMappingListNew,
        InterfaceList & interfaceList);

    CUCriticalSection m_critSec;
    InterfaceMappingList m_interfaceMappingList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\notify.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       N O T I F Y . H 
//
//  Contents:   SSDP client notification support
//
//  Notes:      
//
//  Author:     mbend   12 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "ulist.h"
#include "upsync.h"
#include "ustring.h"
#include "timer.h"
#include "ssdptypes.h"

class CSsdpPendingNotification
{
public:
    CSsdpPendingNotification();
    ~CSsdpPendingNotification();

    HRESULT HrInitialize(const SSDP_REQUEST * pRequest);
    HRESULT HrGetRequest(SSDP_REQUEST * pRequest);
private:
    CSsdpPendingNotification(const CSsdpPendingNotification &);
    CSsdpPendingNotification & operator=(const CSsdpPendingNotification &);

    SSDP_REQUEST m_ssdpRequest;
};

class CSsdpNotifyRequest
{
public:
    CSsdpNotifyRequest();
    ~CSsdpNotifyRequest();

    // RPC rundown support
    static void OnRundown(CSsdpNotifyRequest * pNotify);

    // Timer callback methods
    void TimerFired();
    BOOL TimerTryToLock();
    void TimerUnlock();

    HRESULT HrRestartClientResubscribeTimer(
        DWORD dwSecTimeout);
    HRESULT HrInitializeAlive(
        const char * szNT,
        HANDLE hNotifySemaphore);
    HRESULT HrInitializePropChange(
        const char * szUrl,
        HANDLE hNotifySemaphore);
    HRESULT HrSendPropChangeSubscription(SSDP_REGISTER_INFO ** ppRegisterInfo);
    HRESULT HrShutdown();
    BOOL FIsMatchBySemaphore(HANDLE hNotifySemaphore);
    BOOL FIsMatchingEvent(const SSDP_REQUEST * pRequest);
    BOOL FIsMatchingAliveOrByebye(const SSDP_REQUEST * pRequest);
    HRESULT HrQueuePendingNotification(const SSDP_REQUEST * pRequest);
    BOOL FIsPendingNotification();
    HRESULT HrRetreivePendingNotification(MessageList ** ppSvcList);
private:
    CSsdpNotifyRequest(const CSsdpNotifyRequest &);
    CSsdpNotifyRequest & operator=(const CSsdpNotifyRequest &);

    typedef CUList<CSsdpPendingNotification> PendingNotificationList;

    NOTIFY_TYPE m_nt;
    CUCriticalSection m_critSec;
    CUString    m_strNT;
    CUString    m_strUrl;
    DWORD       m_dwSecTimeout;
    CUString    m_strSid;
    CTimer<CSsdpNotifyRequest> m_timer;
    HANDLE      m_hNotifySemaphore;

    PendingNotificationList m_pendingNotificationList;
};

class CSsdpNotifyRequestManager
{
public:
    ~CSsdpNotifyRequestManager();

    static CSsdpNotifyRequestManager & Instance();

    void OnRundown(CSsdpNotifyRequest * pNotify);

    HRESULT HrCreateAliveNotifyRequest(
        PCONTEXT_HANDLE_TYPE * ppContextHandle,
        const char * szNT,
        HANDLE hNotifySemaphore);
    HRESULT HrCreatePropChangeNotifyRequest(
        PCONTEXT_HANDLE_TYPE * ppContextHandle,
        const char * szUrl,
        HANDLE hNotifySemaphore,
        SSDP_REGISTER_INFO ** ppRegisterInfo);
    HRESULT HrRemoveNotifyRequest(
        HANDLE hNotifySemaphore);
    HRESULT HrRemoveNotifyRequestByPointer(
        CSsdpNotifyRequest * pRequest);    
    HRESULT HrCheckListNotifyForEvent(const SSDP_REQUEST * pRequest);
    HRESULT HrCheckListNotifyForAliveOrByebye(const SSDP_REQUEST * pRequest);
    BOOL FIsAliveOrByebyeInListNotify(const SSDP_REQUEST * pRequest);
    HRESULT HrRetreivePendingNotification(
        HANDLE hNotifySemaphore,
        MessageList ** ppSvcList);
    HRESULT HrRestartClientResubscribeTimer(
        CSsdpNotifyRequest * pRequest,
        DWORD dwSecTimeout);
private:
    CSsdpNotifyRequestManager();
    CSsdpNotifyRequestManager(const CSsdpNotifyRequestManager &);
    CSsdpNotifyRequestManager & operator=(const CSsdpNotifyRequestManager &);

    HRESULT HrRemoveInternal(BOOL bRundown, HANDLE hNotifySemaphore, CSsdpNotifyRequest * pRequest);

    static CSsdpNotifyRequestManager s_instance;

    typedef CUList<CSsdpNotifyRequest> NotifyRequestList;
    typedef CUList<__int64> TimestampList;

    CUCriticalSection m_critSecAliveList;
    NotifyRequestList m_aliveList;

    CUCriticalSection m_critSecPropChangeList;
    NotifyRequestList m_propChangeList;

    CUCriticalSection m_critSecTimestampList;
    TimestampList m_timestampList;
    __int64 m_unTimestamp;
    HANDLE m_hEventTimestamp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\interfacehelper.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I N T E R F A C E H E L P E R . C P P
//
//  Contents:   Manages dealing with multiple interfaces and interface changes
//
//  Notes:
//
//  Author:     mbend   6 Feb 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "InterfaceHelper.h"
#include "ssdp.h"
#include <iphlpapi.h>
#include <winsock2.h>
#include "cache.h"

CInterfaceHelper CInterfaceHelper::s_instance;

CInterfaceHelper::CInterfaceHelper()
{
}

CInterfaceHelper::~CInterfaceHelper()
{
}

CInterfaceHelper & CInterfaceHelper::Instance()
{
    return s_instance;
}

void CInterfaceHelper::OnInterfaceChange(const InterfaceMappingList & interfaceMappingList)
{
    HRESULT hr = S_OK;

    InterfaceList interfaceList;
    {
        CLock lock(m_critSec);

        hr = HrGenerateDirtyGuidList(m_interfaceMappingList, interfaceMappingList, interfaceList);
        if(SUCCEEDED(hr))
        {
            // Copy the interface mapping list
            long nCount = interfaceMappingList.GetCount();
            m_interfaceMappingList.Clear();

            if (nCount)
            {
                hr = m_interfaceMappingList.HrSetCount(nCount);
                if(SUCCEEDED(hr))
                {
                    for(long n = 0; n < nCount; ++n)
                    {
                        m_interfaceMappingList[n] = interfaceMappingList[n];
                    }
                }
            }
        }
    }

    // Do this outside of lock
    if(SUCCEEDED(hr))
    {
        hr = CSsdpCacheEntryManager::Instance().HrClearDirtyInterfaceGuids(interfaceList.GetCount(), interfaceList.GetData());
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceHelper::OnInterfaceChange");
}

HRESULT CInterfaceHelper::HrInitialize()
{
    CLock lock(m_critSec);
    HRESULT hr = S_OK;

    hr = CUPnPInterfaceList::Instance().HrRegisterInterfaceChange(this);

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceHelper::HrInitialize");
    return hr;
}

HRESULT CInterfaceHelper::HrShutdown()
{
    HRESULT hr = S_OK;
    CLock lock(m_critSec);

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceHelper::HrShutdown");
    return hr;
}

HRESULT CInterfaceHelper::HrResolveAddress(DWORD dwIpAddress, GUID & guidInterface)
{
    CLock lock(m_critSec);
    HRESULT hr = S_OK;

    ZeroMemory(&guidInterface, sizeof(guidInterface));

    long nCount = m_interfaceMappingList.GetCount();
    for(long n = 0; n < nCount; ++n)
    {
        if(m_interfaceMappingList[n].m_dwIpAddress == dwIpAddress)
        {
            guidInterface = m_interfaceMappingList[n].m_guidInterface;
            break;
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceHelper::HrResolveAddress");
    return hr;
}

HRESULT CInterfaceHelper::HrGenerateDirtyGuidList(
    const InterfaceMappingList & interfaceMappingListOld,
    const InterfaceMappingList & interfaceMappingListNew,
    InterfaceList & interfaceList)
{
    CLock lock(m_critSec);
    HRESULT hr = S_OK;

    long nCountOld = interfaceMappingListOld.GetCount();
    long nCountNew = interfaceMappingListNew.GetCount();

    for(long n = 0; n < nCountOld && SUCCEEDED(hr); ++n)
    {
        BOOL bDirty = TRUE;
        for(long m = 0; m < nCountNew; ++m)
        {
            if(interfaceMappingListOld[n].m_guidInterface == interfaceMappingListNew[m].m_guidInterface)
            {
                if(interfaceMappingListOld[n].m_dwIpAddress == interfaceMappingListNew[m].m_dwIpAddress)
                {
                    bDirty = FALSE;
                }
                break;
            }
        }
        if(bDirty)
        {
            hr = interfaceList.HrPushBack(interfaceMappingListOld[n].m_guidInterface);
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CInterfaceHelper::HrGenerateDirtyGuidList");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\cache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C A C H E . H 
//
//  Contents:   SSDP client cache implementation
//
//  Notes:      
//
//  Author:     mbend   12 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "ulist.h"
#include "upsync.h"
#include "ustring.h"
#include "timer.h"
#include "ssdptypes.h"

class CSsdpCacheEntry
{
public:
    CSsdpCacheEntry();
    ~CSsdpCacheEntry();

    // Timer callback methods
    void TimerFired();
    BOOL TimerTryToLock();
    void TimerUnlock();

    HRESULT HrInitialize(const SSDP_REQUEST * pRequest);
    HRESULT HrStartTimer(const SSDP_REQUEST * pRequest);
    BOOL FTimerFired();
    HRESULT HrShutdown(BOOL bExpired);
    HRESULT HrUpdateExpireTime(const SSDP_REQUEST * pRequest);
    HRESULT HrUpdateEntry(const SSDP_REQUEST * pRequest, BOOL * pbCheckListNotify);
    BOOL FIsMatchUSN(const char * szUSN);
    BOOL FIsSearchMatch(const char * szType);
    HRESULT HrGetRequest(SSDP_REQUEST * pRequest);
    void PrintItem();
    BOOL FCheckForDirtyInterfaceGuids(long nCount, GUID * arGuidInterfaces);
private:
    CSsdpCacheEntry(const CSsdpCacheEntry &);
    CSsdpCacheEntry & operator=(const CSsdpCacheEntry &);

    volatile BOOL m_bTimerFired;
    SSDP_REQUEST m_ssdpRequest;
    CTimer<CSsdpCacheEntry> m_timer;
    CUCriticalSection m_critSec;
};

class CSsdpCacheEntryManager
{
public:
    ~CSsdpCacheEntryManager();

    static CSsdpCacheEntryManager & Instance();

    HRESULT HrInitialize();
    BOOL    IsCacheListNotFull();
    HRESULT HrShutdown();
    HRESULT HrRemoveEntry(CSsdpCacheEntry * pEntry);
    HRESULT HrUpdateCacheList(const SSDP_REQUEST * pRequest, BOOL bIsSubscribed);
    HRESULT HrSearchListCache(char * szType, MessageList ** ppSvcList);
    HRESULT HrClearDirtyInterfaceGuids(long nCount, GUID * arGuidInterfaces);
private:
    CSsdpCacheEntryManager();
    CSsdpCacheEntryManager(const CSsdpCacheEntryManager &);
    CSsdpCacheEntryManager & operator=(const CSsdpCacheEntryManager &);

    static CSsdpCacheEntryManager s_instance;

    typedef CUList<CSsdpCacheEntry> CacheEntryList;

    CUCriticalSection m_critSec;
    CacheEntryList m_cacheEntryList;
    int m_cCacheEntries;
    int m_cMaxCacheEntries;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\receivedata.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E C E I V E D A T A . C P P
//
//  Contents:   Queue of received data from network
//
//  Notes:
//
//  Author:     mbend   17 Dec 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ReceiveData.h"
#include "ssdp.h"
#include "status.h"
#include "ssdpfunc.h"
#include "ssdptypes.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#include "event.h"
#include "ncinet.h"

VOID ProcessSsdpRequest(PSSDP_REQUEST pSsdpRequest, RECEIVE_DATA *pData);

CReceiveData::CReceiveData(char * szData, SOCKET sock, BOOL fIsTcpSocket, BOOL fMCast,
                           SOCKADDR_IN * psockAddrInRemote)
: m_szData(szData), m_pNext(NULL), m_sock(sock), m_fIsTcpSocket(fIsTcpSocket), m_fMCast(fMCast)
{
    m_sockAddrInRemote = *psockAddrInRemote;
}

CReceiveData::~CReceiveData()
{
    delete [] m_szData;
}

CReceiveDataManager CReceiveDataManager::s_instance;

CReceiveDataManager::CReceiveDataManager() : m_hEventShutdown(NULL), m_hEventWork(NULL), m_hThread(NULL), m_pHead(NULL), m_pTail(NULL)
{
}

CReceiveDataManager::~CReceiveDataManager()
{
    if(m_hEventShutdown)
    {
        CloseHandle(m_hEventShutdown);
        m_hEventShutdown = NULL;
    }
    if(m_hEventWork)
    {
        CloseHandle(m_hEventWork);
        m_hEventWork = NULL;
    }
    if(m_hThread)
    {
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
}

CReceiveDataManager & CReceiveDataManager::Instance()
{
    return s_instance;
}

HRESULT CReceiveDataManager::HrAddData(char * szData, SOCKET sock, BOOL fMCast, SOCKADDR_IN * psockAddrInRemote)
{
    HRESULT hr = S_OK;

    if(!FIsSocketValid(sock))
    {
        delete [] szData;
        return S_OK;
    }

    CReceiveData * pData = new CReceiveData(szData, sock, FALSE, fMCast, psockAddrInRemote);
    if(!pData)
    {
        delete [] szData;
        hr = E_OUTOFMEMORY;
    }

    CLock lock(m_critSec);

    if(SUCCEEDED(hr))
    {
        if(!m_pHead)
        {
            m_pHead = m_pTail = pData;
        }
        else
        {
            m_pTail->m_pNext = pData;
            m_pTail = pData;
        }
        SetEvent(m_hEventWork);
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CReceiveDataManager::HrAddData");
    return hr;
}

HRESULT CReceiveDataManager::HrInitialize()
{
    HRESULT hr = S_OK;

    m_hEventShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(!m_hEventShutdown)
    {
        hr = HrFromLastWin32Error();
    }
    if(SUCCEEDED(hr))
    {
        m_hEventWork = CreateEvent(NULL, TRUE, FALSE, NULL);
        if(!m_hEventWork)
        {
            hr = HrFromLastWin32Error();
        }
        if(SUCCEEDED(hr))
        {
            m_hThread = CreateThread(NULL, 0, &CReceiveDataManager::ThreadFunc, NULL, 0, NULL);
            if(!m_hThread)
            {
                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CReceiveDataManager::HrInitialize");
    return hr;
}

HRESULT CReceiveDataManager::HrShutdown()
{
    HRESULT hr = S_OK;

    if(m_hThread)
    {
        if(!SetEvent(m_hEventShutdown))
        {
        }
        if(SUCCEEDED(hr))
        {
            WaitForSingleObject(m_hThread, INFINITE);
            CloseHandle(m_hThread);
            m_hThread = NULL;
        }
    }

    TraceHr(ttidSsdpNetwork, FAL, hr, FALSE, "CReceiveDataManager::HrShutdown");
    return hr;
}

DWORD WINAPI CReceiveDataManager::ThreadFunc(void *)
{
    return CReceiveDataManager::Instance().ThreadMember();
}

DWORD CReceiveDataManager::ThreadMember()
{
    HANDLE arHandles[] = {m_hEventWork, m_hEventShutdown};

    while(true)
    {
        DWORD dwRet = WaitForMultipleObjects(2, arHandles, FALSE, INFINITE);
        if(WAIT_OBJECT_0 != dwRet)
        {
            break;
        }
        while(true)
        {
            // Get lock and fetch one item
            CReceiveData * pData = NULL;
            {
                CLock lock(m_critSec);
                if(m_pHead)
                {
                    pData = m_pHead;
                    m_pHead = m_pHead->m_pNext;
                    if(!m_pHead)
                    {
                        m_pTail = NULL;
                    }
                }
            }
            if(!pData)
            {
                break;
            }
            // Process data
            ProcessReceiveBuffer(pData);

            delete pData;
        }
        ResetEvent(m_hEventWork);
    }
    return 0;
}

void CReceiveDataManager::ProcessReceiveBuffer(CReceiveData * pData)
{
    SSDP_REQUEST ssdpRequest;
    RECEIVE_DATA rd;

    rd.RemoteSocket = pData->m_sockAddrInRemote;
    rd.socket = pData->m_sock;
    rd.szBuffer = pData->m_szData;
    rd.fIsTcpSocket = pData->m_fIsTcpSocket;
    rd.fMCast = pData->m_fMCast;

    if(InitializeSsdpRequest(&ssdpRequest))
    {
        if(ParseSsdpRequest(pData->m_szData, &ssdpRequest))
        {
            ProcessSsdpRequest(&ssdpRequest, &rd);
        }
        else
        {
            FreeSsdpRequest(&ssdpRequest);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\notify.cpp ===
#include <pch.h>
#pragma hdrstop

#include <wininet.h>
#include "ssdptypes.h"
#include "notify.h"
#include "ssdpnetwork.h"
#include "ssdpfunc.h"
#include "ssdpsrv.h"
#include "event.h"
#include "ncinet.h"
#include "ncbase.h"
#include "upthread.h"
#include "rundown.h"

#define NOTIFY_RESULT_SIZE 2
static const CHAR c_szDeadNts[] = "upnp:dead";

#if DBG
const DWORD c_csecTimeout               = 60 * 3;   // 3 minute timeout (debug)
#else
const DWORD c_csecTimeout               = 60 * 30;  // 30 minute timeout
#endif

const TCHAR c_szSubscribe[]             = TEXT("SUBSCRIBE");
const TCHAR c_szUnSubscribe[]           = TEXT("UNSUBSCRIBE");
extern const TCHAR c_szHttpVersion[]    = TEXT("HTTP/1.1");
const TCHAR c_szSubsHeaderFmt[]         = TEXT("NT: upnp:event\r\n"
                                               "Callback: <http://%s:%d/%s>\r\n"
                                               "Timeout: Second-%d\r\n\r\n");
const TCHAR c_szReSubsHeaderFmt[]       = TEXT("SID: %s\r\nTimeout: Second-%d\r\n");
const TCHAR c_szUnSubsHeaderFmt[]       = TEXT("SID: %s\r\n");
const TCHAR c_szServer[]                = TEXT("Server");
const TCHAR c_szTimeout[]               = TEXT("Timeout");
const TCHAR c_szSid[]                   = TEXT("SID");

// UR