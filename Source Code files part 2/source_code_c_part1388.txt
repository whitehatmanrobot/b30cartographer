      }

            if(GetProp(pwrgn->hwnd, VBCTRLHOOK_PROPNAME) == VBCTRLHOOK_FILTERED)
            {
                // Since we have set the right clip and the message we were supposed to filter
                // out has arrived we can remove the hook.
                RemoveVBControlClipHook(pwrgn->hwnd);
            }
             _aryWndRgn.Delete(i);
        }
        else 
        {
            if (pwrgn->hrgn)
            {
                ::DeleteObject(pwrgn->hrgn);
            }
            if(GetProp(pwrgn->hwnd, VBCTRLHOOK_PROPNAME))
            {
                RemoveVBControlClipHook(pwrgn->hwnd);
            }
            _aryWndRgn.Delete(i);
        }
    }
}


void
CView::SetWindowRgn(HWND hwnd, const RECT * prc, BOOL fRedraw)
{
    TraceTag((tagViewHwndChange, "SWRgn %x Rect: %ld %ld %ld %ld  Redraw: %d",
        hwnd,
        prc->left, prc->top, prc->right, prc->bottom,
        fRedraw));

    Verify(::SetWindowRgn(hwnd, ::CreateRectRgnIndirect(prc), fRedraw));
    CancelDeferSetWindowRgn(hwnd);
}


void
CView::SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL fRedraw)
{
#if DBG == 1
    if (IsTagEnabled(tagViewHwndChange))
    {
        TraceTag((tagViewHwndChange, "SWRgn %x Rgn: %x  Redraw: %u",
            hwnd, hrgn, fRedraw));

        extern void DumpRegion(HRGN);
        DumpRegion(hrgn);
    }
#endif

    Verify(::SetWindowRgn(hwnd, hrgn, fRedraw));
    CancelDeferSetWindowRgn(hwnd);
}


void
CView::CancelDeferSetWindowRgn(HWND hwnd)
{
    for (int i = _aryWndRgn.Size()-1;  i >= 0;  --i)
    {
        if (hwnd == _aryWndRgn[i].hwnd)
        {
            if (_aryWndRgn[i].hrgn)
            {
                ::DeleteObject(_aryWndRgn[i].hrgn);
            }
            
            _aryWndRgn.Delete(i);
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     DeferTransition, EndDeferTransition
//
//  Synopsis:   Collect, defer, and execute Transition requests
//
//----------------------------------------------------------------------------

void
CView::DeferTransition(
    COleSite *          pOleSite)
{
    INSTANTCLASSINFO * pici;
    
    Assert(pOleSite);
    Assert(IsActive() || !_aryTransition.Size());

    if (!IsActive())
        return;

    pici = pOleSite->GetInstantClassInfo();
    
    if (pici && _aryTransition.EnsureSize(_aryTransition.Size() + 1) == S_OK
        && !(pici->dwCompatFlags & COMPAT_INPLACEACTIVATESYNCHRONOUSLY))
    {
        TRANSITIONTO_INFO * ptinfo = &_aryTransition[_aryTransition.Size()];

        ptinfo->pOleSite = pOleSite;

        // make sure we will have the COleSite when we return to process 
        // the posted EndDeferTransition call
        pOleSite->SubAddRef();

        _aryTransition.SetSize(_aryTransition.Size() + 1);
    }
    else
    {
        IGNORE_HR(pOleSite->TransitionToBaselineState(Doc()->State()));
    }

    PostEndDeferTransition();
}

void
CView::EndDeferTransition(
    DWORD   grfLayout,
    BOOL    fIgnore)
{
    Assert(fIgnore || _pDispRoot);
    Assert(IsActive() || !_aryTransition.Size());

    if (grfLayout & LAYOUT_DEFERENDDEFER)
        return;

    if (    !IsActive()
        ||  !_aryTransition.Size())
        return;

    if (!fIgnore)
    {
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

        //
        //  Transition each waiting object
        //  (Re-entrancy can re-alloc _aryTransition so always reference from the index)
        //

        for (int i = 0 ; i < _aryTransition.Size() ; i++)
        {
            TRANSITIONTO_INFO *ptinfo = &_aryTransition[i];

            if (ptinfo->pOleSite)
            {
                COleSite *pOleSite = ptinfo->pOleSite;
                ptinfo->pOleSite = 0;

                // Transition to whatever is the best state to transition to
                if (!pOleSite->IsPassivated() && !pOleSite->IsPassivating() && 
                    (pOleSite->State() < pOleSite->BaselineState(Doc()->State())))
                {
                    pOleSite->TransitionToBaselineState(Doc()->State());
                }

                // release the reference we added in the CView::DeferTransition
                pOleSite->SubRelease();
            }
        }
    }

    _aryTransition.DeleteAll();
}


//+---------------------------------------------------------------------------
//
//  Member:     SetFocus
//
//  Synopsis:   Set or clear the association between the focus adorner and
//              an element
//
//  Arguments:  pElement  - Element which has focus (may be NULL)
//              iDivision - Subdivision of the element which has focus
//
//----------------------------------------------------------------------------

void
CView::SetFocus(
    CElement *  pElement,
    long        iDivision)
{
    if (!IsActive())
        return;

    // TODO (donmarsh) -- we fail if we're in the middle of drawing.  Soon
    // we will have a better mechanism for deferring requests that are made
    // in the middle of rendering.
    if (!OpenView())
        return;

    if (pElement)
    {        
        CTreeNode * pNode =  pElement->GetFirstBranch();

        if (!pNode 
            ||  pNode->IsVisibilityHidden()
            ||  pNode->IsDisplayNone())
        {
            pElement = NULL;
        }        
    }

#ifdef FOCUS_ADORNER
    if (pElement)
    {
        if (!_pFocusAdorner)
        {
            _pFocusAdorner = new CFocusAdorner(this);

            if (    _pFocusAdorner
                &&  !SUCCEEDED(AddAdorner(_pFocusAdorner)))
            {
                _pFocusAdorner->Destroy();
                _pFocusAdorner = NULL;
            }
        }

        if (_pFocusAdorner)
        {
            BOOL fDestroyAdorner = FALSE;

            Assert( IsInState(CView::VS_OPEN) );
            Assert( pElement && pElement->IsInMarkup() );
   
            // check if element takes focus
            if (pElement->GetAAhideFocus())
            {        
                fDestroyAdorner = TRUE;      
            }

            if (pElement->HasMasterPtr())
            {
                pElement = pElement->GetMasterPtr();      
            }
            // If this element is a checkbox or a radio button, use the associated
            // label element if one exists for drawing the focus shape.
            else if (   pElement->Tag() == ETAG_INPUT
                     && DYNCAST(CInput, pElement)->IsOptionButton())
            {
                CLabelElement * pLabel = pElement->GetLabel();
                if (pLabel)
                {
                    if (pLabel->GetAAhideFocus())
                        fDestroyAdorner = TRUE;      
                    else
                        pElement = pLabel;
                }
            }

            if(fDestroyAdorner)
            {
                RemoveAdorner(_pFocusAdorner, FALSE);
                _pFocusAdorner = NULL;
                pElement = NULL;
            }
            else            
                _pFocusAdorner->SetElement(pElement, iDivision);
        }
    }

#endif

#ifdef FOCUS_BEHAVIOR
    if (pElement)
    {
        if (!_pFocusBehavior)
        {
            _pFocusBehavior = new CFocusBehavior(this);
        }

        if (_pFocusBehavior)
        {
            _pFocusBehavior->SetElement(pElement, iDivision);
        }
    }
    else if (_pFocusBehavior)
    {
        _pFocusBehavior->SetElement(NULL, 0);
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     InvalidateFocus
//
//  Synopsis:   Invalidate the focus shape (if any)
//
//----------------------------------------------------------------------------

void
CView::InvalidateFocus() const
{
    if (!IsActive())
        return;

#ifdef FOCUS_ADORNER
    _bUpdateFocusAdorner = TRUE;
#endif

#ifdef FOCUS_BEHAVIOR
    if (_pFocusBehavior)
        _pFocusBehavior->ShapeChanged();
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     GetViewSize
//
//  Synopsis:   Returns the current size of the view
//
//  Arguments:  psize - Returns the size
//
//----------------------------------------------------------------------------

void
CView::GetViewSize(
    CSize * psize) const
{
    Assert(psize);

    if (IsActive())
    {
        *psize = _pDispRoot->GetSize();
    }
    else
    {
        *psize = g_Zero.size;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     SetViewSize
//
//  Synopsis:   Set the size of the view
//
//  Arguments:  size - New view size (in device pixels)
//
//----------------------------------------------------------------------------

void
CView::SetViewSize(const CSize& size)
{
    Assert(!IsLockSet(VL_RENDERINPROGRESS));

    if (IsActive())
    {
        CSize   sizeCurrent;

        GetViewSize(&sizeCurrent);

        if (size != sizeCurrent)
        {            
            if (OpenView())
            {
                //
                //  Set the new size
                //
                _pDispRoot->SetSize(size, NULL, FALSE);
                ClearFlag(VF_SIZED);
                
                if (Doc()->_state >= OS_INPLACE)
                {
                    CLayout *   pLayout = GetRootLayout();
                    
                    if (pLayout && pLayout->ElementOwner()->GetMarkup()->Window()->_fFiredOnLoad && !pLayout->IsDisplayNone())
                    {

                        //
                        // Invalidate possible Z-children positioned on bottom or right sides
                        // (Root layout is always a z-parent)
                        //
                        pLayout->ElementOwner()->SendNotification(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS);

                        //
                        //  Queue a resize event
                        //
                        AddEventTask(pLayout->ElementOwner(), DISPID_EVMETH_ONRESIZE);
                    }
                }
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     OpenView
//
//  Synopsis:   Prepare the view for changes (e.g., open the display tree)
//
//  Returns:    TRUE if the view was successfully opened, FALSE if we are in
//              the middle of rendering
//
//----------------------------------------------------------------------------

BOOL
CView::OpenView(
    BOOL    fBackground,
    BOOL    fPostClose,
    BOOL    fResetTree)
{
    if (!IsActive())
        return TRUE;

    Assert( !IsLockSet(VL_TASKSINPROGRESS)
        ||  IsFlagSet(VF_TREEOPEN));

    if (    (   IsLockSet(VL_ENSUREINPROGRESS)
            &&  !IsLockSet(VL_TASKSINPROGRESS))
        ||  IsLockSet(VL_RENDERINPROGRESS))
        return FALSE;

    if (fResetTree)
    {
        CloseDisplayTree();
    }

    EnsureDisplayTreeIsOpen();

    if (    fPostClose
        &&  !IsLockSet(VL_TASKSINPROGRESS))
    {
        PostCloseView(fBackground);
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CloseView
//
//  Synopsis:   Perform all work necessary to close the view
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::CloseView(
    DWORD   grfLayout)
{
    if (IsFlagSet(VF_PENDINGENSUREVIEW))
    {
        if (grfLayout & LAYOUT_SYNCHRONOUS)
        {
            GWKillMethodCall(this,
                             ONCALL_METHOD(CView,
                                           EnsureViewCallback,
                                           ensureviewcallback),
                             0);

            ClearFlag(VF_PENDINGENSUREVIEW);

            if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONVIEWD))
                g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONVIEWD, (IUnknown*)(IPrivateUnknown*)Doc());
        }
    }

    if (IsFlagSet(VF_PENDINGTRANSITION))
    {
        if (    grfLayout & LAYOUT_SYNCHRONOUS
            &&  !(grfLayout & LAYOUT_DEFERENDDEFER))
        {
            GWKillMethodCall(this,
                             ONCALL_METHOD(CView,
                                           EndDeferTransitionCallback,
                                           enddefertransitioncallback),
                             0);
            ClearFlag(VF_PENDINGTRANSITION);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     PostCloseView
//
//  Synopsis:   Ensure a close view event is posted
//
//              The view is closed whenever EnsureView is called. EnsureView is
//              called for WM_PAINT handling, from the global window (for queued
//              background work or all work on pages without a frame rate), and
//              in response to the draw timer.
//
//              Background closures always occur through a message posted to
//              the global window.
//
//  Arguments:  fBackground - Close the view in the background
//              fEvent      - this is only passed in TRUE by Addtask for Events.
//                            this is necessary because events like onresize and
//                            onlayoutcomplete, and onscroll are going to be 
//                            posted during ensureview's reign in the 
//                            ExecuteLayoutTasks(MEASURE) and so we HAVE to make 
//                            sure that a post close view is queue so that they 
//                            will fire. without this, it is upto chance (and the
//                            luck of the draw( window message) as to when ensureView
//                            will be called next.
//
//----------------------------------------------------------------------------

void
CView::PostCloseView(BOOL  fBackground, /* == FALSE */
                     BOOL  fEvent       /* == FALSE */)
{
    if (    IsActive()
        &&  !IsFlagSet(VF_PENDINGENSUREVIEW)
        &&  (   fEvent 
             || !IsLockSet(VL_ACCUMULATINGINVALID))
        )
    {
        HRESULT hr;

        hr = GWPostMethodCall(this,
                              ONCALL_METHOD(CView,
                                            EnsureViewCallback,
                                            ensureviewcallback),
                              0, FALSE, "CView::EnsureViewCallback");
        SetFlag(VF_PENDINGENSUREVIEW);

        if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONVIEWQ))
            g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONVIEWQ, (IUnknown*)(IPrivateUnknown*)Doc());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     PostRenderView
//
//  Synopsis:   Ensure rendering will take place
//
//  Arguments:  fSynchronousRedraw - Render synchronously (if possible)
//
//----------------------------------------------------------------------------

void
CView::PostRenderView(
    BOOL    fSynchronousRedraw)
{
    //
    //  For normal documents, ensure rendering will occur
    //  (Assume rendering will occur for print documents)
    //

    if (    IsActive()
        &&  !Doc()->IsPrintDialogNoUI())
    {
        TraceTagEx((tagView, TAG_NONAME,
               "View : PostRenderView"));

        //
        //  If a synchronouse render is requested, then
        //      1) If about to render, ensure rendering occurs after publishing the invalid rectangles/region
        //      2) If not rendering, force a immediate WM_PAINT
        //      3) Otherwise, drop the request
        //         (Requests that arrive while rendering are illegal)
        //

        if (fSynchronousRedraw)
        {
            if (IsLockSet(VL_ACCUMULATINGINVALID))
            {
                TraceTagEx((tagView, TAG_NONAME,
                       "View : PostRenderView - Setting VF_FORCEPAINT"));

                SetFlag(VF_FORCEPAINT);
            }

            else if (   !IsLockSet(VL_UPDATEINPROGRESS)
                    &&  !IsLockSet(VL_RENDERINPROGRESS))
            {
                TraceTagEx((tagView, TAG_NONAME,
                       "View : PostRenderView - Calling DrawSynchronous"));

                DrawSynchronous();
            }
        }

        //
        //  For asynchronous requests, just note that the view needs closing
        //

        else
        {
            TraceTagEx((tagView, TAG_NONAME,
                   "View : PostRenderView - Calling PostCloseView"));

            PostCloseView();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     PostEndDeferTransition
//
//  Synopsis:   Ensure a call to EndDeferTransition is posted
//
//----------------------------------------------------------------------------

void
CView::PostEndDeferTransition()
{
    if (    IsActive()
        &&  !IsFlagSet(VF_PENDINGTRANSITION)
        &&  !Doc()->IsPrintDialogNoUI())
    {
        HRESULT hr;

        hr = GWPostMethodCall(this,
                              ONCALL_METHOD(CView,
                                            EndDeferTransitionCallback,
                                            enddefertransitioncallback),
                              0, FALSE, "CView::EndDeferTransitionCallback");
        SetFlag(VF_PENDINGTRANSITION);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     DrawSynchronous
//
//  Synopsis:   Force a synchronous draw of the accumulated invalid areas
//
//  Arguments:  hdc - HDC into which to render
//
//----------------------------------------------------------------------------

void
CView::DrawSynchronous()
{
    Assert( !IsLockSet(VL_ACCUMULATINGINVALID)
        &&  !IsLockSet(VL_UPDATEINPROGRESS)
        &&  !IsLockSet(VL_RENDERINPROGRESS));
    Assert( !HasInvalid()
        ||  !Doc()->IsPrintDialogNoUI());

    TraceTagEx((tagView, TAG_NONAME,
           "View : DrawSynchronous"));

    if (HasInvalid())
    {
        CRect rcBounds;
            _rgnInvalid.GetBounds(&rcBounds);
        TraceTagEx((tagView, TAG_NONAME,
               "View : DrawSynchronous - HasInvalid of (%d, %d, %d, %d)",
               rcBounds.left,
               rcBounds.top,
               rcBounds.right,
               rcBounds.bottom));

        TraceTagEx((tagView, TAG_NONAME,
               "View : DrawSynchronous - Calling UpdateForm"));

        //
        //  Ensure all nested ActiveX/APPLETs receive pending SetObjectRects
        //  before receiving a WM_PAINT
        //  (This is necessary since Windows sends WM_PAINT to child HWNDs
        //   before their parent HWND. Since we delay sending SetObjectRects
        //   until we receive our own WM_PAINT, not forcing it through now
        //   causes it to come after the child HWND has painted.)
        //
        
        EnsureView();

        Doc()->UpdateForm();
    }

    TraceTagEx((tagView, TAG_NONAME,
           "View : DrawSynchronous - Exit"));
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureFocus
//
//  Synopsis:   Ensure the focus adorner is properly initialized
//
//----------------------------------------------------------------------------

void
CView::EnsureFocus()
{
#ifdef FOCUS_ADORNER
    if (    IsActive()
        &&  _pFocusAdorner)
    {
        _pFocusAdorner->EnsureFocus();

        CHECKRECURSION();
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureSize
//
//  Synopsis:   Ensure the top layout is in-sync with the current
//              device (not necessarily the view)
//
//  Arguments:  grfLayout - Current LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::EnsureSize(DWORD grfLayout)
{
    if (IsActive())
    {
        //
        //  Size the top level element to the view and start the CalcSize
        //   

        CLayout *   pLayout = GetRootLayout();

        if (     pLayout
            &&  !pLayout->IsDisplayNone())
        {
            //
            //  If LAYOUT_FORCE is set, re-size and re-attach the layout
            //

            if (grfLayout & LAYOUT_FORCE)       //  Force a resize & reattach
            {
                _pLayout = NULL;
            }

            if (_pLayout != pLayout)            //  Layout does not match.  Resize & reattach.
            {
                _pLayout = pLayout;
                ClearFlag(VF_SIZED);
                ClearFlag(VF_ATTACHED);
            }

            //
            //  Make sure current top layouts are sync'ed with view size
            //

            if (!IsSized(pLayout))
            {
                CSize      size;
                CCalcInfo   CI(&_dciDefaultMedia, pLayout);
        
                GetViewSize(&size);

                CI.SizeToParent((SIZE *)&size);
                CI._grfLayout = grfLayout | LAYOUT_MEASURE;
                CI._sizeParentForVert = CI._sizeParent;
             
                //  NOTE: Used only by CDoc::GetDocCoords
                if (IsFlagSet(VF_FULLSIZE))
                {
                    CI._smMode = SIZEMODE_FULLSIZE;
                }

                pLayout->CalcSize(&CI, (SIZE *)&size);
                
                SetFlag(VF_SIZED);
            }

            CHECKRECURSION();

            //
            //  If the current layout is not attached, attach it
            //

            if (!IsAttached(pLayout))
            {
                CDispNode * pDispNode;

                //
                //  Remove the previous top-most layout (if it exists)
                //

                Assert(_pDispRoot->CountChildren() <= 1);
                pDispNode = _pDispRoot->GetFirstChildNode();

                if (pDispNode)
                {
                    ExtractDispNode(pDispNode);
                }

                //
                //  Insert the current top-most layout
                //
                pDispNode = pLayout->GetElementDispNode();
                Assert(pDispNode);  // Canvas should *always* have a display node.

                if (pDispNode)
                {
                    pDispNode->SetPosition(g_Zero.pt);
                    _pDispRoot->InsertChildInFlow(pDispNode);


                    SetFlag(VF_ATTACHED);                
                }
            }

            CHECKRECURSION();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureViewCallback
//
//  Synopsis:   Process a posted call to EnsureView
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::EnsureViewCallback(DWORD_PTR dwContext)
{
    DWORD grfLayout = (DWORD)dwContext;
    // We need to ref the document because all external holders of the doc
    // could go away during EnsureView.  E.g., EnsureView may cause embedded
    // controls to transition state; that gives external code a chance to
    // execute, and they may release all refs to the doc.
    CServer::CLock Lock( Doc() );

    Assert(IsInitialized());
    Assert(IsActive());

    // GlobalWndOnMethodCall() will have cleared the callback entry in its array;
    // now clear the flag to keep its meaning sync'ed up.
    ClearFlag( VF_PENDINGENSUREVIEW );

    if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONVIEWD))
        g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONVIEWD, (IUnknown*)(IPrivateUnknown*)Doc());

    if (!EnsureView(grfLayout))
    {
        // Something in the middle of EnsureView like a script induced dialog box has
        // made us process window messages and pull this off.  We *can't* repost, because
        // it'll just get pulled off again and we'll spin.  If we can't go away happy, at
        // least we can go away valid.  Clear recursion flag to stop ASSERT.  (greglett)
        CLEARRECURSION();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     EndDeferTransitionCallback
//
//  Synopsis:   Process a posted call to EndDeferTransition
//
//----------------------------------------------------------------------------

void
CView::EndDeferTransitionCallback(DWORD_PTR dwContext)
{
    // We need to ref the document because all external holders of the doc
    // could go away during EnsureView.  E.g., EnsureView may cause embedded
    // controls to transition state; that gives external code a chance to
    // execute, and they may release all refs to the doc.
    CServer::CLock Lock( Doc() );

    Assert(IsInitialized());
    Assert(IsActive());

    // GlobalWndOnMethodCall() will have cleared the callback entry in its array;
    // now clear the flag to keep its meaning sync'ed up.
    ClearFlag( VF_PENDINGTRANSITION );

    EndDeferTransition();
}


//+---------------------------------------------------------------------------
//
//  Member:     FixWindowZOrder
//
//  Synopsis:   Fix Z order of child windows.
//
//  Arguments:  none
//              
//----------------------------------------------------------------------------

void
CView::FixWindowZOrder()
{
    if (IsActive())
    {
        CWindowOrderInfo windowOrderInfo;
        _pDispRoot->TraverseInViewAware((void*)&windowOrderInfo);
        windowOrderInfo.SetWindowOrder(&_pAryHwnd);
    }
}

CView::CWindowOrderInfo::CWindowOrderInfo()
{
    _pAryHwndNew = new (Mt(CView_aryHWND_pv)) CAryHWND;
    if (_pAryHwndNew)
    {
        _pAryHwndNew->EnsureSize(30);
    }

#if DBG==1 || defined(PERFTAGS)
    _cWindows = 0;
#endif
}

void
CView::CWindowOrderInfo::AddWindow(HWND hwnd)
{
    if (_pAryHwndNew)
    {
        HWND* pHwnd = _pAryHwndNew->Append();
        if (pHwnd != NULL)
            *pHwnd = hwnd;
    }

    TraceTag((tagChildWindowOrder, "add hwnd %x", hwnd));

#if DBG==1 || defined(PERFTAGS)
    _cWindows++;
#endif
}

void
CView::CWindowOrderInfo::SetWindowOrder(CAryHWND **ppAryHwnd)
{
    CAryHWND *pAryHwndOld = *ppAryHwnd;
    int iNew;
    const int sizeNew = _pAryHwndNew->Size();
    BOOL fBeginDeferWindowPosCalled = FALSE;
    HDWP hdwp = NULL;

    // for each HWND on the new list
    for (iNew=0;  iNew < sizeNew;  ++iNew)
    {
        HWND hwndPredNew = (iNew == 0) ? HWND_TOP : (*_pAryHwndNew)[iNew-1];

        TraceTag((tagChildWindowOrder, "change pred of %x to %x",
                (*_pAryHwndNew)[iNew], hwndPredNew));

        // start the notification, if this is the first changed HWND
        if (!fBeginDeferWindowPosCalled)
        {
            hdwp = ::BeginDeferWindowPos(30);
            fBeginDeferWindowPosCalled = TRUE;
        }

        if (hdwp)
        {
            hdwp = ::DeferWindowPos(
                    hdwp,
                    (*_pAryHwndNew)[iNew],
                    hwndPredNew,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
        }
        else
        {
            ::SetWindowPos(
                    (*_pAryHwndNew)[iNew],
                    hwndPredNew,
                    0, 0, 0, 0,
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
        }
    }

    // finish the notification (if it was started at all)
#ifndef _MAC
    if (fBeginDeferWindowPosCalled && hdwp)
    {
        ::EndDeferWindowPos(hdwp);
    }
#endif

    // replace the old list with the new
    delete pAryHwndOld;
    *ppAryHwnd = _pAryHwndNew;
    _pAryHwndNew = NULL;

#if DBG==1 || defined(PERFTAGS)
    PerfDbgLog1(tagChildWindowOrder, this, "CView::CWindowOrderInfo::SetWindowOrder, %d windows", _cWindows);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     GetRootLayout
//
//  Synopsis:   Return the top-most layout of the associated CMarkup
//
//  Returns:    CLayout of the top-most element client (if available), NULL otherwise
//
//----------------------------------------------------------------------------

CLayout *
CView::GetRootLayout() const
{
    CElement *  pElement;
    
    pElement = CMarkup::GetCanvasElementHelper(Doc()->PrimaryMarkup());

    return pElement
                ? pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )
                : NULL;
}
//+---------------------------------------------------------------------------
//
//  Member:     ScrollRect
//
//  Synopsis:   Scroll pixels on screen
//
//  Arguments:  rcgScroll        - Rectangle that scrolled
//              sizegScrollDelta - Amount of the scroll
//
//----------------------------------------------------------------------------

void
CView::ScrollRect(
    const CRect&    rcgScroll,
    const CSize&    sizegScrollDelta,
    CDispScroller*  pScroller)
{
    TraceTagEx((tagView, TAG_NONAME,
           "View : ScrollRect - rc(%d, %d, %d, %d), delta(%d, %d)",
           rcgScroll.left,
           rcgScroll.top,
           rcgScroll.right,
           rcgScroll.bottom,
           sizegScrollDelta.cx,
           sizegScrollDelta.cy));

    Assert(Doc());
    
    HWND hwnd;
    HRGN hrgng;
    HDC scrollDC;
    
    if (!AllowScrolling() || (_grfLayout & LAYOUT_FORCE))
        goto JustInvalidate;
    
    hwnd = Doc()->GetHWND();
    if (!hwnd)
        goto JustInvalidate;

    // create region for invalid region created as a result of scrolling
    hrgng = ::CreateRectRgnIndirect(&g_Zero.rc);
    if (!hrgng)
        goto JustInvalidate;

    // get HDC to scroll
    scrollDC = ::GetDCEx(hwnd, NULL, DCX_CACHE|DCX_CLIPSIBLINGS);
    if (!scrollDC)
    {
        ::DeleteObject(hrgng);
        goto JustInvalidate;
    }
    Doc()->GetPalette(scrollDC);

    // adjust any invalid area we are holding that intersects the scroll rect
    if (HasInvalid())
    {
        CRegion rgngAdjust(rcgScroll);

        MergeInvalid();

        rgngAdjust.Intersect(_rgnInvalid);

        if (!rgngAdjust.IsEmpty())
        {
            _rgnInvalid.Subtract(rcgScroll);
            rgngAdjust.Offset(sizegScrollDelta);
            rgngAdjust.Intersect(rcgScroll);
            _rgnInvalid.Union(rgngAdjust);
        }
    }

    // the invalid area that was already published to Windows may need to be
    // adjusted too.  Get the update region for our window, mask it by the
    // rect that is being scrolled, and adjust it.
    if (::GetUpdateRgn(hwnd, hrgng, FALSE) != NULLREGION)
    {
        CRegion rgngUpdate(hrgng);
        rgngUpdate.Offset(sizegScrollDelta);
        rgngUpdate.Intersect(rcgScroll);
        Invalidate(rgngUpdate);
        ::ValidateRect(hwnd, (RECT*) &rcgScroll);
    }
    
    // make sure we don't have any clip region, or ScrollDC won't report
    // the correct invalid region
    ::SelectClipRgn(scrollDC, NULL);


    // do the scroll
    Verify(::ScrollDC(
        scrollDC, 
        sizegScrollDelta.cx, sizegScrollDelta.cy,
        &rcgScroll, &rcgScroll, hrgng, NULL));

    // invalidate area revealed by scroll
    Invalidate(hrgng, TRUE, TRUE);

    if (_pDispRoot->IsObscuringPossible())
    {
        CView::CEnsureDisplayTree edt(this);
        _pDispRoot->RequestRecalc();
        CLayout  * pLayout = GetRootLayout();
        CMarkup  *pLayoutMarkup = pLayout->ElementOwner()->GetMarkup();
        Doc()->WaitForRecalc(pLayoutMarkup);
    }


    ::DeleteObject(hrgng);


    // release the HDC
    Verify(::ReleaseDC(hwnd, scrollDC));
    
    return;
    
JustInvalidate:
    Invalidate(rcgScroll, TRUE, TRUE);
}


//+---------------------------------------------------------------------------
//
//  Member:     ClearInvalid
//
//  Synopsis:   Clear accumulated invalid rectangles/region
//
//----------------------------------------------------------------------------

void
CView::ClearInvalid()
{
    if (IsActive())
    {
        ClearFlag(VF_INVALCHILDWINDOWS);
        _cInvalidRects = 0;
        _rgnInvalid.SetEmpty();
    }

    Assert(!HasInvalid());
}


//+---------------------------------------------------------------------------
//
//  Member:     PublishInvalid
//
//  Synopsis:   Push accumulated invalid rectangles/region into the
//              associated device (HWND)
//
//  Arguments:  grfLayout - Current LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::PublishInvalid(
    DWORD   grfLayout)
{
    if (IsActive())
    {
        CPoint  pt;

        MergeInvalid();

        if (!(grfLayout & LAYOUT_DEFERINVAL))
        {
            GetViewPosition(&pt);

            if (_rgnInvalid.IsComplex())
            {
                if (pt != g_Zero.pt)
                {
                    _rgnInvalid.Offset(pt.AsSize());
                }
            
                HRGN hrgn = _rgnInvalid.GetRegionForever();
                if(hrgn)
                {
                    Doc()->Invalidate(NULL, NULL, hrgn, (IsFlagSet(VF_INVALCHILDWINDOWS)
                                                      ? INVAL_CHILDWINDOWS
                                                                : 0));
                    //NOTE (mikhaill) -- something seem to be incorrect inside CDoc::Invalidate():
                    //some branches keep hrgn, and others just use and forget. So following deletion
                    //also can be incorrect
                    ::DeleteObject(hrgn);
                }
            }

            else if (!_rgnInvalid.IsEmpty())
            {
                CRect rcInvalid;
                    _rgnInvalid.GetBounds(&rcInvalid);

                rcInvalid.OffsetRect(pt.AsSize());

                Doc()->Invalidate(&rcInvalid, NULL, NULL, (IsFlagSet(VF_INVALCHILDWINDOWS)
                                                            ? INVAL_CHILDWINDOWS
                                                            : 0));
            }

            ClearInvalid();
        }
    }

    Assert( grfLayout & LAYOUT_DEFERINVAL
        ||  !HasInvalid());
}


//+---------------------------------------------------------------------------
//
//  Member:     MergeInvalid
//
//  Synopsis:   Merge the collected invalid rectangles/region into a
//              single CRegion object
//
//----------------------------------------------------------------------------

void
CView::MergeInvalid()
{
    if (_cInvalidRects)
    {
#if 1
        //
        //  Create the invalid region
        //  (If too many invalid rectangles arrived during initial load,
        //   union them all into a single rectangle)
        //

        if (    _cInvalidRects == MAX_INVALID
            &&  !IsFlagSet(VF_HASRENDERED))
        {
            CRect   rcUnion(_aryInvalidRects[0]);
            CRect   rcView;

            TraceTag((tagViewInvalidate, "merging inval rects, start with (%d, %d, %d, %d)",
                    rcUnion.left, rcUnion.top, rcUnion.right, rcUnion.bottom));

            for (int i = 1; i < _cInvalidRects; i++)
            {
                TraceTag((tagViewInvalidate, "  merge (%d, %d, %d, %d)",
                    _aryInvalidRects[i].left,
                    _aryInvalidRects[i].top,
                    _aryInvalidRects[i].right,
                    _aryInvalidRects[i].bottom
                    ));

                rcUnion.Union(_aryInvalidRects[i]);
            }

            GetViewRect(&rcView);
            rcUnion.IntersectRect(rcView);

            TraceTag((tagViewInvalidate, "add to inval region (%d, %d, %d, %d)",
                    rcUnion.left, rcUnion.top, rcUnion.right, rcUnion.bottom));

            _rgnInvalid.Union(rcUnion);
        }
        else
        {
            for (int i = 0; i < _cInvalidRects; i++)
            {
                TraceTag((tagViewInvalidate, "add to inval region (%d, %d, %d, %d)",
                    _aryInvalidRects[i].left,
                    _aryInvalidRects[i].top,
                    _aryInvalidRects[i].right,
                    _aryInvalidRects[i].bottom
                    ));

                _rgnInvalid.Union(_aryInvalidRects[i]);
            }
        }
#else
        //
        //  Strategy 3 (see CView::Invalidate): Always build a region from the individual rectangles
        //

        for (int i = 1; i < _cInvalidRects; i++)
        {
            _rgnInvalid.Union(_aryInvalidRects[i]);
        }
#endif

        _cInvalidRects = 0;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     OpenDisplayTree
//
//  Synopsis:   Open the display tree (if it exists)
//
//----------------------------------------------------------------------------

void
CView::OpenDisplayTree()
{
    Assert(IsActive() || !IsFlagSet(VF_TREEOPEN));

    if (IsActive())
    {
        // clients may call back during rendering.  We assume they are doing
        // something safe (like reading width or height of an element).
        if (IsLockSet(VL_RENDERINPROGRESS))
            return;
        
        Assert( (IsFlagSet(VF_TREEOPEN)  && _pDispRoot->DisplayTreeIsOpen())
            ||  (!IsFlagSet(VF_TREEOPEN) && !_pDispRoot->DisplayTreeIsOpen()));

        if (!IsFlagSet(VF_TREEOPEN))
        {
            SetFlag(VF_TREEOPEN);
            TraceTag((tagViewTreeOpen, "TID:%x %x +TreeOpen", GetCurrentThreadId(), this));
            _pDispRoot->OpenDisplayTree();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CloseDisplayTree
//
//  Synopsis:   Close the display tree
//
//----------------------------------------------------------------------------

void
CView::CloseDisplayTree()
{
    Assert(IsActive() || !IsFlagSet(VF_TREEOPEN));

    if (IsActive())
    {
        Assert( (IsFlagSet(VF_TREEOPEN) && _pDispRoot->DisplayTreeIsOpen())
            ||  (!IsFlagSet(VF_TREEOPEN) && !_pDispRoot->DisplayTreeIsOpen()));

        if (IsFlagSet(VF_TREEOPEN))
        {
            CServer::CLock lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);
            //dmitryt: here the context resets to initial state.
            //         ToDo: set context to initial layout->device matrix instead of SetToIdentity
            _pRecalcContext->SetToIdentity();

            _pDispRoot->CloseDisplayTree(_pRecalcContext);
            ClearFlag(VF_TREEOPEN);
            TraceTag((tagViewTreeOpen, "TID:%x %x -TreeOpen", GetCurrentThreadId(), this));
        }

        CHECKRECURSION();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     WantOffscreenBuffer
//
//  Synopsis:   Determine if an offscreen buffer should be used
//
//  Returns:    TRUE if an offscreen buffer should be used, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::WantOffscreenBuffer() const
{
    return !(   (Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_OFFSCREEN)
            ||  (   g_pHtmPerfCtl
                &&  (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_OFFSCREEN))
            ||  !IsFlagSet(VF_HASRENDERED)
            ||  (!Doc()->_pOptionSettings->fForceOffscreen &&
                    g_fTerminalServer && !g_fTermSrvClientSideBitmaps)
            );
}


//+---------------------------------------------------------------------------
//
//  Member:     AllowOffscreenBuffer
//
//  Synopsis:   Determine if an offscreen buffer can be used
//              NOTE: This should override all other checks (e.g., WantOffscreenBuffer)
//
//  Returns:    TRUE if an offscreen buffer can be used, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::AllowOffscreenBuffer() const
{
#if DBG == 1
    static int g_fDisallowOffscreenBuffer = 0;
#endif
        return (!Doc()->IsPrintDialogNoUI()
#if DBG == 1
               && !IsPerfDbgEnabled(tagNoOffScr)
               && !g_fDisallowOffscreenBuffer
#endif
        );
}

//+---------------------------------------------------------------------------
//
//  Member:     AllowScrolling
//
//  Synopsis:   Determine if scrolling of the DC is allowed
//
//  Returns:    TRUE if scrolling is allowed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::AllowScrolling() const
{
    return  !Doc()->IsPrintDialogNoUI()
        &&  !g_fInHomePublisher98;
}


//+---------------------------------------------------------------------------
//
//  Member:     AllowSmoothScrolling
//
//  Synopsis:   Determine if smooth scrolling is allowed
//
//  Returns:    TRUE if smooth scrolling is allowed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::AllowSmoothScrolling() const
{
    return  Doc()->_pOptionSettings->fSmoothScrolling
        WHEN_DBG( && !IsTagEnabled(tagNoSmoothScroll) )
        &&  !g_fTerminalServer
        &&  AllowScrolling();
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     DumpDisplayTree
//
//  Synopsis:   Dump the display tree
//
//----------------------------------------------------------------------------

void
CView::DumpDisplayTree() const
{
    if (IsActive())
    {
        _pDispRoot->DumpDisplayTree();
    }
}
#endif


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     IsDisplayTreeOpen
//
//  Synopsis:   Check if the display tree is open
//
//----------------------------------------------------------------------------

BOOL
CView::IsDisplayTreeOpen() const
{
    return (    IsActive()
            &&  _pDispRoot
            &&  _pDispRoot->DisplayTreeIsOpen());
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     AddTask
//
//  Synopsis:   Add a task to the view-task queue
//
//  Arguments:  pv        - Object to call
//              vtt       - Task type
//              grfLayout - Collection of LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

HRESULT
CView::AddTask(
    void *                  pv,
    CViewTask::VIEWTASKTYPE vtt,
    DWORD                   grfLayout,
    LONG                    lData, 
    DWORD                   dwExtra)
{
    if (!IsActive())
        return S_OK;

    CViewTask       vt(pv, vtt, lData, grfLayout, dwExtra);
    CAryVTasks *    pTaskList = GetTaskList(vtt);
    int             i;
    HRESULT         hr;

    AssertSz(Doc(), "View used while CDoc is not inplace active");
    AssertSz(_pDispRoot, "View used while CDoc is not inplace active");
    Assert(!(grfLayout & LAYOUT_NONTASKFLAGS));
    Assert(!(grfLayout & LAYOUT_TASKDELETED));

    i = vtt != CViewTask::VTT_EVENT
            ? FindTask(pTaskList, vt)
            : -1;
        
        if (i < 0)
        {
            hr = pTaskList->AppendIndirect(&vt);
            
            if (SUCCEEDED(hr))
        {
            PostCloseView(vt.IsFlagSet(LAYOUT_BACKGROUND), 
                          (vtt == CViewTask::VTT_EVENT));
        }
        }
        else
        {
            CViewTask * pvt = &(*pTaskList)[i];
            
            pvt->AddFlags(grfLayout);
            Assert(!(pvt->IsFlagsSet(LAYOUT_BACKGROUND | LAYOUT_PRIORITY)));
            
            hr = S_OK;
        }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     ExecuteLayoutTasks
//
//  Synopsis:   Execute pending layout tasks in document source order
//
//  Arguments:  grfLayout - Collections of LAYOUT_xxxx flags
//
//  Returns:    TRUE if all tasks were processed, FALSE otherwise
//
//----------------------------------------------------------------------------

#pragma warning(disable:4706)           // Assignment within a conditional

BOOL
CView::ExecuteLayoutTasks(
    DWORD   grfLayout)
{
    Assert(IsActive());

    CViewTask * pvtTask;
    DWORD       fLayout = (grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagLayoutTasks, TAG_NONAME|TAG_INDENT, "(CView::ExecuteLayoutTasks [%s]", ((fLayout & LAYOUT_MEASURE) ? "MEASURE" : ((fLayout & LAYOUT_POSITION) ? "POSITION" : "ADORNER" )) ));

    while (pvtTask = GetNextTaskInSourceOrder(CViewTask::VTT_LAYOUT, fLayout))
    {
        Assert(pvtTask->IsType(CViewTask::VTT_LAYOUT));
        Assert(pvtTask->GetLayout());
        Assert(!(pvtTask->GetFlags() & LAYOUT_NONTASKFLAGS));
        Assert(!pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

        //
        //  Mark task has having completed the current LAYOUT_MEASURE/POSITION/ADORNERS pass
        //

        pvtTask->_grfLayout &= ~fLayout;

        //
        //  Execute the task
        //

        pvtTask->GetLayout()->DoLayout(grfLayout);

        CHECKRECURSION();
    }

    if (fLayout & LAYOUT_ADORNERS)
    {
        _aryTaskLayout.DeleteAll();
    }

    TraceTagEx((tagLayoutTasks, TAG_NONAME|TAG_OUTDENT, ")CView::ExecuteLayoutTasks - %d tasks remaining", _aryTaskLayout.Size() ));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     ExecuteEventTasks
//
//  Synopsis:   Execute pending event-firing tasks in receiving order
//
//  Arguments:  grfLayout - Collections of LAYOUT_xxxx flags
//
//  Returns:    TRUE if all tasks were processed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CView::ExecuteEventTasks(DWORD grfLayout)
{
    Assert(IsActive());

    if (grfLayout & LAYOUT_DEFEREVENTS)
        return (_aryTaskEvent.Size() == 0);

    CElement *      pElement;
    CAryVTaskEvent  aryTaskEvent;
    CViewTask *     pvtTask;
    int             cTasks;

    aryTaskEvent.Copy(_aryTaskEvent, FALSE);
    _aryTaskEvent.DeleteAll();

    PerfDbgLog1(tagCViewEnsure, this, "Firing %d tasks", aryTaskEvent.Size());

    //
    //  Ensure the elements stay for the duration of all pending events
    //  (The reference count is increment once per-pending event)
    //


    cTasks = aryTaskEvent.Size();
    for (pvtTask = &((CAryVTaskEvent &) aryTaskEvent)[0];
        cTasks;
        pvtTask++, cTasks--)
    {
        Assert(pvtTask->GetElement());

        pElement = pvtTask->GetElement();
        pElement->AddRef();
        pElement->_fHasPendingEvent = FALSE;
    }

    //
    //  Fire the events and release the hold on the elements
    //

    cTasks = aryTaskEvent.Size();
    for (pvtTask = &((CAryVTaskEvent &) aryTaskEvent)[0];
        cTasks;
        pvtTask++, cTasks--)
    {
        Assert(pvtTask->IsType(CViewTask::VTT_EVENT));
        Assert(pvtTask->GetElement());
        Assert(!pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

        pElement = pvtTask->GetElement();

        switch (pvtTask->GetEventDispID())
        {
            // Specila dispid for remeasure requests that come in
            // while executing position/adorner tasks.
        case STDPROPID_XOBJ_WIDTH:
            PerfDbgLog(tagCViewEnsure, this, "+RemeasureElement");
            pElement->RemeasureElement();
            PerfDbgLog2(tagCViewEnsure, this, "-RemeasureElement(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            break;

        case DISPID_EVMETH_ONSCROLL:
            pElement->Fire_onscroll();
            break;

        case DISPID_EVMETH_ONMOVE:
            PerfDbgLog(tagCViewEnsure, this, "+Fire onmove");
            pElement->Fire_onmove();
            PerfDbgLog2(tagCViewEnsure, this, "-Fire onmove(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            break;

        case DISPID_EVMETH_ONRESIZE:
            if (    Doc()->_state >= OS_INPLACE
                &&  Doc()->_pWindowPrimary->_fFiredOnLoad )
            {
                if (    pElement == Doc()->PrimaryMarkup()->GetCanvasElement()
                    &&  Doc()->_pWindowPrimary)
                {
                    PerfDbgLog(tagCViewEnsure, this, "+Fire window oresize");
                    Doc()->_pWindowPrimary->Fire_onresize();
                    PerfDbgLog(tagCViewEnsure, this, "-Fire window oresize");
                }
                else
                {
                    PerfDbgLog(tagCViewEnsure, this, "+Fire oresize");
                    pElement->Fire_onresize();
                    PerfDbgLog2(tagCViewEnsure, this, "-Fire oresize(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
                }
            }
            break;

        case DISPID_EVMETH_ONLAYOUTCOMPLETE:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onlayoutcomplete");
                pElement->Fire_onlayoutcomplete(FALSE);
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onlayoutcomplete(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;

        case DISPID_EVMETH_ONLINKEDOVERFLOW:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onlayoutcomplete");
                pElement->Fire_onlayoutcomplete(TRUE, pvtTask->GetExtra());
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onlayoutcomplete(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;

        case DISPID_EVMETH_ONPAGE:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onpage");
                pElement->Fire_onpage();
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onpage(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"" ? pElement->GetIdentifier() : L"");
            }
            break;

        case DISPID_EVMETH_ONMULTILAYOUTCLEANUP:
            {
                PerfDbgLog(tagCViewEnsure, this, "+Fire onmultilayoutcleanup");
                pElement->SendNotification( NTYPE_MULTILAYOUT_CLEANUP );
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onmultilayoutcleanup(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;
        case DISPID_EVMETH_ONPROPERTYCHANGE:
            if (Doc()->_state >= OS_INPLACE && pElement)
            {
                HRESULT     hr;
                BSTR        strName = NULL;

                PerfDbgLog(tagCViewEnsure, this, "+Fire onpropertychange");
                hr = THR_NOTRACE(pElement->GetMemberName(pvtTask->GetExtra(), &strName));
                if (hr)
                {
                    strName = NULL;
                }

                if (strName)
                {
                    pElement->Fire_onpropertychange(strName);
                    SysFreeString(strName);
                }
                PerfDbgLog2(tagCViewEnsure, this, "-Fire onpropertychange(%S, %S)", pElement->TagName(), pElement->GetIdentifier() ? pElement->GetIdentifier() : L"");
            }
            break;

        default:
            break;
        }

        CHECKRECURSION();

        pElement->Release();
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     FindTask
//
//  Synopsis:   Locate a task in the task array
//
//  Arguments:  vt  - Task to remove
//
//  Returns:    If found, index of task in task array
//              Otherwise, -1
//
//----------------------------------------------------------------------------

#pragma warning(default:4706)           // Assignment within a conditional

int
CView::FindTask(
    const CAryVTasks *  pTaskList,
    const CViewTask &   vt) const
{
    int     i;
    BOOL    fExactMatch = !!vt.GetObject();

    Assert(IsActive() || !(pTaskList->Size()));

    if (!IsActive())
        return -1;

    for (i = pTaskList->Size()-1; i >= 0; i--)
    {
        const CViewTask & vtCur = ((CAryVTasks &)(*pTaskList))[i];

        if (vtCur.IsFlagSet(LAYOUT_TASKDELETED))
            continue;
        
        //  If the _pv field is supplied, look for an exact match
        if (fExactMatch)
        {
            if (vt == vtCur)
                break;
        }

        //  Otherwise, match only on task type
        else
        {
            if (vt.IsType(vtCur))
                break;
        }
    }

    return i;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetTask
//
//  Synopsis:   Retrieve the a specific task from the appropriate task queue
//
//  Arguments:  vt - CViewTask to retrieve
//
//  Returns:    CViewTask pointer if found, NULL otherwise
//
//----------------------------------------------------------------------------

CViewTask *
CView::GetTask(
    const CViewTask & vt) const
{
    CAryVTasks *    paryTasks = GetTaskList(vt.GetType());
    int             iTask     = FindTask(paryTasks, vt);

    Assert(IsActive() || iTask < 0);
    Assert(iTask < 0 || !((* paryTasks)[iTask]).IsFlagSet(LAYOUT_TASKDELETED));

    return iTask >= 0
                ? &((* paryTasks)[iTask])
                : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetNextTask
//
//  Synopsis:   Retrieve the next task of the specified task type
//
//  Arguments:  vtt       - VIEWTASKTYPE to search for
//
//  Returns:    CViewTask pointer if found, NULL otherwise
//
//----------------------------------------------------------------------------

CViewTask *
CView::GetNextTask(
    CViewTask::VIEWTASKTYPE vtt ) const
{
    CViewTask *     pvtTask = NULL;
    CAryVTasks *    pTaskList = GetTaskList(vtt);
    int             cTasks;

    cTasks = pTaskList->Size();

    Assert(IsActive() || !cTasks);

    if (cTasks)
    {
        for (pvtTask = &((CAryVTasks &)(* pTaskList))[0];
             cTasks && (pvtTask->IsFlagSet(LAYOUT_TASKDELETED) || !pvtTask->IsType(vtt));
             pvtTask++, cTasks--);
    }

    Assert(cTasks <= 0 || !pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

    return (cTasks > 0
                ? pvtTask
                : NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetNextTaskInSourceOrder
//
//  Synopsis:   Retrieve the next task, in document source order, of the
//              specified task type
//
//  Arguments:  vtt       - VIEWTASKTYPE to search for
//              grfLayout - LAYOUT_MEASURE/POSITION/ADORNERS filter
//
//  Returns:    CViewTask pointer if found, NULL otherwise
//
//----------------------------------------------------------------------------

CViewTask *
CView::GetNextTaskInSourceOrder(
    CViewTask::VIEWTASKTYPE vtt,
    DWORD                   grfLayout) const
{
    CViewTask *     pvtTask   = NULL;
    CAryVTasks *    pTaskList = GetTaskList(vtt);
    int             cTasks;

    cTasks = pTaskList->Size();

    Assert(IsActive() || !cTasks);

    if (cTasks > 1)
    {
        CViewTask * pvt;
        int         si, siTask;

        siTask = INT_MAX;

        for (pvt = &((CAryVTasks &)(* pTaskList))[0]; cTasks; pvt++, cTasks--)
        {
            if (    !pvt->IsFlagSet(LAYOUT_TASKDELETED)
                &&  pvt->IsFlagsSet(grfLayout)
                &&  pvt->IsType(vtt))
            {
                Assert(pvt->GetObject());

                si = pvt->GetSourceIndex();
                if (si < siTask)
                {
                    siTask  = si;
                    pvtTask = pvt;
                }
            }
        }
    }
    else if (   cTasks
            &&  !((CAryVTasks &)(* pTaskList))[0].IsFlagSet(LAYOUT_TASKDELETED)
            &&  ((CAryVTasks &)(* pTaskList))[0].IsFlagsSet(grfLayout)
            &&  ((CAryVTasks &)(* pTaskList))[0].IsType(vtt))
    {
        Assert(cTasks == 1);
        pvtTask = &((CAryVTasks &)(* pTaskList))[0];
    }

    Assert(!pvtTask || !pvtTask->IsFlagSet(LAYOUT_TASKDELETED));

    return pvtTask;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveTask
//
//  Synopsis:   Remove a task from the view-task queue
//
//              NOTE: This routine is safe to call with non-existent tasks
//
//  Arguments:  iTask - Index of task to remove, -1 the task is non-existent
//
//----------------------------------------------------------------------------

void
CView::RemoveTask(
    CAryVTasks * pTaskList, int iTask)
{
    Assert(IsActive() || !(pTaskList->Size()));

    if (iTask >= 0 && iTask < pTaskList->Size())
    {
        if (    pTaskList != &_aryTaskLayout
            ||  !IsLockSet(VL_TASKSINPROGRESS))
        {
            pTaskList->Delete(iTask);
        }
        else
        {
            (*pTaskList)[iTask]._grfLayout |= LAYOUT_TASKDELETED;
        }
    }
}

#ifdef ADORNERS
//+---------------------------------------------------------------------------
//
//  Member:     AddAdorner
//
//  Synopsis:   Add a CAdorner to the list of adorners
//
//              Adorners are kept in order by their start cp. If two (or more)
//              have the same start cp, they are sorted by their end cp.
//
//  Arguments:  pAdorner - CAdorner to add
//
//----------------------------------------------------------------------------

HRESULT
CView::AddAdorner(
    CAdorner *  pAdorner)
{
    long    cpStartNew, cpEndNew;
    long    iAdorner, cAdorners;
    HRESULT hr = E_FAIL;

    if (IsActive())
    {
        Assert(pAdorner);

        pAdorner->GetRange(&cpStartNew, &cpEndNew);

        iAdorner  = 0;
        cAdorners = _aryAdorners.Size();

        if (cAdorners)
        {
            CAdorner ** ppAdorner;
            long        cpStart, cpEnd;

            for (ppAdorner = &(_aryAdorners[0]);
                iAdorner < cAdorners;
                iAdorner++, ppAdorner++)
            {
                (*ppAdorner)->GetRange(&cpStart, &cpEnd);

                if (    cpStartNew < cpStart
                    ||  (   cpStartNew == cpStart
                        &&  cpEndNew   <  cpEnd))
                    break;
            }
        }

        Assert(iAdorner <= cAdorners);

        hr = _aryAdorners.InsertIndirect(iAdorner, &pAdorner);

        if (SUCCEEDED(hr))
        {
            CElement *  pElement = pAdorner->GetElement();

            Verify(OpenView());
            Assert( cpEndNew >= cpStartNew );
            AccumulateMeasuredRange( cpStartNew , (cpEndNew - cpStartNew) );


            if (    pElement
                &&  pElement->ShouldHaveLayout())
            {
                pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->SetIsAdorned(TRUE);
            }
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     DeleteAdorners
//
//  Synopsis:   Delete and remove all adorners
//
//----------------------------------------------------------------------------

void
CView::DeleteAdorners()
{
    long    iAdorner  = 0;
    long    cAdorners = _aryAdorners.Size();

    Assert(IsActive() || !cAdorners);

    if (cAdorners)
    {
        CAdorner ** ppAdorner;

        for (ppAdorner = &(_aryAdorners[0]);
            iAdorner < cAdorners;
            iAdorner++, ppAdorner++)
        {
            (*ppAdorner)->Destroy();
        }

        _aryAdorners.DeleteAll();

        _pFocusAdorner = NULL;
    }

    Assert(!_pFocusAdorner);
}

//+---------------------------------------------------------------------------
//
//  Member:     GetAdorner
//
//  Synopsis:   Find the next adorner associated with the passed element
//
//  Arguments:  pElement  - CElement associated with the adorner
//              piAdorner - Index at which to begin the search
//
//  Returns:    Index of adorner if found, -1 otherwise
//
//----------------------------------------------------------------------------

long
CView::GetAdorner(
    CElement *  pElement,
    long        iAdorner) const
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (!IsActive())
        return -1;

    long    cAdorners = _aryAdorners.Size();

    Assert(iAdorner >= 0);

    if (iAdorner < cAdorners)
    {
        CAdorner ** ppAdorner;

        for (ppAdorner = &(((CAryAdorners &)_aryAdorners)[iAdorner]);
            iAdorner < cAdorners;
            iAdorner++, ppAdorner++)
        {
            if ((*ppAdorner)->GetElement() == pElement)
                break;
        }
    }

    return iAdorner < cAdorners
                ? iAdorner
                : -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     RemoveAdorner
//
//  Synopsis:   Remove the specified adorner
//
//  Arguments:  pAdorner - CAdorner to remove
//
//----------------------------------------------------------------------------

void
CView::RemoveAdorner(
    CAdorner *  pAdorner,
    BOOL        fCheckForLast)
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (IsActive())
    {
        CElement *  pElement = pAdorner->GetElement();

        Assert(IsInState(VS_OPEN));

        if (_aryAdorners.DeleteByValueIndirect(&pAdorner))
        {
            pAdorner->Destroy();
        }

        if (    fCheckForLast
            &&  pElement
            &&  pElement->CurrentlyHasAnyLayout())
        {
            pElement->GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->SetIsAdorned(HasAdorners(pElement));
        }
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     CBiew::CompareZOrder
//
//  Synopsis:   Compare the z-order of two display nodes
//
//  Arguments:  pDispNode1 - Display node owned by this display client
//              pDispNode2 - Display node to compare against
//
//  Returns:    Greater than zero if pDispNode1 is greater
//              Less than zero if pDispNode1 is less
//              Zero if they are equal
//
//----------------------------------------------------------------------------

//
// TO BE USED FOR ADORNER COMPARISONS ONLY. Otherwise we return 0.
//

long        
CView::CompareZOrder(CDispNode const* pDispNode1, CDispNode const* pDispNode2)
{
    int i;
    int indexDisp1 = -1;
    int indexDisp2 = -1;
    
    for ( i = 0; i < _aryAdorners.Size(); i ++ )
    {
        if ( _aryAdorners[i]->GetDispNode() == pDispNode1)
        {
            indexDisp1 = i;
            if ( indexDisp2 != - 1)
                break;
        }

        if ( _aryAdorners[i]->GetDispNode() == pDispNode2)
        {
            indexDisp2 = i;
            if ( indexDisp1 != - 1)
                break;
        }        
    }

    if ( indexDisp1 != -1 && indexDisp2 != -1 )
    {
        return indexDisp1 <= indexDisp2 ? 1 : - 1;
    }
    else
        return 0;
}

#endif // ADORNERS

//+---------------------------------------------------------------------------
//
//  Member:     AccumulateMeasuredRanged
//
//  Synopsis:   Accumulate the measured range
//
//  Arguments:  cp  - First character of the range
//              cch - Number of characters in the range
//
//----------------------------------------------------------------------------

void
CView::AccumulateMeasuredRange(
    long    cp,
    long    cch)
{
    if (IsActive())
    {
        long    cpEnd = cp + cch;

        Assert(IsInState(VS_OPEN));

        if (_cpStartMeasured < 0)
        {
            _cpStartMeasured = cp;
            _cpEndMeasured   = cpEnd;
        }
        else
        {
            _cpStartMeasured = min(_cpStartMeasured, cp);
            _cpEndMeasured   = max(_cpEndMeasured,   cpEnd);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     AccumulateTranslatedRange
//
//  Synopsis:   Accumulate the translated range
//
//  Arguments:  size - Amount of translation
//              cp   - First character of the range
//              cch  - Number of characters in the range
//
//----------------------------------------------------------------------------

void
CView::AccumulateTranslatedRange(
    const CSize &   size,
    long            cp,
    long            cch)
{
    if (IsActive())
    {
        long    cpEnd = cp + cch;

        Assert(IsInState(VS_OPEN));

        if (_cpStartTranslated < 0)
        {
            _cpStartTranslated = cp;
            _cpEndTranslated   = cpEnd;
            _sizeTranslated    = size;
        }
        else
        {
            _cpStartTranslated = min(_cpStartTranslated, cp);
            _cpEndTranslated   = max(_cpEndTranslated,   cpEnd);

            if (_sizeTranslated != size)
            {
                _sizeTranslated = g_Zero.size;
            }
        }
    }
}

#ifdef ADORNERS
//+---------------------------------------------------------------------------
//
//  Member:     UpdateAdorners
//
//  Synopsis:   Notify the adorners within the measured and translated ranges
//              possible size/position changes
//
//  Arguments:  grfLayout - Current LAYOUT_xxxx flags
//
//----------------------------------------------------------------------------

void
CView::UpdateAdorners(
    DWORD   grfLayout)
{
    Assert(IsActive() || !_aryAdorners.Size());

    if (!IsActive())
        return;

    Assert( _cpStartMeasured <  0
        ||  _cpEndMeasured   >= 0);
    Assert(_cpStartMeasured <= _cpEndMeasured);
    Assert( _cpStartTranslated <  0
        ||  _cpEndTranslated   >= 0);
    Assert(_cpStartTranslated <= _cpEndTranslated);

    // <bug 33937 cure>
    // This addition can force _pFocusAdorner to be handled twice.
    // Optimization is discarded in favor of smaller code change.
    if (_bUpdateFocusAdorner)
    {
        _bUpdateFocusAdorner = FALSE;
        if(_pFocusAdorner)
        {
            _pFocusAdorner->ShapeChanged();
            _pFocusAdorner->PositionChanged();
        }
    }
    // </bug 33937 cure>

    //
    //  If adorners and a dirty range exists, update the affected adorners
    //

    if (    _aryAdorners.Size()
        &&  HasDirtyRange())
    {
        long        iAdorner;
        long        cAdorners;
        long        cpStart, cpEnd;
        long        cpFirst, cpLast;
        CAdorner ** ppAdorner;

        //
        // TODO marka - profile this sometime. Is it worth maintaining array of adorners sorted by cp ?
        // 
        
        cAdorners = _aryAdorners.Size();

        cpFirst = LONG_MAX;
        cpLast = LONG_MIN;

        for(long i = 0; i < cAdorners; i++)
        {
            _aryAdorners[i]->GetRange(&cpStart, &cpEnd);
    
            cpFirst = min(cpFirst, cpStart);
            cpLast  = max(cpLast, cpEnd);
        }

        //
        //  If a measured range intersects the adorners, update the affected adorners
        //

        if (    HasMeasuredRange() 
            && IsRangeCrossRange(cpFirst, cpLast, _cpStartMeasured, _cpEndMeasured))
        {
            //
            //  Find the first adorner to intersect the range
            //

            cpStart = LONG_MAX;
            cpEnd   = LONG_MIN;

            iAdorner  = 0;
            cAdorners = _aryAdorners.Size();

            for (ppAdorner = &(_aryAdorners[iAdorner]);
                iAdorner < cAdorners;
                iAdorner++, ppAdorner++)
            {
                (*ppAdorner)->GetRange(&cpStart, &cpEnd);

                if (cpEnd >= _cpStartMeasured)
                    break;
            }

            //
            //  Notify all adorners that intersect the range
            //

            cAdorners -= iAdorner;

            if (cAdorners)
            {
                // bug 99829, the adorener is at the end of the document
                // so cpStart and _cpEndMeasured are equal.
                while (cpStart <= _cpEndMeasured)
                {
                    (*ppAdorner)->ShapeChanged();
                    (*ppAdorner)->PositionChanged();

                    CHECKRECURSION();

                    cAdorners--;
                    if (!cAdorners)
                        break;

                    ppAdorner++;
                    (*ppAdorner)->GetRange(&cpStart, &cpEnd);
                }
            }
        }

        //
        //  If a translated range intersects the adorners, update the affected adorners
        //

        if (    HasTranslatedRange()
            && IsRangeCrossRange(cpFirst, cpLast, _cpStartTranslated, _cpEndTranslated))
        {
            CSize * psizeTranslated;

            //
            //  If a measured range exists,
            //  shrink the translated range such that they do not overlap
            //

            if (HasMeasuredRange())
            {
                if (_cpEndMeasured <= _cpEndTranslated)
                {
                    _cpStartTranslated = max(_cpStartTranslated, _cpEndMeasured);
                }

                if (_cpStartMeasured >= _cpStartTranslated)
                {
                    _cpEndTranslated = min(_cpEndTranslated, _cpStartMeasured);
                }

                //
                // marka - Translated can be < Measured range
                //
                if ( ( _cpEndTranslated < _cpEndMeasured ) &&
                     ( _cpStartTranslated > _cpStartMeasured ) )
                {
                    _cpEndTranslated = 0;
                    _cpStartTranslated = 0;
                }
            }

            if (_cpStartTranslated < _cpEndTranslated)
            {
                //
                //  Find the first adorner to intersect the range
                //

                cpStart = LONG_MAX;
                cpEnd   = LONG_MIN;

                iAdorner  = 0;
                cAdorners = _aryAdorners.Size();

                psizeTranslated = _sizeTranslated != g_Zero.size
                                        ? &_sizeTranslated
                                        : NULL;

                for (ppAdorner = &(_aryAdorners[iAdorner]);
                    iAdorner < cAdorners;
                    iAdorner++, ppAdorner++)
                {
                    (*ppAdorner)->GetRange(&cpStart, &cpEnd);

                    if (cpStart >= _cpStartTranslated)
                        break;
                }

                //
                //  Notify all adorners that intersect the range
                //

                cAdorners -= iAdorner;

                if (cAdorners)
                {
                    while (cpStart < _cpEndTranslated)
                    {
                        (*ppAdorner)->PositionChanged(psizeTranslated);

                        CHECKRECURSION();

                        cAdorners--;
                        if (!cAdorners)
                            break;

                        ppAdorner++;
                        (*ppAdorner)->GetRange(&cpStart, &cpEnd);
                    }
                }
            }
        }
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::SetRenderSurface
//
//  Synopsis:   Set destination rendering surface.
//
//  Arguments:  hdc         DC destination
//              pSurface    IDirectDrawSurface
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CView::SetRenderSurface(
        const XHDC& hdc,
        IDirectDrawSurface *pDDSurface)
{
    if (_pRenderSurface)
        delete _pRenderSurface;
    _pRenderSurface = NULL;
    
    if (!hdc.IsEmpty())
        _pRenderSurface = new CDispSurface(hdc);
    else if (pDDSurface)
        _pRenderSurface = new CDispSurface(pDDSurface);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::SetOffscreenBuffer
//              
//  Synopsis:   The primary place of policy regarding our offscreen buffering
//              The only other policy is in the CDispSurface->IsCompat that
//              determines if a cached surface is acceptable.
//              
//  Arguments:  
//              
//  Notes:      fWantOffscreen indicates that the document (and host) want offscreen buffering
//              fAllowOffscreen indicates that the document (and host) will allow offscreen buffering
//              
//----------------------------------------------------------------------------
void
CView::SetOffscreenBuffer(HPALETTE hpal, short bufferDepth, BOOL fDirectDraw, BOOL fTexture, BOOL fWantOffscreen, BOOL fAllowOffscreen)
{
    PerfDbgExtern(tagOscUseDD);
    PerfDbgExtern(tagNoTile);
    PerfDbgExtern(tagOscFullsize);
    PerfDbgExtern(tagOscTinysize);
    PerfDbgExtern(tagNoOffScr);

    Assert(_pRenderSurface != NULL);
    
    // If the host won't allow offscreen buffering then we won't do it
    if (!fAllowOffscreen)
    {
        ReleaseOffscreenBuffer();
        return;
    }

    HDC hdc = _pRenderSurface->GetRawDC();

    short bufferDepthDestination = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);

    if (bufferDepth == -1)
        fDirectDraw = TRUE;

    if (bufferDepth <= 0)
        bufferDepth = bufferDepthDestination;

#if DBG == 1
    if (IsTagEnabled(tagOscUseDD))
        fDirectDraw = TRUE;
#endif

    if (bufferDepth != bufferDepthDestination)
    {
        fDirectDraw = TRUE;     // GDI can't buffer at a bit depth different from the destination
        fWantOffscreen = TRUE;
    }
    else if (fDirectDraw && !_pRenderSurface->VerifyGetSurfaceFromDC())
        fWantOffscreen = TRUE;

    // If we can avoid buffering, we should

    if (!fWantOffscreen)
    {
        ReleaseOffscreenBuffer();
        return;
    }

    // We are definitely going to buffer offscreen
    // Now we determine the size of the buffer

    CSize sizeBuffer = _pDispRoot->GetSize();

    //
    // If we're using DD then we don't tile.  This is mostly because DA and filters don't handle
    // banding very well.  We really need a new status bit that indicates poor tiling support
    //

#ifndef MAC
    if (!fDirectDraw)
        sizeBuffer.cy = s_cBUFFERLINES;
#endif

#if DBG == 1
    if (IsTagEnabled(tagOscFullsize))
    {
        sizeBuffer.cy = _pDispRoot->GetSize().cy;
    }
    else if (IsPerfDbgEnabled(tagOscTinysize))
    {
        sizeBuffer.cy = 8;
    }
    else if (fDirectDraw && IsTagEnabled(tagOscForceDDBanding))
    {
        sizeBuffer.cy = s_cBUFFERLINES;
    }
#endif

    Assert(sizeBuffer.cx > 0 && sizeBuffer.cy > 0);

    if (!_pOffscreenBuffer || !_pOffscreenBuffer->IsCompat(sizeBuffer.cx, sizeBuffer.cy, bufferDepth, hpal, fDirectDraw, fTexture))
    {
        ReleaseOffscreenBuffer();

        // if we get this far under TerminalServer, ask whether it supports
        // a big enough client-side bitmap before proceeding.  This code
        // came from the TerminalServer folks.

        if (g_fTerminalServer && !fDirectDraw &&
            !Doc()->_pOptionSettings->fForceOffscreen &&
            ! ( _pRenderSurface->GetRawDC() == _hdcTSBufferFailed &&
                sizeBuffer == _sizeTSBufferFailed )
            )
        {
            ICA_DEVICE_BITMAP_INFO info;
            INT rc, bSucc;

            info.cx = sizeBuffer.cx;
            info.cy = sizeBuffer.cy;

            bSucc = ExtEscape(
                        _pRenderSurface->GetRawDC(),
                        ESC_GET_DEVICEBITMAP_SUPPORT,
                        sizeof(info),
                        (LPSTR)&info,
                        sizeof(rc),
                        (LPSTR)&rc
                        );

            // if TS won't support the client-side bitmap for the buffer,
            // remember the DC and size so we don't keep making the same
            // doomed call.

            if (!bSucc || !rc)
            {
                _hdcTSBufferFailed = _pRenderSurface->GetRawDC();
                _sizeTSBufferFailed = sizeBuffer;
                return;
            }
            else
            {
                _hdcTSBufferFailed = NULL;
            }
        }

        _pOffscreenBuffer = _pRenderSurface->CreateBuffer(
            sizeBuffer.cx, 
            sizeBuffer.cy, 
            bufferDepth,
            hpal, 
            fDirectDraw,
            fTexture);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CView::ReleaseOffscreenBuffer
//
//  Synopsis:   Release the buffer used to perform offscreen rendering.
//
//  Arguments:  none
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CView::ReleaseOffscreenBuffer()
{
    delete _pOffscreenBuffer;
    _pOffscreenBuffer = NULL;
}

                
//+---------------------------------------------------------------------------
//
//  Member:     CView::ReleaseRenderSurface
//
//  Synopsis:   Release the surface used for rendering.
//
//  Arguments:  none
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CView::ReleaseRenderSurface()
{
    delete _pRenderSurface;
    _pRenderSurface = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CView::SmoothScroll
//
//  Synopsis:   Set new scroll offset smoothly if appropriate.
//
//  Arguments:  offset          new scroll offset
//              fScrollBits     TRUE if we should try to scroll bits on screen
//
//  Notes:
//
//----------------------------------------------------------------------------

#define MAX_SCROLLS 50

BOOL
CView::SmoothScroll(
        const SIZE& offset,
        CLayout * pLayout,
        BOOL fScrollBits,
        LONG lScrollTime)
{
    CDispNode        * pDispNode;
    CDispScroller    * pScroller = NULL;
    BOOL               fReturn = TRUE;

    pDispNode = pLayout->GetElementDispNode();
    if(!(pDispNode && pDispNode->IsScroller()))
    {
        fReturn = FALSE;
        goto Cleanup;
    }
    pScroller = CDispScroller::Cast(pDispNode);

    // determine if smooth scrolling is enabled
    if (fScrollBits 
        && AllowSmoothScrolling() 
        && lScrollTime > 0 
        && pScroller->IsInView() 
        && pScroller->IsVisibleBranch())
    {
        CSize scrollDelta(offset + pScroller->GetScrollOffsetInternal());
        int axis = (scrollDelta.cx != 0 ? 0 : 1);
        LONG cScrolls = min((long)MAX_SCROLLS, (long)abs(scrollDelta[axis]));
        LONG cScrollsDone = 0;
        CSize perScroll(g_Zero.size);
        CSize sizeScrollRemainder = scrollDelta;
        DWORD dwStart = GetTickCount(), dwTimer;
    
        while (cScrolls > 0)
        {
            perScroll[axis] = sizeScrollRemainder[axis] / (cScrolls--);
            sizeScrollRemainder[axis] -= perScroll[axis];

            if (!pScroller->SetScrollOffset(
                    perScroll - pScroller->GetScrollOffsetInternal(), fScrollBits))
            {
                fReturn = FALSE;
                goto Cleanup;
            }

            // Calling SetScrollOffset may replace the pDispNode, so get it again
            pDispNode = pLayout->GetElementDispNode();
            if(!(pDispNode && pDispNode->IsScroller()))
            {
                fReturn = FALSE;
                goto Cleanup;
            }
            pScroller = CDispScroller::Cast(pDispNode);

            // Obtain new cScrolls.
            dwTimer = GetTickCount();
            cScrollsDone++;
            if (cScrolls && dwTimer != dwStart)
            {
                // See how many cScrolls we have time for by dividing the remaining time
                // by duration of last scroll, but don't increase the number (only speed up).
                LONG cSuggestedScrolls = MulDivQuick(cScrollsDone, lScrollTime - (dwTimer - dwStart), dwTimer - dwStart);
                if (cSuggestedScrolls <= 1)
                    cScrolls = 1;
                else if (cSuggestedScrolls < cScrolls)
                    cScrolls = cSuggestedScrolls;
            }
        }
        Assert(sizeScrollRemainder[axis] == 0);
    }
    else
    {
        fReturn = pScroller->SetScrollOffset(offset, fScrollBits);
    }


Cleanup:
    return fReturn;
}


CView::CEnsureDisplayTree::CEnsureDisplayTree(
    CView * pView)
{
    Assert(pView);
    _pView     = pView;
    _fTreeOpen =  TRUE;

    LONG cnt = InterlockedIncrement((LONG*)&(_pView->_cEnsureDisplayTree));
    if (cnt == 1 || (_pView->GetDisplayTree() && !_pView->GetDisplayTree()->DisplayTreeIsOpen()) )
    {
        if(cnt == 1)
        {
            _fTreeOpen = pView->IsFlagSet(VF_TREEOPEN);
        }
        _pView->EnsureDisplayTreeIsOpen();
    }
}


CView::CEnsureDisplayTree::~CEnsureDisplayTree()
{
    Assert(_pView);
    Assert(_pView->_cEnsureDisplayTree > 0);

    LONG cnt = InterlockedDecrement((LONG*)&(_pView->_cEnsureDisplayTree));
    if (cnt == 0 )
    {
        if(!_fTreeOpen)
        {
            _pView->CloseDisplayTree();
        }
    }
    else if(!_pView->IsFlagSet(VF_TREEOPEN))
    {
        _pView->EnsureDisplayTreeIsOpen();
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CView::GetMessageHookProc
//
//  Synopsis:     This is the callback for GetMessage hook (see comments at
//              CreateVBControlClipHook). It fiters out one certain message and
//              sets a special state property on window indicating that it
//              can remove the hook.
//  Arguments: 
//----------------------------------------------------------------------------

static LRESULT CALLBACK 
GetMessageHookProc(int  nCode, WPARAM  wParam, LPARAM  lParam)
{
    MSG             * msg;
    THREADSTATE *   pts;

    pts = GetThreadState();
    if(pts == NULL)
        return 0;

    if(nCode < 0)
        return CallNextHookEx(pts->_hHookHandle, nCode, wParam, lParam);

    Assert(HC_ACTION == nCode);

    msg = (MSG *)lParam;
    
    if(GetProp(msg->hwnd, VBCTRLHOOK_PROPNAME) == VBCTRLHOOK_SET)
    {
        // This is a VB control window
        if(msg->message == VBCTRLHOOK_MSGTOFILTER)
        {
            // Change the message to WM_NULL so that it is ignored
            msg->message = WM_NULL;
            SetProp(msg->hwnd, VBCTRLHOOK_PROPNAME, VBCTRLHOOK_FILTERED);
        }
    }

     return CallNextHookEx(pts->_hHookHandle, nCode, wParam, lParam);
}



//+---------------------------------------------------------------------------
//
//  Member:     CView::CreateVBControlClipHook
//
//  Synopsis:     Installs a GetMessage hook on the thread in order to capture the
//              message some VB controls post to themselves that resets their window
//              clip to the whole window (IE6 bug 13321).
//                The window is also marked with a special property indicating that
//              the window needs filtering of the message.
//                If we already have a hook in place the function just addrefs it and
//  Arguments:  hwnd - the control window that is filtered
//----------------------------------------------------------------------------

HHOOK
CView::CreateVBControlClipHook(HWND hwnd)
{
    THREADSTATE *   pts;

    pts = GetThreadState();
    if(pts == NULL)
        return 0;

    Assert(pts->_cHookRequests >= 0);

    SetProp(hwnd, VBCTRLHOOK_PROPNAME, VBCTRLHOOK_SET);

    if(pts->_cHookRequests == 0)
    {
        pts->_hHookHandle = SetWindowsHookEx(WH_GETMESSAGE, GetMessageHookProc, NULL, GetCurrentThreadId());
    }

    pts->_cHookRequests++;
    
    Assert(pts->_hHookHandle);

    return pts->_hHookHandle;
}


//+---------------------------------------------------------------------------
//
//  Member:     CView::RemoveVBControlClipHook
//
//  Synopsis:     Decrements the refcount on the GetMessage hook (see comments at
//              CreateVBControlClipHook). If the refcount is 0 removes the GetMessage hook.
//                Should be called only for windows that use the hook.
//  Arguments:  hwnd - the control window that is filtered
//----------------------------------------------------------------------------

BOOL
CView::RemoveVBControlClipHook(HWND hwnd)
{
    THREADSTATE  * pts;
    BOOL           fRet = TRUE;

    pts = GetThreadState();
    if(pts == NULL)
        return FALSE;

    Assert(pts->_cHookRequests > 0);

    Verify(RemoveProp(hwnd, VBCTRLHOOK_PROPNAME));

    pts->_cHookRequests--;
    if(pts->_cHookRequests == 0)
    {
        fRet  = UnhookWindowsHookEx(pts->_hHookHandle);
        pts->_hHookHandle = NULL;
    }

    return fRet;
}





#if DBG==1
//+------------------------------------------------------------------------
//
//  Function:   DumpRegion
//
//  Synopsis:   Write region to debug output
//
//-------------------------------------------------------------------------

void
DumpRegion(
    HRGN    hrgn)
{
    if (hrgn == NULL)
        return;

    struct REGIONDATA
    {
        RGNDATAHEADER   rdh;
        RECT            arc[128];
    } data;

    RGNDATA *pData;
    DWORD dwSize = ::GetRegionData(hrgn, 0, NULL);

    if (dwSize <= sizeof(data))
    {
        pData = (RGNDATA *)&data;
        dwSize = sizeof(data);
    }
    else
    {
        pData = (RGNDATA *) new BYTE[dwSize];
    }

    if (::GetRegionData(hrgn, dwSize, pData) > 0)
    {
        REGIONDATA *p = (REGIONDATA*)pData;

        TraceTagEx((0, TAG_NONAME, "    HRGN(0x%x) iType(%d) nCount(%d) nRgnSize(%d) rcBound(%d,%d,%d,%d)",
                hrgn,
                p->rdh.iType,
                p->rdh.nCount,
                p->rdh.nRgnSize,
                p->rdh.rcBound.left,
                p->rdh.rcBound.top,
                p->rdh.rcBound.right,
                p->rdh.rcBound.bottom));

        for (DWORD i = 0; i < p->rdh.nCount; i++)
        {
            TraceTagEx((0, TAG_NONAME, "        rc(%d,%d,%d,%d)",
                p->arc[i].left,
                p->arc[i].top,
                p->arc[i].right,
                p->arc[i].bottom));
        }
    }
    else
    {
        TraceTag((0, "    HRGN(0x%x): Buffer too small", hrgn));
    }

    if (pData != (RGNDATA *)&data)
    {
        delete pData;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   DumpClipRegion
//
//  Synopsis:   Write clip region of hdc to debug output
//
//-------------------------------------------------------------------------

void
DumpClipRegion(
    HDC    hdc)
{
    HRGN    hrgn = ::CreateRectRgn(0,0,0,0);
    RECT    rc;

    if (hrgn)
    {
        switch (::GetClipRgn(hdc, hrgn))
        {
        case 1:
            DumpRegion(hrgn);
            break;

        case 0:
            switch (::GetClipBox(hdc, &rc))
            {
            case SIMPLEREGION:
                TraceTagEx((0, TAG_NONAME, "HDC(0x%x) has SIMPLE clip region rc(%d,%d,%d,%d)",
                        hdc,
                        rc.left,
                        rc.top,
                        rc.right,
                        rc.bottom));
                break;

            case COMPLEXREGION:
                TraceTagEx((0, TAG_NONAME, "HDC(0x%x) has COMPLEX clip region rc(%d,%d,%d,%d)",
                        hdc,
                        rc.left,
                        rc.top,
                        rc.right,
                        rc.bottom));
                break;

            default:
                TraceTagEx((0, TAG_NONAME, "HDC(0x%x) has NO clip region", hdc));
                break;
            }
            break;

        default:
            TraceTagEx((0, TAG_NONAME, "HDC(0x%x) Aaack! Error obtaining clip region", hdc));
            break;
        }

        ::DeleteObject(hrgn);
    }
}

//+------------------------------------------------------------------------
//
//  Function:   DumpHDC
//
//  Synopsis:   Write info about hdc to debug output
//
//-------------------------------------------------------------------------

void
DumpHDC(HDC hdc)
{
    if (hdc)
    {
        POINT ptOrig;

        ::GetViewportOrgEx(hdc, &ptOrig);

        TraceTagEx((0, TAG_NONAME, "HDC(0x%x) origin at (%ld,%ld)",
                        hdc, ptOrig.x, ptOrig.y));

        DumpClipRegion(hdc);
    }
    else
    {
        TraceTagEx((0, TAG_NONAME, "HDC(0x%x) is null"));
    }
}
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\srv\stdafx.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       STDAFX.CXX
//
//  Contents:   Source file that includes pre-compiled header stuff
//
//-------------------------------------------------------------------------

#include "headers.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\srv\mshtmsrv.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      mshtmlsrv.cxx
//
//  Contents:   MSHTML Server Side Application Object and DLL entry points
//
//  Classes:    CServerApp
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif


DeclareTag(tagIISCalls, "TridentOnServer", "Raw IIS Calls");

//
// Misc stuff to keep the linker happy
//
DWORD               g_dwFALSE = 0;          // Used for assert to fool the compiler
EXTERN_C HANDLE     g_hProcessHeap = NULL;  // g_hProcessHeap is set by the CRT in dllcrt0.c
HINSTANCE           g_hInstance = NULL;

CServerApp        * g_pApp = NULL;


//+----------------------------------------------------------------------------
//
// Function: DllMain
//
//+----------------------------------------------------------------------------
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{

    return TRUE;    
}

//+----------------------------------------------------------------------------
//
// IIS Filter Entry Points
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function: GetFilterVersion
//
//+----------------------------------------------------------------------------
BOOL WINAPI GetFilterVersion(HTTP_FILTER_VERSION *pVer)
{
    HRESULT     hr;

    TraceTag((tagIISCalls, "GetFilterVersion, Server Version: %08lX", pVer->dwServerFilterVersion));

    hr = THR(CServerApp::AddRefApp());
    if (!hr)
        return g_pApp->GetIISFilter()->GetVersion(pVer);
    else
        return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function: HttpFilterProc
//
//+----------------------------------------------------------------------------
DWORD WINAPI HttpFilterProc(HTTP_FILTER_CONTEXT *pfc, DWORD dwNotifType, LPVOID pvNotification)
{
    TraceTag((tagIISCalls, "HttpFilterProc"));

    Assert(g_pApp);
    return g_pApp->GetIISFilter()->FilterProc(pfc, dwNotifType, pvNotification);
}


//+----------------------------------------------------------------------------
//
// Function: TerminateFilter
//
//+----------------------------------------------------------------------------
BOOL WINAPI TerminateFilter(DWORD dwFlags)
{
    TraceTag((tagIISCalls, "TerminateFilter"));

    Assert(g_pApp);
    return g_pApp->GetIISFilter()->Terminate(dwFlags);
}


//+----------------------------------------------------------------------------
//
// IIS Extension Entry Points
//
//+----------------------------------------------------------------------------

/*---------------------------------------------------------------------*
GetExtensionVersion

*/
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pextver) 
{
    HRESULT     hr;

    TraceTag((tagIISCalls, "GetExtensionVersion"));

    hr = THR(CServerApp::AddRefApp());
    if (!hr)
        return g_pApp->GetIISExtension()->GetVersion(pextver);
    else
        return FALSE;
}

/*---------------------------------------------------------------------*
TerminateExtension

*/

BOOL __stdcall TerminateExtension(DWORD flag) 
{
    TraceTag((tagIISCalls, "TerminateExtension"));
    Assert(g_pApp);
	return g_pApp->GetIISExtension()->Terminate(flag);
}

/*---------------------------------------------------------------------*
HttpExtensionProc

*/

DWORD __stdcall HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB) 
{
    TraceTag((tagIISCalls, "HttpExtensionProc"));

    Assert(g_pApp);
	return g_pApp->GetIISExtension()->ExtensionProc(pECB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\srv\server.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      server.cxx
//
//  Contents:   Server App object implementation
//
//  Classes:    CServerApp
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif



//+----------------------------------------------------------------------------
//
// Method: constructor
//
//+----------------------------------------------------------------------------
CServerApp::CServerApp() :
    _lRef(1),
    _hTrident(NULL),
    _TridentNormalizeUA(NULL),
    _TridentGetDLText(NULL)
{
}


//+----------------------------------------------------------------------------
//
// Method: destructor
//
//+----------------------------------------------------------------------------
CServerApp::~CServerApp()
{
    Assert(0 == _lRef);
}


//+----------------------------------------------------------------------------
//
// Method: ReleaseApp
//
//+----------------------------------------------------------------------------
LONG
CServerApp::ReleaseApp()
{
    LONG        lRef = InterlockedDecrement(&_lRef);

    if (!lRef)
    {
        delete g_pApp;
        g_pApp = NULL;
    }

    return _lRef;
}

//+----------------------------------------------------------------------------
//
// Method: AddRefApp
//
//+----------------------------------------------------------------------------
HRESULT
CServerApp::AddRefApp()
{
    HRESULT     hr = S_OK;

    if (g_pApp)
    {
        InterlockedIncrement(&(g_pApp->_lRef));
        goto Cleanup;
    }

    g_pApp = new CServerApp;
    if (NULL == g_pApp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = g_pApp->Initialize();

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: Initialize
//
//+----------------------------------------------------------------------------
HRESULT
CServerApp::Initialize(void)
{
    HRESULT     hr = E_NOTIMPL;

    _hTrident = LoadLibraryEx(_T("MSHTML.DLL"), NULL, 0);
    if (_hTrident == NULL) 
        goto Cleanup;

    _TridentNormalizeUA = (TridentNormalizeUACall)GetProcAddress(_hTrident, "SvrTri_NormalizeUA");
    _TridentGetDLText = (TridentGetDLTextCall)GetProcAddress(_hTrident, "SvrTri_GetDLText");

    if (_TridentNormalizeUA == NULL || _TridentGetDLText == NULL) 
        goto Cleanup;

    //  TODO (tomfakes) Get this url from somewhere else
    lstrcpyA(_szExtensionUrl, "/Trident/mshtmsrv.dll?u=");

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: IsHTMLCached
//
//+----------------------------------------------------------------------------
BOOL
CServerApp::IsHTMLCached(LPSTR pszUrl)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\srv\filter.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      filter.cxx
//
//  Contents:   Http Filter object implementation
//
//  Classes:    CHttpFilter
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif


DWORD   CIISFilter::s_dwNotifyFlags = 
        SF_NOTIFY_ORDER_DEFAULT |
        SF_NOTIFY_PREPROC_HEADERS |
        SF_NOTIFY_URL_MAP;

ULONG   CIISFilter::s_ulTotalRequests = 0;
ULONG   CIISFilter::s_ulRequestsFoundInCache = 0;
ULONG   CIISFilter::s_ulRequestsToTrident = 0;

//+----------------------------------------------------------------------------
//
// Method: GetVersion
//
//+----------------------------------------------------------------------------
BOOL
CIISFilter::GetVersion(HTTP_FILTER_VERSION *pVer)
{
    BOOL        fRet = TRUE;
    DWORD       dwCurrentVersion = HTTP_FILTER_REVISION;    // Bug in httpfilt.h

    if (pVer->dwServerFilterVersion < dwCurrentVersion)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    pVer->dwFilterVersion       = dwCurrentVersion;
    strcpy(pVer->lpszFilterDesc, "MSHTMSRV 1.0");

    pVer->dwFlags = s_dwNotifyFlags;

Cleanup:
    return fRet;
}


//+----------------------------------------------------------------------------
//
// Method: Terminate
//
//+----------------------------------------------------------------------------
BOOL
CIISFilter::Terminate(DWORD)
{
    Assert(g_pApp);
    g_pApp->ReleaseApp();

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Method: FilterProc
//
//+----------------------------------------------------------------------------
DWORD           
CIISFilter::FilterProc(HTTP_FILTER_CONTEXT *pctx, DWORD dwNotifType, LPVOID pvNotification)
{
    DWORD       dwRet;
    HRESULT     hr = S_OK;

    // Only handle the notifications we registered for
    Assert((dwNotifType & s_dwNotifyFlags) == dwNotifType);
    Assert(g_pApp);

    switch (dwNotifType)
    {
    case SF_NOTIFY_PREPROC_HEADERS:
        hr = THR(PreProcHeaders(pctx, (HTTP_FILTER_PREPROC_HEADERS *) pvNotification));
        if (hr)
            goto Cleanup;

        break;

    case SF_NOTIFY_URL_MAP:
        hr = THR(UrlMap(pctx, (HTTP_FILTER_URL_MAP *) pvNotification));
        if (hr)
            goto Cleanup;

        break;

    default:
        Assert(FALSE);
        break;
    }

Cleanup:
    if (!hr)
    {
        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
    }
    else
    {
        dwRet = SF_STATUS_REQ_ERROR;
        SetLastError(hr);
    }

    return dwRet;
}


//+----------------------------------------------------------------------------
//
// Method: PreProcHeaders
//
//+----------------------------------------------------------------------------
HRESULT         
CIISFilter::PreProcHeaders(HTTP_FILTER_CONTEXT *pContext, HTTP_FILTER_PREPROC_HEADERS *pPreProc)
{
    HRESULT         hr = E_FAIL;    // TODO (tomfakes) better error code?
    CHAR            chUserAgent[256];
    DWORD           dwUA;
    ULONG           ulSize;
    BOOL            fRet;
        
    ulSize = sizeof(chUserAgent);
    fRet = pPreProc->GetHeader(pContext, "HTTP_USER_AGENT:", chUserAgent, &ulSize);
    if (!fRet) 
    {
        chUserAgent[0] = '\0';
    }

    // normalize UA
    fRet = g_pApp->NormalizeUA(chUserAgent, &dwUA);
    if (!fRet)
        goto Cleanup;

    if (dwUA != USERAGENT_IE5)
    {
        CHAR            chUrl[MAX_URL_LENGTH];
        ULONG           ulSize;
        BOOL            fRet;
        
        ulSize = sizeof(chUrl);
        fRet = pPreProc->GetHeader(pContext, "url", chUrl, &ulSize);
        if (!fRet) 
        {
            chUrl[0] = '\0';
        }

        //
        // Only do this stuff for HTML files, don't intercept ISAPI or CGI or ASP...
        //
        if (IsStaticHTMLFile(chUrl))
        {
            // If the HTML is cached, we need to make that call here.
            if (g_pApp->IsHTMLCached(chUrl))
            {
                //
                // TODO Redirect to the cached HTML
                //
                s_ulRequestsFoundInCache++;
            }
            else
            {
                //
                // Redirect to the Extension to invoke Trident
                //
                long    lExtLen = lstrlenA(g_pApp->GetExtensionUrl());

                ulSize++;       // Catch the trailing \0
                Assert((ulSize + lExtLen) < MAX_URL_LENGTH);
                memmove(chUrl +  lExtLen, chUrl, ulSize);
                memcpy(chUrl, (LPBYTE) g_pApp->GetExtensionUrl(), lExtLen);

                fRet = pPreProc->SetHeader(pContext, "url", chUrl);
                if (!fRet)
                    goto Cleanup;

                s_ulRequestsToTrident++;
            }
        }
    }
    // else - do nothing, there will be no re-direct and no cache lookup

    hr = S_OK;
    s_ulTotalRequests++;

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: UrlMap
//
//  This method can only be used to map physical paths of the same type, ie
//  static file to static file.  This method is only used in the case where
//  we find the item in the cache and need to return the path to that file
//  as the physical file for this url
//
//+----------------------------------------------------------------------------
HRESULT         
CIISFilter::UrlMap(HTTP_FILTER_CONTEXT *pContext, HTTP_FILTER_URL_MAP *pUrlMap)
{
    HRESULT         hr = S_OK;

//Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Method: IsStaticHTMLFile
//
//+----------------------------------------------------------------------------
BOOL
CIISFilter::IsStaticHTMLFile(LPCSTR pszUrl)
{
    //TODO (tomfakes) Make this a better test
    if (strncmp(pszUrl, g_pApp->GetExtensionUrl(), lstrlenA(g_pApp->GetExtensionUrl())))
        return FALSE;
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\srv\ext.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//   File:      ext.cxx
//
//  Contents:   Http Extension object implementation
//
//  Classes:    CHttpExtension
//
//  History:   03-Sep-98   tomfakes  Created
//------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_MSHTMSRV_HXX_
#define X_MSHTMSRV_HXX_
#include "mshtmsrv.hxx"
#endif

//+----------------------------------------------------------------------------
//
// Method: GetVersion
//
//+----------------------------------------------------------------------------
BOOL
CIISExtension::GetVersion(HSE_VERSION_INFO *pVer)
{
    BOOL        fRet = TRUE;

 	pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
	strcpy(pVer->lpszExtensionDesc, "MSHTMSRV 1.0");

    return fRet;
}


//+----------------------------------------------------------------------------
//
// Method: Terminate
//
//+----------------------------------------------------------------------------
BOOL
CIISExtension::Terminate(DWORD)
{
    Assert(g_pApp);
    g_pApp->ReleaseApp();

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Method: ExtensionProc
//
//+----------------------------------------------------------------------------
DWORD           
CIISExtension::ExtensionProc(LPEXTENSION_CONTROL_BLOCK pECB)
{
    DWORD       dwRet = HSE_STATUS_SUCCESS;

    // special request to dump the debug info
    if (lstrcmpA(pECB->lpszQueryString, "debug") == 0) 
    {
        DumpDebugInfo(pECB);
        goto Cleanup;
    }


Cleanup:
    return dwRet;
}


//+----------------------------------------------------------------------------
//
// Method: ReportError
//
//+----------------------------------------------------------------------------
void 
CIISExtension::ReportError(LPEXTENSION_CONTROL_BLOCK pECB, CHAR *errorText, CHAR *status) 
{
    if (status == NULL) {
        status = "500 Server Error";
    }

	(*pECB->ServerSupportFunction)(
		pECB->ConnID,
		HSE_REQ_SEND_RESPONSE_HEADER,
		status,
		NULL,
		(LPDWORD)"Content-Type: text/html\r\n\r\n"
		);

	static const char ErrorFormat[] = 
		"<HTML><HEAD><TITLE>MSHTML ISAPI Error</TITLE></HEAD><BODY>\r\n"
		"<H1>%s</H1><P><B>MSHTML ISAPI Error</B></P>\r\n"
		"<P>%s.</P>\r\n</BODY></HTML>";

	DWORD errorBufferSize = sizeof(ErrorFormat) + 256;
	CHAR errorBuffer[2048];
	wsprintfA(errorBuffer, ErrorFormat, status, errorText);
	DWORD errorBytes = strlen(errorBuffer);

	(*pECB->WriteClient)(
		pECB->ConnID,
		(LPVOID)errorBuffer,
		(LPDWORD)&errorBytes,
		0
		);
}


//+----------------------------------------------------------------------------
//
// Method: DumpDebugInfo
//
//+----------------------------------------------------------------------------
void 
CIISExtension::DumpDebugInfo(LPEXTENSION_CONTROL_BLOCK pECB) 
{
	(*pECB->ServerSupportFunction)(
		pECB->ConnID,
		HSE_REQ_SEND_RESPONSE_HEADER,
		"200 OK",
		NULL,
		(LPDWORD)"Content-Type: text/html\r\n\r\n"
		);

    char buf[256];

#define WRITEBUF()  { DWORD n = strlen(buf); \
                      (*pECB->WriteClient)(pECB->ConnID, buf, &n, 0); }

    // header

    wsprintfA(buf, "<HTML><HEAD><TITLE>MSHISAPI Statistics</TITLE></HEAD>\r\n");
    WRITEBUF();

    wsprintfA(buf, "<BODY><H2>MSHISAPI Statistics</H2>\r\n");
    WRITEBUF();

    // filter requests

    wsprintfA(buf, "<H3>Filter Requests:</H3><UL>\r\n");
    WRITEBUF();

    wsprintfA(buf, "<LI>Total number of requests: <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulTotalRequests);
    WRITEBUF();

    wsprintfA(buf, "<LI>Number of requests resolved from cache: <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulRequestsFoundInCache);
    WRITEBUF();

    wsprintfA(buf, "<LI>Number of requests passed to Trident: <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulRequestsToTrident);
    WRITEBUF();

    wsprintfA(buf, "<LI>Number of requests passed through (Client is IE5): <B>%d</B>\r\n", 
                  g_pApp->GetIISFilter()->s_ulTotalRequests - 
                    (g_pApp->GetIISFilter()->s_ulRequestsFoundInCache + 
                     g_pApp->GetIISFilter()->s_ulRequestsToTrident));
    WRITEBUF();

    wsprintfA(buf, "</UL>\r\n\r\n");
    WRITEBUF();

    // tail

    wsprintfA(buf, "\r\n\r\n</BODY></HTML>");
    WRITEBUF();

#undef WRITEBUF
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: animattr.cpp
//
//  Contents: ITIMEAnimationElement attributes
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "animelm.h"
#include "tokens.h"
#include "attr.h"

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TAE CTIMEAnimationBase

                // Function Name // Class   // Attr Accessor      // COM put_ fn     // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(TAE_Accumulate,    TAE,     GetAccumulateAttr,    put_accumulate,    get_accumulate,    VT_BSTR);
TIME_PERSIST_FN(TAE_Additive,      TAE,     GetAdditiveAttr,      put_additive,      get_additive,      VT_BSTR);
TIME_PERSIST_FN(TAE_AttributeName, TAE,     GetAttributeNameAttr, put_attributeName, get_attributeName, VT_BSTR);
TIME_PERSIST_FN(TAE_By,            TAE,     GetByAttr,            put_by,            get_by,            VARIANT);
TIME_PERSIST_FN(TAE_CalcMode,      TAE,     GetCalcModeAttr,      put_calcMode,      get_calcMode,      VT_BSTR);
TIME_PERSIST_FN(TAE_From,          TAE,     GetFromAttr,          put_from,          get_from,          VARIANT);
TIME_PERSIST_FN(TAE_KeySplines,    TAE,     GetKeySplinesAttr,    put_keySplines,    get_keySplines,    VT_BSTR);
TIME_PERSIST_FN(TAE_KeyTimes,      TAE,     GetKeyTimesAttr,      put_keyTimes,      get_keyTimes,      VT_BSTR);
TIME_PERSIST_FN(TAE_Origin,        TAE,     GetOriginAttr,        put_origin,        get_origin,        VT_BSTR);
TIME_PERSIST_FN(TAE_Path,          TAE,     GetPathAttr,          put_path,          get_path,          VARIANT);
TIME_PERSIST_FN(TAE_TargetElement, TAE,     GetTargetElementAttr, put_targetElement, get_targetElement, VT_BSTR);
TIME_PERSIST_FN(TAE_To,            TAE,     GetToAttr,            put_to,            get_to,            VARIANT);
TIME_PERSIST_FN(TAE_Values,        TAE,     GetValuesAttr,        put_values,        get_values,        VARIANT);
TIME_PERSIST_FN(TAE_Type,          TAE,     GetTypeAttr,          put_type,          get_type,          VT_BSTR);
TIME_PERSIST_FN(TAE_SubType,       TAE,     GetSubtypeAttr,       put_subType,       get_subType,       VT_BSTR);
TIME_PERSIST_FN(TAE_Mode,          TAE,     GetModeAttr,          put_mode,          get_mode,          VT_BSTR);
TIME_PERSIST_FN(TAE_FadeColor,     TAE,     GetFadeColorAttr,     put_fadeColor,     get_fadeColor,     VT_BSTR);

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMEAnimationBase)
                           // Attr Name         // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_ACCUMULATE,       TAE_Accumulate )
    PERSISTENCE_MAP_ENTRY( WZ_ADDITIVE,         TAE_Additive )
    PERSISTENCE_MAP_ENTRY( WZ_ATTRIBUTENAME,    TAE_AttributeName  )
    PERSISTENCE_MAP_ENTRY( WZ_BY,               TAE_By )
    PERSISTENCE_MAP_ENTRY( WZ_CALCMODE,         TAE_CalcMode )
    PERSISTENCE_MAP_ENTRY( WZ_FROM,             TAE_From )
    PERSISTENCE_MAP_ENTRY( WZ_KEYSPLINES,       TAE_KeySplines )
    PERSISTENCE_MAP_ENTRY( WZ_KEYTIMES,         TAE_KeyTimes )
    PERSISTENCE_MAP_ENTRY( WZ_ORIGIN,           TAE_Origin )
    PERSISTENCE_MAP_ENTRY( WZ_PATH,             TAE_Path )
    PERSISTENCE_MAP_ENTRY( WZ_TARGETELEMENT,    TAE_TargetElement )
    PERSISTENCE_MAP_ENTRY( WZ_TO,               TAE_To )
    PERSISTENCE_MAP_ENTRY( WZ_VALUES,           TAE_Values )
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,             TAE_Type )
    PERSISTENCE_MAP_ENTRY( WZ_SUBTYPE,          TAE_SubType )
    PERSISTENCE_MAP_ENTRY( WZ_MODE,             TAE_Mode )
    PERSISTENCE_MAP_ENTRY( WZ_FADECOLOR,        TAE_FadeColor )

END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\time.inc ===
# BUGBUG : move to W4 eventually
WARNING_LEVEL=W3

# include common.inc in mshtml
!include $(ROOT)\common.inc

# optimize for the ppro/pII
!if $(386)
X86_CPU_OPTIMIZATION = /G6
!endif

SRCROOT=$(ROOT)\src
TIMEROOT=$(SRCROOT)\time
TIMEIDLROOT=$(TIMEROOT)\idl\obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)

ATLDIR=$(BASEDIR)\public\sdk\inc\atl21
ATLINCLUDE=$(ATLDIR)

DATIME_INC_DIRS= \
    $(SRCROOT); \
    $(TIMEROOT)\include; \
    $(ATLINCLUDE); \
    $(TIMEROOT); \
    $(SRCROOT)\include; \
    $(TIMEROOT)\idlproxy\obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY); \
    $(TIMEIDLROOT); \
    $(SRCROOT)\core\include; \
    $(ROOT)\lib$(BUILD_ALT_DIR); \
    $(BASEDIR)\public\sdk\amovie; \
    $(ROOT)\external\inc; \
    $(BASEDIR)\public\internal\shell\inc; \
    $(ROOT)\inetcore\published\inc; \
    $(ROOT)\src\f3\include

CONDITIONAL_INCLUDES= \
    $(CONDITIONAL_INCLUDES) \
    list \
    map \
    vector \
    exception \
    set \
    thunk.h

C_DEFINES = $(C_DEFINES) /DOLD_TIME_ENGINE=1 /D_MT=1

USE_STATIC_ATL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animbase.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animbase.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMBASE_H
#define _ANIMBASE_H

#include "timeelmimpl.h"
#include "..\tags\bodyelm.h"

#define CALCMODE_DISCRETE       0
#define CALCMODE_LINEAR         1
#define CALCMODE_SPLINE         2
#define CALCMODE_PACED          3
#define ORIGIN_ELEMENT          1
#define ORIGIN_PARENT           2
#define ORIGIN_DEFAULT          (ORIGIN_ELEMENT)
#define PROPERTYPUT             true
#define PROPERTYGET             false


typedef enum DATATYPES
{
    PATH,
    VALUES,
    TO,
    BY,
    NONE,
    RESET
}enum_dataTypes;


struct SplinePoints
{
    // control points
    double x1;
    double y1;
    double x2;
    double y2;

    // these are samples used for interpolation of the x spline
    double s1;
    double s2;
    double s3;
    double s4;
};


struct AnimPropState
{
    //
    // NOTE: new properties need to be initialized in CTIMEAnimationBase::CTIMEAnimationBase()
    //

    bool fDisableAnimation; // Should animation be disabled?
    bool fForceCalcModeDiscrete;

    // can interpolate?
    bool fInterpolateValues;
    bool fInterpolateFrom;
    bool fInterpolateTo;
    bool fInterpolateBy;

    // syntax errors
    bool fBadBy;
    bool fBadTo;
    bool fBadFrom;
    bool fBadValues;
    bool fBadKeyTimes;

    // whether prop has been set
    bool fAccumulate;
};


// The animation element derives from IAnimationFragmentSite.  
interface IAnimationFragmentSite : public IUnknown
{
    STDMETHOD(NotifyOnGetValue) (BSTR bstrAttributeName, 
                                 VARIANT varOriginal, VARIANT varCurrentValue, 
                                 VARIANT *pvarValue) = 0;
    STDMETHOD(NotifyOnDetachFromComposer) (void) = 0;
    STDMETHOD(NotifyOnGetElement) (IDispatch **ppidispAnimationElement) = 0;
}; 

class CAnimationFragment;

//+-------------------------------------------------------------------------------------
//
// CTIMEAnimationBase
//
//--------------------------------------------------------------------------------------

class
__declspec(uuid("1ad9817f-c206-46a2-b974-7c549a8228c7")) 
ATL_NO_VTABLE
CTIMEAnimationBase :
    public CTIMEElementImpl<ITIMEAnimationElement2, &IID_ITIMEAnimationElement2>,
    public ISupportErrorInfoImpl<&IID_ITIMEAnimationElement>,
    public IConnectionPointContainerImpl< CTIMEAnimationBase>,
    public IPersistPropertyBag2,
    public IAnimationFragmentSite,
    public IPropertyNotifySinkCP< CTIMEAnimationBase>
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMEAnimationBase();
    virtual ~CTIMEAnimationBase();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEAnimationBase"); }
#endif

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // ITIMEAnimationElement
    //

    STDMETHOD(get_attributeName)(BSTR * attrib);
    STDMETHOD(put_attributeName)(BSTR attrib);

    STDMETHOD(get_from)(VARIANT * val);
    STDMETHOD(put_from)(VARIANT val);
    
    STDMETHOD(get_to)(VARIANT * val);
    STDMETHOD(put_to)(VARIANT val);

    STDMETHOD(get_by)(VARIANT * val);
    STDMETHOD(put_by)(VARIANT val);

    STDMETHOD(get_values)(VARIANT * val);
    STDMETHOD(put_values)(VARIANT val);

    STDMETHOD(get_keyTimes)(BSTR * val);
    STDMETHOD(put_keyTimes)(BSTR val);

    STDMETHOD(get_keySplines)(BSTR * val);
    STDMETHOD(put_keySplines)(BSTR val);

    STDMETHOD(get_targetElement)(BSTR * target);
    STDMETHOD(put_targetElement)(BSTR target);

    STDMETHOD(get_calcMode)(BSTR * calcmode);
    STDMETHOD(put_calcMode)(BSTR calcmode);

    STDMETHOD(get_additive)(BSTR * val);
    STDMETHOD(put_additive)(BSTR val);

    STDMETHOD(get_accumulate)(BSTR * val);
    STDMETHOD(put_accumulate)(BSTR val);

    STUB_INVALID_ATTRIBUTE(BSTR, origin)
    STUB_INVALID_ATTRIBUTE(VARIANT, path)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

    //
    // IAnimationFragmentSite
    // 
    STDMETHOD(NotifyOnGetElement)(IDispatch **pidispElement);
    STDMETHOD(NotifyOnGetValue)(BSTR bstrAttributeName, 
                                VARIANT varOrigonal, VARIANT varCurrentValue, 
                                VARIANT *pvarValue);
    STDMETHOD(NotifyOnDetachFromComposer)(void);

    //
    // IPersistPropertyBag2
    // 

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)(void) { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)(void) { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // Persistence helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void);

    //
    // Event Handlers
    //

    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnSync(double dbllastTime, double & dblnewTime);
    virtual void OnUnload();
    virtual void OnTEPropChange(DWORD tePropType);

    //
    // QI Map
    //

    BEGIN_COM_MAP(CTIMEAnimationBase)
        COM_INTERFACE_ENTRY(ITIMEAnimationElement)
        COM_INTERFACE_ENTRY(ITIMEAnimationElement2)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    //
    // Connection Point to allow IPropertyNotifySink
    //

    BEGIN_CONNECTION_POINT_MAP(CTIMEAnimationBase)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // Notification Helpers
    //

    void NotifyPropertyChanged(DISPID dispid);

    //
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    //

    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEAnimationBase* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);

    //
    // Needed by CBvrBase
    //

    void * GetInstance() { return (ITIMEAnimationElement *) this; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo) { return GetTI(GetUserDefaultLCID(), ppInfo); }

    //
    // GetXXXAttr Accessors
    //

    CAttr<LPWSTR> & GetAttributeNameAttr()  { return m_SAAttribute; }
    CAttr<LPWSTR> & GetTargetElementAttr()  { return m_SATarget; }
    CAttr<LPWSTR> & GetValuesAttr()         { return m_SAValues; }
    CAttr<LPWSTR> & GetKeyTimesAttr()       { return m_SAKeyTimes; }
    CAttr<LPWSTR> & GetKeySplinesAttr()     { return m_SAKeySplines; }
    CAttr<LPWSTR> & GetAccumulateAttr()     { return m_SAAccumulate; }
    CAttr<LPWSTR> & GetAdditiveAttr()       { return m_SAAdditive; }
    CAttr<int>    & GetCalcModeAttr()       { return m_IACalcMode; }
    CAttr<void*>  & GetFromAttr()           { return m_VAFrom; }
    CAttr<void*>  & GetToAttr()             { return m_VATo; }
    CAttr<void*>  & GetByAttr()             { return m_VABy; }    
    CAttr<LPWSTR> & GetPathAttr()           { return m_SAPath; }
    CAttr<int>    & GetOriginAttr()         { return m_IAOrigin; }
    CAttr<LPWSTR> & GetTypeAttr()           { return m_SAType; }
    CAttr<LPWSTR> & GetSubtypeAttr()        { return m_SASubtype; }
    CAttr<LPWSTR> & GetModeAttr()           { return m_SAMode; }
    CAttr<LPWSTR> & GetFadeColorAttr()      { return m_SAFadeColor; }
    
    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------
    virtual bool ValidateByValue (const VARIANT *pvarBy);
    virtual bool ValidateValueListItem (const VARIANT *pvarValueItem);

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //
    //
    //

    virtual double CalculateProgressValue(bool fForceDiscrete);
    virtual int CalculateCurrentSegment(bool fForceDiscrete);
    virtual void  resetAnimate();
    virtual HRESULT calculateDiscreteValue(VARIANT *pvarValue);
    virtual HRESULT calculateLinearValue (VARIANT *pvarValue);
    virtual HRESULT calculateSplineValue (VARIANT *pvarValue);
    virtual HRESULT calculatePacedValue (VARIANT *pvarValue);
    virtual void resetValue (VARIANT *pvarValue);
    virtual void CalculateTotalDistance();
    virtual void initAnimate (void);
    virtual void endAnimate (void);
    virtual void SetInitialState (void);
    virtual void SetFinalState (void);
    virtual void OnFirstUpdate (VARIANT *pvarValue);
    virtual void OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess);
    virtual void GetFinalByValue(VARIANT *pvarValue);
    virtual double GetAnimationRange();

    virtual HRESULT CalculateValue (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void UpdateStartValue (VARIANT *pvarNewStartValue);
    virtual void UpdateCurrentBaseline (const VARIANT *pvarCurrent);
    virtual void PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual HRESULT DoFill (VARIANT *pvarValue);
    virtual void DoAccumulation (VARIANT *pvarValue);

    virtual HRESULT addToComposerSite (IHTMLElement2 *pielemTarget);    
    virtual HRESULT removeFromComposerSite (void);   

    HRESULT FindAnimationTarget (IHTMLElement ** ppielemTarget);
    
    double CalculateBezierProgress(const SplinePoints & sp, double cp);
    double KeySplineBezier(double x1, double x2, double cp);
    void SampleKeySpline(SplinePoints & sp);
    bool ConvertToPixels(VARIANT *pvarValue);

    virtual HRESULT CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld);
    virtual HRESULT UncanonicalizeValue (VARIANT *pvarValue, VARTYPE vtOld);
    virtual void DetermineAdditiveEffect (void);
    virtual void DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue);

    void  validateData();
    void  initScriptEngine();
    float getCurrentValue();
    void updateDataToUse(DATATYPES dt);

    HRESULT CreateFragmentHelper (void);

    virtual void ValidateState();
    bool DisableAnimation() { return m_AnimPropState.fDisableAnimation; }

    //
    // Misc. methods
    //

    HRESULT Error();
    virtual bool NeedSyncCB() { return true; }

    virtual bool QueryNeedFirstUpdate (void)
        { return m_bNeedFirstUpdate; }
    virtual bool QueryNeedFinalUpdate (void)
        { return m_bNeedFinalUpdate; }

    bool IsTargetVML(void)
        { return m_bVML; }
    
#ifdef TEST_ENUMANDINSERT // pauld
    HRESULT TestEnumerator (void);
    HRESULT TestInsert (void);
    HRESULT InsertEnumRemove (int iSlot);
#endif // TEST_ENUMANDINSERT

#ifdef TEST_REGISTERCOMPFACTORY // pauld
    HRESULT TestCompFactoryRegister (BSTR bstrAttribName);
#endif // TEST_REGISTERCOMPFACTORY

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    // XML Attributes
    CAttr<LPWSTR>               m_SAAttribute;
    CAttr<LPWSTR>               m_SATarget;
    CAttr<LPWSTR>               m_SAValues;
    CAttr<LPWSTR>               m_SAKeyTimes;
    CAttr<LPWSTR>               m_SAKeySplines;
    CAttr<LPWSTR>               m_SAAccumulate;
    CAttr<LPWSTR>               m_SAAdditive;
    CAttr<int>                  m_IACalcMode;
    CAttr<void*>                m_VAFrom; // Place holder for m_varFrom
    CAttr<void*>                m_VATo;   // Place holder for m_varTo
    CAttr<void*>                m_VABy;   // Place holder for m_varBy
    CAttr<LPWSTR>               m_SAPath;
    CAttr<int>                  m_IAOrigin;
    CAttr<LPWSTR>               m_SAType;
    CAttr<LPWSTR>               m_SASubtype;
    CAttr<LPWSTR>               m_SAMode;
    CAttr<LPWSTR>               m_SAFadeColor;

    // Internal Variables
    CComVariant                 m_varBaseline;
    CComVariant                 m_varCurrentBaseline;
    CComVariant                 m_varTo;
    CComVariant                 m_varFrom;
    CComVariant                 m_varBy;
    // these three are used to store copies to be returned by get_from/to/by
    // as the previous three are local copies that are modified (108725)
    CComVariant                 m_varDOMTo;
    CComVariant                 m_varDOMFrom;
    CComVariant                 m_varDOMBy;
    CComVariant                 m_varLastValue;
    CComVariant                 m_varStartValue;
    bool                        m_bFrom;
    bool                        m_bAdditive;
    bool                        m_bAdditiveIsSum;
    bool                        m_bAccumulate;
    bool                        m_bNeedAnimInit;
    bool                        m_fPropsLoaded;
    bool                        m_bNeedFinalUpdate;
    bool                        m_bNeedFirstUpdate;
    bool                        m_bNeedStartUpdate;
    bool                        m_bVML;
    CComPtr<IHTMLElementCollection> m_spEleCol;
    CComPtr<IHTMLDocument3>     m_spDoc3;
    CComPtr<IHTMLDocument2>     m_spDoc2;
    int                         m_numValues;
    LPOLESTR                   *m_ppstrValues;
    int                         m_numKeyTimes;
    double                     *m_pdblKeyTimes;
    int                         m_numKeySplines;
    SplinePoints               *m_pKeySplinePoints;
    double                      m_dblTotalDistance;
    bool                        m_bNeedToSetInitialState;
    AnimPropState               m_AnimPropState;

    DATATYPES                       m_dataToUse;
    CComPtr<IAnimationComposerSite> m_spCompSite;
    CComObject<CAnimationFragment>  *m_spFragmentHelper;

private:

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    // Persistence map
    static TIME_PERSISTENCE_MAP PersistenceMap[];

}; // CTIMEAnimationBase

//+---------------------------------------------------------------------------------
//  CTIMEAnimationBase inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
HRESULT WINAPI
CTIMEAnimationBase::InternalQueryInterface(CTIMEAnimationBase* pThis,
                                              const _ATL_INTMAP_ENTRY* pEntries,
                                              REFIID iid,
                                              void** ppvObject)
{ 
    return BaseInternalQueryInterface(pThis,
                                      (void *) pThis,
                                      pEntries,
                                      iid,
                                      ppvObject); 
}

#endif /* _ANIMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animcolor.cpp ===
// Coloranim.cpp
//

#include "headers.h"
#include "animcolor.h"

#define SUPER CTIMEAnimationBase

DeclareTag(tagAnimationColor, "SMIL Animation", 
           "CTIMEColorAnimation methods");

DeclareTag(tagAnimationColorInterpolate, "SMIL Animation", 
           "CTIMEColorAnimation interpolation");

DeclareTag(tagAnimationColorAdditive, "SMIL Animation", 
           "CTIMEColorAnimation additive animation methods");

static const LPWSTR s_cPSTR_NEGATIVE = L"-";

#define PART_ONE 0
#define PART_TWO 1

///////////////////////////////////////////////////////////////
//  Name: CTIMEColorAnimation
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMEColorAnimation::CTIMEColorAnimation()
: m_prgbValues(NULL),
  m_byNegative(false)
{
    m_rgbTo.red = 0.0;
    m_rgbTo.green = 0.0;
    m_rgbTo.blue = 0.0;

    m_rgbFrom       = m_rgbTo;
    m_rgbBy         = m_rgbTo;
    m_rgbAdditive   = m_rgbTo;
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMEColorAnimation
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMEColorAnimation::~CTIMEColorAnimation()
{
    delete [] m_prgbValues;
} 

///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    HRESULT hr;
    
    // Set the Caclmode to discrete since that is all that set supports 
    hr = THR(SUPER::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: VariantToRGBColorValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::VariantToRGBColorValue (VARIANT *pvarIn, rgbColorValue *prgbValue)
{
    HRESULT hr;

    if (VT_EMPTY == V_VT(pvarIn))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (VT_BSTR != V_VT(pvarIn))
    {
        hr = VariantChangeTypeEx(pvarIn, pvarIn, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    Assert(VT_BSTR == V_VT(pvarIn));

    hr = RGBStringToRGBValue(V_BSTR(pvarIn), prgbValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // VariantToRGBColorValue


///////////////////////////////////////////////////////////////
//  Name: get_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::get_to(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varTo);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_to(VARIANT val)
{
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt;

    // Clear the attribute
    m_varTo.Clear();
    m_VATo.Reset(NULL);
    m_rgbTo.red = 0;
    m_rgbTo.green = 0;
    m_rgbTo.blue = 0;
    dt = RESET; 

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // store off local copy
    hr = VariantCopy(&m_varTo, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder to mark it as set
    m_VATo.SetValue(NULL);

    hr = VariantToRGBColorValue(&m_varTo, &m_rgbTo);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    dt = TO;

    hr = S_OK;
done:
    m_AnimPropState.fInterpolateTo = fCanInterpolate;

    m_AnimPropState.fBadTo = FAILED(hr) ? true : false;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_TO);

    RRETURN(hr);
} // put_to


///////////////////////////////////////////////////////////////
//  Name: get_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::get_from(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varFrom);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_from(VARIANT val)
{
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;

    // Clear the attribute
    m_varFrom.Clear();
    m_VAFrom.Reset(NULL);
    m_rgbFrom.red = 0;
    m_rgbFrom.green = 0;
    m_rgbFrom.blue = 0;
    m_bFrom = false;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // store off local copy
    hr = VariantCopy(&m_varFrom, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder to mark it as set
    m_VAFrom.SetValue(NULL);

    // Validate the color
    hr = VariantToRGBColorValue(&m_varFrom, &m_rgbFrom);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    m_bFrom = true;

    hr = S_OK;
done:
    m_AnimPropState.fBadFrom = FAILED(hr) ? true : false;

    m_AnimPropState.fInterpolateFrom = fCanInterpolate;

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_FROM);

    RRETURN(hr);
} // put_from


///////////////////////////////////////////////////////////////
//  Name: get_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::get_by(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varBy);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_by(VARIANT val)
{
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt;

    // Clear the attribute
    m_varBy.Clear();
    m_VABy.Reset(NULL);
    m_rgbBy.red = 0;
    m_rgbBy.green = 0;
    m_rgbBy.blue = 0;
    dt = RESET; 

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // store off local copy
    hr = VariantCopy(&m_varBy, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VABy.SetValue(NULL);

    // Try to get us to a colorPoint ... somehow..
    hr = VariantToRGBColorValue(&m_varBy, &m_rgbBy);
    if (FAILED(hr))
    { 
        // Need to handle the negative case...
        if ((m_varBy.vt == VT_BSTR) &&
            (StrCmpNIW(m_varBy.bstrVal, s_cPSTR_NEGATIVE, 1) == 0))
        {
            LPOLESTR Temp;
            CComVariant varTemp;
            
            Temp = CopyString(m_varBy.bstrVal);
            if (Temp == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            varTemp.vt = VT_BSTR;
            varTemp.bstrVal = SysAllocString(Temp+1);
            if(Temp)
            {
                delete [] Temp;
                Temp = NULL;
            }
            hr = VariantToRGBColorValue(&varTemp, &m_rgbBy);
            if (FAILED(hr))
            {
                fCanInterpolate = false;
                goto done;
            }
            m_byNegative = true;
        }
        else
        {
            fCanInterpolate = false;
            goto done;
        }
    }

    dt = BY;

    hr = S_OK;
done:
    m_AnimPropState.fBadBy = FAILED(hr) ? true : false;
    
    m_AnimPropState.fInterpolateBy = fCanInterpolate;

    updateDataToUse(dt);
    
    ValidateState();
 
    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_BY);

    RRETURN(hr);
} // put_by


///////////////////////////////////////////////////////////////
//  Name: put_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEColorAnimation::put_values(VARIANT val)
{
    HRESULT hr = E_FAIL;
    int i = 0, count = 0;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    dTemp = m_dataToUse;

    // reset internal state
    delete [] m_prgbValues;
    m_prgbValues = NULL;

    // delegate to base class
    hr = SUPER::put_values(val);    
    if (FAILED(hr))
    {
        goto done;
    }

    // restore animation-type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // check for an empty string
    if (m_numValues == 0)
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    // allocate internal storage
    m_prgbValues = NEW rgbColorValue[m_numValues];
    if(m_prgbValues == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // parse the values
    {
        CComVariant varVal;

        for (i=0; i < m_numValues; i++)
        {
            V_VT(&varVal) = VT_BSTR;
            V_BSTR(&varVal) = SysAllocString(m_ppstrValues[i]);
            // If the allocation fails, fall out and return an error
            if (NULL == V_BSTR(&varVal))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            hr = VariantToRGBColorValue(&varVal, &(m_prgbValues[i]));
            if (FAILED(hr))
            {
                fCanInterpolate = false;
                goto done;
            }
            count++;
            varVal.Clear();
        }
    }

    dt = VALUES;

    // check for invalid attribute
    if (count < 1)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_AnimPropState.fBadValues = true;
        delete [] m_prgbValues;
        m_prgbValues = NULL;
    }
    else
    {
        m_AnimPropState.fBadValues = false;
    }

    m_AnimPropState.fInterpolateValues = fCanInterpolate;

    updateDataToUse(dt);

    CalculateTotalDistance();

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_values


///////////////////////////////////////////////////////////////
//  Name: UpdateStartValue
//
//  Abstract: Refresh the m_varStartValue, doing any necessary type conversion.
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::UpdateStartValue (VARIANT *pvarNewStartValue)
{
    m_varStartValue.Clear();
    THR(m_varStartValue.Copy(pvarNewStartValue));
} // UpdateStartValue 

///////////////////////////////////////////////////////////////
//  Name: UpdateCurrentBaseTime
//
//  Abstract: Examine the current base time, and update it if 
//            we're doing baseline+to animation (the spec calls
//            this hybrid additive).
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::UpdateCurrentBaseline (const VARIANT *pvarCurrent)
{
    // Are we doing hybrid additive animation?
    if (   (TO == m_dataToUse)
        && (!m_bFrom))
    {
        // Filter out the initial call (when last-value hasn't been set.
        if (VT_EMPTY != V_VT(&m_varLastValue))
        {
            CComVariant varCurrent;
            CComVariant varLast;

            // Make sure we're all speaking in the same format (vector)
            HRESULT hr = THR(varCurrent.Copy(pvarCurrent));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = EnsureVariantVectorFormat(&varCurrent);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = THR(varLast.Copy(&m_varLastValue));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = EnsureVariantVectorFormat(&varLast);
            if (FAILED(hr))
            {
                goto done;
            }

            if (!IsColorVariantVectorEqual(&varLast, &varCurrent))
            {
                THR(::VariantCopy(&m_varCurrentBaseline, &varCurrent));
#if (0 && DBG)
                {
                    CComVariant varNewBaseline;
                    RGBVariantVectorToRGBVariantString(&varCurrent, &varNewBaseline);
                    TraceTag((tagAnimationColorAdditive, 
                              "CTIMEColorAnimation(%p)::UpdateCurrentBaseTime(%ls)", 
                              this, V_BSTR(&varNewBaseline)));
                }
#endif
            }
        }
    }

done :
    return;
} // UpdateCurrentBaseTime


///////////////////////////////////////////////////////////////
//  Name: GetRGBAnimationRange
//
//  Abstract: Get the end point of the animation function over the
//            simple duration
//
///////////////////////////////////////////////////////////////
rgbColorValue 
CTIMEColorAnimation::GetRGBAnimationRange()
{
    rgbColorValue rgbReturnVal = {0.0, 0.0, 0.0};

    switch (m_dataToUse)
    {
        case VALUES:
            {
                if (!m_AnimPropState.fInterpolateValues)
                {
                    goto done;
                }

                if (m_numValues < 1)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    rgbReturnVal = m_prgbValues[0];
                }
                else
                {
                    rgbReturnVal = m_prgbValues[m_numValues - 1];
                }
            }
            break;

        case BY:
            {
                rgbColorValue rgbFrom = {0.0, 0.0, 0.0};

                if (m_bFrom)
                {
                    if (!m_AnimPropState.fInterpolateFrom)
                    {
                        goto done;
                    }

                    rgbFrom = m_rgbFrom;
                }

                if (!m_AnimPropState.fInterpolateBy)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    rgbReturnVal = rgbFrom;
                }
                else
                {
                    rgbReturnVal = CreateByValue(rgbFrom);
                }
            }
            break;

        case TO:
            {
                if (!m_AnimPropState.fInterpolateTo)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    if (m_bFrom)
                    {
                        if (!m_AnimPropState.fInterpolateFrom)
                        {
                            goto done;
                        }

                        rgbReturnVal = m_rgbFrom;
                    }

                    // For "to" animations (i.e. no "from"), accumulation is disabled, 
                    // so we do not need to handle it.
                }
                else
                {
                    rgbReturnVal = m_rgbTo;
                }
            }
            break;
        
        default:
            break;
    }

done:
    return rgbReturnVal;
}


///////////////////////////////////////////////////////////////
//  Name: DoAccumulation
//
//  Abstract: Perform the per-tick accumulation
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::DoAccumulation (VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;
    rgbColorValue rgbCurrColor = {0.0, 0.0, 0.0};

    // get the animation range
    rgbColorValue rgbAnimRange = GetRGBAnimationRange();

    // get the number of iterations elapsed
    long lCurrRepeatCount = GetMMBvr().GetCurrentRepeatCount();

    if ((VT_R8 | VT_ARRAY) == V_VT(pvarValue))
    {
        IGNORE_HR(RGBVariantVectorToRGBValue(pvarValue, &rgbCurrColor));
    }
    else
    {
        hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    rgbCurrColor.red += (rgbAnimRange.red * lCurrRepeatCount);
    rgbCurrColor.green += (rgbAnimRange.green * lCurrRepeatCount);
    rgbCurrColor.blue += (rgbAnimRange.blue * lCurrRepeatCount);

    IGNORE_HR(RGBValueToRGBVariantVector(&rgbCurrColor, pvarValue));

done:
    return;
} // DoAccumulation 


///////////////////////////////////////////////////////////////
//  Name: OnFinalUpdate
//
//  Abstract: Called when this fragment updates the value for the final time.
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;

    SUPER::OnFinalUpdate(pvarCurrent, pvarValue);    

    // If we need to send an updated value back to the 
    // composer, make sure to convert to the composition
    // format.  This happens when we shove in the fill 
    // value (still in the native string format).
    if ((VT_BSTR == V_VT(pvarValue)) &&
        (NULL != V_BSTR(pvarValue)))
    {
        hr = THR(RGBVariantStringToRGBVariantVectorInPlace(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_varLastValue.Copy(pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

done :
    return;
} // OnFinalUpdate

///////////////////////////////////////////////////////////////
//  Name: hasEmptyStartingPoint
//
//  Abstract: Does this fragment have a valid starting value?
//    
///////////////////////////////////////////////////////////////
bool
CTIMEColorAnimation::hasEmptyStartingPoint (void)
{
    return (   (VT_BSTR == V_VT(&m_varStartValue)) 
            && (IsColorUninitialized(V_BSTR(&m_varStartValue)))
           );
} // hasEmptyStartingPoint

///////////////////////////////////////////////////////////////
//  Name: fallbackToDiscreteCalculation
//
//  Abstract: If we find that we cannot perform a continuous 
//            calculation, we should fall back to a discrete one.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::fallbackToDiscreteCalculation (VARIANT *pvarValue)
{
    HRESULT hr;

    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = calculateDiscreteValue(pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // fallbackToDiscreteCalculation


///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculateDiscreteValue (VARIANT *pvarValue)
{
    HRESULT hr;

    // If there's no initial value,  
    // we need to set up the destination 
    // variable.
    if (hasEmptyStartingPoint())
    {
        if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
        {
            hr = THR(CreateInitialRGBVariantVector(pvarValue));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    switch ( m_dataToUse)
    {
        case VALUES:
            {
                int curSeg = CalculateCurrentSegment(true);

                hr = RGBStringToRGBVariantVector (m_ppstrValues[curSeg], pvarValue);
                if (FAILED(hr))
                {
                    goto done;
                }
                TraceTag((tagAnimationColorInterpolate,
                          "CTIMEColorAnimation(%lx)::discrete(%10.4lf) : value[%d] =%ls",
                          this, GetMMBvr().GetProgress(), curSeg, m_ppstrValues[curSeg]));
            }
            break;

        case BY:
            {
                rgbColorValue rgbNewBy;

                // get "from" value
                if (m_bFrom)
                {
                    // Add "by" value only if second half of interval
                    if (GetMMBvr().GetProgress() >= 0.5)
                    {
                        rgbNewBy = CreateByValue(m_rgbFrom);
                    }
                    else
                    {
                        // just use from value
                        rgbNewBy = m_rgbFrom;
                    }
                }
                else
                {
                    // just use by value
                    rgbNewBy = m_rgbBy;
                }
                
                hr = RGBValueToRGBVariantVector (&rgbNewBy, pvarValue);
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            break;

        case TO:
            {
                if (m_bFrom && (GetMMBvr().GetProgress() < 0.5))
                {
                    // use the from value
                    hr = RGBValueToRGBVariantVector(&m_rgbFrom, pvarValue);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
                else
                {
                    // use the to value
                    hr = RGBStringToRGBVariantVector (V_BSTR(&m_varTo), pvarValue);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }

                TraceTag((tagAnimationColorInterpolate,
                          "CTIMEColorAnimation(%lx)::discrete(%10.4lf) : to=%ls",
                          this, GetMMBvr().GetProgress(), V_BSTR(&m_varTo)));
            }
            break;
        
        default:
            break;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}  // calculateDiscreteValue


///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculateLinearValue (VARIANT *pvarValue)
{
    HRESULT hr = S_OK;
    double        dblProgress = 0.0;
    rgbColorValue rgbColor = {0};
    CComVariant cVar;
    
    // If there's no basis for interpolation, try 
    // doing a discrete animation.
    if (hasEmptyStartingPoint())
    {
        hr = fallbackToDiscreteCalculation(pvarValue);
        goto done;
    }

    dblProgress = GetMMBvr().GetProgress();

    if (m_dataToUse == VALUES)
    {
        double curProgress = CalculateProgressValue(false);
        int    curSeg      = CalculateCurrentSegment(false);

        rgbColor.red = InterpolateValues(m_prgbValues[curSeg].red, m_prgbValues[curSeg+1].red, curProgress);
        rgbColor.green = InterpolateValues(m_prgbValues[curSeg].green, m_prgbValues[curSeg+1].green, curProgress);
        rgbColor.blue = InterpolateValues(m_prgbValues[curSeg].blue, m_prgbValues[curSeg+1].blue, curProgress);
    }
    else if (TO == m_dataToUse)
    {
        rgbColorValue rgbFrom;

        if (m_bFrom)
        {
            rgbFrom = m_rgbFrom;
        }
        else
        {
            IGNORE_HR(RGBVariantVectorToRGBValue (&m_varCurrentBaseline, &rgbFrom));            
        }

        rgbColor.red = InterpolateValues(rgbFrom.red, m_rgbTo.red, dblProgress);
        rgbColor.green = InterpolateValues(rgbFrom.green, m_rgbTo.green, dblProgress);
        rgbColor.blue = InterpolateValues(rgbFrom.blue, m_rgbTo.blue, dblProgress);
    }
    else if (BY == m_dataToUse)
    {
        rgbColorValue rgbFrom;
        rgbColorValue rgbTo;

        if (m_bFrom)
        {
            rgbFrom = m_rgbFrom;
        }
        else
        {
            rgbFrom.red = 0.0;
            rgbFrom.green = 0.0;
            rgbFrom.blue = 0.0;
        }

        rgbTo = CreateByValue(rgbFrom);

        rgbColor.red = InterpolateValues(rgbFrom.red, rgbTo.red, dblProgress);
        rgbColor.green = InterpolateValues(rgbFrom.green, rgbTo.green, dblProgress);
        rgbColor.blue = InterpolateValues(rgbFrom.blue, rgbTo.blue, dblProgress);
    }
   
    TraceTag((tagAnimationColorInterpolate,
              "CTIMEColorAnimation(%lx)::linear() : progress(%lf) %lf %lf %lf",
              this, dblProgress, rgbColor.red, rgbColor.green, rgbColor.blue));

    hr = RGBValueToRGBVariantVector(&rgbColor, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculateSplineValue (VARIANT *pvarValue)
{
    HRESULT hr;

    // If there's no basis for interpolation, try 
    // doing a discrete animation.
    if (hasEmptyStartingPoint())
    {
        hr = fallbackToDiscreteCalculation(pvarValue);
        goto done;
    }
    
    if (VALUES == m_dataToUse)
    {
        rgbColorValue   rgbColor;
        double          dblTimeProgress = CalculateProgressValue(false);
        int             curSeg          = CalculateCurrentSegment(false);

        if (   (NULL == m_pKeySplinePoints) 
            || (m_numKeySplines <= curSeg))
        {
            hr = E_FAIL;
            goto done;
        }

        // compute spline progess and interpolate
        {
            double dblSplineProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg],dblTimeProgress);

            rgbColor.red = InterpolateValues(m_prgbValues[curSeg].red, m_prgbValues[curSeg+1].red, dblSplineProgress);
            rgbColor.green = InterpolateValues(m_prgbValues[curSeg].green, m_prgbValues[curSeg+1].green, dblSplineProgress);
            rgbColor.blue = InterpolateValues(m_prgbValues[curSeg].blue, m_prgbValues[curSeg+1].blue, dblSplineProgress);

            TraceTag((tagAnimationColorInterpolate,
                      "CTIMEColorAnimation(%lx)::spline : time progress(%lf) spline progress(%lf) %lf %lf %lf",
                      this, dblTimeProgress, dblSplineProgress, rgbColor.red, rgbColor.green, rgbColor.blue));
        }

        hr = RGBValueToRGBVariantVector(&rgbColor, pvarValue);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = calculateLinearValue(pvarValue);
        if (FAILED(hr))
        {
            goto done;
        }
    }


    hr = S_OK;
done :
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::calculatePacedValue (VARIANT *pvarValue)
{
    HRESULT         hr = S_OK;
    double          dblCurDistance;
    double          dblLastDistance = 0.0;
    double          dblSegLength;
    double          dblDistance;
    double          dblProgress;
    int             i;
    rgbColorValue   rgbColor;
    CComVariant     svarTemp;

    // If there's no basis for interpolation, try 
    // doing a discrete animation.
    if (hasEmptyStartingPoint())
    {
        hr = fallbackToDiscreteCalculation(pvarValue);
        goto done;
    }

    // This only makes sense if you are using m_dataToUse == VALUES
    if (    (m_dataToUse != VALUES)
        ||  (   (VALUES == m_dataToUse)
             && (1 == m_numValues)))
    {
        hr = THR(calculateLinearValue(pvarValue));
        goto done;
    }

    // how much distance should we have traveled?
    dblCurDistance = InterpolateValues(0.0, 
                                       m_dblTotalDistance, 
                                       GetMMBvr().GetProgress());

    // find current segment
    for (i = 1, dblDistance = 0.0; 
         (i < m_numValues)  
         && (dblDistance <= dblCurDistance);
         i++)
    {
        dblLastDistance = dblDistance;
        dblDistance += CalculateDistance(m_prgbValues[i-1], m_prgbValues[i]); 
    }

    // adjust the index
    i = (i <= 1) ? 1 : i - 1;

    // get the length of the last segment
    dblSegLength = CalculateDistance(m_prgbValues[i-1], m_prgbValues[i]); 
    if (0 == dblSegLength)
    {
        goto done;
    }

    // get the normalized progress in the segment
    dblProgress = (dblCurDistance - dblLastDistance) / dblSegLength;

    rgbColor.red = InterpolateValues(m_prgbValues[i-1].red, m_prgbValues[i].red, dblProgress);
    rgbColor.green = InterpolateValues(m_prgbValues[i-1].green, m_prgbValues[i].green, dblProgress);
    rgbColor.blue = InterpolateValues(m_prgbValues[i-1].blue, m_prgbValues[i].blue, dblProgress);
  
    TraceTag((tagAnimationColorInterpolate,
              "CTIMEColorAnimation(%p):: paced : progress(%lf) %lf %lf %lf",
              this, GetMMBvr().GetProgress(), 
              rgbColor.red, rgbColor.green, rgbColor.blue));

    hr = RGBValueToRGBVariantVector(&rgbColor, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: CalculateDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEColorAnimation::CalculateDistance(rgbColorValue a, rgbColorValue b)
{
    double deltaR,deltaG,deltaB;

    deltaR = a.red - b.red;
    deltaG = a.green - b.green;
    deltaB = a.blue - b.blue;
    return(sqrt((double)((deltaR*deltaR) + (deltaG*deltaG) + (deltaB*deltaB))));
}


///////////////////////////////////////////////////////////////
//  Name: CalculateTotalDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::CalculateTotalDistance()
{
    int index;

    m_dblTotalDistance = 0.0;

    if (    (NULL == m_prgbValues)
        ||  (m_numValues < 2))
    {
        goto done;
    }

    for (index=1; index < m_numValues; index++)
    {
        m_dblTotalDistance += CalculateDistance(m_prgbValues[index-1], m_prgbValues[index]);
    }

done:
    return;
}


///////////////////////////////////////////////////////////////
//  Name: CreateByValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
rgbColorValue
CTIMEColorAnimation::CreateByValue(const rgbColorValue & rgbCurrent)
{
    rgbColorValue rgbNew;

    rgbNew.red = rgbCurrent.red + (m_byNegative?(-m_rgbBy.red):(m_rgbBy.red));
    rgbNew.green = rgbCurrent.green + (m_byNegative?(-m_rgbBy.green):(m_rgbBy.green));
    rgbNew.blue = rgbCurrent.blue + (m_byNegative?(-m_rgbBy.blue):(m_rgbBy.blue));

    return rgbNew;
}

///////////////////////////////////////////////////////////////
//  Name: DoAdditive
//
//  Abstract: Add the offset value into the composition's in/out param.
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue)
{
    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Detected additive animation",
              this, GetID()?GetID():L""));

    rgbColorValue rgbOrig;
    rgbColorValue rgbCurrent;
    HRESULT hr;

    // get RGB value for first arg
    if ((VT_ARRAY | VT_R8) == V_VT(pvarOrig))
    {
        hr = THR(RGBVariantVectorToRGBValue (pvarOrig, &rgbOrig));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (VT_BSTR == V_VT(pvarOrig))
    {
        hr = THR(RGBStringToRGBValue(V_BSTR(pvarOrig), &rgbOrig));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // get RGB value for second arg
    if ((VT_ARRAY | VT_R8) == V_VT(pvarValue))
    {
        hr = THR(RGBVariantVectorToRGBValue (pvarValue, &rgbCurrent));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (VT_BSTR == V_VT(pvarValue))
    {
        hr = THR(RGBStringToRGBValue (V_BSTR(pvarValue), &rgbCurrent));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // No need to convert to xyz as the matrices reduce to 
    // simple vector addition (r0+r1 g0+g1 b0+b1)
    // Also need to make sure to handle the negative 'by' case.

    rgbCurrent.red += rgbOrig.red;
    rgbCurrent.green += rgbOrig.green;
    rgbCurrent.blue += rgbOrig.blue;

    // Ensure we have a variant vector
    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(RGBValueToRGBVariantVector(&rgbCurrent, pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Orig=(%lf, %lf, %lf)", 
              this, GetID()?GetID():L"", rgbOrig.red, rgbOrig.blue, rgbOrig.green));

    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Curr=(%lf, %lf, %lf)", 
              this, GetID()?GetID():L"", rgbCurrent.red, rgbCurrent.blue, rgbCurrent.green));

    TraceTag((tagAnimationColorAdditive,
              "CTIMEColorAnimation(%p, %ls)::DoAdditive Added=(%lf, %lf, %lf)", 
              this, GetID()?GetID():L"", rgbCurrent.red, rgbCurrent.blue, rgbCurrent.green));

done :
    return;
} // DoAdditive

///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::CanonicalizeValue (VARIANT *pvarOriginal, VARTYPE *pvtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UncanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEColorAnimation::UncanonicalizeValue (VARIANT *pvarOriginal, VARTYPE vtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // UncanonicalizeValue


///////////////////////////////////////////////////////////////
//  Name: GetFinalByValue
//
//  Abstract: Get the final state of the BY animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEColorAnimation::GetFinalByValue(VARIANT *pvarValue)
{
    rgbColorValue rgbNewBy;

    VariantClear(pvarValue);

    Assert(BY == m_dataToUse);

    if (m_bFrom)
    {
        // Add "by" value to "from" value
        rgbNewBy = CreateByValue(m_rgbFrom);
    }
    else
    {
        // just use by value
        rgbNewBy = m_rgbBy;
    }
    
    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        HRESULT hr = THR(CreateInitialRGBVariantVector(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    IGNORE_HR(RGBValueToRGBVariantVector (&rgbNewBy, pvarValue));

done:
    return;
} // GetFinalByValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animcolor.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animcolor.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMCOLOR_H
#define _ANIMCOLOR_H

#include "colorutil.h"
#include "animbase.h"

//+-------------------------------------------------------------------------------------
//
// CTIMEColorAnimation
//
//--------------------------------------------------------------------------------------

class CTIMEColorAnimation : 
    public CComCoClass<CTIMEColorAnimation, &CLSID_TIMEColorAnimation>,
    public CTIMEAnimationBase
{

public:

    CTIMEColorAnimation();
    virtual ~CTIMEColorAnimation();

    DECLARE_AGGREGATABLE(CTIMEColorAnimation);
    DECLARE_REGISTRY(CLSID_TIMEColorAnimation,
                     LIBID __T(".TIMEColorAnimation.1"),
                     LIBID __T(".TIMEColorAnimation"),
                     0,
                     THREADFLAGS_BOTH);
    
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    STDMETHOD(get_from)(VARIANT * val);
    STDMETHOD(put_from)(VARIANT val);
    
    STDMETHOD(get_to)(VARIANT * val);
    STDMETHOD(put_to)(VARIANT val);

    STDMETHOD(get_by)(VARIANT * val);
    STDMETHOD(put_by)(VARIANT val);

    STDMETHOD(put_values)(VARIANT val);

    STUB_INVALID_ATTRIBUTE(BSTR, origin)
    STUB_INVALID_ATTRIBUTE(VARIANT, path)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

protected :

    virtual void OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void GetFinalByValue(VARIANT *pvarValue);
    virtual void UpdateStartValue (VARIANT *pvarNewStartValue);
    virtual void DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue);
    virtual void DoAccumulation (VARIANT *pvarValue);
    virtual HRESULT CanonicalizeValue (VARIANT *pvarOriginal, VARTYPE *pvtOld);
    virtual HRESULT UncanonicalizeValue (VARIANT *pvarOriginal, VARTYPE vtOld);
    virtual void UpdateCurrentBaseline (const VARIANT *pvarCurrent);
    virtual rgbColorValue GetRGBAnimationRange();

private:

    bool    hasEmptyStartingPoint (void);
    HRESULT fallbackToDiscreteCalculation (VARIANT *pvarValue);

    virtual HRESULT calculateDiscreteValue(VARIANT *pvarValue);
    virtual HRESULT calculateLinearValue (VARIANT *pvarValue);
    virtual HRESULT calculateSplineValue (VARIANT *pvarValue);
    virtual HRESULT calculatePacedValue (VARIANT *pvarValue);

    void CalculateTotalDistance();
    double CalculateDistance(rgbColorValue a, rgbColorValue b);

    HRESULT VariantToRGBColorValue (VARIANT *pvarIn, rgbColorValue *prgbValue);

    rgbColorValue CreateByValue(const rgbColorValue & rgbCurrent);
    void AdditiveColor(VARIANT *pVar, bool bPart);
    

    rgbColorValue   m_rgbTo;
    rgbColorValue   m_rgbFrom;
    rgbColorValue   m_rgbBy;
    rgbColorValue  *m_prgbValues;
    rgbColorValue   m_rgbAdditive;

    bool            m_byNegative;
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEColorAnimation"); }
#endif

}; // CTIMEColorAnimation


#endif /* _ANIMCOLOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animcomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Animation Composer base class.

*******************************************************************************/

#pragma once

#ifndef _ANIMCOMP_H
#define _ANIMCOMP_H

typedef std::list<IDispatch*> FragmentList;
class CTargetProxy;

class __declspec(uuid("DC357A35-DDDF-4288-B17B-1A826CDCB354"))
ATL_NO_VTABLE CAnimationComposerBase
    : public CComObjectRootEx<CComSingleThreadModel>,
      public IAnimationComposer2
{
  public:
    CAnimationComposerBase();
    virtual ~CAnimationComposerBase();

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposerBase"); }
#endif

    // IAnimationComposer methods/props
    STDMETHOD(get_attribute) (BSTR *pbstrAttributeName);
    STDMETHOD(ComposerInit) (IDispatch *pidispHostElem, BSTR bstrAttributeName);
    STDMETHOD(ComposerDetach) (void);
    STDMETHOD(UpdateFragments) (void);
    STDMETHOD(AddFragment) (IDispatch *pidispNewAnimationFragment);
    STDMETHOD(InsertFragment) (IDispatch *pidispNewAnimationFragment, VARIANT varIndex);
    STDMETHOD(RemoveFragment) (IDispatch *pidispOldAnimationFragment);
    STDMETHOD(EnumerateFragments) (IEnumVARIANT **ppienumFragments);
    STDMETHOD(GetNumFragments) (long *fragmentCount);

    // IAnimationComposer2 methods
    STDMETHOD(ComposerInitFromFragment) (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                                         IDispatch *pidispFragment);

    BEGIN_COM_MAP(CAnimationComposerBase)
        COM_INTERFACE_ENTRY(IAnimationComposer2)
        COM_INTERFACE_ENTRY(IAnimationComposer)
    END_COM_MAP();

    // These methods convert the animated value from its native format
    // to the composed format and back again.  This allows us to animate
    // color out of gamut.
    STDMETHOD(PreprocessCompositionValue) (VARIANT *pvarValue);
    STDMETHOD(PostprocessCompositionValue) (VARIANT *pvarValue);

    // Enumerator helper methods.
    unsigned long GetFragmentCount (void) const;
    HRESULT GetFragment (unsigned long ulIndex, IDispatch **ppidispFragment);

    // Internal Methods
  protected:

    HRESULT PutAttribute (LPCWSTR wzAttributeName);
    HRESULT CreateTargetProxy (IDispatch *pidispComposerSite, IAnimationComposer *pcComp);
    void DetachFragments (void);
    void DetachFragment (IDispatch *pidispFragment);
    bool MatchFragments (IDispatch *pidispOne, IDispatch *pidispTwo);
    HRESULT ComposeFragmentValue (IDispatch *pidispFragment, VARIANT varOriginal, VARIANT *pvarValue);

  // Data
  protected:

    LPWSTR          m_wzAttributeName;
    FragmentList    m_fragments;
    CTargetProxy   *m_pcTargetProxy;
    CComVariant     m_VarInitValue;
    CComVariant     m_VarLastValue;
    bool            m_bInitialComposition;
    bool            m_bCrossAxis;

};

#endif /* _ANIMCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animcomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcomp.h"
#include "tokens.h"
#include "fragenum.h"
#include "targetpxy.h"

const LPOLESTR WZ_DETACH_METHOD = L"DetachFromComposer";
const unsigned NUM_GETVALUE_ARGS = 3;

DeclareTag(tagAnimationComposer, "SMIL Animation", 
           "CAnimationComposerBase methods");

DeclareTag(tagAnimationComposerUpdate, "SMIL Animation", 
           "CAnimationComposerBase composition updates");

DeclareTag(tagAnimationComposerError, "SMIL Animation", 
           "CAnimationComposerBase composition errors");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::CAnimationComposerBase
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerBase::CAnimationComposerBase (void) :
    m_wzAttributeName(NULL),
    m_pcTargetProxy(NULL),
    m_bInitialComposition(true),
    m_bCrossAxis(false)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::CAnimationComposerBase()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::~CAnimationComposerBase
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerBase::~CAnimationComposerBase (void)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::~CAnimationComposerBase()",
              this));

    IGNORE_HR(PutAttribute(NULL));   
    Assert(0 == m_fragments.size());
    DetachFragments();
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::get_attribute
//
//  Overview:  Query the composer for the animated attribute's name
//
//  Arguments: pointer to a bstr for the attribute name
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::get_attribute (BSTR *pbstrAttributeName)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::get_attribute()",
              this));

    HRESULT hr;

    if (NULL == pbstrAttributeName)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pbstrAttributeName = ::SysAllocString(m_wzAttributeName);

    // Make sure to isolate the out of memory condition.  If we 
    // have a NULL m_szAttributeName member we would expect a NULL
    // out param.  That's not an error condition.
    if ((NULL == (*pbstrAttributeName) ) && 
        (NULL != m_wzAttributeName))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN2(hr, E_INVALIDARG, E_OUTOFMEMORY);
} // CAnimationComposerBase::get_attribute

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::PutAttribute
//
//  Overview:  Set the composer's animated attribute
//
//  Arguments: attribute name
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerBase::PutAttribute (LPCWSTR wzAttributeNameIn)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::put_attribute(%ls)",
              this, wzAttributeNameIn));

    HRESULT hr;
    LPWSTR wzAttributeName = NULL;

    if (NULL != wzAttributeNameIn)
    {
        wzAttributeName = CopyString(wzAttributeNameIn);
        if (NULL == wzAttributeName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    if (NULL != m_wzAttributeName)
    {
        delete [] m_wzAttributeName;
    }
    m_wzAttributeName = wzAttributeName;

    hr = S_OK;
done :
    RRETURN1(hr, E_OUTOFMEMORY);
} // CAnimationComposerBase::PutAttribute

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposerInit
//
//  Overview:  Tells the composer to initialize itself
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::ComposerInit (IDispatch *pidispHostElem, BSTR bstrAttributeName)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::ComposerInit(%p, %ls)",
              this, pidispHostElem, bstrAttributeName));

    HRESULT hr;

    hr = THR(PutAttribute(bstrAttributeName));
    if (FAILED(hr))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(CTargetProxy::Create(pidispHostElem, m_wzAttributeName, &m_pcTargetProxy));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pcTargetProxy);

    hr = S_OK;
done :
    
    if (FAILED(hr))
    {
        IGNORE_HR(ComposerDetach());
    }

    RRETURN2(hr, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposerBase::ComposerInit

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposerInitFromFragment
//
//  Overview:  Tells the composer to initialize itself - the base
//             class implementation is just a callthrough to ComposerInit
//
//  Returns:   re - ComposerInit
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::ComposerInitFromFragment (IDispatch *pidispHostElem, 
                                                  BSTR bstrAttributeName, 
                                                  IDispatch *)
{
    return ComposerInit(pidispHostElem, bstrAttributeName);
} // CAnimationComposerBase::ComposerInitFromFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::DetachFragment
//
//  Overview:  Tells the composer to detach from a fragment
//
//  Arguments: The fragment's dispatch
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerBase::DetachFragment (IDispatch *pidispFragment)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::DetachFragment(%p)",
              this, pidispFragment));

    // Make all calls to the fragments using IDispatch
    // This one-liner is a method in case we need to 
    // package up info to pump back to the fragments in the future.
    IGNORE_HR(CallMethod(pidispFragment, WZ_DETACH_METHOD));
} // CAnimationComposerBase::DetachFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::DetachFragments
//
//  Overview:  Tells the composer to detach from all of its fragments
//
//  Arguments: none
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerBase::DetachFragments (void)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::DetachFragments()",
              this));

    FragmentList listFragmentsToDetach;

    // Copy the fragment list so that we can tolerate 
    // reentrancy on it.
    for (FragmentList::iterator i = m_fragments.begin(); 
         i != m_fragments.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listFragmentsToDetach.push_back(*i);
    }

    // Do not allow any failure to abort the detach cycle.
    for (i = listFragmentsToDetach.begin(); 
         i != listFragmentsToDetach.end(); i++)
    {
        DetachFragment(*i);
    }

    for (i = listFragmentsToDetach.begin(); 
         i != listFragmentsToDetach.end(); i++)
    {
        // This release is for the reference from the 
        // copied list.
        IGNORE_RETURN((*i)->Release());
    }
              
    m_fragments.clear();

} // CAnimationComposerBase::DetachFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposerDetach
//
//  Overview:  Tells the composer to detach all external references
//
//  Arguments: none
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::ComposerDetach (void)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::ComposerDetach()",
              this));

    HRESULT hr;

    // Detach might have been called under an error condition.
    // We should tolerate a NULL target proxy.

    if (NULL != m_pcTargetProxy)
    {
        IGNORE_HR(m_pcTargetProxy->Detach());
        m_pcTargetProxy->Release();
        m_pcTargetProxy = NULL;
    }

    // Let go of all of the fragments.
    DetachFragments();

    // Clean up data members.
    IGNORE_HR(m_VarInitValue.Clear());
    IGNORE_HR(m_VarLastValue.Clear());
    IGNORE_HR(PutAttribute(NULL));   

    hr = S_OK;
    RRETURN(hr);
} // CAnimationComposerBase::ComposerDetach

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::ComposeFragmentValue
//
//  Overview:  Pull the fragment values -- allowing each to compose into 
//             the prior ones.
//
//  Arguments: none
//
//  Returns:   S_OK, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerBase::ComposeFragmentValue (IDispatch *pidispFragment, VARIANT varOriginal, VARIANT *pvarValue)
{
    HRESULT hr;
    DISPPARAMS dp;
    VARIANTARG rgva[NUM_GETVALUE_ARGS];
    LPWSTR wzMethodName = const_cast<LPWSTR>(WZ_FRAGMENT_VALUE_PROPERTY_NAME);
    DISPID dispidGetValue = 0;

    ZeroMemory(&dp, sizeof(dp));
    ZeroMemory(&rgva, sizeof(rgva));

    hr = THR(::VariantCopy(&(rgva[0]), pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::VariantCopy(&(rgva[1]), &varOriginal));
    if (FAILED(hr))
    {
        goto done;
    }

    rgva[2].vt = VT_BSTR;
    rgva[2].bstrVal = ::SysAllocString(m_wzAttributeName);
    if (0 != StrCmpW(V_BSTR(&(rgva[2])), m_wzAttributeName))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    dp.rgvarg = rgva;
    dp.cArgs = NUM_GETVALUE_ARGS;
    dp.cNamedArgs = 0;

    hr = THR(pidispFragment->GetIDsOfNames(IID_NULL, &wzMethodName, 1, 
                                           LCID_SCRIPTING, &dispidGetValue));
    if (FAILED(hr))
    {
        goto done;
    }

    // Wipe out prior content so we do not leak.
    IGNORE_HR(::VariantClear(pvarValue));

    hr = THR(pidispFragment->Invoke(dispidGetValue, IID_NULL, 
                                    LCID_SCRIPTING, 
                                    DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                                    &dp, pvarValue, NULL, NULL));
    if (FAILED(hr))
    {
        TraceTag((tagAnimationComposerError,
                  "CAnimationComposerBase(%p)::ComposeFragmentValue(hr = %X) error returned from fragment's get_value call",
                  this, hr));
        goto done;
    }

    hr = S_OK;

done :

    ::VariantClear(&(rgva[0]));
    ::VariantClear(&(rgva[1]));
    ::VariantClear(&(rgva[2]));

    RRETURN(hr);
} // CAnimationComposerBase::ComposeFragmentValue

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::UpdateFragments
//
//  Overview:  Tells the composer to cycle through all fragments and 
//             update the animated attribute.
//
//  Arguments: none
//
//  Returns:   S_OK, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::UpdateFragments (void)
{
    TraceTag((tagAnimationComposerUpdate,
              "CAnimationComposerBase(%p)::UpdateFragments() for %ls",
              this, m_wzAttributeName));

    HRESULT hr = S_OK;
    CComVariant varValue;

    if (NULL == m_pcTargetProxy)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // Get the initial current value of the target.
    if (m_VarInitValue.vt == VT_EMPTY)
    {
        m_bInitialComposition = true;
        hr = THR(m_pcTargetProxy->GetCurrentValue(&m_VarInitValue));
        if (FAILED(hr))
        {
            // @@ Need custom error message
            hr = E_UNEXPECTED;
            goto done;
        }
    }
    hr = varValue.Copy(&m_VarInitValue);
    if (FAILED(hr))
    {
        // @@ Need custom error message
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = PreprocessCompositionValue(&varValue);
    if (FAILED(hr))
    {
        goto done;
    }

    // Poll the fragments for their updates.
    // We do not want to abort the update when
    // a single fragment reports a failure.
    {
        FragmentList listFragmentsToUpdate;

        // Copy the fragment list so that we can tolerate 
        // reentrant add/insert/remove.
        for (FragmentList::iterator i = m_fragments.begin(); 
             i != m_fragments.end(); i++)
        {
            IGNORE_RETURN((*i)->AddRef());
            listFragmentsToUpdate.push_back(*i);
        }

        for (i = listFragmentsToUpdate.begin(); 
             i != listFragmentsToUpdate.end(); i++)
        {
            CComVariant varCopy;
            HRESULT hrTemp;

            hrTemp = THR(varCopy.Copy(&varValue));
            if (FAILED(hrTemp))
            {
                continue;
            }
            
            hrTemp = ComposeFragmentValue(*i, m_VarInitValue, &varCopy);
            if (FAILED(hrTemp))
            {
                continue;
            }

            hrTemp = THR(varValue.Copy(&varCopy));
            if (FAILED(hrTemp))
            {
                continue;
            }
        }

        // Get rid of the copied list.
        for (i = listFragmentsToUpdate.begin(); 
             i != listFragmentsToUpdate.end(); i++)
        {
            IGNORE_RETURN((*i)->Release());
        }
        listFragmentsToUpdate.clear();
    }
    if (NULL != m_pcTargetProxy) // Only update if one or more fragments has begun
    {
        hr = PostprocessCompositionValue(&varValue);
        if (FAILED(hr))
        {
            goto done;
        }
        if (m_VarLastValue == varValue)
        {
            // Value is not different ... don't update.
            goto done;
        }

        // We need to make sure that we hit the zero when we transition accross axis in order to 
        // be completely sure that we draw correctly.  In some cases when an Property goes from positive to 
        // negative draw stops, so we need to make sure that we hit the zero or we will end up with artifacts
        // left on the screen.
        if ((V_VT(&varValue) == VT_R8) &&
            (V_VT(&m_VarLastValue) == VT_R8))
        {
            if (((V_R8(&varValue) < 0) && (V_R8(&m_VarLastValue) > 0)) ||
                ((V_R8(&varValue) > 0) && (V_R8(&m_VarLastValue) < 0)))
            {
                CComVariant pVar;
                V_VT(&pVar) = VT_R8;
                V_R8(&pVar) = 0;
                hr = THR(m_pcTargetProxy->Update(&pVar));
                if (FAILED(hr))
                {
                    hr = E_UNEXPECTED;
                    goto done;
                }
                m_VarLastValue.Copy(&pVar);
            }
        }
        // Write the new value back to the target.
        hr = THR(m_pcTargetProxy->Update(&varValue));
        if (FAILED(hr))
        {
            hr = E_UNEXPECTED;
            goto done;
        }
        m_VarLastValue.Copy(&varValue);
    }

    hr = S_OK;
done :
    m_bInitialComposition = false;
    RRETURN1(hr, E_UNEXPECTED);
} // CAnimationComposerBase::UpdateFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::AddFragment
//
//  Overview:  Add a fragment to the composer's internal data structures
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::AddFragment (IDispatch *pidispNewAnimationFragment)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::AddFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr;

    IGNORE_RETURN(pidispNewAnimationFragment->AddRef());
    // @@ Need to handle memory error.
    m_fragments.push_back(pidispNewAnimationFragment);

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_UNEXPECTED);
} // CAnimationComposerBase::AddFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::InsertFragment
//
//  Overview:  Insert a fragment to the composer's internal data structures,
//             at the specified position.
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::InsertFragment (IDispatch *pidispNewAnimationFragment, VARIANT varIndex)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::InsertFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr;
    CComVariant varIndexLocal;

    // Massage the index into an expected format.
    // Eventually we might permit people to pass 
    // in id's, but that is overkill now.
    hr = THR(varIndexLocal.Copy(&varIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeTypeEx(&varIndexLocal, &varIndexLocal, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
    if (FAILED(hr))
    {
        goto done;
    }

    // An out of range value translates to an append.
    if ((m_fragments.size() > V_UI4(&varIndexLocal)) &&
        (0 <= V_I4(&varIndexLocal)))
    {
        FragmentList::iterator i = m_fragments.begin();         

        for (int iSlot = 0; iSlot < V_I4(&varIndexLocal); i++, iSlot++); //lint !e722
        IGNORE_RETURN(pidispNewAnimationFragment->AddRef());
        // @@ Need to handle memory error.
        m_fragments.insert(i, pidispNewAnimationFragment);
    }
    else
    {
        hr = AddFragment(pidispNewAnimationFragment);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = S_FALSE;
    }

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_UNEXPECTED);
} // CAnimationComposerBase::InsertFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::RemoveFragment
//
//  Overview:  Remove a fragment from the composer's internal data structures
//
//  Arguments: the dispatch of the fragment
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::RemoveFragment (IDispatch *pidispOldAnimationFragment)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::RemoveFragment(%p)",
              this,
              pidispOldAnimationFragment));

    HRESULT hr;

    for (FragmentList::iterator i = m_fragments.begin(); 
         i != m_fragments.end(); 
         i++)
    {
        if(MatchElements(*i, pidispOldAnimationFragment))
        {
            // We do not issue a notification to the fragment
            // when remove is called.  Presumably the fragment 
            // already knows.

            // We don't want to let a release on the (*i) 
            // be the final release for the sink object.
            CComPtr<IDispatch> spdispOld = (*i);
            IGNORE_RETURN(spdispOld->Release());
            m_fragments.remove(spdispOld);
            break;
        }
    }

    // If we did not find the fragment in our list, return S_FALSE.
    if (m_fragments.end() == i)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, S_FALSE);
} // CAnimationComposerBase::RemoveFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::EnumerateFragments
//
//  Overview:  Provide an enumerator for our fragments
//
//  Arguments: The outgoing enumerator
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationComposerBase::EnumerateFragments (IEnumVARIANT **ppienumFragments)
{
    HRESULT hr;

    if (NULL == ppienumFragments)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = CFragmentEnum::Create(*this, ppienumFragments);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done : 
    RRETURN1(hr, E_INVALIDARG);
} // CAnimationComposerBase::EnumerateFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::GetNumFragments
//
//  Overview:  Return the number of fragments in this composer
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::GetNumFragments (long *plFragmentCount)
{
    HRESULT hr;

    if (NULL == plFragmentCount)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *plFragmentCount = GetFragmentCount();

    hr = S_OK;
done : 
    RRETURN1(hr, E_INVALIDARG);
} // GetNumFragments

////////////////////////////////////////////////////////////////////////// 
//      Enumerator helper methods.
////////////////////////////////////////////////////////////////////////// 

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::GetFragmentCount
//
//  Overview:  Return the number of fragments in this composer
//
//------------------------------------------------------------------------
unsigned long
CAnimationComposerBase::GetFragmentCount (void) const
{
    return m_fragments.size();
} // CAnimationComposerBase::GetFragmentCount

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::GetFragment
//
//  Overview:  Retrieve a fragment from the composer's internal data structures
//
//  Arguments: the dispatch of the fragment
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerBase::GetFragment (unsigned long ulIndex, IDispatch **ppidispFragment)
{
    HRESULT hr;

    // Make sure we're in range.
    if (((GetFragmentCount() <= ulIndex) ) ||
        (NULL == ppidispFragment))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    {
        // Cycle the iterator until we find the right one.
        FragmentList::iterator i = m_fragments.begin();         
        for (unsigned long ulSlot = 0; ulSlot < ulIndex; i++, ulSlot++); //lint !e722
        IGNORE_RETURN((*i)->AddRef());
        *ppidispFragment = (*i);
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // CAnimationComposerBase::GetFragment 

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::PreprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::PreprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::PreprocessCompositionValue()",
              this));

    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // PreprocessCompositionValue

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerBase::PostprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerBase::PostprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationComposer,
              "CAnimationComposerBase(%p)::PostprocessCompositionValue()",
              this));
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // PostprocessCompositionValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: animelm.cpp
 *
 * Abstract: Simple animation of Elements
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "animfrag.h"
#include "animelm.h"
#include "animutil.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  
DeclareTag(tagAnimationTimeElm, "SMIL Animation", "CTIMEAnimationBase methods")
DeclareTag(tagAnimationTimeElmTest, "SMIL Animation", "CTIMEAnimationBase introspection")
DeclareTag(tagAnimationBaseValue, "SMIL Animation", "CTIMEAnimationBase composition callbacks")
DeclareTag(tagAnimationBaseValueAdditive, "SMIL Animation", "CTIMEAnimationBase additive animation")
DeclareTag(tagAnimationBaseState, "SMIL Animation", "CTIMEAnimationBase composition state changes")
DeclareTag(tagAnimationBaseOnChanged, "SMIL Animation", "CTIMEAnimationBase OnChanged method")
DeclareTag(tagAnimationTimeEvents, "SMIL Animation", "time events")
DeclareTag(tagAnimationFill, "SMIL Animation", "fill detection")
DeclareTag(tagAnimAccumulate, "SMIL Animation", "CTIMEAnimationBase Accumulation")

#define DEFAULT_ATTRIBUTE     NULL
#define DEFAULT_ADDITIVE      false
#define DEFAULT_ACCUMULATE    false
#define DEFAULT_TARGET        NULL
#define DEFAULT_KEYTIMES      NULL
#define DEFAULT_VALUES        NULL
#define DEFAULT_CALCMODE      CALCMODE_LINEAR
#define DEFAULT_ORIGIN        ORIGIN_DEFAULT
#define DEFAULT_PATH          NULL
#define DEFAULT_KEYSPLINES    NULL

#define NUMBER_KEYSPLINES     4
#define VALUE_NOT_SET         -999.998

static const LPWSTR s_cPSTR_SEMI_SEPARATOR  = L";";
static const LPWSTR s_cPSTR_SPACE_SEPARATOR = L" ";

long g_LOGPIXELSX = 0;
long g_LOGPIXELSY = 0;

///////////////////////////////////////////////////////////////
//  Name: CTIMEAnimationBase
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMEAnimationBase::CTIMEAnimationBase()
: m_bNeedAnimInit(true),
  m_spFragmentHelper(NULL),
  m_SAAttribute(DEFAULT_ATTRIBUTE),
  m_bAdditive(DEFAULT_ADDITIVE),
  m_bAdditiveIsSum(DEFAULT_ADDITIVE),
  m_bAccumulate(DEFAULT_ACCUMULATE),
  m_SATarget(DEFAULT_TARGET),
  m_SAValues(DEFAULT_VALUES),
  m_SAKeyTimes(DEFAULT_KEYTIMES),
  m_IACalcMode(DEFAULT_CALCMODE),
  m_SAPath(DEFAULT_PATH),
  m_IAOrigin(DEFAULT_ORIGIN),
  m_SAType(NULL),
  m_SASubtype(NULL),
  m_SAMode(NULL),
  m_SAFadeColor(NULL),
  m_VAFrom(NULL),
  m_VATo(NULL),
  m_VABy(NULL),
  m_bFrom(false),
  m_bNeedFirstUpdate(false),
  m_bNeedFinalUpdate(false),
  m_bNeedStartUpdate(false),
  m_bVML(false),
  m_fPropsLoaded(false),
  m_numValues(0),
  m_numKeyTimes(0),
  m_ppstrValues(NULL),
  m_pdblKeyTimes(NULL),
  m_dataToUse(NONE),
  m_dblTotalDistance(0.0),
  m_numKeySplines(0),
  m_pKeySplinePoints(NULL),
  m_SAKeySplines(DEFAULT_KEYSPLINES),
  m_SAAdditive(NULL),
  m_SAAccumulate(NULL),
  m_bNeedToSetInitialState(true)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::CTIMEAnimationBase()",
              this));

    m_AnimPropState.fDisableAnimation = false;
    m_AnimPropState.fForceCalcModeDiscrete = false;

    m_AnimPropState.fInterpolateValues = true;
    m_AnimPropState.fInterpolateFrom = true;
    m_AnimPropState.fInterpolateTo = true;
    m_AnimPropState.fInterpolateBy = true;

    m_AnimPropState.fBadBy = false;
    m_AnimPropState.fBadTo = false;
    m_AnimPropState.fBadFrom = false;
    m_AnimPropState.fBadValues = false;
    m_AnimPropState.fBadKeyTimes = false;

    m_AnimPropState.fAccumulate = false;
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMEAnimationBase
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMEAnimationBase::~CTIMEAnimationBase()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::~CTIMEAnimationBase()",
              this));
    
    int i;

    if (m_ppstrValues)
    {
        for (i = 0; i <m_numValues;i++)
        {
            delete [] m_ppstrValues[i];
        }
        delete [] m_ppstrValues;
    }
    if (m_pdblKeyTimes)
    {
        delete [] m_pdblKeyTimes;
    }
    if (m_pKeySplinePoints)
    {
        delete [] m_pKeySplinePoints;
    }

    delete [] m_SAAttribute.GetValue();
    delete [] m_SATarget.GetValue();
    delete [] m_SAValues.GetValue();
    delete [] m_SAKeyTimes.GetValue();
    delete [] m_SAKeySplines.GetValue();
    delete [] m_SAAccumulate.GetValue();
    delete [] m_SAAdditive.GetValue();
    delete [] m_SAPath.GetValue();
} 

///////////////////////////////////////////////////////////////
//  Name: CreateFragmentHelper
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::CreateFragmentHelper (void)
{
    HRESULT hr;

    if (m_spFragmentHelper != NULL)
    {
        IGNORE_RETURN(m_spFragmentHelper->Release());
    }

    hr = THR(CComObject<CAnimationFragment>::CreateInstance(&m_spFragmentHelper));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    IGNORE_RETURN(m_spFragmentHelper->AddRef());

    hr = m_spFragmentHelper->SetFragmentSite(this);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        m_spFragmentHelper->Release();
        m_spFragmentHelper = NULL;
    }

    RRETURN(hr);
} // CreateFragmentHelper

///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    CComPtr<IHTMLWindow2>   pWindow2;
    CComPtr<IHTMLScreen>    pScreen;
    CComPtr<IHTMLScreen2>   pScreen2;

    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Init()",
              this));

    HRESULT hr = E_FAIL; 
    CComPtr <IDispatch> pDocDisp;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }     

    hr = THR(GetElement()->get_document(&pDocDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&m_spDoc2));
    if (FAILED(hr))
    {
        goto done;
    }

    initScriptEngine();

    //get all elements in the document
    hr = THR(m_spDoc2->get_all(&m_spEleCol));
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument3, (void**)&m_spDoc3));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateFragmentHelper();
    if (FAILED(hr))
    {
        goto done;
    }

    if (g_LOGPIXELSX == 0 || g_LOGPIXELSY == 0)
    {
        hr = m_spDoc2->get_parentWindow(&pWindow2);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = pWindow2->get_screen(&pScreen);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = THR(pScreen->QueryInterface(IID_IHTMLScreen2, (void**)&pScreen2));
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = pScreen2->get_logicalXDPI(&g_LOGPIXELSX);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }

        hr = pScreen2->get_logicalYDPI(&g_LOGPIXELSY);
        if (FAILED(hr))
        {
            goto defaultDPI;
        }
    }

    hr = S_OK;

done:
    RRETURN(hr);

defaultDPI:
    AssertSz(FALSE, "Failed to determine logical DPI.  Using default 96 dpi.");
    g_LOGPIXELSX = 96;
    g_LOGPIXELSY = 96;
    goto done;
}


///////////////////////////////////////////////////////////////
//  Name: Error
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::Error()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Error()",
              this));
    
    LPWSTR  str = TIMEGetLastErrorString();
    HRESULT hr  = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEAnimationBase, &__uuidof(CTIMEAnimationBase)>::Error(str, IID_ITIMEAnimationElement, hr);
        delete [] str;
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: Notify
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Notify()",
              this));

    HRESULT hr = THR(CTIMEElementBase::Notify(event, pVar));

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: Detach
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::Detach()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::Detach()",
              this));

    IGNORE_RETURN(NotifyOnDetachFromComposer());
    if (m_spFragmentHelper != NULL)
    {
        m_spFragmentHelper->SetFragmentSite(NULL);
        IGNORE_RETURN(m_spFragmentHelper->Release());
        m_spFragmentHelper = NULL;
    }

    THR(CTIMEElementBase::Detach());
  
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyOnGetElement
//
//  Abstract: Get the fragment's element dispatch.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::NotifyOnGetElement (IDispatch **ppidispElement)
{
    HRESULT hr;

    if (NULL == ppidispElement)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *ppidispElement = GetElement();
    Assert(NULL != (*ppidispElement));
    IGNORE_RETURN((*ppidispElement)->AddRef());

    hr = S_OK;
done :
    RRETURN(hr);
} // NotifyOnGetElement


///////////////////////////////////////////////////////////////
//  Name: UpdateStartValue
//
//  Abstract: Refresh the m_varStartValue
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::UpdateStartValue (VARIANT *pvarNewStartValue)
{
    if (m_bNeedStartUpdate)
    {
        m_varStartValue.Clear();
        m_varStartValue.Copy(pvarNewStartValue);
        ConvertToPixels(&m_varStartValue);
        m_bNeedStartUpdate = false;
    }
} // UpdateStartValue 


///////////////////////////////////////////////////////////////
//  Name: GetAnimationRange
//
//  Abstract: Get the end point of the animation function over the
//            simple duration
//
///////////////////////////////////////////////////////////////
double 
CTIMEAnimationBase::GetAnimationRange()
{
    double dblReturnVal = 0.0;
    HRESULT hr = E_FAIL;
    CComVariant svarReturnVal(0.0);

    switch (m_dataToUse)
    {
        case VALUES:
            {
                if (!m_AnimPropState.fInterpolateValues)
                {
                    goto done;
                }

                if (m_numValues > 0)
                {
                    if (GetAutoReverse())
                    {
                        svarReturnVal = m_ppstrValues[0];
                    }
                    else
                    {
                        svarReturnVal = m_ppstrValues[m_numValues - 1];
                    }

                    if (NULL == svarReturnVal .bstrVal)
                    {
                        goto done;
                    }
                }
            }
            break;

        case TO:
            {
                if (!m_AnimPropState.fInterpolateTo)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    if (m_bFrom)
                    {
                        if (!m_AnimPropState.fInterpolateFrom)
                        {
                            goto done;
                        }
                    
                        hr = VariantCopy(&svarReturnVal , &m_varFrom);
                        if (FAILED(hr))
                        {
                            goto done;
                        }
                    }

                    // For "to" animations (i.e. no "from"), accumulation is disabled, 
                    // so we do not need to handle it.
                }
                else
                {
                    hr = VariantCopy(&svarReturnVal , &m_varTo);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
            }
            break;

        case BY:
            {
                double dblFrom = 0.0;

                if (!m_AnimPropState.fInterpolateBy)
                {
                    goto done;
                }

                if (m_bFrom)
                {
                    CComVariant svarFrom;
                    
                    if (!m_AnimPropState.fInterpolateFrom)
                    {
                        goto done;
                    }

                    hr = VariantCopy(&svarFrom, &m_varFrom);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                
                    if (ConvertToPixels(&svarFrom))
                    {
                        dblFrom = V_R8(&svarFrom);
                    }
                }

                if (GetAutoReverse())
                {
                    svarReturnVal = dblFrom;
                }
                else
                {
                    hr = VariantCopy(&svarReturnVal , &m_varBy);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    if (ConvertToPixels(&svarReturnVal))
                    {
                        V_R8(&svarReturnVal) += dblFrom;
                    }
                }
            }
            break;

        default:
            break;
    } // switch

    if (ConvertToPixels(&svarReturnVal))
    {
        dblReturnVal = V_R8(&svarReturnVal );
    }

done:
    return dblReturnVal;
}

///////////////////////////////////////////////////////////////
//  Name: DoAccumulation
//
//  Abstract: 
//    
///////////////////////////////////////////////////////////////
void 
CTIMEAnimationBase::DoAccumulation (VARIANT *pvarValue)
{
    if (VT_R8 != V_VT(pvarValue))
    {
        if (!ConvertToPixels(pvarValue))
        {
            goto done;
        }
    }

    // offset the current value with the accumulated iterations
    if (VT_R8 == V_VT(pvarValue))
    {
        // get the animation range
        double dblAnimRange = GetAnimationRange();

        // get the number of iterations elapsed
        long lCurrRepeatCount = GetMMBvr().GetCurrentRepeatCount();

        V_R8(pvarValue) += dblAnimRange * lCurrRepeatCount;

        TraceTag((tagAnimAccumulate, "CTIMEAnimationBase(%p, %ls)::DoAccumulation range=%lf currRepeatCount=%d",
            this, GetID(), dblAnimRange, lCurrRepeatCount));
    }

done:
    return;
} // DoAccumulation


///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract: Convert a variant into canonical form (BSTR or R8).
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld)
{
    HRESULT hr;

    // Preprocess the data into a canonical form
    // for this fragment - that is either a
    // BSTR or a VT_R8.
    if ((VT_R8 != V_VT(pvarValue)) && (VT_BSTR != V_VT(pvarValue)))
    {
        // VT_R8 is the closest thing we have to a canonical form for composition
        // and interpolation.
        *pvtOld = V_VT(pvarValue);
        hr = THR(::VariantChangeTypeEx(pvarValue, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UncanonicalizeValue
//
//  Abstract: Convert a variant from canonical form (BSTR or R8)
//            into its original form.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::UncanonicalizeValue (VARIANT *pvarValue, VARTYPE vtOld)
{
    HRESULT hr;

    if (VT_EMPTY != vtOld)
    {
        hr = THR(::VariantChangeTypeEx(pvarValue, pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, vtOld));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // UncanonicalizeValue


///////////////////////////////////////////////////////////////
//  Name: ValidateState
//
//  Abstract: Checks state of properties. Determines whether:
//              1. Animation should be disabled
//              2. CalcMode should be forced to "discrete"
//            
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::ValidateState()
{
    bool fIsValid = false;

    // see which attributes have been set
    bool fValues         = ((VALUES == m_dataToUse) || m_AnimPropState.fBadValues);
    bool fKeyTimes       = (m_AnimPropState.fBadKeyTimes || m_pdblKeyTimes || m_numKeyTimes);
    bool fKeySplines     = (m_pKeySplinePoints || m_numKeySplines);
    bool fCalcModeSpline = (CALCMODE_SPLINE == m_IACalcMode);
    bool fCalcModeLinear = (CALCMODE_LINEAR == m_IACalcMode);
    bool fCalcModePaced  = (CALCMODE_PACED  == m_IACalcMode);
    bool fTo             = (m_AnimPropState.fBadTo || (TO == m_dataToUse));

    //
    // The order of checking is important. For an attribute below to be valid, all attributes
    // checked before it must be valid.
    //

    // Validate from/by/to (ignored if "values" is specified)
    if (!fValues)
    {
        if (m_AnimPropState.fBadFrom || m_AnimPropState.fBadTo)
        {
            goto done;
        }

        // validate "by" (ignored if "to" is specified)
        if (!fTo && m_AnimPropState.fBadBy)
        {
            goto done;
        }

        // check if we need to default to calcMode="discrete" 
        if (    (!m_AnimPropState.fInterpolateFrom)
            ||  (!m_AnimPropState.fInterpolateTo)
            ||  (   (!fTo)
                 && (!m_AnimPropState.fInterpolateBy)))
        {
            m_AnimPropState.fForceCalcModeDiscrete = true;
        }
        else
        {
            m_AnimPropState.fForceCalcModeDiscrete = false;
        }
    }
    else
    {
        // Validate values
        if (m_AnimPropState.fBadValues || !m_ppstrValues || !m_numValues)
        {
            goto done;
        }

        // check if we need to default to calcMode="discrete" 
        if (    (m_numValues < 2)
            ||  (false == m_AnimPropState.fInterpolateValues))
        {
            m_AnimPropState.fForceCalcModeDiscrete = true;
        }
        else
        {
            m_AnimPropState.fForceCalcModeDiscrete = false;
        }
    }

    // validate keyTimes
    if (!fCalcModePaced)
    {
        // validate keyTimes 
        if (fKeyTimes)
        {
            if (m_AnimPropState.fBadKeyTimes || !m_pdblKeyTimes || !m_numKeyTimes)
            {
                goto done;
            }
            else if ((fCalcModeLinear || fCalcModeSpline)
                    && (1 != m_pdblKeyTimes[m_numKeyTimes - 1]))
            {
                goto done;
            }

            // Not worth putting in a virtual function since m_dataToUse is aware of paths
            if (PATH != m_dataToUse)
            {
                if (!fValues)
                {
                    goto done;
                }
                else if (m_numKeyTimes != m_numValues)
                {
                    goto done;
                }
            }
        }
    }

    // validate CalcMode="spline"
    if (fCalcModeSpline)
    {
        if (!fKeySplines || !fKeyTimes)
        {
            goto done;
        }
        else if (m_numKeySplines != (m_numKeyTimes - 1))
        {
            goto done;
        }
    }

    // validate accumulate
    if (    (TO == m_dataToUse)
        &&  (!m_bFrom))
    {
        // Accumulate ignored for "to" animations (i.e. no "from" specified)
        m_bAccumulate = false;
    }
    else
    {
        // use the accumulate value that was set
        m_bAccumulate = m_AnimPropState.fAccumulate;
    }

    fIsValid = true;
done:
    m_AnimPropState.fDisableAnimation = !(fIsValid);
} // ValidateState

///////////////////////////////////////////////////////////////
//  Name: UpdateCurrentBaseTime
//
//  Abstract: Examine the current base time, and update it if 
//            we're doing baseline+to animation (the spec calls
//            this hybrid additive).
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::UpdateCurrentBaseline (const VARIANT *pvarCurrent)
{
    // Are we doing hybrid additive animation?
    if (   (TO == m_dataToUse)
        && (!m_bFrom))
    {
        // Filter out the initial call (when last-value hasn't been set.
        if (VT_EMPTY != V_VT(&m_varLastValue))
        {
            bool bNeedUpdate = false;

            if (V_VT(&m_varLastValue) == V_VT(pvarCurrent))
            {
                // Has the baseline value changed since we updated it last?
                // We really only care about canonicalized values (R8 or BSTR)
                if (VT_R8 == V_VT(&m_varLastValue))
                {
                    bNeedUpdate = (V_R8(pvarCurrent) != V_R8(&m_varLastValue));
                }
                else if (VT_BSTR == V_VT(&m_varLastValue))
                {
                    bNeedUpdate = (0 != StrCmpW(V_BSTR(pvarCurrent), V_BSTR(&m_varLastValue)));
                }
            }
            else
            {
                bNeedUpdate = true;
            }

            if (bNeedUpdate)
            {
                THR(::VariantCopy(&m_varCurrentBaseline, const_cast<VARIANT *>(pvarCurrent)));
            }
        }
    }
} // UpdateCurrentBaseTime

///////////////////////////////////////////////////////////////
//  Name: CalculateValue
//
//  Abstract: Do interpolation and postprocessing.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::CalculateValue (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    HRESULT hr = E_FAIL;

    if (m_AnimPropState.fForceCalcModeDiscrete)
    {
        hr = calculateDiscreteValue(pvarValue);
    }
    else
    {
        switch(m_IACalcMode)
        {
            case CALCMODE_DISCRETE :
                hr = calculateDiscreteValue(pvarValue);
                break;

            case CALCMODE_LINEAR :
                hr = calculateLinearValue(pvarValue);
                break;

            case CALCMODE_SPLINE :
                hr = calculateSplineValue(pvarValue);
                break;

            case CALCMODE_PACED :
                hr = calculatePacedValue(pvarValue);
                break;
        
            default :
                break;
        }
    }

    PostprocessValue(pvarCurrent, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CalculateValue

///////////////////////////////////////////////////////////////
//  Name: DoAdditive
//
//  Abstract: Add the offset value into the composition's in/out param.
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::DoAdditive (const VARIANT *pvarOrig, VARIANT *pvarValue)
{
    if (VT_R8 != V_VT(pvarValue))
    {
        if (!ConvertToPixels(pvarValue))
        {
            goto done;
        }
    }

    Assert(VT_R8 == V_VT(pvarValue));
    if (VT_R8 == V_VT(pvarValue))
    {
        CComVariant varCurrentCopy;
        HRESULT hr = THR(varCurrentCopy.Copy(pvarOrig));

        if (FAILED(hr))
        {
            goto done;
        }

        // Need to translate this into numeric form, in
        // order to perform the addition.
        if (!ConvertToPixels(&varCurrentCopy))
        {
            TraceTag((tagAnimationBaseValueAdditive,
                      "CTIMEAnimationBase(%p)::DoAdditive() : Failed to convert current value of type %X to numeric form",
                      this, V_VT(&varCurrentCopy)));
            goto done;
        }

        TraceTag((tagAnimationBaseValueAdditive,
                  "CTIMEAnimationBase(%p)::DoAdditive(calculated value is %lf, previous current value is %lf)",
                  this, V_R8(pvarValue), V_R8(&varCurrentCopy)));
        V_R8(pvarValue) += V_R8(&varCurrentCopy);
    }

done :
    return;
} // DoAdditive

///////////////////////////////////////////////////////////////
//  Name: DoFill
//
//  Abstract: Handle the fill interval.
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEAnimationBase::DoFill (VARIANT *pvarValue)
{
    HRESULT hr;

    if (IsOn() && m_varLastValue.vt != VT_EMPTY && m_timeAction.IsTimeActionOn())
    {
#if DBG
        {
            CComVariant varLast;
            varLast.Copy(&m_varLastValue);
            varLast.ChangeType(VT_R8);
            TraceTag((tagAnimationFill,
                      "CTIMEAnimationBase(%p, %ls) detected fill to %lf",
                      this, GetID(), V_R8(&varLast)));
        }
#endif

        VariantCopy(pvarValue,&m_varLastValue);
        m_bNeedToSetInitialState = true;
    }
    else if (m_bNeedToSetInitialState)
    {
#if DBG
        {
            CComVariant varBase;
            varBase.Copy(&m_varBaseline);
            varBase.ChangeType(VT_R8);
            TraceTag((tagAnimationFill,
                      "CTIMEAnimationBase(%p, %ls) applying initial value %lf",
                      this, GetID(), V_R8(&varBase)));
        }
#endif
        VariantCopy(pvarValue,&m_varBaseline);
        m_bNeedToSetInitialState = false;
        SetFinalState();
    }
    else
    {
        // Fail on the case that we have never started..
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_FAIL);
} // DoFill

///////////////////////////////////////////////////////////////
//  Name: PostprocessValue
//
//  Abstract: Apply additive, accumulate passes and save the value.
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    if (m_bAdditive)
    {
        DoAdditive(pvarCurrent, pvarValue);
    }
    if (m_bAccumulate)
    {
        DoAccumulation(pvarValue);
    }
    THR(::VariantCopy(&m_varLastValue, pvarValue));

    TraceTag((tagAnimAccumulate, "CTIMEAnimationBase(%p, %ls)::PostprocessValue m_varLastValue=%lf",
        this, GetID(), V_R8(&m_varLastValue)));

} // PostprocessValue

///////////////////////////////////////////////////////////////
//  Name: NotifyOnGetValue
//
//  Abstract: Compose the new value of the in/out variant
//            according to our interpolation logic.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::NotifyOnGetValue (BSTR, 
                                      VARIANT varOriginal, VARIANT varCurrentValue, 
                                      VARIANT *pvarInOutValue)
{
    HRESULT hr = S_OK;
    VARTYPE vtOrigType = VT_EMPTY;

    // Do we have work to do?
    if (NONE == m_dataToUse)
    {
        hr = E_FAIL;
        goto done;
    }

    // Check if we need to do anything
    if (DisableAnimation())
    {
        hr = E_FAIL;
        goto done;
    }
    
    // Check first and final states
    // Checking the final state first permits
    // a reset to trigger a final state followed
    // by initial ... this is what needs to happen 
    // during a restart.

    hr = THR(::VariantCopy(pvarInOutValue, &varCurrentValue));
    vtOrigType = V_VT(pvarInOutValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CanonicalizeValue(pvarInOutValue, &vtOrigType);
    if (FAILED(hr))
    {
        goto done;
    }

    if (QueryNeedFinalUpdate())
    {
        OnFinalUpdate(&varCurrentValue, pvarInOutValue);
        hr = S_OK;
        goto done;
    }
    else if (QueryNeedFirstUpdate())
    {
        OnFirstUpdate(pvarInOutValue);
    }
    
    // If we're not playing, apply the fill
    if (IsActive())
    {
        UpdateStartValue(&varOriginal);
        UpdateCurrentBaseline(&varCurrentValue);
        m_varLastValue.Copy(pvarInOutValue);
        hr = CalculateValue(&varCurrentValue, &m_varLastValue);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(::VariantCopy(pvarInOutValue, &m_varLastValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = DoFill(pvarInOutValue);
        goto done;
    }

    hr = S_OK;
done :

    // Postprocess the from canonical form
    // to its original type.
    hr = UncanonicalizeValue(pvarInOutValue, vtOrigType);

    RRETURN(hr);
} // NotifyOnGetValue

///////////////////////////////////////////////////////////////
//  Name: NotifyOnDetachFromComposer
//
//  Abstract: Let go of any refs to the composer site.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEAnimationBase::NotifyOnDetachFromComposer (void)
{
    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstrAttribName;

        bstrAttribName = m_SAAttribute;
        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->RemoveFragment(bstrAttribName, m_spFragmentHelper));
        IGNORE_RETURN(m_spCompSite.Release()); //lint !e792
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // NotifyOnDetachFromComposer

///////////////////////////////////////////////////////////////
//  Name: SetInitialState
//
//  Abstract: set an initial internal state
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::SetInitialState (void)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::SetInitialState()",
              this));

    m_bNeedFirstUpdate = true;
    m_bNeedFinalUpdate = false;
} // SetInitialState

///////////////////////////////////////////////////////////////
//  Name: SetFinalState
//
//  Abstract: set an final internal state
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::SetFinalState (void)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::SetFinalState()",
              this));

    m_bNeedFinalUpdate = true;
} // SetFinalState

///////////////////////////////////////////////////////////////
//  Name: OnFirstUpdate
//
//  Abstract: save the baseline value of the animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnFirstUpdate (VARIANT *pvarValue)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::OnFirstUpdate()",
              this));

    m_varStartValue.Clear();
    m_bNeedStartUpdate = true;
    THR(m_varBaseline.Copy(pvarValue));
    THR(m_varCurrentBaseline.Copy(pvarValue));

    m_bNeedFirstUpdate = false;

#if DBG

    if (VT_BSTR == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value of %ls",
                  this, V_BSTR(pvarValue)));
    }
    else if (VT_R4 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value of %f",
                  this, V_R4(pvarValue)));
    }
    else if (VT_R8 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value of %lf",
                  this, V_R8(pvarValue)));
    }
    else 
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) saving initial value in variant of type %X",
                  this, V_VT(pvarValue)));
    }
#endif
} // OnFirstUpdate

///////////////////////////////////////////////////////////////
//  Name: OnFinalUpdate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::OnFinalUpdate()",
              this));

    HRESULT hr = E_FAIL;
    bool bNeedPostprocess = false;

    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p, %ls)::OnFinalUpdate() - progress = %lf",
              this,
              GetID()?GetID():L"",
              GetMMBvr().GetProgress()));

    // Ended before we hit progress value of 1, and we want to apply a fill.
    if ((GetMMBvr().GetProgress() != 1) && NeedFill())
    {
        VariantClear(pvarValue);
        hr = THR(::VariantCopy(pvarValue, &m_varLastValue));
        if (FAILED(hr))
        {
            goto done;
        }  
    }
    // Ended when we hit progress value of 1, and we want to apply a fill.
    else if (NeedFill() &&
            (m_dataToUse != NONE))
    {
        bool fDontPostProcess = false;

        GetFinalValue(pvarValue, &fDontPostProcess);

        if (!fDontPostProcess)
        {
            bNeedPostprocess = true;
        }
    }
    // reset the animation - no fill.
    else
    {
        resetValue(pvarValue);
        // Indicate that we don't need to perform 
        // the additive work.
        if (!QueryNeedFirstUpdate())
        {
            endAnimate();
        }
    }

    if (bNeedPostprocess)
    {
        PostprocessValue(pvarCurrent, pvarValue);
    }

done :

#if DBG
    if (VT_BSTR == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is %ls",
                  this, m_SAAttribute, V_BSTR(pvarValue)));
    }
    else if (VT_R4 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is %f",
                  this, m_SAAttribute, V_R4(pvarValue)));
    }
    else if (VT_R8 == V_VT(pvarValue))
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is %lf",
                  this, m_SAAttribute, V_R8(pvarValue)));
    }
    else 
    {
        TraceTag((tagAnimationBaseState,
                  "CTIMEAnimationBase(%p) final value of %ls is variant of type %X",
                  this, m_SAAttribute, V_VT(pvarValue)));
    }
#endif

    m_bNeedFinalUpdate = false;
} // OnFinalUpdate

///////////////////////////////////////////////////////////////
//  Name: OnBegin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p, %ls)::OnBegin()",
              this,
              GetID()?GetID():L""));

    if(m_bNeedAnimInit)
    {
        initAnimate();
    }

    SetInitialState();
    CTIMEElementBase::OnBegin(dblLocalTime, flags);
    
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: OnEnd
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnEnd(double dblLocalTime)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p, %ls)::OnEnd()",
              this,
              GetID()?GetID():L""));

    SetFinalState();
    CTIMEElementBase::OnEnd(dblLocalTime);
}


///////////////////////////////////////////////////////////////
//  Name: resetValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::resetValue(VARIANT *pvarValue)
{
    if (m_varBaseline.vt != VT_EMPTY)
    {
        Assert(NULL != pvarValue);
        IGNORE_HR(THR(::VariantCopy(pvarValue, &m_varBaseline)));
        IGNORE_HR(THR(::VariantCopy(&m_varCurrentBaseline, &m_varBaseline)));
    }
}


///////////////////////////////////////////////////////////////
//  Name: OnReset
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p)::OnReset(%lf, %#X)",
              this, dblLocalTime, flags));

    CTIMEElementBase::OnReset(dblLocalTime, flags);
}


///////////////////////////////////////////////////////////////
//  Name: OnTEPropChange
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnTEPropChange(DWORD tePropType)
{
    CTIMEElementBase::OnTEPropChange(tePropType);

    if ((tePropType & TE_PROPERTY_ISON) != 0)
    {
        // check if we need to be added to the composer
        // This condition is true only when an animation is in
        // the fill region but is not added to the composer.
        if (    m_bNeedAnimInit
            &&  m_mmbvr->IsOn()
            &&  (!(m_mmbvr->IsActive()))
            &&  NeedFill()) 
        {
            TraceTag((tagAnimationTimeEvents,
                      "CTIMEAnimationBase(%p, %ls)::OnTEPropChange() - Inited Animation",
                      this,
                      GetID()?GetID():L""));
            // Add ourselves because we need to be ticked in this condition.
            initAnimate();

            // need to recalc our final state to ensure correct fill value
            m_bNeedFinalUpdate = true;
        }
    }
} // OnTEPropChange


///////////////////////////////////////////////////////////////
//  Name: OnUnload
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnUnload()
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p)::OnUnload()",
              this));

    CTIMEElementBase::OnUnload();
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEAnimationBase::NotifyPropertyChanged, CBaseBvr
//
//  Synopsis:   Make sure to force any in-progress animations to initialize when
//              a property changes.
//
//  Arguments:  DISPID of the changed property (passed to the superclass implementation.
//
//  Returns:    
//
//------------------------------------------------------------------------------------
void 
CTIMEAnimationBase::NotifyPropertyChanged(DISPID dispid)
{
    CTIMEElementImpl<ITIMEAnimationElement2, &IID_ITIMEAnimationElement2>::NotifyPropertyChanged(dispid);

    // If we're already initialized, make sure to force a restart.
    if (m_fPropsLoaded)
    {
        resetAnimate();
    }

done :
    return;
} // NotifyPropertyChanged

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEAnimationBase::OnPropertiesLoaded, CBaseBvr
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEAnimationBase::OnPropertiesLoaded(void)
{
    TraceTag((tagAnimationTimeEvents,
              "CTIMEAnimationBase(%p)::OnPropertiesLoaded()",
              this));

    HRESULT hr;
    // Once we've read the properties in, 
    // set up the timeline.  This is immutable
    // in script.

    hr = CTIMEElementBase::OnPropertiesLoaded();
    m_fPropsLoaded = true;

done:
    RRETURN(hr);
} // OnPropertiesLoaded


///////////////////////////////////////////////////////////////
//  Name: GetConnectionPoint
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEAnimationBase::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

///////////////////////////////////////////////////////////////
//  Name: get_attributename
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEAnimationBase::get_attributeName(BSTR *attrib)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(attrib);

    if (m_SAAttribute.GetValue())
    {
        *attrib = SysAllocString(m_SAAttribute.GetValue());
        if (NULL == *attrib)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_attributename
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_attributeName(BSTR attrib)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(attrib);

    // This will clean out the old value.
    // We need to can the old composer et al.
    if (NULL != m_SAAttribute.GetValue())
    {
        endAnimate();
    }

    delete [] m_SAAttribute.GetValue();
    m_SAAttribute.Reset(DEFAULT_ATTRIBUTE);

    m_SAAttribute.SetValue(CopyString(attrib));
    if (NULL == m_SAAttribute.GetValue())
    {
        hr = E_OUTOFMEMORY;
    }

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ATTRIBUTENAME);

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_targetElement
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEAnimationBase::get_targetElement (BSTR *target)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(target);

    if (m_SATarget.GetValue())
    {
        *target = SysAllocString(m_SATarget.GetValue());
        if (NULL == *target)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_targetElement
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_targetElement (BSTR target)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(target);

    delete [] m_SATarget.GetValue();
    m_SATarget.Reset(DEFAULT_TARGET);

    m_SATarget.SetValue(CopyString(target));
    if (NULL == m_SATarget.GetValue())
    {
        hr = E_OUTOFMEMORY;
    }

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_TARGETELEMENT);

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: put_keytimes
  //
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_keyTimes(BSTR val)
{
    HRESULT hr = E_FAIL;  
    CComVariant varTemp;
    int i;
    CPtrAry<STRING_TOKEN*> aryTokens;
    OLECHAR *sString = NULL;
    OLECHAR sTemp[INTERNET_MAX_URL_LENGTH];

    CHECK_RETURN_NULL(val);

    m_AnimPropState.fBadKeyTimes = false;

    // reset the attribute
    delete [] m_SAKeyTimes.GetValue();
    m_SAKeyTimes.Reset(DEFAULT_KEYTIMES);

    if (m_pdblKeyTimes)
    {
        delete [] m_pdblKeyTimes;
        m_pdblKeyTimes = NULL;
    }

    // store off the values
    m_SAKeyTimes.SetValue(CopyString(val));
    if (m_SAKeyTimes.GetValue() == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Parse out the values.....
    sString = CopyString(val);
    if (sString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = ::StringToTokens(sString, s_cPSTR_SEMI_SEPARATOR, &aryTokens);
    m_numKeyTimes = aryTokens.Size();
    if (FAILED(hr) ||
        m_numKeyTimes == 0)
    {
        goto done;
    }

    m_pdblKeyTimes = NEW double [m_numKeyTimes];
    if (NULL == m_pdblKeyTimes)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    for(i = 0; i < m_numKeyTimes; i++)
    {
        if (INTERNET_MAX_URL_LENGTH <= (lstrlenW(sString+aryTokens.Item(i)->uIndex) + 2))
        {
            hr = E_INVALIDARG;
            m_numKeyTimes = i;
            goto done;
        }
        StrCpyNW(sTemp,sString+aryTokens.Item(i)->uIndex,aryTokens.Item(i)->uLength+1);
        varTemp = sTemp;
        hr = VariantChangeTypeEx(&varTemp,&varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if(FAILED(hr))
        {
            m_numKeyTimes = i;
            goto done;
        }
        m_pdblKeyTimes[i] = V_R8(&varTemp);
    }
    
    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_KEYTIMES);

    if (m_pdblKeyTimes)
    {
        // verify key times are in increasing order
        bool fIncreasingOrder = true;
        for(int index = 1; index < m_numKeyTimes; index++)
        {
            if (m_pdblKeyTimes[index - 1] > m_pdblKeyTimes[index])
            {
               fIncreasingOrder = false;
               break;
            }
        }

        // check whether keytimes are in increasing order, first keyTime is 0 
        // and last keyTime is less than or equal to 1
        if (    (!fIncreasingOrder)
            ||  (m_pdblKeyTimes[0] != 0)
            ||  (m_pdblKeyTimes[m_numKeyTimes - 1] > 1))
        {
            // delete the keytimes and say that they are invalid.
            delete [] m_pdblKeyTimes;
            m_pdblKeyTimes = NULL;
            m_numKeyTimes = 0;
            m_AnimPropState.fBadKeyTimes = true;
        }
    }

    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    if (sString != NULL)
    {
        delete [] sString;
    }

    ValidateState();

    RRETURN(hr);
} // put_keyTimes


///////////////////////////////////////////////////////////////
//  Name: get_keytimes
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_keyTimes(BSTR * val)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(val);

    if (m_SAKeyTimes.GetValue())
    {
        *val = SysAllocString(m_SAKeyTimes.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: ValidateValueListItem
//
///////////////////////////////////////////////////////////////
bool
CTIMEAnimationBase::ValidateValueListItem (const VARIANT *pvarValueItem)
{
    return ConvertToPixels(const_cast<VARIANT *>(pvarValueItem));
} // ValidateValueListItem


///////////////////////////////////////////////////////////////
//  Name: put_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_values(VARIANT val)
{
    HRESULT                 hr = E_FAIL;
    CComVariant             svarTemp;
    int                     i;
    CPtrAry<STRING_TOKEN*>  aryTokens;
    LPWSTR                  pstrValues = NULL;
    bool                    fCanInterpolate = true; 
    DATATYPES dt;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    delete [] m_SAValues.GetValue();
    m_SAValues.Reset(DEFAULT_VALUES);

    // Clear and reset internal state
    if (m_ppstrValues)
    {
        for (i = 0; i <m_numValues;i++)
        {
            delete [] m_ppstrValues[i];
        }
        delete [] m_ppstrValues;
        m_ppstrValues = NULL;
    }
    m_numValues = 0;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    // convert to BSTR
    hr = THR(svarTemp.Copy(&val));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(VariantChangeTypeEx(&svarTemp, &svarTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        goto done;
    }

    // Store the new attribute string
    pstrValues = CopyString(V_BSTR(&svarTemp));
    if (NULL == pstrValues)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    m_SAValues.SetValue(pstrValues);

    // Tokenize the values
    hr = THR(::StringToTokens(pstrValues, s_cPSTR_SEMI_SEPARATOR , &aryTokens));
    m_numValues = aryTokens.Size();
    if (FAILED(hr)) 
    {
        goto done;
    }

    // check for an empty string
    if (0 == m_numValues)
    {
        hr = S_OK;
        goto done;
    }

    // create array of values
    m_ppstrValues = NEW LPOLESTR [m_numValues];
    if (NULL == m_ppstrValues)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    ZeroMemory(m_ppstrValues, sizeof(LPOLESTR) * m_numValues);

    // parse the values
    for (i = 0; i < m_numValues; i++)
    {
        UINT uTokLength = aryTokens.Item(i)->uLength;
        UINT uIndex = aryTokens.Item(i)->uIndex;

        // alloc a string to hold the token
        m_ppstrValues[i] = NEW OLECHAR [uTokLength + 1];
        if (NULL == m_ppstrValues[i])
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // NULL terminate the string
        m_ppstrValues[i][uTokLength] = NULL;

        // copy the token value
        StrCpyNW(m_ppstrValues[i], 
                 pstrValues + uIndex, 
                 uTokLength + 1); 

        // Check to see if we can interpolate
        if (fCanInterpolate)
        {
            svarTemp = m_ppstrValues[i];
            if (NULL != svarTemp.bstrVal)
            {
                if (!ValidateValueListItem(&svarTemp))
                {
                    fCanInterpolate = false;
                }
                svarTemp.Clear();
            }
        }
    }

    dt = VALUES;
    
    hr = S_OK;
done:
    if (FAILED(hr))
    {
        for (i = 0; i < m_numValues; i++)
        {
            delete [] m_ppstrValues[i];
        }
        delete [] m_ppstrValues;
        m_ppstrValues = NULL;
    }

    updateDataToUse(dt);

    m_AnimPropState.fInterpolateValues = fCanInterpolate;

    CalculateTotalDistance();
    
    ValidateState();

    DetermineAdditiveEffect();

    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_VALUES);

    // do not delete pstrValues! Its memory is re-used by m_SAValues.
    
    
    RRETURN(hr);
} // put_values


///////////////////////////////////////////////////////////////
//  Name: get_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_values(VARIANT * pvarVal)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_NULL(pvarVal);

    VariantInit(pvarVal);

    if (m_SAValues.GetValue())
    {
        V_BSTR(pvarVal) = SysAllocString(m_SAValues.GetValue());
        if (NULL == V_BSTR(pvarVal))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            V_VT(pvarVal) = VT_BSTR;
        }
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: put_keysplines
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_keySplines(BSTR val)
{
    HRESULT hr = E_FAIL;
    CPtrAry<STRING_TOKEN*> aryTokens;
    CPtrAry<STRING_TOKEN*> aryTokens2;
    OLECHAR *sString = NULL;
    OLECHAR sTemp[INTERNET_MAX_URL_LENGTH];
    OLECHAR sTemp2[INTERNET_MAX_URL_LENGTH];
    CComVariant varValue;
    int i;

    CHECK_RETURN_NULL(val);

    delete [] m_SAKeySplines.GetValue();
    m_SAKeySplines.Reset(DEFAULT_KEYSPLINES);

    delete [] m_pKeySplinePoints;
    m_pKeySplinePoints = NULL;
    m_numKeySplines = 0;

    m_SAKeySplines.SetValue(CopyString(val));
    if (m_SAKeySplines.GetValue() == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_KEYSPLINES); 
    
    // Parse out the values.....
    sString = CopyString(val);
    if (sString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // tokenize the values
    hr = ::StringToTokens(sString, s_cPSTR_SEMI_SEPARATOR, &aryTokens);
    m_numKeySplines = aryTokens.Size();
    if (FAILED(hr) ||
        m_numKeySplines == 0)
    {
        goto done;
    }

    m_pKeySplinePoints = NEW SplinePoints [m_numKeySplines];
    if (NULL == m_pKeySplinePoints)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    for (i=0; i< m_numKeySplines; i++)
    {
        if (INTERNET_MAX_URL_LENGTH <= (lstrlenW(sString+aryTokens.Item(i)->uIndex) + 2))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        StrCpyNW(sTemp,sString+aryTokens.Item(i)->uIndex,aryTokens.Item(i)->uLength+1);

        hr = ::StringToTokens(sTemp, s_cPSTR_SPACE_SEPARATOR, &aryTokens2);
        if (FAILED(hr) ||
            aryTokens2.Size() != NUMBER_KEYSPLINES) // We must have four values or there is an error
        {
            hr = E_FAIL;
            goto done;
        }

        // fill in the Data...
        if (INTERNET_MAX_URL_LENGTH <= (lstrlenW(sTemp+aryTokens2.Item(0)->uIndex) + 2))
        {
            hr = E_INVALIDARG;
            goto done;
        }
        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(0)->uIndex,aryTokens2.Item(0)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].x1 = V_R8(&varValue);

        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(1)->uIndex,aryTokens2.Item(1)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].y1 = V_R8(&varValue);

        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(2)->uIndex,aryTokens2.Item(2)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].x2 = V_R8(&varValue);

        StrCpyNW(sTemp2,sTemp+aryTokens2.Item(3)->uIndex,aryTokens2.Item(3)->uLength+1);
        varValue = sTemp2;
        hr = ::VariantChangeTypeEx(&varValue,&varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if (    FAILED(hr)
            ||  (V_R8(&varValue) < 0)
            ||  (V_R8(&varValue) > 1))
        {
            hr = E_FAIL;
            goto done;
        }
        m_pKeySplinePoints[i].y2 = V_R8(&varValue);
        
        // Create samples for linear interpolation
        SampleKeySpline(m_pKeySplinePoints[i]);

        IGNORE_HR(::FreeStringTokenArray(&aryTokens2));
    }

    hr = S_OK;
done:
    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    if (sString != NULL)
    {
        delete [] sString;
    }
    if (FAILED(hr))
    {
        // free memory
        delete [] m_pKeySplinePoints;
        m_pKeySplinePoints = NULL;

        m_numKeySplines = 0;

        IGNORE_HR(::FreeStringTokenArray(&aryTokens2));
    }

    ValidateState();

    RRETURN(hr);
} // put_keySplines


///////////////////////////////////////////////////////////////
//  Name: get_keysplines
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_keySplines(BSTR * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(val);

    if (m_SAKeySplines.GetValue())
    {
        *val = SysAllocString(m_SAKeySplines.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: DetermineAdditiveEffect
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::DetermineAdditiveEffect (void)
{
    // by w/o from implies additive
    if (   (BY == m_dataToUse)
        && (VT_EMPTY != V_VT(&m_varBy))
        && (VT_EMPTY == V_VT(&m_varFrom)))
    {
        m_bAdditive = true;
    }
    // to w/o from overrides the additive=sum effect.
    else if (   (TO == m_dataToUse)
             && (VT_EMPTY != V_VT(&m_varTo))
             && (VT_EMPTY == V_VT(&m_varFrom)))
    {
        m_bAdditive = false;
    }
    // 
    else
    {
        m_bAdditive = m_bAdditiveIsSum;
    }
} // DetermineAdditiveEffect


///////////////////////////////////////////////////////////////
//  Name: put_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_from(VARIANT val)
{
    HRESULT hr = E_FAIL;

    // reset this attribute
    m_VAFrom.Reset(NULL);
    m_varDOMFrom.Clear();
    m_varFrom.Clear();
    m_bFrom = false;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = VariantCopy(&m_varDOMFrom,&val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VAFrom.SetValue(NULL);

    hr = VariantCopy(&m_varFrom,&val);
    if (FAILED(hr))
    {
        goto done;
    }

    if (ConvertToPixels(&m_varFrom))
    {
        m_AnimPropState.fInterpolateFrom = true;
    }
    else
    {
        m_AnimPropState.fInterpolateFrom = false;
    }

    m_bFrom = true;

    hr = S_OK;
done:
    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_FROM);

    RRETURN(hr);
} // put_from


///////////////////////////////////////////////////////////////
//  Name: get_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_from(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varDOMFrom);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_to(VARIANT val)
{
    HRESULT hr = E_FAIL;
    DATATYPES dt;

    // reset this attribute
    dt = RESET;
    m_VATo.Reset(NULL);
    m_varDOMTo.Clear();
    m_varTo.Clear();

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = VariantCopy(&m_varDOMTo, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VATo.SetValue(NULL);

    hr = VariantCopy(&m_varTo, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    if (ConvertToPixels(&m_varTo))
    {
        m_AnimPropState.fInterpolateTo = true;
    }
    else
    {
        m_AnimPropState.fInterpolateTo = false;
    }

    dt = TO;

    hr = S_OK;
done:
    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_TO);

    RRETURN(hr);
} // put_to


///////////////////////////////////////////////////////////////
//  Name: get_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_to(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varDOMTo);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: ValidateByValue
//
///////////////////////////////////////////////////////////////
bool
CTIMEAnimationBase::ValidateByValue (const VARIANT *pvarBy)
{
    bool fRet = true;

    if (!ConvertToPixels(const_cast<VARIANT *>(pvarBy)))
    {
        m_AnimPropState.fInterpolateBy = false;
    }
    else
    {
        m_AnimPropState.fInterpolateBy = true;
    }

    return fRet;
} // ValidateByValue


///////////////////////////////////////////////////////////////
//  Name: put_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_by(VARIANT val)
{
    HRESULT hr = S_OK;;
    DATATYPES dt;

    // reset this attribute
    dt = RESET;
    m_VABy.Reset(NULL);
    m_varDOMBy.Clear();
    m_varBy.Clear();

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = VariantCopy(&m_varDOMBy, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an arbitrary value on the persistence place holder mark it as set
    m_VABy.SetValue(NULL);

    hr = VariantCopy(&m_varBy, &val);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!ValidateByValue(&m_varBy))
    {
        goto done;
    }

    dt = BY;

    hr = S_OK;
done:
    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_BY);
    
    RRETURN(hr);
} // put_by


///////////////////////////////////////////////////////////////
//  Name: get_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_by(VARIANT * val)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(val);

    hr = THR(VariantClear(val));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = VariantCopy(val, &m_varDOMBy);
    if (FAILED(hr))
    {
        goto done;
    }
   
    hr = S_OK;
  done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_additive
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_additive(BSTR val)
{
    HRESULT hr = S_OK;
    LPOLESTR szAdditive = NULL;

    CHECK_RETURN_NULL(val);

    m_bAdditive = false;
    m_bAdditiveIsSum = false;
     
    delete [] m_SAAdditive.GetValue();
    m_SAAdditive.Reset(NULL);

    m_SAAdditive.SetValue(CopyString(val));
    if (m_SAAdditive == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    szAdditive = TrimCopyString(val);
    if (szAdditive == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_ADDITIVE_SUM, szAdditive))
    {
        m_bAdditive = true;
        m_bAdditiveIsSum = true;
    }

    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ADDITIVE);

    delete [] szAdditive;

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_additive
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_additive(BSTR * val)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(val);

    if (m_SAAdditive.GetValue())
    {
        *val = SysAllocString(m_SAAdditive.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_accumulate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_accumulate(BSTR val)
{
    HRESULT hr = S_OK;
    LPOLESTR szAccumulate = NULL;

    CHECK_RETURN_NULL(val);

    m_bAccumulate = false;

    delete [] m_SAAccumulate.GetValue();
    m_SAAccumulate.Reset(NULL);

    m_SAAccumulate.SetValue(CopyString(val));
    if (m_SAAccumulate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    szAccumulate = TrimCopyString(val);
    if (szAccumulate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_ADDITIVE_SUM, szAccumulate))
    {
        m_bAccumulate = true;
    }

    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ACCUMULATE);

    m_AnimPropState.fAccumulate = m_bAccumulate;

    ValidateState();

    delete [] szAccumulate;
 
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_accumulate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_accumulate(BSTR * val)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(val);

    if (m_SAAccumulate.GetValue())
    {
        *val = SysAllocString(m_SAAccumulate.GetValue());
        if (NULL == *val)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: put_calcmode
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::put_calcMode(BSTR calcmode)
{
    HRESULT hr = S_OK;
    LPOLESTR szCalcMode = NULL;

    CHECK_RETURN_NULL(calcmode);

    m_IACalcMode.Reset(DEFAULT_CALCMODE);

    szCalcMode = TrimCopyString(calcmode);
    if (NULL == szCalcMode)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_CALCMODE_DISCRETE, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_DISCRETE);
    }
    else if (0 == StrCmpIW(WZ_CALCMODE_LINEAR, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_LINEAR);
    }
    else if (0 == StrCmpIW(WZ_CALCMODE_SPLINE, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_SPLINE);
    }
    else if (0 == StrCmpIW(WZ_CALCMODE_PACED, szCalcMode))
    {
        m_IACalcMode.SetValue(CALCMODE_PACED);
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;
done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_CALCMODE);

    if (szCalcMode != NULL)
    {
        delete [] szCalcMode;
    }

    ValidateState();

    RRETURN(hr);
} // put_calcMode


///////////////////////////////////////////////////////////////
//  Name: get_calcmode
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEAnimationBase::get_calcMode(BSTR * calcmode)
{
    HRESULT hr = S_OK;
    LPWSTR wszCalcmodeString = WZ_NONE;

    CHECK_RETURN_NULL(calcmode);

    switch(m_IACalcMode)
    {
        case CALCMODE_DISCRETE :
            wszCalcmodeString = WZ_CALCMODE_DISCRETE;
            break;
        case CALCMODE_LINEAR :
            wszCalcmodeString = WZ_CALCMODE_LINEAR;
            break;
        case CALCMODE_SPLINE :
            wszCalcmodeString = WZ_CALCMODE_SPLINE;
            break;
        case CALCMODE_PACED :
            wszCalcmodeString = WZ_CALCMODE_PACED;
            break;
        default:
            wszCalcmodeString = WZ_CALCMODE_LINEAR;
    }

    *calcmode = SysAllocString(wszCalcmodeString);
    if (NULL == *calcmode)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: initScriptEngine
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void CTIMEAnimationBase::initScriptEngine()
{

    HRESULT hr;
   
    CComPtr<IHTMLWindow2>   pWindow2;
    CComVariant             vResult;
    CComBSTR                bstrScript(L"2+2");
    CComBSTR                bstrJS(L"JScript");

    if (bstrScript == NULL ||
        bstrJS     == NULL)
    {
        goto done;
    }

    hr = m_spDoc2->get_parentWindow(&pWindow2);
    if (FAILED(hr))
    {
        goto done;
    }

    pWindow2->execScript(bstrScript,bstrJS,&vResult);

done: 
    return;
}



///////////////////////////////////////////////////////////////
//  Name: resetAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::resetAnimate()
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::resetAnimate()",
              this));
    // Need to reload to set up correct target / attribute.
    
    m_bNeedAnimInit = true;
    m_varBaseline.Clear();
    m_varCurrentBaseline.Clear();
    initAnimate();
}

///////////////////////////////////////////////////////////////
//  Name: removeFromComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::removeFromComposerSite (void)
{
    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstrAttribName;

        bstrAttribName = m_SAAttribute;

        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->RemoveFragment(bstrAttribName, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // removeFromComposerSite

///////////////////////////////////////////////////////////////
//  Name: endAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::endAnimate (void)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::endAnimate()",
              this));

    if (m_spCompSite != NULL)
    {
        IGNORE_HR(removeFromComposerSite());
        m_spCompSite.Release();
    }
    m_bNeedAnimInit = true;
} // endAnimate

#ifdef TEST_REGISTERCOMPFACTORY // pauld

HRESULT
CTIMEAnimationBase::TestCompFactoryRegister (BSTR bstrAttribName)
{
    HRESULT hr;
    CComVariant varFactory;

    // Need to force the desired branch in the debugger.
    if (false)
    {
        // Register our composer factory by classid.
        V_VT(&varFactory) = VT_BSTR;
        V_BSTR(&varFactory) = ::SysAllocString(L"{EA627651-F84E-46b8-8FE4-21650FA09ED9}");

        hr = THR(m_spCompSite->RegisterComposerFactory(&varFactory));
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (false)
    {
        CComPtr<IAnimationComposerFactory> spCompFactory;

        // Or - register our composer factory by IUnknown.
        hr = THR(::CoCreateInstance(CLSID_AnimationComposerFactory, 
                                    NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IAnimationComposerFactory, 
                                    reinterpret_cast<void **>(&spCompFactory)));
        if (FAILED(hr))
        {
            goto done;
        }
        
        // AddRef because we're stuffing this into a CComVariant, which will decrement
        // the refcount on exit.
        V_VT(&varFactory) = VT_UNKNOWN;
        V_UNKNOWN(&varFactory) = spCompFactory;
        V_UNKNOWN(&varFactory)->AddRef();

        hr = THR(m_spCompSite->RegisterComposerFactory(&varFactory));
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // TestCompFactoryRegister

#endif // TEST_REGISTERCOMPFACTORY

#ifdef TEST_ENUMANDINSERT

static void
Introspect (VARIANT *pvarItem)
{
    CComVariant varID;

    Assert(VT_DISPATCH == V_VT(pvarItem));
    TraceTag((tagAnimationTimeElmTest,
              "Introspect : item %p ",
              V_DISPATCH(pvarItem)));
done :
    return;
}

static void
Enumerate (IEnumVARIANT *pienum)
{
    HRESULT hr = S_OK;
    ULONG celtReturned = 0;

    while (hr == S_OK)
    {
        CComVariant varItem;

        hr = pienum->Next(1, &varItem, &celtReturned);
        if (S_OK != hr)
        {
            break;
        }

        Introspect(&varItem);
        VariantClear(&varItem);
    }

done :
    return;
}

HRESULT
CTIMEAnimationBase::TestEnumerator (void)
{
    HRESULT hr;
    CComBSTR bstrAttribName = static_cast<LPWSTR>(m_SAAttribute);
    CComPtr<IEnumVARIANT> spEnum;

    TraceTag((tagAnimationTimeElmTest,
              "Testing enumerator code"));
    hr = THR(m_spCompSite->EnumerateFragments(bstrAttribName, &spEnum));
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    // OBJECTIVE : Test all of the enumerator entry points.
    // Try looping through the fragments (Next).
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating all items "));
    Enumerate(spEnum);

    // Reset 
    // Skip to the end and retrieve the last item
    // Try walking off the end.
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spEnum->Skip(100);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from item 100"));
    Enumerate(spEnum);

    // Reset 
    // Retrieve the first item
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from beginning again"));
    Enumerate(spEnum);

    // Skip to middle
    // Retrieve a middle element
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spEnum->Skip(1);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from item 2 "));
    Enumerate(spEnum);

    // Reset
    // Retrieve a bunch of items
    hr = spEnum->Reset();
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }
    {
        VARIANT rgVars[0x100];
        ULONG ulGot = 0;
        
        hr = spEnum->Next(0x100, rgVars, &ulGot);
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
        TraceTag((tagAnimationTimeElmTest,
                  "Getting a bunch of items  tried for %u got %u",
                   0x100, ulGot));
        for (unsigned long j = 0; j < ulGot; j++)
        {
            Introspect(&(rgVars[j]));
            ::VariantClear(&(rgVars[j]));
        }
    }
    TraceTag((tagAnimationTimeElmTest,
              "Enumerating from last item"));
    Enumerate(spEnum);

    // Clone the list
    // Iterate through cloned list from middle
    // Reset and iterate from the beginning
    {
        CComPtr<IEnumVARIANT> spenum2;

        TraceTag((tagAnimationTimeElmTest,
                  "Cloning enumerator"));
        hr = spEnum->Clone(&spenum2);
        Assert(SUCCEEDED(hr));
        if (FAILED(hr))
        {
            goto done;
        }
        TraceTag((tagAnimationTimeElmTest,
                  "Enumerating clone from last item"));
        Enumerate(spenum2);
        hr = spenum2->Reset();
        if (FAILED(hr))
        {
            goto done;
        }
        TraceTag((tagAnimationTimeElmTest,
                  "Enumerating clone from beginning"));
        Enumerate(spenum2);
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // TestEnumerator

HRESULT
CTIMEAnimationBase::InsertEnumRemove (int iSlot)
{
    HRESULT hr;

    CComBSTR bstrName = static_cast<LPWSTR>(m_SAAttribute);
    CComVariant varIndex;
    CComPtr<IEnumVARIANT> spEnum;

    V_VT(&varIndex) = VT_I4;
    V_I4(&varIndex) = iSlot;

    hr = m_spCompSite->InsertFragment(bstrName, this, varIndex);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spCompSite->EnumerateFragments(bstrName, &spEnum));
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationTimeElmTest,
              "Inserted new item at position %d -- current list is : ", iSlot));
    Enumerate(spEnum);

    Assert(m_spFragmentHelper != NULL);
    hr = m_spCompSite->RemoveFragment(bstrName, m_spFragmentHelper);
    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}

HRESULT
CTIMEAnimationBase::TestInsert (void)
{
    HRESULT hr;

    // OBJECTIVE : Test the insertion code
    // Insert at beginning
    hr = InsertEnumRemove(0);
    if (FAILED(hr))
    {
        goto done;
    }

    // Insert in the middle
    hr = InsertEnumRemove(1);
    if (FAILED(hr))
    {
        goto done;
    }

    // Insert with invalid index
    hr = InsertEnumRemove(-1);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // TestInsert

#endif // TEST_ENUMANDINSERT

///////////////////////////////////////////////////////////////
//  Name: addToComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::addToComposerSite (IHTMLElement2 *pielemTarget)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::ensureComposerSite(%p)",
              this, pielemTarget));

    HRESULT hr;
    CComPtr<IDispatch> pidispSite;

    hr = removeFromComposerSite();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_SAAttribute == NULL)
    {
        TraceTag((tagAnimationTimeElm,
                  "CTIMEAnimationBase(%p)::addToComposerSite() : attributeName has not been set - ignoring fragment",
                  this));
        hr = S_FALSE;
        goto done;
    }

    // Do we have work to do?
    if (NONE == m_dataToUse)
    {
        hr = S_FALSE;
        goto done;
    }    

    if (m_spCompSite == NULL)
    {
        hr = THR(EnsureComposerSite(pielemTarget, &pidispSite));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pidispSite->QueryInterface(IID_TO_PPV(IAnimationComposerSite, 
                                                       &m_spCompSite)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

#ifdef TEST_REGISTERCOMPFACTORY // pauld
    TestCompFactoryRegister(m_SAAttribute);
#endif // TEST_REGISTERCOMPFACTORY

#ifdef TEST_ENUMANDINSERT
    TestInsert();
#endif // TEST_ENUMANDINSERT

    {
        CComBSTR bstrAttribName;
        
        bstrAttribName = m_SAAttribute;
        if (bstrAttribName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->AddFragment(bstrAttribName, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
    }

#ifdef TEST_ENUMANDINSERT
    hr = TestEnumerator();
#endif // TEST_ENUMANDINSERT

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(removeFromComposerSite());
    }

    RRETURN2(hr, E_OUTOFMEMORY, S_FALSE);
} // CTIMEAnimationBase::addToComposerSite

///////////////////////////////////////////////////////////////
//  Name: FindTarget
//
//  Abstract: Get a reference to our animation target
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::FindAnimationTarget (IHTMLElement ** ppielemTarget)
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::initAnimate()",
              this));

    HRESULT hr = E_FAIL;
    CComPtr<IDispatch> pdisp;
    CComPtr<IHTMLElement> phtmle;

    Assert(NULL != ppielemTarget);

    if (m_SATarget)
    {
        if(m_spEleCol)
        {
            CComPtr <IDispatch> pSrcDisp;
            CComVariant vName;
            CComVariant vIndex;

            vName.vt      = VT_BSTR;
            vName.bstrVal = SysAllocString(m_SATarget);
            vIndex.vt     = VT_I2;
            vIndex.iVal   = 0;
            hr = THR(m_spEleCol->item(vName, vIndex, &pSrcDisp));
            if (FAILED(hr) ||
                pSrcDisp == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        
            hr = THR(pSrcDisp->QueryInterface(IID_TO_PPV(IHTMLElement, ppielemTarget)));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    { 
        phtmle = GetElement();

        hr = phtmle->get_parentElement(ppielemTarget);

        // 2001/04/18 mcalkins  IE6.0 Bug 25804
        //
        // CElement::get_parentElement can return a NULL pointer and also
        // return S_OK.

        if (   (NULL == *ppielemTarget)
            && (SUCCEEDED(hr)))
        {
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            goto done;
        }        
    }

    hr = S_OK;

done:

    RRETURN(hr);
} // CTIMEAnimationBase::FindAnimationTarget 

///////////////////////////////////////////////////////////////
//  Name: initAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::initAnimate()
{
    TraceTag((tagAnimationBaseState,
              "CTIMEAnimationBase(%p)::initAnimate()",
              this));

    HRESULT                     hr = E_FAIL;
    CComPtr<IHTMLElement>       phtmle;
    CComPtr<IHTMLElement2>      phtmle2;
    CComPtr<IDispatch>          pElmDisp;
    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;
    
    endAnimate();

    // Check to see if we are supposed to play animations.
    Assert(GetBody());
    GetBody()->ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
    if (!fPlayAnimations)
    {
        goto done;
    }

    hr = FindAnimationTarget(&phtmle);
    if (SUCCEEDED(hr))
    {
        CComPtr<IHTMLElement2> phtmle2;
        
        Assert(phtmle != NULL);
        hr = THR(phtmle->QueryInterface(IID_TO_PPV(IHTMLElement2, &phtmle2)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = addToComposerSite (phtmle2);
        if (FAILED(hr))
        {
            goto done;
        }

        // See if we are going to be animating VML or not.
        hr = THR(phtmle->QueryInterface(IID_IDispatch, (void**)&pElmDisp));
        if (FAILED(hr))
        {
            goto done;
        }
        m_bVML = IsVMLObject(pElmDisp);     
        m_bNeedAnimInit = false;
    }

    
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: updateDataToUse
//
//  Abstract: allows setting the animation type in priority order.
//            RESET is used indicate a need to recompute the data to use
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::updateDataToUse(DATATYPES dt)
{
    if (RESET == dt)
    {
        //
        // NOTE: All the if statements need to be evaluated
        //

        // if "path" has been cleared, revert to "values"
        if (    (PATH == m_dataToUse)
            &&  (!m_SAPath.IsSet()))
        {
            m_dataToUse = VALUES;
        }

        // if "values" has been cleared, revert to "to"
        if (    (VALUES == m_dataToUse)
            &&  (!m_SAValues.IsSet()))
        {
            m_dataToUse = TO;
        }
        
        // if "to" has been cleared, revert to "by"
        if (    (TO == m_dataToUse)
            &&  (!m_VATo.IsSet()))
        {
            m_dataToUse = BY;
        }

        // if "to" has been cleared, revert to "by"
        if (    (BY == m_dataToUse)
            &&  (!m_VABy.IsSet()))
        {
            m_dataToUse = NONE;
        }
    }
    else if (dt < m_dataToUse)
    {
        m_dataToUse = dt;
    }
}


///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::calculateDiscreteValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    Assert(NULL != pvarValue);

    switch ( m_dataToUse)
    {
        case VALUES:
            {
                CComVariant varTemp;
                int curSeg = CalculateCurrentSegment(true);
            
                varTemp.vt = VT_BSTR;
                varTemp.bstrVal = SysAllocString(m_ppstrValues[curSeg]);
                hr = THR(::VariantCopy(pvarValue, &varTemp));
                if (FAILED(hr))
                {
                    goto done;
                }
                TraceTag((tagAnimationBaseValue,
                          "CTIMEAnimationBase(%p)::calculateDiscreteValue(%ls) segment is %d progress is %lf ",
                          this, V_BSTR(pvarValue), curSeg, GetMMBvr().GetProgress()));
            }
            break;

        case TO:
            {
                if (m_bFrom && (GetMMBvr().GetProgress() < 0.5))
                {
                    CComVariant varFrom;
                    VARTYPE vtDummy = VT_EMPTY;

                    hr = VariantCopy(&varFrom,&m_varFrom);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = CanonicalizeValue(&varFrom, &vtDummy);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = THR(::VariantCopy(pvarValue, &varFrom));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
                else
                {
                    hr = THR(::VariantCopy(pvarValue, &m_varTo));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }

                TraceTag((tagAnimationBaseValue,
                          "CTIMEAnimationBase(%p)::calculateDiscreteValue(to value)",
                          this));
            }
            break;

        case BY:
            {
                if (!ConvertToPixels(pvarValue) || 
                    !ConvertToPixels(&m_varBy))
                {
                    goto done;
                }

                if (m_bFrom)
                {
                    CComVariant varFrom;
                    VARTYPE vtDummy = VT_EMPTY;

                    hr = VariantCopy(&varFrom,&m_varFrom);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = CanonicalizeValue(&varFrom, &vtDummy);
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    // copy "from"
                    hr = THR(::VariantCopy(pvarValue, &varFrom));
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    // if in second half of interval
                    if (GetMMBvr().GetProgress() >= 0.5)
                    {
                        // increment "by"
                        Assert(V_VT(&m_varBy)== VT_R8);

                        V_R8(pvarValue) += V_R8(&m_varBy);
                    }
                }
                else
                {
                    hr = THR(::VariantCopy(pvarValue, &m_varBy));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }

                TraceTag((tagAnimationBaseValue,
                          "CTIMEAnimationBase(%p, %ls)::calculateDiscreteValue(%lf) for %ls.%ls",
                          this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));
            }
            break;

        case PATH:
        case NONE:
        default:
            break;

    }

    hr = S_OK;
done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::calculateLinearValue(VARIANT *pvarValue)
{
    HRESULT     hr = S_OK;
    CComVariant varVal;
    double dblReturnVal;

    if (m_dataToUse == VALUES)
    {
        double curProgress = CalculateProgressValue(false);
        int    curSeg      = CalculateCurrentSegment(false);

        Assert(m_ppstrValues && ((curSeg + 1) <= (m_numValues - 1)));

        if (!m_ppstrValues[curSeg] || !m_ppstrValues[curSeg + 1])
        {
            goto done;
        }

        CComVariant svarFrom(m_ppstrValues[curSeg]);
        CComVariant svarTo(m_ppstrValues[curSeg + 1]);

        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            goto done;
        }

        dblReturnVal = InterpolateValues(svarFrom.dblVal,  
                                         svarTo.dblVal,
                                         curProgress);
    }
    else
    {
        CComVariant varData;
        double dblFrom = 0;
        double dblToOffset = 0;
                   
        if (m_bFrom)
        {
            CComVariant varFrom;
            VARTYPE vtDummy = VT_EMPTY;

            hr = VariantCopy(&varFrom,&m_varFrom);
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CanonicalizeValue(&varFrom, &vtDummy);
            dblFrom = V_R8(&varFrom);
        }
        else if (TO == m_dataToUse)
        {
            if (VT_R8 != V_VT(&m_varCurrentBaseline))
            {
                if (!ConvertToPixels(&m_varCurrentBaseline))
                {
                    hr = E_UNEXPECTED;
                    goto done;
                }
            }
            dblFrom = V_R8(&m_varCurrentBaseline);
        }
                        
        if (TO == m_dataToUse)
        {
            hr = VariantCopy(&varData, &m_varTo);
        }
        else if (BY == m_dataToUse) 
        {
            hr = VariantCopy(&varData, &m_varBy);
            dblToOffset = dblFrom;
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }

        if (FAILED(hr) || (!ConvertToPixels(&varData)))
        {
            goto done;
        }
        Assert(V_VT(&varData) == VT_R8);     

        dblReturnVal = InterpolateValues(dblFrom, dblToOffset + V_R8(&varData), (GetMMBvr().GetProgress()));
    }
    
    THR(::VariantClear(pvarValue));
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = dblReturnVal; 

    TraceTag((tagAnimationBaseValue,
              "CTIMEAnimationBase(%p, %ls)::calculateLinearValue(%lf) for %ls.%ls",
              this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));

    hr = S_OK;
done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEAnimationBase::calculateSplineValue(VARIANT *pvarValue)
{
    HRESULT     hr = S_OK;
    CComVariant varVal;
    CComVariant varRes;
    double dblReturnVal = 0.0;

    V_VT(&varRes) = VT_R8;

    if (m_pKeySplinePoints == NULL)
    {
        goto done;
    }

    if (m_dataToUse == VALUES)
    {
        int    curSeg      = CalculateCurrentSegment(false);
        double curProgress = CalculateProgressValue(false);

        curProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg],curProgress);

        CComVariant svarFrom(m_ppstrValues[curSeg]);
        CComVariant svarTo(m_ppstrValues[curSeg + 1]);

        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            goto done;
        }

        dblReturnVal = InterpolateValues(svarFrom.dblVal,  
                                         svarTo.dblVal,
                                         curProgress);
    }
    else
    {
        double curProgress = CalculateBezierProgress(m_pKeySplinePoints[0],GetMMBvr().GetProgress());
        CComVariant varData;
        double dblFrom = 0;
        double dblToOffset = 0;
                   
        if (m_bFrom)
        {
            CComVariant varFrom;
            VARTYPE vtDummy = VT_EMPTY;

            hr = VariantCopy(&varFrom,&m_varFrom);
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CanonicalizeValue(&varFrom, &vtDummy);
            dblFrom = V_R8(&varFrom);
        }
        else if (TO == m_dataToUse)
        {
            if (VT_R8 != V_VT(&m_varCurrentBaseline))
            {
                if (!ConvertToPixels(&m_varCurrentBaseline))
                {
                    hr = E_UNEXPECTED;
                    goto done;
                }
            }
            dblFrom = V_R8(&m_varCurrentBaseline);
        }
                        
        if (TO == m_dataToUse)
        {
            hr = VariantCopy(&varData, &m_varTo);
        }
        else if (BY == m_dataToUse) 
        {
            hr = VariantCopy(&varData, &m_varBy);
            dblToOffset = dblFrom;
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }

        if (FAILED(hr) || (!ConvertToPixels(&varData)))
        {
            goto done;
        }
        Assert(V_VT(&varData) == VT_R8);     

        dblReturnVal = InterpolateValues(dblFrom, dblToOffset + V_R8(&varData), curProgress);
    }
    
    THR(::VariantClear(pvarValue));
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = dblReturnVal; 

    TraceTag((tagAnimationBaseValue,
              "CTIMEAnimationBase(%p, %ls)::calculateSplineValue(%lf) for %ls.%ls",
              this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));

    hr = S_OK;
done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEAnimationBase::calculatePacedValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;
    CComVariant varData, varRes;
    CComVariant svarFrom, svarTo;
    double dblDistance =0.0;
    double pDistance;
    double curDisanceTraveled = 0.0;
    int i;

    // This only makes sense if you are using m_dataToUse == VALUES
    if (m_dataToUse != VALUES)
    {
        hr = THR(calculateLinearValue(pvarValue));
        goto done;
    }

    curDisanceTraveled = InterpolateValues(0.0, 
                                           m_dblTotalDistance, 
                                           GetMMBvr().GetProgress());

    i=1;
    dblDistance = 0.0;
    pDistance   = 0.0;
    do
    {
        pDistance = dblDistance;
        if (m_ppstrValues[i-1] == NULL || m_ppstrValues[i] == NULL)
        {
            dblDistance = 0.0;
            goto done;
        }

        svarFrom = m_ppstrValues[i - 1];
        svarTo = m_ppstrValues[i];

        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            goto done;
        }

        dblDistance += fabs(svarFrom.dblVal - svarTo.dblVal); 
        i++;
    }
    while (dblDistance < curDisanceTraveled);
    
    i = (i < 2)?1:i-1;

    // how far are we into the segment
    svarFrom = m_ppstrValues[i - 1];
    svarTo = m_ppstrValues[i];

    if (    (NULL == svarFrom.bstrVal)
        ||  (NULL == svarTo.bstrVal)
        ||  (!ConvertToPixels(&svarFrom))
        ||  (!ConvertToPixels(&svarTo)))
    {
        goto done;
    }

    dblDistance = fabs(svarFrom.dblVal - svarTo.dblVal); 

    if (dblDistance == 0)
    {
        goto done;
    }

    dblDistance = (curDisanceTraveled - pDistance)/dblDistance;

    dblDistance =  InterpolateValues(svarFrom.dblVal,
                                     svarTo.dblVal, 
                                     dblDistance); 

    V_VT(&varRes) = VT_R8;
    V_R8(&varRes) = dblDistance; 
    hr = THR(::VariantCopy(pvarValue, &varRes));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationBaseValue,
              "CTIMEAnimationBase(%p, %ls)::calculatePacedValue(%lf) for %ls.%ls",
              this, m_id, V_R8(pvarValue), m_SATarget, m_SAAttribute));

    hr = S_OK;
done:

    RRETURN(hr);
}
   

///////////////////////////////////////////////////////////////
//  Name: CalculateProgressValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEAnimationBase::CalculateProgressValue(bool fForceDiscrete)
{
    double segDur       = 0.0;
    double curProgress  = 0.0;
    int    curSeg       = 0;
    CComVariant varTemp;

    double curTime = GetMMBvr().GetSimpleTime();

    curSeg = CalculateCurrentSegment(fForceDiscrete);

    if (m_numKeyTimes == m_numValues &&
        GetMMBvr().GetSimpleDur() != TIME_INFINITE)
    {
        // We have corresponding times for the values...
        segDur  = (m_pdblKeyTimes[curSeg+1] - m_pdblKeyTimes[curSeg] ) * GetMMBvr().GetSimpleDur();
        double pt = (m_pdblKeyTimes[curSeg] * GetMMBvr().GetSimpleDur());
        curTime = curTime - pt;
        if(curTime < 0)
        {
            curTime = 0;
        }

        curProgress = curTime/segDur;
    }
    else 
    {
        // Only use values. 
        if ( m_numValues == 1)
        {
            segDur = GetMMBvr().GetSimpleDur();
        }
        else
        {
            segDur = GetMMBvr().GetSimpleDur() / (m_numValues-1);
        }
        if (segDur != 0)
        {
            double timeInSeg = curTime;

            if (curTime >= segDur)
            {
                int segOffset = (int) (curTime/segDur);
                if (segOffset == 0)
                { 
                    segOffset = 1;
                }
                timeInSeg = curTime - (segDur * segOffset);
            }
            curProgress = timeInSeg / segDur;
        }
    }

    
    return curProgress;
} 


///////////////////////////////////////////////////////////////
//  Name: CalculateCurrentSegment
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
int
CTIMEAnimationBase::CalculateCurrentSegment(bool fForceDiscrete)
{
    double segDur = 0.0;
    int    curSeg = 0;                       
    bool fDiscrete = fForceDiscrete
                     || (CALCMODE_DISCRETE == m_IACalcMode.GetValue());

    if (m_numKeyTimes == m_numValues  &&
        GetMMBvr().GetSimpleDur() != TIME_INFINITE)
    {
        if (fDiscrete)
        {
            // adjust for last segment
            curSeg = m_numKeyTimes - 1;
        }

        // We have corresponding times for the values...
        for(int i=0; i < m_numKeyTimes;i++)
        {
            if (m_pdblKeyTimes[i] > (GetMMBvr().GetProgress()))
            {
                curSeg = i;
                if(curSeg != 0)
                {
                    curSeg -= 1;
                }
                break;
            }
        }
    }
    else 
    {
        // Only use values. 
        if ( m_numValues == 1)
        {
            segDur = GetMMBvr().GetSimpleDur();
        }
        else
        {
            if (fDiscrete)
            {
                segDur = GetMMBvr().GetSimpleDur() / (m_numValues);
            }
            else
            {
                segDur = GetMMBvr().GetSimpleDur() / (m_numValues - 1);
            }
        }

        curSeg = (int) (GetMMBvr().GetSimpleTime() / segDur);
    }
    
    // adjust for the last tick
    if (curSeg == m_numValues)
    {
        curSeg --;
    }

    return curSeg;
} 


///////////////////////////////////////////////////////////////
//  Name: CalculateTotalDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::CalculateTotalDistance()
{
    m_dblTotalDistance = 0.0;
    CComVariant svarFrom, svarTo;
    int i;

    for (i=1; i < m_numValues; i++)
    {
        svarFrom = m_ppstrValues[i - 1];
        svarTo = m_ppstrValues[i];

        // need to change the below 0 to origval..
        if (    (NULL == svarFrom.bstrVal)
            ||  (NULL == svarTo.bstrVal)
            ||  (!ConvertToPixels(&svarFrom))
            ||  (!ConvertToPixels(&svarTo)))
        {
            m_dblTotalDistance = 0.0;
            goto done;
        }

        m_dblTotalDistance += fabs(svarFrom.dblVal - svarTo.dblVal); 
    }
done:
    return;
}


void
CTIMEAnimationBase::SampleKeySpline(SplinePoints & sp)
{
    // sample at 4 equi-spaced points
    sp.s1 = KeySplineBezier(sp.x1, sp.x2, 0.2);
    sp.s2 = KeySplineBezier(sp.x1, sp.x2, 0.4);
    sp.s3 = KeySplineBezier(sp.x1, sp.x2, 0.6);
    sp.s4 = KeySplineBezier(sp.x1, sp.x2, 0.8);
}


///////////////////////////////////////////////////////////////
//  Name: CalculateBezierProgress
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double 
CTIMEAnimationBase::CalculateBezierProgress(const SplinePoints & sp, double cp)
{
    //
    // First solve the equation x(t) = cp, where x(t) is the cubic bezier function 
    // Then evaluate y(t1) where t1 is the root of the above equation
    // 
    // Approximate the x- spline with 4 line segments that are found by 
    // subdiving the parameter into 4 equal intervals
    //
    double x1 = 0.0;
    double x2 = 1.0;
    double t1 = 0.0;
    double t2 = 1.0;

    if (cp < sp.s3)
    {
        if (cp < sp.s2)
        {
            if (cp < sp.s1)
            {
                x2 = sp.s1;
                t2 = 0.2;
            }
            else
            {
                x1 = sp.s1;
                x2 = sp.s2;
                t1 = 0.2;
                t2 = 0.4;
            }
        }
        else
        {
            x1 = sp.s2;
            x2 = sp.s3;
            t1 = 0.4;
            t2 = 0.6;
        }
    }
    else
    {
        if (cp < sp.s4)
        {
            x1 = sp.s3;
            x2 = sp.s4;
            t1 = 0.6;
            t2 = 0.8;
        }
        else
        {
            x1 = sp.s4;
            t1 = 0.8;

        }
    }

    // get the value of t at x = cp
    t1 = InterpolateValues(t1, t2, (cp - x1) / (x2 - x1));
    
    return KeySplineBezier(sp.y1, sp.y2, t1);
} // CalculateBezierProgress


// optimized for start-value = 0 and end-value = 1, so we just need the control points
inline
double
CTIMEAnimationBase::KeySplineBezier(double x1, double x2, double cp)
{
    //
    // dilipk: reduce number of multiplies using Horner's rule
    //

    double cpm1, cp3;
    
    cpm1 = 1 - cp;
    cp3 = cp * cp * cp;

    return(3 * cp * cpm1 * cpm1 * x1 + 3 * cp * cp * cpm1 * x2 + cp3);
}


#if (0 && DBG) 

// This computes Exact bezier progress for KeySplines. This is slower than the above inexact computation.
// Keeping this around for benchmarking the above approximation method.

// need to link with libc.lib if this block is enabled
#include "math.h"

///////////////////////////////////////////////////////////////
//  Name: CalculateBezierProgressExact
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double 
CTIMEAnimationBase::CalculateBezierProgressExact(SplinePoints s, double progress)
{
    double cpm1, cp3, cp = progress, result = 0.0;

    Assert(progress <= 1.0 && progress >= 0.0);

    //
    // First solve the equation x(t) = progress, where x(t) is the cubic bezier function 
    // Then evaluate y(t1) where t1 is the root of the above equation
    // 
    // Though cubic equations can have 3 roots, the SMIL spec constrains the end points to be
    // 0,0 and 1,1 and the control points to lie within the end points' bounding rectangle
    // so we are guaranteed a single-valued function in the interval [0, 1]
    //
    // We need to solve for all roots and choose the root that lies in the interval [0, 1]
    //

    // polynomial is of the form --- a3*x^3 + a2*x^2 + a1*x + a0 

    double a0 = -1 * progress;
    double a1 = 3 * s.x1;
    double a2 = 3 * (s.x2 - 2 * s.x1);
    double a3 = 1 + 3 * (s.x1 - s.x2);

    if (0.0 == a3)
    {
        if (0.0 == a2)
        {
            if (0.0 == a1)
            {
                // this is a constant polynomial

                // we should never get here, but if we do
                // just skip this part of the computation
                cp = progress;
            }
            else
            {
                // this is a linear polynomial

                cp = -1 * a0 / a1;
            }
        }
        else
        {
            // this is a quadratic polynomial

            double D = a1 * a1 - 4 * a2 * a0;

            // switch on the Discriminant
            if (D < 0.0)
            {
                // there are no real roots

                // we should never get here, but if we do
                // just skip this part of the computation
                cp = progress;
            }
            else if (0.0 == D)
            {
                // there is one repeating root

                cp = -1 * a1 / (2 * a2);
            }
            else
            {
                // there are two distinct roots

                double sqrtD = sqrt(D);

                cp = (-1 * a1 + sqrtD) / (2 * a2);

                if (cp > 1.0 || cp < 0.0)
                {
                    cp = (-1 * a1 - sqrtD) / (2 * a2);
                }
            }
        }
    }
    else
    {
        // this is a cubic polynomial

        a0 /= a3;
        a1 /= a3;
        a2 /= a3;

        double a2by3 = a2 / 3;

        double Q = ((3 * a1) - (a2 * a2)) / 9;
        double R = ((9 * a2 * a1) - (27 * a0) - (2 * a2 * a2 *a2)) / 54;

        double D = (Q * Q * Q) + (R * R);

        // switch on Discriminant
        if (D > 0)
        {
            // There is only one root

            double sqrtD = sqrt(D);

            // pow does not handle cube roots of negative numbers, so work around...
            int mult = (R + sqrtD < 0 ? -1 : 1);
            double S = mult * pow((mult * (R + sqrtD)), (1.0/3.0));

            mult = (R < sqrtD ? -1 : 1);
            double T = mult * pow((mult * (R - sqrtD)), (1.0/3.0));

            cp = S + T - a2by3; 
        }
        else if (0.0 == D)
        {
            // there are two roots

            int mult = (R < 0 ? -1 : 1);
            double S = mult * pow((mult * R), (1.0/3.0));

            cp = 2 * S - a2by3; 

            if (cp > 1.0 || cp < 0.0)
            {
                cp -= 3 * S;
            }
        }
        else
        {
            // there are three roots

            double theta = acos(R / sqrt(-1 * Q * Q * Q));
            double pi = 22.0 / 7.0;
            double sqrtQ2 = 2 * sqrt(-1 * Q);

            cp = sqrtQ2 * cos(theta / 3) - a2by3;

            if (cp > 1.0 || cp < 0.0)
            {
                cp = sqrtQ2 * cos((theta + 2 * pi) / 3) - a2by3;

                if (cp > 1.0 || cp < 0.0)
                {
                    cp = sqrtQ2 * cos((theta + 4 * pi) / 3) - a2by3;
                }
            }
        }
    }

    if (cp > 1.0 || cp < 0.0)
    {
        // Since a root should always exist for valid keySpline values (i.e. between 0,0 and 1,1)
        // this should never happen theoretically. But in case of floating point error
        // revert to progress
        cp = progress;
    }

    cpm1 = 1 - cp;
    cp3 = cp * cp * cp;

    result = 3*cp*cpm1*cpm1*s.y1 + 3*cp*cp*cpm1*s.y2 + cp3;

done:
    return result;
} // CalculateBezierProgressExact

#endif // if 0 && DBG

///////////////////////////////////////////////////////////////
//  Name: OnSync
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::OnSync() dbllastTime = %g dblnewTime = %g",
              this, dbllastTime, dblnewTime));
}


///////////////////////////////////////////////////////////////
//  Name: OnResume
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnResume(double dblLocalTime)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::OnResume()",
              this));

    CTIMEElementBase::OnResume(dblLocalTime);
} 

///////////////////////////////////////////////////////////////
//  Name: OnPause
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEAnimationBase::OnPause(double dblLocalTime)
{
    TraceTag((tagAnimationTimeElm,
              "CTIMEAnimationBase(%p)::OnPause()",
              this));

    CTIMEElementBase::OnPause(dblLocalTime);
}

STDMETHODIMP
CTIMEAnimationBase::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr = THR(::TimeLoad(this, CTIMEAnimationBase::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Load(pPropBag, pErrorLog));
done:
    return hr;
}

STDMETHODIMP
CTIMEAnimationBase::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = THR(::TimeSave(this, CTIMEAnimationBase::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));
done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: CompareValuePairs
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
static int __cdecl
CompareValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((VALUE_PAIR*)pv1)->wzName,
                    ((VALUE_PAIR*)pv2)->wzName);
} 

///////////////////////////////////////////////////////////////
//  Name: ConvertToPixels
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool
CTIMEAnimationBase::ConvertToPixels(VARIANT *pvarValue)
{
    int  pixelPerInchVert, pixelPerInchHoriz, pixelFactor;
    LPOLESTR szTemp  = NULL;
    HDC hdc;
    double dblVal = VALUE_NOT_SET;
    HRESULT hr;
    bool bReturn = false;

    pixelPerInchHoriz=pixelPerInchVert=0;
   
    // see if we can just do a straight converstion.
    hr = VariantChangeTypeEx(pvarValue,pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
    if (SUCCEEDED(hr))
    {
        bReturn = true;
        goto done;
    }

    if (pvarValue->vt != VT_BSTR)
    {
        // no conversion to do...just return.
        bReturn = true;
        goto done;
    }
    
    // see if the bstr is empty
    if (ocslen(pvarValue->bstrVal) == 0)
    {
        SysFreeString(pvarValue->bstrVal);
        V_VT(pvarValue)= VT_R8;
        V_R8(pvarValue) = 0;
        bReturn = true;
        goto done;
    }


    szTemp = CopyString(pvarValue->bstrVal);
    if (NULL == szTemp)
    {
        goto done;
    }

    hdc = GetDC(NULL);
    if (NULL != hdc)
    {
        pixelPerInchHoriz = g_LOGPIXELSX;
        pixelPerInchVert  = g_LOGPIXELSY;
        ReleaseDC(NULL, hdc);
    }


    // Determine the PixelFactor based on what the target is...
    {
        VALUE_PAIR valName;
        valName.wzName = m_SAAttribute;

        VALUE_PAIR * pValPair = (VALUE_PAIR*)bsearch(&valName,
                                              rgPropOr,
                                              SIZE_OF_VALUE_TABLE,
                                              sizeof(VALUE_PAIR),
                                              CompareValuePairsByName);

        if (NULL == pValPair)
            pixelFactor = (pixelPerInchVert + pixelPerInchHoriz) /2;
        else
            pixelFactor = pValPair->bValue == HORIZ ? pixelPerInchHoriz : pixelPerInchVert;
    }


    {
        // See if we have PIXELS
        if (ConvertToPixelsHELPER(szTemp, PX, 1.0, 1.0f, &dblVal))
        {
            bReturn = true;
            goto done;
        }
     
        // Try to convert to Pixels.
        int i;
        for(i=0; i< (int)SIZE_OF_CONVERSION_TABLE;i++)
        {
            if (ConvertToPixelsHELPER(szTemp, rgPixelConv[i].wzName, rgPixelConv[i].dValue, (float) pixelFactor, &dblVal))
            {
                bReturn = true;
                goto done;
            }
        }
    }

done:
    if (dblVal != VALUE_NOT_SET)
    {
        ::VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = dblVal;
    }
    if (szTemp)
    {
        delete [] szTemp;
    }
    return bReturn;
}

void
CTIMEAnimationBase::GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess)
{
    HRESULT hr = S_OK;
    CComVariant inValue;
    
    *pfDontPostProcess = false;

    inValue.Copy(pvarValue);
    
    if (GetAutoReverse())
    {
        VariantClear(pvarValue);
        hr = THR(::VariantCopy(pvarValue, &m_varLastValue));
        if (FAILED(hr))
        {
            goto done;
        }
        
        *pfDontPostProcess = true;
    }
    else if (m_dataToUse == VALUES)
    {
        ::VariantClear(pvarValue);
        V_VT(pvarValue) = VT_BSTR;
        V_BSTR(pvarValue) = SysAllocString(m_ppstrValues[m_numValues-1]);
    }
    else if (m_dataToUse == BY)
    {
        GetFinalByValue(pvarValue);
    }
    else if (m_dataToUse == TO)
    {
        hr = THR(::VariantCopy(pvarValue, &m_varTo));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
done:
    return;
}


void
CTIMEAnimationBase::GetFinalByValue(VARIANT *pvarValue)
{
    VariantClear(pvarValue);

    if (m_bFrom)
    {
        VariantCopy(pvarValue, &m_varFrom);
        if (!ConvertToPixels(pvarValue))
        {
            goto done;
        }
    }
    else
    {
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = 0;
    }
    
    if (!ConvertToPixels(&m_varBy))
    {
        goto done;
    }      

    Assert(V_VT(pvarValue) == VT_R8);
    Assert(V_VT(&m_varBy)   == VT_R8);

    V_R8(pvarValue)+= V_R8(&m_varBy);

done:
    return;
} // GetFinalByValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animfilter.cpp ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\src\animfilter.cpp
//
//  Classes:    CTIMEFilterAnimation
//
//  History:
//  2000/08/24  mcalkins    Created.
//  2000/09/20  pauld       Hooked up fragment to specialized filter composer.
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "animfilter.h"

DeclareTag(tagAnimationFilter, "SMIL Animation", 
           "CTIMEFilterAnimation methods");

DeclareTag(tagAnimationFilterInterpolate, "SMIL Animation", 
           "CTIMEFilterAnimation interpolation");

DeclareTag(tagAnimationFilterAdditive, "SMIL Animation", 
           "CTIMEFilterAnimation additive animation methods");

#define TRANSITION_KEY_DELIMITER    (L":")

#define PART_ONE 0
#define PART_TWO 1

#define DEFAULT_TRANSITIONFILTER_DURATION 1.0

static const int g_iDefaultFrom = 0;
static const int g_iDefaultTo   = 1;

//+-----------------------------------------------------------------------------
//
//  Method: CTIMEFilterAnimation::CTIMEFilterAnimation
//
//------------------------------------------------------------------------------
CTIMEFilterAnimation::CTIMEFilterAnimation()
{
}
//  Method: CTIMEFilterAnimation::CTIMEFilterAnimation


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEFilterAnimation::~CTIMEFilterAnimation
//
//------------------------------------------------------------------------------
CTIMEFilterAnimation::~CTIMEFilterAnimation()
{
    if (m_SAType.IsSet())
    {
        delete [] m_SAType.GetValue();
        m_SAType.Reset(NULL);
    }

    if (m_SASubtype.IsSet())
    {
        delete [] m_SASubtype.GetValue();
        m_SASubtype.Reset(NULL);
    }

    if (m_SAMode.IsSet())
    {
        delete [] m_SAMode.GetValue();
        m_SAMode.Reset(NULL);
    }

    if (m_SAFadeColor.IsSet())
    {
        delete [] m_SAFadeColor.GetValue();
        m_SAFadeColor.Reset(NULL);
    }
} 
//  Method: CTIMEFilterAnimation::~CTIMEFilterAnimation


//+-----------------------------------------------------------------------------
//
// CTIMEFilterAnimation::Init
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEFilterAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagAnimationFilter,
              "CTIMEFilterAnimation(%p)::Init()",
              this));

    HRESULT hr = CTIMEAnimationBase::Init(pBehaviorSite);

    m_SAType.InternalSet(WZ_DEFAULT_TRANSITION_TYPE);
    m_SASubtype.InternalSet(WZ_DEFAULT_TRANSITION_SUBTYPE);

    hr = S_OK;
done :
    RRETURN(hr);
}
// CTIMEFilterAnimation::Init


///////////////////////////////////////////////////////////////
//
//  Name: CTIMEFilterAnimation::AssembleFragmentKey
//
//  Synopsis : The composer site uses each fragments 
//             the attributeName property as a key.  We 
//             need to put information that makes this particular
//             transition distinct into the attributeName.
//             By and large, these will be the union of our properties
//             and parameters (from our param children's name/value
//             pairs governing this transition's visual qualities
//
///////////////////////////////////////////////////////////////
HRESULT
CTIMEFilterAnimation::AssembleFragmentKey (void)
{
    HRESULT hr = S_OK;

    // Bundle up the type and subtype attributes and stuff them into the 
    // (non-queryable) attributeName object.
    // ## ISSUE - we must intellegently handle subType defaults.
    // ## ISSUE - we should include the param tag values as a part of the fragment key.
    if (m_SAType.GetValue())
    {
        int iCount = lstrlenW(m_SAType.GetValue());

        iCount += lstrlenW(TRANSITION_KEY_DELIMITER);
        if (m_SASubtype.GetValue())
        {
            iCount += lstrlenW(m_SASubtype.GetValue());
        }
        iCount += lstrlenW(TRANSITION_KEY_DELIMITER);
        if (m_SAMode.GetValue())
        {
            iCount += lstrlenW(m_SAMode.GetValue());
        }
        iCount += lstrlenW(TRANSITION_KEY_DELIMITER);
        if (m_SAFadeColor.GetValue())
        {
            iCount += lstrlenW(m_SAFadeColor.GetValue());
        }

        {
            LPWSTR wzAttributeName = NEW WCHAR[iCount + 1];

            if (NULL != wzAttributeName)
            {
                StrCpyW(wzAttributeName, m_SAType.GetValue());
                StrCatW(wzAttributeName, TRANSITION_KEY_DELIMITER);
                // Only need to set the subtype when using a non-default type.
                if ( (m_SAType.IsSet()) && (m_SASubtype.IsSet()) )
                {
                    StrCatW(wzAttributeName, m_SASubtype.GetValue());
                }
                StrCatW(wzAttributeName, TRANSITION_KEY_DELIMITER);
                if (m_SAMode.IsSet())
                {
                    StrCatW(wzAttributeName, m_SAMode.GetValue());
                }
                StrCatW(wzAttributeName, TRANSITION_KEY_DELIMITER);
                if (m_SAFadeColor.IsSet())
                {
                    StrCatW(wzAttributeName, m_SAFadeColor.GetValue());
                }

                m_SAAttribute.SetValue(wzAttributeName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CTIMEFilterAnimation::AssembleFragmentKey


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEFilterAnimation::EnsureAnimationFunction
//
//  Synopsis:   Make sure that the transitionFilter element has at 
//              least a default animation function if none is supplied.
//
//  Arguments:  None
//
//------------------------------------------------------------------------------
void
CTIMEFilterAnimation::EnsureAnimationFunction (void)
{
    if ((NONE == m_dataToUse) && (!DisableAnimation()))
    {
        CComVariant varFrom(g_iDefaultFrom);
        CComVariant varTo(g_iDefaultTo);
        
        IGNORE_HR(put_from(varFrom));
        IGNORE_HR(put_to(varTo));
    }

    if (!m_FADur.IsSet())
    {
        CComVariant varDefaultDur(DEFAULT_TRANSITIONFILTER_DURATION);

        IGNORE_HR(put_dur(varDefaultDur));
    }

    // Do not override a declared function
} // CTIMEFilterAnimation::EnsureAnimationFunction


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEFilterAnimation::OnLoad
//
//  Synopsis:   Called when the window.onload event has fired.  We will need to 
//              sniff out our target, and set a flag telling it to expect a filter.
//
//  Arguments:  None
//
//------------------------------------------------------------------------------
void
CTIMEFilterAnimation::OnLoad (void)
{
    CComPtr<IHTMLElement> spElem;
    CComPtr<ITIMEElement> spTimeElem;
    CComPtr<ITIMETransitionSite> spTransSite;

    TraceTag((tagAnimationFilter,
              "CTIMEFilterAnimation(%p)::OnLoad()",
              this));

    CTIMEAnimationBase::OnLoad();

    HRESULT hr = THR(FindAnimationTarget(&spElem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(FindTIMEInterface(spElem, &spTimeElem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spTimeElem->QueryInterface(IID_TO_PPV(ITIMETransitionSite, &spTransSite)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spTransSite->InitTransitionSite());
    if (FAILED(hr))
    {
        goto done;
    }

done :
    return;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEFilterAnimation::OnPropertiesLoaded
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties.  We will use the type/subtype 
//              tuple to assemble a value that we'll pass up to the composer, 
//              to identify the type of transition.
//
//  Arguments:  None
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEFilterAnimation::OnPropertiesLoaded(void)
{
    TraceTag((tagAnimationFilter,
              "CTIMEFilterAnimation(%p)::OnPropertiesLoaded()",
              this));

    HRESULT hr = CTIMEAnimationBase::OnPropertiesLoaded();

    if (FAILED(hr))
    {
        goto done;
    }

    hr = AssembleFragmentKey();
    if (FAILED(hr))
    {
        goto done;
    }

    EnsureAnimationFunction();

    hr = S_OK;
done:
    RRETURN(hr);
} // OnPropertiesLoaded

///////////////////////////////////////////////////////////////
//  Name: get_type
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_type(BSTR *pbstrType)
{
    return getStringAttribute (m_SAType, pbstrType);
} // get_type

///////////////////////////////////////////////////////////////
//  Name: put_type
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_type(BSTR bstrType)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_TYPE, 
                              bstrType, m_SAType, 
                              WZ_DEFAULT_TRANSITION_TYPE);
} // put_type

///////////////////////////////////////////////////////////////
//  Name: get_subType
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_subType(BSTR *pbstrSubtype)
{
    return getStringAttribute (m_SASubtype, pbstrSubtype);
} // get_subType


///////////////////////////////////////////////////////////////
//  Name: put_subType
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_subType(BSTR bstrSubtype)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_SUBTYPE, 
                              bstrSubtype, m_SASubtype, 
                              WZ_DEFAULT_TRANSITION_SUBTYPE);
} // put_subType


///////////////////////////////////////////////////////////////
//  Name: get_mode
//
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_mode(BSTR *pbstrMode)
{
    return getStringAttribute (m_SAMode, pbstrMode);
} // get_mode


///////////////////////////////////////////////////////////////
//  Name: put_mode
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_mode(BSTR bstrMode)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_MODE, 
                              bstrMode, m_SAMode, 
                              WZ_DEFAULT_TRANSITION_MODE);
} // put_mode


///////////////////////////////////////////////////////////////
//  Name: get_fadeColor
//
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEFilterAnimation::get_fadeColor (BSTR *pbstrFadeColor)
{
    return getStringAttribute (m_SAFadeColor, pbstrFadeColor);
} // get_fadeColor


///////////////////////////////////////////////////////////////
//  Name: put_fadeColor
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::put_fadeColor(BSTR bstrFadeColor)
{
    return putStringAttribute(DISPID_TIMEANIMATIONELEMENT_FADECOLOR, 
                              bstrFadeColor, m_SAFadeColor, 
                              WZ_DEFAULT_TRANSITION_SUBTYPE);
} // put_fadeColor


///////////////////////////////////////////////////////////////
//  Name: getStringAttribute
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::getStringAttribute (const CAttr<LPWSTR> & refStringAttr, BSTR *pbstrStringAttr)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_SET_NULL(pbstrStringAttr);

    if (refStringAttr.GetValue())
    {
        *pbstrStringAttr = SysAllocString(refStringAttr.GetValue());
        if (NULL == (*pbstrStringAttr))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
} // getStringAttribute


///////////////////////////////////////////////////////////////
//  Name: putStringAttribute
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::putStringAttribute (DISPID dispidProperty, 
                                          BSTR bstrStringAttr, 
                                          CAttr<LPWSTR> & refStringAttr, 
                                          LPCWSTR wzDefaultValue)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(bstrStringAttr);

    // This will clean out the old value.
    // We need to can the old composer et al.
    if (NULL != refStringAttr.GetValue())
    {
        endAnimate();
    }

    if (refStringAttr.IsSet())
    {
        delete [] refStringAttr.GetValue();
        refStringAttr.Reset(const_cast<LPWSTR>(wzDefaultValue));
    }

    refStringAttr.SetValue(CopyString(bstrStringAttr));
    if (NULL == refStringAttr.GetValue())
    {
        hr = E_OUTOFMEMORY;
    }

    NotifyPropertyChanged(dispidProperty);
    RRETURN(hr);
} // putStringAttribute


///////////////////////////////////////////////////////////////
//  Name: GetParameters
//
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEFilterAnimation::GetParameters (VARIANT *pvarParams)
{
    return E_NOTIMPL;
} // GetParameters

///////////////////////////////////////////////////////////////
//  Name: RangeCheckValue
//
///////////////////////////////////////////////////////////////
bool
CTIMEFilterAnimation::RangeCheckValue (const VARIANT *pvarValueItem)
{
    bool fRet = false;

    if (VT_R8 == V_VT(pvarValueItem))
    {
        if ((0.0 <= V_R8(pvarValueItem)) && (1.0 >= V_R8(pvarValueItem)) )
        {
            fRet = true;
        }
    }

    return fRet;
} // RangeCheckValue

///////////////////////////////////////////////////////////////
//  Name: ValidateByValue
//
///////////////////////////////////////////////////////////////
bool
CTIMEFilterAnimation::ValidateByValue (const VARIANT *pvarBy)
{
    bool fRet = CTIMEAnimationBase::ValidateByValue(pvarBy);

    if (fRet)
    {
        fRet = RangeCheckValue(pvarBy);
    }

    if (!fRet)
    {
        m_AnimPropState.fBadBy = true;
    }

    return fRet;
} // ValidateByValue


///////////////////////////////////////////////////////////////
//  Name: ValidateValueListItem
//
//  Synopsis : Range check our value list items
//
///////////////////////////////////////////////////////////////
bool
CTIMEFilterAnimation::ValidateValueListItem (const VARIANT *pvarValueItem)
{
    bool fRet = CTIMEAnimationBase::ValidateValueListItem(pvarValueItem);

    if (fRet)
    {
        fRet = RangeCheckValue(pvarValueItem);
    }

    if (!fRet)
    {
        m_AnimPropState.fBadValues = true;
    }

    return fRet;
} // ValidateValueListItem


///////////////////////////////////////////////////////////////
//  Name: addToComposerSite
//
///////////////////////////////////////////////////////////////
HRESULT
CTIMEFilterAnimation::addToComposerSite (IHTMLElement2 *pielemTarget)
{
    HRESULT hr = E_FAIL;

    // We do not want to set this up unless 
    // the animation is valid.  If we apply the 
    // filter when we do not mean to, we'll get 
    // incorrect results.
    if (!DisableAnimation())
    {
        hr = THR(CTIMEAnimationBase::addToComposerSite(pielemTarget));
    }

    RRETURN2(hr, E_FAIL, S_FALSE);
} // addToComposerSite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animelm.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animelm.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMELM_H
#define _ANIMELM_H

#include "animbase.h"


class
ATL_NO_VTABLE
CTIMEAnimationElement :
    public CComCoClass<CTIMEAnimationElement, &CLSID_TIMEAnimation>,
    public CTIMEAnimationBase
{

public:
    CTIMEAnimationElement() {;}
    virtual ~CTIMEAnimationElement() {;}

    DECLARE_AGGREGATABLE(CTIMEAnimationElement);
    DECLARE_REGISTRY(CLSID_TIMEAnimation,
                     LIBID __T(".TIMEAnimation.1"),
                     LIBID __T(".TIMEAnimation"),
                     0,
                     THREADFLAGS_BOTH);
private:
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEAnimationElement"); }
#endif

};

#endif /* _ANIMELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animfilter.h ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\src\animfilter.h
//
//  Classes:    CTIMEFilterAnimation
//
//  History:
//  2000/08/24  mcalkins    Created.
//
//------------------------------------------------------------------------------
#pragma once

#ifndef _ANIMFILTER_H
#define _ANIMFILTER_H

#include "colorutil.h"
#include "animbase.h"

//+-----------------------------------------------------------------------------
//
// CTIMEFilterAnimation
//
//------------------------------------------------------------------------------
class CTIMEFilterAnimation : 
    public CComCoClass<CTIMEFilterAnimation, &CLSID_TIMEFilterAnimation>,
    public CTIMEAnimationBase,
    public IFilterAnimationInfo
{
public:

    CTIMEFilterAnimation();
    virtual ~CTIMEFilterAnimation();

    DECLARE_AGGREGATABLE(CTIMEFilterAnimation);
    DECLARE_REGISTRY(CLSID_TIMEFilterAnimation,
                     LIBID __T(".TIMEFilterAnimation.1"),
                     LIBID __T(".TIMEFilterAnimation"),
                     0,
                     THREADFLAGS_BOTH);

    //
    // IElementBehavior
    //
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    //
    // IFilterAnimationInfo
    //
    STDMETHOD(GetParameters)    (VARIANT *pvarParams);

    //
    // CBaseBvr
    //
    STDMETHOD(OnPropertiesLoaded)(void);

    //
    // CTIMEElementBase
    //
    void OnLoad (void);

    //
    // ITIMEAnimationElement
    //
    STDMETHOD(get_type)(BSTR *pbstrType);
    STDMETHOD(put_type)(BSTR bstrType);

    STDMETHOD(get_subType)(BSTR *pbstrSubtype);
    STDMETHOD(put_subType)(BSTR bstrSubtype);

    STDMETHOD(get_mode)(BSTR *pbstrMode);
    STDMETHOD(put_mode)(BSTR bstrMode);

    STDMETHOD(get_fadeColor)(BSTR *pbstrFadeColor);
    STDMETHOD(put_fadeColor)(BSTR bstrFadeColor);

    STUB_INVALID_ATTRIBUTE(BSTR, attributeName)

    //
    // QI Map
    //
    BEGIN_COM_MAP(CTIMEFilterAnimation)
        COM_INTERFACE_ENTRY(IFilterAnimationInfo)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEAnimationBase)
    END_COM_MAP();

protected :

    STDMETHOD(putStringAttribute)(DISPID dispidProperty, 
                                  BSTR bstrStringAttr, 
                                  CAttr<LPWSTR> & refStringAttr, 
                                  LPCWSTR wzDefaultValue);
    STDMETHOD(getStringAttribute)(const CAttr<LPWSTR> & refStringAttr, 
                                  BSTR *pbstrStringAttr);

    HRESULT     AssembleFragmentKey     (void);
    void        EnsureAnimationFunction (void);
    bool        RangeCheckValue (const VARIANT *pvarValueItem);
    virtual HRESULT addToComposerSite (IHTMLElement2 *pielemTarget);    
    virtual bool ValidateByValue (const VARIANT *pvarBy);
    virtual bool ValidateValueListItem (const VARIANT *pvarValueItem);

private:

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEFilterAnimation"); }
#endif

}; // CTIMEFilterAnimation


#endif // _ANIMFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animmotion.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: animmotion.cpp
 *
 * Abstract: Simple animation of Elements
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "animfrag.h"
#include "animmotion.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagMotionAnimationTimeElm, "SMIL Animation", "CTIMEMotionAnimation methods")
DeclareTag(tagMotionAnimationTimeValue, "SMIL Animation", "CTIMEMotionAnimation composition callbacks")
DeclareTag(tagMotionAnimationTimeValueAdditive, "SMIL Animation", "CTIMEMotionAnimation additive updates")
DeclareTag(tagMotionAnimationPath, "SMIL Animation", "CTIMEMotionAnimation Path")

#define DEFAULT_ORIGIN        ORIGIN_DEFAULT
#define DEFAULT_PATH          NULL

static const LPWSTR s_cPSTR_COMMA_SEPARATOR = L",";

#define SUPER CTIMEAnimationBase

///////////////////////////////////////////////////////////////
//  Name: CTIMEMotionAnimation
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMEMotionAnimation::CTIMEMotionAnimation() :
  m_bBy(false),
  m_bTo(false),
  m_bFrom(false),
  m_bNeedFirstLeftUpdate(false),
  m_bNeedFinalLeftUpdate(false),
  m_bNeedFirstTopUpdate(false),
  m_bNeedFinalTopUpdate(false),
  m_pPointValues(NULL),
  m_bLastSet(false),
  m_bNeedBaselineUpdate(false),
  m_bAnimatingLeft(false)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::CTIMEMotionAnimation()",
              this));
    
    m_ptOffsetParent.x = 0.0;
    m_ptOffsetParent.y = 0.0;
    m_pointTO.x               = m_pointTO.y               = 0;
    m_pointFROM.x             = m_pointFROM.y             = 0;
    m_pointBY.x               = m_pointBY.y               = 0;
    m_pointLast.x             = m_pointLast.y             = 0;
    m_pointCurrentBaseline.x  = m_pointCurrentBaseline.y  = 0;
    m_pSplinePoints.x1 = m_pSplinePoints.y1 = m_pSplinePoints.x2 = m_pSplinePoints.y2 = 0.0;
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMEMotionAnimation
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMEMotionAnimation::~CTIMEMotionAnimation()
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::~CTIMEMotionAnimation()",
              this));

    if (m_spPath.p)
    {
        IGNORE_HR(m_spPath->Detach());
    }

    delete [] m_pPointValues;
} 


///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::Init(%p)",
              this, pBehaviorSite));
    
    
    HRESULT hr = E_FAIL; 
    CComPtr <IDispatch> pDocDisp;

    hr = THR(SUPER::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

    // Set up defauts
    m_bAdditive    = false;
    m_bAccumulate  = false;
    // Using InternalSet instead of '=', to prevent attribute from being persisted
    m_IACalcMode.InternalSet(CALCMODE_PACED);
    

done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: DetermineAdditiveEffect
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::DetermineAdditiveEffect (void)
{
    // by w/o from implies additive
    if (   (BY == m_dataToUse)
        && (m_bBy)
        && (!m_bFrom))
    {
        m_bAdditive = true;
    }
    // to w/o from overrides the additive=sum effect.
    else if (   (TO == m_dataToUse)
             && (m_bTo)
             && (!m_bFrom))
    {
        m_bAdditive = false;
    }
    // 
    else
    {
        m_bAdditive = m_bAdditiveIsSum;
    }
} // DetermineAdditiveEffect

///////////////////////////////////////////////////////////////
//  Name: put_by
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_by(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_by()",
              this));
    
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    // reset this attribute
    dt = RESET;
    m_pointBY.x = 0;
    m_pointBY.y = 0;
    m_bBy = false;

    // cache animation type
    dTemp = m_dataToUse;

    // delegate to base class
    hr = SUPER::put_by(val);
    if (FAILED(hr))
    {
        goto done;
    }
    
    // restore animation type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // parse
    hr = ParsePair(val,&m_pointBY);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    // indicate valid BY value
    m_bBy = true;
    dt = BY;

    hr = S_OK;
done:
    m_AnimPropState.fBadBy = FAILED(hr) ? true : false;

    m_AnimPropState.fInterpolateBy = fCanInterpolate;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_by


///////////////////////////////////////////////////////////////
//  Name: put_from
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_from(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_from()",
              this));
   
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;

    // Clear the attribute
    m_pointFROM.x = 0;
    m_pointFROM.y = 0;
    m_bFrom = false;

    // delegate to base class
    hr = SUPER::put_from(val);
    if (FAILED(hr))
    {
        goto done;
    }

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    hr = ParsePair(val, &m_pointFROM);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }
                
    m_bFrom = true;
    
    hr = S_OK;;
done:
    m_AnimPropState.fBadFrom = FAILED(hr) ? true : false;
    
    m_AnimPropState.fInterpolateFrom = fCanInterpolate;

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_from


///////////////////////////////////////////////////////////////
//  Name: put_values
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_values(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_values()",
              this));

    HRESULT hr = E_FAIL;
    CComVariant svarTemp;
    int i;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    dTemp = m_dataToUse;

    // reset internal state
    delete [] m_pPointValues;
    m_pPointValues = NULL;

    // delegate to base class
    hr = SUPER::put_values(val);
    if (FAILED(hr))
    {
        goto done;
    }

    // restore animation-type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // check for an empty string
    if (m_numValues == 0)
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    m_pPointValues = NEW POINTF [m_numValues];
    if (NULL == m_pPointValues)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Parse out the pairs values.....
    for (i=0; i< m_numValues;i++)
    {
        svarTemp = m_ppstrValues[i];

        if (NULL == svarTemp.bstrVal)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = ParsePair(svarTemp, &m_pPointValues[i]);
        if (FAILED(hr))
        {
            fCanInterpolate = false;
            goto done;
        }
    }

    dt = VALUES;

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_AnimPropState.fBadValues = true;
        delete [] m_pPointValues;
        m_pPointValues = NULL;
    }
    else
    {
        m_AnimPropState.fBadValues = false;
    }

    m_AnimPropState.fInterpolateValues = fCanInterpolate;
    
    updateDataToUse(dt);

    CalculateTotalDistance();
    
    ValidateState();

    DetermineAdditiveEffect();
    
    RRETURN(hr);
} // put_values


///////////////////////////////////////////////////////////////
//  Name: put_to
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_to(VARIANT val)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_to()",
              this));
   
    HRESULT hr = E_FAIL;
    bool fCanInterpolate = true;
    DATATYPES dt, dTemp;

    // reset this attribute
    dt = RESET;
    m_pointTO.x = 0;
    m_pointTO.y = 0;
    m_bTo = false;

    // cache animation type
    dTemp = m_dataToUse;

    // delegate to base class
    hr = SUPER::put_to(val);
    if (FAILED(hr))
    {
        goto done;
    }
    
    // restore animation type
    m_dataToUse = dTemp;

    // do we need to remove this attribute?
    if (    (VT_EMPTY == val.vt)
        ||  (VT_NULL == val.vt))
    {
        hr = S_OK;
        goto done;
    }

    // parse
    hr = ParsePair(val,&m_pointTO);
    if (FAILED(hr))
    {
        fCanInterpolate = false;
        goto done;
    }

    // indicate valid TO value
    m_bTo = true;
    dt = TO;

    hr = S_OK;
done:
    m_AnimPropState.fBadTo = FAILED(hr) ? true : false;
    
    m_AnimPropState.fInterpolateTo = fCanInterpolate;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    RRETURN(hr);
} // put_to


HRESULT 
CTIMEMotionAnimation::SetSMILPath(CTIMEPath ** pPath, long numPath, long numMoveTo)
{
    HRESULT hr = E_FAIL;
    CComPtr<ISMILPath> spPath;

    CHECK_RETURN_NULL(pPath);

    if (!m_spPath)
    {
        hr = THR(::CreateSMILPath(this, &spPath));
        if (FAILED(hr))
        {
            goto done;
        }

        // keep a reference on the interface
        m_spPath = spPath;
    }

    hr = THR(m_spPath->SetPath(pPath, numPath, numMoveTo));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: get_path
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::get_path(VARIANT * pvarPath)
{
    HRESULT hr = S_OK;
   
    CHECK_RETURN_NULL(pvarPath);

    VariantInit(pvarPath);

    if (m_SAPath.GetValue())
    {
        V_BSTR(pvarPath) = SysAllocString(m_SAPath.GetValue());

        if (NULL == V_BSTR(pvarPath))
        {
            hr = E_OUTOFMEMORY;
        }

        V_VT(pvarPath) = VT_BSTR;
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: put_path
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_path(VARIANT varPath)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::put_path()",
              this));
    TraceTag((tagMotionAnimationPath, "CTIMEMotionAnimation(%p, %ls)::put_path(%ls)",
        this, GetID(), varPath.bstrVal));

    HRESULT hr = S_OK;  
    long numPath = 0;
    long numMoveTo = 0;
    CTIMEPath ** pPath = NULL;
    CTIMEParser *pParser = NULL;
    CComVariant svarTemp;
    DATATYPES dt;

    //
    // Clear and reset the attribute
    //

    dt = RESET;
    delete [] m_SAPath.GetValue();
    m_SAPath.Reset(DEFAULT_PATH);

    // Clear and reset internal state
    if (m_spPath.p)
    {
        m_spPath->ClearPath();
    }

    // do we need to remove this attribute?
    if (    (VT_EMPTY == varPath.vt)
        ||  (VT_NULL == varPath.vt))
    {
        hr = S_OK;
        goto done;
    }

    //
    // Process the attribute
    //

    // convert to BSTR
    hr = THR(svarTemp.Copy(&varPath));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(VariantChangeTypeEx(&svarTemp, &svarTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        goto done;
    }

    // Store the new attribute string
    m_SAPath.SetValue(CopyString(svarTemp.bstrVal));
    if (NULL == m_SAPath.GetValue())
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
  
    // create parser
    pParser = NEW CTIMEParser(svarTemp.bstrVal, true);
    if (pParser == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    // parse the path 
    pParser->ParsePath(numPath, numMoveTo,&pPath);

    // set it on the smil path object
    hr = THR(SetSMILPath(pPath, numPath, numMoveTo));
    if (FAILED(hr))
    {
        goto done;
    }

    // mark data as path values
    dt = PATH;

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        delete pPath;
    }
    delete pParser;

    updateDataToUse(dt);

    ValidateState();

    DetermineAdditiveEffect();

    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_PATH);

    RRETURN(hr);
} // put_path


///////////////////////////////////////////////////////////////
//  Name: get_origin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::get_origin(BSTR * val)
{
    HRESULT hr = S_OK;
    LPWSTR wszOriginString = WZ_ORIGIN_DEFAULT;

    CHECK_RETURN_SET_NULL(val);

    if (m_IAOrigin == ORIGIN_ELEMENT)
    {
        wszOriginString = WZ_ORIGIN_ELEMENT;
    }
    else if (m_IAOrigin == ORIGIN_PARENT)
    {
        wszOriginString = WZ_ORIGIN_PARENT;
    }
    else
    {
        wszOriginString = WZ_ORIGIN_DEFAULT;
    }

    *val = SysAllocString(wszOriginString);
    if (NULL == *val)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
} // get_origin

///////////////////////////////////////////////////////////////
//  Name: put_origin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::put_origin(BSTR val)
{
    HRESULT hr = S_OK;
    LPOLESTR szOrigin = NULL;

    CHECK_RETURN_NULL(val);

    m_IAOrigin.Reset(DEFAULT_ORIGIN);

    szOrigin = TrimCopyString(val);
    if (szOrigin == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (0 == StrCmpIW(WZ_ORIGIN_DEFAULT, szOrigin))
    {
        m_IAOrigin.SetValue(ORIGIN_DEFAULT);
    }
    else if (0 == StrCmpIW(WZ_ORIGIN_PARENT, szOrigin))
    {
        m_IAOrigin.SetValue(ORIGIN_PARENT);
    }
    else if (0 == StrCmpIW(WZ_ORIGIN_ELEMENT, szOrigin))
    {
        m_IAOrigin.SetValue(ORIGIN_ELEMENT);
    }

done:
    NotifyPropertyChanged(DISPID_TIMEANIMATIONELEMENT_ORIGIN);

    if (szOrigin != NULL)
    {
        delete [] szOrigin;
    }

    RRETURN(hr);
} // put_origin


///////////////////////////////////////////////////////////////
//  Name: removeFromComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::removeFromComposerSite (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::removeFromComposerSite(%p)", 
              this, m_spFragmentHelper));

    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstr(m_bAnimatingLeft?WZ_LEFT:WZ_TOP);

        if (bstr == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = THR(m_spCompSite->RemoveFragment(bstr, m_spFragmentHelper));
        
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // removeFromComposerSite


///////////////////////////////////////////////////////////////
//  Name: endAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::endAnimate (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%lx)::endAnimate()",
              this));

    if (m_spCompSite != NULL)
    {
        m_bAnimatingLeft = true;
        IGNORE_HR(removeFromComposerSite());
        m_bAnimatingLeft = false;
        IGNORE_HR(removeFromComposerSite());
        m_spCompSite.Release();
    }
    SUPER::endAnimate();
} // endAnimate


///////////////////////////////////////////////////////////////
//  Name: addToComposerSite
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::addToComposerSite (IHTMLElement2 *pielemTarget)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::addToComposerSite(%p, %p)",
              this, pielemTarget, m_spFragmentHelper));

    HRESULT hr;
    CComPtr<IDispatch> pidispSite;

    hr = removeFromComposerSite();
    if (FAILED(hr))
    {
        goto done;
    }

    // Do we have work to do?
    if (NONE == m_dataToUse)
    {
        hr = S_FALSE;
        goto done;
    }    

    if (m_spCompSite == NULL)
    {
        hr = THR(EnsureComposerSite (pielemTarget, &pidispSite));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pidispSite->QueryInterface(IID_TO_PPV(IAnimationComposerSite, 
                                                       &m_spCompSite)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    {   
        CComBSTR bstrLeft(WZ_LEFT);
        CComBSTR bstrTop(WZ_TOP);

        if (bstrLeft == NULL ||
            bstrTop  == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->AddFragment(bstrLeft, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = THR(m_spCompSite->AddFragment(bstrTop, m_spFragmentHelper));
        if (FAILED(hr))
        {
            goto done;
        }
        
    }

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(removeFromComposerSite());
    }

    RRETURN2(hr, E_OUTOFMEMORY, S_FALSE);
} // CTIMEMotionAnimation::addToComposerSite

///////////////////////////////////////////////////////////////
//  Name: QueryAttributeForTopLeft
//
//  Abstract: Determine whether we're animating top or left.
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::QueryAttributeForTopLeft (LPCWSTR wzAttributeName)
{
    HRESULT hr;

    // Check first and final states for each attribute 
    // governed by this behavior.
    if (0 == StrCmpIW(wzAttributeName, WZ_LEFT))
    {
        m_bAnimatingLeft = true;
    }
    else if (0 == StrCmpIW(wzAttributeName, WZ_TOP))
    {
        m_bAnimatingLeft = false;
    }
    else
    {
        // Invalid attribute name for this behavior.
        // It must be either left or top.
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // QueryAttributeForTopLeft

///////////////////////////////////////////////////////////////
//  Name: PostprocessValue
//
//  Abstract: Apply additive, accumulate passes and save the value.
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    Assert(VT_R8 == V_VT(pvarValue));

    if (VT_R8 != V_VT(pvarValue))
    {
        goto done;
    }

    if (m_bAdditive)
    {
        DoAdditive(pvarCurrent, pvarValue);
    }
    // Do we need to apply an origin offset?  
    // This is only relevant when we're not doing 
    // additive animation.
    else if (m_IAOrigin != ORIGIN_PARENT)
    {
        V_R8(pvarValue) += GetCorrectLeftTopValue(m_ptOffsetParent);
    }

    if (m_bAccumulate)
    {
        DoAccumulation(pvarValue);
    }

    PutCorrectLeftTopValue(V_R8(pvarValue),m_pointLast);

done :
    return;
} // PostprocessValue

///////////////////////////////////////////////////////////////
//  Name: NotifyOnDetachFromComposer
//
//  Abstract: Let go of any refs to the composer site.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP 
CTIMEMotionAnimation::NotifyOnDetachFromComposer (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::NotifyOnDetach(%p)", 
              this, m_spFragmentHelper));

    HRESULT hr;

    if (m_spCompSite != NULL)
    {
        CComBSTR bstrLeft(WZ_LEFT);
        CComBSTR bstrTop(WZ_TOP);

        if ((bstrLeft == NULL) ||
            (bstrTop  == NULL))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }


        Assert(m_spFragmentHelper != NULL);
        hr = THR(m_spCompSite->RemoveFragment(bstrLeft, m_spFragmentHelper));
        hr = THR(m_spCompSite->RemoveFragment(bstrTop, m_spFragmentHelper));
        IGNORE_RETURN(m_spCompSite.Release()); //lint !e792
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // NotifyOnDetachFromComposer

///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract: Convert the original and in-out values into
//            a canonical form.
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMEMotionAnimation::CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld)
{
    HRESULT hr = CTIMEAnimationBase::CanonicalizeValue(pvarValue, pvtOld);

    if (FAILED(hr))
    {
        goto done;
    }

    if (VT_BSTR == V_VT(pvarValue))
    {
        // We can avert canonicalizing "auto" here, as it 
        // will usually be an intial value.  If it turns
        // out not to be superfluous, we'll see this again
        // during interpolation.
        if (0 != StrCmpW(WZ_AUTO, V_BSTR(pvarValue)))
        {
            if (!ConvertToPixels(pvarValue))
            {
                hr = E_FAIL;
                goto done;
            }
        }
        *pvtOld = VT_BSTR;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UpdateCurrentBaseTime
//
//  Abstract: Examine the current base time, and update it if 
//            we're doing baseline+to animation (the spec calls
//            this hybrid additive).
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::UpdateCurrentBaseline (const VARIANT *pvarCurrent)
{
    m_bNeedBaselineUpdate = false;

    // Are we doing hybrid additive animation?
    if (   (TO == m_dataToUse)
        && (!m_bFrom))
    {
        CComVariant varCurrent;
        HRESULT hr = varCurrent.Copy(pvarCurrent);

        if (FAILED(hr))
        {
            goto done;
        }

        if (!ConvertToPixels(&varCurrent))
        {
            goto done;
        }

        // Has the baseline value changed since we updated it last?
        if (GetCorrectLeftTopValue(m_pointCurrentBaseline) != V_R8(&varCurrent))
        {
            m_bNeedBaselineUpdate = true;
            PutCorrectLeftTopValue(varCurrent, m_pointCurrentBaseline);
        }
    }

done :
    return;
} // UpdateCurrentBaseTime

///////////////////////////////////////////////////////////////
//  Name: UpdateStartValue
//
//  Abstract: This is a nop for animateMotion.
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::UpdateStartValue (VARIANT *pvarNewStartValue)
{
    m_bNeedStartUpdate = false;
} // UpdateStartValue

///////////////////////////////////////////////////////////////
//  Name: DoFill
//
//  Abstract: Apply the fill value if necessary.
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::DoFill (VARIANT *pvarValue)
{
    HRESULT hr;

    if (IsOn() && m_bLastSet && m_timeAction.IsTimeActionOn())
    {
        VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: NotifyOnGetValue
//
//  Abstract: Compose the new value of the in/out variant
//            according to our interpolation logic.
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMotionAnimation::NotifyOnGetValue (BSTR bstrAttributeName, 
                                        VARIANT varOriginal, VARIANT varCurrentValue,
                                        VARIANT *pvarInOutValue)
{
    HRESULT hr = QueryAttributeForTopLeft(bstrAttributeName);
    if (FAILED(hr))
    {
        goto done;
    }

    // Check if we need to do anything
    if (DisableAnimation())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = CTIMEAnimationBase::NotifyOnGetValue(bstrAttributeName, varOriginal,
                                              varCurrentValue, pvarInOutValue);

    hr = S_OK;
done :

// Turn this on to trace in/out parameters of this function (this doesn't need to be in all dbg builds)
#if (0 && DBG) 
    {
        CComVariant v1(varOriginal);
        CComVariant v2(varCurrentValue);
        CComVariant v3(*pvarInOutValue);

        v1.ChangeType(VT_BSTR);
        v2.ChangeType(VT_BSTR);
        v3.ChangeType(VT_BSTR);

        TraceTag((tagError, "CTIMEAnimationBase(%p)::NotifyOnGetValue(Attr=%ls, Orig=%ls, Curr=%ls, Out=%ls)", 
            this, bstrAttributeName, v1.bstrVal, v2.bstrVal, v3.bstrVal));
    }
#endif

    RRETURN(hr);
} // NotifyOnGetValue

///////////////////////////////////////////////////////////////
//  Name: SetInitialState
//
//  Abstract: set an initial internal state for the animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::SetInitialState (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::SetInitialState()",
              this));

    m_bNeedFirstLeftUpdate = true;
    m_bNeedFirstTopUpdate = true;
    m_bNeedFinalLeftUpdate = false;
    m_bNeedFinalTopUpdate = false;
} // SetInitialState

///////////////////////////////////////////////////////////////
//  Name: SetFinalState
//
//  Abstract: set an final internal state for animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::SetFinalState (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::SetFinalState()",
              this));

    m_bNeedFinalLeftUpdate = true;
    m_bNeedFinalTopUpdate = true;
} // SetFinalState


///////////////////////////////////////////////////////////////
//  Name: OnFirstUpdate
//
//  Abstract: save the baseline value of the animation
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnFirstUpdate (VARIANT *pvarValue)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnFirstUpdate()",
              this));
    
    HRESULT hr = S_OK;
    CComVariant varTemp;

    hr = THR(varTemp.Copy(pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    PutCorrectLeftTopValue(varTemp ,m_pointLast);
    PutCorrectLeftTopValue(varTemp ,m_pointCurrentBaseline);
    PutCorrectLeftTopValue(varTemp, m_ptOffsetParent);

    if (m_bAnimatingLeft)
    {
        VariantCopy(&m_varLeftOrig,pvarValue);
        m_bNeedFirstLeftUpdate = false;
    }
    else
    {
        VariantCopy(&m_varTopOrig,pvarValue);
        m_bNeedFirstTopUpdate = false;
    }
        
done :
    return;
} // OnFirstUpdate

///////////////////////////////////////////////////////////////
//  Name: resetValue
//
//  Abstract: reset to the initial value
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::resetValue (VARIANT *pvarValue)
{
    if (m_varLeftOrig.vt != VT_EMPTY || m_varTopOrig.vt != VT_EMPTY)
    {
        if (m_bAnimatingLeft)
        {
            IGNORE_HR(THR(::VariantCopy(pvarValue, &m_varLeftOrig)));
            PutCorrectLeftTopValue(m_varLeftOrig, m_pointCurrentBaseline);
        }
        else
        {
            IGNORE_HR(THR(::VariantCopy(pvarValue, &m_varTopOrig)));
            PutCorrectLeftTopValue(m_varTopOrig, m_pointCurrentBaseline);
        }
    }
} // resetValue

///////////////////////////////////////////////////////////////
//  Name: resetAnimate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::resetAnimate (void)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::resetAnimate()",
              this));

    m_pointCurrentBaseline.x = m_pointCurrentBaseline.y = 0.0;
    CTIMEAnimationBase::resetAnimate();
} // resetAnimate

////////////////////////////////////////////////////////////////
//  Name: OnFinalUpdate
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnFinalUpdate()",
              this));

    bool bNeedPostprocess = false;

    VariantClear(pvarValue);
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = 0.0f;
    
    if (GetMMBvr().GetProgress() == 0 &&
        NeedFill() &&
        GetAutoReverse())
    {
        if (PATH == m_dataToUse)
        {
            //
            // Get the first point on the path
            // 

            POINTF startPoint = {0.0, 0.0};

            if (m_spPath.p)
            {
                IGNORE_HR(m_spPath->GetPoint(0, &startPoint));
            }
            else
            {
                Assert(false);
            }

            V_R8(pvarValue) = GetCorrectLeftTopValue(startPoint);
        }
        else if (m_dataToUse == VALUES)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pPointValues[0]);
        }
        else if (m_varFrom.vt != VT_EMPTY)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointFROM);
        }

        bNeedPostprocess = true;
    } 
    else if ((GetMMBvr().GetProgress() != 1) &&
             (NeedFill()))
    {
        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else if ((NeedFill()) &&
             (m_dataToUse != NONE))
    {
        bool fDontPostProcess = false;

        GetFinalValue(pvarValue, &fDontPostProcess);

        if (!fDontPostProcess)
        {
            bNeedPostprocess = true;
        }
    }
    else
    {
        // The animation has ended, and we should tell the base class so.
        resetValue(pvarValue); 
        // Indicate that we don't need to perform 
        // the additive work.
        if (!QueryNeedFirstUpdate())
        {
            IGNORE_HR(removeFromComposerSite());
            m_bNeedAnimInit = true;

        }
    }

    if (bNeedPostprocess)
    {
        PostprocessValue(pvarCurrent, pvarValue);
    }
    
    m_bLastSet = true;
done :

    if (m_bAnimatingLeft)
    {
        m_bNeedFinalLeftUpdate = false;
    }
    else
    {
        m_bNeedFinalTopUpdate = false;
    }
} // OnFinalUpdate


///////////////////////////////////////////////////////////////
//  Name: OnBegin
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnBegin()",
              this));

    SetInitialState();
    SUPER::OnBegin(dblLocalTime, flags);
    
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: OnEnd
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::OnEnd(double dblLocalTime)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::OnEnd()",
              this));

    SetFinalState();
    SUPER::OnEnd(dblLocalTime);
}


///////////////////////////////////////////////////////////////
//  Name: GetAnimationRange
//
//  Abstract: Get the end point of the animation function over the
//            simple duration
//
///////////////////////////////////////////////////////////////
double 
CTIMEMotionAnimation::GetAnimationRange()
{
    double dblReturnVal = 0.0;

    switch (m_dataToUse)
    {
        case PATH:
            {
                if (m_spPath.p)
                {
                    int numPoints = 0;
                    POINTF ptEndPoint = {0.0, 0.0};

                    IGNORE_HR(m_spPath->GetNumPoints(&numPoints));

                    if (0 == numPoints)
                    {
                        goto done;
                    }

                    if (GetAutoReverse())
                    {
                        IGNORE_HR(m_spPath->GetPoint(0, &ptEndPoint));
                    }
                    else
                    {
                        IGNORE_HR(m_spPath->GetPoint(numPoints - 1, &ptEndPoint));
                    }

                    dblReturnVal = GetCorrectLeftTopValue(ptEndPoint);
                }
            }
            break;

        case VALUES:
            {
                if (!m_AnimPropState.fInterpolateValues)
                {
                    goto done;
                }

                if (m_numValues < 1)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pPointValues[0]);
                }
                else
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pPointValues[m_numValues - 1]);
                }
            }
            break;

        case TO:
            {
                if (!m_AnimPropState.fInterpolateTo)
                {
                    goto done;
                }

                if (GetAutoReverse())
                {
                    if (m_bFrom)
                    {
                        if (!m_AnimPropState.fInterpolateFrom)
                        {
                            goto done;
                        }
                    
                        dblReturnVal = GetCorrectLeftTopValue(m_pointFROM);
                    }

                    // For "to" animations (i.e. no "from"), accumulation is disabled, 
                    // so we do not need to handle it.
                }
                else
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pointTO);
                }
            }
            break;

        case BY:
            {
                POINTF ptFrom = {0.0, 0.0};

                if (!m_AnimPropState.fInterpolateBy)
                {
                    goto done;
                }

                if (m_bFrom)
                {
                    if (!m_AnimPropState.fInterpolateFrom)
                    {
                        goto done;
                    }

                    ptFrom = m_pointFROM;
                }

                if (GetAutoReverse())
                {
                    dblReturnVal = GetCorrectLeftTopValue(ptFrom);
                }
                else
                {
                    dblReturnVal = GetCorrectLeftTopValue(m_pointBY) + GetCorrectLeftTopValue(ptFrom);
                }
            }
            break;

        default:
            goto done;
    }

done:
    return dblReturnVal;
}


///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculateDiscreteValue (VARIANT *pvarValue)
{
    if (!ConvertToPixels(pvarValue))
    {
        VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
    }

    switch (m_dataToUse)
    {
        case PATH:
            {
                // ISSUE : dilipk: How should we handle MoveTo and KeyTimes?

                //
                // Discrete values are simply the points on the path
                //

                POINTF   newPos = {0.0, 0.0};

                if (m_spPath.p)
                {
                    int curPoint = 0;
                    int numPoints = 0;
                    double dblSegDur = 0.0;
                    double dblSimpTime = 0.0;

                    IGNORE_HR(m_spPath->GetNumPoints(&numPoints));

                    dblSegDur   = GetMMBvr().GetSimpleDur() / (numPoints ? numPoints : 1); 
                    dblSimpTime = GetMMBvr().GetSimpleTime();

                    if (dblSegDur != 0)
                    {
                        curPoint =  (int) (dblSimpTime / dblSegDur);
                    }
                
                    IGNORE_HR(m_spPath->GetPoint(curPoint, &newPos));
                
                }
                else
                {
                    Assert(false);
                }

                V_R8(pvarValue) = GetCorrectLeftTopValue(newPos);
            }
            break;

        case VALUES:
            {
                int curSeg = CalculateCurrentSegment(true);
                V_R8(pvarValue) = GetCorrectLeftTopValue(m_pPointValues[curSeg]);
            }
            break;

        case TO:
            {
                POINTF ptTo;

                if (m_bFrom && (GetMMBvr().GetProgress() < 0.5))
                {
                    ptTo = m_pointFROM;
                }
                else
                {
                    ptTo   = m_pointTO;
                }

                V_R8(pvarValue) = GetCorrectLeftTopValue(ptTo);
            }
            break;

        case BY:
            {
                if (m_bFrom) 
                {
                    if (GetMMBvr().GetProgress() < 0.5)
                    {
                        // use "from"
                        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointFROM);
                    }
                    else
                    {
                        // use "from" + "by"
                        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointBY)  
                                          + GetCorrectLeftTopValue(m_pointFROM);
                    }
                }
                else
                {
                    // use "parent offset" + "by" - the parent offset is
                    // applied during postprocessing.
                    V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointBY); 
                }
            }
            break;

        default:
            goto done;
    }

done:
    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p,%ls)::calculateDiscreteValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculateLinearValue (VARIANT *pvarValue)
{
    double dblProgress = GetMMBvr().GetProgress();
    POINTF ptFrom = m_pointFROM;

    if (!ConvertToPixels(pvarValue))
    {
        VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
    }

    Assert(pvarValue->vt == VT_R8);
    
    if (m_dataToUse == PATH)
    {
        m_pointLast = InterpolatePath();

        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else if (m_dataToUse == VALUES)
    {
        double curProgress;
        int    curSeg;

        curProgress = CalculateProgressValue(false);
        curSeg      = CalculateCurrentSegment(false);

        
        V_R8(pvarValue) = InterpolateValues((double)(GetCorrectLeftTopValue(m_pPointValues[curSeg])), 
                                                (double)(GetCorrectLeftTopValue(m_pPointValues[curSeg+1])),
                                                (double) curProgress); //lint !e736
    }
    else if (TO == m_dataToUse)
    {   
        if (m_FADur)
        {
            double dblFrom = 0;
            double dblTo = GetCorrectLeftTopValue(m_pointTO);
            
            if (m_bFrom)
            {
                dblFrom = GetCorrectLeftTopValue(ptFrom);
            }
            else
            {
                // Handle the case in which a hybrid animation
                // must factor in results from other fragments.
                if (m_bNeedBaselineUpdate)
                {
                    // Offset the new baseline relative to the old.
                    dblFrom = GetCorrectLeftTopValue(m_pointCurrentBaseline);
                }

                // animating TO w/ no from value, and parent's origin :
                // we should animate from our current position, to 
                // the parent's offset specified as the 'to' value.
                if (ORIGIN_PARENT == m_IAOrigin)
                {
                    dblFrom += GetCorrectLeftTopValue(m_ptOffsetParent);
                }
            }

            V_R8(pvarValue) = InterpolateValues(dblFrom, dblTo, dblProgress);
        }
        else
        {
            // Just go to the to Value...
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointTO);
        }
        
    }
    else if (BY == m_dataToUse)
    {
        double dblFrom = 0;

        if (m_bFrom)
        {
            dblFrom = GetCorrectLeftTopValue(ptFrom);
        }

        if (m_FADur)
        {
            V_R8(pvarValue) = InterpolateValues(dblFrom, dblFrom + GetCorrectLeftTopValue(m_pointBY), dblProgress);
        }
        else
        {
            // Just offset by the m_varBy value.
            V_R8(pvarValue) = dblFrom + GetCorrectLeftTopValue(m_pointBY);
        }
    }
    else
    {
        // just bail.
        goto done;
    }
        
done:

    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p, %ls)::calculateLinearValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculateSplineValue (VARIANT *pvarValue)
{
    double dblProgress = GetMMBvr().GetProgress();
    POINTF ptFrom = m_pointFROM;
    
    if (!ConvertToPixels(pvarValue))
    {
        VariantClear(pvarValue);
        pvarValue->vt = VT_R8;
    }

    Assert(pvarValue->vt == VT_R8);
  
    if (m_dataToUse == PATH)
    {
        m_pointLast = InterpolatePath();

        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);
    }
    else if (VALUES == m_dataToUse)
    {
        double curProgress;
        int    curSeg;

        if (NULL == m_pKeySplinePoints)
        {
            // do nothing if we have no SplinePoints and are told to animate with calcmode=spline
            goto done;
        }

        curProgress = CalculateProgressValue(false);
        curSeg      = CalculateCurrentSegment(false);

        curProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg],curProgress);

        V_R8(pvarValue) = InterpolateValues((double)(GetCorrectLeftTopValue(m_pPointValues[curSeg])), 
                                                (double)(GetCorrectLeftTopValue(m_pPointValues[curSeg+1])),
                                                curProgress); //lint !e736
    }
    else if (TO == m_dataToUse)
    {   
        if (m_FADur)
        {
            double dblFrom = 0;
            double dblTo = GetCorrectLeftTopValue(m_pointTO);

            dblProgress = CalculateBezierProgress(m_pKeySplinePoints[0],dblProgress);            
            
            if (m_bFrom)
            {
                dblFrom = GetCorrectLeftTopValue(ptFrom);
            }
            else
            {
                // Handle the case in which a hybrid animation
                // must factor in results from other fragments.
                if (m_bNeedBaselineUpdate)
                {
                    // Offset the new baseline relative to the old.
                    dblFrom = GetCorrectLeftTopValue(m_pointCurrentBaseline);
                }

                // animating TO w/ no from value, and parent's origin :
                // we should animate from our current position, to 
                // the parent's offset specified as the 'to' value.
                if (ORIGIN_PARENT == m_IAOrigin)
                {
                    dblFrom += GetCorrectLeftTopValue(m_ptOffsetParent);
                }
            }

            V_R8(pvarValue) = InterpolateValues(dblFrom, dblTo, dblProgress);
        }
        else
        {
            // Just go to the to Value...
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointTO);
        }
        
    }
    else if (BY == m_dataToUse)
    {
        double dblFrom = 0;

        if (m_bFrom)
        {
            dblFrom = GetCorrectLeftTopValue(ptFrom);
        }
        if (m_FADur)
        {
            dblProgress = CalculateBezierProgress(m_pKeySplinePoints[0],dblProgress);
            V_R8(pvarValue) = InterpolateValues(dblFrom, dblFrom + GetCorrectLeftTopValue(m_pointBY), dblProgress);
        }
        else
        {
            // Just offset by the m_varBy value.
            V_R8(pvarValue) = dblFrom + GetCorrectLeftTopValue(m_pointBY);
        }
    }
    else
    {
        // just bail.
        goto done;
    }
        
done:
    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p, %ls)::calculateSplineValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::calculatePacedValue (VARIANT *pvarValue)
{
    double dblVal = 0.;
    double dblProgress = GetMMBvr().GetProgress();
    double curDisanceTraveled = 0.0;
    double dblDistance,pDistance;
    int i;

    if (m_dataToUse == PATH)
    {
        //
        // delegate to the smil path object
        //

        POINTF fNewPoint = InterpolatePathPaced();

        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = GetCorrectLeftTopValue(fNewPoint);
    }
    else if (m_dataToUse == VALUES)
    {
        // how much should we have travelled by now ?
        curDisanceTraveled = InterpolateValues(0.0, m_dblTotalDistance, dblProgress);

        // run though and see what segment we should be in.
        i=1;
        dblDistance  =0.0;
        pDistance =0.0;
        do{
            pDistance = dblDistance;
            dblDistance += CalculateDistance(m_pPointValues[i-1],m_pPointValues[i]);
            i++;
        }while(dblDistance < curDisanceTraveled);
        i = (i < 2)?1:i-1;

        // Calculate what percentage of the current segment we are at.
        dblDistance = CalculateDistance(m_pPointValues[i-1],m_pPointValues[i]);
        if (dblDistance == 0)
        {
            goto done;
        }

        dblDistance = (curDisanceTraveled - pDistance)/dblDistance;

        V_R8(pvarValue) = InterpolateValues((double)(GetCorrectLeftTopValue(m_pPointValues[i-1])), 
                                            (double)(GetCorrectLeftTopValue(m_pPointValues[i])),
                                            dblDistance);
        V_VT(pvarValue) = VT_R8;
    }
    else
    {
        IGNORE_HR(calculateLinearValue(pvarValue));
        goto done;
    }

   
   
    TraceTag((tagMotionAnimationTimeValue,
              "CTIMEMotionAnimation(%p, %ls)::calculatePacedValue(%ls %lf)",
              this, m_id, 
              m_bAnimatingLeft ? L"x = " : L"\t y =",
              V_R8(pvarValue)));

done:
    return S_OK;
}
   
///////////////////////////////////////////////////////////////
//  Name: CalculateDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEMotionAnimation::CalculateDistance(POINTF a, POINTF b)
{
    float deltaX,deltaY;

    deltaX = a.x - b.x;
    deltaY = a.y - b.y;
    return(sqrt((deltaX*deltaX) + (deltaY*deltaY)));
}


///////////////////////////////////////////////////////////////
//  Name: CalculateTotalDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::CalculateTotalDistance()
{
    int index;
    m_dblTotalDistance = 0;

    if (    (NULL == m_pPointValues)
        ||  (m_numValues < 2))
    {
        goto done;
    }

    for (index=1; index < m_numValues; index++)
    {
         m_dblTotalDistance += CalculateDistance(m_pPointValues[index-1], m_pPointValues[index]);
    }
done:
    return;
}

///////////////////////////////////////////////////////////////
//  Name: CalculatePointDistance
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
double
CTIMEMotionAnimation::CalculatePointDistance(POINTF p1, POINTF p2)
{
    double dX = (p1.x - p2.x);
    double dY = (p1.y - p2.y);
    return sqrt((dX*dX) + (dY*dY));  
}


POINTF 
CTIMEMotionAnimation::InterpolatePathPaced()
{
    POINTF newPos = {0.0, 0.0};
    double dblProgress = 0.0;

    if (!m_spPath)
    {
        Assert(false);
        goto done;
    }

    // get the progress
    dblProgress = GetMMBvr().GetProgress();

    IGNORE_HR(m_spPath->InterpolatePaced(dblProgress, &newPos));

done:
    return newPos;
}


///////////////////////////////////////////////////////////////
//  Name: InterpolatePath
//
//  Abstract: calculates current position on path
//            Used for linear and spline CalcModes.
//            
///////////////////////////////////////////////////////////////
POINTF 
CTIMEMotionAnimation::InterpolatePath()
{
    HRESULT hr = E_FAIL;
    POINTF newPos = {0.0, 0.0};
    double dblProgress;
    bool fValid = false;
    int curSeg = 0;
    double curProgress = 0.0;

    if (!m_spPath)
    {
        Assert(false);
        goto done;
    }

    // get the progress
    dblProgress = GetMMBvr().GetProgress();

    // use keytimes if any
    if (m_pdblKeyTimes)
    {
        // get the segment we are in 
        if (dblProgress > 0)
        {
            //
            // ISSUE dilipk: should use binary search here (bug #14225, ie6)
            //

            // find the current segment
            for (int i = 1; i < m_numKeyTimes; i++)
            {
                if (dblProgress <= m_pdblKeyTimes[i])
                {
                    curSeg = i - 1;
                    break;
                }
            }

            // get the normalized linear progress in the segment
            curProgress = (dblProgress - m_pdblKeyTimes[curSeg]) / 
                          (m_pdblKeyTimes[curSeg + 1] - m_pdblKeyTimes[curSeg]);
        }
        else
        {
            curProgress = dblProgress;
        }

        // if necessary, apply bezier curve to progress
        if (    (m_IACalcMode == CALCMODE_SPLINE) 
            &&  (curSeg < m_numKeySplines))
        {
            curProgress = CalculateBezierProgress(m_pKeySplinePoints[curSeg], curProgress);
        }
    }
    else
    {
        // divvy up the time equally among segments

        // get the current segment and progress in that segment
        hr = THR(m_spPath->GetSegmentProgress(dblProgress, &curSeg, &curProgress));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // ask smil path object to interpolate this segment
    IGNORE_HR(m_spPath->InterpolateSegment(curSeg, curProgress, &newPos));

done:
    return newPos;
}


///////////////////////////////////////////////////////////////
//  Name: parsePair
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMEMotionAnimation::ParsePair(VARIANT val, POINTF *outPT)
{
    TraceTag((tagMotionAnimationTimeElm,
              "CTIMEMotionAnimation(%p)::parsePair()",
              this));
   
    HRESULT hr = E_FAIL;
    OLECHAR *sString = NULL;
    OLECHAR sTemp[INTERNET_MAX_URL_LENGTH];
    OLECHAR sTemp2[INTERNET_MAX_URL_LENGTH];
    CPtrAry<STRING_TOKEN*> aryTokens;
                   
    // need to parse out the top,left values.....
    if (val.vt != VT_BSTR)
    {
        hr = VariantChangeTypeEx(&val, &val, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            goto done;
        }   
    }

    sString = CopyString(val.bstrVal);
    if (sString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    hr = ::StringToTokens(sString, s_cPSTR_COMMA_SEPARATOR, &aryTokens);
    if (FAILED(hr) ||
        aryTokens.Size() != 2) // We must have a pair..
    {
        hr = E_FAIL;
        goto done;
    }

    if (   ((aryTokens.Item(0)->uLength + 1) >= INTERNET_MAX_URL_LENGTH)
        || ((aryTokens.Item(1)->uLength + 1) >= INTERNET_MAX_URL_LENGTH)
       )
    {
        hr = E_FAIL;
        goto done;
    }

    StrCpyNW(sTemp, sString+aryTokens.Item(0)->uIndex,aryTokens.Item(0)->uLength + 1);
    StrCpyNW(sTemp2,sString+aryTokens.Item(1)->uIndex,aryTokens.Item(1)->uLength + 1);

    {
        CComVariant tVar;
        tVar.vt      = VT_BSTR;
        tVar.bstrVal = SysAllocString(sTemp);
        if (!ConvertToPixels(&tVar))
        {
            hr = E_FAIL;
            goto done;
        }
        outPT->x = V_R8(&tVar);

        tVar.Clear();
        tVar.vt      = VT_BSTR;
        tVar.bstrVal = SysAllocString(sTemp2);
        if (!ConvertToPixels(&tVar))
        {
            hr = E_FAIL;
            goto done;
        }
        outPT->y = V_R8(&tVar);
    }

done:
    IGNORE_HR(::FreeStringTokenArray(&aryTokens));
    if (sString != NULL)
    {
        delete [] sString;
    }
        
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: GetCorrectLeftTopValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
float
CTIMEMotionAnimation::GetCorrectLeftTopValue(POINTF fPoint)
{
    if (m_bAnimatingLeft)
    {
        return fPoint.x;
    }

    return fPoint.y;
}

///////////////////////////////////////////////////////////////
//  Name: PutCorrectLeftTopValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::PutCorrectLeftTopValue(VARIANT pVar ,POINTF &fPointDest)
{
    if (!ConvertToPixels(&pVar))
    {
        goto done;
    }
       
    if (m_bAnimatingLeft)
    {
        fPointDest.x =  static_cast<float>(V_R8(&pVar));
    }
    else
    {
        fPointDest.y =  static_cast<float>(V_R8(&pVar));
    }
    
done:
    return;
}

void
CTIMEMotionAnimation::PutCorrectLeftTopValue(double val ,POINTF &fPointDest)
{     
    if (m_bAnimatingLeft)
    {
        fPointDest.x =  static_cast<float>(val);
    }
    else
    {
        fPointDest.y =  static_cast<float>(val);
    }
}

void
CTIMEMotionAnimation::PutCorrectLeftTopValue(POINTF fPointSrc ,POINTF &fPointDest)
{     
    if (m_bAnimatingLeft)
    {
        fPointDest.x =  fPointSrc.x;
    }
    else
    {
        fPointDest.y =  fPointSrc.y;
    }
}


void
CTIMEMotionAnimation::GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess)
{
    *pfDontPostProcess = false;

    ::VariantClear(pvarValue);
    V_VT(pvarValue) = VT_R8;
    V_R8(pvarValue) = 0.0;
    if (GetAutoReverse())
    {
        V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointLast);

        *pfDontPostProcess = true;
    }
    else
    {
        if (PATH == m_dataToUse)
        {
            // if this is endholding then return last point
            // else return the first point 

            //
            // Get the last point on the path
            //

            POINTF endPoint = {0.0, 0.0};

            if (m_spPath.p)
            {
                int numPoints = 0;

                IGNORE_HR(m_spPath->GetNumPoints(&numPoints));
                IGNORE_HR(m_spPath->GetPoint(numPoints-1, &endPoint));
            }
            else
            {
                Assert(false);
            }

            V_R8(pvarValue) = GetCorrectLeftTopValue(endPoint);
        }        
        else if (VALUES == m_dataToUse)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pPointValues[m_numValues-1]);
        }
        else if (TO == m_dataToUse)
        {
            V_R8(pvarValue) = GetCorrectLeftTopValue(m_pointTO);
        }
        else if (BY == m_dataToUse)
        {
            double dblFrom = 0;

            if (m_bFrom)
            {
                dblFrom = GetCorrectLeftTopValue(m_pointFROM);
            }

            V_R8(pvarValue) = dblFrom + GetCorrectLeftTopValue(m_pointBY);
        }
    }

done:
    return;

}


///////////////////////////////////////////////////////////////
//  Name: ValidateState, CTIMEAnimationBase
//
//  Abstract: Checks state of properties. Determines whether:
//              1. Animation should be disabled
//              2. CalcMode should be forced to "discrete"
//            
///////////////////////////////////////////////////////////////
void
CTIMEMotionAnimation::ValidateState()
{
    bool fIsValid = false;

    // validate base props
    CTIMEAnimationBase::ValidateState();

    // if base props are invalid then our state is invalid
    if (DisableAnimation())
    {
        goto done;
    }

    // Validate path
    if (PATH == m_dataToUse)
    {
        bool fCalcModeSpline = (CALCMODE_SPLINE == m_IACalcMode);
        bool fCalcModeLinear = (CALCMODE_LINEAR == m_IACalcMode);
        int  iNumSeg         = 0;
        bool fPathValid      = false;

        if (!m_spPath)
        {
            goto done;
        }

        IGNORE_HR(m_spPath->IsValid(&fPathValid));

        if (!fPathValid)
        {
            goto done;
        }

        IGNORE_HR(m_spPath->GetNumSeg(&iNumSeg));

        if (0 == iNumSeg)
        {
            goto done;
        }

        // validate keyTimes
        if (fCalcModeSpline || fCalcModeLinear)
        {
            // base class has already found keyTimes, keySplines and CalcModeSpline to be valid
            // so no need to check that here

            if (m_pdblKeyTimes)
            {
                // number of segments in keyTimes should equal
                // number of segments in path
                if (iNumSeg != (m_numKeyTimes - 1))
                {
                    goto done;
                }
            }
        }
    }

    fIsValid = true;
done:
    m_AnimPropState.fDisableAnimation = !(fIsValid);
} // ValidateState
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animfrag.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: animfrag.h
//
//  Contents: TIME Animation fragment helper class
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMFRAG_H
#define _ANIMFRAG_H

#include "animbase.h"

// The fragment is the helper class employed by the element as an 
// alternate dispatch implementation for communication between the 
// composer and the animation element.
class
ATL_NO_VTABLE
CAnimationFragment :
      public CComObjectRootEx<CComSingleThreadModel>,
      public ITIMEDispatchImpl<IAnimationFragment, &IID_IAnimationFragment>,
      public ISupportErrorInfoImpl<&IID_IAnimationFragment>
{

public:

    CAnimationFragment (void);
    virtual ~CAnimationFragment (void);

    DECLARE_NOT_AGGREGATABLE(CAnimationFragment)

    HRESULT SetFragmentSite (IAnimationFragmentSite *piFragmentSite);

    //
    // IAnimationFragment
    // 
    STDMETHOD(get_element) (IDispatch **ppidispAnimationElement);
    STDMETHOD(get_value) (BSTR bstrAttributeName, VARIANT varOriginal, VARIANT varCurrent, VARIANT *pvarValue);
    STDMETHOD(DetachFromComposer) (void);

    BEGIN_COM_MAP(CAnimationFragment)
        COM_INTERFACE_ENTRY(IAnimationFragment)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP();

private:
        
    CComPtr<IAnimationFragmentSite> m_spFragmentSite;

#if DBG
    const _TCHAR * GetName (void) { return __T("CAnimationFragment"); }
#endif

};

#endif /* _ANIMFRAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animfrag.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Fragment Implementation

*******************************************************************************/


#include "headers.h"
#include "animfrag.h"

DeclareTag(tagAnimationFragment, "SMIL Animation", "CAnimationFragment methods")

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::CAnimationFragment
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFragment::CAnimationFragment (void)
{
    TraceTag((tagAnimationFragment,
              "CAnimationFragment(%lx)::CAnimationFragment()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::~CAnimationFragment
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFragment::~CAnimationFragment (void)
{
    TraceTag((tagAnimationFragment,
              "CAnimationFragment(%lx)::~CAnimationFragment()",
              this));
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::SetFragmentSite
//
//  Overview:  sets a reference to the owning fragment site
//
//  Arguments: fragment site
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CAnimationFragment::SetFragmentSite (IAnimationFragmentSite *piFragmentSite)
{
    TraceTag((tagAnimationFragment,
              "CAnimationFragment(%lx)::SetFragmentSite(%lx)",
              this, piFragmentSite));

    HRESULT hr;

    m_spFragmentSite = piFragmentSite;

    hr = S_OK;
done :
    RRETURN(hr);
} // SetFragmentSite

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::get_value
//
//  Overview:  This is the query from the composer for the animated 
//             attribute's current value.
//
//  Arguments: animated attribute name, its original value, its current value
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFragment::get_value (BSTR bstrAttributeName, 
                               VARIANT varOriginal, VARIANT varCurrentValue,
                               VARIANT *pvarValue)
{
    HRESULT hr;

    if (m_spFragmentSite)
    {
        hr = m_spFragmentSite->NotifyOnGetValue(bstrAttributeName, 
                                                varOriginal, varCurrentValue, 
                                                pvarValue);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done : 
    RRETURN(hr);
} // get_value

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::DetachFromComposer
//
//  Overview:  This is the notification from the composer telling the fragment to 
//             detach itself.
//             
//  Arguments: None 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFragment::DetachFromComposer (void)
{
    HRESULT hr;

    if (m_spFragmentSite)
    {
        hr = m_spFragmentSite->NotifyOnDetachFromComposer();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done : 
    RRETURN(hr);
} // get_value

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFragment::get_element
//
//  Overview:  This is the query from the composer for the animated 
//             element's dispatch.
//             
//  Arguments: None 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFragment::get_element (IDispatch **ppidispAnimationElement)
{
    HRESULT hr;

    if (m_spFragmentSite)
    {
        hr = m_spFragmentSite->NotifyOnGetElement(ppidispAnimationElement);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done : 
    RRETURN(hr);
} // get_element
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animmotion.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\animmotion.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMMOTION_H
#define _ANIMMOTION_H

#include "animbase.h"
#include "smilpath.h"

//+-------------------------------------------------------------------------------------
//
// CTIMEMotionAnimation
//
//--------------------------------------------------------------------------------------

class CTIMEMotionAnimation : 
    public CComCoClass<CTIMEMotionAnimation, &CLSID_TIMEMotionAnimation>,
    public CTIMEAnimationBase
{

 public:

    CTIMEMotionAnimation();
    virtual ~CTIMEMotionAnimation();
   
    DECLARE_AGGREGATABLE(CTIMEMotionAnimation);
    DECLARE_REGISTRY(CLSID_TIMEMotionAnimation,
                     LIBID __T(".TIMEMotionAnimation.1"),
                     LIBID __T(".TIMEMotionAnimation"),
                     0,
                     THREADFLAGS_BOTH);
                     
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    // Overrides
    STDMETHOD(put_from)(VARIANT val);
    STDMETHOD(put_to)(VARIANT val);
    STDMETHOD(put_by)(VARIANT val);
    STDMETHOD(put_values)(VARIANT val);
    STDMETHOD(get_origin)(BSTR * val);
    STDMETHOD(put_origin)(BSTR val);
    STDMETHOD(get_path)(VARIANT * path);
    STDMETHOD(put_path)(VARIANT path);

    // Overrides to prevent get/put of invalid attributes
    STUB_INVALID_ATTRIBUTE(BSTR,attributeName)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

    //
    // IAnimationFragmentSite
    // 
    STDMETHOD(NotifyOnGetValue)(BSTR bstrAttributeName, 
                                VARIANT varOriginal, VARIANT varCurrent, 
                                VARIANT *pvarValue);
    STDMETHOD(NotifyOnDetachFromComposer) (void);

    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);

 protected :

    virtual HRESULT removeFromComposerSite (void);   
    virtual HRESULT addToComposerSite (IHTMLElement2 *pielemTarget);
    virtual HRESULT CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld);
    virtual void DetermineAdditiveEffect (void);
    virtual void ValidateState();
    virtual double GetAnimationRange();
    
 private:

    HRESULT calculateDiscreteValue (VARIANT *pvarValue);    
    HRESULT calculateLinearValue (VARIANT *pvarValue);      
    HRESULT calculateSplineValue (VARIANT *pvarValue);      
    HRESULT calculatePacedValue (VARIANT *pvarValue);      
    HRESULT QueryAttributeForTopLeft (LPCWSTR wzAttributeName);
    virtual void UpdateStartValue (VARIANT *pvarNewStartValue);
    virtual HRESULT DoFill (VARIANT *pvarValue);
    virtual void PostprocessValue (const VARIANT *pvarCurrent, VARIANT *pvarValue);

    void resetValue (VARIANT *pvarValue);

    virtual void SetInitialState (void);
    virtual void SetFinalState (void);

    virtual bool QueryNeedFirstUpdate (void)
        { return m_bAnimatingLeft?m_bNeedFirstLeftUpdate:m_bNeedFirstTopUpdate; }

    virtual bool QueryNeedFinalUpdate (void)
        { return m_bAnimatingLeft?m_bNeedFinalLeftUpdate:m_bNeedFinalTopUpdate; }
    virtual void OnFinalUpdate (const VARIANT *pvarCurrent, VARIANT *pvarValue);
    virtual void OnFirstUpdate (VARIANT *pvarValue);

    void CalculateTotalDistance();
    double CalculateDistance(POINTF a, POINTF b);

    // path stuff
    HRESULT SetSMILPath(CTIMEPath ** pPath, long numPath, long numMoveTo);
    POINTF InterpolatePath();
    POINTF InterpolatePathPaced();

    double CalculatePointDistance(POINTF p1, POINTF p2);
    HRESULT ParsePair(VARIANT val, POINTF *outPT);
    float GetCorrectLeftTopValue(POINTF fPoint);
    void  PutCorrectLeftTopValue(VARIANT pVar ,POINTF &fPointDest);
    void  PutCorrectLeftTopValue(double val ,POINTF &fPointDest);
    void  PutCorrectLeftTopValue(POINTF fPointSrc ,POINTF &fPointDest);
    void  GetFinalValue(VARIANT *pvarValue, bool * pfDontPostProcess);
    virtual void resetAnimate (void);
    virtual void endAnimate (void);
    virtual void UpdateCurrentBaseline (const VARIANT *pvarCurrent);

 private:

    bool m_bBy;
    bool m_bTo;
    bool m_bFrom;

    bool m_bNeedFirstLeftUpdate;
    bool m_bNeedFinalLeftUpdate;
    bool m_bNeedFirstTopUpdate;
    bool m_bNeedFinalTopUpdate;
    bool m_bLastSet;
    bool m_bNeedBaselineUpdate;

    POINTF m_pointTO;
    POINTF m_pointFROM;
    POINTF m_pointBY;
    POINTF m_pointLast;
    POINTF m_pointCurrentBaseline;
    POINTF m_ptOffsetParent;

    SplinePoints m_pSplinePoints;
    POINTF *m_pPointValues;
    
    bool m_bAnimatingLeft;

    CComVariant m_varLeftOrig;
    CComVariant m_varTopOrig;

    CComPtr<ISMILPath> m_spPath;

        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEMotionAnimation"); }
#endif

    
}; // CTIMEMotionAnimation

#endif /* _ANIMMOTION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animset.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\animset.h
//
//  Contents: TIME Animation behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ANIMSET_H
#define _ANIMSET_H

#include "animbase.h"


//+-------------------------------------------------------------------------------------
//
// CTIMESetAnimation
//
//--------------------------------------------------------------------------------------

class CTIMESetAnimation : 
    public CComCoClass<CTIMESetAnimation, &CLSID_TIMESetAnimation>,
    public CTIMEAnimationBase
{

public:
    CTIMESetAnimation();
    virtual ~CTIMESetAnimation();

    DECLARE_AGGREGATABLE(CTIMESetAnimation);
    DECLARE_REGISTRY(CLSID_TIMESetAnimation,
                     LIBID __T(".TIMESetAnimation.1"),
                     LIBID __T(".TIMESetAnimation"),
                     0,
                     THREADFLAGS_BOTH);
    
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);

    STDMETHOD(get_calcmode)(BSTR * calcmode);

    STUB_INVALID_ATTRIBUTE(BSTR, additive)
    STUB_INVALID_ATTRIBUTE(BSTR, accumulate)
    STUB_INVALID_ATTRIBUTE(VARIANT, by)
    STUB_INVALID_ATTRIBUTE(VARIANT, from)
    STUB_INVALID_ATTRIBUTE(BSTR, keySplines)
    STUB_INVALID_ATTRIBUTE(BSTR, keyTimes)
    STUB_INVALID_ATTRIBUTE(BSTR, origin)
    STUB_INVALID_ATTRIBUTE(BSTR, path)
    STUB_INVALID_ATTRIBUTE(BSTR, values)
    STUB_INVALID_ATTRIBUTE(BSTR, type)
    STUB_INVALID_ATTRIBUTE(BSTR, subType)
    STUB_INVALID_ATTRIBUTE(BSTR, mode)
    STUB_INVALID_ATTRIBUTE(BSTR, fadeColor)

protected:

    virtual HRESULT CanonicalizeValue (VARIANT *pvarValue, VARTYPE *pvtOld);
    virtual HRESULT UncanonicalizeValue (VARIANT *pvarValue, VARTYPE vtOld);

private:

    HRESULT calculateDiscreteValue(VARIANT *pvarValue);
    HRESULT calculateLinearValue(VARIANT *pvarValue);
    HRESULT calculateSplineValue(VARIANT *pvarValue);
    HRESULT calculatePacedValue(VARIANT *pvarValue);
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMESetAnimation"); }
#endif



}; // CTIMESetAnimation


#endif /* _ANIMSET_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animset.cpp ===
// *******************************************************************************
// *
// * Copyright (c) 1998 Microsoft Corporation
// *
// * File: animset.cpp
// *
// * Abstract: Simple animation of Elements
// *
// *
// *
// *******************************************************************************

#include "headers.h"
#include "animset.h"
#include "colorutil.h"


// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagSetElementValue, "MSTIME", "CTIMESetAnimation composition callbacks")

#define SUPER CTIMEAnimationBase

///////////////////////////////////////////////////////////////
//  Name: CTIMESetAnimation
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
CTIMESetAnimation::CTIMESetAnimation()
{
    
}


///////////////////////////////////////////////////////////////
//  Name: ~CTIMESetAnimation
//
//  Abstract:
//    cleanup
///////////////////////////////////////////////////////////////
CTIMESetAnimation::~CTIMESetAnimation()
{
    
} 


///////////////////////////////////////////////////////////////
//  Name: Init
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMESetAnimation::Init(IElementBehaviorSite * pBehaviorSite)
{
    HRESULT hr = S_OK;
   
    hr = THR(SUPER::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    
   
    // Set the Caclmode to discrete since that is all that set supports
    // Using InternalSet instead of '=', to prevent attribute from being persisted
    m_IACalcMode.InternalSet(CALCMODE_DISCRETE);
  
done:
    RRETURN(hr);
}


///////////////////////////////////////////////////////////////
//  Name: get_calcmode
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMESetAnimation::get_calcmode(BSTR * calcmode)
{
    HRESULT hr = S_OK;
    CHECK_RETURN_NULL(calcmode);

    *calcmode = SysAllocString(WZ_CALCMODE_DISCRETE);
    if (NULL == *calcmode)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculateDiscreteValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::calculateDiscreteValue(VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (m_varDOMTo.vt != VT_EMPTY)
    {
        CComVariant svarTo;

        hr = svarTo.Copy(&m_varDOMTo);
        if (FAILED(hr))
        {
            goto done;
        }

        // We need to make sure that the type to be set is the same
        // as the original value.
        hr = VariantChangeTypeEx(&svarTo, &svarTo, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, V_VT(&m_varBaseline));
        if (!FAILED(hr))
        {
            if (IsTargetVML())
            {
                // We are trying to set this on a VML target.  So, we are going to 
                // see if what we have is a BSTR and if so if it also matches a value in our colorTable
                // if it does mactch then we are going to use the #RRGGBB value instead.
                CComVariant varRRGGBB;
               
                hr = RGBStringColorLookup(&m_varTo, &varRRGGBB);     
                if (SUCCEEDED(hr))
                {
                     hr = svarTo.Copy(&varRRGGBB);
                }
            }
            hr = THR(::VariantCopy(pvarValue, &svarTo));
        }
#if DBG
        if (VT_BSTR == V_VT(pvarValue))
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is %ls",
                      this, m_SAAttribute, V_BSTR(pvarValue)));
        }
        else if (VT_R4 == V_VT(pvarValue))
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is %f",
                      this, m_SAAttribute, V_R4(pvarValue)));
        }
        else if (VT_R8 == V_VT(pvarValue))
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is %lf",
                      this, m_SAAttribute, V_R8(pvarValue)));
        }
        else 
        {
            TraceTag((tagSetElementValue,
                      "CTIMESetAnimation(%lx) setting value of %ls is variant of type %X",
                      this, m_SAAttribute, V_VT(pvarValue)));
        }
#endif

    
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: calculateLinearValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::calculateLinearValue(VARIANT *pvarValue)
{
    return CTIMESetAnimation::calculateDiscreteValue(pvarValue);
}

///////////////////////////////////////////////////////////////
//  Name: calculateSplineValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::calculateSplineValue(VARIANT *pvarValue)
{
    return CTIMESetAnimation::calculateDiscreteValue(pvarValue);   
}

///////////////////////////////////////////////////////////////
//  Name: calculatePacedValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
CTIMESetAnimation::calculatePacedValue(VARIANT *pvarValue)
{
    return CTIMESetAnimation::calculateDiscreteValue(pvarValue);
}

///////////////////////////////////////////////////////////////
//  Name: CanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::CanonicalizeValue (VARIANT *pvarOriginal, VARTYPE *pvtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // CanonicalizeValue

///////////////////////////////////////////////////////////////
//  Name: UncanonicalizeValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
CTIMESetAnimation::UncanonicalizeValue (VARIANT *pvarOriginal, VARTYPE vtOld)
{
    HRESULT hr;

    hr = S_OK;
done :
    RRETURN(hr);
} // UncanonicalizeValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\colorcomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Color Animation Composer.

*******************************************************************************/

#pragma once

#ifndef _COLORCOMP_H
#define _COLORCOMP_H

class __declspec(uuid("C6E2F3CE-B548-442d-9958-7C433C31B93B"))
ATL_NO_VTABLE CAnimationColorComposer
    : public CComCoClass<CAnimationColorComposer, &__uuidof(CAnimationColorComposer)>,
      public CAnimationComposerBase
{

  public:

    CAnimationColorComposer (void);
    virtual ~CAnimationColorComposer (void);

    DECLARE_NOT_AGGREGATABLE(CAnimationColorComposer)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationColorComposer"); }
#endif

    static HRESULT Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                           IAnimationComposer **ppiComp);

    // These methods convert the animated value from its native format
    // to the composed format and back again.  This allows us to animate
    // color out of gamut.
    STDMETHOD(PreprocessCompositionValue) (VARIANT *pvarValue);
    STDMETHOD(PostprocessCompositionValue) (VARIANT *pvarValue);

  protected :

};

#endif /* _COLORCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\colorcomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcolor.h"
#include "animcomp.h"
#include "colorcomp.h"

DeclareTag(tagAnimationColorComposer, "SMIL Animation", 
           "CAnimationColorComposer methods");

DeclareTag(tagAnimationColorComposerProcess, "SMIL Animation", 
           "CAnimationColorComposer pre/post process methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT 
CAnimationColorComposer::Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                                 IAnimationComposer **ppiComp)
{
    HRESULT hr;

    CComObject<CAnimationColorComposer> *pNew = NULL;
    hr = THR(CComObject<CAnimationColorComposer>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiComp)));
    if (FAILED(hr))
    {
        pNew->Release();
        hr = E_UNEXPECTED;
        goto done;
    }

    Assert(NULL != (*ppiComp));

    hr = (*ppiComp)->ComposerInit(pidispHostElem, bstrAttributeName);
    if (FAILED(hr))
    {
        (*ppiComp)->Release();
        *ppiComp = NULL;
        goto done;
    }

    hr = S_OK;
done :

    RRETURN3(hr, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationColorComposer::Create

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::CAnimationColorComposer
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationColorComposer::CAnimationColorComposer (void)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::CAnimationColorComposer()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::~CAnimationColorComposer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationColorComposer::~CAnimationColorComposer (void)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::~CAnimationColorComposer()",
              this));
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::PreprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationColorComposer::PreprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::PreprocessCompositionValue()",
              this));

    HRESULT hr;
    CComVariant varNew;

    if ((VT_ARRAY | VT_R8) == V_VT(pvarValue))
    {
        hr = S_OK;
        goto done;
    }

    if (VT_BSTR != V_VT(pvarValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // If there's no proper value, clear the empty
    // BSTR and don't try to convert it to a color definition.
    // This can happen when there is no initial value specified.
    if (!IsColorUninitialized(V_BSTR(pvarValue)))   
    {
        hr = THR(RGBVariantStringToRGBVariantVectorInPlace(pvarValue));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_bInitialComposition)
    {
        hr = THR(::VariantCopy(&m_VarInitValue, pvarValue));
        if (FAILED(hr))
        {
            goto done;
        } 
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // PreprocessCompositionValue

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationColorComposer::PostprocessCompositionValue
//
//  Overview:  Massage the target's native data into the composable format
//
//  Arguments: the in/out variant
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationColorComposer::PostprocessCompositionValue (VARIANT *pvarValue)
{
    TraceTag((tagAnimationColorComposer,
              "CAnimationColorComposer(%lx)::PostprocessCompositionValue()",
              this));

    HRESULT hr;
    CComVariant varNew;

    if (VT_BSTR == V_VT(pvarValue))
    {
        hr = S_OK;
        goto done;
    }

    hr = RGBVariantVectorToRGBVariantString (pvarValue, &varNew);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::VariantCopy(pvarValue, &varNew));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationColorComposerProcess,
              "CAnimationColorComposer(%lx)::PostprocessCompositionValue() value is %ls",
              this, V_BSTR(pvarValue)));

    hr = S_OK;
done :
    RRETURN(hr);
} // PostprocessCompositionValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\colorutil.cpp ===
// Colorutil.cpp
//

#include "headers.h"
#include "tokens.h"
#include "colorutil.h"

#define RGB_STRING_LENGTH           (7)
#define RGB_STRING_LENGTH2          (4)
#define MAX_COLOR_STRING_LENGTH     (0x10)

const double PERCEPTABLE_COLOR_ERROR = 0.001;

typedef struct _COLORVALUE_PAIR
{
    const WCHAR *wzName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { (L"aliceblue"),             0x01f0f8ff },
    { (L"antiquewhite"),          0x02faebd7 },
    { (L"aqua"),                  0x0300ffff },
    { (L"aquamarine"),            0x047fffd4 },
    { (L"azure"),                 0x05f0ffff },
    { (L"beige"),                 0x06f5f5dc },
    { (L"bisque"),                0x07ffe4c4 },
    { (L"black"),                 0x08000000 },
    { (L"blanchedalmond"),        0x09ffebcd },
    { (L"blue"),                  0x0a0000ff },
    { (L"blueviolet"),            0x0b8a2be2 },
    { (L"brown"),                 0x0ca52a2a },
    { (L"burlywood"),             0x0ddeb887 },
    { (L"cadetblue"),             0x0e5f9ea0 },
    { (L"chartreuse"),            0x0f7fff00 },
    { (L"chocolate"),             0x10d2691e },
    { (L"coral"),                 0x11ff7f50 },
    { (L"cornflowerblue"),        0x126495ed },
    { (L"cornsilk"),              0x13fff8dc },
    { (L"crimson"),               0x14dc143c },
    { (L"cyan"),                  0x1500ffff },
    { (L"darkblue"),              0x1600008b },
    { (L"darkcyan"),              0x17008b8b },
    { (L"darkgoldenrod"),         0x18b8860b },
    { (L"darkgray"),              0x19a9a9a9 },
    { (L"darkgreen"),             0x1a006400 },
    { (L"darkkhaki"),             0x1bbdb76b },
    { (L"darkmagenta"),           0x1c8b008b },
    { (L"darkolivegreen"),        0x1d556b2f },
    { (L"darkorange"),            0x1eff8c00 },
    { (L"darkorchid"),            0x1f9932cc },
    { (L"darkred"),               0x208b0000 },
    { (L"darksalmon"),            0x21e9967a },
    { (L"darkseagreen"),          0x228fbc8f },
    { (L"darkslateblue"),         0x23483d8b },
    { (L"darkslategray"),         0x242f4f4f },
    { (L"darkturquoise"),         0x2500ced1 },
    { (L"darkviolet"),            0x269400d3 },
    { (L"deeppink"),              0x27ff1493 },
    { (L"deepskyblue"),           0x2800bfff },
    { (L"dimgray"),               0x29696969 },
    { (L"dodgerblue"),            0x2a1e90ff },
    { (L"firebrick"),             0x2bb22222 },
    { (L"floralwhite"),           0x2cfffaf0 },
    { (L"forestgreen"),           0x2d228b22 },
    { (L"fuchsia"),               0x2eff00ff },
    { (L"gainsboro"),             0x2fdcdcdc },
    { (L"ghostwhite"),            0x30f8f8ff },
    { (L"gold"),                  0x31ffd700 },
    { (L"goldenrod"),             0x32daa520 },
    { (L"gray"),                  0x33808080 },
    { (L"green"),                 0x34008000 },
    { (L"greenyellow"),           0x35adff2f },
    { (L"honeydew"),              0x36f0fff0 },
    { (L"hotpink"),               0x37ff69b4 },
    { (L"indianred"),             0x38cd5c5c },
    { (L"indigo"),                0x394b0082 },
    { (L"ivory"),                 0x3afffff0 },
    { (L"khaki"),                 0x3bf0e68c },
    { (L"lavender"),              0x3ce6e6fa },
    { (L"lavenderblush"),         0x3dfff0f5 },
    { (L"lawngreen"),             0x3e7cfc00 },
    { (L"lemonchiffon"),          0x3ffffacd },
    { (L"lightblue"),             0x40add8e6 },
    { (L"lightcoral"),            0x41f08080 },
    { (L"lightcyan"),             0x42e0ffff },
    { (L"lightgoldenrodyellow"),  0x43fafad2 },
    { (L"lightgreen"),            0x4490ee90 },
    { (L"lightgrey"),             0x45d3d3d3 },
    { (L"lightpink"),             0x46ffb6c1 },
    { (L"lightsalmon"),           0x47ffa07a },
    { (L"lightseagreen"),         0x4820b2aa },
    { (L"lightskyblue"),          0x4987cefa },
    { (L"lightslategray"),        0x4a778899 },
    { (L"lightsteelblue"),        0x4bb0c4de },
    { (L"lightyellow"),           0x4cffffe0 },
    { (L"lime"),                  0x4d00ff00 },
    { (L"limegreen"),             0x4e32cd32 },
    { (L"linen"),                 0x4ffaf0e6 },
    { (L"magenta"),               0x50ff00ff },
    { (L"maroon"),                0x51800000 },
    { (L"mediumaquamarine"),      0x5266cdaa },
    { (L"mediumblue"),            0x530000cd },
    { (L"mediumorchid"),          0x54ba55d3 },
    { (L"mediumpurple"),          0x559370db },
    { (L"mediumseagreen"),        0x563cb371 },
    { (L"mediumslateblue"),       0x577b68ee },
    { (L"mediumspringgreen"),     0x5800fa9a },
    { (L"mediumturquoise"),       0x5948d1cc },
    { (L"mediumvioletred"),       0x5ac71585 },
    { (L"midnightblue"),          0x5b191970 },
    { (L"mintcream"),             0x5cf5fffa },
    { (L"mistyrose"),             0x5dffe4e1 },
    { (L"moccasin"),              0x5effe4b5 },
    { (L"navajowhite"),           0x5fffdead },
    { (L"navy"),                  0x60000080 },
    { (L"oldlace"),               0x61fdf5e6 },
    { (L"olive"),                 0x62808000 },
    { (L"olivedrab"),             0x636b8e23 },
    { (L"orange"),                0x64ffa500 },
    { (L"orangered"),             0x65ff4500 },
    { (L"orchid"),                0x66da70d6 },
    { (L"palegoldenrod"),         0x67eee8aa },
    { (L"palegreen"),             0x6898fb98 },
    { (L"paleturquoise"),         0x69afeeee },
    { (L"palevioletred"),         0x6adb7093 },
    { (L"papayawhip"),            0x6bffefd5 },
    { (L"peachpuff"),             0x6cffdab9 },
    { (L"peru"),                  0x6dcd853f },
    { (L"pink"),                  0x6effc0cb },
    { (L"plum"),                  0x6fdda0dd },
    { (L"powderblue"),            0x70b0e0e6 },
    { (L"purple"),                0x71800080 },
    { (L"red"),                   0x72ff0000 },
    { (L"rosybrown"),             0x73bc8f8f },
    { (L"royalblue"),             0x744169e1 },
    { (L"saddlebrown"),           0x758b4513 },
    { (L"salmon"),                0x76fa8072 },
    { (L"sandybrown"),            0x77f4a460 },
    { (L"seagreen"),              0x782e8b57 },
    { (L"seashell"),              0x79fff5ee },
    { (L"sienna"),                0x7aa0522d },
    { (L"silver"),                0x7bc0c0c0 },
    { (L"skyblue"),               0x7c87ceeb },
    { (L"slateblue"),             0x7d6a5acd },
    { (L"slategray"),             0x7e708090 },
    { (L"snow"),                  0x7ffffafa },
    { (L"springgreen"),           0x8000ff7f },
    { (L"steelblue"),             0x814682b4 },
    { (L"tan"),                   0x82d2b48c },
    { (L"teal"),                  0x83008080 },
    { (L"thistle"),               0x84d8bfd8 },
    { (L"tomato"),                0x85ff6347 },
    { (L"turquoise"),             0x8640e0d0 },
    { (L"violet"),                0x87ee82ee },
    { (L"wheat"),                 0x88f5deb3 },
    { (L"white"),                 0x89ffffff },
    { (L"whitesmoke"),            0x8af5f5f5 },
    { (L"yellow"),                0x8bffff00 },
    { (L"yellowgreen"),           0x8c9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))

///////////////////////////////////////////////////////////////
//  Name: CompareColorValuePairs
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
static int __cdecl
CompareColorValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((COLORVALUE_PAIR*)pv1)->wzName,
                    ((COLORVALUE_PAIR*)pv2)->wzName);
} 

///////////////////////////////////////////////////////////////
//  Name: GetDWORDColorFromString
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
DWORD
GetDWORDColorFromString (LPCWSTR wzColorValue)
{
    DWORD dwRet;
    WCHAR wzTempColorValue[RGB_STRING_LENGTH + 1] = {0};
    if (0 == lstrlenW(wzColorValue))
        return PROPERTY_INVALIDCOLOR;

    // first check if this string is possibly a color by name
    // by checking the first character for '#'
    if (wzColorValue[0] != L'#')
    {
        // check if it is a string named color
        COLORVALUE_PAIR ColorName;
        ColorName.wzName = wzColorValue;

        COLORVALUE_PAIR * pColorPair = (COLORVALUE_PAIR*)bsearch(&ColorName,
                                              rgColorNames,
                                              SIZE_OF_COLOR_TABLE,
                                              sizeof(COLORVALUE_PAIR),
                                              CompareColorValuePairsByName);

        if (NULL == pColorPair)
            return PROPERTY_INVALIDCOLOR;
        else
            return pColorPair->dwValue;
    }
    if (lstrlenW(wzColorValue) != RGB_STRING_LENGTH)
    {
        if (lstrlenW(wzColorValue) != RGB_STRING_LENGTH2) //this is the case of #xyz format which needs to become #xyz
        {
            return PROPERTY_INVALIDCOLOR;
        }
        else
        {
            wzTempColorValue[0] = wzColorValue[0];
            for (int i = 1; i < RGB_STRING_LENGTH2; i++)
            {
                wzTempColorValue[i * 2 - 1] = wzColorValue[i];
                wzTempColorValue[i * 2] = wzColorValue[i];
            }
        }
    }
    else
    {
        memcpy(wzTempColorValue, wzColorValue, sizeof(WCHAR) * RGB_STRING_LENGTH);
    }

    dwRet = 0;
    for (int i = 1; i < RGB_STRING_LENGTH; i++)
    {
        // shift dwRet by 4
        dwRet <<= 4;
        // and add in the value of this string
        switch (wzTempColorValue[i])
        {
        case '0':
            dwRet +=  0;
            break;
        case '1':
            dwRet +=  1;
            break;
        case '2':
            dwRet +=  2;
            break;
        case '3':
            dwRet +=  3;
            break;
        case '4':
            dwRet +=  4;
            break;
        case '5':
            dwRet +=  5;
            break;
        case '6':
            dwRet +=  6;
            break;
        case '7':
            dwRet +=  7;
            break;
        case '8':
            dwRet +=  8;
            break;
        case '9':
            dwRet +=  9;
            break;
        case 'a':
        case 'A':
            dwRet += 10;
            break;
        case 'b':
        case 'B':
            dwRet += 11;
            break;
        case 'c':
        case 'C':
            dwRet += 12;
            break;
        case 'd':
        case 'D':
            dwRet += 13;
            break;
        case 'e':
        case 'E':
            dwRet += 14;
            break;
        case 'f':
        case 'F':
            dwRet += 15;
            break;
        default:
            return PROPERTY_INVALIDCOLOR;
        }
    }
    return dwRet;
} // GetDWORDColorFromString

///////////////////////////////////////////////////////////////
//  Name: RGBStringToRGBValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT
RGBStringToRGBValue (LPCWSTR wzColorValue, rgbColorValue *prgbValue)
{
    HRESULT hr;
    LPWSTR wzTrimmedColorValue = TrimCopyString(wzColorValue);

    if (NULL != wzTrimmedColorValue)
    {
        DWORD dwColorTo = GetDWORDColorFromString (wzTrimmedColorValue);

        delete [] wzTrimmedColorValue;

        if (dwColorTo == PROPERTY_INVALIDCOLOR)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        prgbValue->red = ((double)((dwColorTo & 0x00FF0000) >> 16)) / 255.0f;
        prgbValue->red = Clamp(0.0, prgbValue->red, 1.0);
        prgbValue->green = ((double)((dwColorTo & 0x0000FF00) >> 8)) / 255.0f;
        prgbValue->green = Clamp(0.0, prgbValue->green, 1.0);
        prgbValue->blue = ((double)(dwColorTo & 0x000000FF)) / 255.0f;
        prgbValue->blue = Clamp(0.0, prgbValue->blue, 1.0);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, E_INVALIDARG);
} // RGBStringToRGBValue


///////////////////////////////////////////////////////////////
//  Name: DWORDToRGB
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
void
DWORDToRGB (const DWORD dwColorTo, rgbColorValue *prgbValue)
{  
    prgbValue->red = ((double)((dwColorTo & 0x00FF0000) >> 16)) / 255.0f;
    prgbValue->red = Clamp(0.0, prgbValue->red, 1.0);
    prgbValue->green = ((double)((dwColorTo & 0x0000FF00) >> 8)) / 255.0f;
    prgbValue->green = Clamp(0.0, prgbValue->green, 1.0);
    prgbValue->blue = ((double)(dwColorTo & 0x000000FF)) / 255.0f;
    prgbValue->blue = Clamp(0.0, prgbValue->blue, 1.0);

} // DWORDToRGB


///////////////////////////////////////////////////////////////
//  Name: RGBValueToRGBVariantVector
//
//  Abstract: Push a color value specified in a rgbColorValue struct
//            into a SAFEARRAY with the double values {red, green, blue}
//    
///////////////////////////////////////////////////////////////
HRESULT
RGBValueToRGBVariantVector (const rgbColorValue *prgbValue, VARIANT *pvarValue)
{
    HRESULT hr;

    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }    

    {
        SAFEARRAY *psa = V_ARRAY(pvarValue);
        double rgdblValues[3];
        LPVOID pData = NULL;

        if (NULL == psa)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        hr = THR(::SafeArrayAccessData(psa, &pData));
        if (FAILED(hr))
        {
            goto done;
        }

        rgdblValues[0] = prgbValue->red;
        rgdblValues[1] = prgbValue->green;
        rgdblValues[2] = prgbValue->blue;
        memcpy(pData, rgdblValues, 3 * sizeof(double));

        hr = THR(::SafeArrayUnaccessData(psa));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBValueToRGBVariantVector

///////////////////////////////////////////////////////////////
//  Name: RGBStringToRGBVariantVector
//
//  Abstract: Push a color value specified in a string of the form #rrggbb
//            into a SAFEARRAY with the double values {red, green, blue}
//    
///////////////////////////////////////////////////////////////
HRESULT
RGBStringToRGBVariantVector (LPCWSTR wzColorValue, VARIANT *pvarValue)
{
    HRESULT hr;
    rgbColorValue rgbValue;

    if ((NULL == wzColorValue) ||
        (!(VT_ARRAY & V_VT(pvarValue))) 
       )
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = RGBStringToRGBValue (wzColorValue, &rgbValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = RGBValueToRGBVariantVector (&rgbValue, pvarValue);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBStringToRGBVariantVector

///////////////////////////////////////////////////////////////
//  Name: CreateInitialRGBVariantVector
//
//  Abstract: Create a safearray with space for a color value
//            in this variant
//    
///////////////////////////////////////////////////////////////
HRESULT 
CreateInitialRGBVariantVector(VARIANT *pvarValue)
{
    HRESULT hr;

    if (NULL == pvarValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(::VariantClear(pvarValue));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        SAFEARRAY *psa = ::SafeArrayCreateVector(VT_R8, 0, 3);

        if (NULL == psa)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        V_VT(pvarValue) = VT_R8 | VT_ARRAY;
        V_ARRAY(pvarValue) = psa;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CreateInitialRGBVariantVector

///////////////////////////////////////////////////////////////
//  Name: RGBVariantStringToRGBVariantVectorInPlace
//
//  Abstract: Convert a variant with an RGB string into 
//            one containing the RGB values in a safearray.
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBVariantStringToRGBVariantVectorInPlace (VARIANT *pvarValue)
{
    HRESULT hr;

    if ((NULL == pvarValue) || (VT_BSTR != V_VT(pvarValue)) ||
        (NULL == V_BSTR(pvarValue)))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    {
        CComVariant varNew;

        hr = CreateInitialRGBVariantVector(&varNew);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = RGBStringToRGBVariantVector(V_BSTR(pvarValue), &varNew);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(::VariantCopy(pvarValue, &varNew));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBVariantStringToRGBVariantVectorInPlace


///////////////////////////////////////////////////////////////
//  Name: RGBVariantVectorToRGBValue
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBVariantVectorToRGBValue (const VARIANT *pvarValue, rgbColorValue *prgbValue)
{
    HRESULT hr;

    Assert(NULL != pvarValue);
    Assert(NULL != prgbValue);

    if ((VT_ARRAY | VT_R8) != V_VT(pvarValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    {
        SAFEARRAY *psa = V_ARRAY(pvarValue);
        double *pdblValues = NULL;
        LPVOID pData = NULL;

        if (NULL == psa)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        hr = THR(::SafeArrayAccessData(psa, &pData));
        if (FAILED(hr))
        {
            goto done;
        }

        pdblValues = static_cast<double *>(pData);

        prgbValue->red   = pdblValues[0];
        prgbValue->green = pdblValues[1]; 
        prgbValue->blue  = pdblValues[2];
        
        hr = THR(::SafeArrayUnaccessData(psa));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBVariantVectorToRGBValue

///////////////////////////////////////////////////////////////
//  Name: RGBVariantVectorToRGBVariantString
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBVariantVectorToRGBVariantString (const VARIANT *pvarArray, VARIANT *pvarRGBString)
{
    HRESULT hr;
    rgbColorValue rgbValue;

    USES_CONVERSION; //lint !e522

    hr = RGBVariantVectorToRGBValue(pvarArray, &rgbValue);
    if (FAILED(hr))
    {
        goto done;
    }

    rgbValue.red = Clamp(0.0, rgbValue.red, 1.0);
    rgbValue.green = Clamp(0.0, rgbValue.green, 1.0);
    rgbValue.blue = Clamp(0.0, rgbValue.blue, 1.0);

    {
        CComVariant varNew;

        // NOTE:
        // We are switching the R & B in the below RGB() for a reason!!
        // We need to construct the value this way inorder for IE to understand
        // and display the correct value.
        DWORD dwColor = RGB(rgbValue.blue*NUM_RGB_COLORS, 
                            rgbValue.green*NUM_RGB_COLORS, 
                            rgbValue.red*NUM_RGB_COLORS);
        char szColor[MAX_COLOR_STRING_LENGTH];

        wsprintfA(szColor, "#%06x", dwColor);
        V_VT(&varNew) = VT_BSTR;
        V_BSTR(&varNew) = ::SysAllocString(A2OLE(szColor));
        hr = THR(::VariantCopy(pvarRGBString, &varNew));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBVariantVectorToRGBVariantString

///////////////////////////////////////////////////////////////
//  Name: RGBStringColorLookup
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
HRESULT 
RGBStringColorLookup(const VARIANT *pvarString, VARIANT *pvarRGBString)
{
    HRESULT hr;
    DWORD dwColor;

    USES_CONVERSION; //lint !e522

    if (pvarString->vt != VT_BSTR)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    dwColor = GetDWORDColorFromString (pvarString->bstrVal);

    if (dwColor == PROPERTY_INVALIDCOLOR)
    {
        hr = E_INVALIDARG;
        goto done;
    }
   
    {
        CComVariant varNew;
        // NOTE:
        // We are switching the R & B in the below RGB() for a reason!!
        // We need to construct the value this way inorder for IE to understand
        // and display the correct value.
   
        char szColor[MAX_COLOR_STRING_LENGTH];

        wsprintfA(szColor, "#%06x", dwColor);
        V_VT(&varNew) = VT_BSTR;
        V_BSTR(&varNew) = ::SysAllocString(A2OLE(szColor));
        hr = THR(::VariantCopy(pvarRGBString, &varNew));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // RGBStringColorLookup


///////////////////////////////////////////////////////////////
//  Name: IsColorUninitialized
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool 
IsColorUninitialized (LPCWSTR wzColorValue)
{
    return (   (NULL == wzColorValue)
            || (0 == lstrlenW(wzColorValue))
            || (0 == StrCmpIW(wzColorValue, WZ_TRANSPARENT))
           );
} // IsColorUninitialized

///////////////////////////////////////////////////////////////
//  Name: EnsureVariantVectorFormat
//
//  Abstract: Ensure that we're using the 
//            variant color vector format.
//    
///////////////////////////////////////////////////////////////
HRESULT
EnsureVariantVectorFormat (VARIANT *pvarVector)
{
    HRESULT hr = S_OK;

    if (VT_BSTR == V_VT(pvarVector))
    {
        hr = RGBVariantStringToRGBVariantVectorInPlace(pvarVector);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    if ((VT_R8 | VT_ARRAY) != V_VT(pvarVector))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // EnsureVariantVectorFormat

///////////////////////////////////////////////////////////////
//  Name: IsColorVariantVectorEqual
//
//  Abstract: Are the vectors in the two variants the same?
//    
///////////////////////////////////////////////////////////////
bool
IsColorVariantVectorEqual (const VARIANT *pvarLeft, const VARIANT *pvarRight)
{
    const double dblError = PERCEPTABLE_COLOR_ERROR;
    rgbColorValue rgbLeft;
    rgbColorValue rgbRight;
    bool bRet = false;
    HRESULT hr = THR(RGBVariantVectorToRGBValue(pvarLeft, &rgbLeft));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(RGBVariantVectorToRGBValue(pvarRight, &rgbRight));
    if (FAILED(hr))
    {
        goto done;
    }

    // Allow for imperceptible error in the 
    // comparison
    if (   (dblError > fabs(rgbLeft.red -   rgbRight.red) )
        && (dblError > fabs(rgbLeft.green - rgbRight.green) )
        && (dblError > fabs(rgbLeft.blue -  rgbRight.blue) ) )
    {
        bRet = true;
    }

done:
    return bRet;
} // IsColorVariantVectorEqual
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\animutil.h ===
static const LPWSTR PX   = L"px";

#define HORIZ   true
#define VERT    false

typedef struct _VALUE_PAIR
{
    const WCHAR *wzName;
    bool         bValue;
} VALUE_PAIR;

// The info in the VALUE_PAIR is runtime-property and then either a vertical or horizontal depending on the 
// typeof attribute it is.

const VALUE_PAIR 
rgPropOr[] =
{
    { (L"backgroundPositionX"),     HORIZ  },
    { (L"backgroundPositionY"),     VERT   },
    { (L"borderBottomWidth"),       VERT   },
    { (L"borderLeftWidth"),         HORIZ  },
    { (L"borderRightWidth"),        HORIZ  },
    { (L"borderTopWidth"),          VERT   },
    { (L"bottom"),                  VERT   },
    { (L"height"),                  VERT   },
    { (L"left"),                    HORIZ  },
    { (L"top"),                     VERT   },
    { (L"letterSpacing"),           HORIZ  },
    { (L"lineHeight"),              VERT   },
    { (L"marginBottom"),            VERT   },
    { (L"marginLeft"),              HORIZ  },
    { (L"marginRight"),             HORIZ  },
    { (L"marginTop"),               VERT   },
    { (L"overflowX"),               HORIZ  },
    { (L"overflowY"),               VERT   },
    { (L"pixelBottom"),             VERT   },
    { (L"pixelHeight"),             VERT   },
    { (L"pixelLeft"),               HORIZ  },
    { (L"pixelRight"),              HORIZ  },
    { (L"pixelTop"),                VERT   },
    { (L"pixelWidth"),              HORIZ  },
    { (L"posBottom"),               VERT   },
    { (L"posHeight"),               VERT   },
    { (L"posLeft"),                 HORIZ  },
    { (L"posRight"),                HORIZ  },
    { (L"posTop"),                  VERT   },
    { (L"posWidth"),                HORIZ  },
    { (L"right"),                   HORIZ  },
    { (L"textIndent"),              HORIZ  },
    { (L"width"),                   HORIZ  }
}; // rgPropOr[]

#define SIZE_OF_VALUE_TABLE (sizeof(rgPropOr) / sizeof(VALUE_PAIR))


typedef struct _CONVERSION_PAIR
{
    WCHAR  *wzName;
    double  dValue;
} CONVERSION_PAIR;


const CONVERSION_PAIR 
rgPixelConv[] =
{
    // type , convertion to inches
    { (L"in"),   1.00  },
    { (L"cm"),   2.54  },
    { (L"mm"),  25.40  },
    { (L"pt"),  72.00  },
    { (L"pc"),   6.00  }
}; // 

#define SIZE_OF_CONVERSION_TABLE (sizeof(rgPixelConv) / sizeof(CONVERSION_PAIR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\compfact.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Factory Implementation

*******************************************************************************/


#include "headers.h"
#include "tokens.h"
#include "compfact.h"
#include "animcomp.h"
#include "colorcomp.h"
#include "filtercomp.h"
#include "defcomp.h"

DeclareTag(tagAnimationComposerFactory, "SMIL Animation", 
           "CAnimationComposerFactory methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CAnimationComposerFactory
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerFactory::CAnimationComposerFactory (void)
{
} // CAnimationComposerFactory::CAnimationComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::~CAnimationComposerFactory
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerFactory::~CAnimationComposerFactory (void)
{
} // CAnimationComposerFactory::~CAnimationComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CreateColorComposer
//
//  Overview:  Build the color composer
//
//  Arguments: out param for the composer
//
//  Returns:   S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerFactory::CreateColorComposer (IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory::CreateColorComposer()"));

    HRESULT hr;

    CComObject<CAnimationColorComposer> *pNew;
    CComObject<CAnimationColorComposer>::CreateInstance(&pNew);

    if (NULL == pNew)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiAnimationComposer)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CreateColorComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CreateTransitionComposer
//
//  Overview:  Build the transition composer
//
//  Arguments: out param for the composer
//
//  Returns:   S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerFactory::CreateTransitionComposer (IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory::CreateTransitionComposer()"));

    HRESULT hr;

    CComObject<CAnimationFilterComposer> *pNew;
    CComObject<CAnimationFilterComposer>::CreateInstance(&pNew);

    if (NULL == pNew)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiAnimationComposer)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CreateColorComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::CreateDefaultComposer
//
//  Overview:  Build the default composer
//
//  Arguments: out param for the composer
//
//  Returns:   S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposerFactory::CreateDefaultComposer (IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory(%lx)::CreateDefaultComposer()"));

    HRESULT hr;

    CComObject<CAnimationComposer> *pNew;
    CComObject<CAnimationComposer>::CreateInstance(&pNew);

    if (NULL == pNew)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiAnimationComposer)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CreateDefaultComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerFactory::FindComposer
//
//  Overview:  Build the default composer
//
//  Arguments: the name of attribute that the composer will animate, out param for the composer
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerFactory::FindComposer (IDispatch *pidispElement, BSTR bstrAttributeName, 
                                         IAnimationComposer **ppiAnimationComposer)
{
    TraceTag((tagAnimationComposerFactory,
              "CAnimationComposerFactory(%lx)::FindComposer()",
              this));

    HRESULT hr;

    if ((NULL == pidispElement) || (NULL == bstrAttributeName) || 
        (NULL == ppiAnimationComposer))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // Sniff the fragment element's tag name for the proper composer.
    {
        CComPtr<IHTMLElement> spElem;
        CComBSTR bstrTag;

        hr = THR(pidispElement->QueryInterface(IID_TO_PPV(IHTMLElement, &spElem)));
        if (FAILED(hr))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        hr = THR(spElem->get_tagName(&bstrTag));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (0 == StrCmpIW(bstrTag, WZ_COLORANIM))
        {
            hr = CAnimationComposerFactory::CreateColorComposer(ppiAnimationComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else if (0 == StrCmpIW(bstrTag, WZ_TRANSITIONFILTER))
        {
            hr = CAnimationComposerFactory::CreateTransitionComposer(ppiAnimationComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            hr = CAnimationComposerFactory::CreateDefaultComposer(ppiAnimationComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE);
} // CAnimationComposerFactory::FindComposer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\compfact.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Default Animation Composer Factory.

*******************************************************************************/

#pragma once

#ifndef _COMPFACTORY_H
#define _COMPFACTORY_H

interface IAnimationComposer;

class __declspec(uuid("E9B48B62-53EA-4ab7-BD2C-8105D1C0624F"))
ATL_NO_VTABLE CAnimationComposerFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CAnimationComposerFactory, &CLSID_AnimationComposerFactory>,
      public IAnimationComposerFactory,
      public ISupportErrorInfoImpl<&IID_IAnimationComposerFactory>
{
  public:
    CAnimationComposerFactory();
    virtual ~CAnimationComposerFactory();

    DECLARE_NOT_AGGREGATABLE(CAnimationComposerFactory)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposerFactory"); }
#endif

    // IAnimationComposerFactory   
    STDMETHOD(FindComposer)(IDispatch *pidispElement, BSTR bstrAttributeName, 
                            IAnimationComposer **ppiAnimationComposer); 

    DECLARE_REGISTRY(CLSID_AnimationComposerFactory,
                     LIBID __T(".SMILAnimDefaultCompFactory.1"),
                     LIBID __T(".SMILAnimDefaultCompFactory"),
                     0,
                     THREADFLAGS_BOTH);    

    BEGIN_COM_MAP(CAnimationComposerFactory)
        COM_INTERFACE_ENTRY(IAnimationComposerFactory)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    static HRESULT CreateColorComposer   (IAnimationComposer **ppiAnimationComposer);
    static HRESULT CreateTransitionComposer   (IAnimationComposer **ppiAnimationComposer);
    static HRESULT CreateDefaultComposer (IAnimationComposer **ppiAnimationComposer);

  protected:

};

#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\colorutil.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: colorutil.h
//
//  Contents: Color conversion utilities
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _COLORUTIL__H
#define _COLORUTIL__H

#define PROPERTY_INVALIDCOLOR   (0x99999999)
#define NUM_RGB_COLORS          (255)

struct rgbColorValue
{
    double red;
    double green;
    double blue;
};

HRESULT CreateInitialRGBVariantVector(VARIANT *pvarValue);
HRESULT RGBVariantStringToRGBVariantVectorInPlace (VARIANT *pvarValue);
HRESULT RGBStringToRGBVariantVector (LPCWSTR wzColorValue, VARIANT *pvarValue);
HRESULT RGBStringToRGBValue (LPCWSTR wzColorValue, rgbColorValue *prgbValue);
HRESULT RGBValueToRGBVariantVector (const rgbColorValue *prgbValue, VARIANT *pvarValue);
HRESULT RGBVariantVectorToRGBValue (const VARIANT *pvarValue, rgbColorValue *prgbValue);
HRESULT RGBVariantVectorToRGBVariantString (const VARIANT *pvarArray, VARIANT *pvarRGBString);
HRESULT RGBStringColorLookup(const VARIANT *pvarString, VARIANT *pvarRGBString);
HRESULT EnsureVariantVectorFormat (VARIANT *pvarVector);
void DWORDToRGB (const DWORD dwColorTo, rgbColorValue *prgbValue);
bool IsColorVariantVectorEqual (const VARIANT *pvarLeft, const VARIANT *pvarRight);
bool IsColorUninitialized (LPCWSTR wzColorValue);

#endif // _COLORUTIL__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\defcomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Default Animation Composer.

*******************************************************************************/

#pragma once

#ifndef _DEFCOMP_H
#define _DEFCOMP_H

class __declspec(uuid("5FAD79F0-D40C-4df3-B334-7292FE80E664"))
ATL_NO_VTABLE CAnimationComposer
    : public CComCoClass<CAnimationComposer, &__uuidof(CAnimationComposer)>,
      public CAnimationComposerBase
{

  public:

    CAnimationComposer (void);
    virtual ~CAnimationComposer (void);

    DECLARE_NOT_AGGREGATABLE(CAnimationComposer)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposer"); }
#endif

    static HRESULT Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                           IAnimationComposer **ppiComp);

  protected :

};

#endif /* _DEFCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\defcomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "animcomp.h"
#include "defcomp.h"

DeclareTag(tagAnimationDefaultComposer, "SMIL Animation", 
           "CAnimationComposer methods");

DeclareTag(tagAnimationDefaultComposerProcess, "SMIL Animation", 
           "CAnimationComposer pre/post process methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposer::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT 
CAnimationComposer::Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                            IAnimationComposer **ppiComp)
{
    HRESULT hr;

    CComObject<CAnimationComposer> *pNew = NULL;
    hr = THR(CComObject<CAnimationComposer>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiComp)));
    if (FAILED(hr))
    {
        pNew->Release();
        hr = E_UNEXPECTED;
        goto done;
    }

    Assert(NULL != (*ppiComp));

    hr = (*ppiComp)->ComposerInit(pidispHostElem, bstrAttributeName);
    if (FAILED(hr))
    {
        (*ppiComp)->Release();
        *ppiComp = NULL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposer::Create

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposer::CAnimationComposer
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposer::CAnimationComposer (void)
{
    TraceTag((tagAnimationDefaultComposer,
              "CAnimationComposer(%lx)::CAnimationComposer()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposer::~CAnimationComposer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposer::~CAnimationComposer (void)
{
    TraceTag((tagAnimationDefaultComposer,
              "CAnimationComposer(%lx)::~CAnimationComposer()",
              this));
} //dtor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\compsite.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: compsite.h
//
//  Contents: Animation Composer Site object
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _COMPSITE_H
#define _COMPSITE_H

/////////////////////////////////////////////////////////////////////////////
// CAnimationComposerSite

typedef std::list<IAnimationComposer*> ComposerList;
typedef std::list<VARIANT *> ComposerFactoryList;

class CBaseBvr;

class __declspec(uuid("27982921-8CF2-49cc-9A1B-F41F5C11A607"))
ATL_NO_VTABLE CAnimationComposerSite : 
    public CBaseBvr,
    public CComCoClass<CAnimationComposerSite, &__uuidof(CAnimationComposerSite)>,
    public ITIMEDispatchImpl<IAnimationComposerSite, &IID_IAnimationComposerSite>,
    public ISupportErrorInfoImpl<&IID_IAnimationComposerSite>,
    public IAnimationComposerSiteSink
{
  
  public :

    CAnimationComposerSite (void);
    virtual ~CAnimationComposerSite (void);

    //
    // IElementBehavior
    //
    STDMETHOD(Init) (IElementBehaviorSite *piBvrSite);
    STDMETHOD(Detach) (void);

    //
    // IAnimationComposerSite
    //
    STDMETHOD(AddFragment) (BSTR bstrAttributeName, IDispatch *pidispFragment);
    STDMETHOD(RemoveFragment) (BSTR bstrAttributeName, IDispatch *pidispFragment);
    STDMETHOD(InsertFragment) (BSTR bstrAttributeName, IDispatch *pidispFragment, VARIANT varIndex);
    STDMETHOD(EnumerateFragments) (BSTR bstrAttributeName, IEnumVARIANT **ppienumFragments);
    STDMETHOD(RegisterComposerFactory) (VARIANT *varFactory);
    STDMETHOD(UnregisterComposerFactory) (VARIANT *varFactory);   

    //
    // IAnimationComposerSiteSink
    //
    STDMETHOD_(void, UpdateAnimations) (void);
    STDMETHOD_(void, ComposerSiteDetach) (void);

    // QI Map
    
    BEGIN_COM_MAP(CAnimationComposerSite)
        COM_INTERFACE_ENTRY(IAnimationComposerSite)
        COM_INTERFACE_ENTRY(IAnimationComposerSiteSink)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // CBaseBvr pure virtuals.
    // Most of these are do not have bona-fide implementations
    // as this behavior has no properties.
    void * GetInstance (void);
    HRESULT GetTypeInfo (ITypeInfo ** ppInfo);
    HRESULT GetPropertyBagInfo (CPtrAry<BSTR> **);
    HRESULT SetPropertyByIndex (unsigned , VARIANT *);
    HRESULT GetPropertyByIndex (unsigned , VARIANT *);
    bool IsPropertySet (unsigned long);
    void SetPropertyFlag (DWORD uIndex);
    void ClearPropertyFlag (DWORD uIndex);
    STDMETHOD(OnPropertiesLoaded) (void);
    HRESULT GetConnectionPoint(REFIID , IConnectionPoint **);
    LPCWSTR GetBehaviorURN (void);
    LPCWSTR GetBehaviorName (void);
    bool IsBehaviorAttached (void);

  // Internal Methods
  protected :

    void    DetachComposers (void);
    void    UnregisterFactories (void);
    HRESULT CacheAnimationRoot (void);
    HRESULT RegisterSite (void);
    void    UnregisterSite (void);

    void RemoveComposer(IAnimationComposer *piOldComp);
    bool QueryReleaseComposer (IAnimationComposer *piComp);

    HRESULT FindCustomComposer (IDispatch *pidispFragment, 
                                BSTR bstrAttributeName, 
                                IAnimationComposer **ppiComposer);
    HRESULT FindAndInitComposer (IAnimationComposerFactory *piFactory,
                                 IDispatch *pidispFragment,
                                 BSTR bstrAttributeName,
                                 IAnimationComposer **ppiComposer);
    IAnimationComposer * FindComposerForAttribute (BSTR bstrAttribName);
    IAnimationComposer * FindComposer (BSTR bstrAttributeName, IDispatch *pidispFragment);
    IAnimationComposer * EnsureComposer (BSTR bstrAttributeName, IDispatch *pidispFragment);

  // Data
  protected :

    CComPtr<IAnimationRoot> m_spAnimationRoot;
    ComposerList            m_composers;
    ComposerFactoryList     m_factories;

};

// ----------------------------------------------------------------------------------------

inline void * 
CAnimationComposerSite::GetInstance (void)
{ 
    return reinterpret_cast<ITIMEAnimationElement *>(this) ; 
} // CAnimationComposerSite::GetInstance

// ----------------------------------------------------------------------------------------

inline HRESULT
CAnimationComposerSite::GetTypeInfo (ITypeInfo ** ppInfo)
{
    return GetTI(GetUserDefaultLCID(), ppInfo);
} // CAnimationComposerSite::GetTypeInfo

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::GetPropertyBagInfo (CPtrAry<BSTR> **)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::GetPropertyBagInfo

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::SetPropertyByIndex (unsigned , VARIANT *)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::SetPropertyByIndex

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::GetPropertyByIndex (unsigned , VARIANT *)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::GetPropertyByIndex

// ----------------------------------------------------------------------------------------

inline bool
CAnimationComposerSite::IsPropertySet (unsigned long)
{
    return false;
} // CAnimationComposerSite::IsPropertySet

// ----------------------------------------------------------------------------------------

inline STDMETHODIMP
CAnimationComposerSite::OnPropertiesLoaded (void)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::OnPropertiesLoaded

// ----------------------------------------------------------------------------------------

inline HRESULT 
CAnimationComposerSite::GetConnectionPoint (REFIID , IConnectionPoint **)
{
    return E_NOTIMPL;
} // CAnimationComposerSite::GetConnectionPoint

// ----------------------------------------------------------------------------------------

inline void 
CAnimationComposerSite::SetPropertyFlag (DWORD )
{
} // CAnimationComposerSite::SetPropertyFlag

// ----------------------------------------------------------------------------------------

inline void 
CAnimationComposerSite::ClearPropertyFlag (DWORD )
{
} // CAnimationComposerSite::ClearPropertyFlag

// ----------------------------------------------------------------------------------------

inline LPCWSTR 
CAnimationComposerSite::GetBehaviorURN (void)
{
    return WZ_SMILANIM_URN;
} // CAnimationComposerSite::GetBehaviorURN

// ----------------------------------------------------------------------------------------

inline LPCWSTR 
CAnimationComposerSite::GetBehaviorName (void)
{
    return WZ_REGISTERED_ANIM_NAME;
} // CAnimationComposerSite::GetBehaviorName

// ----------------------------------------------------------------------------------------

inline bool 
CAnimationComposerSite::IsBehaviorAttached (void)
{
    return IsComposerSiteBehaviorAttached(GetElement());
} // CTIMEElementBase::IsBehaviorAttached

#endif // _COMPSITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\filtercomp.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "timeparser.h"
#include "animcomp.h"
#include "filtercomp.h"
#include "transworker.h"
#include "targetpxy.h"
#include "filterpxy.h"

DeclareTag(tagAnimationFilterComposer, "SMIL Animation", 
           "CAnimationFilterComposer methods");

DeclareTag(tagAnimationFilterComposerProcess, "SMIL Animation", 
           "CAnimationFilterComposer pre/post process methods");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The dispatch of the host element, and the animated attribute
//
//  Returns:   S_OK, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT 
CAnimationFilterComposer::Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                                 IAnimationComposer **ppiComp)
{
    HRESULT hr = S_OK;

    CComObject<CAnimationFilterComposer> *pNew = NULL;
    hr = THR(CComObject<CAnimationFilterComposer>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IAnimationComposer, 
                                  reinterpret_cast<void **>(ppiComp)));
    if (FAILED(hr))
    {
        pNew->Release();
        hr = E_UNEXPECTED;
        goto done;
    }

    Assert(NULL != (*ppiComp));

    hr = (*ppiComp)->ComposerInit(pidispHostElem, bstrAttributeName);
    if (FAILED(hr))
    {
        (*ppiComp)->Release();
        *ppiComp = NULL;
        goto done;
    }

    hr = S_OK;
done :

    RRETURN3(hr, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationFilterComposer::Create

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::CAnimationFilterComposer
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFilterComposer::CAnimationFilterComposer (void)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::CAnimationFilterComposer()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::~CAnimationFilterComposer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationFilterComposer::~CAnimationFilterComposer (void)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::~CAnimationFilterComposer()",
              this));
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::QueryFragmentForParameters
//
//  Overview:  Pull the filter parameters from the incoming fragment.
//
//  Arguments: The dispatch of the fragment, and the variants holding the 
//             respective filter attributes and custom parameters.
//
//------------------------------------------------------------------------
HRESULT
CAnimationFilterComposer::QueryFragmentForParameters (IDispatch *pidispFragment,
                                                      VARIANT *pvarType, 
                                                      VARIANT *pvarSubtype,
                                                      VARIANT *pvarMode,
                                                      VARIANT *pvarFadeColor,
                                                      VARIANT *pvarParams)
{
    HRESULT hr = S_OK;

    // Find the filter properties on the fragment
    {
        CComVariant varElem;

        //  Get the fragment's element
        hr = THR(GetProperty(pidispFragment, WZ_FRAGMENT_ELEMENT_PROPERTY_NAME, &varElem));
        if (FAILED(hr))
        {
            goto done;
        }

        //  Get the filter properties from the fragment's element
        Assert(VT_DISPATCH == V_VT(&varElem));
        if (VT_DISPATCH != V_VT(&varElem))
        {
            hr = E_UNEXPECTED;
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_TYPE, pvarType));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_SUBTYPE, pvarSubtype));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_MODE, pvarMode));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(GetProperty(V_DISPATCH(&varElem), WZ_FADECOLOR, pvarFadeColor));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    // ## ISSUE Pull the custom parameters from the fragment
    //  Find the time behavior dispatch
    //  Query for the IFilterAnimationInfo interface and ask for the parameters from that
    ::VariantClear(pvarParams);

    hr = S_OK;
done :
    RRETURN(hr);
} // QueryFragmentForParameters

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::ComposerInitFromFragment
//
//  Overview:  Tells the composer to initialize itself
//
//  Arguments: The dispatch of the host element, the animated attribute, 
//             and the fragment we can query for filter parameters from.
//
//  Returns:   S_OK, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationFilterComposer::ComposerInitFromFragment (IDispatch *pidispHostElem, 
                                                    BSTR bstrAttributeName, 
                                                    IDispatch *pidispFragment)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::ComposerInitFromFragment(%p, %ls, %p)",
              this, pidispHostElem, bstrAttributeName, pidispFragment));

    HRESULT hr;

    hr = THR(PutAttribute(bstrAttributeName));
    if (FAILED(hr))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = QueryFragmentForParameters(pidispFragment,
                                    &m_varType, &m_varSubtype, 
                                    &m_varMode, &m_varFadeColor,
                                    &m_varParams);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CFilterTargetProxy::Create(pidispHostElem, 
                                        m_varType, m_varSubtype, 
                                        m_varMode, m_varFadeColor,
                                        m_varParams,
                                        &m_pcTargetProxy));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pcTargetProxy);

    hr = S_OK;
done :
    
    if (FAILED(hr))
    {
        IGNORE_HR(ComposerDetach());
    }

    RRETURN(hr);
} // CAnimationFilterComposer::ComposerInit

//+-----------------------------------------------------------------------
//
//  Member:    MatchStringVariant
//
//  Overview:  Case-insensitive compare of two variants 
//
//  Returns:   boolean
//
//------------------------------------------------------------------------
static bool
MatchStringVariant (VARIANT *pvarLeft, VARIANT *pvarRight)
{
    bool fRet = false;

    if (   (VT_BSTR == V_VT(pvarLeft)) 
        && (VT_BSTR == V_VT(pvarRight)))
    {
        // GetProperty will return VT_BSTR with a value
        // of NULL.  For some reason StrCmpIW doesn't
        // consider these equal.
        if (   (NULL == V_BSTR(pvarLeft)) 
            && (NULL == V_BSTR(pvarRight)))
        {
            fRet = true;
        }
        else if (0 == StrCmpIW(V_BSTR(pvarLeft), V_BSTR(pvarRight)))
        {
            fRet = true;
        }
    }
    // Need to allow for two empty variants 
    else if (   (VT_EMPTY == V_VT(pvarLeft))
             && (VT_EMPTY == V_VT(pvarRight)))
    {
        fRet = true;
    }

    return fRet;
} // MatchStringVariant

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::ValidateFragmentForComposer
//
//  Overview:  Validate this fragment to make sure its attributes
//             and params match those already registered here.
//
//  Arguments: the dispatch of the new fragment
//
//------------------------------------------------------------------------
HRESULT
CAnimationFilterComposer::ValidateFragmentForComposer (IDispatch *pidispFragment)
{
    HRESULT hr = S_OK;

    {
        CComVariant varType;
        CComVariant varSubtype;
        CComVariant varMode;
        CComVariant varFadeColor;
        CComVariant varParams;

        // ## ISSUE - we will need to match this fragment's parameter settings 
        // against those of the other fragments registered here.  Assuming that
        // parameters govern a filter's visual qualities, they should be identical.
        hr = QueryFragmentForParameters(pidispFragment, 
                                        &varType, &varSubtype, 
                                        &varMode, &varFadeColor,
                                        &varParams);

        if (   (!MatchStringVariant(&varType, &m_varType)) 
            || (!MatchStringVariant(&varSubtype, &m_varSubtype))
            || (!MatchStringVariant(&varMode, &m_varMode))
            || (!MatchStringVariant(&varFadeColor, &m_varFadeColor))
           )
        {
            hr = E_FAIL;
        }
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationFilterComposer::ValidateFragmentForComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::AddFragment
//
//  Overview:  Add a fragment to the composer's internal data structures.  
//             We will validate this fragment to make sure its attributes
//             and params match those already registered here.
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationFilterComposer::AddFragment (IDispatch *pidispNewAnimationFragment)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::AddFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr = S_OK;

    hr = ValidateFragmentForComposer(pidispNewAnimationFragment);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CAnimationComposerBase::AddFragment(pidispNewAnimationFragment));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationFilterComposer::AddFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationFilterComposer::InsertFragment
//
//  Overview:  Insert a fragment to the composer's internal data structures,
//             at the specified position.
//             We will validate this fragment to make sure its attributes
//             and params match those already registered here.
//
//  Arguments: the dispatch of the new fragment
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP 
CAnimationFilterComposer::InsertFragment (IDispatch *pidispNewAnimationFragment, VARIANT varIndex)
{
    TraceTag((tagAnimationFilterComposer,
              "CAnimationFilterComposer(%p)::InsertFragment(%p)",
              this,
              pidispNewAnimationFragment));

    HRESULT hr = S_OK;

    hr = ValidateFragmentForComposer(pidispNewAnimationFragment);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CAnimationComposerBase::InsertFragment(pidispNewAnimationFragment, varIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationFilterComposer::InsertFragment
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\compsite.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer Site Implementation

*******************************************************************************/


#include "headers.h"
#include "tokens.h"
#include "array.h"
#include "basebvr.h"
#include "util.h"
#include "compfact.h"
#include "compsite.h"
#include "animcomp.h"

DeclareTag(tagAnimationComposerSite, "SMIL Animation", 
           "CAnimationComposerSite methods");

DeclareTag(tagAnimationComposerSiteLifecycle, "SMIL Animation", 
           "CAnimationComposerSite Composer lifecycle methods");

DeclareTag(tagAnimationComposerSiteUpdate, "SMIL Animation", 
           "CAnimationComposerSite UpdateAnimations");

DeclareTag(tagAnimationComposerSiteRegistration, "SMIL Animation", 
           "CAnimationComposerSite Register/Unregister site");

DeclareTag(tagAnimationComposerSiteAddRemove, "SMIL Animation", 
           "CAnimationComposerSite Add/remove Fragment");

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::CAnimationComposerSite
//
//  Overview:  constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerSite::CAnimationComposerSite (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::CAnimationComposerSite()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::~CAnimationComposerSite
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CAnimationComposerSite::~CAnimationComposerSite (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::~CAnimationComposerSite()",
              this));

    Assert(0 == m_composers.size());
    Assert(0 == m_factories.size());
    m_spAnimationRoot.Release();
} //dtor

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::CacheAnimationRoot
//
//  Overview:  Consult the body for the animation root
//
//  Arguments: None
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::CacheAnimationRoot (void)
{
    HRESULT hr;

    CComPtr<IHTMLElement> piBodyElm;

    hr = THR(GetBodyElement(GetElement(), IID_IHTMLElement,
                            reinterpret_cast<void **>(&piBodyElm)));
    if (FAILED(hr))
    {
        TraceTag((tagError,
         "CacheAnimationRoot (%p) could not get body element",
         this));
        hr = E_FAIL;
        goto done;
    }

    // For the time being, we need to preclude registration 
    // of the site when we're running in IE4.  This will prevent 
    // a per-tick penalty.
    {
        CComPtr<IHTMLElement> spElem;
        CComPtr<IHTMLElement2> spElem2;

        spElem = GetElement();
        // IHTMLElement2 only supported since IE5.
        hr = THR(spElem->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElem2)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // The animation root interface is part of the behavior
    hr = THR(FindBehaviorInterface(WZ_REGISTERED_TIME_NAME,
                                   piBodyElm, IID_IAnimationRoot,
                                   reinterpret_cast<void **>(&m_spAnimationRoot)));
    if (FAILED(hr))
    {
        TraceTag((tagError,
         "CacheAnimationRoot (%p) body behavior not installed",
         this));
        hr = E_FAIL;
        goto done;
    }

    hr= S_OK;
done :
    RRETURN(hr);
} // CAnimationComposerSite::CacheAnimationRoot

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RegisterSite
//
//  Overview:  Register the composer site behavior with the animation root
//
//  Arguments: None
//
//  Returns:   S_OK, E_FAIL
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::RegisterSite (void)
{
    TraceTag((tagAnimationComposerSiteRegistration,
              "CAnimationComposerSite(%p)::RegisterSite()", this));

    HRESULT hr;

    // Allow for initialization failure
    if (m_spAnimationRoot != NULL)
    {
        hr = THR(m_spAnimationRoot->RegisterComposerSite(
                 static_cast<IAnimationComposerSiteSink *>(this)));
        if (FAILED(hr))
        {
            TraceTag((tagError,
             "Cannot register composer site (%p)", this));
            hr = E_FAIL;
            goto done;
        }
    }

    hr= S_OK;
done :
    RRETURN1(hr, E_FAIL);
} // CAnimationComposerSite::RegisterSite

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::Init
//
//  Overview:  Initialize the composer site behavior
//
//  Arguments: the behavior site
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::Init (IElementBehaviorSite *piBvrSite)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::Init(%p)",
              this, piBvrSite));

    HRESULT hr = CBaseBvr::Init(piBvrSite);

    // Make sure there is a time root that we can hook into
    hr = THR(AddBodyBehavior(GetElement()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CacheAnimationRoot();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationComposerSite::Init

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UnregisterSite
//
//  Overview:  Unregister the composer site behavior with the animation root
//
//  Arguments: None
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::UnregisterSite (void)
{
    TraceTag((tagAnimationComposerSiteRegistration,
              "CAnimationComposerSite(%p)::UnregisterSite()", this));

    // Allow for initialization failure
    if (m_spAnimationRoot != NULL)
    {
        HRESULT hr;

        hr = THR(m_spAnimationRoot->UnregisterComposerSite(
                 static_cast<IAnimationComposerSiteSink *>(this)));
        if (FAILED(hr))
        {
            TraceTag((tagError,
             "Cannot unregister composer site (%p)", this));
        }
    }
} // CAnimationComposerSite::UnregisterSite

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::DetachComposers
//
//  Overview:  Tell all of the composers to detach
//
//  Arguments: none
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::DetachComposers (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::DetachComposers()",
              this));

    ComposerList listComposersToDetach;

    // Copy the composer list so that we can tolerate 
    // reentrancy on it.
    for (ComposerList::iterator i = m_composers.begin(); 
         i != m_composers.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listComposersToDetach.push_back(*i);
    }

    // Do not allow any failure to abort the detach cycle.
    for (i = listComposersToDetach.begin(); 
         i != listComposersToDetach.end(); i++)
    {
        IGNORE_HR((*i)->ComposerDetach());
        // This release is for the reference from the 
        // original list.
        IGNORE_RETURN((*i)->Release());
    }

    for (i = listComposersToDetach.begin(); 
         i != listComposersToDetach.end(); i++)
    {
        // This release is for the reference from the 
        // copied list.
        IGNORE_RETURN((*i)->Release());
    }

    m_composers.clear();
} // CAnimationComposerSite::DetachComposers

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UnregisterFactories
//
//  Overview:  Tell all of the factories to unregister, then delete 
//             their memory.
//
//  Arguments: none
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::UnregisterFactories (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::UnregisterFactories()",
              this));

    for (ComposerFactoryList::iterator i = m_factories.begin(); i != m_factories.end(); i++)
    {
        VARIANT *pvarRegisteredFactory = *i;
        IGNORE_HR(::VariantClear(pvarRegisteredFactory));
        delete pvarRegisteredFactory;
    }

    m_factories.clear();
} // CAnimationComposerSite::UnregisterFactories

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::Detach
//
//  Overview:  Tear down the composer site behavior
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::Detach (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::Detach()",
              this));

    HRESULT hr;

    // We typically do not want errors to stop us from detaching everything.

    // Let go of our reference to the animation root.
    ComposerSiteDetach();

    // Tear down the factories and fragments.
    DetachComposers();
    UnregisterFactories();

    hr = CBaseBvr::Detach();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CAnimationComposerSite::Detach (%p) Error in base detach -- continuing detach",
                  this));
    }

done :
    RRETURN(hr);
} // CAnimationComposerSite::Detach

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindComposerForAttribute
//
//  Overview:  Find the proper composer for a given attribute
//
//  Arguments: the name of the animated attribute
//
//  Returns:   a weak reference to the composer
//
//------------------------------------------------------------------------
IAnimationComposer *
CAnimationComposerSite::FindComposerForAttribute (BSTR bstrAttribName)
{
    IAnimationComposer *piComp = NULL;

    for (ComposerList::iterator i = m_composers.begin(); 
         i != m_composers.end(); i++)
    {
        CComBSTR bstrOneAttrib;

        (*i)->get_attribute(&bstrOneAttrib);
        if (0 == StrCmpIW(bstrAttribName, bstrOneAttrib))
        {
            piComp = *i;
            break;
        }
    }

done :
    return piComp;
} // CAnimationComposerSite::FindComposerForAttribute

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindComposer
//
//  Overview:  Find the proper composer for a given fragment
//
//  Arguments: the animated attribute name, and the dispatch of the fragment
//
//  Returns:   a weak reference to the composer
//
//------------------------------------------------------------------------
IAnimationComposer *
CAnimationComposerSite::FindComposer (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    IAnimationComposer *piComp = NULL;

    // Look in the current list of composers for the proper one for this attribute.
    // If we could not find one, make one.
    piComp = FindComposerForAttribute(bstrAttributeName);

done :
    return piComp;
} // CAnimationComposerSite::FindComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindAndInitComposer
//
//  Overview:  Given a composer factory, try to find and init a composer.
//
//  Arguments: Composer Factory, 
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::FindAndInitComposer (IAnimationComposerFactory *piFactory,
                                             IDispatch *pidispFragment,
                                             BSTR bstrAttributeName,
                                             IAnimationComposer **ppiComposer)
{
    HRESULT hr;
    CComVariant varElem;

    hr = THR(GetProperty(pidispFragment, WZ_FRAGMENT_ELEMENT_PROPERTY_NAME, &varElem));
    if (FAILED(hr))
    {
        goto done;
    }

    if (VT_DISPATCH != V_VT(&varElem))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(piFactory->FindComposer(V_DISPATCH(&varElem), bstrAttributeName, ppiComposer));
    if (S_OK == hr)
    {
        CComPtr<IAnimationComposer2> spComp2;

        // Try calling through the newer init method.  This allows the filter composer
        // to set itself up correctly upon initialization.
        hr = THR((*ppiComposer)->QueryInterface(IID_TO_PPV(IAnimationComposer2, &spComp2)));
        if (SUCCEEDED(hr))
        {
            hr = THR(spComp2->ComposerInitFromFragment(GetElement(), bstrAttributeName, pidispFragment));
        }
        // Fallback to older interface - no harm done, except for filters which we're revving
        // here.
        else
        {
            hr = THR((*ppiComposer)->ComposerInit(GetElement(), bstrAttributeName));
        }

        if (FAILED(hr))
        {
            IGNORE_RETURN((*ppiComposer)->Release());
            *ppiComposer = NULL;
            goto done;
        }
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // FindAndInitComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::FindCustomComposer
//
//  Overview:  Search the registered composer factories for the proper composer
//
//  Arguments: the animated attribute name
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CAnimationComposerSite::FindCustomComposer (IDispatch *pidispFragment, 
                                            BSTR bstrAttributeName, 
                                            IAnimationComposer **ppiComposer)
{
    HRESULT hr = S_FALSE;
    HRESULT hrTemp;
    CComPtr<IAnimationComposerFactory> spCompFactory;

    // Internal method - validation is not necessary.
    *ppiComposer = NULL;

    for (ComposerFactoryList::iterator i = m_factories.begin(); i != m_factories.end(); i++)
    {
        VARIANT *pvarFactory = *i;
        CLSID clsidFactory;

        if (VT_BSTR == V_VT(pvarFactory))
        {
            hrTemp = THR(CLSIDFromString(V_BSTR(pvarFactory), &clsidFactory));
            if (FAILED(hrTemp))
            {
                TraceTag((tagAnimationComposerSite,
                          "CAnimationComposerSite(%p)::FindCustomComposer() failed getting a CLSID -- continuing",
                          this));
                continue;
            }

            hrTemp = THR(::CoCreateInstance(clsidFactory, NULL, CLSCTX_INPROC_SERVER, 
                                            IID_IAnimationComposerFactory, 
                                            reinterpret_cast<void **>(&spCompFactory)));
            if (FAILED(hrTemp))
            {

                TraceTag((tagAnimationComposerSite,
                          "CAnimationComposerSite(%p)::FindCustomComposer() failed during a CoCreate -- continuing",
                          this));
                continue;
            }
        }
        else if (VT_UNKNOWN == V_VT(pvarFactory))
        {
            hrTemp = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_TO_PPV(IAnimationComposerFactory, &spCompFactory)));
            if (FAILED(hrTemp))
            {

                TraceTag((tagAnimationComposerSite,
                          "CAnimationComposerSite(%p)::FindCustomComposer() failed during a QI -- continuing",
                          this));
                continue;
            }
        }
        else
        {
            TraceTag((tagAnimationComposerSite,
                      "CAnimationComposerSite(%p)::FindCustomComposer() unexpected factory type %X -- continuing",
                      this, V_VT(pvarFactory)));
            continue;
        }

        // If either FindComposer or InitComposer come up empty, we want to keep looking 
        // for another composer, on the off-chance the animation will work properly.
        hrTemp = FindAndInitComposer(spCompFactory, pidispFragment, 
                                     bstrAttributeName, ppiComposer);
        if (S_OK == hrTemp)
        {
            hr = hrTemp;
            break;
        }
    }

done :
    RRETURN1(hr, S_FALSE);
} // CAnimationComposerSite::FindCustomComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::EnsureComposer
//
//  Overview:  Find or create the proper composer for a given fragment
//
//  Arguments: the animated attribute name, and the dispatch of the fragment
//
//  Returns:   a weak reference to the composer
//
//------------------------------------------------------------------------
IAnimationComposer *
CAnimationComposerSite::EnsureComposer (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    IAnimationComposer *piComp = FindComposer(bstrAttributeName, pidispFragment);

    if (NULL == piComp)
    {
        HRESULT hr;

        hr = FindCustomComposer(pidispFragment, bstrAttributeName, &piComp);
        if (S_OK != hr)
        {
            // Make sure we don't eat a composer reference.  This might happen if the composer 
            // doesn't properly clean up after a failure.
            Assert(NULL == piComp);

            // create a composer using the default factory.
            // The static create method addrefs the object.
            CComPtr<IAnimationComposerFactory> spFactory;

            hr = THR(::CoCreateInstance(CLSID_AnimationComposerFactory, NULL, CLSCTX_INPROC_SERVER, 
                                        IID_IAnimationComposerFactory, 
                                        reinterpret_cast<void **>(&spFactory)));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = FindAndInitComposer(spFactory, pidispFragment, bstrAttributeName, &piComp);
            if (FAILED(hr))
            {
                goto done;
            }

        }
        
        if (NULL != piComp)
        {
            TraceTag((tagAnimationComposerSiteLifecycle,
                      "CAnimationComposerSite(%p)::EnsureComposer(%ls, %p) created composer",
                      this, bstrAttributeName, piComp));

            // @@ Handle memory errors.
            m_composers.push_back(piComp);
            // If this is our first composer, then register ourselves 
            // for updates with the animation root.
            if (1 == m_composers.size())
            {
                hr = RegisterSite();
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
    }

done :
    return piComp;
} // CAnimationComposerSite::EnsureComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::AddFragment
//
//  Overview:  Add a fragment to the composer site.  Consults the 
//             registered composer factories to find the proper 
//             composer
//
//  Arguments: the animated attribute name and the fragment's dispatch
//
//  Returns:   S_OK, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::AddFragment (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    TraceTag((tagAnimationComposerSiteAddRemove,
              "CAnimationComposerSite(%p)::AddFragment(%ls, %p)",
              this, bstrAttributeName, pidispFragment));

    HRESULT hr;
    CComPtr<IAnimationComposer> piComp;

    // Find the proper composer for this fragment.
    piComp = EnsureComposer(bstrAttributeName, pidispFragment);
    if (piComp == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
        
    // This can return S_FALSE if the fragment is already inside the 
    // composer's fragment list.
    hr = THR(piComp->AddFragment(pidispFragment));
    if (S_OK != hr)
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN4(hr, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposerSite::AddFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RemoveFragment
//
//  Overview:  Remove a fragment from the composer site.  Determines which of 
//             the composers owns it.
//
//  Arguments: the animated attribute name, and the fragment's dispatch
//
//  Returns:   S_OK, S_FALSE, E_UNEXPECTED
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::RemoveFragment (BSTR bstrAttributeName, IDispatch *pidispFragment)
{
    TraceTag((tagAnimationComposerSiteAddRemove,
              "CAnimationComposerSite(%p)::RemoveFragment(%ls, %p)",
              this, bstrAttributeName, pidispFragment));

    HRESULT hr;
    CComPtr<IAnimationComposer> spComp;

    spComp = FindComposer(bstrAttributeName, pidispFragment);
    if (spComp == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = THR(spComp->RemoveFragment(pidispFragment));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_UNEXPECTED);
} // CAnimationComposerSite::RemoveFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::InsertFragment
//
//  Overview:  Insert a fragment to the composer site.  Consults the 
//             registered composer factories to find the proper 
//             composer
//
//  Arguments: the animated attribute name and the fragment's dispatch
//
//  Returns:   S_OK, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::InsertFragment (BSTR bstrAttributeName, IDispatch *pidispFragment, 
                                     VARIANT varIndex)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::InsertFragment(%ls, %p)",
              this, bstrAttributeName, pidispFragment));

    HRESULT hr;
    CComPtr<IAnimationComposer> piComp;

    // Find the proper composer for this fragment.
    piComp = EnsureComposer(bstrAttributeName, pidispFragment);
    if (piComp == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
        
    // This can return S_FALSE if the fragment is already inside the 
    // composer's fragment list.
    hr = THR(piComp->InsertFragment(pidispFragment, varIndex));
    if (S_OK != hr)
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN4(hr, S_FALSE, E_OUTOFMEMORY, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND);
} // CAnimationComposerSite::InsertFragment

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::EnumerateFragments
//
//  Overview:  Enumerate the fragments on the composer registered for 
//             the given attribute name.
//
//  Arguments: the animated attribute name and the enumerator
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::EnumerateFragments (BSTR bstrAttributeName, 
                                            IEnumVARIANT **ppienumFragments)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::EnumerateFragments(%ls)",
              this, bstrAttributeName));

    HRESULT hr;
    CComPtr<IAnimationComposer> piComp;

    // Find the proper composer for this fragment.
    piComp = FindComposerForAttribute(bstrAttributeName);
    if (piComp == NULL)
    {
        // @@ Need a proper error value for this.
        hr = E_FAIL;
        goto done;
    }
    
    hr = piComp->EnumerateFragments(ppienumFragments);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CAnimationComposerSite::EnumerateFragments

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RegisterComposerFactory
//
//  Overview:  Register a new composer factory with this site
//
//  Arguments: The CLSID or IUnknown of the new composer factory
//
//  Returns:   S_OK, E_INVALIDARG, DISP_E_BADVARTYPE, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::RegisterComposerFactory (VARIANT *pvarFactory)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::RegisterComposerFactory()",
              this));

    HRESULT hr;

    if (NULL == pvarFactory)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if ((VT_BSTR != V_VT(pvarFactory)) && (VT_UNKNOWN != V_VT(pvarFactory)))
    {
        hr = DISP_E_BADVARTYPE;
        goto done;
    }

    // Add this to the list of factories.
    {
        VARIANT *pvarNewFactory = new VARIANT;

        if (NULL == pvarNewFactory)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        ::VariantInit(pvarNewFactory);
        hr = THR(::VariantCopy(pvarNewFactory, pvarFactory));
        if (FAILED(hr))
        {
            goto done;
        }
        // Put the newly registered factory at the 
        // front of the list to give it precedence over
        // previously registered factories.
        // @@ Check for memory error.
        m_factories.push_front(pvarNewFactory);
        // we no longer own this.
        pvarNewFactory = NULL; //lint !e423
    }
    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, DISP_E_BADVARTYPE, E_OUTOFMEMORY);
} // CAnimationComposerSite::RegisterComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UnregisterComposerFactory
//
//  Overview:  Unregister a composer factory on this site
//
//  Arguments: The CLSID of the composer factory
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP
CAnimationComposerSite::UnregisterComposerFactory (VARIANT *pvarFactory)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::UnregisterComposerFactory()",
              this));

    HRESULT hr;

    // Remove this from the list of factories.
    for (ComposerFactoryList::iterator i = m_factories.begin(); i != m_factories.end(); i++)
    {
        VARIANT *pvarRegisteredFactory = *i;

        if ((VT_BSTR == V_VT(pvarFactory)) &&
            (VT_BSTR == V_VT(pvarRegisteredFactory)))
        {
            if (0 == StrCmpIW(V_BSTR(pvarFactory), V_BSTR(pvarRegisteredFactory)))
            {
                break;
            }
        }
        else if ((VT_UNKNOWN == V_VT(pvarFactory)) &&
                 (VT_UNKNOWN == V_VT(pvarRegisteredFactory)))
        {
            if (MatchElements(V_UNKNOWN(pvarFactory), V_UNKNOWN(pvarRegisteredFactory)))
            {
                break;
            }
        }
    }

    if (i != m_factories.end())
    {
        IGNORE_HR(::VariantClear(*i));
        m_factories.remove(*i);
    }
    else
    {
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, S_FALSE);
} // CAnimationComposerSite::UnregisterComposerFactory

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::QueryReleaseComposer
//
//  Overview:  Determine whether we can release this composer
//
//  Returns:   
//
//------------------------------------------------------------------------
bool
CAnimationComposerSite::QueryReleaseComposer (IAnimationComposer *piComp)
{
    bool bRet = false;
    long lNumFragments = 0;
    HRESULT hr = THR(piComp->GetNumFragments(&lNumFragments));

    if (FAILED(hr))
    {
        // Failure constitutes a perf
        // hit, but not a disaster.
        goto done;
    }

    if (0 == lNumFragments)
    {
        bRet = true;
    }

done :
    return bRet;
} // CAnimationComposerSite::QueryReleaseComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::RemoveComposer
//
//  Overview:  Remove this composer from our list.
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CAnimationComposerSite::RemoveComposer(IAnimationComposer *piOldComp)
{
    CComBSTR bstrAttrib;
    HRESULT hr = THR(piOldComp->get_attribute(&bstrAttrib));

    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagAnimationComposerSiteLifecycle,
              "CAnimationComposerSite(%p)::RemoveComposer(%p, %ls)",
              this, piOldComp, bstrAttrib));

    {
        for (ComposerList::iterator i = m_composers.begin(); 
             i != m_composers.end(); i++)
        {
            CComBSTR bstrOneAttrib;

            (*i)->get_attribute(&bstrOneAttrib);
            if (0 == StrCmpIW(bstrAttrib, bstrOneAttrib))
            {
                CComPtr<IAnimationComposer> spComp = (*i);
                m_composers.erase(i);
                THR(spComp->ComposerDetach());
                spComp->Release();
                break;
            }
        }
    }

done :
    return;
} // RemoveComposer

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::UpdateAnimations
//
//  Overview:  Tell all of our composers to cycle through their fragments 
//             and update the target.
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CAnimationComposerSite::UpdateAnimations (void)
{
    ComposerList listComposers;

    TraceTag((tagAnimationComposerSiteUpdate,
              "CAnimationComposerSite(%p)::UpdateAnimations(%ld composers)",
              this, m_composers.size()));

    // Make sure we can remove composers as we see fit.
    for (ComposerList::iterator i = m_composers.begin(); 
         i != m_composers.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listComposers.push_back(*i);
    }

    for (i = listComposers.begin(); i != listComposers.end(); i++)
    {
        IGNORE_RETURN((*i)->UpdateFragments());
        if (QueryReleaseComposer(*i))
        {
            // Remove this composer from the original list.
            RemoveComposer(*i);
        }
    }

    for (i = listComposers.begin(); i != listComposers.end(); i++)
    {
        IGNORE_RETURN((*i)->Release());
    }
    listComposers.clear();

    // If we have no active composers, we might as well unregister ourselves.
    if (0 == m_composers.size())
    {
        UnregisterSite();
    }
} // CAnimationComposerSite::UpdateAnimations

//+-----------------------------------------------------------------------
//
//  Member:    CAnimationComposerSite::ComposerSiteDetach
//
//  Overview:  The animation root is going away.  Time to off our reference to it.
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP_(void)
CAnimationComposerSite::ComposerSiteDetach (void)
{
    TraceTag((tagAnimationComposerSite,
              "CAnimationComposerSite(%p)::AnimationComposerSiteDetach()",
              this));

    // Let go of our cached anim root reference.
    m_spAnimationRoot.Release();
} // CAnimationComposerSite::ComposerSiteDetach
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\filtercomp.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Filter Animation Composer.

*******************************************************************************/

#pragma once

#ifndef _FILTERCOMP_H
#define _FILTERCOMP_H

class __declspec(uuid("5B81FB87-CC13-4bde-9F5C-51CFE4D221ED"))
ATL_NO_VTABLE CAnimationFilterComposer
    : public CComCoClass<CAnimationFilterComposer, &__uuidof(CAnimationFilterComposer)>,
      public CAnimationComposerBase
{

  public:

    CAnimationFilterComposer (void);
    virtual ~CAnimationFilterComposer (void);

    // IAnimationComposer methods
    STDMETHOD(AddFragment) (IDispatch *pidispNewAnimationFragment);
    STDMETHOD(InsertFragment) (IDispatch *pidispNewAnimationFragment, VARIANT varIndex);

    // IAnimationComposer2 methods
    STDMETHOD(ComposerInitFromFragment) (IDispatch *pidispHostElem, 
                                         BSTR bstrAttributeName, 
                                         IDispatch *pidispFragment);

    DECLARE_NOT_AGGREGATABLE(CAnimationFilterComposer)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationFilterComposer"); }
#endif

    static HRESULT Create (IDispatch *pidispHostElem, BSTR bstrAttributeName, 
                           IAnimationComposer **ppiComp);

  protected :

    HRESULT QueryFragmentForParameters (IDispatch *pidispFragment,
                                        VARIANT *pvarType, 
                                        VARIANT *pvarSubtype,
                                        VARIANT *pvarMode,
                                        VARIANT *pvarFadeColor,
                                        VARIANT *pvarParams);

    HRESULT ValidateFragmentForComposer (IDispatch *pidispFragment);

  protected :

    CComVariant m_varType;
    CComVariant m_varSubtype;
    CComVariant m_varMode;
    CComVariant m_varFadeColor;
    CComVariant m_varParams;

};

#endif /* _FILTERCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\filterpxy.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Abstract:

    Animation Composer's Target Proxy for filters.

*******************************************************************************/

#pragma once

#ifndef _FILTERPXY_H
#define _FILTERPXY_H

interface ITransitionWorker;
class CTargetProxy;

// The filter target proxy abstracts the communication with the target 
// object.  
class CFilterTargetProxy : 
    public CTargetProxy,
    public ITransitionSite
{

 public :

    static HRESULT Create (IDispatch *pidispHostElem, 
                           VARIANT varType, VARIANT varSubtype, 
                           VARIANT varMode, VARIANT varFadeColor,
                           VARIANT varParams,
                           CTargetProxy **ppCFilterTargetProxy);

    virtual ~CFilterTargetProxy (void);

    // ITransitionSite methods
    STDMETHOD(get_htmlElement)(IHTMLElement ** ppHTMLElement);
    STDMETHOD(get_template)(IHTMLElement ** ppHTMLElement);

    // CTargetProxy overrides.
    virtual HRESULT Detach (void);
    virtual HRESULT GetCurrentValue (VARIANT *pvarValue);
    virtual HRESULT Update (VARIANT *pvarNewValue);

#if DBG
    const _TCHAR * GetName() { return __T("CFilterTargetProxy"); }
#endif

        // QI Map
    BEGIN_COM_MAP(CTargetProxy)
        COM_INTERFACE_ENTRY2(IUnknown, CTargetProxy)
    END_COM_MAP();

 // Internal Methods
 protected :
    
    CFilterTargetProxy (void);
    HRESULT Init (IDispatch *pidispSite, 
                  VARIANT varType, VARIANT varSubtype, 
                  VARIANT varMode, VARIANT varFadeColor,
                  VARIANT varParams);

    DXT_QUICK_APPLY_TYPE DetermineMode (VARIANT varMode);

  // Data
 protected:


    // A transition worker manages the DXTransform attached to our host 
    // element.

    CComPtr<ITransitionWorker>  m_spTransitionWorker;
    CComPtr<IHTMLElement> m_spElem;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\filterpxy.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer's Filter Proxy Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "tokens.h"
#include "animcomp.h"
#include "targetpxy.h"
#include "transworker.h"
#include "filterpxy.h"

DeclareTag(tagFilterProxy, "SMIL Animation", 
           "CFilterTargetProxy methods");
DeclareTag(tagFilterProxyValue, "SMIL Animation", 
           "CFilterTargetProxy value get/put");


//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Create
//
//  Overview:  Creates and initializes the target proxy
//
//  Arguments: The dispatch of the host element, attribute name, out param
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Create (IDispatch *pidispHostElem, 
                            VARIANT varType, VARIANT varSubtype,
                            VARIANT varMode, VARIANT varFadeColor,
                            VARIANT varParams,
                            CTargetProxy **ppCFilterTargetProxy)
{
    HRESULT hr;

    CComObject<CFilterTargetProxy> * pTProxy;

    if (NULL == ppCFilterTargetProxy)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(CComObject<CFilterTargetProxy>::CreateInstance(&pTProxy));
    if (hr != S_OK)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    *ppCFilterTargetProxy = static_cast<CFilterTargetProxy *>(pTProxy);
    (static_cast<CTargetProxy *>(*ppCFilterTargetProxy))->AddRef();

    hr = THR(pTProxy->Init(pidispHostElem, varType, varSubtype, 
                           varMode, varFadeColor, varParams));
    if (FAILED(hr))
    {
        (static_cast<CTargetProxy *>(*ppCFilterTargetProxy))->Release();
        *ppCFilterTargetProxy = NULL;
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED);
} // CFilterTargetProxy::Create

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::CFilterTargetProxy
//
//  Overview:  Constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CFilterTargetProxy::CFilterTargetProxy (void)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::CFilterTargetProxy()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::~CFilterTargetProxy
//
//  Overview:  Destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CFilterTargetProxy::~CFilterTargetProxy (void)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::~CFilterTargetProxy()",
              this));
    
    // Make sure Detach is called.
    IGNORE_HR(Detach());

} // dtor


//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::DetermineMode
//
//  Overview:  Given a variant string determine the proper 
//             quick apply type for the filter.
//
//------------------------------------------------------------------------
DXT_QUICK_APPLY_TYPE
CFilterTargetProxy::DetermineMode (VARIANT varMode)
{
    DXT_QUICK_APPLY_TYPE dxtQAT = DXTQAT_TransitionIn;

    if (   (VT_BSTR == V_VT(&varMode)) 
        && (NULL != V_BSTR(&varMode))
        && (0 == StrCmpIW(V_BSTR(&varMode), WZ_TRANSITION_MODE_OUT)))
    {
        dxtQAT = DXTQAT_TransitionOut;
    }

    return dxtQAT;
} // CFilterTargetProxy::DetermineMode


//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Init
//
//  Overview:  Initialize the target proxy
//
//  Arguments: the host element dispatch, type/subtype name
//
//  Returns:   S_OK, E_UNEXPECTED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Init (IDispatch *pidispHostElem, 
                          VARIANT varType, VARIANT varSubtype, 
                          VARIANT varMode, VARIANT varFadeColor,
                          VARIANT varParams)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::Init (%p, %ls, %ls)",
              this, pidispHostElem, V_BSTR(&varType), V_BSTR(&varSubtype)));

    HRESULT hr = S_OK;

    Assert(!m_spElem);
    if (m_spElem)
    {
        m_spElem.Release();
    }

    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &m_spElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    // Create a transition worker.  This actually creates the DXTransform, 
    // adds it to the element, and manages it in general.

    hr = THR(CreateTransitionWorker(&m_spTransitionWorker));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransitionWorker->put_transSite((ITransitionSite *)this));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spTransitionWorker->InitStandalone(varType, varSubtype));

    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(m_spTransitionWorker->Apply(DetermineMode(varMode)));
    IGNORE_HR(m_spTransitionWorker->OnBeginTransition());

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(Detach());
    }

    RRETURN(hr);
} // CFilterTargetProxy::Init

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Detach
//
//  Overview:  Detach all external references in the target proxy
//
//  Arguments: none
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Detach (void)
{
    TraceTag((tagFilterProxy,
              "CFilterTargetProxy(%p)::Detach()",
              this));

    HRESULT hr = S_OK;

    if (m_spTransitionWorker)
    {
        IGNORE_HR(m_spTransitionWorker->OnEndTransition());
        m_spTransitionWorker->Detach();
        m_spTransitionWorker.Release();
    }
    if (m_spElem)
    {
        m_spElem.Release();
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CFilterTargetProxy::Detach

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::GetCurrentValue
//
//  Overview:  Get the current value of target's attribute
//
//  Arguments: the attribute value
//
//  Returns:   S_OK, E_INVALIDARG, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::GetCurrentValue (VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    if (NULL == pvarValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!m_spTransitionWorker)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    {
        double dblProgress = 0;0;
     
        hr = THR(m_spTransitionWorker->get_progress(&dblProgress));
        if (FAILED(hr))
        {
            goto done;
        }
        ::VariantClear(pvarValue);
        V_VT(pvarValue) = VT_R8;
        V_R8(pvarValue) = dblProgress;
    }

    hr = S_OK;

done :
    RRETURN2(hr, E_INVALIDARG, E_UNEXPECTED);
} // CFilterTargetProxy::GetCurrentValue

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::Update
//
//  Overview:  Update the target's attribute
//
//  Arguments: the new attribute value
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
HRESULT
CFilterTargetProxy::Update (VARIANT *pvarNewValue)
{
    HRESULT hr = S_OK;

    if (NULL == pvarNewValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    if (VT_R8 != V_VT(pvarNewValue))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // Clamp the values to between [0..1].
    V_R8(pvarNewValue) = Clamp(0.0, V_R8(pvarNewValue), 1.0);

    {
        hr = THR(m_spTransitionWorker->put_progress(V_R8(pvarNewValue)));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // CFilterTargetProxy::Update

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::get_htmlElement, ITransitionSite
//
//  Overview:  Get the host html element for this transition
//
//  Arguments: the outgoing element
//
//------------------------------------------------------------------------
STDMETHODIMP
CFilterTargetProxy::get_htmlElement (IHTMLElement ** ppHTMLElement)
{
    HRESULT hr = S_OK;

    if (NULL == ppHTMLElement)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!m_spElem)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    m_spElem->AddRef();
    *ppHTMLElement = m_spElem.p;

    hr = S_OK;
done :
    RRETURN(hr);
} // get_htmlElement

//+-----------------------------------------------------------------------
//
//  Member:    CFilterTargetProxy::get_template, ITransitionSite
//
//  Overview:  Get the transition template (does not apply here)
//
//  Arguments: the outgoing template element
//
//------------------------------------------------------------------------
STDMETHODIMP 
CFilterTargetProxy::get_template (IHTMLElement ** ppHTMLElement)
{
    return S_FALSE;
} // get_template
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\fragenum.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Fragment Enumerator.

*******************************************************************************/

#pragma once

#ifndef _FRAGENUM_H
#define _FRAGENUM_H

class CFragmentEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{

  public:

    CFragmentEnum (void);
    virtual ~CFragmentEnum (void);

    static HRESULT Create (CAnimationComposerBase &refComp, 
                           IEnumVARIANT **ppienumFragments,
                           unsigned long ulCurrent = 0);

    void Init (CAnimationComposerBase &refComp) 
        { m_spComp = &refComp; }
    bool SetCurrent (unsigned long ulCurrent);
    
    // IEnumVARIANT methods
    STDMETHOD(Clone) (IEnumVARIANT **ppEnum);
    STDMETHOD(Next) (unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
    STDMETHOD(Reset) (void);
    STDMETHOD(Skip) (unsigned long celt);
                        
    // QI Map
    BEGIN_COM_MAP(CFragmentEnum)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP();

  protected:

    bool ValidateIndex (unsigned long ulIndex);

    unsigned long                       m_ulCurElement;
    CComPtr<CAnimationComposerBase>     m_spComp;

}; //lint !e1712

#endif // _FRAGENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\sitefact.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Composer Site factory

*******************************************************************************/

#pragma once

#ifndef _COMPSITEFACTORY_H
#define _COMPSITEFACTORY_H

class ATL_NO_VTABLE CAnimationComposerSiteFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CAnimationComposerSiteFactory, &CLSID_AnimationComposerSiteFactory>,
      public ITIMEDispatchImpl<IAnimationComposerSiteFactory, &IID_IAnimationComposerSiteFactory>,
      public ISupportErrorInfoImpl<&IID_IAnimationComposerSiteFactory>,
      public IElementBehaviorFactory,
      public IObjectSafety
{
  public:
    CAnimationComposerSiteFactory();
    virtual ~CAnimationComposerSiteFactory();

    DECLARE_NOT_AGGREGATABLE(CAnimationComposerSiteFactory)

#if DBG
    const _TCHAR * GetName() { return __T("CAnimationComposerSiteFactory"); }
#endif

    // IElementBehaviorFactory
    
    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IElementBehaviorSite * pUnkArg,
                            IElementBehavior ** ppBehavior);

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(
        /* [in] */ REFIID riid,
        /* [in] */ DWORD dwOptionSetMask,
        /* [in] */ DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(
        /* [in] */ REFIID riid, 
        /* [out] */DWORD *pdwSupportedOptions, 
        /* [out] */DWORD *pdwEnabledOptions);
    
    DECLARE_REGISTRY(CLSID_AnimationComposerSiteFactory,
                     LIBID __T(".SMILAnimCompSiteFactory.1"),
                     LIBID __T(".SMILAnimCompSiteFactory"),
                     0,
                     THREADFLAGS_BOTH);
    
    BEGIN_COM_MAP(CAnimationComposerSiteFactory)
        COM_INTERFACE_ENTRY(IAnimationComposerSiteFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    END_COM_MAP();

    HRESULT Error();

  protected:

    DWORD m_dwSafety;

};

#endif /* _COMPSITEFACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\fragenum.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Fragment Enumerator Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcomp.h"
#include "fragenum.h"

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Create
//
//  Overview:  static Create method -- wraps both ctor and Init
//
//  Arguments: The composer containing the fragments we will enumerate
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CFragmentEnum::Create (CAnimationComposerBase &refComp,
                       IEnumVARIANT **ppienumFragments, 
                       unsigned long ulCurrent)
{
    HRESULT hr;

    CComObject<CFragmentEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(ppienumFragments);

    hr = THR(CComObject<CFragmentEnum>::CreateInstance(&pNewEnum));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(refComp);
    pNewEnum->SetCurrent(ulCurrent);

    hr = THR(pNewEnum->QueryInterface(IID_TO_PPV(IEnumVARIANT, ppienumFragments)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // Create

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::CFragmentEnum
//
//  Overview:  ctor
//
//------------------------------------------------------------------------
CFragmentEnum::CFragmentEnum (void) :
    m_ulCurElement(0)
{
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::CFragmentEnum
//
//  Overview:  dtor
//
//------------------------------------------------------------------------
CFragmentEnum::~CFragmentEnum (void)
{
} // dtor

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::ValidateIndex
//
//  Overview:  Make sure an index is within the range of accepted values.
//
//  Arguments: index
//
//  Returns:   true on success
//
//------------------------------------------------------------------------
bool
CFragmentEnum::ValidateIndex (unsigned long ulIndex)
{
    bool bRet = false;

    if (m_spComp == NULL)
    {
        goto done;
    }

    if (m_spComp->GetFragmentCount() <= ulIndex)
    {
        goto done;
    }

    bRet = true;
done :
    return bRet;
} // CFragmentEnum::ValidateIndex

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::SetCurrent
//
//  Overview:  Set the current location to the specified index
//
//  Arguments: The new index
//
//  Returns:   true on success
//
//------------------------------------------------------------------------
bool
CFragmentEnum::SetCurrent (unsigned long ulCurrent)
{
    bool bRet = false;

    // If the new index is out of range, put us right at the end.
    if (!ValidateIndex(ulCurrent))
    {
        ulCurrent = m_spComp->GetFragmentCount();
    }

    m_ulCurElement = ulCurrent;

    bRet = true;
done :
    return bRet;
} // SetCurrent

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Reset
//
//  Overview:  Reset the current location to the beginning
//
//  Arguments: None
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Reset (void)
{
    m_ulCurElement = 0;
    RRETURN(S_OK);
} // Reset

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Clone
//
//  Overview:  Clone this enumerator
//
//  Arguments: The new enumerator
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Clone (IEnumVARIANT **ppEnum)
{
    HRESULT hr;

    hr = CFragmentEnum::Create(*m_spComp, ppEnum, m_ulCurElement);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // Reset

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Skip
//
//  Overview:  Move the current location forward lIndex slots
//
//  Arguments: The index delta
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Skip (unsigned long celt)
{
    HRESULT hr;
    
    // Try setting the location to the desired slot.  This
    // will fail if it will cause us to walk off the end of the 
    // sequence.
    if (!SetCurrent(m_ulCurElement + celt))
    {
        if (m_spComp)
        {
            // If we've got zero items, keep the location there.
            // Otherwise set the location to the last item in
            // the sequence.
            unsigned long ulNew = m_spComp->GetFragmentCount();

            if (0 < ulNew)
            {
                ulNew--;
            }

            IGNORE_RETURN(SetCurrent(ulNew));
        }
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, S_FALSE);
} // Reset

//+-----------------------------------------------------------------------
//
//  Member:    CFragmentEnum::Next
//
//  Overview:  Get the next celt items from the enumeration sequence.
//
//  Arguments: celt : number requested
//             rgVar : array of celt variants in which elements are returned
//             pCeltFetched : a pointer to a location in which the number
//                            actually retrieved is returned.
//
//  Returns:   S_OK, S_FALSE
//
//------------------------------------------------------------------------
STDMETHODIMP
CFragmentEnum::Next (unsigned long celt, VARIANT *prgVar, unsigned long *pCeltFetched)
{
    HRESULT hr;
    unsigned long i = 0;

    if (!m_spComp)
    {
        hr = E_FAIL;
        goto done;
    }

    for (i = 0; i < celt; i++)
    {
        CComPtr<IDispatch> spDisp;

        if (!ValidateIndex(m_ulCurElement))
        {
            hr = S_FALSE;
            goto done;
        }

        hr = THR(m_spComp->GetFragment(m_ulCurElement, &spDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        spDisp->AddRef();
        V_DISPATCH(&(prgVar[i])) = spDisp;
        V_VT(&(prgVar[i])) = VT_DISPATCH;

        m_ulCurElement++;
    }

    hr = S_OK;
done :    
    if (NULL != pCeltFetched)
    {
        *pCeltFetched = i;
    }

    RRETURN1(hr, S_FALSE);
} // Reset
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\sitefact.cpp ===
/*******************************************************************************
 *                                                                              
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Abstract:
 *
 *******************************************************************************/

#include "headers.h"
#include "sitefact.h"
#include "tokens.h"
#include "array.h"
#include "util.h"
#include "basebvr.h"
#include "compsite.h"

DeclareTag(tagAnimCompSiteFactory, "SMILANIM", "CAnimationComposerSiteFactory methods");

// ----------------------------------------------------------------------------------------

CAnimationComposerSiteFactory::CAnimationComposerSiteFactory (void)
: m_dwSafety(0)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::CAnimationComposerSiteFactory()",
              this));
} // CAnimationComposerSiteFactory::CAnimationComposerSiteFactory

// ----------------------------------------------------------------------------------------

CAnimationComposerSiteFactory::~CAnimationComposerSiteFactory (void)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::~CAnimationComposerSiteFactory()",
              this));
} // CAnimationComposerSiteFactory::~CAnimationComposerSiteFactory

// ----------------------------------------------------------------------------------------

HRESULT
CAnimationComposerSiteFactory::Error (void)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::Error()",
              this));

    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CAnimationComposerSiteFactory, &CLSID_AnimationComposerSiteFactory>::Error(str, IID_IAnimationComposerSiteFactory, hr);
        delete [] str;
    }
        
    return hr;
} // CAnimationComposerSiteFactory::Error

// ----------------------------------------------------------------------------------------

STDMETHODIMP 
CAnimationComposerSiteFactory::FindBehavior(BSTR bstrBehavior,
                                            BSTR bstrBehaviorURL,
                                            IElementBehaviorSite * pUnkArg,
                                            IElementBehavior ** ppBehavior)
{
    TraceTag((tagAnimCompSiteFactory,
              "CAnimationComposerSiteFactory(%lx)::FindBehavior(%ls, %ls, %#x)",
              this, bstrBehavior, bstrBehaviorURL, pUnkArg));

    CHECK_RETURN_SET_NULL(ppBehavior);
    
    HRESULT hr;

    CComObject<CAnimationComposerSite> *pNew;
    hr = THR(CComObject<CAnimationComposerSite>::CreateInstance(&pNew));
    if (FAILED(hr)) 
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNew->QueryInterface(IID_IElementBehavior, 
                                  reinterpret_cast<void **>(ppBehavior)));
    if (FAILED(hr))
    {
        delete pNew;
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_OUTOFMEMORY, E_UNEXPECTED);
} // CAnimationComposerSiteFactory::FindBehavior

// ----------------------------------------------------------------------------------------

STDMETHODIMP 
CAnimationComposerSiteFactory::GetInterfaceSafetyOptions (REFIID riid, 
                                                          DWORD *pdwSupportedOptions, 
                                                          DWORD *pdwEnabledOptions)
{
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;

    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag2 )
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    
    RRETURN1(hr, E_NOINTERFACE);
} // CAnimationComposerSiteFactory::GetInterfaceSafetyOptions

// ----------------------------------------------------------------------------------------

STDMETHODIMP
CAnimationComposerSiteFactory::SetInterfaceSafetyOptions (REFIID riid, 
                                                          DWORD dwOptionSetMask, 
                                                          DWORD dwEnabledOptions)
{       
    HRESULT hr;

    // If we're being asked to set our safe for scripting or
    // safe for initialization options then oblige
    if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
    {
            // Store our current safety level to return in GetInterfaceSafetyOptions
            m_dwSafety = dwEnabledOptions & dwOptionSetMask;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_NOINTERFACE);
} // CAnimationComposerSiteFactory::SetInterfaceSafetyOptions

// ----------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\targetpxy.h ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

    Animation Composer's Target Proxy.

*******************************************************************************/

#pragma once

#ifndef _TARGETPXY_H
#define _TARGETPXY_H

// The target proxy abstracts the communication with the target 
// object.  This allows us to change the target sniffing strategy 
// without changing the composer object.
class CTargetProxy : public IDispatch,
                     public CComObjectRootEx<CComSingleThreadModel>
{

 public :

    static HRESULT Create (IDispatch *pidispSite, LPOLESTR wzAttributeName, 
                           CTargetProxy **ppcTargetProxy);

    virtual ~CTargetProxy (void);

    virtual HRESULT Detach (void);
    virtual HRESULT GetCurrentValue (VARIANT *pvarValue);
    virtual HRESULT Update (VARIANT *pvarNewValue);

#if DBG
    const _TCHAR * GetName() { return __T("CTargetProxy"); }
#endif

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

        // QI Map
    BEGIN_COM_MAP(CTargetProxy)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP();

 // Internal Methods
 protected :
    
    CTargetProxy (void);
    HRESULT Init (IDispatch *pidispSite, LPOLESTR wzAttributeName);
    HRESULT InitHost (IDispatch *pidispHostElem);
    HRESULT GetDispatchFromScriptEngine(IDispatch *pidispScriptEngine, BSTR bstrID);
    HRESULT FindScriptableTargetDispatch (IDispatch *pidispHostElem, 
                                          LPOLESTR wzAttributeName);
    HRESULT FindTargetDispatchOnStyle (IDispatch *pidispHostElem, 
                                       LPOLESTR wzAttributeName);
    HRESULT FindTargetDispatch (IDispatch *pidispHostElem, 
                                LPOLESTR wzAttributeName);

  // Data
 protected:

    CComPtr<IDispatch>          m_spdispTargetSrc;
    CComPtr<IDispatch>          m_spdispTargetDest;
    LPWSTR                      m_wzAttributeName;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\targetpxy.cpp ===
/*******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Abstract:

	Animation Composer's Target Proxy Implementation

*******************************************************************************/


#include "headers.h"
#include "util.h"
#include "animcomp.h"
#include "targetpxy.h"

const LPOLESTR WZ_EVAL_METHOD = L"eval";
const WCHAR WCH_OM_SEPARATOR = L'.';
const LPOLESTR WZ_OM_SEPARATOR = L".";
const LPOLESTR WZ_VML_SUBPROPERTY = L"value";
const LPOLESTR WZ_STYLEDOT = L"style.";
const WCHAR WZ_CSS_SEPARATOR = L'-';

DeclareTag(tagTargetProxy, "SMIL Animation", 
           "CTargetProxy methods");
DeclareTag(tagTargetProxyValue, "SMIL Animation", 
           "CTargetProxy value get/put");

//+-----------------------------------------------------------------------
//
//  Member:    GetHostDocument
//
//  Overview:  Get the host document for an element
//
//  Arguments: The element's dispatch
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
static HRESULT
GetHostDocument (IDispatch *pidispHostElem, IHTMLDocument2 **ppiDoc)
{
    HRESULT hr;
    CComPtr<IHTMLElement> piElem;
    CComPtr<IDispatch> pidispDoc;

    Assert(NULL != pidispHostElem);
    Assert(NULL != ppiDoc);

    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &piElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(piElem->get_document(&pidispDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pidispDoc->QueryInterface(IID_TO_PPV(IHTMLDocument2, ppiDoc)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // GetHostDocument

//+-----------------------------------------------------------------------
//
//  Member:    InitScriptEngine
//
//  Overview:  Kick start the script engine.  Required prior to calling 
//             'eval'.
//
//  Arguments: The hosting document
//
//  Returns:   void
//
//------------------------------------------------------------------------
static void 
InitScriptEngine (IHTMLDocument2 *piDoc)
{
    HRESULT hr;
   
    CComPtr<IHTMLWindow2>   piWindow2;
    CComVariant             varResult;
    CComBSTR                bstrScript(L"2+2");
    CComBSTR                bstrJS(L"JScript");

    Assert(NULL != piDoc);

    if (bstrScript == NULL ||
        bstrJS     == NULL)
    {
        goto done;
    }

    hr = THR(piDoc->get_parentWindow(&piWindow2));
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(piWindow2->execScript(bstrScript,bstrJS, &varResult));

done: 
    return;
} // InitScriptEngine

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Create
//
//  Overview:  Creates and initializes the target proxy
//
//  Arguments: The dispatch of the host element, attribute name, out param
//
//  Returns:   S_OK, E_INVALIDARG, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Create (IDispatch *pidispHostElem, LPOLESTR wzAttributeName, 
                      CTargetProxy **ppcTargetProxy)
{
    HRESULT hr;

    CComObject<CTargetProxy> * pTProxy;

    if (NULL == ppcTargetProxy)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(CComObject<CTargetProxy>::CreateInstance(&pTProxy));
    if (hr != S_OK)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    *ppcTargetProxy = static_cast<CTargetProxy *>(pTProxy);
    (*ppcTargetProxy)->AddRef();

    hr = THR((*ppcTargetProxy)->Init(pidispHostElem, wzAttributeName));
    if (FAILED(hr))
    {
        (*ppcTargetProxy)->Release();
        *ppcTargetProxy = NULL;
        hr = DISP_E_MEMBERNOTFOUND;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_INVALIDARG, E_OUTOFMEMORY, DISP_E_MEMBERNOTFOUND);
} // CTargetProxy::Create

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::CTargetProxy
//
//  Overview:  Constructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CTargetProxy::CTargetProxy (void) :
    m_wzAttributeName(NULL)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::CTargetProxy()",
              this));
} // ctor

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::~CTargetProxy
//
//  Overview:  Destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CTargetProxy::~CTargetProxy (void)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::~CTargetProxy()",
              this));
    
    if (NULL != m_wzAttributeName)
    {
        delete [] m_wzAttributeName;
        m_wzAttributeName = NULL;
    }
    // Make sure Detach is called.
    IGNORE_HR(Detach());

} // dtor

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::FindTargetDispatchOnStyle
//
//  Overview:  Discern the proper dispatch from this element's style interfaces 
//             for the given attribute.
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::FindTargetDispatchOnStyle (IDispatch *pidispHostElem, LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::FindTargetDispatchOnStyle(%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr;
    CComPtr<IHTMLElement2> spiElement2;
    CComVariant varResult;

    // We must be prepared to fall back for IE4.
    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement2, &spiElement2)));
    if (SUCCEEDED(hr))
    {
        CComPtr<IHTMLCurrentStyle> spiCurrStyle;
        CComPtr<IHTMLStyle> spiRuntimeStyle;

        hr = THR(spiElement2->get_currentStyle(&spiCurrStyle));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiCurrStyle->QueryInterface(IID_TO_PPV(IDispatch, &m_spdispTargetSrc)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiElement2->get_runtimeStyle(&spiRuntimeStyle));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiRuntimeStyle->QueryInterface(IID_TO_PPV(IDispatch, &m_spdispTargetDest)));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        CComPtr<IHTMLElement> spiElement;
        CComPtr<IHTMLStyle> spiStyle;

        hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &spiElement)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiElement->get_style(&spiStyle));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spiStyle->QueryInterface(IID_TO_PPV(IDispatch, &m_spdispTargetSrc)));
        if (FAILED(hr))
        {
            goto done;
        }

        // No distinction between current/runtime style in IE4.
        m_spdispTargetDest = m_spdispTargetSrc;
    }

    // We don't care about the value in the attribute at this time -- just that
    // the attribute is present.
    Assert(m_spdispTargetSrc != NULL);
    hr = THR(GetProperty(m_spdispTargetSrc, wzAttributeName, &varResult));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_spdispTargetDest != NULL);
    hr = THR(GetProperty(m_spdispTargetDest, wzAttributeName, &varResult));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        // If we didn't find the attribute here, 
        // then we need to wipe out these dispatch pointers.
        m_spdispTargetSrc.Release();
        m_spdispTargetDest.Release();
        hr = DISP_E_MEMBERNOTFOUND;
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
} // CTargetProxy::FindTargetDispatchOnStyle

//+-----------------------------------------------------------------------
//
//  Member:    BuildScriptParameters
//
//  Overview:  Build the parameters necessary to talk directly an element's property
//
//  Arguments: 
//              input args : id, attrib name
//              output args : object path, and leaf attribute name.
//              
//              If the attribute name is atomic (something like 'top'
//              as opposed to 'filters.item(1).opacity', then pwzObject 
//              and pwzProperty will come back as NULL strings.  In that case,
//              the caller may use the input parameters to put a new value via
//              a scriptable dispatch.
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
static HRESULT
BuildScriptParameters (LPCWSTR wzID, LPCWSTR wzAttributeName, 
                       BSTR *pbstrObject, BSTR *pbstrProperty)
{
    HRESULT hr;

    Assert(NULL != wzID);
    Assert(NULL != wzAttributeName);

    // Get the last token in the attribute string.
    LPWSTR wzBeginLeafProperty = StrRChrW(wzAttributeName, 
                                          &(wzAttributeName[lstrlenW(wzAttributeName)]), 
                                          WCH_OM_SEPARATOR);

    // Simple attribute name.
    if (NULL == wzBeginLeafProperty)
    {
        *pbstrObject = NULL;
        *pbstrProperty = NULL;
    }
    else
    {
        unsigned int uObjectSize = lstrlenW(wzID) + lstrlenW(wzAttributeName) + 1;
        // The separator slot in this string accounts for the trailing NULL.
        unsigned int uPropertySize = lstrlenW(wzBeginLeafProperty);

        *pbstrObject = ::SysAllocStringLen(NULL, uObjectSize);
        *pbstrProperty = ::SysAllocStringLen(NULL, uPropertySize);

        if ((NULL == (*pbstrObject)) || (NULL == (*pbstrProperty)))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        ZeroMemory(*pbstrObject, uObjectSize * sizeof(WCHAR));
        ZeroMemory(*pbstrProperty, uPropertySize * sizeof(WCHAR));

        // Glom the id together with the attribute string.
        StrCpyW((*pbstrObject), wzID);
        StrCatW((*pbstrObject), WZ_OM_SEPARATOR);
        StrNCatW((*pbstrObject), wzAttributeName, 
                 lstrlenW(wzAttributeName) - lstrlenW(wzBeginLeafProperty) + 1);
        
        // Isolate the last token from the leading separator.
        StrCpyW((*pbstrProperty), &(wzBeginLeafProperty[1]));        
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // BuildScriptParameters

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::GetDispatchFromScriptEngine
//
//  Overview:  Discern a dispatch for this element/attribute using 
//             the script engine.  This method potentially changes 
//             the value of m_wzAttributeName to reflect something
//             we can query directly for a value.
//
//  Arguments: the script engine dispatch and the element id
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::GetDispatchFromScriptEngine(IDispatch *pidispScriptEngine, BSTR bstrID)
{
    HRESULT hr;
    CComVariant varArg;
    CComVariant varResultDispatch;
    CComVariant varResultPropGet;
    CComBSTR bstrObjectName;
    CComBSTR bstrPropertyName;

    // Build names we can query the script engine for.
    hr = THR(BuildScriptParameters(bstrID, m_wzAttributeName, &bstrObjectName, &bstrPropertyName));
    if (FAILED(hr))
    {
        goto done;
    }

    // Both the object and property names must be valid in order to rely on 
    // the results of BuildScriptParameters.  If we got NULL back for either 
    // or both, we'll just use our current ID and attribute values.
    V_VT(&varArg) = VT_BSTR;
    if ((bstrObjectName == NULL) || (bstrPropertyName == NULL))
    {
        V_BSTR(&varArg) = ::SysAllocString(bstrID);
        if (NULL == V_BSTR(&varArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    else
    {
        V_BSTR(&varArg) = ::SysAllocString(bstrObjectName);
        if (NULL == V_BSTR(&varArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        delete [] m_wzAttributeName;
        m_wzAttributeName = CopyString(bstrPropertyName);
        if (NULL == m_wzAttributeName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = THR(CallMethod(pidispScriptEngine, WZ_EVAL_METHOD, &varResultDispatch, &varArg));
    if (SUCCEEDED(hr) &&
        VT_DISPATCH == V_VT(&varResultDispatch))
    {
        varResultPropGet.Clear();
        hr = THR(GetProperty(V_DISPATCH(&varResultDispatch), m_wzAttributeName, &varResultPropGet));
        if (FAILED(hr) ||
            (varResultPropGet.vt      == VT_BSTR &&
             varResultPropGet.bstrVal == NULL))
        {
            hr = E_FAIL;
        }
    }
    if (FAILED(hr) ||
        VT_DISPATCH != V_VT(&varResultDispatch))
    {
        // Fall back and try document.all
        CComBSTR bstrDocumentAll;
        
        bstrDocumentAll = L"document.all.";
        bstrDocumentAll.AppendBSTR(varArg.bstrVal);
        VariantClear(&varArg);
        VariantClear(&varResultDispatch);
        V_VT(&varArg) = VT_BSTR;
        V_BSTR(&varArg) = ::SysAllocString(bstrDocumentAll);
        if (NULL == V_BSTR(&varArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
      
        hr = THR(CallMethod(pidispScriptEngine, WZ_EVAL_METHOD, &varResultDispatch, &varArg));
        if (FAILED(hr) ||
            VT_DISPATCH != V_VT(&varResultDispatch))
        {
            hr = E_FAIL;
            goto done;
        }
        varResultPropGet.Clear();
        hr = THR(GetProperty(V_DISPATCH(&varResultDispatch), m_wzAttributeName, &varResultPropGet));
        if (FAILED(hr) ||
            (varResultPropGet.vt      == VT_BSTR &&
            varResultPropGet.bstrVal == NULL))
        {
            hr = E_FAIL;
            goto done;
        }
    }

    // If we got a I_DISPATCH back we need to try "value" as that is what VML uses.
    if (varResultPropGet.vt == VT_DISPATCH)
    {
        varResultDispatch.Clear();
        varResultDispatch.Copy(&varResultPropGet);
        varResultPropGet.Clear();
        hr = THR(GetProperty(V_DISPATCH(&varResultDispatch), WZ_VML_SUBPROPERTY, &varResultPropGet));
        if (FAILED(hr)||
            varResultPropGet.pvarVal == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        if (m_wzAttributeName)
        {
            delete [] m_wzAttributeName;
        }
        m_wzAttributeName = CopyString(WZ_VML_SUBPROPERTY);
    }

    m_spdispTargetSrc = V_DISPATCH(&varResultDispatch);
    m_spdispTargetDest = V_DISPATCH(&varResultDispatch);

    hr = S_OK;
done :

    RRETURN(hr);
} // CTargetProxy::GetDispatchFromScriptEngine

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::FindScriptableTargetDispatch
//
//  Overview:  Discern a scriptable dispatch for this element/attribute.
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::FindScriptableTargetDispatch (IDispatch *pidispHostElem, 
                                            LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::FindScriptableTargetDispatch(%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr;
    CComPtr<IHTMLElement> spElem;
    CComPtr<IHTMLDocument2> spDoc;
    CComPtr<IHTMLWindow2> spWindow;
    CComPtr<IDispatch> spdispScriptEngine;
    CComBSTR bstrID;
    CComVariant varErrorFunction;
    CComVariant varNewError;
    bool fMustRemoveID = false;
    
    // Ensure that this element has an id.  If not, create one for
    // temporary use.
    hr = THR(pidispHostElem->QueryInterface(IID_TO_PPV(IHTMLElement, &spElem)));
    if (FAILED(hr))
    {
        goto done;
    }

    // We require an ID here.
    IGNORE_HR(spElem->get_id(&bstrID));
    if ((bstrID == NULL) || (0 == bstrID.Length()))
    {
        CComPtr<IHTMLUniqueName> spUniqueName;

        hr = THR(spElem->QueryInterface(IID_TO_PPV(IHTMLUniqueName, &spUniqueName)));
        if (FAILED(hr))
        {
            goto done;
        }

        // This causes an ID to be assigned to the element.
        hr = THR(spUniqueName->get_uniqueID(&bstrID));

        fMustRemoveID = true;
        Assert(bstrID != NULL);

        if (FAILED(hr))
        {
            goto done;
        }


        TraceTag((tagTargetProxy,
                  "CTargetProxy(%lx)::FindScriptableTargetDispatch : Generated ID is %ls",
                  this, bstrID));
    }

    hr = GetHostDocument(pidispHostElem, &spDoc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spDoc->get_Script(&spdispScriptEngine));
    if (FAILED(hr))
    {
        goto done;
    }

    // Need to save off onerror function and put our own on
    // we addref before we send it to the ScriptEngine ( script enigne WILL release)
    this->AddRef();
    varNewError.vt = VT_DISPATCH;
    varNewError.pdispVal = this;

    hr = spDoc->get_parentWindow(&spWindow);
    if (FAILED(hr))
    {
        goto done;
    } 
    hr = spWindow->get_onerror(&varErrorFunction);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spWindow->put_onerror(varNewError);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetDispatchFromScriptEngine(spdispScriptEngine, bstrID);
    if (FAILED(hr))
    {
        CComBSTR bTemp;

        bTemp = bstrID.Copy();
        bTemp.Append(L".style");
        hr = GetDispatchFromScriptEngine(spdispScriptEngine, bTemp);
    }

    // Need to replace the users onerror function..
    spWindow->put_onerror(varErrorFunction);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done :

    // Must clean things up.
    if (fMustRemoveID)
    {
        IGNORE_HR(spElem->put_id(NULL));
    }

    RRETURN2(hr, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::FindTargetDispatch
//
//  Overview:  Discern the proper dispatch from this element for the given attribute.
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, DISP_E_MEMBERNOTFOUND
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::FindTargetDispatch (IDispatch *pidispHostElem, LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::FindTargetDispatch(%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr;
    bool bVML = IsVMLObject(pidispHostElem);

    if (bVML)
    {
        hr = FindScriptableTargetDispatch(pidispHostElem, wzAttributeName); 
        if (FAILED(hr))
        {
            hr = FindTargetDispatchOnStyle(pidispHostElem, wzAttributeName);       
        }
    }
    else
    {
        hr = FindTargetDispatchOnStyle(pidispHostElem, wzAttributeName);
    }

    if (FAILED(hr))
    {
        WCHAR wzTrimmedAttributeName[INTERNET_MAX_URL_LENGTH];
        WCHAR wzTrimmedAttributeNameWithoutDashes[INTERNET_MAX_URL_LENGTH];

        // Prevent overflow.
        if (INTERNET_MAX_URL_LENGTH < (ocslen(wzAttributeName) - 1))
        {
            hr = E_FAIL;
            goto done;
        }

        ZeroMemory(wzTrimmedAttributeName,sizeof(WCHAR)*INTERNET_MAX_URL_LENGTH);
        ZeroMemory(wzTrimmedAttributeNameWithoutDashes,sizeof(WCHAR)*INTERNET_MAX_URL_LENGTH);

        // Lets see if there is a style. if so strip it off and try the sytle again..
        if ((StrCmpNIW(wzAttributeName, WZ_STYLEDOT, 6) == 0))
        {
            StrCpyNW(wzTrimmedAttributeName,wzAttributeName+6,((int) ocslen(wzAttributeName)) -5);
            hr = FindTargetDispatchOnStyle(pidispHostElem, wzTrimmedAttributeName);
        }
        else
        {
            StrCpyNW(wzTrimmedAttributeName,wzAttributeName, INTERNET_MAX_URL_LENGTH);
        }

        // We need to strip out the '-' (WZ_CSS_SEPARATOR) and try again since we need to support border-top-color form as well as the 
        // standard bordertopcolor.
        if (FAILED(hr))    
        {
            int count =0;

            for (int i=0; i< (int) ocslen(wzTrimmedAttributeName); i++)
            {   
                if (wzTrimmedAttributeName[i] != WZ_CSS_SEPARATOR)
                {
                    wzTrimmedAttributeNameWithoutDashes[count++] = wzTrimmedAttributeName[i];
                }
            }
            hr = FindTargetDispatchOnStyle(pidispHostElem, wzTrimmedAttributeNameWithoutDashes);
            StrCpyW(wzTrimmedAttributeName, wzTrimmedAttributeNameWithoutDashes);
        }
        if (FAILED(hr))
        {
            hr = FindScriptableTargetDispatch(pidispHostElem, wzAttributeName); 
            if (FAILED(hr))
            {
                TraceTag((tagError,
                          "CTargetProxy(%lx)::FindTargetDispatch(%lx, %ls) cannot find attribute on targetElement",
                          this, pidispHostElem, wzAttributeName));          
                goto done;
            }
        }
        else 
        {
            if (m_wzAttributeName)
            {
                delete [] m_wzAttributeName ;
            }
            m_wzAttributeName = CopyString(wzTrimmedAttributeName);
        }
    }

    hr = S_OK;
done :
    RRETURN2(hr, DISP_E_MEMBERNOTFOUND, E_FAIL);
} // CTargetProxy::FindTargetDispatch

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::InitHost
//
//  Overview:  Initialize the host
//
//  Arguments: the host element dispatch
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::InitHost (IDispatch *pidispHostElem)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::InitHost(%lx)",
              this, pidispHostElem));

    HRESULT hr;
    CComPtr<IHTMLDocument2> piDoc;

    hr = GetHostDocument(pidispHostElem, &piDoc);
    if (FAILED(hr))
    {
        goto done;
    }

    InitScriptEngine(piDoc);

    hr = S_OK;
done :
    RRETURN(hr);
} // InitHost

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Init
//
//  Overview:  Initialize the target proxy
//
//  Arguments: the host element dispatch, attribute name
//
//  Returns:   S_OK, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Init (IDispatch *pidispHostElem, LPOLESTR wzAttributeName)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::Init (%lx, %ls)",
              this, pidispHostElem, wzAttributeName));

    HRESULT hr = S_OK;

    if (NULL != wzAttributeName)
    {
        m_wzAttributeName = CopyString(wzAttributeName);
        if (NULL == m_wzAttributeName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = InitHost (pidispHostElem);
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // Sniff the target element for the attribute name.
    hr = FindTargetDispatch(pidispHostElem, wzAttributeName);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_spdispTargetSrc != NULL);
    Assert(m_spdispTargetDest != NULL);

    hr = S_OK;
done :

    if (FAILED(hr))
    {
        IGNORE_HR(Detach());
    }

    RRETURN3(hr, E_UNEXPECTED, DISP_E_MEMBERNOTFOUND, E_OUTOFMEMORY);
} // CTargetProxy::Init

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Detach
//
//  Overview:  Detach all external references in the target proxy
//
//  Arguments: none
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Detach (void)
{
    TraceTag((tagTargetProxy,
              "CTargetProxy(%lx)::Detach()",
              this));

    HRESULT hr;

    if (NULL != m_wzAttributeName)
    {
        delete [] m_wzAttributeName;
        m_wzAttributeName = NULL;
    }

    if (m_spdispTargetSrc != NULL)
    {
        m_spdispTargetSrc.Release();
    }

    if (m_spdispTargetDest != NULL)
    {
        m_spdispTargetDest.Release();
    }

    hr = S_OK;
done :
    RRETURN(hr);
} // CTargetProxy::Detach

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::GetCurrentValue
//
//  Overview:  Get the current value of target's attribute
//
//  Arguments: the attribute value
//
//  Returns:   S_OK, E_INVALIDARG, E_UNEXPECTED
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::GetCurrentValue (VARIANT *pvarValue)
{
    HRESULT hr;

    if (NULL == pvarValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_spdispTargetSrc == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(::VariantClear(pvarValue));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(GetProperty(m_spdispTargetSrc, m_wzAttributeName, pvarValue));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;

#if (0 && DBG)
    {
        CComVariant varValue;
        varValue.Copy(pvarValue);
        ::VariantChangeTypeEx(&varValue, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        TraceTag((tagTargetProxyValue,
                  "CTargetProxy(%p)::GetCurrentValue(%ls = %ls)",
                  this, m_wzAttributeName, V_BSTR(&varValue)));
    }
#endif


done :
    RRETURN2(hr, E_INVALIDARG, E_UNEXPECTED);
} // CTargetProxy::GetCurrentValue

//+-----------------------------------------------------------------------
//
//  Member:    CTargetProxy::Update
//
//  Overview:  Update the target's attribute
//
//  Arguments: the new attribute value
//
//  Returns:   S_OK, E_INVALIDARG
//
//------------------------------------------------------------------------
HRESULT
CTargetProxy::Update (VARIANT *pvarNewValue)
{
    HRESULT hr;

#if (0 && DBG)
    {
        CComVariant varValue;
        varValue.Copy(pvarNewValue);
        ::VariantChangeTypeEx(&varValue, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        TraceTag((tagTargetProxyValue,
                  "CTargetProxy(%p)::Update (%ls = %ls)",
                  this, m_wzAttributeName, V_BSTR(&varValue)));
    }
#endif

    if (NULL == pvarNewValue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_spdispTargetDest == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(PutProperty(m_spdispTargetDest, m_wzAttributeName, pvarNewValue));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
} // CTargetProxy::Update




///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CTargetProxy::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CTargetProxy::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CTargetProxy::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//      Currently this is only used for OnError.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CTargetProxy::Invoke( DISPID id,
                           REFIID riid,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pDispParams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pExcepInfo,
                           UINT *puArgErr)
{
    HRESULT hr = S_OK;

    if ( DISPATCH_METHOD == wFlags)
    {
        pvarResult->vt = VT_BOOL;    
        pvarResult->boolVal = VARIANT_TRUE;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\smilpath.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: smilpath.h
//
//  Contents: SMIL path
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _SMILPATH_H
#define _SMILPATH_H

#include "timeparser.h"

class CTIMEMotionAnimation;

#define IID_ISMILPath __uuidof(ISMILPath)


//+-------------------------------------------------------------------------------------
//
// ISMILPath
//
//--------------------------------------------------------------------------------------

interface 
__declspec(uuid("cbe68ca2-47b9-41ff-a8f4-d2f810bd53c5")) 
ISMILPath :
    public IUnknown
{
    //
    // Interpolation functions
    //

    STDMETHOD(Interpolate)(double dblProgress, POINTF * pPoint) = 0;
    
    STDMETHOD(InterpolateSegment)(int curseg, double dblSegProgress, POINTF * pNewPos) = 0;

    STDMETHOD(InterpolatePaced)(double dblProgress, POINTF * pPoint) = 0;

    //
    // utility functions and accessors
    //

    STDMETHOD(Init)(CTIMEMotionAnimation * pAnimElm) = 0;

    STDMETHOD(Detach)() = 0;

    STDMETHOD_(void, ClearPath)() = 0;

    STDMETHOD(SetPath)(CTIMEPath ** pPath, long numPath, long numMoveTo) = 0;

    STDMETHOD(IsValid)(bool * pfValid) = 0;
    
    STDMETHOD(GetPoint)(int nIndex, POINTF * pPoint) = 0;
    
    STDMETHOD(GetNumPoints)(int * pnNumPoints) = 0;

    STDMETHOD(GetNumSeg)(int * pnNumSeg) = 0;

    STDMETHOD(GetSegmentProgress)(double dblProgress, int * pnSeg, double * pdblSegProgress) = 0; 
};


//+-------------------------------------------------------------------------------------
//
// CSMILPath factory method
//
//--------------------------------------------------------------------------------------

HRESULT CreateSMILPath(CTIMEMotionAnimation * pAnimElm, ISMILPath ** ppSMILPath);


//+-------------------------------------------------------------------------------------
//
// CSMILPath
//
//--------------------------------------------------------------------------------------

class CSMILPath : 
    public ISMILPath
{
public:
    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CSMILPath();
    virtual ~CSMILPath();

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    //
    // ISMILPath
    //

    // interpolation methods
    STDMETHOD(Interpolate)(double dblProgress, POINTF * pPoint);
    STDMETHOD(InterpolateSegment)(int curseg, double dblSegProgress, POINTF * pNewPos);
    STDMETHOD(InterpolatePaced)(double dblProgress, POINTF * pPoint);

    // utility methods
    STDMETHOD(Init)(CTIMEMotionAnimation * pAnimElm);
    STDMETHOD(Detach)();
    STDMETHOD_(void, ClearPath)();
    STDMETHOD(SetPath)(CTIMEPath ** pPath, long numPath, long numMoveTo);
    STDMETHOD(IsValid)(bool * pfValid) { *pfValid = IsPathValid(); return S_OK; }
    STDMETHOD(GetPoint)(int nIndex, POINTF * pPoint);
    STDMETHOD(GetNumPoints)(int * pnNumPoints) { *pnNumPoints = m_numPath; return S_OK; }
    STDMETHOD(GetNumSeg)(int * pnNumSeg) { *pnNumSeg = m_numPath - m_numMOVETO; return S_OK; }
    STDMETHOD(GetSegmentProgress)(double dblProgress, int * pnSeg, double * pdblSegProgress); 

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:
    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // hide the copy constructor
    CSMILPath(CSMILPath &);

    bool IsPathValid();
    HRESULT CreateSegmentMap();
    HRESULT MapSegment(int seg, int & index);
    POINTF CubicBezier(POINTF ptStart, POINTF *aryPoints, double curPorgress);
    LPWSTR GetID();
    HRESULT CreateLengthMap();
    long GetNumSeg() { return m_numPath - m_numMOVETO; }
    void ClearLengthMap();
    void ClearSegmentMap();
    double GetLength();
    HRESULT ComputeSegmentLength(int seg, double & segLength);
    HRESULT GetSegmentEndPoints(int seg, int & startIndex, int & endIndex);
    double GetDistance(POINTF & p1, POINTF & p2);
    double GetBezierLength(POINTF & startPoint, POINTF * pts);
    HRESULT GetCumulativeLength(int seg, double & segLength);

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

private:
    //+--------------------------------------------------------------------------------
    //
    // Private Methods
    //
    //---------------------------------------------------------------------------------

#if DBG
    int PrintPath(long numPath, long numMOVETO, CTIMEPath ** pPath);
#endif

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    long         m_numPath;
    long         m_numMOVETO;
    int *        m_pSegmentMap;
    CTIMEPath ** m_pPath;
    double *     m_pLengthMap;

    long m_cRef;

    // this is used only to get the ID for debugging
    CTIMEMotionAnimation * m_pAnimElm;
};


#endif // _SMILPATH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\anim\smilpath.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: smilpath.cpp
//
//  Contents: SMIL path
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "smilpath.h"
#include "animmotion.h"

DeclareTag(tagSMILPath, "SMIL Animation", "SMIL Path")


//+-------------------------------------------------------------------------------------
//
// CSMILPath factory method
//
//--------------------------------------------------------------------------------------

HRESULT CreateSMILPath(CTIMEMotionAnimation * pAnimElm, ISMILPath ** ppSMILPath)
{
    HRESULT hr = E_FAIL;
    CSMILPath * pPath = NULL;
    
    CHECK_RETURN_NULL(pAnimElm);
    CHECK_RETURN_SET_NULL(ppSMILPath);

    pPath = new CSMILPath;
    if (NULL == pPath)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pPath->Init(pAnimElm));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pPath->QueryInterface(IID_TO_PPV(ISMILPath, ppSMILPath)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        delete pPath;
    }
    return hr;
}


//+-------------------------------------------------------------------------------------
//
// CSMILPath Methods
//
//--------------------------------------------------------------------------------------

CSMILPath::CSMILPath() :
    m_numPath(0),
    m_numMOVETO(0),
    m_pSegmentMap(NULL),
    m_pLengthMap(NULL),
    m_pPath(NULL),
    m_pAnimElm(NULL),
    m_cRef(0)
{

}

CSMILPath::~CSMILPath()
{
    CSMILPath::ClearPath();
}


STDMETHODIMP
CSMILPath::Init(CTIMEMotionAnimation * pAnimElm)
{
    Assert(pAnimElm);

    m_pAnimElm = pAnimElm;

    return S_OK;
}

STDMETHODIMP
CSMILPath::Detach()
{
    m_pAnimElm = NULL;

    return S_OK;
}


STDMETHODIMP_(void)
CSMILPath::ClearPath()
{
    // delete the points
    if (m_pPath  != NULL &&
        *m_pPath != NULL)
    {
        for (int i = 0; i < m_numPath; i++)
        {
            delete m_pPath[i];
        }

        delete [] m_pPath;
        m_pPath = NULL;
    } 

    // clear the maps
    ClearSegmentMap();
    ClearLengthMap();
    
    // reset counts
    m_numPath = 0;
    m_numMOVETO = 0;
}


LPWSTR 
CSMILPath::GetID() 
{ 
    if (m_pAnimElm)
    {   
        return m_pAnimElm->GetID();
    }
    else
    {
        return NULL;
    }
}


STDMETHODIMP
CSMILPath::SetPath(CTIMEPath ** pPath, long numPath, long numMoveTo)
{
    HRESULT hr = E_FAIL;

    // clear the existing path
    ClearPath();

    // skip invalid paths
    // ASSUMES path always starts with a moveto, so there must at least be two points in a valid path
    if (!pPath            ||         // need points
        (numPath < 2)     ||         // need at least two points
        (numMoveTo < 1)   ||         // need at least 1 moveto
        ((numPath - numMoveTo) < 1)) // need at least one segment
    {
        hr = E_FAIL;
        goto done;
    }
    else
    {
        Assert(!m_pPath);
        Assert(!m_numPath);
        Assert(!m_numMOVETO);

        m_pPath = pPath;
        m_numPath = numPath;
        m_numMOVETO = numMoveTo;
    }

    TraceTag((tagSMILPath, "End of Parsed path: (%d)",
        PrintPath(numPath, numMoveTo, pPath)));

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CSMILPath::GetSegmentProgress(double dblProgress, int * pnSeg, double * pdblSegProgress)
{
    HRESULT hr = E_FAIL;
    long curSeg = 0;
    double curFractionalSeg = 0.0;
    double curProgress = 0.0;
    
    CHECK_RETURN_NULL(pnSeg);
    CHECK_RETURN_NULL(pdblSegProgress);

    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // get the fractional segment number
    curFractionalSeg = dblProgress * GetNumSeg();

    // get the (integer) segment number
    curSeg = static_cast<int>(curFractionalSeg);

    // get the progress in the current segment
    curProgress = curFractionalSeg - curSeg;

    hr = S_OK;
done:
    *pnSeg = curSeg;
    *pdblSegProgress = curProgress;

    return hr;
}


STDMETHODIMP
CSMILPath::Interpolate(double dblProgress, POINTF * pPoint)
{
    HRESULT hr = E_FAIL;
    int curSeg;
    double curProgress;
    
    CHECK_RETURN_NULL(pPoint);

    hr = THR(GetSegmentProgress(dblProgress, &curSeg, &curProgress));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(InterpolateSegment(curSeg, curProgress, pPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::Interpolate(prog=%g newPos={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            dblProgress,
            pPoint->x,
            pPoint->y
            ));

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CSMILPath::InterpolatePaced(double dblProgress, POINTF * pPoint)
{
    HRESULT hr = E_FAIL;
    int curSeg;
    int numSeg;
    double dblCumLength;
    double dblCurDistance;
    double dblCurProgress;
    double dblPrevCumLength;
    
    CHECK_RETURN_NULL(pPoint);

    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // clamp the progress
    dblProgress = Clamp(0.0, dblProgress, 1.0);

    dblCurDistance = dblProgress * GetLength();

    numSeg = GetNumSeg();

    // find the current segment
    for (curSeg = 0; curSeg < numSeg; curSeg++)
    {
        //
        // dilipk this should be a binary search (ie6 bug #14216)
        //

        dblCumLength = 0.0;

        hr = THR(GetCumulativeLength(curSeg, dblCumLength));
        if (FAILED(hr))
        {
            goto done;
        }

        if (dblCurDistance <= dblCumLength)
        {
            break;
        }
    }

    dblPrevCumLength = 0.0;

    if (curSeg > 0)
    {
        hr = THR(GetCumulativeLength(curSeg-1, dblPrevCumLength));
        if (FAILED(hr))
        {
            goto done;
        }
    }
        
    dblCurProgress = (dblCurDistance - dblPrevCumLength) / (dblCumLength - dblPrevCumLength);

    //
    //      dilipk: using linear sampling within bezier curve segments. This is an approximation
    //      that works reasonably well for bezier curves without sharp changes in curvature or when
    //      control points are relatively uniform in spacing.
    //      To do this the right way when the above assumptions are not valid, we need to integrate 
    //      along the length of the curve for each interpolation (unless we cache values). This could 
    //      be expensive and we should consider if we feel this is worth the added computation.
    //

    hr = THR(InterpolateSegment(curSeg, dblCurProgress, pPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::InterpolatePaced(prog=%g newPos={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            dblProgress,
            pPoint->x,
            pPoint->y
            ));

    hr = S_OK;
done:
    return hr;
}

double 
CSMILPath::GetLength()
{
    double dblLength = 0;
    HRESULT hr = E_FAIL;

    if (!IsPathValid())
    {
        goto done;
    }
    
    hr = THR(GetCumulativeLength(GetNumSeg(), dblLength));  
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return dblLength;
}


inline
bool 
CSMILPath::IsPathValid()
{
    // path is already validated in SetPath. Need only check m_pPath
    return (m_pPath ? true : false);
}


inline
void 
CSMILPath::ClearLengthMap()
{
    delete [] m_pLengthMap;
    m_pLengthMap = NULL;
}


inline
void 
CSMILPath::ClearSegmentMap()
{
    delete [] m_pSegmentMap;
    m_pSegmentMap = NULL;
}


double
CSMILPath::GetDistance(POINTF & p1, POINTF & p2)
{
    double dX = (p1.x - p2.x);
    double dY = (p1.y - p2.y);
    return sqrt((dX*dX) + (dY*dY));  
}


double 
CSMILPath::GetBezierLength(POINTF & startPoint, POINTF * pts)
{
    //
    //        ISSUE : this is not the best way to do this. To avoid wasted computations for sub-pixel segments,
    //        number of segments should be adaptive to the segment length
    //

    POINTF lastPoint = startPoint;
    double dblDistance = 0;

    for (double seg = 0.01; seg <= 1.0; seg += 0.01)
    {
        POINTF curPoint = CubicBezier(startPoint, pts, seg);
        dblDistance += GetDistance(lastPoint, curPoint);
        lastPoint = curPoint;
    }

    return dblDistance;
}


HRESULT
CSMILPath::GetCumulativeLength(int seg, double & segLength)
{
    HRESULT hr = E_FAIL;

    if (!m_pLengthMap)
    {
        hr = THR(CreateLengthMap());
        if (FAILED(hr))
        {
            goto done;
        }

        // sanity check
        if (!m_pLengthMap)
        {
            Assert(false);
            hr = E_FAIL;
            goto done;
        }
    }

    // clamp seg to within path
    seg = Clamp(0, seg, GetNumSeg()-1);

    // look up cumulative length
    segLength = m_pLengthMap[seg];

    hr = S_OK;
done:
    return hr;
}


HRESULT 
CSMILPath::ComputeSegmentLength(int seg, double & segLength)
{
    HRESULT hr = E_FAIL;
    int startIndex = 0;
    int endIndex = 0;
    POINTF startPoint = {0.0, 0.0};
    POINTF endPoint = {0.0, 0.0};
    POINTF * pts = NULL;

    // get start and end point indices
    hr = THR(GetSegmentEndPoints(seg, startIndex, endIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the start point
    hr = THR(GetPoint(startIndex, &startPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the end point and length
    if (PathBezier == m_pPath[endIndex]->GetType())
    {
        pts = m_pPath[endIndex]->GetPoints();
        if (NULL == pts)
        {
            hr = E_FAIL;
            goto done;
        }

        segLength = GetBezierLength(startPoint, pts);
    }
    else
    {
        // get the end point
        hr = THR(GetPoint(endIndex, &endPoint));
        if (FAILED(hr))
        {
            goto done;
        }

        segLength = GetDistance(startPoint, endPoint);
    }

    hr = S_OK; 
done:
    delete [] pts;
    return hr;
}


HRESULT
CSMILPath::CreateLengthMap()
{
    HRESULT hr = E_FAIL;
    int i;
    int numSeg;

    // delete the old map
    ClearLengthMap();

    // bail if path is invalid
    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // compute the number of segments
    numSeg = GetNumSeg();
    
    // allocate the map
    m_pLengthMap = new double [numSeg];
    if (!m_pLengthMap)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    for (i = 0; i < numSeg; i++)
    {
        double segLength = 0.0;

        hr = THR(ComputeSegmentLength(i, segLength));
        if (FAILED(hr))
        {
            goto done;
        }
        
        // compute the cumulative length
        m_pLengthMap[i] = segLength + (i > 0 ? m_pLengthMap[i-1] : 0);        
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        ClearLengthMap();
    }

    return hr;
}


//
// Creates a mapping between segment number and (index of) the start-point of the segment in the m_pPath array
//
// ASSUMES path always starts with a moveto
//
// -1 indicates no mapping
HRESULT
CSMILPath::CreateSegmentMap()
{
    HRESULT hr = E_FAIL;
    int i;
    int curSeg;
    int numSeg;

    // delete the old map
    ClearSegmentMap();

    // bail if path is invalid
    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // compute the number of segments
    numSeg = GetNumSeg();

    // alloc the new map
    m_pSegmentMap = new int [numSeg];
    if (!m_pSegmentMap)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    //
    // compute the mapping 
    // 

    for (curSeg = -1, i = 1; i < m_numPath; i++)
    {
        // map the segment number to (index of) it's start-point in the points array
        // The logic is that the end-point of a segment cannot be a move-to
        // so we skip all move-to's
        if (PathMoveTo == m_pPath[i]->GetType())
        {
            continue;
        }
        else
        {
            curSeg++;
            
            // subtract 1 because we are testing for the end-point of the segment
            if (curSeg < numSeg)
            {
                m_pSegmentMap[curSeg] = i - 1;
            }
            else
            {
                // this shouldn't happen
                Assert(false);
            }
        }
    }

    if (-1 == curSeg)
    {
        // something is really wrong
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:

    if (FAILED(hr))
    {
        ClearSegmentMap();
    }

    return hr;
}


// assumes zero-based segment numbers
HRESULT
CSMILPath::MapSegment(int seg, int & index)
{
    HRESULT hr = E_FAIL;
    int numSeg;

    // bail if path is invalid
    if (!IsPathValid())
    {
        hr = E_FAIL;
        goto done;
    }

    // bail if seg is invalid
    numSeg = GetNumSeg();
    if (0 == numSeg)
    {
        hr = E_FAIL;
        goto done;
    }

    // create the segment map if it doesn't exist
    if (!m_pSegmentMap)
    {
        hr = THR(CreateSegmentMap());
        if (FAILED(hr))
        {
            goto done;
        }

        if (!m_pSegmentMap)
        {
            Assert(false);
            hr = E_FAIL;
            goto done;
        }
    }

    // clamp seg to within path
    seg = Clamp(0, seg, numSeg-1);

    index = m_pSegmentMap[seg];

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::MapSegment(seg=%d, index=%d)",
            this, 
            (GetID()?GetID():L"No id"), 
            seg,
            index
            ));

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CSMILPath::GetPoint(int nIndex, POINTF * pPoint)
{
    HRESULT hr = E_FAIL;
    PathType pt;
    POINTF * pts = NULL;
    int i;

    CHECK_RETURN_NULL(pPoint);

    nIndex = Clamp(0, nIndex, m_numPath - 1);

    pPoint->x = pPoint->y = 0.0;
    pt = m_pPath[nIndex]->GetType();
    pts = m_pPath[nIndex]->GetPoints();

    switch(pt)
    {
        case PathLineTo: 
        case PathHorizontalLineTo: 
        case PathVerticalLineTo: 
        case PathMoveTo:
            if (NULL != pts)
            {
                *pPoint = pts[0];
            }
            else
            {
                hr = E_FAIL;
                goto done;
            }
            break;

        case PathBezier:
            if (NULL != pts)
            {
                *pPoint = pts[2];
            }
            else
            {
                hr = E_FAIL;
                goto done;
            }
            break;

        case PathClosePath:
            {
                // This like a LineTo to the beginning of the subpath
                // so return the coordinates for the beginning of the subpath

                //
                // TODO: dilipk: compute and store point during parsing to eliminate this recomputation
                //

                // scan backwards for the beginning of the subpath
                for (i = nIndex - 1; i >= 0; i --)
                {
                    if (PathMoveTo == m_pPath[i]->GetType())
                    {
                        hr = THR(GetPoint(i, pPoint));
                        if (FAILED(hr))
                        {
                            goto done;
                        }
                        // break out of the for loop
                        break;
                    }
                }
                
                // sanity check to make sure we found a preceeding move-to. This has to exist because
                // all paths begin with a move-to.
                if (i < 0)
                {
                    Assert(false);
                    hr = E_FAIL;
                    goto done;
                }
            }
            break;

        case PathNotSet:
        default:
            hr = E_FAIL;
            goto done;
            break; //lint !e527
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::GetPoint(nIndex=%d, point={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            nIndex,
            pPoint->x,
            pPoint->y
            ));

    hr = S_OK;
done:
    delete [] pts;
    return hr;
}


POINTF 
CSMILPath::CubicBezier(POINTF ptStart, POINTF *aryPoints, double curPorgress)
{
    double cpm1,cpm13,cp3;
    double x,y;
    POINTF p,p1,p4;
    // This should either be to ORIG or the origin as specified.
    p1.x = ptStart.x;
    p1.y = ptStart.y;
    p4.x = aryPoints[2].x;
    p4.y = aryPoints[2].y;

    cpm1 = 1 - curPorgress;
    cpm13 = cpm1 * cpm1 * cpm1;
    cp3 = curPorgress * curPorgress * curPorgress;

    x = (cpm13*p1.x + 3*curPorgress*cpm1*cpm1*aryPoints[0].x + 3*curPorgress*curPorgress*cpm1*aryPoints[1].x + cp3*p4.x);
    y = (cpm13*p1.y + 3*curPorgress*cpm1*cpm1*aryPoints[0].y + 3*curPorgress*curPorgress*cpm1*aryPoints[1].y + cp3*p4.y);

    p.x = (float) Round(x);
    p.y = (float) Round(y);
  
    return(p);
}


HRESULT 
CSMILPath::GetSegmentEndPoints(int seg, int & startIndex, int & endIndex)
{
    HRESULT hr = E_FAIL;
    
    // init the out params
    startIndex = 0;
    endIndex = 0;

    // get start point index
    hr = THR(MapSegment(seg, startIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    // check start index
    if (startIndex > (m_numPath - 2))
    {
        Assert(false);
        hr = E_FAIL;
        goto done;
    }

    // get end point index
    endIndex = startIndex + 1;

    // check end point index
    if (PathMoveTo == m_pPath[endIndex]->GetType())
    {
        Assert(false);
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK; 
done:
    return hr;
}


STDMETHODIMP
CSMILPath::InterpolateSegment(int curseg, double dblCurProgress, POINTF * pNewPos)
{
    HRESULT hr = E_FAIL;
    int startIndex = 0;
    int endIndex = 0;
    POINTF startPoint = {0.0, 0.0};
    POINTF endPoint = {0.0, 0.0};
    POINTF * pts = NULL;

    CHECK_RETURN_NULL(pNewPos);

    // clamp progress
    dblCurProgress = Clamp(0.0, dblCurProgress, 1.0);

    // get start and end point indices
    hr = THR(GetSegmentEndPoints(curseg, startIndex, endIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the start point
    hr = THR(GetPoint(startIndex, &startPoint));
    if (FAILED(hr))
    {
        goto done;
    }

    // get the end point and interpolate
    if (PathBezier == m_pPath[endIndex]->GetType())
    {
        pts = m_pPath[endIndex]->GetPoints();
        if (NULL == pts)
        {
            hr = E_FAIL;
            goto done;
        }

        *pNewPos = CubicBezier(startPoint, pts, (double) dblCurProgress);
    }
    else
    {
        // get the end point
        hr = THR(GetPoint(endIndex, &endPoint));
        if (FAILED(hr))
        {
            goto done;
        }

        pNewPos->x = InterpolateValues((double)(startPoint.x), 
                                     (double)(endPoint.x),
                                     dblCurProgress); //lint !e736

        pNewPos->y = InterpolateValues((double)(startPoint.y), 
                                     (double)(endPoint.y),
                                     dblCurProgress); //lint !e736
    }

    TraceTag((tagSMILPath, 
            "CSMILPath(%p, %ls)::InterpolateSegment(curseg=%d prog=%g newPos={%g, %g})",
            this, 
            (GetID()?GetID():L"No id"), 
            curseg,
            dblCurProgress,
            pNewPos->x,
            pNewPos->y
            ));

    hr = S_OK; 
done:
    delete [] pts;
    return hr;
}



STDMETHODIMP_(ULONG)
CSMILPath::AddRef()
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CSMILPath::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CSMILPath::QueryInterface(REFIID riid, void **ppv)
{
    CHECK_RETURN_SET_NULL(ppv);

    if (InlineIsEqualUnknown(riid))
    {
        *ppv = (void *)(IUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_ISMILPath))
    {
        *ppv = (void *)(ISMILPath *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


#if DBG
int 
CSMILPath::PrintPath(long numPath, long numMOVETO, CTIMEPath ** pPath)
{
    if (pPath)
    {
        for (int i = 0; i < numPath; i++)
        {
            if (pPath[i])
            {
                POINTF * pts = pPath[i]->GetPoints();

                switch (pPath[i]->GetType())
                {
                case PathMoveTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "M" : "m"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathLineTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "L" : "l"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathHorizontalLineTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "H" : "h"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathVerticalLineTo:
                    {
                        TraceTag((tagSMILPath, "%s %g %g",
                            (pPath[i]->GetAbsolute() ? "V" : "v"),
                            pts[0].x,
                            pts[0].y));
                        break;
                    }
                case PathClosePath:
                    {
                        TraceTag((tagSMILPath, "%s",
                            (pPath[i]->GetAbsolute() ? "Z" : "z")));
                        break;
                    }
                case PathBezier:
                    {
                        TraceTag((tagSMILPath, "%s %g %g %g %g %g %g",
                            (pPath[i]->GetAbsolute() ? "C" : "c"),
                            pts[0].x,
                            pts[0].y,
                            pts[1].x,
                            pts[1].y,
                            pts[2].x,
                            pts[2].y));
                        break;
                    }
                case PathNotSet:
                default:
                    {
                        TraceTag((tagSMILPath, "Error: Unknown Path!!"));
                        break;
                    }
                }

                delete [] pts;
            }
        }
    }

    TraceTag((tagSMILPath, "Number of points parsed   : %d", numPath));
    TraceTag((tagSMILPath, "Number of move-to's parsed: %d", numMOVETO));

    return 0;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#undef malloc
#undef free
#undef realloc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\dll\init.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: init.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern bool InitializeModule_##ModuleName();  \
  if (!InitializeModule_##ModuleName()) return false;

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

bool
InitializeAllModules()
{
    // initialize Util first because InitializeModule_ATL uses a 
    // STL lock that is allocated in Util.
    INITIALIZE_MODULE(Util); //lint !e1717
    INITIALIZE_MODULE(ATL); //lint !e1717

    return true;
}

void
DeinitializeAllModules(bool bShutdown)
{
    DEINITIALIZE_MODULE(ATL, bShutdown);
    // deinitialize Util last because DeinitializeModule_ATL uses a 
    // STL lock that is deallocated in Util.
    DEINITIALIZE_MODULE(Util, bShutdown);
}

#include <initguid.h>
#include <strmif.h>
#include "transsiteguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\dll\oleobj.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: oleobj.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "tags\factory.h"

#include "anim\sitefact.h"
#include "anim\compfact.h"
#include "anim\animelm.h"
#include "anim\animset.h"
#include "anim\animmotion.h"
#include "anim\animcolor.h"
#include "anim\animfilter.h"

DeclareTag(tagLockCount,"TIME","Lock count")

DAComModule _Module;
extern HINSTANCE g_hInst;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_TIMEFactory, CTIMEFactory)
    OBJECT_ENTRY(CLSID_AnimationComposerSiteFactory, CAnimationComposerSiteFactory)
    OBJECT_ENTRY(CLSID_AnimationComposerFactory, CAnimationComposerFactory)
    OBJECT_ENTRY(CLSID_TIMEAnimation, CTIMEAnimationElement)
    OBJECT_ENTRY(CLSID_TIMESetAnimation, CTIMESetAnimation)
    OBJECT_ENTRY(CLSID_TIMEMotionAnimation, CTIMEMotionAnimation)
    OBJECT_ENTRY(CLSID_TIMEColorAnimation, CTIMEColorAnimation)
    OBJECT_ENTRY(CLSID_TIMEFilterAnimation, CTIMEFilterAnimation)
END_OBJECT_MAP() //lint !e785

extern bool InitializeModule_ImportManager(void);
extern void DeinitializeModule_ImportManager(bool);

LONG
DAComModule::Lock()
{
    bool bNeedInitialize = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (bNeedInitialize) 
    {
        InitializeModule_ImportManager();
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (l) return l;
    
    DeinitializeModule_ImportManager(true);

    return 0;
}

#if DBG
#include <map>

typedef std::map<void *, const _TCHAR *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const _TCHAR * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
        OutputDebugString(__T("\n**************Begin Time Dump List****************\n"));
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString (__T("DATIME.DLL: Detected unfreed COM pointers\n"));
            OutputDebugString (__T("Listing pointers and types:\n"));
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintfA(buf, "%#x:", (*i).first);
                OutputDebugStringA(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString(__T("\n"));
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
        OutputDebugString(__T("**************End Time Dump List******************\n\n"));
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif

bool
InitializeModule_ATL()
{
    _Module.Init(COMObjectMap, g_hInst);

#if DBG
    // NOTE: Memory allocation during construction now gives a warning. 
    // If this is ok because this is DEV_DEBUG then leave the following
    // pragma, otherwise move this NEW.
#pragma warning( disable: 4291 )     
    objMap = NEW ObjectMap;
#endif

    return true;
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DBG
    DumpCOMObjectList();
    
    delete objMap;
    objMap = NULL;
#endif
    
    _Module.Term();
}

//
//
//
STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(COMObjectMap)/sizeof(COMObjectMap[0])) - 1) //lint !e574
    {
        return S_FALSE;
    }

    *pclsid = *(COMObjectMap[i].pclsid);
    return DllGetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"

#include "dlldatax.h"

//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE     g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
LCID                g_lcidUserDefault = 0;

HINSTANCE  g_hInst;

DWORD g_dwFALSE = 0;

bool InitializeAllModules(void);
void DeinitializeAllModules(bool bShutdown);

extern "C" void InitDebugLib(HANDLE, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

MtDefine(OpNewATL, Mem, "operator new (mstime ATL)")

// Below is the trick used to make ATL use our memory allocator
void    __cdecl ATL_free(void * pv) { MemFree(pv); }
void *  __cdecl ATL_malloc(size_t cb) { return(MemAlloc(Mt(OpNewATL), cb)); }
void *  __cdecl ATL_realloc(void * pv, size_t cb)
{
    void * pvNew = pv;
    HRESULT hr = MemRealloc(Mt(OpNewATL), &pvNew, cb);
    return(hr == S_OK ? pvNew : NULL);
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
        return FALSE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {

#if DBG
        char buf[MAX_PATH + 1];

        GetModuleFileNameA(hInstance, buf, MAX_PATH);

        char buf2[1024];
        wsprintfA(buf2, "[%s] - Loaded DLL\n", buf);
        OutputDebugStringA(buf2);

        // init the debug Trace mech.
//        InitDebugLib(hInstance, NULL); 


    //  Tags for the .dll should be registered before
    //  calling DbgExRestoreDefaultDebugState().  Do this by
    //  declaring each global tag object or by explicitly calling
    //  DbgExTagRegisterTrace.

    DbgExRestoreDefaultDebugState();

#endif 
        g_hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        if (!InitializeAllModules())
        {
            return FALSE;
        }
        
    } else if (dwReason == DLL_PROCESS_DETACH) {
#if DBG
        char buf[MAX_PATH + 1];

        GetModuleFileNameA(hInstance, buf, MAX_PATH);

        char buf2[1024];
        wsprintfA(buf2, "[%s] - Unloaded DLL(%d)\n", buf, lpReserved);
        OutputDebugStringA(buf2);
#endif
        DeinitializeAllModules(lpReserved != NULL);
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }

    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
    {
        return hRes;
    }

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    PrxDllUnregisterServer();
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\idlproxy\makefile.inc ===
$(O)\mstimepdlldata.c $O\mstimep.h : mstimep.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\mstimep_p.c \
    -iid $O\mstimep_i.c \
    -dlldata $O\mstimepdlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\mstimep.h \
    $(C_DEFINES) \
    -Oicf \
    -error all \
    mstimep.idl

$(O)\prxyguid.lib : $(O)\mstimep_i.obj
    LIB $(O)\mstimep_i.obj /out:$(O)\prxyguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\idl\makefile.inc ===
!if !$(FREEBUILD)
C_DEFINES       = $(C_DEFINES) -DDBG=1
!endif

$O\TimeEng.h : TimeEng.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\TimeEng_p.c \
    -iid $O\TimeEng_i.c \
    -dlldata $O\dlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\TimeEng.h \
    $(C_DEFINES) \
    -Oicf \
    -no_warn \
    -error all \
    TimeEng.idl

$(O)\TimeEng_i.obj : $(O)\TimeEng_i.c

$(O)\mmpguid.lib : $(O)\TimeEng_i.obj
    copy $? $@

$(O)\MediaPrivate.tlb : $O\MediaPrivate.h

$O\MediaPrivate.h : MediaPrivate.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\MediaPrivate_p.c \
    -iid $O\MediaPrivate_i.c \
    -dlldata $O\dlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\MediaPrivate.h \
    -tlb $(O)\MediaPrivate.tlb \
    $(C_DEFINES) \
    -Oicf \
    -no_warn \
    -error all \
    MediaPrivate.idl

$(O)\MediaPrivate_i.obj : $(O)\MediaPrivate_i.c

$(O)\mediaprivateguid.lib : $(O)\MediaPrivate_i.obj
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\dll\transsiteguid.h ===
// {387B7322-E999-4228-905D-D85CFB971AB5}
DEFINE_GUID(IID_ITIMETransitionSite, 
0x387b7322, 0xe999, 0x4228, 0x90, 0x5d, 0xd8, 0x5c, 0xfb, 0x97, 0x1a, 0xb5);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\atomtable.h ===
#ifndef _ATOMTABLE_H_
#define _ATOMTABLE_H_

//************************************************************
//
// FileName:        atomtbl.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CAtomTable
//************************************************************

static const long ATOM_TABLE_VALUE_UNITIALIZED = -1L;

#include "array.h"

class CAtomTable
{
public:
    CAtomTable();
    virtual ~CAtomTable();
    
    //
    // CAtomTable impl
    //
    HRESULT AddNameToAtomTable(const WCHAR *pwszName,
                               long        *plOffset);
    HRESULT GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset);
    HRESULT GetNameFromAtom(long          lOffset, 
                            const WCHAR **ppwszName);

    LONG AddRef( void) { return InterlockedIncrement(&m_lRefCount); }
    LONG Release( void) { ULONG l = InterlockedDecrement(&m_lRefCount); if (l == 0) delete this; return l; }


private:
    CPtrAry<BSTR> *m_rgNames;
    LONG m_lRefCount;
};

#endif // _ATOMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\atlutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_STATIC_REGISTRY 1

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DBG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if DBG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DBG
        _Module.AddComPtr(this, GetName());
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DBG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\array.h ===
#ifndef _ARRAY_H_
#define _ARRAY_H_

//************************************************************
//
// FileName:        array.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//
//************************************************************

#pragma once

#define ULREF_IN_DESTRUCTOR 256

//************************************************************
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        DeleteItem(int i)  Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        BringToFront(int i) Moves the given element of the array to index 0,
//                          shuffling elements to make room.
//
//        SendToBack(int i) Moves the given element to the end of the array,
//                          shuffling elements to make room.
//
//        Swap(int i, int j) Swaps the given two elements.
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//************************************************************

//************************************************************
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    m_c          Current size of the array
//              m_pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//************************************************************

class CImplAry
{
    friend class CBaseEnum;
    friend class CEnumGeneric;
    friend class CEnumVARIANT;

public:
    virtual ~CImplAry();

    inline long Size() const
    {
        return m_c;
    } // Size

    inline void SetSize(int c)
    {
        m_c = c;
    } // SetSize

    inline operator void *()
    {
        return PData();
    } // void *
    
    void DeleteAll();

    void * Deref(size_t cb, int i);

    NO_COPY(CImplAry);

protected:

    //  Methods which are wrapped by inline subclass methods
    CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void *pv, void **ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void *pv);
    int         FindIndirect(size_t cb, void *);

    void        DeleteItem(size_t cb, int i);
    bool        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void *pv, bool fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(size_t   cb,
                             REFIID   iid,
                             void   **ppv,
                             bool     fAddRef,
                             bool     fCopy = true,
                             bool     fDelete = true);

    HRESULT     EnumVARIANT(size_t         cb,
                            VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);

    inline bool UsingStackArray()
    {
        return m_fDontFree;
    } // UsingStackArray

    UINT GetStackSize()
    { 
        Assert(m_fStack);
        return *(UINT*)((BYTE*)this + sizeof(CImplAry));
    } // GetStackSize

    void * GetStackPtr()
    {
        Assert(m_fStack);
        return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int));
    } // GetStackPtr

    bool          m_fStack;    // Set if we're a stack-based array.
    bool          m_fDontFree; // Cleared if m_pv points to alloced memory.
    unsigned long m_c;         // Count of elements

    void           *m_pv;

    inline void * & PData()
    {
        return m_pv;
    } // PData
};

//************************************************************
//
//  Member:     CImplAry::CImplAry
//
//************************************************************

inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
} // CImplAry 

//************************************************************
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//************************************************************

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));

    return ((BYTE *) PData()) + i * cb;
} // Deref

//************************************************************
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//************************************************************

class CImplPtrAry : public CImplAry
{
protected:
    CImplPtrAry() : CImplAry()
    {
    } // CImplPtrAry

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    bool        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, bool fAddRef);


public:
    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        DeleteItem(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);

    HRESULT     EnumElements(REFIID iid,
                             void **ppv,
                             bool   fAddRef,
                             bool   fCopy = true,
                             bool   fDelete = true);

    HRESULT     EnumVARIANT(VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);
}; // CImplPtrAry

//************************************************************
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    CDataAry() : CImplAry()
    {
    } // CDataAry

    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *

    CDataAry(const CDataAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT EnsureSize(long c)
    {
        return CImplAry::EnsureSize(sizeof(ELEM), c);
    } // EnsureSize
    
    HRESULT Grow(int c)
    {
        return CImplAry::Grow(sizeof(ELEM), c);
    } // Grow
    
    HRESULT AppendIndirect(ELEM *pe, ELEM **ppePlaced=NULL)
    {
        return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced);
    } // AppendIndirect
    
    ELEM * Append()
    {
        ELEM *pElem;
        return AppendIndirect( NULL, & pElem ) ? NULL : pElem;
    } // Append
    
    HRESULT InsertIndirect(int i, ELEM * pe)
    {
        return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe);
    } // InsertIndirect
    
    int FindIndirect(ELEM * pe)
    {
        return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe);
    } // FindIndirect
    
    void DeleteItem(int i)
    {
        CImplAry::DeleteItem(sizeof(ELEM), i);
    } // DeleteItem
    
    bool DeleteByValueIndirect(ELEM *pe)
    {
        return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe);
    } // DeleteByValueIndirect
    
    void DeleteMultiple(int start, int end)
    {
        CImplAry::DeleteMultiple(sizeof(ELEM), start, end);
    } // DeleteMultiple
    
    HRESULT CopyAppend(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return CImplAry::Copy(sizeof(ELEM), ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pv, bool fAddRef)
    {
        return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef);
    } // CopyIndirect

    HRESULT EnumElements(REFIID  iid,
                         void  **ppv,
                         bool    fAddRef,
                         bool    fCopy = true,
                         bool    fDelete = true)
    {
        return CImplAry::EnumElements(sizeof(ELEM), iid, ppv, fAddRef, fCopy, fDelete);
    } // EnumElements

    HRESULT EnumVARIANT(VARTYPE        vt,
                        IEnumVARIANT **ppenum,
                        bool           fCopy = true,
                        bool           fDelete = true)
    {
        return CImplAry::EnumVARIANT(sizeof(ELEM), vt, ppenum, fCopy, fDelete);
    } // EnumVARIANT
}; // CDataAry

//************************************************************
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:

    CPtrAry() : CImplPtrAry()
    {
        Assert(sizeof(ELEM) == sizeof(void*));
    } // CPtrAry
    
    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *
    
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT Append(ELEM e)
    {
        return CImplPtrAry::Append((void*)e);
    } // Append

    HRESULT Insert(int i, ELEM e)
    {
        return CImplPtrAry::Insert(i, (void*)e);
    } // Insert

    bool DeleteByValue(ELEM e)
    {
        return CImplPtrAry::DeleteByValue((void*)e);
    } // DeleteByValue

    int Find(ELEM e)
    {
        return CImplPtrAry::Find((void*)e);
    } // Find

    HRESULT CopyAppend(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return CImplPtrAry::Copy(ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pe, bool fAddRef)
    {
        return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef);
    } // CopyIndirect
}; // CPtrAry

//************************************************************
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    CStackDataAry(): CDataAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackDataAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackDataAry
/*lint --flb*/

//************************************************************
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    CStackPtrAry() : CPtrAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackPtrAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackPtrAry
/*lint --flb*/

//************************************************************
//
//  Class:      CBaseEnum (benum)
//
//  Purpose:    Base OLE enumerator class for a CImplAry.
//
//  Interface:  DECLARE_FORMS_STANRARD_IUNKNOWN
//
//              Next                   -- Per IEnum*
//              Skip                   --    ""
//              Reset                  --    ""
//              Clone                  --    ""
//              CBaseEnum              -- ctor.
//              CBaseEnum              -- ctor.
//              ~CBaseEnum             -- dtor.
//              Init                   -- 2nd stage initialization.
//              Deref                  -- gets pointer to element.
//
//  Notes:      Since there is no IEnum interface, we create a vtable
//              with the same layout as all IEnum interfaces.  Be careful
//              where you put virtual function declarations!
//
//************************************************************

class CBaseEnum : public IUnknown
{
public:
    //
    // IUnknown
    //
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    
    STDMETHOD_(ULONG, AddRef) (void)
    {
        return ++m_ulRefs;
    } // AddRef

    STDMETHOD_(ULONG, Release) (void)
    {
        if (--m_ulRefs == 0)
        {
            m_ulRefs = ULREF_IN_DESTRUCTOR;
            delete this;
            return 0;
        }
        return m_ulRefs;
    } // Release

    ULONG GetRefs(void)
    {
        return m_ulRefs;
    } // GetRefs

    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched) PURE;
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (CBaseEnum ** ppenum) PURE;

    //
    // Ensure that vtable contains virtual destructor after other virtual methods.
    //
    virtual ~CBaseEnum();

protected:
    CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CBaseEnum(const CBaseEnum & benum);

    CBaseEnum& operator=(const CBaseEnum & benum); // don't define

    HRESULT Init(CImplAry *rgItems, bool fCopy);
    void *  Deref(int i);

    CImplAry   *m_rgItems;
    const IID  *m_piid;
    int         m_i;
    size_t      m_cb;
    bool        m_fAddRef;
    bool        m_fDelete;
    ULONG       m_ulRefs;
    CBaseEnum();
}; // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::Deref
//
//  Synopsis:   Forwards deref to m_rgItems.  Required because classes derived
//              from CBaseEnum are friends of CImplAry.
//
//************************************************************

inline void *
CBaseEnum::Deref(int i)
{
    Assert(i >= 0);
    return (BYTE *)m_rgItems->PData() + i * m_cb;
} // Deref 

#endif // _ARRAY_H_

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\basebvr.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\basebvr.h
//
//  Contents: DHTML Behavior base class
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _BASEBVR_H
#define _BASEBVR_H

class CBaseBvr :   
    public CComObjectRootEx<CComSingleThreadModel>,
    public IElementBehavior,
    public IServiceProvider,
    public IOleClientSite
{

protected:

    // To prevent instantiation/copying of this class
    CBaseBvr();
    CBaseBvr(const CBaseBvr&);
    virtual ~CBaseBvr();

public:

    BEGIN_COM_MAP(CBaseBvr)
        COM_INTERFACE_ENTRY(IElementBehavior)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IOleClientSite)
    END_COM_MAP();

    virtual void * GetInstance() = 0;
    virtual HRESULT GetTypeInfo(ITypeInfo ** ppInfo) = 0;

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // IServiceProvider interfaces
    //

    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    //
    // IOleClientSite interfaces
    //
    
    STDMETHOD(SaveObject)()
    { return E_NOTIMPL; }
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk)
    { CHECK_RETURN_SET_NULL(ppmk); return E_NOTIMPL; }
    STDMETHOD(GetContainer)(LPOLECONTAINER * ppContainer)
    { CHECK_RETURN_SET_NULL(ppContainer); return E_NOTIMPL; }
    STDMETHOD(ShowObject)()
    { return E_NOTIMPL; }
    STDMETHOD(OnShowWindow)(BOOL fShow)
    { return E_NOTIMPL; }
    STDMETHOD(RequestNewObjectLayout)()
    { return E_NOTIMPL; }

    virtual LPCWSTR GetBehaviorURN (void) = 0;
    virtual LPCWSTR GetBehaviorName (void) = 0;
    virtual bool    IsBehaviorAttached (void) = 0;

    //
    // Notification Helpers
    //

    void NotifyPropertyChanged(DISPID dispid);

    //
    // Accessors for cached interface pointers
    //
    
    IElementBehaviorSite * GetBvrSite()
    { return m_pBvrSite; }
    IElementBehaviorSiteOM * GetBvrSiteOM()
    { return m_pBvrSiteOM; }
    IHTMLElement * GetElement()
    { return m_pHTMLEle; }
    IHTMLDocument2 * GetDocument()
    { return m_pHTMLDoc; }
    IServiceProvider * GetServiceProvider()
    { return m_pSp; }

protected:

    //
    // IPersistPropertyBag2 methods
    //

    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // Persistance helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void) PURE;

    //
    // Notification Helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP) PURE;

    //
    // Persistance and Notification data
    //

    CLSID                                  m_clsid;
    bool                                   m_fPropertiesDirty;

    //
    // Cached Interface Pointers
    //

    CComPtr<IElementBehaviorSite>          m_pBvrSite;
    CComPtr<IElementBehaviorSiteOM>        m_pBvrSiteOM;
    CComPtr<IHTMLElement>                  m_pHTMLEle;
    CComPtr<IHTMLDocument2>                m_pHTMLDoc;
    CComPtr<IServiceProvider>              m_pSp;

    bool m_fIsIE4;
};

#endif /* _BASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\bindstatuscallback.h ===
#ifndef _BINDSTATUSCALLBACK_H__
#define _BINDSTATUSCALLBACK_H__

class CTIMEBindStatusCallback : 
  public IBindStatusCallback
{
  public:
    static HRESULT CreateTIMEBindStatusCallback(CTIMEBindStatusCallback ** ppbsc)
    {
        Assert(NULL != ppbsc);

        *ppbsc = new CTIMEBindStatusCallback;
        if (NULL == ppbsc)
        {
            return E_OUTOFMEMORY;
        }
        (*ppbsc)->AddRef();
        return S_OK;
    }

    virtual ~CTIMEBindStatusCallback() { delete m_pszText; m_pszText = NULL; }
    
    void StopAfter(ULONG ulStatusCode) { m_ulCodeToStopOn = ulStatusCode; }
    LPWSTR GetStatusText() { return m_pszText; }

    //
    // IUnknown methods
    //
    STDMETHOD_(ULONG, AddRef)(void) { return InterlockedIncrement(&m_cRef); }
    STDMETHOD_(ULONG, Release)(void)
    {
        LONG l = InterlockedDecrement(&m_cRef);
        
        if (0 == l)
        {
            delete this;
        }
        return l;
    }

    STDMETHOD (QueryInterface)(REFIID riid, void** ppv)
    {
        if (NULL == ppv)
        {
            return E_POINTER;
        }
        
        *ppv = NULL;
        
        if ( IsEqualGUID(riid, IID_IUnknown) )
        {
            *ppv = static_cast<IBindStatusCallback*>(this);
        }
        else if (IsEqualGUID(riid, IID_IBindStatusCallback))
        {
            *ppv = static_cast<IBindStatusCallback*>(this);
        }
        
        if ( NULL != *ppv )
        {
            ((LPUNKNOWN)*ppv)->AddRef();
            return NOERROR;
        }
        return E_NOINTERFACE;
    }

    //
    // IBindStatusCallback methods
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib)
    {
        return S_OK;
    }
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority)
    {
        return S_OK;
    }
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved)
    {
        return S_OK;
    }
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText)
    {
        if (ulStatusCode == m_ulCodeToStopOn)
        {
            m_pszText = ::CopyString(szStatusText);
            return E_ABORT;
        }
        return S_OK;
    }
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError)
    {
        return S_OK;
    }
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
    {
        return S_OK;
    }
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
    {
        return S_OK;
    }
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
    {
        return S_OK;
    }

  protected:
    CTIMEBindStatusCallback() { m_cRef = 0; m_ulCodeToStopOn = -1; m_pszText = NULL; }

  private:
    ULONG   m_ulCodeToStopOn;
    LPWSTR  m_pszText;
    LONG    m_cRef;
};

#endif // _BINDSTATUSCALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\attr.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: attr.h
//
//  Contents: utilities for persistable attributes
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _ATTR_H
#define _ATTR_H

//+-------------------------------------------------------------------------------------
//
// CAttrBase
//
//--------------------------------------------------------------------------------------


// This class stores the persisted string and implements IsSet()
class 
ATL_NO_VTABLE
CAttrBase
{
public:
    CAttrBase();
    virtual ~CAttrBase();

    // This is for setting/getting the persisted string
    HRESULT SetString(BSTR pbstrAttr);
    HRESULT GetString(BSTR * ppbstrAttr);

    // This is for use of persistence macros only! Uses the storage passed in (does not allocate).
    void SetStringFromPersistenceMacro(LPWSTR pstrAttr);

    // Indicates if a valid value was set through persistence or the DOM
    bool IsSet() { return m_fSet; }

protected:
    NO_COPY(CAttrBase);

    void ClearString();
    void SetFlag(bool fSet) { m_fSet = fSet; }

private:
    LPWSTR m_pstrAttr;
    bool m_fSet;
};


//+-------------------------------------------------------------------------------------
//
// CAttr Template
//
//--------------------------------------------------------------------------------------

template<class T>
class CAttr :
    public CAttrBase
{
public:
    CAttr(T val) : m_val(val) {}
    virtual ~CAttr() {}

    //
    // Operators
    //

    operator T() const { return m_val; }
    
    //
    // Accessors
    //
    
    void SetValue(T val) 
    {
        m_val = val;
        MarkAsSet();
    }
    T GetValue() const { return m_val; }
    
    //
    // Misc methods
    //
    
    // Just sets the value. Does not clear the persisted string or mark it as set.
    // e.g. used internally to change defaults without affecting persistence
    T InternalSet(T val) { return (m_val = val); }
    // Resets to the specified value (usually the default), marks as not set, and does not persist
    void Reset(T val)
    {
        ClearString();
        SetFlag(false);
        m_val = val;
    }
    // Clears persisted string, forces IsSet() to return 'true'
    void MarkAsSet()
    { 
        ClearString();
        SetFlag(true);
    }

protected:
    // These are not to be used
    NO_COPY(CAttr);

private:
    // Data
    T m_val;
};

class CAttrString  : 
  public CAttrBase
{
  public:
    CAttrString(LPWSTR val);
    virtual ~CAttrString();

    HRESULT SetValue(LPWSTR val);
    BSTR GetValue();

  protected:
    NO_COPY(CAttrString);

    void MarkAsSet();

  private:
    LPWSTR m_pszVal;
};

//+-------------------------------------------------------------------------------------
//
// TIME_PERSISTENCE_MAP macros
//
//--------------------------------------------------------------------------------------


typedef HRESULT (*PFNPERSIST)(void*, VARIANT*, bool);

struct TIME_PERSISTENCE_MAP
{
    LPWSTR     pstrName;    // Attribute Name
    PFNPERSIST pfnPersist;  // Static persistence function for this attribute
};

#define BEGIN_TIME_PERSISTENCE_MAP(className)     TIME_PERSISTENCE_MAP className##::PersistenceMap[] = {
#define PERSISTENCE_MAP_ENTRY(AttrName, FnName)   {AttrName, ::TimePersist_##FnName},
#define END_TIME_PERSISTENCE_MAP()                {NULL, NULL}};


//+-------------------------------------------------------------------------------------
//
// Persistence helpers (All classes delegate to these functions for persistence)
//
//--------------------------------------------------------------------------------------

HRESULT TimeLoad(void * pvObj, TIME_PERSISTENCE_MAP PersistenceMap[], IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
HRESULT TimeSave(void * pvObj, TIME_PERSISTENCE_MAP PersistenceMap[], IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

//
// For loading attributes out of an element
//
HRESULT TimeElementLoad(void * pvObj, TIME_PERSISTENCE_MAP PersistenceMap[], IHTMLElement * pElement);


//+-------------------------------------------------------------------------------------
//
// The following macros are used to create static persistence accessor functions for the TIME_PERSISTENCE_MAP
// (It is best to read these in a top-down fashion, starting at the TIME_PERSIST_FN macro)
//
//--------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------------------
//
// VT_R4 Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VT_R4(hr, pvarAttr, PropPutFn) \
{ \
    hr = VariantChangeTypeEx(##pvarAttr##, ##pvarAttr##, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4); \
    if (SUCCEEDED(hr)) \
    { \
        hr = PropPutFn##(V_R4(##pvarAttr##)); \
    } \
}
#define TIME_GET_VT_R4(hr, pvarAttr, PropGetFn) \
{ \
    float flVal = 0; \
    hr = PropGetFn##(&flVal); \
    if (SUCCEEDED(hr)) \
    { \
        V_VT(##pvarAttr##) = VT_R4; \
        V_R4(##pvarAttr##) = flVal; \
    } \
} 

//+-------------------------------------------------------------------------------------
//
// VT_BOOL Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VT_BOOL(hr, pvarAttr, PropPutFn) \
{ \
    hr = VariantChangeTypeEx(##pvarAttr##, ##pvarAttr##, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BOOL); \
    if (SUCCEEDED(hr)) \
    { \
        hr = PropPutFn##(V_BOOL(##pvarAttr##)); \
    } \
}
#define TIME_GET_VT_BOOL(hr, pvarAttr, PropGetFn) \
{ \
    VARIANT_BOOL vbVal = VARIANT_TRUE; \
    hr = PropGetFn##(&vbVal); \
    if (SUCCEEDED(hr)) \
    { \
        V_VT(##pvarAttr##) = VT_BOOL; \
        V_BOOL(##pvarAttr##) = vbVal; \
    } \
} 

//+-------------------------------------------------------------------------------------
//
// VT_BSTR Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VT_BSTR(hr, pvarAttr, PropPutFn) \
{ \
    hr = PropPutFn##(V_BSTR(##pvarAttr##)); \
}
#define TIME_GET_VT_BSTR(hr, pvarAttr, PropGetFn) \
{ \
    hr = PropGetFn##(&V_BSTR(##pvarAttr##)); \
    if (SUCCEEDED(hr)) \
    { \
        if (NULL == V_BSTR(##pvarAttr##)) \
        { \
            /* No need to propogate a NULL string back.  A number of our */ \
            /* get methods return NULL strings. */ \
            V_VT(##pvarAttr##) = VT_NULL; \
        } \
        else \
        { \
            V_VT(##pvarAttr##) = VT_BSTR; \
        } \
    } \
}

//+-------------------------------------------------------------------------------------
//
// VARIANT Accessors
//
//--------------------------------------------------------------------------------------

#define TIME_PUT_VARIANT(hr, pvarAttr, PropPutFn) \
{ \
    hr = PropPutFn##(*##pvarAttr##); \
}
#define TIME_GET_VARIANT(hr, pvarAttr, PropGetFn) \
{ \
    hr = PropGetFn##(##pvarAttr##); \
}

//+-------------------------------------------------------------------------------------
//
// TIME_PERSISTGET macro
//
//--------------------------------------------------------------------------------------

// Assumes pvarAttr has been cleared
#define TIME_PERSISTGET(hr, pvarAttr, refAttr, idl_arg_type, PropGetFn) \
{ \
    BSTR bstrTemp; \
    /* Try to get string */ \
    hr = THR(refAttr##.GetString(&bstrTemp)); \
    if (SUCCEEDED(hr) && NULL != bstrTemp) \
    { \
        V_VT(##pvarAttr##) = VT_BSTR; \
        V_BSTR(##pvarAttr##) = bstrTemp; \
    } \
    /* else if attr is set, get value */ \
    else if (##refAttr##.IsSet()) \
    { \
        TIME_GET_##idl_arg_type##(hr, pvarAttr, PropGetFn); \
    } \
    /* else indicate that this attr should not be persisted */ \
    else \
    { \
        V_VT(##pvarAttr##) = VT_NULL; \
    } \
} 

//+-------------------------------------------------------------------------------------
//
// TIME_PERSISTPUT macro
//
//--------------------------------------------------------------------------------------

// The variant is first passed to the COM accessor, and then the persisted string is set 
// on the CAttr<> class. This ordering is important for the attribute to persist correctly.
// Assumes pvarAttr is valid and is a VT_BSTR (this is guaranteed by ::TimeLoad)
#define TIME_PERSISTPUT(hr, pvarAttr, refAttr, idl_arg_type, PropPutFn) \
{ \
    LPWSTR pstrTemp = NULL; \
    Assert(VT_BSTR == V_VT(pvarAttr)); \
    /* cache the bstr */ \
    if (NULL != V_BSTR(pvarAttr)) \
    { \
        /* intentionally ignoring NULL return value */ \
        pstrTemp = CopyString(V_BSTR(pvarAttr)); \
    } \
    /* use put_xxx COM accessor */ \
    TIME_PUT_##idl_arg_type(hr, pvarAttr, PropPutFn); \
    /* Assert that variant was not modified by COM Accessor */ \
    /* set the persisted string (do not delete pstrTemp because the storage is re-used) */ \
    refAttr##.SetStringFromPersistenceMacro(pstrTemp); \
}


#define TIME_CALLFN(ClassName, pvObj, Function)       static_cast<##ClassName##*>(##pvObj##)->##Function

//+-------------------------------------------------------------------------------------
//
// Macro: TIME_PERSIST_FN 
//
// Synopsis: This is the top level macro used to create static functions for the TIME_PERSISTENCE_MAP.
//           It provides a static, in-place definition for the ::TimePersist_[FnName] functions.
// 
// Arguments: [FnName]      Name of function (should be globally unique, one per attribute)
//            [ClassName]   Name of class that supports this attribute
//            [GetAttr_fn]  Name of accessor for the CAttr<> that stores this attribute
//            [put_fn]      Name of COM put_ function
//            [get_fn]      Name of COM get_ function
//            [idl_ArgType] VARTYPE of the COM put_function argument. It is assumed that the 
//                          VARTYPE of the COM get_function argument is [idl_ArgType]*
//
//--------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------------------
//
// Function: ::TimePersist_[FnName] (FnName is a macro parameter, see above comment)
//
// Synopsis: This function is called from ::TimeLoad and ::TimeSave, which iterate through 
//           the TIME_PERSISTENCE_MAP (which stores a pointer to this function). 
//
//           While loading an attribute, it first puts the attribute by calling the COM put_ method,
//           and then sets the persisted string on the CAttr (The order is important, because
//           the COM put_ functions clear the persisted string since it is expected to be invalid
//           once the attribute has bee set by the DOM).
//
//           While saving an attribute, it tries to get the persisted string from the CAttr. If
//           that fails, and if the attribute has been set by the DOM, it uses the COM get_ methods
//           to get the attribute value. Finally, if the attribute has not been set then it sets
//           the variant's VARTYPE field to VT_NULL to indicate that this attribute is not to be saved.
//             
// Arguments:   [pvObj]     pointer to the CTIMEXXXElement
//              [pvarAttr]  pointer to Variant that holds a bstr value (for puts) or that
//                          will return the attribute value (for gets)
//              [fPut]      flag that indicates whether to get or put the attribute
//
//--------------------------------------------------------------------------------------


#define TIME_PERSIST_FN(FnName, ClassName, GetAttr_fn, put_fn, get_fn, idl_ArgType) \
static HRESULT TimePersist_##FnName(void * pvObj, VARIANT * pvarAttr, bool fPut) \
{ \
    HRESULT hr = S_OK; \
    if (fPut) \
    { \
        TIME_PERSISTPUT(hr, \
                        pvarAttr, \
                        TIME_CALLFN(ClassName, pvObj, GetAttr_fn)(), \
                        idl_ArgType, \
                        TIME_CALLFN(ClassName, pvObj, put_fn)); \
    } \
    else \
    { \
        TIME_PERSISTGET(hr, \
                        pvarAttr, \
                        TIME_CALLFN(ClassName, pvObj, GetAttr_fn)(), \
                        idl_ArgType, \
                        TIME_CALLFN(ClassName, pvObj, get_fn)); \
    } \
    return hr; \
}


#endif // _ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\dlldatax.h ===
#ifndef _DLLDATAX_H_
#define _DLLDATAX_H_

#pragma once

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}


#endif // _DLLDATAX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}


template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    operator T*() const { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T& operator*() const { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator->() const { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

//
// This is copied almost directly from atlcom.h.  It only changes the
// way we load the typelib to not use the registry but the current
// DLL.
//

// Create our own CComTypeInfoHolder so we can ensure which typelib is
// loaded

class CTIMEComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
        const GUID* m_pguid;
        const TCHAR * m_ptszIndex;

        ITypeInfo* m_pInfo;
        long m_dwRef;

public:
        HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

        void AddRef();
        void Release();
        HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid);
        HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

/////////////////////////////////////////////////////////////////////////////
// ITIMEDispatchImpl

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex = NULL,
          class tihclass = CTIMEComTypeInfoHolder>
class ATL_NO_VTABLE ITIMEDispatchImpl : public T
{
public:
        typedef tihclass _tihclass;
        ITIMEDispatchImpl() {_tih.AddRef();}
        virtual ~ITIMEDispatchImpl() {_tih.Release();}

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {*pctinfo = 1; return S_OK;}

        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
        static _tihclass _tih;
        static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
        {return _tih.GetTI(lcid, ppInfo);}
};

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex,
          class tihclass>
ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tihclass
ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tih =
{piid, ptszIndex, NULL, 0};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\daatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _DAATL_H
#define _DAATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define malloc ATL_malloc
#define free ATL_free
#define realloc ATL_realloc

void   __cdecl ATL_free(void *);
void * __cdecl ATL_malloc(size_t);
void * __cdecl ATL_realloc(void *, size_t);

#ifndef X_ATLBASE_H_
#define X_ATLBASE_H_
#pragma INCMSG("--- Beg <atlbase.h>")
#include <atlbase.h>
#pragma INCMSG("--- End <atlbase.h>")
#endif


// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DBG
    void AddComPtr(void *ptr, const _TCHAR * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#ifndef X_ATLCOM_H_
#define X_ATLCOM_H_
#pragma INCMSG("--- Beg <atlcom.h>")
#include <atlcom.h>
#pragma INCMSG("--- End <atlcom.h>")
#endif

#ifndef X_ATLCTL_H_
#define X_ATLCTL_H_
#pragma INCMSG("--- Beg <atlctl.h>")
#include <atlctl.h>
#pragma INCMSG("--- End <atlctl.h>")
#endif


#if DBG
#ifndef X_TYPEINFO_H_
#define X_TYPEINFO_H_
#pragma INCMSG("--- Beg <typeinfo.h>")
#include <typeinfo.h>
#pragma INCMSG("--- End <typeinfo.h>")
#endif
#endif

#undef malloc
#undef free
#undef realloc


#endif /* _DAATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\clock.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _CLOCK_H
#define _CLOCK_H

#include <ocmm.h>
#include <htmlfilter.h>

// This needs to be implemented by the object that wants to be called
// back on timer ticks

class ClockSink
{
  public:
    virtual void OnTimer(double time)=0;
};

// This is the base clock implementation

enum ClockState
{
    CS_STARTED,
    CS_PAUSED,
    CS_STOPPED
};

class Clock
    : public ITimerSink
{
  public :
    Clock();
    virtual ~Clock();

    HRESULT SetITimer(IServiceProvider * sp, ULONG iInterval);
    void SetSink(ClockSink *pClockSink)
    {
        m_pClockSink = pClockSink;
    }

    HRESULT Start();
    HRESULT Pause();
    HRESULT Resume();
    HRESULT Stop();

    // For the timer sink.
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

    // For the starvation sniffer
    void WINAPI StarvationCallback (void);
    static LRESULT __stdcall StarveWndProc (HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);

    double GetCurrentTime() { return m_curTime; }
    ClockState GetCurrentState() { return m_state; }
  protected :
    ULONG                      m_ulRefs;
    ClockState                 m_state;
    CComPtr<ITimer>            m_timer;
    DWORD                      m_cookie;
    ClockSink                 *m_pClockSink;
    ULONG                      m_interval;
    double                     m_lastTime;
    double                     m_curTime;
    UINT                       m_uStarveTimerID;
    HWND                       m_hWndStarveTimer;
    ULONG                      m_ulLastStarvationCallback;
    long                       m_lConsectiveStarvedTicks;
    bool                       m_fAllowOnTimer;
    bool                       m_fAllowStarvationCallback;

    HRESULT StartITimer();
    HRESULT StopITimer();

    void CreateStarveTimerWindow (void);
    void SetStarveTimer (void);
    
    ULONG GetNextInterval (void);
    HRESULT SetNextTimerInterval (ULONG ulNextInterval);

    double GetITimerTime();
    double GetGlobalTime() { return GetITimerTime(); }

    void ProcessCB(double time);
};


#endif /* _CLOCK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\empty.cpp ===
#include "headers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\headers.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: headers.h
//
//  Contents: Precompiled header for mstime.dll
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef DAL_HEADERS_HXX
#define DAL_HEADERS_HXX
#define DIRECTDRAW_VERSION 0x0300

//
//  STL needs a _Lockit class.  However, this causes us to start linking to
//  msvcp60.dll which is 400k and we don't currently ship it.  Obviously,
//  this wouldn't be efficient.  So instead of doing that, we will instead fake
//  out the header that we can implement our own version of _Lockit
//
#undef _DLL
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#define _DLL
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)


// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#define NEW new
#define AssertStr AssertSz
#ifndef INCMSG
//#define INCMSG(x)
#define INCMSG(x) message(x)
#endif

#pragma warning(disable:4530)

// Don't overload operator new -- it messes
// up the STL new operator (UG!)
#define TRIMEM_NOOPNEW

#ifndef X_TRIRT_H_
#define X_TRIRT_H_
#pragma INCMSG("--- Beg 'trirt.h'")
#include "trirt.h"
#pragma INCMSG("--- End 'trirt.h'")
#endif

#ifndef X_DAATL_H_
#define X_DAATL_H_
#pragma INCMSG("--- Beg 'daatl.h'")
#include "daatl.h"
#pragma INCMSG("--- End 'daatl.h'")
#endif

/* Standard */
#ifndef X_MATH_H_
#define X_MATH_H_
#pragma INCMSG("--- Beg <math.h>")
#include <math.h>
#pragma INCMSG("--- End <math.h>")
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#pragma INCMSG("--- Beg <stdio.h>")
#include <stdio.h>
#pragma INCMSG("--- End <stdio.h>")
#endif

#ifndef X_STDLIB_H_
#define X_STDLIB_H_
#pragma INCMSG("--- Beg <stdlib.h>")
#include <stdlib.h>
#pragma INCMSG("--- End <stdlib.h>")
#endif

#ifndef X_MEMORY_H_
#define X_MEMORY_H_
#pragma INCMSG("--- Beg <memory.h>")
#include <memory.h>
#pragma INCMSG("--- End <memory.h>")
#endif

#ifndef X_WTYPES_H_
#define X_WTYPES_H_
#pragma INCMSG("--- Beg <wtypes.h>")
#include <wtypes.h>
#pragma INCMSG("--- End <wtypes.h>")
#endif


#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#pragma INCMSG("--- Beg <mshtmhst.h>")
#include <mshtmhst.h>
#pragma INCMSG("--- End <mshtmhst.h>")
#endif

#ifndef X_MSHTML_H_
#define X_MSHTML_H_
#pragma INCMSG("--- Beg <mshtml.h>")
#include <mshtml.h>
#pragma INCMSG("--- End <mshtml.h>")
#endif


#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#pragma INCMSG("--- Beg <ddraw.h>")
#include <ddraw.h>
#pragma INCMSG("--- End <ddraw.h>")
#endif


#ifndef X_SHLWAPI_H_
#define X_SHLWAPI_H_
#pragma INCMSG("--- Beg <shlwapi.h>")
#include <shlwapi.h>
#pragma INCMSG("--- End <shlwapi.h>")
#endif


#define LIBID __T("MSTIME")

extern HINSTANCE g_hInst;

//+------------------------------------------------------------------------
//
//  Implement THR and IGNORE_HR for TIME code
//
//  This is to allow tracing of TIME-only THRs and IGNORE_HRs. Trident's THR 
//  and IGNORE_HR output is too polluted to allow TIME failures to be easily detected.
//
//-------------------------------------------------------------------------

#undef THR
#undef IGNORE_HR

#if DBG == 1
#define THR(x) THRTimeImpl(x, #x, __FILE__, __LINE__)
#define IGNORE_HR(x) IGNORE_HRTimeImpl(x, #x, __FILE__, __LINE__)
#else
#define THR(x) x
#define IGNORE_HR(x) x
#endif // if DBG == 1

//+------------------------------------------------------------------------
//
//  NO_COPY *declares* the constructors and assignment operator for copying.
//  By not *defining* these functions, you can prevent your class from
//  accidentally being copied or assigned -- you will be notified by
//  a linkage error.
//
//-------------------------------------------------------------------------

#define NO_COPY(cls)    \
    cls(const cls&);    \
    cls& operator=(const cls&)

#ifndef X_UTIL_H_
#define X_UTIL_H_
#pragma INCMSG("--- Beg 'util.h'")
#include "util.h"
#pragma INCMSG("--- End 'util.h'")
#endif

#ifndef X_MSTIME_H_
#define X_MSTIME_H_
#pragma INCMSG("--- Beg 'mstime.h'")
#include "mstime.h"
#pragma INCMSG("--- End 'mstime.h'")
#endif

#ifndef X_COMUTIL_H_
#define X_COMUTIL_H_
#pragma INCMSG("--- Beg 'comutil.h'")
#include "comutil.h"
#pragma INCMSG("--- End 'comutil.h'")
#endif

#ifndef X_TIMEENG_H_
#define X_TIMEENG_H_
#pragma INCMSG("--- Beg 'timeeng.h'")
#include "timeeng.h"
#pragma INCMSG("--- End 'timeeng.h'")
#endif

#ifndef X_LIST_
#define X_LIST_
#pragma INCMSG("--- Beg <list>")
#include <list>
#pragma INCMSG("--- End <list>")
#endif

#ifndef X_SET_
#define X_SET_
#pragma INCMSG("--- Beg <set>")
#include <set>
#pragma INCMSG("--- End <set>")
#endif

#ifndef X_ARRAY_H_
#define X_ARRAY_H_
#pragma INCMSG("--- Beg 'array.h'")
#include "array.h"
#pragma INCMSG("--- End 'array.h'")
#endif

#ifndef X_MAP_
#define X_MAP_
#pragma INCMSG("--- Beg <map>")
#include <map>
#pragma INCMSG("--- End <map>")
#endif

#ifndef X_SHLWAPI_H_
#define X_SHLWAPI_H_
#pragma INCMSG("--- Beg 'shlwapi.h'")
#include "shlwapi.h"
#pragma INCMSG("--- End 'shlwapi.h'")
#endif

#ifndef X_WININET_H_
#define X_WININET_H_
#pragma INCMSG("--- Beg <wininet.h>")
#include <wininet.h>
#pragma INCMSG("--- End <wininet.h>")
#endif

#ifndef X_MINMAX_H_
#define X_MINMAX_H_
#pragma INCMSG("--- Beg <minmax.h>")
#include <minmax.h>
#pragma INCMSG("--- End <minmax.h>")
#endif


#pragma warning(disable:4102)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\loader.h ===
// loader.h : 
//
// (c) 1999 Microsoft Corporation.
//

#ifndef __LOADER_H_
#define __LOADER_H_
#include <windows.h>
#include <objbase.h>
#include "dmusici.h"
#include <stdio.h>
#include <atlbase.h>

class CObjectRef
{
public:
    CObjectRef() { m_pNext = NULL; m_pObject = NULL; m_guidObject = GUID_NULL; m_wszFileName[0] = L'\0'; m_pStream = NULL; m_guidClass = GUID_NULL; };
    CObjectRef *    m_pNext;
    GUID            m_guidObject;
    WCHAR           m_wszFileName[DMUS_MAX_FILENAME];
    IDirectMusicObject *    m_pObject;
    IStream *       m_pStream;
    GUID            m_guidClass;
};

class CLoader : public IDirectMusicLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicLoader
	virtual STDMETHODIMP GetObject(LPDMUS_OBJECTDESC pDesc, REFIID, LPVOID FAR *) ;
	virtual STDMETHODIMP SetObject(LPDMUS_OBJECTDESC pDesc) ;
    virtual STDMETHODIMP SetSearchDirectory(REFGUID rguidClass, WCHAR *pwzPath, BOOL fClear) ;
	virtual STDMETHODIMP ScanDirectory(REFGUID rguidClass, WCHAR *pwzFileExtension, WCHAR *pwzScanFileName) ;
	virtual STDMETHODIMP CacheObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ReleaseObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ClearCache(REFGUID rguidClass) ;
	virtual STDMETHODIMP EnableCache(REFGUID rguidClass, BOOL fEnable) ;
	virtual STDMETHODIMP EnumObject(REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc) ;
	CLoader();
	~CLoader();
	ULONG				AddRefP();			// Private AddRef, for streams.
	ULONG				ReleaseP();			// Private Release, for streams.
	HRESULT				Init();

	// Returns the segment found at bstrSrc and remembers its URL so that subsequent GetObject
	// calls from the segment resolve relative to its filename.
	HRESULT				GetSegment(BSTR bstrSrc, IDirectMusicSegment **ppSeg);

private:
    HRESULT             LoadFromFile(LPDMUS_OBJECTDESC pDesc,
                            IDirectMusicObject * pIObject);
    HRESULT             LoadFromMemory(LPDMUS_OBJECTDESC pDesc,
                            IDirectMusicObject * pIObject);
    HRESULT             LoadFromStream(REFGUID rguidClass, IStream *pStream,
                            IDirectMusicObject * pIObject);
	long				m_cRef;             // Regular COM reference count.
	long				m_cPRef;			// Private reference count.
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage internal object list.
    CObjectRef *        m_pObjectList;      // List of already loaded objects.
	BSTR     			m_bstrSrc;			// Current source segment
};

class CFileStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CFileStream( CLoader *pLoader );
						~CFileStream();
	HRESULT				Open( WCHAR *lpFileName, DWORD dwDesiredAccess );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
    WCHAR           m_wszFileName[DMUS_MAX_FILENAME]; // Save name for cloning.
	HANDLE			m_pFile;		// file pointer
	CLoader *		m_pLoader;
};

class CMemStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CMemStream( CLoader *pLoader );
						~CMemStream();
	HRESULT				Open( BYTE *pbData, LONGLONG llLength );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
	BYTE*			m_pbData;		// memory pointer
	LONGLONG		m_llLength;
	LONGLONG		m_llPosition;	// Current file position.
	CLoader *		m_pLoader;
};


#endif //__CDMLOADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\mmutil.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMUTIL_H
#define _MMUTIL_H

#include "TimeEng.h"
#include "clock.h"
#include "float.h"

class MMBaseBvr;
class CTIMEElementBase;
class MMPlayer;

enum ELM_CHANGE_TYPE
{
    ELM_ADDED = 0,
    ELM_DELETED = 1
};

#if DBG
inline char *
EventString(TE_EVENT_TYPE et)
{
    switch(et) {
      case TE_EVENT_BEGIN:
        return "Begin";
      case TE_EVENT_END:
        return "End";
      case TE_EVENT_PAUSE:
        return "Pause";
      case TE_EVENT_RESUME:
        return "Resume";
      case TE_EVENT_REPEAT:
        return "Repeat";
      case TE_EVENT_AUTOREVERSE:
        return "Autoreverse";
      case TE_EVENT_RESET:
        return "Reset";
      case TE_EVENT_UPDATE:
        return "Update";
      case TE_EVENT_SEEK:
        return "Seek";
      case TE_EVENT_PARENT_TIMESHIFT:
        return "ParentTimeShift";
      case TE_EVENT_ENABLE:
        return "Enable";
      case TE_EVENT_DISABLE:
        return "Disable";
      default:
        return "Unknown";
    }
}
#endif

class MMBaseBvr
{
  public:
    MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMBaseBvr();

    bool Init(ITIMENode * node);
    virtual bool Init() = 0;

    HRESULT Begin(double dblOffset);
    HRESULT BeginAt(double dblParentTime,
                    double dblOffset);
    HRESULT End(double dblOffset);
    HRESULT EndAt(double dblParentTime,
                  double dblOffset);

    HRESULT Pause();
    HRESULT Resume();

    HRESULT Enable();
    HRESULT Disable();

    HRESULT Reset(bool bLightweight);

    virtual HRESULT Update(bool bUpdateBegin,
                           bool bUpdateEnd);

    HRESULT SeekSegmentTime(double dblSegmentTime);
    HRESULT SeekActiveTime(double dblActiveTime);
    HRESULT SeekTo(long lRepeatCount, double dblSegmentTime);

    HRESULT PutNaturalDur(double dblNaturalDur);
    double GetNaturalDur();

    void SetEndSync(bool b);
    void SetSyncMaster(bool b);
    
    void ElementChangeNotify(CTIMEElementBase & teb, ELM_CHANGE_TYPE ect);

    double DocumentTimeToParentTime(double documentTime);
    double ParentTimeToDocumentTime(double parentTime);
        
    double ParentTimeToActiveTime(double parentTime);
    double ActiveTimeToParentTime(double activeTime);

    double ActiveTimeToSegmentTime(double activeTime);
    double SegmentTimeToActiveTime(double segmentTime);

    double SegmentTimeToSimpleTime(double segmentTime);
    double SimpleTimeToSegmentTime(double simpleTime);

    double             GetSegmentTime() const;
    double             GetSegmentDur() const;
    double             GetSimpleTime() const;
    double             GetSimpleDur() const;
    double             GetProgress() const;
    LONG               GetCurrentRepeatCount() const;
    double             GetRepeatCount() const;
    double             GetRepeatDur() const;
    float              GetSpeed() const;
    float              GetCurrSpeed() const;
    double             GetActiveBeginTime() const;
    double             GetActiveEndTime() const;
    double             GetActiveTime() const;
    double             GetActiveDur() const;
    TE_STATE           GetPlayState() const;
    bool               IsPaused() const;
    bool               IsOn() const;
    bool               IsActive() const;
    bool               IsCurrPaused() const;
    double             GetCurrParentTime() const;
    void               SetEnabled (bool bEnabled);
    bool               GetEnabled (){return m_bEnabled;};
    void               SetZeroRepeatDur(bool bFlag){ m_bZeroRepeatDur = bFlag; };
    bool               IsDisabled() const;
    bool               IsCurrDisabled() const;

#if DBG
    const LPOLESTR GetID() { return m_id; }
#endif

    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD tePropType) { return true; }
    
    ITIMENode *        GetMMBvr() const { return m_bvr; }
    CTIMEElementBase & GetElement() const { return m_elm; }

    void               AddOneTimeValue(MMBaseBvr * pmmbvr,
                                   TE_TIMEPOINT tetp,
                                   double dblOffset,
                                   bool bBegin);
    void               AddSyncArcs(bool bBegin);
    void               ClearSyncArcs(bool bBegin);

  protected:
    

  protected:
    CTIMEElementBase & m_elm;
    bool m_bFireEvents;

    class TEBvr :
        public ITIMENodeBehavior
    {
      public:
        TEBvr();
        ~TEBvr();
        
        // IUnknown

        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);

        // ITIMENodeBehavior
        
        STDMETHOD(tick)();

        STDMETHOD(eventNotify)(double eventTime,
                               TE_EVENT_TYPE eventType,
                               long lRepeatCount);

        STDMETHOD(getSyncTime)(double * dblNewTime,
                               LONG * lNewRepeatCount,
                               VARIANT_BOOL * bCueing);

        STDMETHOD(propNotify)(DWORD tepPropType);
    
        void SetMMBvr(MMBaseBvr * t) { m_mmbvr = t; }

      protected:
        // This is a weak pointer and it is our parent's responsibility to
        // NULL this out before it goes away
        MMBaseBvr * m_mmbvr;
        long m_cRef;
    };

    friend TEBvr;

    DAComPtr<TEBvr> m_teb;
    MMBaseBvr();

    typedef std::multimap<CTIMEElementBase *, long> CookieMap;

    // Only syncArc are stored here so we can handle updating
    // correctly
    CookieMap m_cmBegin;
    CookieMap m_cmEnd;
#if DBG    
    LPOLESTR        m_id;
#endif

    bool DeleteFromCookieMap(bool bBegin, CTIMEElementBase & teb);
    bool CheckForSyncArc(bool bBegin, CTIMEElementBase & teb);
    
  private:
    // Make sure no one ever sets this themselves
    DAComPtr<ITIMENode> m_bvr;
    bool                m_bEnabled;
    bool                m_bZeroRepeatDur;

};

inline bool
MMBaseBvr::IsPaused() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isPaused(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsCurrPaused() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isCurrPaused(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsDisabled() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isDisabled(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsCurrDisabled() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_isCurrDisabled(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsOn() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr != NULL)
    {
        IGNORE_HR(m_bvr->get_isOn(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

inline bool
MMBaseBvr::IsActive() const
{
    VARIANT_BOOL vb = VARIANT_FALSE;
    
    if (m_bvr != NULL)
    {
        IGNORE_HR(m_bvr->get_isActive(&vb));
    }

    return (vb == VARIANT_FALSE)?false:true;
}

class MMBvr
    : public MMBaseBvr
{
  public:
    MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB);
    ~MMBvr();

    virtual bool Init();
  protected:
    bool m_fNeedSyncCB;
    MMBvr();
};

#endif /* _MMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\eventmgr.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1999 Microsoft Corporation
//
// File: EventMgr.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTMGR_H
#define _EVENTMGR_H

#include "mshtml.h"
#include "eventmgrmacros.h"
#include "timevalue.h"


#define INVALID_DISPID -1

///////////////////////////////////////////////////////////////
// This is the base class that must be implemented in the behavior
// to allow the event manager and the behavior class communicate.
///////////////////////////////////////////////////////////////

class CTIMEEventSite : 
    public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE EventNotify( 
        long event) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onBeginEndEvent(bool bBegin, float beginTime, float beginOffset, bool bend, float endTime, float endOffset) = 0;
   
    virtual HRESULT STDMETHODCALLTYPE onPauseEvent(float time, float offset) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onResumeEvent(float time, float offset) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onLoadEvent() = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onUnloadEvent() = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onReadyStateChangeEvent( 
        LPOLESTR lpstrReadyState) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE onStopEvent(float time) = 0;
    
    virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_playState( 
        /* [retval][out] */ long __RPC_FAR *time) = 0;
    
    virtual /* [propget] */ float GetGlobalTime() = 0;
               
    virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
    
    virtual ULONG STDMETHODCALLTYPE Release( void) = 0;

    virtual bool IsThumbnail() = 0;
    
};





///////////////////////////////////////////////////////////////
// structures
///////////////////////////////////////////////////////////////

struct EventItem
{
    LPOLESTR  pEventName;
    LPOLESTR  pElementName;
    bool      bAttach;       //this field indicates whether the event should be
                             //attached to.  It is used to flag duplicate events
                             //so that only a single event can be attached to.
    float     offset;        //for passing timing information back to the timeelmbase.
};

struct Event
{
    EventItem *pEventList; 
    DISPID *pEventDispids;          //list of dispids for document events for each type of event
    IHTMLElement2 **pEventElements; //cached list of IHTMLElements that each event list references
    long lEventCount;               //count of events in list
    bool *pbDynamicEvents;          //flags to show whether event is presumed to be dynamic or not
};


//
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// enums
///////////////////////////////////////////////////////////////
enum TIME_EVENT  //these are events that Event Manager can fire
{
    TE_ONTIMEERROR = 0,
    TE_ONBEGIN,
    TE_ONPAUSE, 
    TE_ONRESUME, 
    TE_ONEND,
    TE_ONRESYNC,
    TE_ONREPEAT,
    TE_ONREVERSE,
    TE_ONMEDIACOMPLETE,
    TE_ONOUTOFSYNC,
    TE_ONSYNCRESTORED,
    TE_ONMEDIAERROR,
    TE_ONRESET,
    TE_ONSCRIPTCOMMAND,
    TE_ONMEDIABARTARGET,
    TE_ONURLFLIP,
    TE_ONTRACKCHANGE,
    TE_GENERIC,
    TE_ONSEEK,
    TE_ONMEDIAINSERTED,
    TE_ONMEDIAREMOVED,
    TE_ONTRANSITIONINBEGIN,
    TE_ONTRANSITIONINEND,
    TE_ONTRANSITIONOUTBEGIN,
    TE_ONTRANSITIONOUTEND,
    TE_ONTRANSITIONREPEAT,
    TE_ONUPDATE,
    TE_ONCODECERROR,
    TE_MAX
};

enum TIME_EVENT_NOTIFY  //these are events that event manager can sync and notify the 
{                       //managed class of.
    TEN_LOAD = 0,
    TEN_UNLOAD,
    TEN_STOP,
    TEN_READYSTATECHANGE,
    TEN_MOUSE_DOWN,
    TEN_MOUSE_UP,
    TEN_MOUSE_CLICK,
    TEN_MOUSE_DBLCLICK,
    TEN_MOUSE_OVER,
    TEN_MOUSE_OUT,
    TEN_MOUSE_MOVE,
    TEN_KEY_DOWN,
    TEN_KEY_UP,
    TEN_FOCUS,
    TEN_RESIZE,
    TEN_BLUR,
    TEN_MAX
};

enum TIME_EVENT_TYPE
{
    TETYPE_BEGIN = 0,
    TETYPE_END
};
//
///////////////////////////////////////////////////////////////


class CEventMgr
    : public IDispatch
{
  public:
    CEventMgr();
    virtual ~CEventMgr();

    //methods

    // These are functions that are used by the macros
    // they should not be called directly.
    HRESULT _InitEventMgrNotify(CTIMEEventSite *pEventSite);
    HRESULT _RegisterEventNotification(TIME_EVENT_NOTIFY event_id);
    HRESULT _RegisterEvent(TIME_EVENT event_id);
    HRESULT _SetTimeEvent(int type, LPOLESTR lpstrEvents);
    HRESULT _SetTimeEvent(int type, TimeValueList & tvList);
    HRESULT _Init(IHTMLElement *pEle, IElementBehaviorSite *pEleBehaviorSite);
    HRESULT _Deinit();
    HRESULT _FireEvent(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[],
                       float fTime); 

    HRESULT _RegisterDynamicEvents(LPOLESTR lpstrEvents);  //unsure how this will be handled or used.
    HRESULT _ToggleEndEvent(bool bOn);

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

  protected:
    //////////////////////////////////////////////////
    //data
    //////////////////////////////////////////////////

    //Cookie for the Window ConnectionPoint
    CComPtr<IConnectionPoint>        m_pWndConPt;
    CComPtr<IConnectionPoint>        m_pDocConPt;

    Event                            *m_pBeginEvents;
    Event                            *m_pEndEvents;

    // event cookies
    long                              m_cookies[TE_MAX];
    DWORD                             m_dwWindowEventConPtCookie;
    DWORD                             m_dwDocumentEventConPtCookie;

    // callback interface
    CTIMEEventSite                   *m_pEventSite;
    CComPtr <IHTMLElement>           m_pElement; //This is the element that the behavior is attached to.

    // status flags
    bool                              m_bInited;
    float                             m_fLastEventTime;
    bool                              m_bAttached;
    bool                              m_bEndAttached;
    bool                              m_bUnLoaded;
                                                                                                                  //the playstate has already been updated
    // Registered events
    bool                              m_bRegisterEvents[TE_MAX];  //determines if the managed class wants 
                                                                  //to register the appropriate event.
    bool                              m_bNotifyEvents[TEN_MAX];   //determines if the managed class wants 
                                                                  //to be notified of the appropriate event.
    IElementBehaviorSiteOM           *m_pBvrSiteOM;
    long                              m_lRefs;
    bool                              m_bDeInited;
    bool                              m_bReady;
    long                              m_lEventRecursionCount;

    //////////////////////////////////////////////////
    //methods
    //////////////////////////////////////////////////
    HRESULT                           RegisterEvents();   
    HRESULT                           ConnectToContainerConnectionPoint();
    long                              GetEventCount(LPOLESTR lpstrEvents);
    void                              EventMatch(IHTMLEventObj *pEventObj, Event *pEvent, BSTR bstrEvent, TIME_EVENT_TYPE evType, float fTime, bool *bZeroOffsetMatch);
    void                              EventNotifyMatch(IHTMLEventObj *pEventObj);
    void                              AttachNotifyEvents();
    void                              DetachNotifyEvents();
    HRESULT                           AttachEvents();
    HRESULT                           Attach(Event *pEvents);
    HRESULT                           DetachEvents();
    HRESULT                           Detach(Event *pEvents);
    HRESULT                           FireDynamicEvent(TIME_EVENT TimeEvent, long Count, LPWSTR szParamNames[], VARIANT varParams[], float fTime);
    HRESULT                           SetNewEventList(LPOLESTR lpstrEvents, Event **EventList);
    HRESULT                           SetNewEventStruct(TimeValueList & tvList,
                                                        Event **ppEvents);
    HRESULT                           GetEvents(LPOLESTR lpstrEvents, EventItem *pEvents, long lEventCount);
    void                              FindDuplicateEvents();
    void                              MarkSelfDups(Event *pEvents);
    void                              MarkDups(Event *pSrcEvents, Event *pDestEvents);
    bool                              ValidateEvent(LPOLESTR lpstrEventName, IHTMLEventObj2 *pEventObj, IHTMLElement *pElement);
    int                               isTimeEvent(LPOLESTR lpszEventName);
    long                              GetEventCount(TimeValueList & tvList);
    void                              UpdateReadyState();
};

#endif /* _EVENTMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\eventmgrmacros.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelmbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _EVENTMGRMACROS_H
#define _EVENTMGRMACROS_H

#define TEM_BEGINEVENT 1
#define TEM_ENDEVENT 2

///////////////////////////////////////////////////////////////
// MACROS
///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// These make up calls that can only appear in the event map
///////////////////////////////////////////////////////////////


#define DECLARE_EVENT_MANAGER()             CEventMgr  *m_EventMgr;       

// creates an init function that sets data then calls _Init()
#define BEGIN_TIME_EVENTMAP()               virtual HRESULT _InitEventMgr(IHTMLElement *pEle, IElementBehaviorSite *pEleBehaviorSite) \
                                            {                                   \
                                                HRESULT hr = S_OK;              \
                                                CComPtr <IHTMLElement> pEle2 = NULL;    \
                                                m_EventMgr = NEW CEventMgr;    \
                                                if (!m_EventMgr)                \
                                                {                               \
                                                    goto done;                  \
                                                }                               


//calls _RegisterEvent
#define TEM_REGISTER_EVENT(event_id)                hr = THR(m_EventMgr->_RegisterEvent(event_id)); \
                                                    if (FAILED(hr))                     \
                                                    {                                   \
                                                        goto done;                      \
                                                    }                                   
        
// calls _RegisterEventNotification      
#define TEM_REGISTER_EVENT_NOTIFICATION(event_id)   hr = THR(m_EventMgr->_RegisterEventNotification(event_id)); \
                                                    if (FAILED(hr))                                 \
                                                    {                                               \
                                                        goto done;                                  \
                                                    }

//calls _InitEventMgrNotify                                              
#define TEM_INIT_EVENTMANAGER_SITE()                m_EventMgr->_InitEventMgrNotify((CTIMEEventSite *)this);                     \
                                                    
// handles some cleanup and closes the function started by BEGIN_TIME_EVENTMAP();
#define END_TIME_EVENTMAP()                         hr = THR(pEle->QueryInterface(IID_IHTMLElement, (void **)&pEle2)); \
                                                    if (FAILED(hr))                             \
                                                    {                                           \
                                                        goto done;                              \
                                                    }                                           \
                                                    m_EventMgr->_Init(pEle2, pEleBehaviorSite);  \
                                                  done:                                         \
                                                    return hr;                                  \
                                                }


///////////////////////////////////////////////////////////////
// These are macro's that can be used anywhere.
///////////////////////////////////////////////////////////////

//calls into the init function created by BEGIN_TIME_EVENTMAP()
// This takes an HRESULT hr that should be checked on return. 
// an IHTMLElement *pEle that is the element the behavior is attached to,
// an IHTMLElementBehaviorSite *pEleBehaviorSite.
#define TEM_INIT_EVENTMANAGER(pEle, pEleBehaviorSite)   THR(_InitEventMgr(pEle, pEleBehaviorSite))
                                                        

//calls _Deinit
// This will return an HRESULT that should be checked for success
#define TEM_CLEANUP_EVENTMANAGER()      if (NULL != m_EventMgr) \
                                        { \
                                            IGNORE_HR(m_EventMgr->_Deinit());   \
                                        }

//deletes the eventmgr.
#define TEM_DELETE_EVENTMGR()           if (NULL != m_EventMgr) \
                                        { \
                                            delete m_EventMgr;                  \
                                            m_EventMgr = NULL; \
                                        }

//calls _FireEvent
// This will return an HRESULT that should be checked for success
#define TEM_FIRE_EVENT(event, param_count, param_names, params, time)  (m_EventMgr != NULL ? THR(m_EventMgr->_FireEvent(event, param_count, param_names, params, time)) : E_FAIL)

//calls _SetBeginEvent
// This will return an HRESULT that should be checked for success
#define TEM_SET_TIME_BEGINEVENT(event_list)     (m_EventMgr != NULL ? THR(m_EventMgr->_SetTimeEvent(TEM_BEGINEVENT, event_list)) : E_FAIL)

//calls _SetEndEvent
// This will return an HRESULT that should be checked for success
#define TEM_SET_TIME_ENDEVENT(event_list)       (m_EventMgr != NULL ? THR(m_EventMgr->_SetTimeEvent(TEM_ENDEVENT, event_list)) : E_FAIL)

//calls _ToggleEndEvent
#define TEM_TOGGLE_END_EVENT(bOn)               (m_EventMgr != NULL ? m_EventMgr->_ToggleEndEvent(bOn) : E_FAIL)

// used in constructor to initialize the eventmanager
#define TEM_DECLARE_EVENTMGR()                  (m_EventMgr = NULL)
// used in destructor to free the eventmanager
#define TEM_FREE_EVENTMGR()                     if (m_EventMgr != NULL) \
                                                {                       \
                                                    delete m_EventMgr;  \
                                                    m_EventMgr = NULL;  \
                                                }                       

//calls _RegisterDynamicEvents
// This will return an HRESULT that should be checked for success
// UNDONE;
#define REGISTER_DYNAMIC_TIME_EVENTS(eventlist)                 
//
///////////////////////////////////////////////////////////////

#endif /* _EVENTMGRMACROS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\importman.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\importman.h
//
//  Contents: declaration for CImportManager, CImportManagerList
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _IMPORTMAN_H
#define _IMPORTMAN_H

#include "threadsafelist.h"

#include "atomtable.h"

class CImportManager;

static const LONG NUMBER_THREADS_TO_SPAWN = 2;

CImportManager* GetImportManager(void);

class CImportManagerList :
    public CThreadSafeList
{
  public:
    CImportManagerList();
    virtual ~CImportManagerList();
  
    virtual HRESULT Add(ITIMEImportMedia * pImportMedia);

  protected:
    HRESULT FindMediaDownloader(ITIMEImportMedia * pImportMedia, ITIMEMediaDownloader** ppDownloader, bool * pfExisted);
    HRESULT GetNode(std::list<CThreadSafeListNode*> &listToCheck, const long lID, bool * pfExisted, ITIMEMediaDownloader ** ppMediaDownloader);
};


class CImportManager
{
  public:
    CImportManager();
    virtual ~CImportManager();

    HRESULT Init();
    HRESULT Detach();

    HRESULT Add(ITIMEImportMedia * pImportMedia);
    HRESULT Remove(ITIMEImportMedia * pImportMedia);

    HRESULT DataAvailable();
    
    HRESULT RePrioritize(ITIMEImportMedia * pImportMedia);

  protected:
    CImportManager(const CImportManager&);

    HRESULT StartThreads();

  private:
    HANDLE m_handleThread[NUMBER_THREADS_TO_SPAWN];
    CImportManagerList * m_pList;

    LONG m_lThreadsStarted;
};

#endif // _IMPORTMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\pbagimp.cpp ===
//*****************************************************************************
//
// File: pbagimp.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of IPersistPropertyBag2 interface
//           for all objects to call to base class.
//
// Modification List:
// Date		Author		Change
// 11/21/98	jeffort		Created this file
//
//*****************************************************************************

STDMETHODIMP 
THIS::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
THIS::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
THIS::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return SUPER::Load(pPropBag, pErrorLog);
} // Load

//*****************************************************************************

STDMETHODIMP 
THIS::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);

} // Save 

//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\playerbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: playerbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _PLAYERBASE_H
#define _PLAYERBASE_H

#include "playerinterfaces.h"
#include "atomtable.h"

class CPlayList;
class CTIMEMediaElement;
class CTIMEPlayerNative;
/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

typedef enum SYNC_TYPE_ENUM
{
    sync_slow,
    sync_fast,
    sync_none
}; //lint !e612

interface ITIMEBasePlayer :
    public IUnknown,
    public ITIMEPlayerObjectManagement,
    public ITIMEPlayerEventHandling,
    public ITIMEPlayerPlaybackCapabilities,
    public ITIMEPlayerStateManagement,
    public ITIMEPlayerRender,
    public ITIMEPlayerTiming,
    public ITIMEPlayerProperties,
    public ITIMEPlayerMediaContent,
    public ITIMEPlayerPlayList,
    public ITIMEPlayerIntegration,
    public ITIMEPlayerMediaContext
{
//    virtual void SetCLSID(REFCLSID clsid) = 0;
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) = 0;

    virtual HRESULT SetRate(double dblRate) = 0;
    virtual HRESULT GetRate(double &dblRate) = 0;

    virtual HRESULT onMouseMove(long x, long y) = 0;
    virtual HRESULT onMouseDown(long x, long y) = 0;

    virtual void LoadFailNotify(PLAYER_EVENT reason) = 0;
    virtual void Tick() = 0;
};

class CTIMEBasePlayer :
    public ITIMEBasePlayer
{
  public:
    CTIMEBasePlayer();
    virtual ~CTIMEBasePlayer();

    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(QueryInterface)(REFIID refiid, void** ppunk) { return E_NOTIMPL; }
    STDMETHOD_(ULONG,AddRef)(void) { return 0; }
    STDMETHOD_(ULONG,Release)(void) { return 0; }
    virtual HRESULT Init(CTIMEMediaElement *pelem, 
                         LPOLESTR base, 
                         LPOLESTR src, 
                         LPOLESTR lpMimeType = NULL, 
                         double dblClipBegin = -1.0, 
                         double dblClipEnd = -1.0);
    virtual HRESULT DetachFromHostElement (void) = 0;
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp)
    { *ppDisp = NULL; return S_OK;}
    virtual CTIMEPlayerNative *GetNativePlayer()
    { return NULL;}
    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Pause() = 0;
    virtual void Resume() = 0;
    virtual void Repeat() = 0;
    virtual HRESULT Seek(double dblTime) = 0;
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT CanSeek(bool &fcanSeek) = 0;
    virtual HRESULT CanPause(bool &fcanPause);
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT HasPlayList(bool &fhasPlayList);
    virtual HRESULT ConvertFrameToTime(LONGLONG lFrameNr, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);
    // PLAYER PLAYBACK CAPABILITIES: END

    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Reset();
    virtual PlayerState GetState();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();
    virtual void Tick();
    virtual void LoadFailNotify(PLAYER_EVENT reason);
    virtual void SetPlaybackSite(CTIMEBasePlayer *pSite);
    virtual void FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer = NULL);

    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Render(HDC hdc, LPRECT prc) = 0;
    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);
    virtual HRESULT SetSize(RECT *prect) = 0;
    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetMediaLength(double &dblLength) = 0;
    virtual HRESULT GetEffectiveLength(double &dblLength);
    virtual double GetClipBegin();
    virtual void GetClipBegin(double &dblClibBegin);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void GetClipEnd(double &dblClipEnd);
    virtual void SetClipEnd(double dblClipEnd);
    virtual void GetClipBeginFrame(long &lClibBeginFrame);
    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void GetClipEndFrame(long &lClipEndFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);
    virtual double GetCurrentTime() = 0;
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime) = 0;
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);
    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PROPERTY ACCESSORS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src) = 0;
    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pRating) ;
    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    //////////////////////////////////////////////////////////////////////////
    // PROPERTY METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle);
    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: END
    //////////////////////////////////////////////////////////////////////////

    virtual HRESULT onMouseMove(long x, long y);
    virtual HRESULT onMouseDown(long x, long y);

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);

    // These are to make our internal implementation of playlists work
    // with all players
    virtual HRESULT SetActiveTrack(long index);
    virtual HRESULT GetActiveTrack(long *index);

    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT GetDownloadProgress(double &dblDownloadProgress);

    bool IsActive() const;
    bool IsPaused() const;
    bool IsParentPaused() const;

    // This does not addref so be careful what you do with it
    IHTMLElement * GetElement();
    IServiceProvider * GetServiceProvider();

    void InvalidateElement(LPCRECT lprect);
    void PutNaturalDuration(double dblNatDur);
    void ClearNaturalDuration();
    double GetElapsedTime() const;

    double GetRealClipStart() const { return m_dblClipStart; }
    double GetRealClipEnd() const { return m_dblClipEnd; }

  protected:
    virtual HRESULT InitElementSize();

    long VolumeLinToLog(float LinKnobValue);
    float VolumeLogToLin(long LogValue);
    long BalanceLinToLog(float LinKnobValue);
    float BalanceLogToLin(long LogValue);

    CAtomTable * GetAtomTable() { return m_pAtomTable; }
    void NullAtomTable()
    { 
        if (m_pAtomTable)
            {
                ReleaseInterface(m_pAtomTable);
            }
        m_pAtomTable = NULL;
    }

    CTIMEMediaElement *m_pTIMEElementBase;
    CTIMEBasePlayer *m_pPlaybackSite;
    
    double m_dblClipStart;
    double m_dblClipEnd;
    long m_lClipStartFrame;
    long m_lClipEndFrame;

  private:
    bool m_fHavePriority;
    double m_dblPriority;
    CAtomTable *m_pAtomTable;
};

#endif /* _PLAYERBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    DALite Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H



#define RESID_TYPELIB           1
#define RESID_TYPELIB_PRIVATE   2


/////////////////////////////////////////////////////////////////////////////
// String resource IDs

#define IDR_INVALID_ARG             0x10


#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\timeelmimpl.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\timeelmimpl.h
//
//  Contents: Implements ITIMEElement (delegates to base_xxxx methods)
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _TIMEELMIMPL_H
#define _TIMEELMIMPL_H

#include "../timebvr/timeelmbase.h"


//+-------------------------------------------------------------------------------------
//
// CTIMEElementImpl
//
//--------------------------------------------------------------------------------------

template <class T, const IID* pIID_T> 
class 
ATL_NO_VTABLE 
CTIMEElementImpl :
    public CTIMEElementBase,
    public ITIMEDispatchImpl<T, pIID_T>
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    virtual ~CTIMEElementImpl() { }

    //
    // ITIMEElement properties
    //
    
    STDMETHOD(get_accelerate)(VARIANT * v)
    { return CTIMEElementBase::base_get_accelerate(v); }
    STDMETHOD(put_accelerate)(VARIANT v)
    { return CTIMEElementBase::base_put_accelerate(v); }

    STDMETHOD(get_autoReverse)(VARIANT * b)
    { return CTIMEElementBase::base_get_autoReverse(b); }
    STDMETHOD(put_autoReverse)(VARIANT b)
    { return CTIMEElementBase::base_put_autoReverse(b); }

    STDMETHOD(get_begin)(VARIANT * time)
    { return CTIMEElementBase::base_get_begin(time); }
    STDMETHOD(put_begin)(VARIANT time)
    { return CTIMEElementBase::base_put_begin(time); }

    STDMETHOD(get_decelerate)(VARIANT * v)
    { return CTIMEElementBase::base_get_decelerate(v); }
    STDMETHOD(put_decelerate)(VARIANT v)
    { return CTIMEElementBase::base_put_decelerate(v); }

    STDMETHOD(get_dur)(VARIANT * time)
    { return CTIMEElementBase::base_get_dur(time); }
    STDMETHOD(put_dur)(VARIANT time)
    { return CTIMEElementBase::base_put_dur(time); }

    STDMETHOD(get_end)(VARIANT * time)
    { return CTIMEElementBase::base_get_end(time); }
    STDMETHOD(put_end)(VARIANT time)
    { return CTIMEElementBase::base_put_end(time); }

    STDMETHOD(get_fill)(LPOLESTR * f)
    { return CTIMEElementBase::base_get_fill(f); }
    STDMETHOD(put_fill)(LPOLESTR f)
    { return CTIMEElementBase::base_put_fill(f); }

    STDMETHOD(get_mute)(VARIANT *b)
    { return CTIMEElementBase::base_get_mute(b); }
    STDMETHOD(put_mute)(VARIANT b)
    { return CTIMEElementBase::base_put_mute(b); }

    STDMETHOD(get_repeatCount)(VARIANT * c)
    { return CTIMEElementBase::base_get_repeatCount(c); }
    STDMETHOD(put_repeatCount)(VARIANT c)
    { return CTIMEElementBase::base_put_repeatCount(c); }

    STDMETHOD(get_repeatDur)(VARIANT * time)
    { return CTIMEElementBase::base_get_repeatDur(time); }
    STDMETHOD(put_repeatDur)(VARIANT time)
    { return CTIMEElementBase::base_put_repeatDur(time); }

    STDMETHOD(get_restart)(LPOLESTR * r)
    { return CTIMEElementBase::base_get_restart(r); }
    STDMETHOD(put_restart)(LPOLESTR r)
    { return CTIMEElementBase::base_put_restart(r); }

    STDMETHOD(get_speed)(VARIANT * speed)
    { return CTIMEElementBase::base_get_speed(speed); }
    STDMETHOD(put_speed)(VARIANT speed)
    { return CTIMEElementBase::base_put_speed(speed); }

    STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
    { return CTIMEElementBase::base_get_syncBehavior(sync); }
    STDMETHOD(put_syncBehavior)(LPOLESTR sync)
    { return CTIMEElementBase::base_put_syncBehavior(sync); }

    STDMETHOD(get_syncTolerance)(VARIANT * tol)
    { return CTIMEElementBase::base_get_syncTolerance(tol); }
    STDMETHOD(put_syncTolerance)(VARIANT tol)
    { return CTIMEElementBase::base_put_syncTolerance(tol); }

    STDMETHOD(get_syncMaster)(VARIANT * b)
    { return CTIMEElementBase::base_get_syncMaster(b); }
    STDMETHOD(put_syncMaster)(VARIANT b)
    { return CTIMEElementBase::base_put_syncMaster(b); }

    STDMETHOD(get_timeAction)(LPOLESTR * time)
    { return CTIMEElementBase::base_get_timeAction(time); }
    STDMETHOD(put_timeAction)(LPOLESTR time)
    { return CTIMEElementBase::base_put_timeAction(time); }

    STDMETHOD(get_timeContainer)(LPOLESTR *tl)
    { return CTIMEElementBase::base_get_timeContainer(tl); }

    STDMETHOD(get_volume)(VARIANT * vol)
    { return CTIMEElementBase::base_get_volume(vol); }
    STDMETHOD(put_volume)(VARIANT vol)
    { return CTIMEElementBase::base_put_volume(vol); }

    // Properties
    STDMETHOD(get_currTimeState)(ITIMEState ** TimeState)
    { return CTIMEElementBase::base_get_currTimeState(TimeState); }

    STDMETHOD(get_timeAll)(ITIMEElementCollection **allColl)
    { return CTIMEElementBase::base_get_timeAll(allColl); }

    STDMETHOD(get_timeChildren)(ITIMEElementCollection **childColl)
    { return CTIMEElementBase::base_get_timeChildren(childColl); }

    STDMETHOD(get_timeParent)(ITIMEElement ** parent)
    { return CTIMEElementBase::base_get_timeParent(parent); }

    STDMETHOD(get_isPaused)(VARIANT_BOOL * b)
    { return CTIMEElementBase::base_get_isPaused(b); }

    // Methods
    STDMETHOD(beginElement)()
    { return CTIMEElementBase::base_beginElement(0.0); }

    STDMETHOD(beginElementAt)(double parentTime)
    { return CTIMEElementBase::base_beginElementAt(parentTime, 0.0); }

    STDMETHOD(endElement)()
    { return CTIMEElementBase::base_endElement(0.0); }

    STDMETHOD(endElementAt)(double parentTime)
    { return CTIMEElementBase::base_endElementAt(parentTime, 0.0); }

    STDMETHOD(pauseElement)()
    { return CTIMEElementBase::base_pauseElement(); }

    STDMETHOD(resetElement)()
    { return CTIMEElementBase::base_resetElement(); }

    STDMETHOD(resumeElement)()
    { return CTIMEElementBase::base_resumeElement(); }

    STDMETHOD(seekActiveTime)(double activeTime)
    { return CTIMEElementBase::base_seekActiveTime(activeTime); }
        
    STDMETHOD(seekSegmentTime)(double segmentTime)
    { return CTIMEElementBase::base_seekSegmentTime(segmentTime); }
        
    STDMETHOD(seekTo)(LONG repeatCount, double segmentTime)
    { return CTIMEElementBase::base_seekTo(repeatCount, segmentTime); }
        
    STDMETHOD(documentTimeToParentTime)(double documentTime,
                                        double * parentTime)
    { return CTIMEElementBase::base_documentTimeToParentTime(documentTime,
                                                        parentTime); }
        
    STDMETHOD(parentTimeToDocumentTime)(double parentTime,
                                        double * documentTime)
    { return CTIMEElementBase::base_parentTimeToDocumentTime(parentTime,
                                                        documentTime); }
        
    STDMETHOD(parentTimeToActiveTime)(double parentTime,
                                      double * activeTime)
    { return CTIMEElementBase::base_parentTimeToActiveTime(parentTime,
                                                      activeTime); }
        
    STDMETHOD(activeTimeToParentTime)(double activeTime,
                                      double * parentTime)
    { return CTIMEElementBase::base_activeTimeToParentTime(activeTime,
                                                      parentTime); }
        
    STDMETHOD(activeTimeToSegmentTime)(double activeTime,
                                       double * segmentTime)
    { return CTIMEElementBase::base_activeTimeToSegmentTime(activeTime,
                                                       segmentTime); }
        
    STDMETHOD(segmentTimeToActiveTime)(double segmentTime,
                                       double * activeTime)
    { return CTIMEElementBase::base_segmentTimeToActiveTime(segmentTime,
                                                       activeTime); }
        
    STDMETHOD(segmentTimeToSimpleTime)(double segmentTime,
                                       double * simpleTime)
    { return CTIMEElementBase::base_segmentTimeToSimpleTime(segmentTime,
                                                       simpleTime); }
        
    STDMETHOD(simpleTimeToSegmentTime)(double simpleTime,
                                       double * segmentTime)
    { return CTIMEElementBase::base_simpleTimeToSegmentTime(simpleTime,
                                                       segmentTime); }
        
    // Container attributes
    STDMETHOD(get_endSync)(LPOLESTR * es)
    { return CTIMEElementBase::base_get_endSync(es); }
    STDMETHOD(put_endSync)(LPOLESTR es)
    { return CTIMEElementBase::base_put_endSync(es); }

    // Container Properties
    STDMETHOD(get_activeElements)(ITIMEActiveElementCollection **activeColl)
    { return CTIMEElementBase::base_get_activeElements(activeColl); }
    STDMETHOD(get_hasMedia)(VARIANT_BOOL * pvbVal)
    { return CTIMEElementBase::base_get_hasMedia(pvbVal); }

    // Container Methods
    STDMETHOD(nextElement)()
    { return CTIMEElementBase::base_nextElement(); }
    STDMETHOD(prevElement)()
    { return CTIMEElementBase::base_prevElement(); }

    STDMETHOD(get_updateMode)(BSTR * pbstrUpdateMode)
    { return CTIMEElementBase::base_get_updateMode(pbstrUpdateMode); }
    STDMETHOD(put_updateMode)(BSTR bstrUpdateMode)
    { return CTIMEElementBase::base_put_updateMode(bstrUpdateMode); }
    
  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // hide these
    CTIMEElementImpl() { }
    NO_COPY(CTIMEElementImpl);

}; // CTIMEElementImpl

#endif // _TIMEELMIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\playlist.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYLIST_H
#define _PLAYLIST_H

class CTIMEBasePlayer;
class CPlayItem;

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayList :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayList, &__uuidof(CPlayList)>,
    public ITIMEDispatchImpl<ITIMEPlayList, &IID_ITIMEPlayList>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayList>,
    public IConnectionPointContainerImpl<CPlayList>,
    public IPropertyNotifySinkCP<CPlayList>
{
  public:
    CPlayList();
    virtual ~CPlayList();
    HRESULT ConstructArray();
        
    HRESULT Init(CTIMEBasePlayer & player);
    void Deinit();
    
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    // 
    // ITIMEPlayList methods
    //
        
    STDMETHOD(put_activeTrack)(VARIANT vTrack);
    STDMETHOD(get_activeTrack)(ITIMEPlayItem **pPlayItem);
        
    //returns the duration of the entire playlist if it is known or -1 if it is not.
    STDMETHOD(get_dur)(double *dur);

    STDMETHOD(item)(VARIANT varIndex,
                    ITIMEPlayItem **pPlayItem);

    STDMETHOD(get_length)(long* len);

    STDMETHOD(get__newEnum)(IUnknown** p);

    STDMETHOD(nextTrack)(); //Advances the active Track by one
    STDMETHOD(prevTrack)(); //moves the active track to the previous track

    //    
    // QI & CP Map
    //

    BEGIN_COM_MAP(CPlayList)
        COM_INTERFACE_ENTRY(ITIMEPlayList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CPlayList)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

    void Clear();
    void SetLoaded(bool bLoaded);
    void SetLoadedFlag(bool bLoaded);
    long GetLength() { return m_rgItems->Size(); }

    CPlayItem * GetActiveTrack();
    CPlayItem * GetItem(long index);
    
    HRESULT Add(CPlayItem *pPlayItem,
                long index);
    HRESULT Remove(long index);

    void SetIndex();
    long GetIndex(LPOLESTR name);

    HRESULT CreatePlayItem(CPlayItem **pPlayItem);
        
  protected:
    CPtrAry<CPlayItem *>      *m_rgItems;
    CTIMEBasePlayer *          m_player;
    bool                       m_fLoaded;
    CComVariant                m_vNewTrack;

}; //lint !e1712


class CPlayListEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{
  public:
    CPlayListEnum();
    virtual ~CPlayListEnum();

    void Init(CPlayList &playList) { m_playList = &playList; }
    
    // IEnumVARIANT methods
    STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
    STDMETHOD(Next)(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
    STDMETHOD(Reset)();
    STDMETHOD(Skip)(unsigned long celt);
    void SetCurElement(unsigned long celt);
                        
    // QI Map
    BEGIN_COM_MAP(CPlayListEnum)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP();

  protected:
    long                        m_lCurElement;
    DAComPtr<CPlayList>         m_playList;
}; //lint !e1712

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayItem :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayItem, &__uuidof(CPlayItem)>,
    public ITIMEDispatchImpl<ITIMEPlayItem2, &IID_ITIMEPlayItem2>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayItem2>,
    public IConnectionPointContainerImpl<CPlayItem>,
    public IPropertyNotifySinkCP<CPlayItem>
{
  public:
    CPlayItem();
    virtual ~CPlayItem();

    void Init(CPlayList & pPlayList) { m_pPlayList = &pPlayList; }
    void Deinit() { m_pPlayList = NULL; }
    
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // ITIMEPlayItem interface
    //
    STDMETHOD(get_abstract)(LPOLESTR *abs);
    STDMETHOD(get_author)(LPOLESTR *auth);
    STDMETHOD(get_copyright)(LPOLESTR *cpyrght);
    STDMETHOD(get_dur)(double *dur);
    STDMETHOD(get_index)(long *index);
    STDMETHOD(get_rating)(LPOLESTR *rate);
    STDMETHOD(get_src)(LPOLESTR *src);
    STDMETHOD(get_title)(LPOLESTR *title);
    STDMETHOD(setActive)();

    
    //
    // ITIMEPlayItem2 interface
    //
    STDMETHOD(get_banner)(LPOLESTR *banner);
    STDMETHOD(get_bannerAbstract)(LPOLESTR *abstract);
    STDMETHOD(get_bannerMoreInfo)(LPOLESTR *moreInfo);
    
    //
    
    LPCWSTR GetAbstract() const { return m_abstract; }
    HRESULT PutAbstract(LPWSTR abstract);

    LPCWSTR GetAuthor() const { return m_author; }
    HRESULT PutAuthor(LPWSTR author);

    LPCWSTR GetCopyright() const { return m_copyright; }
    HRESULT PutCopyright(LPWSTR copyright);

    double GetDur() const { return m_dur; }
    void PutDur(double dur);

    long GetIndex() const { return m_lIndex; }
    void PutIndex(long index);

    LPCWSTR GetRating() const { return m_rating; }
    HRESULT PutRating(LPWSTR rating);

    LPCWSTR GetSrc() const { return m_src; }
    HRESULT PutSrc(LPWSTR src);

    LPCWSTR GetTitle() const { return m_title; }
    HRESULT PutTitle(LPWSTR title);

    bool GetCanSkip() const { return m_fCanSkip; }
    HRESULT PutCanSkip(bool fCanSkip) { m_fCanSkip = fCanSkip; return S_OK; }

    LPCWSTR GetBanner() const { return m_banner; };
    LPCWSTR GetBannerAbstract() const { return m_bannerAbstract; };
    LPCWSTR GetBannerMoreInfo() const { return m_bannerMoreInfo; };
    HRESULT PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo);

    // QI Map
    BEGIN_COM_MAP(CPlayItem)
        COM_INTERFACE_ENTRY(ITIMEPlayItem2)
        COM_INTERFACE_ENTRY(ITIMEPlayItem)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CPlayItem)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

  protected:
    CPlayList            *m_pPlayList;
    LPWSTR                m_abstract;
    LPWSTR                m_author;
    LPWSTR                m_copyright;
    double                m_dur;
    int                   m_lIndex;
    LPWSTR                m_rating;
    LPWSTR                m_src;
    LPWSTR                m_title;
    bool                  m_fCanSkip;
    LPWSTR                m_banner;
    LPWSTR                m_bannerAbstract;
    LPWSTR                m_bannerMoreInfo;


};  //lint !e1712

#endif /* _PLAYLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\threadsafelist.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\threadsafelist.h
//
//  Contents: declarations for CThreadSafeList, and CThreadSafeListNode
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _THREADSAFELIST_H
#define _THREADSAFELIST_H

#include "mstimep.h"

static const DWORD TIMEOUT = 1000 * 30; // 1000 milliseconds/second * 30 seconds

DWORD PumpMessagesWhileWaiting(HANDLE * pHandleArray, UINT iHandleCount, DWORD dwTimeOut);

class CThreadSafeListNode
{
  public:
      CThreadSafeListNode(ITIMEImportMedia * pElement) :
        m_spElement(pElement), m_fRemove(false) { ; }

    virtual ~CThreadSafeListNode() {;}

    ITIMEImportMedia * GetElement() { return m_spElement; }

    void RemoveWhenDone() { m_fRemove = true; }
    bool GetRemoveWhenDone() { return m_fRemove; }

  protected:
    CThreadSafeListNode();
    CThreadSafeListNode(const CThreadSafeListNode&);

  private:
    CComPtr<ITIMEImportMedia>      m_spElement;
    bool            m_fRemove;
};

class CThreadSafeList :
 public IUnknown
{
  public:
    CThreadSafeList();
    virtual ~CThreadSafeList();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
    virtual ULONG STDMETHODCALLTYPE AddRef( void);
        
    virtual ULONG STDMETHODCALLTYPE Release( void);

    virtual HRESULT Init();
    virtual HRESULT Detach();

    virtual HRESULT Add(ITIMEImportMedia * pImportMedia);
    virtual HRESULT Remove(ITIMEImportMedia * pImportMedia);

    virtual HRESULT ReturnElement(ITIMEImportMedia * pOldMedia);
    virtual HRESULT GetNextElement(ITIMEImportMedia ** pNewMedia, bool fBlockThread = true); //lint !e1735

    virtual HRESULT DataAvailable();
    
    virtual HRESULT RePrioritize(ITIMEImportMedia * pImportMedia);

    virtual LONG Size() { return m_listToDoDownload.size() + m_listCurrentDownload.size() + m_listDoneDownload.size(); }

    virtual LONG GetThreadsWaiting();
    
  protected:
    CThreadSafeList (const CThreadSafeList&);

    CThreadSafeListNode * GetNextMediaToCue();
    HRESULT ClearList(std::list<CThreadSafeListNode*> &listToClear);

  protected:
    CritSect                            m_CriticalSection;

    std::list<CThreadSafeListNode*>     m_listToDoDownload;
    std::list<CThreadSafeListNode*>     m_listCurrentDownload;
    std::list<CThreadSafeListNode*>     m_listDoneDownload;

  private:

    HANDLE                              m_hDataAvailable;
    HANDLE                              m_hDataRecieved;
    HANDLE                              m_hShutdown;

    LONG                                m_lThreadsWaiting;
    LONG                                m_lRefCount;
};


#endif // _THREADSAFELIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\timer.h ===
#pragma once

#ifndef _TIMER_H__
#define _TIMER_H__

class CTIMETimer
{
  public:
      CTIMETimer(bool fBeginNow = false) : 
  m_bStarted(false),
  m_iBeginTime(0),
  m_iusecSumTime(0)
{
    QueryPerformanceFrequency((LARGE_INTEGER *)&m_iFreq);

    if (fBeginNow)
    {
        Start();
    }
}

    ~CTIMETimer() { }

    inline void Start();
    inline void Stop();
    void Clear() { Assert(!m_bStarted); m_iusecSumTime = 0; }

    // micro-second time
    LONG usecTime() { Assert(!m_bStarted); return m_iusecSumTime; }

    // milli-second time
    LONG msecTime() { Assert(!m_bStarted); return m_iusecSumTime / 1000; }

    bool IsStopped() { return !m_bStarted; }

  private:
    __int64 m_iBeginTime;
    __int64 m_iusecSumTime;
    __int64 m_iFreq;

    bool m_bStarted;
};


inline void
CTIMETimer::Start()
{
#ifdef DBG
    Assert(!m_bStarted);
    m_bStarted = true;
#endif

    QueryPerformanceCounter((LARGE_INTEGER *)&m_iBeginTime);    
}

inline void
CTIMETimer::Stop()
{
    __int64 iEndTime;
    QueryPerformanceCounter((LARGE_INTEGER *)&iEndTime);

#ifdef DBG
    Assert(m_bStarted);
    m_bStarted = false;
#endif

    __int64 usecdelta = (((iEndTime - m_iBeginTime) * 1000000) / m_iFreq);

    m_iusecSumTime += usecdelta;
}


#endif // _TIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\playerinterfaces.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: playerinterfaces.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _PLAYERINTERFACES_H
#define _PLAYERINTERFACES_H

class CTIMEMediaElement;
class CPlayList;
class CTIMEBasePlayer;

typedef enum PlayerState
{
    PLAYER_STATE_ACTIVE,
    PLAYER_STATE_INACTIVE,
    PLAYER_STATE_SEEKING,
    PLAYER_STATE_CUEING,
    PLAYER_STATE_HOLDING,
    PLAYER_STATE_UNKNOWN
} tagPlayerState;

typedef
enum PLAYER_EVENT  //these are events that players can fire into the media element.
{
    PE_ONMEDIACOMPLETE,
    PE_ONTRACKCOMPLETE,
    PE_ONMEDIAEND,
    PE_ONMEDIASLIPSLOW,
    PE_ONMEDIASLIPFAST,
    PE_ONSYNCRESTORED,
    PE_ONSCRIPTCOMMAND,
    PE_ONRESIZE,
    PE_ONSEEKDONE,
    PE_ONMEDIAINSERTED,
    PE_ONMEDIAREMOVED,
    PE_ONMEDIALOADFAILED,
    PE_ONMEDIATRACKCHANGED,
    PE_METAINFOCHANGED,
    PE_ONMEDISYNCGAIN,
    PE_ONMEDIAERRORCOLORKEY,
    PE_ONMEDIAERRORRENDERFILE,
    PE_ONMEDIAERROR,
    PE_ONCODECERROR,
    PE_MAX
};

interface ITIMEPlayerObjectManagement
{
    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS
    // METHOD SYNOPSIS:
    // SetCLSID: is used to set class id on players that host windowless controls.
    //   this method should be called before the init method. The WMP player is hosted
    //   with the CTIMEPlayer class.
    // Init: is called by the mediaelement to initialize the player. If
    //   the player does not support dynamic changing of source this method
    //   changes the source by rebuilding the player. Before calling Init
    //   again DetachFromHostElement is called to release all player resources.
    // DetachFromHostElement: is called by the mediaelement before the element
    //   is removed or before rebuilding the player with a call on Init.
    // GetExternalPlayerDispatch: This method returns a pointer to a IDispatch interface if the
    // player implements it.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Init(CTIMEMediaElement *pelem, 
                         LPOLESTR base, 
                         LPOLESTR src, 
                         LPOLESTR lpMimeType = NULL, 
                         double dblClipBegin = -1.0, 
                         double dblClipEnd = -1.0) = 0;
    virtual HRESULT DetachFromHostElement (void) = 0;
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp) = 0;
};

interface ITIMEPlayerEventHandling
{
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS
    // METHOD SYNOPSIS:
    // Start: starts media playback
    // Stop: stops media playback
    // Pause: pauses media playback
    // Resume: resumes media playback
    // Repeat: causes the media to repeat playback from the beginning
    // Seek: jumps to location in media playback
    //////////////////////////////////////////////////////////////////////////
    virtual void Start() = 0;
    virtual void Stop() = 0;
    virtual void Pause() = 0;
    virtual void Resume() = 0;
    virtual void Repeat() = 0;
    virtual HRESULT Seek(double dblTime) = 0;
};

interface ITIMEPlayerPlaybackCapabilities
{
    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: BEGIN
    // METHOD SYNOPSIS:
    // HasMedia: tests if media is loaded into the player i.e. player is ready for playback
    // HasVideo: tests if media contains video content
    // HasAudio: tests if media contains audio content
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT HasMedia(bool &fHasMedia) = 0;
    virtual HRESULT HasVisual(bool &fHasVideo) = 0;
    virtual HRESULT HasAudio(bool &fHasAudio) = 0;
    virtual HRESULT CanSeek(bool &fcanSeek) = 0;
    virtual HRESULT CanPause(bool &fcanPause) = 0;
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM) = 0;
    virtual HRESULT IsBroadcast(bool &bisBroad) = 0;
    virtual HRESULT HasPlayList(bool &fhasPlayList) = 0;
    virtual HRESULT ConvertFrameToTime(LONGLONG lFrameNr, double &dblTime) = 0;
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr) = 0;
};

interface ITIMEPlayerStateManagement
{
    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: BEGIN
    // METHOD SYNOPSIS:
    // Reset: alligns the player state to that of it's associated mediaelement.
    // OnTEPropChange: called by the media element when timing state changes.
    // GetState: returns the state of the player.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Reset() = 0;
    virtual PlayerState GetState() = 0;
    virtual void PropChangeNotify(DWORD tePropType) = 0;
    virtual void ReadyStateNotify(LPWSTR szReadyState) = 0;
    virtual bool UpdateSync() = 0;
    virtual void SetPlaybackSite(CTIMEBasePlayer *pSite) = 0;
};

interface ITIMEPlayerRender
{
    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS
    // Render: is called when element rendering is ncessarry.
    // GetNaturalWidth and GetNaturalWidth: return the natural size of visible
    //   media.
    // SetSize: This method is used to inform the player that size has changed.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Render(HDC hdc, LPRECT prc) = 0;
    virtual HRESULT GetNaturalHeight(long *height) = 0;
    virtual HRESULT GetNaturalWidth(long *width) = 0;
    virtual HRESULT SetSize(RECT *prect) = 0;
};

interface ITIMEPlayerTiming
{
    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: BEGIN
    // METHOD SYNOPSIS:
    // GetMediaLength: returns the duration of the media.
    // GetEffectiveLength: returns the duration that is media 
    //   length minus clip times.
    // SetClipBegin: sets clip begin time. Not dynamic in current implementation.
    // SetClipEnd: sets clip begin time. Not dynamic in current implementation.
    // GetCurrentTime: returns current playback time.
    // GetCurrentSyncTime: returns S_FALSE is player is not in playback,
    //   S_OK if the player is active. This method is used by the timing engine
    //   to get clock source information.
    // SetRate and GetRate: set and get playback speed. 1.0 indicates
    //   playback at media natural speed.
    //////////////////////////////////////////////////////////////////////////
    virtual double GetCurrentTime() = 0;
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime) = 0;
    virtual HRESULT GetMediaLength(double &dblLength) = 0;
    virtual HRESULT GetEffectiveLength(double &dblLength) = 0;
    virtual void GetClipBegin(double &dblClibBegin) = 0;
    virtual void SetClipBegin(double dblClipBegin) = 0;
    virtual void GetClipEnd(double &dblClipEnd) = 0;
    virtual void SetClipEnd(double dblClipEnd) = 0;
    virtual void GetClipBeginFrame(long &lClibBeginFrame) = 0;
    virtual void SetClipBeginFrame(long lClipBeginFrame) = 0;
    virtual void GetClipEndFrame(long &lClipEndFrame) = 0;
    virtual void SetClipEndFrame(long lClipEndFrame) = 0;
    virtual HRESULT GetPlaybackOffset(double &dblOffset) = 0;
    virtual HRESULT GetEffectiveOffset(double &dblOffset) = 0;
};

interface ITIMEPlayerProperties
{
    //////////////////////////////////////////////////////////////////////////
    // PROPERTY ACCESSORS: BEGIN
    // METHOD SYNOPSIS:
    // GetVolume and SetVolume: get and set volume on player. Value range (0 - 1.0).
    // GetMute and SetMute: get and set mute flag on player (true - media muted).
    // Save: This method is used to pass a property bag to players that
    // can use it.
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetVolume(float *pflVolume) = 0;
    virtual HRESULT SetVolume(float flVolume) = 0;
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance) = 0;
    virtual HRESULT SetBalance(float flBalance) = 0;
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute) = 0;
    virtual HRESULT SetMute(VARIANT_BOOL varMute) = 0;
};

interface ITIMEPlayerMediaContent
{
    //////////////////////////////////////////////////////////////////////////
    // MEDIA CONTENT ACCESSORS: BEGIN
    // METHOD SYNOPSIS:
    // SetSrc: changes the media source
    // GetAuthor: gets author info from media content
    // GetTilte: gets title info from media content
    // GetCopyright: gets copyright info from media content
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src) = 0;
    virtual HRESULT GetAuthor(BSTR *pAuthor) = 0;
    virtual HRESULT GetTitle(BSTR *pTitle) = 0;
    virtual HRESULT GetCopyright(BSTR *pCopyright) = 0;
    virtual HRESULT GetAbstract(BSTR *pAbstract) = 0;
    virtual HRESULT GetRating(BSTR *pAbstract) = 0;
};

interface ITIMEPlayerMediaContext
{
    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime) = 0;
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime) = 0;
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur) = 0;
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur) = 0;
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal) = 0;
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent) = 0;
    virtual HRESULT GetIsStreamed(bool &fIsStreamed) = 0;
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress) = 0;
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress) = 0;
    virtual HRESULT GetMimeType(BSTR *pMime) = 0;
    virtual HRESULT GetDownloadProgress(double &dblDownloadProgress) = 0;
};

interface ITIMEPlayerIntegration
{
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle) = 0;
};

interface ITIMEPlayerPlayList
{
    virtual HRESULT GetPlayList(ITIMEPlayList **pPlayList) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\timeparser.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timeparser.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _TIMEPARSER_H
#define _TIMEPARSER_H

#include "timetoken.h"
#include "tokens.h"
#include "timevalue.h"

class CPlayList;
class CPlayItem;

enum TimelineType
{
    ttUninitialized,
    ttNone,
    ttPar,
    ttSeq,
    ttExcl
};

enum PathType
{
    PathMoveTo,
    PathLineTo,
    PathHorizontalLineTo,
    PathVerticalLineTo,
    PathClosePath,
    PathBezier,
    PathNotSet
};


class CTIMEPath
{
public:
    CTIMEPath();
    ~CTIMEPath();

    PathType    GetType() { return m_pathType; };
    bool        GetAbsolute() { return m_bAbsoluteMode; };
    POINTF     *GetPoints();

    
    HRESULT     SetType(PathType type);
    HRESULT     SetAbsolute(bool bMode);
    HRESULT     SetPoints (long index, POINTF point);

private:
    long        m_lPointCount;
    POINTF     *m_pPoints;
    PathType    m_pathType;
    bool        m_bAbsoluteMode;      //true when the mode is absolute, false otherwise

};

typedef struct _ParentList
{
    TOKEN tagToken;
    int listLen;
    TOKEN allowedParents[5];
} ParentList;


class CTIMEParser
{
protected:
    typedef std::list<TOKEN> TokenList;
    typedef std::list<LPOLESTR> StringList;

public:
    
    CTIMEParser(CTIMETokenizer *tokenizer, bool bSingleChar = false) 
        { CreateParser(tokenizer, bSingleChar);};
    CTIMEParser(LPOLESTR tokenStream, bool bSingleChar = false)
        { CreateParser(tokenStream, bSingleChar);};
    CTIMEParser(VARIANT *tokenStream, bool bSingleChar = false)
        { CreateParser(tokenStream, bSingleChar);};

    void CreateParser(CTIMETokenizer *tokenizer, bool bSingleChar);
    void CreateParser(LPOLESTR tokenStream, bool bSingleChar);
    void CreateParser(VARIANT *tokenStream, bool bSingleChar);
    ~CTIMEParser();

    HRESULT ParsePercent(double & percentVal);
    HRESULT ParseBoolean(bool & boolVal);
    HRESULT ParseClockValue(double & time);
    HRESULT ParseNumber(double & doubleVal, bool bValidate=true);
    HRESULT ParseTimeValueList(TimeValueList & tvList, bool * bWallClock = NULL, SYSTEMTIME * sysTime = NULL);
    HRESULT ParseFill(TOKEN & FillTok);
    HRESULT ParseRestart(TOKEN & TokRestart);
    HRESULT ParseSyncBehavior(TOKEN & SyncVal);
    HRESULT ParseTimeAction(TOKEN & timeAction);
    HRESULT ParseTimeLine(TimelineType & timeline);
    HRESULT ParseUpdateMode(TOKEN & update);
    HRESULT ParsePlayer(TOKEN & player, CLSID & clsid);
    HRESULT ParseCLSID(CLSID & clsid);
    HRESULT ParseCalcMode(TOKEN & calcMode);
    HRESULT ParseIdentifier(LPOLESTR & id);
    HRESULT ParseEnd(LPOLESTR & ElementID, LPOLESTR & syncEvent, double & time);
    HRESULT ParseEOF();
    HRESULT ParseSyncBase(LPOLESTR & ElementID, LPOLESTR & syncEvent, double & time);
    HRESULT ParseEndSync(TOKEN & endSync, LPOLESTR & ID);
    HRESULT ParsePath(long & count, long & moveCount, CTIMEPath ***pppPath);
    HRESULT ParseWallClock(double & curOffsetTime, SYSTEMTIME * sysTime = NULL);
    HRESULT ParseRepeatDur(double & time);
    HRESULT ParseDur(double & time);

    HRESULT ParseDate(int & nYear, int & nMonth, int & nDay);
    HRESULT ParseOffset(double & fHours, double & fMinutes, double & fSec, bool & bUseLocalTime);
    HRESULT ParseSystemLanguages(long & lLangCount, LPWSTR **ppszLang);

    HRESULT ParsePriorityClass(TOKEN & priorityClass);

    HRESULT ParsePlayList(CPlayList *pPlayList, bool fOnlyHeader, std::list<LPOLESTR> *asxList = NULL);
    HRESULT IgnoreValueTag();
    HRESULT ProcessValueTag(TOKEN token, CPlayItem *pPlayItem, TOKEN parentToken, bool &ffound, std::list<LPOLESTR> *asxList, TokenList *ptokenList);
    HRESULT ProcessRefTag(CPlayItem *pPlayItem);
    HRESULT ProcessBannerTag(CPlayItem *pPlayItem);
    HRESULT ProcessEntryRefTag(std::list<LPOLESTR> *asxList);

    LPOLESTR ProcessMoreInfoTag();
    LPOLESTR ProcessAbstractTag();   
    HRESULT ProcessHREF(LPOLESTR *);
    HRESULT GetTagParams(TokenList *tokenList, StringList *valueList, bool &fClosed);

    HRESULT ParseTransitionTypeAndSubtype (VARIANT *pvarType, VARIANT *pvarSubtype);

protected:

    static LPOLESTR FindTokenValue(TOKEN token, TokenList &tokenList, StringList &valueList);
    static void FreeStrings(StringList &valueList);

    CTIMEParser();
    CTIMETokenizer      *m_Tokenizer;

    bool IsAsxTagToken(TOKEN token);
    void TestForValueTag(TOKEN token, TOKEN parentToken, bool &ffound, bool &fparentOk);
    HRESULT ProcessTag(TOKEN tempToken, LPOLESTR pszTemp, CPlayItem *pPlayItem);
    double DoubleToDecimal(double val, long lCount);  //converts a number to a decimal value i.e. 5.24 to 0.524.
    HRESULT ParseToken(TOKEN *pToken);  //returns a token representation of the next identifier or E_FAIL if the next token is not an identifier.
    double GetModifier(OLECHAR *szToken);
    long CountPath();
    bool IsWallClock(OLECHAR *szWallclock);
    HRESULT ComputeTime(SYSTEMTIME *curTime, SYSTEMTIME *wallTime, double & curOffsetTime, bool bUseDate);
    bool IsEmpty();
    void CheckTime(SYSTEMTIME *wallTime, bool bUseDate);

private:
    HRESULT                m_hrLoadError;
    bool                   m_fDeleteTokenizer;
};

#endif //CTIMEParser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\timetoken.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: timetoken.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#pragma once

#ifndef _TIMETOKEN_H
#define _TIMETOKEN_H

#pragma INCMSG("--- Beg 'timetoken.h'")


/* BNF CSS1 grammar

    *  : 0 or more 
    +  : 1 or more 
    ?  : 0 or 1 
    |  : separates alternatives 
    [ ]: grouping 

    S  : [ \t\r\n\f]+


  stylesheet : 

  import : 

  ruleset : 

  selector : 

*/


#define     CHAR_ESCAPE         '\\'
#define     CHAR_AT             '@'
#define     CHAR_DOT            '.'
#define     CHAR_COLON          ':'
#define     CHAR_SINGLE         '\''
#define     CHAR_DOUBLE         '"'
#define     CHAR_SEMI           ';'
#define     CHAR_LEFT_PAREN     '('
#define     CHAR_RIGHT_PAREN    ')'
#define     CHAR_LEFT_CURLY     '{'
#define     CHAR_RIGHT_CURLY    '}'
#define     CHAR_HASH           '#'
#define     CHAR_BACKSLASH      '\\'
#define     CHAR_FORWARDSLASH   '/'
#define     CHAR_ASTERISK       '*'
#define     CHAR_EQUAL          '='
#define     CHAR_UNDERLINE      '_'
#define     CHAR_HYPHEN         '-'
#define     CHAR_BANG           '!'
#define     CHAR_COMMA          ','
#define     CHAR_PERCENT        '%'
#define     CHAR_PLUS           '+'
#define     CHAR_MINUS          '-'
#define     CHAR_SPACE          ' '
#define     CHAR_LESS           '<'
#define     CHAR_GREATER        '>'

enum TIME_TOKEN_TYPE { TT_Identifier,
                       TT_Number,
                       TT_At,
                       TT_Minus,
                       TT_Plus,
                       TT_ForwardSlash,
                       TT_Comma,
                       TT_Semi,
                       TT_Dot,
                       TT_Colon,
                       TT_Equal,
                       TT_Asterisk,
                       TT_Backslash,
                       TT_Comment,
                       TT_Import,
                       TT_QuotedString,
                       TT_LParen,
                       TT_RParen,
                       TT_LCurly,
                       TT_RCurly,
                       TT_Symbol,
                       TT_EOF,
                       TT_String,
                       TT_Hash,
                       TT_Bang,
                       TT_Percent,
                       TT_Space,
                       TT_Less,
                       TT_Greater,
                       TT_Unknown };


class CTIMETokenizer
{
public:
    CTIMETokenizer();
    ~CTIMETokenizer();
    HRESULT Init (OLECHAR *pData, ULONG ulLen);

    
    TIME_TOKEN_TYPE NextToken();
    TIME_TOKEN_TYPE TokenType()
      { return _currToken; }

    OLECHAR * GetTokenValue();
    OLECHAR * GetNumberTokenValue();
    double    GetTokenNumber();
    OLECHAR * GetStartToken()
      { return _pStartTokenValueOffset; }
    OLECHAR * GetStartOffset(ULONG uStartOffset)
      { return _pCharacterStream + uStartOffset; }
    ULONG   GetTokenLength()
      { return _pEndTokenValueOffset - _pStartTokenValueOffset; }

        OLECHAR CurrentChar()
      { return _currChar; }
        OLECHAR PrevChar()
      { Assert(_nextTokOffset >= 2); return *(_pCharacterStream + _nextTokOffset - 2); }

    OLECHAR PeekNextChar(int relOffset)
      { return (_nextTokOffset < _cCharacterStream) ? (*(_pCharacterStream + _nextTokOffset + relOffset)) : '\0'; }

    OLECHAR PeekNextNonSpaceChar();

    BOOL isIdentifier(OLECHAR *szMatch);

    // ISSUE : Really shouldn't expose this however, I do to get the value parsing up quicker...
    ULONG CurrTokenOffset()
      { return _currTokOffset; }
    ULONG NextTokenOffset()
      { return _nextTokOffset; }
    ULONG GetStreamLength()
      { return _cCharacterStream; }
    OLECHAR *GetRawString(ULONG uStartOffset, ULONG uEndOffset);
    ULONG  GetCharCount(OLECHAR token);
    ULONG GetAlphaCount(char cCount); //counts all alphabetic characters in the string

    bool GetTightChecking()
        { return _bTightSyntaxCheck; };
    void SetTightChecking(bool bCheck)
        { _bTightSyntaxCheck = bCheck; };
    void SetSingleCharMode(bool bSingle);
    BOOL FetchStringToChar(OLECHAR chDelim);
    BOOL FetchStringToString(LPOLESTR pstrDelim);

protected:
    OLECHAR       NextNonSpaceChar();
    BOOL        FetchString(OLECHAR chDelim);
    BOOL        FetchString(LPOLESTR strDelim);
    inline OLECHAR       NextChar();
    TIME_TOKEN_TYPE FetchIdentifier();
    TIME_TOKEN_TYPE FetchNumber();
    BOOL        CDOToken();
    void        BackChar()
      { _nextTokOffset--; }

private:
        OLECHAR      *_pCharacterStream;
        ULONG       _cCharacterStream;
    ULONG       _currTokOffset;
    ULONG       _nextTokOffset;
    OLECHAR       _currChar;

    TIME_TOKEN_TYPE  _currToken;
    OLECHAR      *_pStartOffset;
    OLECHAR      *_pEndOffset;

    OLECHAR      *_pStartTokenValueOffset;
    OLECHAR      *_pEndTokenValueOffset;
    bool          _bTightSyntaxCheck; //used to determine if whitespaces should be skipped or not.
    bool          _bSingleCharMode;   //used for path parsing where a single character is needed.
};


#endif //_TIMETOKEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\tokens.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: tokens.h
//
//  Contents: tokens and related utilities
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _TOKENS_H
#define _TOKENS_H

//+----------------------------------------------------------------------------
//
// Good place to put general string expansion macros that are not tokens:
//
//-----------------------------------------------------------------------------

#define WZ_LAST                         L"last"
#define WZ_FIRST                        L"first"
#define WZ_NONE                         L"none"
#define WZ_ALL                          L"all"
#define WZ_INDEFINITE                   L"indefinite"

#define WZ_PAR                          L"par"
#define WZ_EXCL                         L"excl"
#define WZ_SEQUENCE                     L"seq"

#define WZ_SWITCH                       L"switch"

#define WZ_REF                          L"ref"
#define WZ_MEDIA                        L"media"
#define WZ_IMG                          L"img"
#define WZ_AUDIO                        L"audio"
#define WZ_VIDEO                        L"video"
#define WZ_ANIMATION                    L"animation"

#define WZ_EVENT                        L"event"

#define WZ_ANIMATE                      L"animate"
#define WZ_SET                          L"set"
#define WZ_COLORANIM                    L"animatecolor"
#define WZ_MOTIONANIM                   L"animatemotion"

#define WZ_BODY                         L"body"

#define WZ_TRANSITIONFILTER             L"transitionFilter"
#define WZ_TRANSITION_NAME              L"transition"

#define WZ_DEFAULT_SCOPE_NAME           L"HTML"

#define WZ_TIME_STYLE_PREFIX            L"#time"
#define WZ_SMILANIM_STYLE_PREFIX        L"#smilanim"

#define WZ_REGISTERED_TIME_NAME             L"HTMLTIME"
#define WZ_REGISTERED_ANIM_NAME             L"SMILANIMCOMPOSERSITE"
#define WZ_TIME_URN                         L"TIME_BEHAVIOR_URN"
#define WZ_SMILANIM_URN                     L"SMILANIM_COMPSITE_BEHAVIOR_URN"
#define WZ_TIME_TAG_URN                     L"urn:schemas-microsoft-com:time"

#define WZ_MEDIA_PRINTING               L"print"

#define WZ_PRIORITYCLASS_NAME           L"priorityClass"
#define WZ_PEERS                        L"peers"
#define WZ_HIGHER                       L"higher"
#define WZ_LOWER                        L"lower"

#define WZ_TRANSPARENT                  L"transparent"

#define WZ_FRAGMENT_ATTRIBUTE_PROPERTY_NAME L"attributeName"
#define WZ_FRAGMENT_VALUE_PROPERTY_NAME     L"get_value"
#define WZ_FRAGMENT_ELEMENT_PROPERTY_NAME   L"element"
#define WZ_EVENT_CAUSE_IS_RESTART           L"restart"

#define WZ_STATE_ON                         L"on"
#define WZ_STATE_OFF                        L"off"
#define WZ_STATE_PAUSED                     L"paused"

#define WZ_STATE_ACTIVE                     L"active"
#define WZ_STATE_INACTIVE                   L"inactive"
#define WZ_STATE_SEEKING                    L"seeking"
#define WZ_STATE_HOLDING                    L"holding"
#define WZ_STATE_CUEING                     L"cueing"

#define WZ_CALCMODE_DISCRETE                L"discrete"
#define WZ_CALCMODE_LINEAR                  L"linear"
#define WZ_CALCMODE_SPLINE                  L"spline"
#define WZ_CALCMODE_PACED                   L"paced"

#define WZ_ORIGIN_DEFAULT                   L"default"
#define WZ_ORIGIN_PARENT                    L"parent"
#define WZ_ORIGIN_ELEMENT                   L"element"

#define WZ_FILL_FREEZE                      L"freeze"
#define WZ_FILL_REMOVE                      L"remove"
#define WZ_FILL_HOLD                        L"hold"
#define WZ_FILL_TRANSITION                  L"transition"

#define WZ_RESTART_NEVER                    L"never"
#define WZ_RESTART_ALWAYS                   L"always"
#define WZ_RESTART_WHENNOTACTIVE            L"whennotactive"

#define WZ_DIRECTION_NOHUE                  L"nohue"
#define WZ_DIRECTION_CLOCKWISE              L"clockwise"
#define WZ_DIRECTION_CCLOCKWISE             L"cclockwise"

#define WZ_TOP                              L"top"
#define WZ_LEFT                             L"left"
#define WZ_AUTO                             L"auto"

#define WZ_TIMEBASE_BEGIN                   L"begin"
#define WZ_TIMEBASE_END                     L"end"

#define WZ_ADDITIVE_SUM                     L"sum"   

#define WZ_TRUE                             L"true"
#define WZ_FALSE                            L"false"

#define WZ_SWITCHCHILDDISABLED              L"SwitchChildDisabled"

#define WZ_HIDDEN                           L"hidden"
#define WZ_VISIBLE                          L"visible"

//
// ITIMEElement attribute names
// 

#define WZ_SPEED                            L"speed"
#define WZ_VOLUME                           L"volume"
#define WZ_DUR                              L"dur"
#define WZ_ACCELERATE                       L"accelerate"
#define WZ_DECELERATE                       L"decelerate"
#define WZ_END                              L"end"
#define WZ_REPEATCOUNT                      L"repeatCount"
#define WZ_REPEATDUR                        L"repeatDur"
#define WZ_SYNCTOLERANCE                    L"syncTolerance"
#define WZ_AUTOREVERSE                      L"autoReverse"
#define WZ_BEGIN                            L"begin"
#define WZ_END                              L"end"
#define WZ_FILL                             L"fill"
#define WZ_MUTE                             L"mute"
#define WZ_RESTART                          L"restart"
#define WZ_SYNCBEHAVIOR                     L"syncBehavior"
#define WZ_SYNCMASTER                       L"syncMaster"
#define WZ_TIMECONTAINER                    L"timeContainer"
#define WZ_TIMEACTION                       L"timeAction"
#define WZ_UPDATEMODE                       L"updateMode"
#define WZ_ENDSYNC                          L"endSync"

//
// ITIMEMediaElement attribute names
// 

#define WZ_CLIPBEGIN                        L"clipBegin"
#define WZ_CLIPEND                          L"clipEnd"
#define WZ_PLAYER                           L"player"
#define WZ_SRC                              L"src"
#define WZ_TYPE                             L"type"
#define WZ_TRANSIN                          L"transIn"
#define WZ_TRANSOUT                         L"transOut"

//
// ITIMETransitionElement attribute names
//
#define WZ_SUBTYPE                          L"subType"
#define WZ_DURATION                         L"duration"
#define WZ_STARTPROGRESS                    L"startProgress"
#define WZ_ENDPROGRESS                      L"endProgress"
#define WZ_DIRECTION                        L"direction"
#define WZ_FORWARD                          L"forward"
#define WZ_REVERSE                          L"reverse"
#define WZ_REPEAT                           L"repeat"
#define WZ_TRANSITIONTYPE                   L"transitiontype"
#define WZ_DEFAULT_TRANSITION_TYPE          L"barWipe"
#define WZ_DEFAULT_TRANSITION_SUBTYPE       L"leftToRight"
#define WZ_DEFAULT_TRANSITION_MODE          L"in"
#define WZ_TRANSITION_MODE_OUT              L"out"


//
// ITIMEAnimationElement attribute names
// 

#define WZ_ACCUMULATE                       L"accumulate"
#define WZ_ADDITIVE                         L"additive"
#define WZ_ATTRIBUTENAME                    L"attributeName"
#define WZ_BY                               L"by"
#define WZ_CALCMODE                         L"calcMode"
#define WZ_FROM                             L"from"
#define WZ_KEYSPLINES                       L"keySplines"
#define WZ_KEYTIMES                         L"keyTimes"
#define WZ_ORIGIN                           L"origin"
#define WZ_PATH                             L"path"
#define WZ_TARGETELEMENT                    L"targetElement"
#define WZ_TO                               L"to"
#define WZ_VALUES                           L"values"
#define WZ_MODE                             L"mode"
#define WZ_FADECOLOR                        L"fadeColor"

//
// ITIMEBodyElement attribute names
// 


//
// ITIMEventElement attribute names
// 

#define WZ_TYPE_EVENT                   L"type"
#define WZ_ACTIVE                       L"active"

//
// Attribute names for elements whose events we monitor
//
#define WZ_FILTER_MOUSE_EVENTS          L"filterMouseOverMouseOut"
#define WZ_TIMECANCELBUBBLE             L"timeCancelBubble"

//
// Connection type names
#define WZ_MODEM                        L"modem"
#define WZ_LAN                          L"lan"






// merge conflict here please




//+----------------------------------------------------------------------------
//
// This is to save on string storage space and to avoid unnecessary
// string comparisons
//
//-----------------------------------------------------------------------------

typedef void * TOKEN;

TOKEN StringToToken(wchar_t * str);
inline wchar_t * TokenToString(TOKEN token) { return (wchar_t *) token; }

// timeAction values
extern TOKEN NONE_TOKEN;
extern TOKEN INVALID_TOKEN;
extern TOKEN STYLE_TOKEN;
extern TOKEN DISPLAY_TOKEN;
extern TOKEN VISIBILITY_TOKEN;

extern TOKEN     CLASS_TOKEN;
extern const int nCLASS_TOKEN_LENGTH;
extern TOKEN     SEPARATOR_TOKEN;
extern const int nSEPARATOR_TOKEN_LENGTH;

extern TOKEN ONOFF_PROPERTY_TOKEN;

extern TOKEN TRUE_TOKEN;
extern TOKEN FALSE_TOKEN;
extern TOKEN HIDDEN_TOKEN;

extern TOKEN CANSLIP_TOKEN;
extern TOKEN LOCKED_TOKEN;

extern TOKEN STOP_TOKEN;
extern TOKEN PAUSE_TOKEN;
extern TOKEN DEFER_TOKEN;
extern TOKEN NEVER_TOKEN;

extern TOKEN READYSTATE_COMPLETE_TOKEN;

extern TOKEN REMOVE_TOKEN;
extern TOKEN FREEZE_TOKEN;
extern TOKEN HOLD_TOKEN;
extern TOKEN TRANSITION_TOKEN;

extern TOKEN ALWAYS_TOKEN;
// extern TOKEN NEVER_TOKEN; // also above
extern TOKEN WHENNOTACTIVE_TOKEN;

extern TOKEN SEQ_TOKEN;
extern TOKEN PAR_TOKEN;
extern TOKEN EXCL_TOKEN;

extern TOKEN AUTO_TOKEN; 
extern TOKEN MANUAL_TOKEN;
extern TOKEN RESET_TOKEN;

#if DBG // 94850
extern TOKEN DSHOW_TOKEN;
#endif
extern TOKEN DVD_TOKEN;
extern TOKEN DMUSIC_TOKEN;
extern TOKEN CD_TOKEN;

extern TOKEN DISCRETE_TOKEN;
extern TOKEN LINEAR_TOKEN;
extern TOKEN PACED_TOKEN;

extern TOKEN CLOCKWISE_TOKEN;
extern TOKEN COUNTERCLOCKWISE_TOKEN;

extern TOKEN FIRST_TOKEN;
extern TOKEN LAST_TOKEN;

extern TOKEN ENTRY_TOKEN;
extern TOKEN TITLE_TOKEN;
extern TOKEN COPYRIGHT_TOKEN;
extern TOKEN AUTHOR_TOKEN;
extern TOKEN REF_TOKEN;
extern TOKEN ENTRYREF_TOKEN;
extern TOKEN ASX_TOKEN;
extern TOKEN ABSTRACT_TOKEN;
extern TOKEN HREF_TOKEN;
extern TOKEN REPEAT_TOKEN;
extern TOKEN EVENT_TOKEN;
extern TOKEN MOREINFO_TOKEN;
extern TOKEN BASE_TOKEN;
extern TOKEN LOGO_TOKEN;
extern TOKEN PARAM_TOKEN;
extern TOKEN PREVIEWDURATION_TOKEN;
extern TOKEN STARTTIME_TOKEN;
extern TOKEN STARTMARKER_TOKEN;
extern TOKEN ENDTIME_TOKEN;
extern TOKEN ENDMARKER_TOKEN;
extern TOKEN DURATION_TOKEN;
extern TOKEN BANNER_TOKEN;
extern TOKEN CLIENTSKIP_TOKEN;
extern TOKEN CLIENTBIND_TOKEN;
extern TOKEN COUNT_TOKEN;


extern TOKEN INDEFINITE_TOKEN;

#endif /* _TOKENS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\transsite.h ===
#ifndef _TRANSITIONSITE_H__
#define _TRANSITIONSITE_H__

#pragma once

EXTERN_C const IID IID_ITIMETransitionSite;
extern enum TIME_EVENT;

interface ITIMETransitionSite : public IUnknown
{
  public:
    STDMETHOD(InitTransitionSite) (void) PURE;
    STDMETHOD(DetachTransitionSite) (void) PURE;
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b) PURE;
    STDMETHOD(get_node)(ITIMENode ** ppNode) PURE;
    STDMETHOD(get_timeParentNode)(ITIMENode ** ppNode) PURE;
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event) PURE;
};

#endif // _TRANSITIONSITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\timevalue.h ===
//+___________________________________________________________________________________
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timevalue.h
//
//  Contents: 
//
//____________________________________________________________________________________



#ifndef _TIMEVALUE_H
#define _TIMEVALUE_H

class TimeValue
{
  public:
    TimeValue(LPWSTR Element,
              LPWSTR Event,
              double Offset);
    TimeValue();
    TimeValue(const TimeValue & tv);
    ~TimeValue();
    
    TimeValue& operator=(const TimeValue & tv)
    { if ( &tv != this ) Copy(tv); return *this; }

    void Clear();
    HRESULT Copy(const TimeValue & tv);
    HRESULT Set(LPWSTR Element,
                LPWSTR Event,
                double Offset);
    
    LPOLESTR GetElement() const { return m_pwszElm; }
    LPOLESTR GetEvent() const { return m_pwszEv; }
    double GetOffset() const { return m_dblOffset; }
  protected:
    LPOLESTR m_pwszElm;
    LPOLESTR m_pwszEv;
    double m_dblOffset;
};

typedef std::list<TimeValue *> TimeValueSTLList;

class TimeValueList
{
  public:
    TimeValueList();
    ~TimeValueList();

    void Clear();
    
    TimeValueSTLList & GetList() { return m_tvlList; }
  protected:
    TimeValueSTLList m_tvlList;
};

#endif /* _TIMEVALUE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\trans.h ===
/*******************************************************************************
 *
 * Copyright (c) 2000 Microsoft Corporation
 *
 * File: trans.h
 *
 * Abstract: Interface definition for ITransitionElement
 *
 *******************************************************************************/

#ifndef _TRANS_H__
#define _TRANS_H__

#pragma once

//
// ITransitionElement is for private use by HTML+TIME.
// Do *NOT* use a CTrans* in other places.
//
// If you need something else, add it to the ITransitionElement interface
// and then implement it in CTIMETransBase and the relates classes
//

interface ITransitionElement : public IUnknown
{
  public:
    STDMETHOD(Init)() PURE;
    STDMETHOD(Detach)() PURE;

    STDMETHOD(put_template)(LPWSTR pwzTemplate) PURE;
    STDMETHOD(put_htmlElement)(IHTMLElement * pHTMLElement) PURE;
    STDMETHOD(put_timeElement)(ITIMEElement * pTIMEElement) PURE;
};

HRESULT CreateTransIn(ITransitionElement ** ppTransElement);
HRESULT CreateTransOut(ITransitionElement ** ppTransElement);

#endif // _TRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\transworker.h ===
//------------------------------------------------------------------------------
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  File:       transworker.h
//
//  Interfaces: ITransitionSite
//              ITransitionWorker
//
//  Functions:  CreateTransitionWorker
//
//  History:
//  2000/07/??  jeffwall    Created.
//  2000/09/07  mcalkins    Added these comments!
//  2000/09/15  mcalkins    Added eQuickApplyType parameter to Apply().
//
//------------------------------------------------------------------------------

#ifndef _TRANSWORKER_H__
#define _TRANSWORKER_H__

#pragma once

#include "dxtransp.h"




// TODO: (mcalkins) Create an idl file for private SMIL Transitions interfaces?

interface ITransitionSite : public IUnknown
{
public:
    STDMETHOD(get_htmlElement)(IHTMLElement ** ppHTMLElement) PURE;
    STDMETHOD(get_template)(IHTMLElement ** ppHTMLElement) PURE;
};


interface ITransitionWorker : public IUnknown
{
public:
    STDMETHOD(InitFromTemplate)() PURE;
    STDMETHOD(InitStandalone)(VARIANT varType, VARIANT varSubtype) PURE;
    STDMETHOD(Detach)() PURE;
    STDMETHOD(Apply)(DXT_QUICK_APPLY_TYPE eDXTQuickApplyType) PURE;

    STDMETHOD(put_transSite)(ITransitionSite * pTransElement) PURE;
    STDMETHOD(put_progress)(double dblProgress) PURE;
    STDMETHOD(get_progress)(double * pdblProgress) PURE;

    STDMETHOD(OnBeginTransition) (void) PURE;
    STDMETHOD(OnEndTransition) (void) PURE;

};


HRESULT CreateTransitionWorker(ITransitionWorker ** ppTransWorker);

#endif // _TRANSWORKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\codec.h ===
//+___________________________________________________________________________________
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: codec.h
//
//  Contents: 
//
//____________________________________________________________________________________



#ifndef _CODEC_H
#define _CODEC_H

class
ATL_NO_VTABLE
CDownloadCallback
    : public CComObjectRootEx<CComSingleThreadModel>,
      public IBindStatusCallback,
      public IAuthenticate,
      public ICodeInstall
{
  public:
    CDownloadCallback();
    virtual ~CDownloadCallback();
    
    BEGIN_COM_MAP(CDownloadCallback)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
        COM_INTERFACE_ENTRY(IAuthenticate)
        COM_INTERFACE_ENTRY(ICodeInstall)
        COM_INTERFACE_ENTRY(IWindowForBindingUI)
    END_COM_MAP();
            
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    // --- IBindStatusCallback methods ---

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                               LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                                    STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IAuthenticate methods
    STDMETHODIMP Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);

    // IWindowForBindingUI methods
    STDMETHODIMP GetWindow(REFGUID rguidReason, HWND *phwnd);

    // ICodeInstall methods
    STDMETHODIMP OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination, 
                                      LPCWSTR szSource, DWORD dwReserved);

    HWND                m_hwnd;
    HRESULT             m_hrBinding;
    HANDLE              m_evFinished;
    ULONG               m_ulProgress;
    ULONG               m_ulProgressMax;
    DAComPtr<IBinding>  m_spBinding;
    DAComPtr<IUnknown>  m_pUnk;
};

#endif /* _CODEC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\codec.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: codec.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "codec.h"

DeclareTag(tagCodec, "TIME: Media", "CDownloadCallback methods");

/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::CDownloadCallback()
: m_hrBinding(S_ASYNCHRONOUS),
  m_ulProgress(0),
  m_ulProgressMax(0),
  m_hwnd(NULL)
{
    m_evFinished = CreateEvent(NULL, FALSE, FALSE, NULL);
}


STDMETHODIMP
CDownloadCallback::Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::Authenticate()",
              this));

    *phwnd = m_hwnd; // !!! is this right?
    *pszUsername = NULL;
    *pszPassword = NULL;
    return S_OK;
}

// IWindowForBindingUI methods
STDMETHODIMP
CDownloadCallback:: GetWindow(REFGUID rguidReason, HWND *phwnd)
{
    *phwnd = m_hwnd; // !!! is this right?

#ifdef DEBUG
    WCHAR achguid[50];
    StringFromGUID2(rguidReason, achguid, 50);
    
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::GetWindow(): (%ls) returned %x",
              this,
              achguid,
              *phwnd));
#endif
    
    return S_OK;
}

STDMETHODIMP
CDownloadCallback::OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination,
                                        LPCWSTR szSource, DWORD dwReserved)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnCodeInstallProblem(%d, %ls, %ls)",
              this,
              ulStatusCode,
              szDestination,
              szSource));

    return S_OK;   // !!!!!!!@!!!!!!!!!!!
}


/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::~CDownloadCallback()
{
    Assert(!m_spBinding);

    if (m_evFinished)
    {
        // Set it first to make sure we break any loops
        SetEvent(m_evFinished);
        CloseHandle(m_evFinished);
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnStartBinding(%x, %p)",
              this,
              grfBSCOption,
              pbinding));

    m_spBinding = pbinding;

    return S_OK;
}  // CDownloadCallback::OnStartBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetPriority(LONG* pnPriority)
{
    return E_NOTIMPL;
}  // CDownloadCallback::GetPriority

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}  // CDownloadCallback::OnLowResource

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                              ULONG ulStatusCode, LPCWSTR szStatusText)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnProgress(%d, %d, %d, %ls)",
              this,
              ulProgress,
              ulProgressMax,
              ulStatusCode,
              szStatusText));

    m_ulProgress = ulProgress;
    m_ulProgressMax = ulProgressMax;

#if 0
    if (ulStatusCode >= BINDSTATUS_FINDINGRESOURCE &&
        ulStatusCode <= BINDSTATUS_SENDINGREQUEST)
    {
        m_pDXMP->SetStatusMessage(NULL, IDS_BINDSTATUS + ulStatusCode,
                                  szStatusText ? szStatusText : L"",
                                  ulProgress, ulProgressMax);
    }
#endif
    
    return S_OK;
}  // CDownloadCallback::OnProgress

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnStopBinding(%hr, %ls)",
              this,
              hrStatus,
              pszError));

    // should this be a SetEvent?
    m_hrBinding = hrStatus;

    if (FAILED(hrStatus))
    {
        // !!! send some notification that the download failed....
    }

    if (m_evFinished)
    {
        SetEvent(m_evFinished);
    }

    m_spBinding.Release();

    return S_OK;
}  // CDownloadCallback::OnStopBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::GetBindInfo()",
              this));

    // !!! are these the right flags?

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_NEEDFILE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CDownloadCallback::GetBindInfo

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
    return S_OK;
}  // CDownloadCallback::OnDataAvailable

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    TraceTag((tagCodec,
              "CDownloadCallback(%p)::OnObjectAvailable()",
              this));

    // should only be used in BindToObject case, which we don't use?
    m_pUnk = punk;

    return S_OK;
}  // CDownloadCallback::OnObjectAvailable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\include\util.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\include\util.h
//
//  Contents: commonly used utility functions, etc.
//
//------------------------------------------------------------------------------------

#ifndef _UTIL_H
#define _UTIL_H

#include "mstime.h"
#include "atlcom.h"
#include "array.h"
#include <ras.h>

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define TIME_INFINITE HUGE_VAL
#define valueNotSet -1

#if DBG == 1

//+------------------------------------------------------------------------
//
//  This is to allow tracing of TIME-only THRs and IGNORE_HRs.
//
//-------------------------------------------------------------------------
HRESULT THRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine);
void    IGNORE_HRTimeImpl(HRESULT hr, char * pchExpression, char * pchFile, int nLine);

#endif // if DBG == 1

class TimeValueList;

//+------------------------------------------------------------------------
//
//  global: enum for tri-state variables .
//
//-------------------------------------------------------------------------
enum TRI_STATE_BOOL {TSB_UNINITIALIZED, TSB_TRUE, TSB_FALSE};



//************************************************************
// this is used globally to denote that when scripting, we 
// use English.
#define LCID_SCRIPTING 0x0409

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS;


//+-------------------------------------------------------------------------------------
// RAS accessor function types
//+-------------------------------------------------------------------------------------
typedef DWORD (APIENTRY *RASGETCONNECTIONSTATISTICSPROC)(HRASCONN hRasConn, RAS_STATS *lpStatistics);
typedef DWORD (APIENTRY *RASENUMCONNECTIONSPROC)( LPRASCONNW, LPDWORD, LPDWORD );


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar ? _allocArr: _ppUnk; } //lint !e1402

    bool IsOK() { return !_failed; }
  protected:
    SafeArrayAccessor();
    NO_COPY(SafeArrayAccessor);

    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

WCHAR * TrimCopyString(const WCHAR *str);
WCHAR * BeckifyURL(WCHAR *url);

IDirectDraw * GetDirectDraw(void);

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT *pf,
                       bool vidmem,
                       LONG width, LONG height);

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect);

/////////////////////////  CriticalSections  //////////////////////

class CritSect
{
  public:
    CritSect();
    ~CritSect();
    void Grab();
    void Release();
    
  protected:
    CRITICAL_SECTION _cs;
};

class CritSectGrabber
{
  public:
    CritSectGrabber(CritSect& cs, bool grabIt = true);
    ~CritSectGrabber();
    
  protected:
    NO_COPY(CritSectGrabber);
    CritSectGrabber();

    CritSect& _cs;
    bool grabbed;
};

/////////////////////// Misc ////////////////////

typedef bool TEDirection;
const bool TED_Forward = true;
const bool TED_Backward = false;

inline bool TEIsForward(TEDirection dir) { return dir; }
inline bool TEIsBackward(TEDirection dir) { return !dir; }
inline TEDirection TEReverse(TEDirection dir) { return !dir; }

#if DBG
inline char *
DirectionString(TEDirection dir)
{
    return dir?"Forward":"Backward";
}
#endif

#define INDEFINITE (float) HUGE_VAL //defined for Variant conversion functions

#define FOREVER    (float) HUGE_VAL

#define INVALID    ((float) -HUGE_VAL)

HRESULT GetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, LONG lFlags, VARIANT * value);
HRESULT SetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, VARIANT value, LONG lFlags);
BSTR CreateTIMEAttrName(LPCWSTR str);

bool VariantToBool(VARIANT var);
float VariantToFloat(VARIANT var,
                     bool bAllowIndefinite = false,
                     bool bAllowForever = false);
HRESULT VariantToTime(VARIANT vt, float *retVal, long *lframe = NULL, bool *isFrame = NULL);
BOOL IsIndefinite(OLECHAR *szTime);

extern const wchar_t * TIMEAttrPrefix;

/////////////////////// Convenience macros ////////////////////

//
// used in QI implementations for safe pointer casting
// e.g. if( IsEqualGUID(IID_IBleah) ) *ppv = SAFECAST(this,IBleah);
// Note: w/ vc5, this is ~equiv to *ppv = static_cast<IBleah*>(this);
//
#define SAFECAST(_src, _type) static_cast<_type>(_src)

// 
// used in QI calls, 
// e.g. IOleSite * pSite;  p->QI( IID_TO_PPV(IOleInPlaceSite, &pSite) ) 
// would cause a C2440 as _src is not really a _type **.
// Note: the riid must be the _type prepended by IID_.
//
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

// Explicit directive to ignore a return value
#define IGNORE_RETURN(_call)        static_cast<void>((_call))

//************************************************************


#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86


//
// ReleaseInterface calls 'Release' and NULLs the pointer
// The Release() return will be in eax for IA builds.
//
#define ReleaseInterface(p)\
{\
    /*lint -e550 -e774 -e423*/ /* suppress cRef not referenced, if always evaluates to false, and creation of memory leak */ \
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
    /*lint -restore */ \
} 

//************************************************************
// Error Reporting helper macros

HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg = NULL);

HRESULT CheckElementForBehaviorURN(IHTMLElement *pElement,
                                   WCHAR *wzURN,
                                   bool *pfReturn);
HRESULT TIMEGetLastError(void);
LPWSTR TIMEGetLastErrorString(void);

HRESULT AddBodyBehavior(IHTMLElement* pElement);
HRESULT GetBodyElement(IHTMLElement *pElement, REFIID riid, void **);

bool IsTIMEBodyElement(IHTMLElement *pElement);
HRESULT FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem);
HRESULT FindTIMEBehavior(IHTMLElement *pHTMLElem, IDispatch **ppDisp);

HRESULT FindBehaviorInterface(LPCWSTR pszName,
                              IDispatch *pHTMLElem,
                              REFIID riid,
                              void **ppRet);

bool IsTIMEBehaviorAttached (IDispatch *pidispElem);
bool IsComposerSiteBehaviorAttached (IDispatch *pidispElem);

HRESULT EnsureComposerSite (IHTMLElement2 *pielemTarget, IDispatch **ppidispComposerSite);

const LPOLESTR HTMLSTREAMSRC = L"#html";
const LPOLESTR SAMISTREAMSRC = L"#sami";
const long HTMLSTREAMSRCLEN = 5;

const LPOLESTR M3USRC = L".m3u";
const LPOLESTR WAXSRC = L".wax";
const LPOLESTR WMXSRC = L".wmx";
const LPOLESTR WVXSRC = L".wvx";
const LPOLESTR ASXSRC = L".asx";
const LPOLESTR ASFSRC = L".asf";
const LPOLESTR WMFSRC = L".wmf";
const LPOLESTR LSXSRC = L".lsx";
const LPOLESTR ASXMIME = L"x-ms-asf";
const LPOLESTR ASXMIME2 = L"asx";
const LPOLESTR WZ_VML_URN = L"urn:schemas-microsoft-com:vml";

bool IsHTMLSrc(const WCHAR * src);

bool IsASXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsM3USrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWAXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWVXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWMFSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsLSXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);
bool IsWMXSrc(LPCWSTR src, LPCWSTR srcType, LPCWSTR userMimeType);

bool MatchElements (IUnknown *piInOne, IUnknown *piInTwo);

LPWSTR GetSystemLanguage(IHTMLElement *pEle);
bool GetSystemCaption();
bool GetSystemOverDub();
HRESULT GetSystemBitrate(long *lpBitrate);
LPWSTR GetSystemConnectionType();
HRESULT CheckRegistryBitrate(long *pBitrate);


//////////////////////////////////////////////////////////////////////////////////////////////////
// IDispatch Utilities
//////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT PutProperty (IDispatch *pidisp, LPCWSTR wzPropName, VARIANTARG *pvar);
HRESULT GetProperty (IDispatch *pidisp, LPCWSTR wzPropName, VARIANTARG *pvar);
HRESULT CallMethod(IDispatch *pidisp, LPCWSTR wzMethodName, VARIANT *pvarResult = NULL, VARIANT *pvarArgument1 = NULL);
bool IsVMLObject(IDispatch *pidisp);

//////////////////////////////////////////////////////////////////////////////////////////////////
// String Parsing Utilities
//////////////////////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------------------
//
//  Structure:  STRING_TOKEN
//
//  Synopsis:   References a token in a string. Used in conjunction with a string Str, 
//              the first character of the token is Str[uIndex] and the last character
//              of the token is Str[uIndex + uLength - 1].
//
//  Members:    [uIndex]    Index of the first character of the token. First char of the
//                          string has uIndex = 0.
//              [uLength]   Number of characters in the token, excluding separators, null, etc.  
//
//------------------------------------------------------------------------------------

typedef struct TAG_STRING_TOKEN
{
    UINT    uIndex;
    UINT    uLength;
} STRING_TOKEN;


HRESULT StringToTokens(/*in*/ LPWSTR                   pstrString, 
                       /*in*/ LPWSTR                   pstrSeparators, 
                       /*out*/CPtrAry<STRING_TOKEN*> * paryTokens );  

HRESULT TokensToString(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens, 
                       /*in*/  LPWSTR                   pstrString, 
                       /*out*/ LPWSTR *                 ppstrOutString);  

HRESULT TokenSetDifference(/*in*/  CPtrAry<STRING_TOKEN*> * paryTokens1,
                           /*in*/  LPWSTR                   pstr1,
                           /*in*/  CPtrAry<STRING_TOKEN*> * paryTokens2,
                           /*in*/  LPWSTR                   pstr2,
                           /*out*/ CPtrAry<STRING_TOKEN*> * paryTokens1Minus2);

HRESULT FreeStringTokenArray(/*in*/CPtrAry<STRING_TOKEN*> * paryTokens);


bool    StringEndsIn(const LPWSTR pszString, const LPWSTR pszSearch);


bool IsPalettizedDisplay();

bool IsElementNameThis(IHTMLElement * pElement, LPWSTR pszName);
bool IsElementPriorityClass(IHTMLElement * pElement);
bool IsElementTransition(IHTMLElement * pElement);

HRESULT GetHTMLAttribute(IHTMLElement * pElement, const WCHAR * pwchAttribute, VARIANT * pVar);

bool IsValidtvList(TimeValueList *tvlist);

HRESULT
SinkHTMLEvents(IUnknown * pSink, 
               IHTMLElement * pEle, 
               IConnectionPoint ** ppDocConPt,
               DWORD * pdwDocumentEventConPtCookie,
               IConnectionPoint ** ppWndConPt,
               DWORD * pdwWindowEventConPtCookie);

// get document.all.pwzID
HRESULT FindHTMLElement(LPWSTR pwzID, IHTMLElement * pAnyElement, IHTMLElement ** ppElement);
HRESULT SetVisibility(IHTMLElement * pElement, bool bVisibile);
HRESULT GetSyncBaseBody(IHTMLElement * pHTMLElem, ITIMEBodyElement ** ppBodyElem);

HRESULT WalkUpTree(IHTMLElement *pFirst, long &lscrollOffsetyc, long &lscrollOffsetxc, long &lPixelPosTopc, long &lPixelPosLeftc);
void GetRelativeVideoClipBox(RECT &screenRect, RECT &elementSize, RECT &rectVideo, long lscaleFactor);
//
//
//

inline double
Clamp(double min, double val, double max)
{
    if (val < min)
    {
        val = min;
    }
    else if (val > max)
    {
        val = max;
    }

    return val;
}

double 
Round(double inValue);

double 
InterpolateValues(double dblNum1, double dblNum2, double dblProgress);

inline int
Clamp(int min, int val, int max)
{
    if (val < min)
    {
        val = min;
    }
    else if (val > max)
    {
        val = max;
    }

    return val;
}

HRESULT GetReadyState(IHTMLElement * pElm, BSTR * pbstrReadyState);

HRESULT CreateObject(REFCLSID clsid,
                     REFIID iid,
                     void ** ppObj);
 
HWND GetDocumentHwnd(IHTMLDocument2 * pDoc);


//
// Returns true if this is Win95 or 98
//

bool TIMEIsWin9x(void);

//
// Returns true is this is Win95 only
//
bool TIMEIsWin95(void);

//
// Combine a base and src into newly allocated storage, ppOut
//
HRESULT TIMECombineURL(LPCTSTR base, LPCTSTR src, LPOLESTR * ppOut);

UINT TIMEGetUrlScheme(const TCHAR * pchUrlIn);

bool ConvertToPixelsHELPER(LPOLESTR szString, LPOLESTR szKey, double dFactor, float fPixelFactor, double *outVal);
//
// Find a mime type
//
HRESULT
TIMEFindMimeFromData(LPBC pBC,
                     LPCWSTR pwzUrl,
                     LPVOID pBuffer,
                     DWORD cbSize,
                     LPCWSTR pwzMimeProposed,
                     DWORD dwMimeFlags,
                     LPWSTR *ppwzMimeOut,
                     DWORD dwReserved);

//
// Property change notification helper
//

HRESULT NotifyPropertySinkCP(IConnectionPoint *pICP, DISPID dispid);

//
// Stub out property accessors that don't really belong on an object.
//
#define STUB_INVALID_ATTRIBUTE_GET(type_name,attrib_name) \
STDMETHOD(get_##attrib_name##) ( ##type_name## * ) \
{\
    return E_UNEXPECTED;\
}

#define STUB_INVALID_ATTRIBUTE_PUT(type_name,attrib_name) \
STDMETHOD(put_##attrib_name##) ( ##type_name## ) \
{\
    return E_UNEXPECTED;\
}

#define STUB_INVALID_ATTRIBUTE(type_name,attrib_name) \
    STUB_INVALID_ATTRIBUTE_GET(##type_name##,##attrib_name##)\
    STUB_INVALID_ATTRIBUTE_PUT(##type_name##,##attrib_name##)


#ifdef DBG

//
// Debugging Utilities
//

void PrintStringTokenArray(/*in*/ LPWSTR                  pstrString, 
                           /*in*/CPtrAry<STRING_TOKEN*> * paryTokens);

void PrintWStr(/*in*/ LPWSTR pstr);

#endif /* DBG */

#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\containerobj.h ===
#ifndef _CONTAINEROBJ_H_
#define _CONTAINEROBJ_H_

//************************************************************
//
// FileName:        containerobj.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of CContainerObj
//
//************************************************************


#include "mpctnsite.h"
#include "playlist.h"

interface ITIMEMediaPlayerOld;

#define mpShowFilename      0
#define mpShowTitle         1
#define mpShowAuthor        2
#define mpShowCopyright     3
#define mpShowRating        4
#define mpShowDescription   5
#define mpShowLogoIcon      6
#define mpClipFilename      7
#define mpClipTitle         8
#define mpClipAuthor        9
#define mpClipCopyright     10
#define mpClipRating        11
#define mpClipDescription   12
#define mpClipLogoIcon      13
#define mpBannerImage       14
#define mpBannerMoreInfo    15
#define mpWatermark         16

enum PlayerState;

// forward declaration
class CMPContainerSite;
class CTIMEPlayer;

class CContainerObj
    : public CMPContainerSiteHost
{
  public: 
    CContainerObj();
    virtual ~CContainerObj();
    HRESULT Init(REFCLSID clsid, 
                 CTIMEPlayer *pPlayer,
                 IPropertyBag2 * pPropBag,
                 IErrorLog * pErrorLog);
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // CContainerSiteHost
    virtual IHTMLElement * GetElement();
    virtual IServiceProvider * GetServiceProvider();

    virtual HRESULT Invalidate(LPCRECT prc);

    virtual HRESULT GetContainerSize(LPRECT prcPos);
    virtual HRESULT SetContainerSize(LPCRECT prcPos);
    
    virtual HRESULT ProcessEvent(DISPID dispid,
                                 long lCount, 
                                 VARIANT varParams[]);

    virtual HRESULT GetExtendedControl(IDispatch **ppDisp);

    // CMPContainerSiteHost
    virtual HRESULT NegotiateSize(RECT &nativeSize,
                                  RECT &finalSize,
                                  bool &fIsNative);

    // methods for hosting site
    HRESULT Start();
    HRESULT Stop();
    HRESULT Pause();
    HRESULT Resume();

    HRESULT Render(HDC hdc, RECT *prc);
    HRESULT SetMediaSrc(WCHAR * pwszSrc);
    HRESULT SetRepeat(long lRepeat);
    HRESULT SetSize(RECT *prect);

    HRESULT GetControlDispatch(IDispatch **ppDisp);

    HRESULT clipBegin(VARIANT var);
    HRESULT clipEnd(VARIANT var);

    HRESULT Seek(double dblTime);
    double GetCurrentTime();
    HRESULT GetMediaLength(double &dblLength);
    HRESULT GetCurrClipLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    HRESULT CanSeekToMarkers(bool &fcanSeek);
    HRESULT IsBroadcast(bool &fcanSeek);
    HRESULT BufferingTime(double &dblBuffTime);
    HRESULT BufferingProgress(double &dblBuffTime);
    HRESULT BufferingCount(long &dblBuffTime);
    HRESULT HasMedia(bool &fhasMedia);
    bool UsingWMP() {return m_fUsingWMP; }

    HRESULT GetNaturalWidth(long *width);
    HRESULT GetNaturalHeight(long *height);
        
    HRESULT setActiveTrackOnLoad(long index);
    void SetDuration();
    HRESULT SetVisibility(bool fVisible);
    bool UsingPlaylist();
    
    HRESULT GetMediaPlayerInfo(LPWSTR *pwstr,  int mpInfoToReceive);
    void SetMediaInfo(CPlayItem *pPlayItem);

    HRESULT GetSourceLink(LPWSTR *pwstr);

    // persistance
    HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //state control
    void ReadyStateNotify(LPWSTR szReadyState);

    CTIMEPlayer * GetPlayer() { return m_pPlayer; }
    ITIMEMediaPlayerOld *GetProxyPlayer() { return m_pProxyPlayer; }

    PlayerState GetState();

    bool IsActive() const { return m_bActive; }

  private:
    bool isFileNameAsfExt(WCHAR * pwszSrc);
    void UpdateNaturalDur(bool bUpdatePlaylist);
    
    void SetMediaReadyFlag() { m_fMediaReady = true;}
    bool GetMediaReadyFlag() const { return m_fMediaReady;}
    HRESULT SetPosition(double dblLength);

    HRESULT PutSrc(WCHAR *pwszSrc);
        
  private:
    LONG                m_cRef;
    DAComPtr<CMPContainerSite> m_pSite;
    bool                m_fStarted;
    bool                m_fUsingWMP;
    bool                m_bPauseOnPlay;
    bool                m_bFirstOnMediaReady;
    bool                m_bSeekOnPlay;
    bool                m_bEndOnPlay;
    double              m_dblSeekTime;
    bool                m_bIsAsfFile;
    long                m_lActiveLoadedTrack;
    bool                m_setVisible;
    LPOLESTR            m_origVisibility;
    CTIMEPlayer        *m_pPlayer;
    bool                m_bMMSProtocol;
    bool                m_bStartOnLoad;
    bool                m_fMediaReady;
    bool                m_fLoaded;

    DAComPtr<ITIMEMediaPlayerOld>    m_pProxyPlayer;
    bool                             m_bActive;
}; // CContainerObj

#endif //_CONTAINEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\containersite.h ===
#ifndef _CONTAINERSITE_H_
#define _CONTAINERSITE_H_

//************************************************************
//
// FileName:        containersite.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CContainerSite
//
//************************************************************

#include <docobj.h>
#include <mshtml.h>

// forward class declarations
class
ATL_NO_VTABLE
CContainerSiteHost
{
  public:
    virtual IHTMLElement * GetElement() = 0;
    virtual IServiceProvider * GetServiceProvider() = 0;

    virtual HRESULT Invalidate(LPCRECT prc) = 0;

    virtual HRESULT GetContainerSize(LPRECT prcPos) = 0;
    virtual HRESULT SetContainerSize(LPCRECT prcPos) = 0;
    virtual HRESULT ProcessEvent(DISPID dispid,
                                 long lCount, 
                                 VARIANT varParams[]) = 0;

    virtual HRESULT GetExtendedControl(IDispatch **ppDisp) = 0;
};

enum ObjectState
{
    OS_PASSIVE,
    OS_LOADED,
    OS_RUNNING,
    OS_INPLACE,
    OS_UIACTIVE
};

class
ATL_NO_VTABLE
CContainerSite :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatch,
    public IServiceProvider,
    public IOleClientSite,
    public IAdviseSinkEx,
    public IOleInPlaceSiteWindowless,
    public IOleInPlaceFrame,
    public IOleCommandTarget,
    public IOleControlSite
{
  public:
    CContainerSite();
    virtual ~CContainerSite();

    HRESULT Init(CContainerSiteHost &pHost,
                 IUnknown * pCtl,
                 IPropertyBag2 *pPropBag,
                 IErrorLog *pErrorLog);
    virtual void Detach();

    //
    // IUnknown Methods
    //
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // IServiceProvider methods
    //
    STDMETHODIMP QueryService(REFGUID guid, REFIID iid, void **ppv);

    //
    // IOleClientSite methods
    //
    STDMETHODIMP SaveObject(void);
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk);
    STDMETHODIMP GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    //
    // IAdviseSink Methods
    //
    STDMETHODIMP_(void) OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *pmk);
    STDMETHODIMP_(void) OnSave(void);
    STDMETHODIMP_(void) OnClose(void);

    //
    // IAdviseSinkEx Methods
    //
    STDMETHODIMP_(void) OnViewStatusChange(DWORD dwViewStatus);

    //
    // IOleWindow Methods
    //
    STDMETHODIMP GetWindow(HWND *phWnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    //
    // IOleInPlaceSite Methods
    //
    STDMETHODIMP CanInPlaceActivate(void);
    STDMETHODIMP OnInPlaceActivate(void);
    STDMETHODIMP OnUIActivate(void);
    STDMETHODIMP GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppUIWin, RECT *prc, RECT *prcClip, OLEINPLACEFRAMEINFO *pFI);
    STDMETHODIMP Scroll(SIZE sz);
    STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate(void);
    STDMETHODIMP DiscardUndoState(void);
    STDMETHODIMP DeactivateAndUndo(void);
    STDMETHODIMP OnPosRectChange(const RECT * prc);

    //
    // IOleInPlaceSiteEx Methods
    //
    STDMETHODIMP OnInPlaceActivateEx(BOOL * pfNoRedraw, DWORD dwFlags);
    STDMETHODIMP OnInPlaceDeactivateEx(BOOL fNoRedraw);
    STDMETHODIMP RequestUIActivate(void);

    //
    // IOleInPlaceSiteWindowless Methods
    //
    STDMETHODIMP CanWindowlessActivate(void);
    STDMETHODIMP GetCapture(void);
    STDMETHODIMP SetCapture(BOOL fCapture);
    STDMETHODIMP GetFocus(void);
    STDMETHODIMP SetFocus(BOOL fFocus);
    STDMETHODIMP GetDC(const RECT *pRect, DWORD dwFlags, HDC* phDC);
    STDMETHODIMP ReleaseDC(HDC hDC);
    STDMETHODIMP InvalidateRect(const RECT *pRect, BOOL fErase);
    STDMETHODIMP InvalidateRgn(HRGN hRGN, BOOL fErase);
    STDMETHODIMP ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip);
    STDMETHODIMP AdjustRect(RECT *prc);
    STDMETHODIMP OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

    //
    // IOleUIWindow
    //
    STDMETHODIMP GetBorder(LPRECT prcBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pBW);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pBW);
    STDMETHODIMP SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj);

    //
    // IOleInPlaceFrame Methods
    //
    STDMETHODIMP InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW);
    STDMETHODIMP SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj);
    STDMETHODIMP RemoveMenus(HMENU hMenu);
    STDMETHODIMP SetStatusText(LPCOLESTR pszText);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP TranslateAccelerator(LPMSG pMSG, WORD wID);

    //
    // IDispatch Methods
    //
    STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
    STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
    STDMETHODIMP Invoke(DISPID disIDMember, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

    //
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    //
    // IOleControlSite methods
    //
    STDMETHOD(OnControlInfoChanged)(void);
    STDMETHOD(LockInPlaceActive)(BOOL fLock);
    STDMETHOD(GetExtendedControl)(IDispatch **ppDisp);
    STDMETHOD(TransformCoords)(POINTL *pPtlHiMetric, POINTF *pPtfContainer, DWORD dwFlags);
    STDMETHOD(TranslateAccelerator)(MSG *pmsg, DWORD grfModifiers);
    STDMETHOD(OnFocus)(BOOL fGotFocus);
    STDMETHOD(ShowPropertyFrame)(void);

    //
    // ATL Maps
    //

    BEGIN_COM_MAP(CContainerSite)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IOleClientSite)
        COM_INTERFACE_ENTRY(IAdviseSink)
        COM_INTERFACE_ENTRY(IAdviseSinkEx)
        COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceSiteWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceSite)
        COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
        COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY(IOleControlSite)
        COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
        COM_INTERFACE_ENTRY(IOleInPlaceFrame)
    END_COM_MAP();

    // internal
    HRESULT Activate();
    HRESULT Deactivate();
    HRESULT Unload();
    HRESULT Draw(HDC hdc, RECT *prc);

    IOleInPlaceObject *GetIOleInPlaceObject() { return m_pInPlaceObject;}

    // persistance
    HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    void SetSize (RECT *pRect);

  protected:
    enum
    {
        VALIDATE_ATTACHED = 1,
        VALIDATE_LOADED   = 2,
        VALIDATE_INPLACE  = 3,
        VALIDATE_WINDOWLESSINPLACE = 4
    };

    bool IllegalSiteCall(DWORD dwFlags);
    virtual HRESULT _OnPosRectChange(const RECT * prc) { return S_OK; }

  protected:
    DWORD                            m_dwAdviseCookie;
    ObjectState                      m_osMode;
    IViewObject2                    *m_pViewObject;
    IOleObject                      *m_pIOleObject;
    IUnknown                        *m_pObj;
    IOleInPlaceObject               *m_pInPlaceObject;
    IHTMLDocument2                  *m_pHTMLDoc;
    CContainerSiteHost              *m_pHost;
    bool                             m_fWindowless;
    bool                             m_fStarted;
    bool                             m_fIgnoreInvalidate;
    RECT                             m_rectSize;
}; // CContainerSite

#endif //_CONTAINERSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\containersite.cpp ===
//************************************************************
//
// FileName:        containersite.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container site implementation.
//
//************************************************************

#include "headers.h"
#include "containersite.h"
#include "player.h"
#include "util.h"
#include "eventmgr.h"

DeclareTag(tagContainerSite, "TIME: Players", "CContainerSite methods");

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerSite::CContainerSite() :
    m_pObj(NULL),
    m_pIOleObject(NULL),
    m_pInPlaceObject(NULL),
    m_pViewObject(NULL),
    m_dwAdviseCookie(0),
    m_osMode(OS_PASSIVE),
    m_fWindowless(false),
    m_pHTMLDoc(NULL),
    m_pHost(NULL),
    m_fStarted(false),
    m_fIgnoreInvalidate(false)
{
    TraceTag((tagContainerSite, "CContainerSite::CContainerSite"));

    m_rectSize.top = m_rectSize.left = m_rectSize.bottom = m_rectSize.right = 0;
} // CContainerSite

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerSite::~CContainerSite()
{
    TraceTag((tagContainerSite, "CContainerSite::~CContainerSite"));
    
    m_pHost = NULL;

    ReleaseInterface(m_pViewObject);
    ReleaseInterface(m_pIOleObject);
    ReleaseInterface(m_pObj);
    ReleaseInterface(m_pInPlaceObject);
    ReleaseInterface(m_pHTMLDoc);
} // ~CContainerSite

HRESULT
CContainerSite::Init(CContainerSiteHost & pHost,
                     IUnknown * pObj,
                     IPropertyBag2 *pPropBag,
                     IErrorLog *pErrorLog)
{
    TraceTag((tagContainerSite, "CContainerSite::Init"));

    HRESULT hr = S_OK;
    CComPtr<IPersistPropertyBag2> spPropBag;

    Assert(pObj);

    m_pHost = &pHost;
    
    m_pObj = pObj;
    m_pObj->AddRef();
    
    // Weak reference.
    IHTMLElement *pHTMLElem = m_pHost->GetElement();
    
    if (NULL == pHTMLElem)
    {
        TraceTag((tagError,
                  "CContainerSite::Init - unable to get element pointer from time behavior!!!"));
        hr = E_UNEXPECTED;
        goto done;
    }

    {
        DAComPtr<IDispatch> pDisp;
        hr = THR(pHTMLElem->get_document(&pDisp));
        if (FAILED(hr))
        {
            goto done;
        }
        
        Assert(pDisp);
        Assert(m_pHTMLDoc == NULL);
        hr = THR(pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &m_pHTMLDoc)));

        if (FAILED(hr))
        {
            goto done;
        }
    }

    Assert(m_pHTMLDoc != NULL);

    // We need an IOleObject most of the time, so get one here.
    hr = THR(m_pObj->QueryInterface(IID_TO_PPV(IOleObject, &m_pIOleObject)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pIOleObject->QueryInterface(IID_TO_PPV(IViewObject2, &m_pViewObject)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pObj->QueryInterface(IID_TO_PPV(IPersistPropertyBag2, &spPropBag)));
    if (SUCCEEDED(hr) && pPropBag != NULL)
    {
        hr = THR(spPropBag->Load(pPropBag, pErrorLog));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    // SetClientSite is critical for DocObjects
    hr = THR(m_pIOleObject->SetClientSite(SAFECAST(this, IOleClientSite*)));
    if (FAILED(hr))
    {
        goto done;
    }

    m_dwAdviseCookie = 0;
    hr = THR(m_pIOleObject->Advise(SAFECAST(this, IAdviseSink*), &m_dwAdviseCookie));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_dwAdviseCookie != 0);

    // Put the object in the running state
    hr = THR(OleRun(m_pIOleObject));
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_osMode = OS_RUNNING;
        
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    RRETURN(hr);
} // Init

void 
CContainerSite::SetSize(RECT *pRect)
{
	HRESULT hr = S_OK;

    if (!pRect)
    {
        goto done;
    }

    m_rectSize.top = pRect->top;
    m_rectSize.left = pRect->left;
    m_rectSize.right = pRect->right;
    m_rectSize.bottom = pRect->bottom;

    hr = THR(m_pInPlaceObject->SetObjectRects(pRect, pRect));
    if (FAILED(hr))
    {
        goto done;
    }

  done:

    return;
}

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        Detach
//************************************************************
void
CContainerSite::Detach()
{
    TraceTag((tagContainerSite, "CContainerSite(%p)::Detach()",
              this));

    Unload();

    m_osMode = OS_LOADED;

    ReleaseInterface(m_pObj);

    m_osMode = OS_PASSIVE;

    // local book keeping
    ReleaseInterface(m_pHTMLDoc);

    m_pHost = NULL;
} // Detach

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Validate call
//************************************************************

bool
CContainerSite::IllegalSiteCall(DWORD dwFlags)
{
    // check object state
    switch (dwFlags)
    {
        case VALIDATE_WINDOWLESSINPLACE:
            if (!m_fWindowless)
            {
                Assert(0 && "Illegal call to windowless interface by ActiveX control (not a hosting bug)");
                return true;
            }
            break;

        case VALIDATE_INPLACE:
            if (m_osMode < OS_INPLACE)
                return true;
            break;

        case VALIDATE_LOADED:
            if (m_osMode < OS_LOADED)
                return true;
            break;
        default:
            break;
    }

    return false;
} // IllegalSiteCall

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        IService Provider method
//************************************************************

STDMETHODIMP
CContainerSite::QueryService(REFGUID sid, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    IServiceProvider *psp = NULL;

    if( NULL == ppv )
    {
        Assert( false );
        return E_POINTER;
    }

    *ppv = NULL;

    // check to see if this is something we support locally
    // in the container.
    if (IsEqualGUID(sid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
        goto done;
    }

   
    // Fall back to TIME Element if we still have one.

    // We have the supporting Service Provider cached (at init() time) for 
    // the behavior over in CBaseBvr which CTIMEElementBase inherits from.
    if (m_pHost != NULL)
    {
        psp = m_pHost->GetServiceProvider();
        if (psp != NULL)
        {
            hr = psp->QueryService(sid, riid, ppv);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CContainerSite::QueryService - query failed!!! [%08X]", hr));
            }
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }

  done:
    return hr;
} // QueryService

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::Activate()
{
    HRESULT hr = S_OK;
    HWND hWnd = NULL;
    RECT rc;

    rc.left = rc.top = rc.right = rc.bottom = 0;

    hr = THR(GetWindow(&hWnd));
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pIOleObject && !m_fStarted)
    {
        hr = m_pIOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE,
                                   NULL, 
                                   SAFECAST(this, IOleClientSite*), 
                                   0, 
                                   hWnd, 
                                   &rc);

    }
    m_fStarted = true;
    hr = S_OK;
done:
    return hr;
}


HRESULT
CContainerSite::Unload()
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite(%p)::Unload()",
              this));

    // Deactivate InPlace Object (Interface is released as a result of this call)
    if (m_pInPlaceObject != NULL)
    { 
        m_pInPlaceObject->InPlaceDeactivate();
        ReleaseInterface(m_pInPlaceObject);
    }

    ReleaseInterface(m_pViewObject);

    if (m_pIOleObject != NULL)
    {
        DAComPtr<IOleObject> spTmp = m_pIOleObject;
        
        ReleaseInterface(m_pIOleObject);

        spTmp->Close(OLECLOSE_NOSAVE);

        Assert(m_dwAdviseCookie != 0);

        spTmp->Unadvise(m_dwAdviseCookie);
        spTmp->SetClientSite(NULL);
    }

    hr = S_OK;
  done:
    return hr;
}


//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::Deactivate()
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite(%p)::Deactivate()",
              this));

    m_fStarted = false;
    
    hr = S_OK;
  done:
    return hr;
}


//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

HRESULT
CContainerSite::Draw(HDC hdc, RECT *prc)
{
    HRESULT hr = S_OK;

    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, NULL)", hdc));
    else
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, (%d, %d, %d, %d))", hdc, prc->left, prc->top, prc->right, prc->bottom));

    if (m_pViewObject == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    // repack rect into RECTL.
    RECTL  rcl;
    RECTL *prcl;
    
    if (prc == NULL)
    {
        prcl = NULL;
    }
    else
    {
        rcl.left = prc->left;
        rcl.top = prc->top;
        rcl.right = prc->right;
        rcl.bottom = prc->bottom;
        prcl = &rcl;

        if (m_pInPlaceObject)
        {
            // This is a workaround for the WMP.  We have to ignore the Invalidate that is 
            // generated in the SetObjectRect in the Draw call otherwise will will not render correctly
            m_fIgnoreInvalidate = true;
            hr = m_pInPlaceObject->SetObjectRects(prc, prc);
            m_fIgnoreInvalidate = false;
            if (FAILED(hr))
            {
                goto done;
            }
        }

    }

    hr = m_pViewObject->Draw(DVASPECT_CONTENT,
                             0,
                             NULL,
                             NULL,
                             NULL,
                             hdc,
                             prcl,
                             NULL,
                             NULL,
                             0);
done:

    return hr;
} // render

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SaveObject, IOleClientSite 
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

STDMETHODIMP
CContainerSite::SaveObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::SaveObject"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    RRETURN(E_NOTIMPL);
} // SaveObject

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetMoniker, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk)
{
    TraceTag((tagContainerSite, "CContainerSite::GetMoniker"));
    return E_NOTIMPL;
} // GetMoniker

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetContainer, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetContainer(IOleContainer **ppContainer)
{
    TraceTag((tagContainerSite, "CContainerSite::GetContainer"));

    *ppContainer = NULL;
    return E_NOINTERFACE;
} // GetContainer

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestNewObjectLayout, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::RequestNewObjectLayout(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestNewObjectLayout"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // RequestNewObjectLayout

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnShowWindow, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagContainerSite, "CContainerSite::OnShowWindow"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // OnShowWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ShowObject, IOleClientSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ShowObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowObject"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // ShowObject

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnControlInfoChanged, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnControlInfoChanged(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnControlInfoChanged"));
    return S_OK;
} // OnControlInfoChanged

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        LockInPlaceActive, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagContainerSite, "CContainerSite::LockInPlaceActive"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // LockInPlaceActive

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        GetExtendedControl, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetExtendedControl(IDispatch **ppDisp)
{
    TraceTag((tagContainerSite, "CContainerSite::GetExtendedControl"));
    
    HRESULT hr = E_NOTIMPL;
    
    CHECK_RETURN_SET_NULL(ppDisp);
    
    if (m_pHost != NULL)
    {
        hr = m_pHost->GetExtendedControl(ppDisp);
    }

    return hr;
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TransformCoords, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::TransformCoords(POINTL *pPtlHiMetric,
                       POINTF *pPtfContainer,
                       DWORD   dwFlags)
{
    TraceTag((tagContainerSite, "CContainerSite::TransformCoords"));
    return E_NOTIMPL;
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TranslateAccelerator, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::TranslateAccelerator(MSG *pmsg, DWORD grfModifiers)
{
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    return S_FALSE;
} // TranslateAccelerator

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnFocus, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnFocus"));
    return S_OK;
} // OnFocus

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        ShowPropertyFrame, IOleControlSite 
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ShowPropertyFrame(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowPropertyFrame"));
    return S_OK;
} // ShowPropertyFrame

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindow, IOleWindow 
// Abstract:        Retrieves the handle of the window 
//                  associated with the object on which this 
//                  interface is implemented.
//************************************************************

STDMETHODIMP
CContainerSite::GetWindow(HWND *phWnd)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindow"));

    if (phWnd == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetWindow - invalid arg"));
        return E_POINTER;
    }
        
    Assert(m_pHTMLDoc != NULL);

    IOleWindow *pOleWindow = NULL;
    HRESULT hr = m_pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pOleWindow));

#if 1
    if (FAILED(hr))
    {
        goto done;
    }
#else
    if (FAILED(hr))
    {
        // IE4 path
        CComPtr<IElementBehaviorSite> spElementBehaviorSite;
        spElementBehaviorSite = m_pTIMEElem->GetBvrSite();

        CComPtr<IObjectWithSite> spSite;
        // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
        hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
        if (FAILED(hr))
        {
            goto done;
        }

        // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
        hr = spSite->GetSite(IID_IOleWindow, (void**) &pOleWindow);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::GetWindow - unable to QI for IOleWindow on hosting Document"));
            goto done;
        }
    }
#endif
   
    Assert(pOleWindow != NULL);

    hr = pOleWindow->GetWindow(phWnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(*phWnd != NULL);
    
    hr = S_OK;
done:
    ReleaseInterface(pOleWindow);
    return hr;
} // GetWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ContextSensitiveHelp, IOleWindow 
// Abstract:        Instructs the object on which this 
//                  interface is implemented to enter or leave 
//                  a context-sensitive help mode.
//************************************************************

STDMETHODIMP
CContainerSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagContainerSite, "CContainerSite::ContextSensitiveHelp"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    
    // ISSUE - reach back to document and forward on call to it's InplaceSite!
    return NOERROR;
} // ContextSensitiveHelp

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanInPlaceActivate, IOleInPlaceSite
// Abstract:        Answers the server whether or not we can 
//                  currently in-place activate its object.  
//                  By implementing this interface we say
//                  that we support in-place activation, but 
//                  through this function we indicate whether 
//                  the object can currently be activated
//                  in-place.  Iconic aspects, for example, 
//                  cannot, meaning we return S_FALSE.
//************************************************************

STDMETHODIMP
CContainerSite::CanInPlaceActivate(void)
{    
    TraceTag((tagContainerSite, "CContainerSite::CanInPlaceActivate"));
    return S_OK;
} // CanInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivate, IOleInPlaceSite
// Abstract:        Informs the container that an object is 
//                  being activated in-place such that the 
//                  container can prepare appropriately.  The
//                  container does not, however, make any user 
//                  interface changes at this point.
//                  See OnUIActivate.
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivate"));
    return OnInPlaceActivateEx(NULL, 0);
} // OnInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivate, IOleInPlaceSite
// Abstract:        Notifies the container that the object has 
//                  deactivated itself from an in-place state.  
//                  Opposite of OnInPlaceActivate.  The 
//                  container does not change any UI at this 
//                  point.
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceDeactivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivate"));

    if (m_osMode == OS_UIACTIVE)
        OnUIDeactivate(false);
    
    Assert(m_pInPlaceObject != NULL);
    ReleaseInterface(m_pInPlaceObject);

    m_fWindowless = false;
    m_osMode = OS_RUNNING;

    return S_OK;
} // OnInPlaceDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIActivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  going to start munging around with user 
//                  interface, like replacing the menu.  The
//                  container should remove any relevant UI in 
//                  preparation.
//************************************************************

STDMETHODIMP
CContainerSite::OnUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIActivate"));
    if (IllegalSiteCall(VALIDATE_LOADED) ||
        (m_osMode < OS_RUNNING))
    {
        TraceTag((tagError, "Object is not inplace yet!!!"));
        return E_UNEXPECTED;
    }

    m_osMode = OS_UIACTIVE;
    return S_OK;
} // OnUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIDeactivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  deactivating its in-place user interface 
//                  at which time the container may reinstate 
//                  its own.  Opposite of OnUIActivate.
//************************************************************

STDMETHODIMP
CContainerSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIDeactivate"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    
    m_osMode = OS_INPLACE;
    return S_OK;
} // OnUIDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DeactivateAndUndo, IOleInPlaceSite
// Abstract:        If immediately after activation the object 
//                  does an Undo, the action being undone is 
//                  the activation itself, and this call
//                  informs the container that this is, in 
//                  fact, what happened.
//************************************************************

STDMETHODIMP
CContainerSite::DeactivateAndUndo(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DeactivateAndUndo"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // DeactivateAndUndo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DiscardUndoState, IOleInPlaceSite
// Abstract:        Informs the container that something 
//                  happened in the object that means the 
//                  container should discard any undo 
//                  information it currently maintains for the 
//                  object.
//************************************************************

STDMETHODIMP
CContainerSite::DiscardUndoState(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DiscardUndoState"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // DiscardUndoState

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindowContext, IOleInPlaceSite
// Abstract:        Provides an in-place object with pointers 
//                  to the frame and document level in-place 
//                  interfaces (IOleInPlaceFrame and 
//                  IOleInPlaceUIWindow) such that the object 
//                  can do border negotiation and so forth.  
//                  Also requests the position and clipping 
//                  rectangles of the object in the container 
//                  and a pointer to an OLEINPLACEFRAME info 
//                  structure which contains accelerator 
//                  information.
//
//                  NOTE: that the two interfaces this call 
//                  returns are not available through 
//                  QueryInterface on IOleInPlaceSite since 
//                  they live with the frame and document, but 
//                  not the site.
//************************************************************

STDMETHODIMP
CContainerSite::GetWindowContext(IOleInPlaceFrame    **ppFrame,
                                 IOleInPlaceUIWindow **ppUIWindow, 
                                 RECT                 *prcPos, 
                                 RECT                 *prcClip, 
                                 OLEINPLACEFRAMEINFO  *pFI)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindowContext"));
    HRESULT hr;

    if ( (ppFrame == NULL) ||
         (ppUIWindow == NULL) ||
         (prcPos == NULL) ||
         (prcClip == NULL) ||
         (pFI == NULL) )
    {
        TraceTag((tagError, "CContainerSite::GetWindowContext - invalid arg"));
        return E_POINTER;
    }

    *ppFrame = NULL;
    *ppUIWindow = NULL;
    SetRectEmpty(prcPos);
    SetRectEmpty(prcClip);
    memset(pFI, 0, sizeof(OLEINPLACEFRAMEINFO));

    if (IllegalSiteCall(VALIDATE_LOADED))
    {
        Assert(0 && "Unexpected call to client site.");
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // return pointers to ourselves
    // NOTE: these are stubbed out
    hr = THR(this->QueryInterface(IID_IOleInPlaceFrame, (void**)ppFrame));
    if (FAILED(hr))
        goto done;

    hr = THR(this->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow));
    if (FAILED(hr))
        goto done;

    // get position rect
    if (m_pHost != NULL)
    {
        hr = THR(m_pHost->GetContainerSize(prcPos));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // Note that Clip and Pos are the same.
    ::CopyRect(prcClip, prcPos);

    hr = S_OK;

done:
    return hr;
} // GetWindowContext

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Scroll, IOleInPlaceSite
// Abstract:        Asks the container to scroll the document, 
//                  and thus the object, by the given amounts 
//                  in the sz parameter.
//************************************************************

STDMETHODIMP
CContainerSite::Scroll(SIZE sz)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::Scroll"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // Scroll

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnPosRectChange, IOleInPlaceSite
// Abstract:        Informs the container that the in-place 
//                  object was resized.  This does not change 
//                  the site's rectangle in any case.
//************************************************************

STDMETHODIMP
CContainerSite::OnPosRectChange(const RECT *prcPos)
{
    if (prcPos == NULL)
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange((%d, %d, %d, %d))", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));
 
    HRESULT hr;

    if (prcPos == NULL)
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - invalidarg"));
        hr = E_POINTER;
        goto done;
    }


    if (IllegalSiteCall(VALIDATE_INPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (m_pHost == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(_OnPosRectChange(prcPos));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
} // OnPosRectChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags)
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivateEx"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    Assert(m_pInPlaceObject == NULL);

    // Make Sure we are Windowless
    if (dwFlags == ACTIVATE_WINDOWLESS)
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObjectWindowless, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
        m_fWindowless = true;
    }
    else
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObject, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
    }

    if (m_pInPlaceObject)
    {
        if (m_rectSize.bottom - m_rectSize.top != 0 && m_rectSize.left - m_rectSize.right != 0)
        {
            IGNORE_HR(m_pInPlaceObject->SetObjectRects(&m_rectSize, &m_rectSize));
        }
    }

    if (pfNoRedraw != NULL)
        *pfNoRedraw = m_fWindowless ? true : false;

    m_osMode = OS_INPLACE;

    return S_OK;
} // OnInPlaceActivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivateEx"));
        
    return OnInPlaceDeactivate();
} // OnInPlaceDeactivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestUIActivate, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::RequestUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestUIActivate"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // RequestUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanWindowlessActivate, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::CanWindowlessActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::CanWindowlessActivate"));
    return S_OK;
} // CanWindowlessActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetCapture, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetCapture(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // GetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetCapture, IOleInPlaceSiteWindowless
// Abstract:        Enables an in-place active, windowless 
//                  object to capture all mouse messages.
//                  If TRUE, the container should capture the 
//                  mouse for the object. If FALSE, the container 
//                  should release mouse capture for the object. 
//************************************************************

STDMETHODIMP
CContainerSite::SetCapture(BOOL fCapture)
{
    TraceTag((tagContainerSite, "CContainerSite::SetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // SetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetFocus, IOleInPlaceSiteWindowless
// Abstract:        Called by an in-place active, windowless 
//                  object to determine if it still has the 
//                  keyboard focus or not.
//************************************************************

STDMETHODIMP
CContainerSite::GetFocus(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return S_FALSE;
} // GetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetFocus, IOleInPlaceSiteWindowless
// Abstract:        Sets the keyboard focus for a UI-active, 
//                  windowless object.  If TRUE, sets the 
//                  keyboard focus to the calling object. If FALSE, 
//                  removes the keyboard focus from the calling object, 
//                  provided that the object has the focus.
//************************************************************

STDMETHODIMP
CContainerSite::SetFocus(BOOL fFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::SetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
 } // SetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::GetDC(const RECT *prc, DWORD dwFlags, HDC *phDC)
{
    TraceTag((tagContainerSite, "CContainerSite::GetDC"));
    HRESULT hr;
    HWND hWnd;

    if (phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - invalid arg"));
        hr = E_POINTER;
        goto done;
    }

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = GetWindow(&hWnd);
    if (FAILED(hr) || (hWnd == NULL))
    {
        TraceTag((tagError, "CContainerSite::GetDC - GetWindow() failed"));
        hr = E_FAIL;
        goto done;
    }

    *phDC = ::GetDC(hWnd);
    if (*phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - Win32 GetDC returned NULL!"));
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }

done:
    return hr;
} // GetDC

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ReleaseDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ReleaseDC(HDC hDC)
{
    TraceTag((tagContainerSite, "CContainerSite::ReleaseDC"));

    HRESULT hr;
    HWND    hWnd;

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    hr = GetWindow(&hWnd);
    Assert(SUCCEEDED(hr) && (hWnd != NULL));
    
    Assert(hDC != NULL);

    ::ReleaseDC(hWnd, hDC);

    return S_OK;
} //lint !e550

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRect, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

STDMETHODIMP
CContainerSite::InvalidateRect(const RECT *prc, BOOL fErase)
{
    if (m_fIgnoreInvalidate)
    {
        // This is a workaround for the WMP.  We have to ignore the Invalidate that is 
        // generated in the SetObjectRect in the Draw call otherwise will will not render correctly
        return S_OK;
    }
    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(%d, %d, %d, %d)", prc->left, prc->top, prc->right, prc->bottom));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // reach back to the time element and invalidate
    Assert(m_pHost != NULL);
    // TODO: The below was changed to NULL from for use with the IHTMLPainter interfaces
    return m_pHost->Invalidate(NULL);//prc);
} // InvalidateRect

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRgn, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

STDMETHODIMP
CContainerSite::InvalidateRgn(HRGN hRGN, BOOL fErase)
{
    TraceTag((tagContainerSite, "CContainerSite::InvalidateRgn"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    HRESULT hr = S_OK;
    return hr;
} // InvalidateRgn

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ScrollRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::ScrollRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // ScrollRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        AdjustRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::AdjustRect(RECT *prc)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::AdjustRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // AdjustRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDefWindowMessage, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDefWindowMessage"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // Return that the message was not handled.

    // release focus for the document.

    switch (msg)
    {
// ISSUE: we don't handle focus right now
//        case WM_SETFOCUS:
//            return SetFocus(true);
//        case WM_KILLFOCUS:
//            return SetFocus(false);

        case WM_MOUSEMOVE:
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSKEYUP:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
        case WM_LBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            return S_OK;

        case WM_SETCURSOR:
        case WM_CONTEXTMENU:
        case WM_HELP:
            return S_FALSE;

        case WM_MOUSEHOVER:
        case WM_MOUSELEAVE:
        case 0x8004: //  WM_MOUSEOVER
            return S_OK;

        case WM_CAPTURECHANGED:
            return S_OK;
        default:
            break;
    }

    return S_FALSE;
} // OnDefWindowMessage

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDataChange, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void)
CContainerSite::OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDataChange"));
} // OnDataChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewChange, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnViewChange(DWORD dwAspect, LONG lindex)
{    
    TraceTag((tagContainerSite, "CContainerSite::OnViewChange"));
} // OnViewChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnRename, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnRename(IMoniker *pmk)
{
    TraceTag((tagContainerSite, "CContainerSite::OnRename"));
} // OnRename

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnSave, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnSave(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnSave"));
} // OnSave

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnClose, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnClose(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnClose"));
} // OnClose

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewStatusChange, IAdviseSink
// Abstract:        
//************************************************************

STDMETHODIMP_(void) 
CContainerSite::OnViewStatusChange(DWORD dwViewStatus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnViewStatusChange"));
} // OnViewStatusChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

STDMETHODIMP
CContainerSite::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

STDMETHODIMP
CContainerSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

STDMETHODIMP
CContainerSite::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagContainerSite, "CContainerSite::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

STDMETHODIMP
CContainerSite::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
              DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{

#ifdef DEBUG
    // Here the key to wFlags:
    //
    // #define DISPATCH_METHOD         0x1
    // #define DISPATCH_PROPERTYGET    0x2
    // #define DISPATCH_PROPERTYPUT    0x4
    // #define DISPATCH_PROPERTYPUTREF 0x8

    switch (dispIDMember)
    {
        case DISPID_AMBIENT_USERMODE:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(DISPID_AMBIENT_USERMODE, %04X)", wFlags));
            break;

        default:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(%08X, %04X)", dispIDMember, wFlags));
            break;
    }
#endif

    return E_NOTIMPL;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        QueryStatus, IOleCommandTarget
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{ 
    TraceTag((tagContainerSite, "CContainerSite::QueryStatus"));
    return E_NOTIMPL;
} // QueryStatus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Exec, IOleCommandTarget
// Abstract:        
//************************************************************

STDMETHODIMP
CContainerSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{ 
    TraceTag((tagContainerSite, "CContainerSite::Exec"));
    return E_NOTIMPL;
} // Exec
//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        GetBorder, IOleUIWindow
// Abstract:        Returns the rectangle in which the 
//                  container is willing to negotiate about an 
//                  object's adornments. 
//************************************************************

STDMETHODIMP
CContainerSite::GetBorder(LPRECT prcBorder)
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetBorder"));
    return NOERROR; 
} // GetBorder

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        RequestBorderSpace, IOleUIWindow
// Abstract:        Asks the container if it can surrender the
//                  amount of space in pBW that the object 
//                  would like for it's adornments.  The 
//                  container does nothing but validate the 
//                  spaces on this call. 
//************************************************************

STDMETHODIMP
CContainerSite::RequestBorderSpace(LPCBORDERWIDTHS pBW)
{ 
    TraceTag((tagContainerSite, "CContainerSite::RequestBorderSpace"));
    return NOERROR; 
} // RequestBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetBorderSpace, IOleUIWindow
// Abstract:        Called when the object now officially 
//                  requests that the container surrender 
//                  border space it previously allowed in 
//                  RequestBorderSpace.  The container should 
//                  resize windows appropriately to surrender 
//                  this space. 
//************************************************************

STDMETHODIMP
CContainerSite::SetBorderSpace(LPCBORDERWIDTHS pBW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetBorderSpace"));
    return NOERROR; 
} // SetBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetActiveObject, IOleUIWindow
// Abstract:        Provides the container with the object's 
//                  IOleInPlaceActiveObject pointer and a name 
//                  of the object to show in the container's 
//                  caption. 
//************************************************************

STDMETHODIMP
CContainerSite::SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetActiveObject(%08X, %08X)", pIIPActiveObj, pszObj));
    return S_OK; 
} // SetActiveObject

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        InsertMenus, IOleInPlaceFrame
// Abstract:        Instructs the container to place its 
//                  in-place menu items where necessary in the 
//                  given menu and to fill in elements 0, 2, 
//                  and 4 of the OLEMENUGROUPWIDTHS array to 
//                  indicate how many top-level items are in 
//                  each group. 
//************************************************************

STDMETHODIMP
CContainerSite::InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::InsertMenus"));
    return NOERROR; 
} // InsertMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetMenu, IOleInPlaceFrame
// Abstract:        Instructs the container to replace 
//                  whatever menu it's currently using with 
//                  the given menu and to call 
//                  OleSetMenuDescritor so OLE knows to whom 
//                  to dispatch messages. 
//************************************************************

STDMETHODIMP
CContainerSite::SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetMenu"));
    return NOERROR; 
} // SetMenu

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RemoveMenus, IOleInPlaceFrame
// Abstract:        Asks the container to remove any menus it 
//                  put into hMenu in InsertMenus.
//************************************************************

STDMETHODIMP
CContainerSite::RemoveMenus(HMENU hMenu) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::RemoveMenus"));
    return NOERROR; 
} // RemoveMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetStatusText, IOleInPlaceFrame
// Abstract:        Asks the container to place some text in a 
//                  status line, if one exists.  If the 
//                  container does not have a status line it 
//                  should return E_FAIL here in which case 
//                  the object could display its own. 
//************************************************************

STDMETHODIMP
CContainerSite::SetStatusText(LPCOLESTR pszText) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetStatusText"));
    return E_FAIL; 
} // SetStatusText

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        EnableModeless, IOleInPlaceFrame
// Abstract:        Instructs the container to show or hide 
//                  any modeless popup windows that it may be 
//                  using. 
//************************************************************

STDMETHODIMP
CContainerSite::EnableModeless(BOOL fEnable) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::EnableModeless - %s", fEnable ? "TRUE" : "FALSE"));
    return NOERROR; 
} // EnableModeless

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        TranslateAccelerator, IOleInPlaceFrame
// Abstract:        When dealing with an in-place object from 
//                  an EXE server, this is called to give the 
//                  container a chance to process accelerators 
//                  after the server has looked at the message. 
//************************************************************

STDMETHODIMP
CContainerSite::TranslateAccelerator(LPMSG pMSG, WORD wID) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    return S_FALSE; 
} // TranslateAccelerator

HRESULT 
CContainerSite::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;

    CComPtr<IPersistPropertyBag2> spPropBag;
    
    hr = m_pObj->QueryInterface(IID_TO_PPV(IPersistPropertyBag2, &spPropBag));
    if (SUCCEEDED(hr))
    {
        hr = THR(spPropBag->Save(pPropBag, fClearDirty, fSaveAllProperties));
        if (FAILED(hr))
        {
            goto done;
        }
    }
done:
    return hr;
}

//************************************************************
// End of file
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\containerobj.cpp ===
//************************************************************
//
// FileName:        containerobj.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container object implementation.
//
//************************************************************

#include "headers.h"
#include "containerobj.h"
#include "player.h"
#include "playlist.h"
#include "util.h"
#include "eventmgr.h"
#include "mediaprivate.h"

DeclareTag(tagContainerObj, "TIME: Players", "CContainerObj methods")

#define NOTRACKSELECTED -1

const LPOLESTR cszVisible = L"visible";
const LPOLESTR cszHidden = L"hidden";


//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerObj::CContainerObj() :
    m_cRef(0),
    m_pSite(NULL),
    m_fStarted(false),
    m_fUsingWMP(false),
    m_bPauseOnPlay(false),
    m_bSeekOnPlay(false),
    m_bEndOnPlay(false),
    m_dblSeekTime(0),
    m_bFirstOnMediaReady(true),
    m_bIsAsfFile(false),
    m_lActiveLoadedTrack(NOTRACKSELECTED),
    m_setVisible(false),
    m_origVisibility(NULL),
    m_pPlayer(NULL),
    m_bMMSProtocol(false),
    m_fMediaReady(false),
    m_bStartOnLoad(false),
    m_bActive(false),
    m_fLoaded(false)
{
    TraceTag((tagContainerObj, "CContainerObj::CContainerObj"));
} // CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerObj::~CContainerObj()
{
    TraceTag((tagContainerObj, "CContainerObj::~CContainerObj"));

    DetachFromHostElement();

    if (m_origVisibility)
    {
        delete [] m_origVisibility;
        m_origVisibility = NULL;
    }
} // ~CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Init
//************************************************************

HRESULT
CContainerObj::Init(REFCLSID clsid, CTIMEPlayer *pPlayer, IPropertyBag2 * pPropBag, IErrorLog * pErrorLog)
{
    TraceTag((tagContainerObj, "CContainerObj::Init"));

    HRESULT hr;

    CComPtr<IUnknown> pObj;
    Assert(pPlayer != NULL);

    m_pPlayer = pPlayer;

    hr = THR(::CreateObject(clsid,
                            IID_IUnknown,
                            (void **)&pObj));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // before we try anything, see if it supports ITIMEMediaPlayer
    hr = THR(pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayerOld, &m_pProxyPlayer)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pProxyPlayer->Init());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CreateMPContainerSite(*this,
                                   pObj,
                                   pPropBag,
                                   pErrorLog,
                                   true,
                                   &m_pSite));
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsEqualCLSID(clsid, __uuidof(MediaPlayerCLSID)))
    {
        m_fUsingWMP = true;
    }

  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }
    
    return hr;
} // Init

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        DetachFromHostElement
//************************************************************
HRESULT
CContainerObj::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagContainerObj, "CContainerObj::DetachFromHostElement(%lx)", this));

    Stop();
    
    m_pPlayer = NULL;

    // Protect against reentrancy
    if (m_pProxyPlayer)
    {
        DAComPtr<ITIMEMediaPlayerOld> pTmp = m_pProxyPlayer;
        
        m_pProxyPlayer.Release();

        pTmp->end();
    }
    
    if (m_pSite)
    {
        DAComPtr<CMPContainerSite> pTmp = m_pSite;
        
        m_pSite.Release();

        pTmp->Detach();
    }

    return hr;
} // DetachFromHostElement

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
} // Release

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Start
//************************************************************

HRESULT
CContainerObj::Start()
{
    TraceTag((tagContainerObj, "CContainerObj::Start"));
    HRESULT hr;
    
    if (m_bFirstOnMediaReady)
    {
        if (!m_fLoaded)
        {
            ReadyStateNotify(L"OnLoad");
        }
        m_bStartOnLoad = true;
        m_bPauseOnPlay = false;
        hr = S_OK;
        goto done;
    }

    if (!m_pPlayer)
    {
        hr = E_FAIL;
        goto done;
    }

    IGNORE_HR(m_pProxyPlayer->end());

    if (!m_pSite)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pSite->Activate());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_pProxyPlayer->begin());
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_fStarted = true;

    if (m_pPlayer != NULL)
    {
        m_pPlayer->ClearHoldingFlag();
    }

  done:
    if (FAILED(hr))
    {
        Stop();
    }
    
    return hr;
} // Start

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Pause
//************************************************************

HRESULT
CContainerObj::Pause()
{
    TraceTag((tagContainerObj, "CContainerObj::Pause"));
    HRESULT hr;

    hr  = m_pProxyPlayer->pause();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Pause - pause() failed"));
        if (m_pPlayer->IsActive())
        {
            m_bPauseOnPlay = true;
        }
    }
    return hr;
} // Pause

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Stop
//************************************************************

HRESULT
CContainerObj::Stop()
{
    TraceTag((tagContainerObj, "CContainerObj::Stop(%lx)", this));
    HRESULT hr = S_OK;

        
    if (m_bFirstOnMediaReady)
    {
        m_bStartOnLoad = false;
        m_bEndOnPlay = true;
    }
    if (m_fStarted)
    {    
        // This protects against reentrancy
        m_fStarted = false;

        if (m_pProxyPlayer)
        {
            hr = THR(m_pProxyPlayer->pause());
            if (FAILED(hr))
            {
                goto done;
            }
        }

        if (m_pSite)
        {
            hr = THR(m_pSite->Deactivate());
            if (S_FALSE == hr)
            {
                // when we get the onmediacomplete, we must call end
                m_bEndOnPlay = true;
                hr = S_OK;
            }
            
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
  done:
    return hr;
} // Stop

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Resume
//************************************************************

HRESULT
CContainerObj::Resume()
{
    TraceTag((tagContainerObj, "CContainerObj::Resume"));
    HRESULT hr;
    
    hr  = m_pProxyPlayer->resume();
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::Resume - resume() failed"));
    }
    return hr;
} // Resume


HRESULT CContainerObj::SetVisibility(bool fVisible)
{
    IHTMLElement *pEle; //this is a weak reference
    CComPtr <IHTMLStyle> pStyle;
    BSTR bstrVis = NULL;
    HRESULT hr;

    if (UsingPlaylist() == false)
    {
        hr = S_OK;
        goto done;
    }

    //need to hide the element here.
    pEle = m_pPlayer->GetElement();
    
    hr = THR(pEle->get_style(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    if (fVisible == false)
    {
        BSTR bstrOrigVis;
        //need to cache the old visiblity value here
        if (m_origVisibility == NULL)
        {
            hr = THR(pStyle->get_visibility(&bstrOrigVis));
            if (FAILED(hr) || bstrOrigVis == NULL)
            {
                m_origVisibility = CopyString(cszVisible);
            }
            else
            {
                m_origVisibility = CopyString(bstrOrigVis);
                SysFreeString(bstrOrigVis);
            }
        }

        bstrVis = SysAllocString(cszHidden);
        m_setVisible = true;
    }
    else
    {
        if (m_origVisibility)
        {
            bstrVis = SysAllocString(m_origVisibility);
            delete [] m_origVisibility;
            m_origVisibility = NULL;
        }
        else
        {
            bstrVis = SysAllocString(cszVisible);
        }
        m_setVisible = false;
    }

    if (bstrVis == NULL)
    {
        goto done;
    }
    
    hr = THR(pStyle->put_visibility(bstrVis));
    SysFreeString(bstrVis);
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return S_OK;

}

HRESULT CContainerObj::setActiveTrackOnLoad(long index)
{
 
    m_lActiveLoadedTrack = index; 
    m_bFirstOnMediaReady = true;
    
    //SetVisibility(false);
    return S_OK;
}

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Render(HDC hdc, RECT *prc)
{
    HRESULT hr = S_OK;
    bool bHasMedia = false;

    if (prc == NULL)
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, NULL)"));
    else
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, (%d, %d, %d, %d))", prc->left, prc->right, prc->top, prc->bottom));

    HasMedia(bHasMedia);
    if (m_pSite && bHasMedia)
    {
        hr = m_pSite->Draw(hdc, prc);
    }
    
    return hr;
} // Render

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetMediaSrc
//************************************************************

HRESULT
CContainerObj::SetMediaSrc(WCHAR *pwszSrc)
{
    TraceTag((tagContainerObj, "CContainerObj::SetMediaSrc (%S)", pwszSrc));
    HRESULT hr;

    isFileNameAsfExt(pwszSrc);

    m_pProxyPlayer->end();

    hr  = PutSrc(pwszSrc);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::SetMediaSrc - SetSrc() failed"));
    }

    m_bFirstOnMediaReady = true;

    return hr;
} // SetMediaSrc


// the following is a helper function used because the CanSeek method on WMP only
// works on ASF fles.
bool
CContainerObj::isFileNameAsfExt(WCHAR *pwszSrc)
{
    WCHAR *pext;
    
    m_bIsAsfFile = false;
    m_bMMSProtocol = false;

    if (NULL != pwszSrc)
    {
        if(wcslen(pwszSrc) > 4)
        {
            pext = pwszSrc + wcslen(pwszSrc) - 4;
            if(StrCmpIW(pext, L".asf") == 0)
            {
                m_bIsAsfFile = true;
            }

            if (StrCmpNIW(pwszSrc, L"mms:", 4) == 0)
            {
                m_bMMSProtocol = true;
            }
        }
    }

    return m_bIsAsfFile;
}


//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetRepeat
//************************************************************

HRESULT
CContainerObj::SetRepeat(long lRepeat)
{
    TraceTag((tagContainerObj, "CContainerObj::SetRepeat (%d)", lRepeat));
    HRESULT hr;
    
    if (lRepeat == 1)
       return S_OK;
    
    hr = THR(m_pProxyPlayer->put_repeat(lRepeat));
    if (FAILED(hr))
    {    
    }
    return hr;
} // SetRepeat

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipBegin
//************************************************************

HRESULT
CContainerObj::clipBegin(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipBegin"));
    HRESULT hr = S_OK;
    CComVariant vClip = var;
    
    if (var.vt == VT_EMPTY)
    {
        goto done;
    }

    if (vClip.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&vClip, &vClip, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }
            
    hr  = THR(m_pProxyPlayer->clipBegin(vClip));
    if (FAILED(hr))
    {    
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
} // ClipBegin

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipEnd
//************************************************************

HRESULT
CContainerObj::clipEnd(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipEnd"));
    HRESULT hr = S_OK;


    CComVariant vClip = var;
    
    if (var.vt == VT_EMPTY)
    {
        goto done;
    }

    if (vClip.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&vClip, &vClip, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }
            
    hr  = m_pProxyPlayer->clipEnd(vClip);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::clipEnd - clipEnd() failed"));
    }

    hr = S_OK;
  done:
    return hr;

} // ClipEnd

//************************************************************
// Author:          twillie
// Created:         10/26/98
// Abstract:        GetControlDispatch
//************************************************************

HRESULT
CContainerObj::GetControlDispatch(IDispatch **ppDisp)
{
    HRESULT hr;
    TraceTag((tagContainerObj, "CContainerObj::GetControlDispatch"));

    if(!m_pProxyPlayer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CMPContainerSite::GetControlDispatch - QI failed for IDispatch"));
    }
done:
    return hr;
} // GetControlDispatch

void 
CContainerObj::SetMediaInfo(CPlayItem *pPlayItem)
{
    HRESULT hr;
    LPWSTR pwzStr = NULL;

    if (pPlayItem == NULL)
    {
        goto done;
    }

    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipTitle));
    if (hr == S_OK)
    {
        pPlayItem->PutTitle(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipAuthor));
    if (hr == S_OK)
    {
        pPlayItem->PutAuthor(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipCopyright));
    if (hr == S_OK)
    {
        pPlayItem->PutCopyright(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipRating));
    if (hr == S_OK)
    {
        pPlayItem->PutRating(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipDescription));
    if (hr == S_OK)
    {
        pPlayItem->PutAbstract(pwzStr);
        delete [] pwzStr;
    }
    hr = THR(GetMediaPlayerInfo(&pwzStr, mpClipFilename));
    if (hr == S_OK)
    {
        // 105410: do the best we can when no clip filename is available
        if (NULL == pwzStr)
        {
            IGNORE_HR(GetSourceLink(&pwzStr));
        }

        pPlayItem->PutSrc(pwzStr);
        delete [] pwzStr;
    }
  done:

    return;
}

HRESULT
CContainerObj::GetSourceLink(LPWSTR *pwstr)
{
    CComPtr<IDispatch>  pdisp;
    HRESULT             hr = E_FAIL;
    CComVariant         svarOut;
      
    *pwstr = NULL;
    
    hr = GetControlDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::GetProperty(pdisp, L"SourceLink", &svarOut));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::VariantChangeTypeEx(&svarOut, &svarOut, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        goto done;
    }

    *pwstr = CopyString(V_BSTR(&svarOut));

    hr = S_OK;
  done:
    return hr;
}


HRESULT
CContainerObj::GetMediaPlayerInfo(LPWSTR *pwstr,  int mpInfoToReceive)
{
    HRESULT             hr = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName = L"GetMediaInfoString";
    CComVariant         varResult;
    VARIANT             rgvarg[1];

    *pwstr = NULL;
    
    hr = GetControlDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    rgvarg[0].vt    = VT_I4;
    rgvarg[0].lVal  = mpInfoToReceive;

    DISPPARAMS dp;
    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if((*varResult.bstrVal) != NULL)
    {
        *pwstr = CopyString(V_BSTR(&varResult));
    }
    
    hr = S_OK;
  done:
    return hr;
} 


bool 
CContainerObj::UsingPlaylist()
{
    if (!m_pPlayer)
    {
        return false;
    }

    if(NULL == m_pPlayer->GetPlayList())
    {
        return false;
    }

    return (m_pPlayer->GetPlayList()->GetLength() > 1);
}

//sets the duration of the currently playing track in the playlist
void  
CContainerObj::SetDuration()
{
    double mediaLength;
    HRESULT hr;
    double duration = 0;
    CPlayList * pPlayList = NULL;
    CPlayItem * pPlayItem = NULL;
    
    if (m_pPlayer == NULL)
    {
        goto done;
    }
    
    pPlayList = m_pPlayer->GetPlayList();
    pPlayItem = pPlayList->GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        goto done;
    }
    
    duration = pPlayItem->GetDur();

    //if it is not set, then query the media player for it.
    if (duration == valueNotSet)
    {
        hr = GetCurrClipLength(mediaLength);
        if(FAILED(hr))
        {
            goto done;
        }   

        pPlayItem->PutDur(mediaLength);
    }

  done:
    return;
}

#define DISPID_DURATION 1003

#define DISPID_ISDURATIONVALID 1059
#define DISPID_CANSEEK 1012
#define DISPID_CANSEEKTOMARKERS 1047
#define DISPID_ISBROADCAST 1058
#define DISPID_BUFFERINGPROGRESS 1080
#define DISPID_BUFFERINGTIME 1070
#define DISPID_BUFFERINGCOUNT 1043

HRESULT
CContainerObj::BufferingTime(double &dblBuffTime)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vBuffTime;
    
    if (!m_pProxyPlayer)
    {
        dblBuffTime = 0.0;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_BUFFERINGTIME,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vBuffTime, NULL, NULL);
    if (FAILED(hr))
    {
        dblBuffTime = 0.0;
        goto done;
    }

    if(vBuffTime.vt != VT_R8)
    {
        hr = VariantChangeTypeEx(&vBuffTime, &vBuffTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R8);
        if(FAILED(hr))
        {
            dblBuffTime = 0;
            goto done;
        }
    }

    dblBuffTime = vBuffTime.dblVal;

    hr = S_OK;
  done:
    return hr;

}

HRESULT
CContainerObj::BufferingProgress(double &dblBuffTime)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vBuffTime;
    
    if (!m_pProxyPlayer)
    {
        dblBuffTime = 0.0;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_BUFFERINGPROGRESS,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vBuffTime, NULL, NULL);
    if (FAILED(hr))
    {
        dblBuffTime = 0.0;
        goto done;
    }

    if(vBuffTime.vt != VT_I4)
    {
        hr = VariantChangeTypeEx(&vBuffTime, &vBuffTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if(FAILED(hr))
        {
            dblBuffTime = 0;
            goto done;
        }
    }

    dblBuffTime = vBuffTime.lVal;

    hr = S_OK;
  done:
    return hr;

}


HRESULT
CContainerObj::BufferingCount(long &lBuffCount)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vBuffTime;
    
    if (!m_pProxyPlayer)
    {
        lBuffCount = 0;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_BUFFERINGCOUNT,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vBuffTime, NULL, NULL);
    if (FAILED(hr))
    {
        lBuffCount;
        goto done;
    }

    if(vBuffTime.vt != VT_I4)
    {
        hr = VariantChangeTypeEx(&vBuffTime, &vBuffTime, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if(FAILED(hr))
        {
            lBuffCount = 0;
            goto done;
        }
    }

    lBuffCount = vBuffTime.lVal;

    hr = S_OK;
  done:
    return hr;

}

HRESULT
CContainerObj::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    if(m_bIsAsfFile)
    {
        if (!m_bMMSProtocol || !UsingWMP()) //if this is not the WMP or this is not the MMS:// protocol call canseek.
        {
            DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
            CComPtr<IDispatch> pdisp;
            CComVariant vIsValid;
            hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
            if (FAILED(hr))
            {
                fcanSeek = false;
                goto done;
            }

            hr = pdisp->Invoke(DISPID_CANSEEK,
                               IID_NULL,
                               LCID_SCRIPTING,
                               DISPATCH_PROPERTYGET,
                               &dispparamsNoArgs,
                               &vIsValid, NULL, NULL);
            if (FAILED(hr))
            {
                fcanSeek = false;
                goto done;
            }
            if (vIsValid.boolVal)
            {
                fcanSeek = true;
            }
            else
            {
                fcanSeek = false;
            }
        }
        else // if this is both the WMP and the MMS: protocol, canseek should return false.  The WMP does not 
        {    // correctly identify that it cannot seek asf files using this protocol.
            fcanSeek = false;
        }

        if(FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        fcanSeek = true;
    }
  done:
    return hr;

}

HRESULT
CContainerObj::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_CANSEEKTOMARKERS,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }

    if(vIsValid.vt != VT_BOOL)
    {
        bcanSeekToM = false; //I got wrong type.
        goto done;
    }

    if (vIsValid.boolVal == VARIANT_FALSE)
    {
        bcanSeekToM = false;
    }
    else
    {
        bcanSeekToM = true;
    }

    hr = S_OK;
  done:
    return hr;

}


HRESULT
CContainerObj::IsBroadcast(bool &bisBroadcast)
{
    HRESULT hr = S_OK;

    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;
    
    if (!m_pProxyPlayer)
    {
        bisBroadcast = false;
        goto done;
    }

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_ISBROADCAST,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        bisBroadcast = false;
        goto done;
    }

    if(vIsValid.vt != VT_BOOL)
    {
        bisBroadcast = false; //I got wrong type.
        goto done;
    }

    if (vIsValid.boolVal == VARIANT_FALSE)
    {
        bisBroadcast = false;
    }
    else
    {
        bisBroadcast = true;
    }

    hr = S_OK;
  done:
    return hr;

}

HRESULT
CContainerObj::HasMedia(bool &fhasMedia)
{
    // m_bFirstOnMediaReady is set to flase when the media has finished loading
    // and is ready to play.
    if(m_bFirstOnMediaReady)
    {
        fhasMedia = false;
    }
    else
    {
        fhasMedia = true;
    }
    return S_OK;
}

HRESULT
CContainerObj::Seek(double dblTime)
{
    HRESULT hr = S_OK;
    bool fcanSeek;
    double dblLength = HUGE_VAL;

    if (m_bFirstOnMediaReady)
    {
        // we haven't started yet, wait on the seek
        m_bSeekOnPlay = true;
        m_dblSeekTime = dblTime;
    }
    else if (m_pSite)
    {
        hr = CanSeek(fcanSeek);
        if(FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }

        if(fcanSeek)
        {
            //
            // ISSUE: dilipk: does this handle playlists? GetMediaLength returns infinite for playlists.
            //

            // hack to get WMP playing  if we have played in the element beyond the
            // natural duration of the media i.e. dur is set to a value greater than 
            // the media length. (dorinung)
            if(SUCCEEDED(m_pPlayer->GetEffectiveLength(dblLength)))
            {
                if((dblTime >= dblLength) && (m_pPlayer != NULL))
                {
                    m_pPlayer->SetHoldingFlag();
                    dblTime = dblLength;
                }
                if((dblTime < dblLength) && (m_pPlayer != NULL))
                {
                    m_pPlayer->ClearHoldingFlag();
                }
            }
            if (UsingWMP() && (dblTime >= dblLength))
            {
                SetPosition(dblLength);
            }
            else
            {
                IGNORE_HR(m_pProxyPlayer->put_CurrentTime(dblTime));
            }
        }
    }
done:
    return hr;
}

double
CContainerObj::GetCurrentTime()
{
    double dblTime = 0.0;
    
    if (m_pProxyPlayer)
    {
        double dblTemp = 0.0;
        HRESULT hr;
        hr = m_pProxyPlayer->get_CurrentTime(&dblTemp);
        if (SUCCEEDED(hr))
            dblTime = dblTemp;
    }
    return dblTime;
}


HRESULT
CContainerObj::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    if (!m_pSite)
    {
        hr = E_FAIL;
        goto done;
    }

    m_pSite->SetSize(prect);

done:
    return hr;
}

HRESULT
CContainerObj::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    if (!m_fUsingWMP)
    {
        return E_FAIL;
    }
    
    Assert(m_pSite);
    if (UsingPlaylist()) //if a playlist is being used then it is not possible to determine the length
    {
        dblLength = HUGE_VAL;
    }
    else
    {
        hr = GetCurrClipLength(dblLength);
    }
        
    return hr;
}


HRESULT
CContainerObj::GetCurrClipLength(double &dblLength)
{
    HRESULT hr = S_OK;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    CComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;

    hr = m_pProxyPlayer->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_ISDURATIONVALID,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!vIsValid.boolVal)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = pdisp->Invoke(DISPID_DURATION,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &_retVar, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = _retVar.ChangeType(VT_R8, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    dblLength = _retVar.dblVal;

    hr = S_OK;
  done:
    return hr;
}


HRESULT
CContainerObj::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;

    if (m_pSite)
    {
        *height = m_pSite->GetNaturalHeight();
        if (*height == 0)
        {
            *height = -1;
        }
    }
    else
    {
        *height = -1;
    }

    return hr;
}


HRESULT
CContainerObj::GetNaturalWidth(long *width)
{
    HRESULT hr = S_OK;

    if (m_pSite)
    {
        *width = m_pSite->GetNaturalWidth();
        if (*width == 0)
        {
            *width = -1;
        }
    }
    else
    {
        *width = -1;
    }

    return hr;
}

HRESULT 
CContainerObj::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;

    hr = THR(m_pSite->Save(pPropBag, fClearDirty, fSaveAllProperties));
    
    return hr;
}


void 
CContainerObj::ReadyStateNotify(LPWSTR szReadyState)
{
    if (StrCmpIW(szReadyState, L"OnLoad") == 0)
    {
        if (!m_fStarted && !m_fLoaded)
        {
            SetVisibility(false);

            if(m_bStartOnLoad == false)
            {
                m_bPauseOnPlay = true;
            }
            
            if (m_pSite)
            {   
                IGNORE_HR(m_pSite->Activate());
                IGNORE_HR(m_pProxyPlayer->begin());
            }

            if (m_pPlayer)
            {
                m_pPlayer->SetMute(VARIANT_TRUE);
            }
            m_fLoaded = true;
        }
    }
    else if (StrCmpIW(szReadyState, L"OnUnload") == 0)
    {
        if (m_pSite)
        {
            IGNORE_HR(m_pSite->Unload());
        }
    }

    return;
}

void
CContainerObj::UpdateNaturalDur(bool bUpdatePlaylist)
{
    HRESULT hr;

    double dblMediaLength;
    double dblClipStart;
    double dblClipEnd;

    if (!m_pPlayer)
    {
        goto done;
    }
    
    dblMediaLength = 0.0;
    dblClipStart = m_pPlayer->GetRealClipStart();
    dblClipEnd = m_pPlayer->GetRealClipEnd();

    if (dblClipStart < 0.0)
    {
        dblClipStart = 0.0;
    }

    // if this is not a playlist, attempt to set the natural duration
    if (dblClipEnd != valueNotSet &&
        dblClipEnd > dblClipStart)
    {
        dblMediaLength = dblClipEnd - dblClipStart;
    }
    else if (UsingPlaylist())
    {
        if (!bUpdatePlaylist)
        {
            goto done;
        }
        
        // Need to add a fudge factor since we cannot calc right now
        dblMediaLength = (m_pPlayer->GetElapsedTime() + 0.00001);
    }
    else
    {
        hr = THR(GetMediaLength(dblMediaLength));
        if (FAILED(hr))
        {
            goto done;
        }

        dblMediaLength -= dblClipStart;
    }

    if (dblMediaLength <= 0.0)
    {
        goto done;
    }
    
    m_pPlayer->PutNaturalDuration(dblMediaLength);

  done:
    return;
}

PlayerState
CContainerObj::GetState()
{
    PlayerState state;
    
    if (!m_fStarted)
    {
        if (m_bFirstOnMediaReady)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        state = PLAYER_STATE_ACTIVE;
    }

    return state;
}

HRESULT
CContainerObj::PutSrc(WCHAR *pwszSrc)
{
    HRESULT hr;
    
    if (m_pSite)
    {
        m_pSite->ClearSizeFlag();
    }

    if (m_pProxyPlayer)
    {
        hr = THR(m_pProxyPlayer->put_src(pwszSrc));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

IHTMLElement *
CContainerObj::GetElement()
{
    IHTMLElement * pRet = NULL;

    if (m_pPlayer)
    {
        pRet = m_pPlayer->GetElement();
    }

    return pRet;
}

IServiceProvider *
CContainerObj::GetServiceProvider()
{
    IServiceProvider * pRet = NULL;

    if (m_pPlayer)
    {
        pRet = m_pPlayer->GetServiceProvider();
    }

    return pRet;
}

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Invalidate(LPCRECT prc)
{
    HRESULT  hr;
    RECT     rc;
    RECT    *prcNew;

    // No need to forward call on if we are not started yet or if the element has detached.
    if ((!m_fStarted) || (NULL == m_pPlayer))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // since we have incapatible types due to const.  Take the time and repack it.
    if (prc == NULL)
    {
        prcNew = NULL;
    }
    else
    {
        ::CopyRect(&rc, prc);
        prcNew = &rc;
    }

    // m_pPlayer != is checked above.
    m_pPlayer->InvalidateElement(prcNew);   
    hr = S_OK;

done:
    return hr;
} // Invalidate

HRESULT
CContainerObj::GetContainerSize(LPRECT prcPos)
{
    HRESULT hr = E_FAIL;

    if (m_pPlayer)
    {
        hr = THR(GetPlayer()->GetPlayerSize(prcPos));
    }

    return hr;
}

HRESULT
CContainerObj::SetContainerSize(LPCRECT prcPos)
{
    HRESULT hr = E_FAIL;

    if (m_pPlayer)
    {
        hr = THR(GetPlayer()->SetPlayerSize(prcPos));
    }

    return hr;
}

HRESULT
CContainerObj::ProcessEvent(DISPID dispid,
                            long lCount, 
                            VARIANT varParams[])
{
    TraceTag((tagContainerObj, "CContainerObj::ProcessEvent(%lx)",this));

    HRESULT hr = S_OK;
    int itrackNr = 0;
    LPWSTR szParamNames[1] = {{ L"TrackError" }};
    VARIANT varParamsLocal[1];

    AddRef(); //to protect this object from being deleted during the event handling

    if (NULL == m_pPlayer)
    {
        hr = E_NOTIMPL;
        goto done;
    }

    switch (dispid)
    {
#define DISPID_WARNING                  3009
      case DISPID_WARNING:
        if(lCount != 3)
        {
            break;
        }
        if(varParams[2].vt != VT_I4)
        {
            break;
        }
        if(varParams[2].lVal != 2)
        {
            break;
        }
        if(varParams[1].vt != VT_I4)
        {
            break;
        }
        VariantInit(&varParamsLocal[0]);

        varParamsLocal[0].vt =  VT_I4;
        varParamsLocal[0].lVal = varParams[1].lVal;

        if(m_pPlayer)
        {
            m_pPlayer->FireEventNoErrorState(TE_ONMEDIAERROR, 1, szParamNames, varParamsLocal);
        }
        
        break;
//left in for future investigation dorinung.
#define DISPID_BUFFERING 3003
      case DISPID_BUFFERING:
        break;
      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
       
        if(m_pPlayer)
        {
            m_pPlayer->FireMediaEvent(PE_ONMEDIAERROR);
        }
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:

        SetMediaReadyFlag();
        if (m_pSite)
        {
            m_pSite->ClearAutosizeFlag();
        }
                
        //make the element visible here.
        if (m_setVisible)
        {
            SetVisibility(true);
        }

        if (m_bFirstOnMediaReady)
        {
            m_bFirstOnMediaReady = false;
                
            // This must happen before we set natural duration
            // since we detect playlist during this call
            
            if(m_pPlayer)
            {
                m_pPlayer->FireMediaEvent(PE_ONMEDIACOMPLETE);        
                m_pPlayer->ClearNaturalDuration();
            }
            UpdateNaturalDur(false);

            // if this is not a playlist, attempt to set the natural duration

            if (m_lActiveLoadedTrack != NOTRACKSELECTED)
            {
                if (m_pPlayer && m_pPlayer->GetPlayList())
                {
                    CComVariant vIndex(m_lActiveLoadedTrack);
                        
                    IGNORE_HR(m_pPlayer->GetPlayList()->put_activeTrack(vIndex));
                }

                m_lActiveLoadedTrack = NOTRACKSELECTED;
            }

            if (m_bStartOnLoad)
            {
                m_bStartOnLoad = false;
                Start();
            }

            if (m_bEndOnPlay)
            {
                m_pProxyPlayer->end();
                m_bEndOnPlay = false;
            }
            if (m_bPauseOnPlay || (m_pPlayer && m_pPlayer->IsParentPaused()))
            {
                THR(m_pProxyPlayer->pause());
                m_bPauseOnPlay = false;
            }

            if (m_bSeekOnPlay)
            {
                IGNORE_HR(Seek(m_dblSeekTime));
                if(m_pPlayer)
                {
                    m_pPlayer->InvalidateElement(NULL);
                }
                m_bSeekOnPlay = false;
            }

        }
        else
        {
            CPlayItem *pPlayItem = NULL;
                
            if (m_bPauseOnPlay)
            {
                hr = THR(m_pProxyPlayer->pause());
                if (FAILED(hr))
                {
                    TraceTag((tagError, "Pause failed"));
                }
                m_bPauseOnPlay = false;
            }

            if (m_pPlayer && m_pPlayer->GetPlayList())
            {
                //load the current info into the selected playitem.
                pPlayItem = m_pPlayer->GetPlayList()->GetActiveTrack();
                SetMediaInfo(pPlayItem);
            }

            if(m_pPlayer)
            {
                m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
            }
        }

        SetDuration();
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN:
        m_bActive = true;
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
        m_bActive = false;

        //need notification here.
        if(m_pPlayer)
        {
            m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
        }
        if (m_bFirstOnMediaReady || UsingPlaylist())
        {
            UpdateNaturalDur(true);
        }
            
        if(m_pPlayer != NULL)
        {
            m_pPlayer->SetHoldingFlag();
        }

        break;

#define DISPID_SCRIPTCOMMAND 3001
      case DISPID_SCRIPTCOMMAND:
        // HACKHACK
        // Pick off the script command from WMP and repackage the event as our own.
        // This allows triggers to work.  The real fix is to add another event on
        // TIMEMediaPlayerEvents.
        if (m_fUsingWMP && lCount == 2) 
        {
            static LPWSTR pNames[] = {L"Param", L"scType"};
            
            if(m_pPlayer)
            {
                hr = m_pPlayer->FireEvents(TE_ONSCRIPTCOMMAND, 
                                           lCount, 
                                           pNames, 
                                           varParams);
            }
        }
        break;
      default:
        hr = E_NOTIMPL;
        goto done;
    }

    hr = S_OK;
  done:

    Release(); //Release the addref done at the beginning of the function
    
    RRETURN(hr);
}

HRESULT
CContainerObj::GetExtendedControl(IDispatch **ppDisp)
{
    CHECK_RETURN_SET_NULL(ppDisp);

    return E_NOTIMPL;
}

HRESULT
CContainerObj::NegotiateSize(RECT &nativeSize,
                             RECT &finalSize,
                             bool &fIsNative)
{
    HRESULT hr = S_OK;
    bool fResetSize = false;

    if(UsingPlaylist())
    {
        fResetSize = true;
    }

    if (m_pPlayer)
    {
        hr = THR(m_pPlayer->NegotiateSize(nativeSize,
                                          finalSize,
                                          fIsNative, fResetSize));
    }

    return hr;
}

HRESULT 
CContainerObj::SetPosition(double dblLength)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDispatch;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName = L"CurrentPosition";
    CComVariant         varResult;
    VARIANT             rgvarg[1];
    DISPPARAMS dp;
    UINT puArgErr = 0;

    hr = GetControlDispatch(&pDispatch);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    VariantInit(&rgvarg[0]);
    rgvarg[0].vt    = VT_R8;
    rgvarg[0].dblVal = dblLength;

    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = pDispatch->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           &puArgErr);
    if (FAILED(hr))
    {
        goto done;
    }

  done:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\decibels.cpp ===
//--------------------------------------------------------------------------;
//
//  File: decibels.cpp
//
//  Copyright (c) 1995 - 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	SteveDav    plagiarised from Direct Sound
//
//--------------------------------------------------------------------------;

#include "headers.h"

#include "decibels.h"

//
// This table covers -96.4 dB to -0.1 dB in 0.1 dB units
//
const WORD tblDBTenthsToAmpFactor[] = {
    0x0000, // (-964/10)dB = 0.000015 * amplitude
    0x0001, // (-963/10)dB = 0.000015 * amplitude
    0x0001, // (-962/10)dB = 0.000015 * amplitude
    0x0001, // (-961/10)dB = 0.000016 * amplitude
    0x0001, // (-960/10)dB = 0.000016 * amplitude
    0x0001, // (-959/10)dB = 0.000016 * amplitude
    0x0001, // (-958/10)dB = 0.000016 * amplitude
    0x0001, // (-957/10)dB = 0.000016 * amplitude
    0x0001, // (-956/10)dB = 0.000017 * amplitude
    0x0001, // (-955/10)dB = 0.000017 * amplitude
    0x0001, // (-954/10)dB = 0.000017 * amplitude
    0x0001, // (-953/10)dB = 0.000017 * amplitude
    0x0001, // (-952/10)dB = 0.000017 * amplitude
    0x0001, // (-951/10)dB = 0.000018 * amplitude
    0x0001, // (-950/10)dB = 0.000018 * amplitude
    0x0001, // (-949/10)dB = 0.000018 * amplitude
    0x0001, // (-948/10)dB = 0.000018 * amplitude
    0x0001, // (-947/10)dB = 0.000018 * amplitude
    0x0001, // (-946/10)dB = 0.000019 * amplitude
    0x0001, // (-945/10)dB = 0.000019 * amplitude
    0x0001, // (-944/10)dB = 0.000019 * amplitude
    0x0001, // (-943/10)dB = 0.000019 * amplitude
    0x0001, // (-942/10)dB = 0.000019 * amplitude
    0x0001, // (-941/10)dB = 0.000020 * amplitude
    0x0001, // (-940/10)dB = 0.000020 * amplitude
    0x0001, // (-939/10)dB = 0.000020 * amplitude
    0x0001, // (-938/10)dB = 0.000020 * amplitude
    0x0001, // (-937/10)dB = 0.000021 * amplitude
    0x0001, // (-936/10)dB = 0.000021 * amplitude
    0x0001, // (-935/10)dB = 0.000021 * amplitude
    0x0001, // (-934/10)dB = 0.000021 * amplitude
    0x0001, // (-933/10)dB = 0.000022 * amplitude
    0x0001, // (-932/10)dB = 0.000022 * amplitude
    0x0001, // (-931/10)dB = 0.000022 * amplitude
    0x0001, // (-930/10)dB = 0.000022 * amplitude
    0x0001, // (-929/10)dB = 0.000023 * amplitude
    0x0001, // (-928/10)dB = 0.000023 * amplitude
    0x0001, // (-927/10)dB = 0.000023 * amplitude
    0x0001, // (-926/10)dB = 0.000023 * amplitude
    0x0001, // (-925/10)dB = 0.000024 * amplitude
    0x0001, // (-924/10)dB = 0.000024 * amplitude
    0x0001, // (-923/10)dB = 0.000024 * amplitude
    0x0001, // (-922/10)dB = 0.000025 * amplitude
    0x0001, // (-921/10)dB = 0.000025 * amplitude
    0x0001, // (-920/10)dB = 0.000025 * amplitude
    0x0001, // (-919/10)dB = 0.000025 * amplitude
    0x0001, // (-918/10)dB = 0.000026 * amplitude
    0x0001, // (-917/10)dB = 0.000026 * amplitude
    0x0001, // (-916/10)dB = 0.000026 * amplitude
    0x0001, // (-915/10)dB = 0.000027 * amplitude
    0x0001, // (-914/10)dB = 0.000027 * amplitude
    0x0001, // (-913/10)dB = 0.000027 * amplitude
    0x0001, // (-912/10)dB = 0.000028 * amplitude
    0x0001, // (-911/10)dB = 0.000028 * amplitude
    0x0001, // (-910/10)dB = 0.000028 * amplitude
    0x0001, // (-909/10)dB = 0.000029 * amplitude
    0x0001, // (-908/10)dB = 0.000029 * amplitude
    0x0001, // (-907/10)dB = 0.000029 * amplitude
    0x0001, // (-906/10)dB = 0.000030 * amplitude
    0x0001, // (-905/10)dB = 0.000030 * amplitude
    0x0001, // (-904/10)dB = 0.000030 * amplitude
    0x0002, // (-903/10)dB = 0.000031 * amplitude
    0x0002, // (-902/10)dB = 0.000031 * amplitude
    0x0002, // (-901/10)dB = 0.000031 * amplitude
    0x0002, // (-900/10)dB = 0.000032 * amplitude
    0x0002, // (-899/10)dB = 0.000032 * amplitude
    0x0002, // (-898/10)dB = 0.000032 * amplitude
    0x0002, // (-897/10)dB = 0.000033 * amplitude
    0x0002, // (-896/10)dB = 0.000033 * amplitude
    0x0002, // (-895/10)dB = 0.000033 * amplitude
    0x0002, // (-894/10)dB = 0.000034 * amplitude
    0x0002, // (-893/10)dB = 0.000034 * amplitude
    0x0002, // (-892/10)dB = 0.000035 * amplitude
    0x0002, // (-891/10)dB = 0.000035 * amplitude
    0x0002, // (-890/10)dB = 0.000035 * amplitude
    0x0002, // (-889/10)dB = 0.000036 * amplitude
    0x0002, // (-888/10)dB = 0.000036 * amplitude
    0x0002, // (-887/10)dB = 0.000037 * amplitude
    0x0002, // (-886/10)dB = 0.000037 * amplitude
    0x0002, // (-885/10)dB = 0.000038 * amplitude
    0x0002, // (-884/10)dB = 0.000038 * amplitude
    0x0002, // (-883/10)dB = 0.000038 * amplitude
    0x0002, // (-882/10)dB = 0.000039 * amplitude
    0x0002, // (-881/10)dB = 0.000039 * amplitude
    0x0002, // (-880/10)dB = 0.000040 * amplitude
    0x0002, // (-879/10)dB = 0.000040 * amplitude
    0x0002, // (-878/10)dB = 0.000041 * amplitude
    0x0002, // (-877/10)dB = 0.000041 * amplitude
    0x0002, // (-876/10)dB = 0.000042 * amplitude
    0x0002, // (-875/10)dB = 0.000042 * amplitude
    0x0002, // (-874/10)dB = 0.000043 * amplitude
    0x0002, // (-873/10)dB = 0.000043 * amplitude
    0x0002, // (-872/10)dB = 0.000044 * amplitude
    0x0002, // (-871/10)dB = 0.000044 * amplitude
    0x0002, // (-870/10)dB = 0.000045 * amplitude
    0x0002, // (-869/10)dB = 0.000045 * amplitude
    0x0002, // (-868/10)dB = 0.000046 * amplitude
    0x0003, // (-867/10)dB = 0.000046 * amplitude
    0x0003, // (-866/10)dB = 0.000047 * amplitude
    0x0003, // (-865/10)dB = 0.000047 * amplitude
    0x0003, // (-864/10)dB = 0.000048 * amplitude
    0x0003, // (-863/10)dB = 0.000048 * amplitude
    0x0003, // (-862/10)dB = 0.000049 * amplitude
    0x0003, // (-861/10)dB = 0.000050 * amplitude
    0x0003, // (-860/10)dB = 0.000050 * amplitude
    0x0003, // (-859/10)dB = 0.000051 * amplitude
    0x0003, // (-858/10)dB = 0.000051 * amplitude
    0x0003, // (-857/10)dB = 0.000052 * amplitude
    0x0003, // (-856/10)dB = 0.000052 * amplitude
    0x0003, // (-855/10)dB = 0.000053 * amplitude
    0x0003, // (-854/10)dB = 0.000054 * amplitude
    0x0003, // (-853/10)dB = 0.000054 * amplitude
    0x0003, // (-852/10)dB = 0.000055 * amplitude
    0x0003, // (-851/10)dB = 0.000056 * amplitude
    0x0003, // (-850/10)dB = 0.000056 * amplitude
    0x0003, // (-849/10)dB = 0.000057 * amplitude
    0x0003, // (-848/10)dB = 0.000058 * amplitude
    0x0003, // (-847/10)dB = 0.000058 * amplitude
    0x0003, // (-846/10)dB = 0.000059 * amplitude
    0x0003, // (-845/10)dB = 0.000060 * amplitude
    0x0003, // (-844/10)dB = 0.000060 * amplitude
    0x0003, // (-843/10)dB = 0.000061 * amplitude
    0x0004, // (-842/10)dB = 0.000062 * amplitude
    0x0004, // (-841/10)dB = 0.000062 * amplitude
    0x0004, // (-840/10)dB = 0.000063 * amplitude
    0x0004, // (-839/10)dB = 0.000064 * amplitude
    0x0004, // (-838/10)dB = 0.000065 * amplitude
    0x0004, // (-837/10)dB = 0.000065 * amplitude
    0x0004, // (-836/10)dB = 0.000066 * amplitude
    0x0004, // (-835/10)dB = 0.000067 * amplitude
    0x0004, // (-834/10)dB = 0.000068 * amplitude
    0x0004, // (-833/10)dB = 0.000068 * amplitude
    0x0004, // (-832/10)dB = 0.000069 * amplitude
    0x0004, // (-831/10)dB = 0.000070 * amplitude
    0x0004, // (-830/10)dB = 0.000071 * amplitude
    0x0004, // (-829/10)dB = 0.000072 * amplitude
    0x0004, // (-828/10)dB = 0.000072 * amplitude
    0x0004, // (-827/10)dB = 0.000073 * amplitude
    0x0004, // (-826/10)dB = 0.000074 * amplitude
    0x0004, // (-825/10)dB = 0.000075 * amplitude
    0x0004, // (-824/10)dB = 0.000076 * amplitude
    0x0005, // (-823/10)dB = 0.000077 * amplitude
    0x0005, // (-822/10)dB = 0.000078 * amplitude
    0x0005, // (-821/10)dB = 0.000079 * amplitude
    0x0005, // (-820/10)dB = 0.000079 * amplitude
    0x0005, // (-819/10)dB = 0.000080 * amplitude
    0x0005, // (-818/10)dB = 0.000081 * amplitude
    0x0005, // (-817/10)dB = 0.000082 * amplitude
    0x0005, // (-816/10)dB = 0.000083 * amplitude
    0x0005, // (-815/10)dB = 0.000084 * amplitude
    0x0005, // (-814/10)dB = 0.000085 * amplitude
    0x0005, // (-813/10)dB = 0.000086 * amplitude
    0x0005, // (-812/10)dB = 0.000087 * amplitude
    0x0005, // (-811/10)dB = 0.000088 * amplitude
    0x0005, // (-810/10)dB = 0.000089 * amplitude
    0x0005, // (-809/10)dB = 0.000090 * amplitude
    0x0005, // (-808/10)dB = 0.000091 * amplitude
    0x0006, // (-807/10)dB = 0.000092 * amplitude
    0x0006, // (-806/10)dB = 0.000093 * amplitude
    0x0006, // (-805/10)dB = 0.000094 * amplitude
    0x0006, // (-804/10)dB = 0.000095 * amplitude
    0x0006, // (-803/10)dB = 0.000097 * amplitude
    0x0006, // (-802/10)dB = 0.000098 * amplitude
    0x0006, // (-801/10)dB = 0.000099 * amplitude
    0x0006, // (-800/10)dB = 0.000100 * amplitude
    0x0006, // (-799/10)dB = 0.000101 * amplitude
    0x0006, // (-798/10)dB = 0.000102 * amplitude
    0x0006, // (-797/10)dB = 0.000104 * amplitude
    0x0006, // (-796/10)dB = 0.000105 * amplitude
    0x0006, // (-795/10)dB = 0.000106 * amplitude
    0x0007, // (-794/10)dB = 0.000107 * amplitude
    0x0007, // (-793/10)dB = 0.000108 * amplitude
    0x0007, // (-792/10)dB = 0.000110 * amplitude
    0x0007, // (-791/10)dB = 0.000111 * amplitude
    0x0007, // (-790/10)dB = 0.000112 * amplitude
    0x0007, // (-789/10)dB = 0.000114 * amplitude
    0x0007, // (-788/10)dB = 0.000115 * amplitude
    0x0007, // (-787/10)dB = 0.000116 * amplitude
    0x0007, // (-786/10)dB = 0.000117 * amplitude
    0x0007, // (-785/10)dB = 0.000119 * amplitude
    0x0007, // (-784/10)dB = 0.000120 * amplitude
    0x0007, // (-783/10)dB = 0.000122 * amplitude
    0x0008, // (-782/10)dB = 0.000123 * amplitude
    0x0008, // (-781/10)dB = 0.000124 * amplitude
    0x0008, // (-780/10)dB = 0.000126 * amplitude
    0x0008, // (-779/10)dB = 0.000127 * amplitude
    0x0008, // (-778/10)dB = 0.000129 * amplitude
    0x0008, // (-777/10)dB = 0.000130 * amplitude
    0x0008, // (-776/10)dB = 0.000132 * amplitude
    0x0008, // (-775/10)dB = 0.000133 * amplitude
    0x0008, // (-774/10)dB = 0.000135 * amplitude
    0x0008, // (-773/10)dB = 0.000136 * amplitude
    0x0009, // (-772/10)dB = 0.000138 * amplitude
    0x0009, // (-771/10)dB = 0.000140 * amplitude
    0x0009, // (-770/10)dB = 0.000141 * amplitude
    0x0009, // (-769/10)dB = 0.000143 * amplitude
    0x0009, // (-768/10)dB = 0.000145 * amplitude
    0x0009, // (-767/10)dB = 0.000146 * amplitude
    0x0009, // (-766/10)dB = 0.000148 * amplitude
    0x0009, // (-765/10)dB = 0.000150 * amplitude
    0x0009, // (-764/10)dB = 0.000151 * amplitude
    0x000A, // (-763/10)dB = 0.000153 * amplitude
    0x000A, // (-762/10)dB = 0.000155 * amplitude
    0x000A, // (-761/10)dB = 0.000157 * amplitude
    0x000A, // (-760/10)dB = 0.000158 * amplitude
    0x000A, // (-759/10)dB = 0.000160 * amplitude
    0x000A, // (-758/10)dB = 0.000162 * amplitude
    0x000A, // (-757/10)dB = 0.000164 * amplitude
    0x000A, // (-756/10)dB = 0.000166 * amplitude
    0x000B, // (-755/10)dB = 0.000168 * amplitude
    0x000B, // (-754/10)dB = 0.000170 * amplitude
    0x000B, // (-753/10)dB = 0.000172 * amplitude
    0x000B, // (-752/10)dB = 0.000174 * amplitude
    0x000B, // (-751/10)dB = 0.000176 * amplitude
    0x000B, // (-750/10)dB = 0.000178 * amplitude
    0x000B, // (-749/10)dB = 0.000180 * amplitude
    0x000B, // (-748/10)dB = 0.000182 * amplitude
    0x000C, // (-747/10)dB = 0.000184 * amplitude
    0x000C, // (-746/10)dB = 0.000186 * amplitude
    0x000C, // (-745/10)dB = 0.000188 * amplitude
    0x000C, // (-744/10)dB = 0.000191 * amplitude
    0x000C, // (-743/10)dB = 0.000193 * amplitude
    0x000C, // (-742/10)dB = 0.000195 * amplitude
    0x000C, // (-741/10)dB = 0.000197 * amplitude
    0x000D, // (-740/10)dB = 0.000200 * amplitude
    0x000D, // (-739/10)dB = 0.000202 * amplitude
    0x000D, // (-738/10)dB = 0.000204 * amplitude
    0x000D, // (-737/10)dB = 0.000207 * amplitude
    0x000D, // (-736/10)dB = 0.000209 * amplitude
    0x000D, // (-735/10)dB = 0.000211 * amplitude
    0x000E, // (-734/10)dB = 0.000214 * amplitude
    0x000E, // (-733/10)dB = 0.000216 * amplitude
    0x000E, // (-732/10)dB = 0.000219 * amplitude
    0x000E, // (-731/10)dB = 0.000221 * amplitude
    0x000E, // (-730/10)dB = 0.000224 * amplitude
    0x000E, // (-729/10)dB = 0.000226 * amplitude
    0x000F, // (-728/10)dB = 0.000229 * amplitude
    0x000F, // (-727/10)dB = 0.000232 * amplitude
    0x000F, // (-726/10)dB = 0.000234 * amplitude
    0x000F, // (-725/10)dB = 0.000237 * amplitude
    0x000F, // (-724/10)dB = 0.000240 * amplitude
    0x000F, // (-723/10)dB = 0.000243 * amplitude
    0x0010, // (-722/10)dB = 0.000245 * amplitude
    0x0010, // (-721/10)dB = 0.000248 * amplitude
    0x0010, // (-720/10)dB = 0.000251 * amplitude
    0x0010, // (-719/10)dB = 0.000254 * amplitude
    0x0010, // (-718/10)dB = 0.000257 * amplitude
    0x0011, // (-717/10)dB = 0.000260 * amplitude
    0x0011, // (-716/10)dB = 0.000263 * amplitude
    0x0011, // (-715/10)dB = 0.000266 * amplitude
    0x0011, // (-714/10)dB = 0.000269 * amplitude
    0x0011, // (-713/10)dB = 0.000272 * amplitude
    0x0012, // (-712/10)dB = 0.000275 * amplitude
    0x0012, // (-711/10)dB = 0.000279 * amplitude
    0x0012, // (-710/10)dB = 0.000282 * amplitude
    0x0012, // (-709/10)dB = 0.000285 * amplitude
    0x0012, // (-708/10)dB = 0.000288 * amplitude
    0x0013, // (-707/10)dB = 0.000292 * amplitude
    0x0013, // (-706/10)dB = 0.000295 * amplitude
    0x0013, // (-705/10)dB = 0.000299 * amplitude
    0x0013, // (-704/10)dB = 0.000302 * amplitude
    0x0014, // (-703/10)dB = 0.000305 * amplitude
    0x0014, // (-702/10)dB = 0.000309 * amplitude
    0x0014, // (-701/10)dB = 0.000313 * amplitude
    0x0014, // (-700/10)dB = 0.000316 * amplitude
    0x0014, // (-699/10)dB = 0.000320 * amplitude
    0x0015, // (-698/10)dB = 0.000324 * amplitude
    0x0015, // (-697/10)dB = 0.000327 * amplitude
    0x0015, // (-696/10)dB = 0.000331 * amplitude
    0x0015, // (-695/10)dB = 0.000335 * amplitude
    0x0016, // (-694/10)dB = 0.000339 * amplitude
    0x0016, // (-693/10)dB = 0.000343 * amplitude
    0x0016, // (-692/10)dB = 0.000347 * amplitude
    0x0016, // (-691/10)dB = 0.000351 * amplitude
    0x0017, // (-690/10)dB = 0.000355 * amplitude
    0x0017, // (-689/10)dB = 0.000359 * amplitude
    0x0017, // (-688/10)dB = 0.000363 * amplitude
    0x0018, // (-687/10)dB = 0.000367 * amplitude
    0x0018, // (-686/10)dB = 0.000372 * amplitude
    0x0018, // (-685/10)dB = 0.000376 * amplitude
    0x0018, // (-684/10)dB = 0.000380 * amplitude
    0x0019, // (-683/10)dB = 0.000385 * amplitude
    0x0019, // (-682/10)dB = 0.000389 * amplitude
    0x0019, // (-681/10)dB = 0.000394 * amplitude
    0x001A, // (-680/10)dB = 0.000398 * amplitude
    0x001A, // (-679/10)dB = 0.000403 * amplitude
    0x001A, // (-678/10)dB = 0.000407 * amplitude
    0x001B, // (-677/10)dB = 0.000412 * amplitude
    0x001B, // (-676/10)dB = 0.000417 * amplitude
    0x001B, // (-675/10)dB = 0.000422 * amplitude
    0x001B, // (-674/10)dB = 0.000427 * amplitude
    0x001C, // (-673/10)dB = 0.000432 * amplitude
    0x001C, // (-672/10)dB = 0.000437 * amplitude
    0x001C, // (-671/10)dB = 0.000442 * amplitude
    0x001D, // (-670/10)dB = 0.000447 * amplitude
    0x001D, // (-669/10)dB = 0.000452 * amplitude
    0x001D, // (-668/10)dB = 0.000457 * amplitude
    0x001E, // (-667/10)dB = 0.000462 * amplitude
    0x001E, // (-666/10)dB = 0.000468 * amplitude
    0x001F, // (-665/10)dB = 0.000473 * amplitude
    0x001F, // (-664/10)dB = 0.000479 * amplitude
    0x001F, // (-663/10)dB = 0.000484 * amplitude
    0x0020, // (-662/10)dB = 0.000490 * amplitude
    0x0020, // (-661/10)dB = 0.000495 * amplitude
    0x0020, // (-660/10)dB = 0.000501 * amplitude
    0x0021, // (-659/10)dB = 0.000507 * amplitude
    0x0021, // (-658/10)dB = 0.000513 * amplitude
    0x0022, // (-657/10)dB = 0.000519 * amplitude
    0x0022, // (-656/10)dB = 0.000525 * amplitude
    0x0022, // (-655/10)dB = 0.000531 * amplitude
    0x0023, // (-654/10)dB = 0.000537 * amplitude
    0x0023, // (-653/10)dB = 0.000543 * amplitude
    0x0024, // (-652/10)dB = 0.000550 * amplitude
    0x0024, // (-651/10)dB = 0.000556 * amplitude
    0x0024, // (-650/10)dB = 0.000562 * amplitude
    0x0025, // (-649/10)dB = 0.000569 * amplitude
    0x0025, // (-648/10)dB = 0.000575 * amplitude
    0x0026, // (-647/10)dB = 0.000582 * amplitude
    0x0026, // (-646/10)dB = 0.000589 * amplitude
    0x0027, // (-645/10)dB = 0.000596 * amplitude
    0x0027, // (-644/10)dB = 0.000603 * amplitude
    0x0027, // (-643/10)dB = 0.000610 * amplitude
    0x0028, // (-642/10)dB = 0.000617 * amplitude
    0x0028, // (-641/10)dB = 0.000624 * amplitude
    0x0029, // (-640/10)dB = 0.000631 * amplitude
    0x0029, // (-639/10)dB = 0.000638 * amplitude
    0x002A, // (-638/10)dB = 0.000646 * amplitude
    0x002A, // (-637/10)dB = 0.000653 * amplitude
    0x002B, // (-636/10)dB = 0.000661 * amplitude
    0x002B, // (-635/10)dB = 0.000668 * amplitude
    0x002C, // (-634/10)dB = 0.000676 * amplitude
    0x002C, // (-633/10)dB = 0.000684 * amplitude
    0x002D, // (-632/10)dB = 0.000692 * amplitude
    0x002D, // (-631/10)dB = 0.000700 * amplitude
    0x002E, // (-630/10)dB = 0.000708 * amplitude
    0x002E, // (-629/10)dB = 0.000716 * amplitude
    0x002F, // (-628/10)dB = 0.000724 * amplitude
    0x0030, // (-627/10)dB = 0.000733 * amplitude
    0x0030, // (-626/10)dB = 0.000741 * amplitude
    0x0031, // (-625/10)dB = 0.000750 * amplitude
    0x0031, // (-624/10)dB = 0.000759 * amplitude
    0x0032, // (-623/10)dB = 0.000767 * amplitude
    0x0032, // (-622/10)dB = 0.000776 * amplitude
    0x0033, // (-621/10)dB = 0.000785 * amplitude
    0x0034, // (-620/10)dB = 0.000794 * amplitude
    0x0034, // (-619/10)dB = 0.000804 * amplitude
    0x0035, // (-618/10)dB = 0.000813 * amplitude
    0x0035, // (-617/10)dB = 0.000822 * amplitude
    0x0036, // (-616/10)dB = 0.000832 * amplitude
    0x0037, // (-615/10)dB = 0.000841 * amplitude
    0x0037, // (-614/10)dB = 0.000851 * amplitude
    0x0038, // (-613/10)dB = 0.000861 * amplitude
    0x0039, // (-612/10)dB = 0.000871 * amplitude
    0x0039, // (-611/10)dB = 0.000881 * amplitude
    0x003A, // (-610/10)dB = 0.000891 * amplitude
    0x003B, // (-609/10)dB = 0.000902 * amplitude
    0x003B, // (-608/10)dB = 0.000912 * amplitude
    0x003C, // (-607/10)dB = 0.000923 * amplitude
    0x003D, // (-606/10)dB = 0.000933 * amplitude
    0x003D, // (-605/10)dB = 0.000944 * amplitude
    0x003E, // (-604/10)dB = 0.000955 * amplitude
    0x003F, // (-603/10)dB = 0.000966 * amplitude
    0x0040, // (-602/10)dB = 0.000977 * amplitude
    0x0040, // (-601/10)dB = 0.000989 * amplitude
    0x0041, // (-600/10)dB = 0.001000 * amplitude
    0x0042, // (-599/10)dB = 0.001012 * amplitude
    0x0043, // (-598/10)dB = 0.001023 * amplitude
    0x0043, // (-597/10)dB = 0.001035 * amplitude
    0x0044, // (-596/10)dB = 0.001047 * amplitude
    0x0045, // (-595/10)dB = 0.001059 * amplitude
    0x0046, // (-594/10)dB = 0.001072 * amplitude
    0x0047, // (-593/10)dB = 0.001084 * amplitude
    0x0047, // (-592/10)dB = 0.001096 * amplitude
    0x0048, // (-591/10)dB = 0.001109 * amplitude
    0x0049, // (-590/10)dB = 0.001122 * amplitude
    0x004A, // (-589/10)dB = 0.001135 * amplitude
    0x004B, // (-588/10)dB = 0.001148 * amplitude
    0x004C, // (-587/10)dB = 0.001161 * amplitude
    0x004C, // (-586/10)dB = 0.001175 * amplitude
    0x004D, // (-585/10)dB = 0.001189 * amplitude
    0x004E, // (-584/10)dB = 0.001202 * amplitude
    0x004F, // (-583/10)dB = 0.001216 * amplitude
    0x0050, // (-582/10)dB = 0.001230 * amplitude
    0x0051, // (-581/10)dB = 0.001245 * amplitude
    0x0052, // (-580/10)dB = 0.001259 * amplitude
    0x0053, // (-579/10)dB = 0.001274 * amplitude
    0x0054, // (-578/10)dB = 0.001288 * amplitude
    0x0055, // (-577/10)dB = 0.001303 * amplitude
    0x0056, // (-576/10)dB = 0.001318 * amplitude
    0x0057, // (-575/10)dB = 0.001334 * amplitude
    0x0058, // (-574/10)dB = 0.001349 * amplitude
    0x0059, // (-573/10)dB = 0.001365 * amplitude
    0x005A, // (-572/10)dB = 0.001380 * amplitude
    0x005B, // (-571/10)dB = 0.001396 * amplitude
    0x005C, // (-570/10)dB = 0.001413 * amplitude
    0x005D, // (-569/10)dB = 0.001429 * amplitude
    0x005E, // (-568/10)dB = 0.001445 * amplitude
    0x005F, // (-567/10)dB = 0.001462 * amplitude
    0x0060, // (-566/10)dB = 0.001479 * amplitude
    0x0062, // (-565/10)dB = 0.001496 * amplitude
    0x0063, // (-564/10)dB = 0.001514 * amplitude
    0x0064, // (-563/10)dB = 0.001531 * amplitude
    0x0065, // (-562/10)dB = 0.001549 * amplitude
    0x0066, // (-561/10)dB = 0.001567 * amplitude
    0x0067, // (-560/10)dB = 0.001585 * amplitude
    0x0069, // (-559/10)dB = 0.001603 * amplitude
    0x006A, // (-558/10)dB = 0.001622 * amplitude
    0x006B, // (-557/10)dB = 0.001641 * amplitude
    0x006C, // (-556/10)dB = 0.001660 * amplitude
    0x006E, // (-555/10)dB = 0.001679 * amplitude
    0x006F, // (-554/10)dB = 0.001698 * amplitude
    0x0070, // (-553/10)dB = 0.001718 * amplitude
    0x0071, // (-552/10)dB = 0.001738 * amplitude
    0x0073, // (-551/10)dB = 0.001758 * amplitude
    0x0074, // (-550/10)dB = 0.001778 * amplitude
    0x0075, // (-549/10)dB = 0.001799 * amplitude
    0x0077, // (-548/10)dB = 0.001820 * amplitude
    0x0078, // (-547/10)dB = 0.001841 * amplitude
    0x007A, // (-546/10)dB = 0.001862 * amplitude
    0x007B, // (-545/10)dB = 0.001884 * amplitude
    0x007C, // (-544/10)dB = 0.001905 * amplitude
    0x007E, // (-543/10)dB = 0.001928 * amplitude
    0x007F, // (-542/10)dB = 0.001950 * amplitude
    0x0081, // (-541/10)dB = 0.001972 * amplitude
    0x0082, // (-540/10)dB = 0.001995 * amplitude
    0x0084, // (-539/10)dB = 0.002018 * amplitude
    0x0085, // (-538/10)dB = 0.002042 * amplitude
    0x0087, // (-537/10)dB = 0.002065 * amplitude
    0x0088, // (-536/10)dB = 0.002089 * amplitude
    0x008A, // (-535/10)dB = 0.002113 * amplitude
    0x008C, // (-534/10)dB = 0.002138 * amplitude
    0x008D, // (-533/10)dB = 0.002163 * amplitude
    0x008F, // (-532/10)dB = 0.002188 * amplitude
    0x0091, // (-531/10)dB = 0.002213 * amplitude
    0x0092, // (-530/10)dB = 0.002239 * amplitude
    0x0094, // (-529/10)dB = 0.002265 * amplitude
    0x0096, // (-528/10)dB = 0.002291 * amplitude
    0x0097, // (-527/10)dB = 0.002317 * amplitude
    0x0099, // (-526/10)dB = 0.002344 * amplitude
    0x009B, // (-525/10)dB = 0.002371 * amplitude
    0x009D, // (-524/10)dB = 0.002399 * amplitude
    0x009F, // (-523/10)dB = 0.002427 * amplitude
    0x00A0, // (-522/10)dB = 0.002455 * amplitude
    0x00A2, // (-521/10)dB = 0.002483 * amplitude
    0x00A4, // (-520/10)dB = 0.002512 * amplitude
    0x00A6, // (-519/10)dB = 0.002541 * amplitude
    0x00A8, // (-518/10)dB = 0.002570 * amplitude
    0x00AA, // (-517/10)dB = 0.002600 * amplitude
    0x00AC, // (-516/10)dB = 0.002630 * amplitude
    0x00AE, // (-515/10)dB = 0.002661 * amplitude
    0x00B0, // (-514/10)dB = 0.002692 * amplitude
    0x00B2, // (-513/10)dB = 0.002723 * amplitude
    0x00B4, // (-512/10)dB = 0.002754 * amplitude
    0x00B6, // (-511/10)dB = 0.002786 * amplitude
    0x00B8, // (-510/10)dB = 0.002818 * amplitude
    0x00BA, // (-509/10)dB = 0.002851 * amplitude
    0x00BD, // (-508/10)dB = 0.002884 * amplitude
    0x00BF, // (-507/10)dB = 0.002917 * amplitude
    0x00C1, // (-506/10)dB = 0.002951 * amplitude
    0x00C3, // (-505/10)dB = 0.002985 * amplitude
    0x00C5, // (-504/10)dB = 0.003020 * amplitude
    0x00C8, // (-503/10)dB = 0.003055 * amplitude
    0x00CA, // (-502/10)dB = 0.003090 * amplitude
    0x00CC, // (-501/10)dB = 0.003126 * amplitude
    0x00CF, // (-500/10)dB = 0.003162 * amplitude
    0x00D1, // (-499/10)dB = 0.003199 * amplitude
    0x00D4, // (-498/10)dB = 0.003236 * amplitude
    0x00D6, // (-497/10)dB = 0.003273 * amplitude
    0x00D9, // (-496/10)dB = 0.003311 * amplitude
    0x00DB, // (-495/10)dB = 0.003350 * amplitude
    0x00DE, // (-494/10)dB = 0.003388 * amplitude
    0x00E0, // (-493/10)dB = 0.003428 * amplitude
    0x00E3, // (-492/10)dB = 0.003467 * amplitude
    0x00E5, // (-491/10)dB = 0.003508 * amplitude
    0x00E8, // (-490/10)dB = 0.003548 * amplitude
    0x00EB, // (-489/10)dB = 0.003589 * amplitude
    0x00ED, // (-488/10)dB = 0.003631 * amplitude
    0x00F0, // (-487/10)dB = 0.003673 * amplitude
    0x00F3, // (-486/10)dB = 0.003715 * amplitude
    0x00F6, // (-485/10)dB = 0.003758 * amplitude
    0x00F9, // (-484/10)dB = 0.003802 * amplitude
    0x00FC, // (-483/10)dB = 0.003846 * amplitude
    0x00FE, // (-482/10)dB = 0.003890 * amplitude
    0x0101, // (-481/10)dB = 0.003936 * amplitude
    0x0104, // (-480/10)dB = 0.003981 * amplitude
    0x0107, // (-479/10)dB = 0.004027 * amplitude
    0x010A, // (-478/10)dB = 0.004074 * amplitude
    0x010E, // (-477/10)dB = 0.004121 * amplitude
    0x0111, // (-476/10)dB = 0.004169 * amplitude
    0x0114, // (-475/10)dB = 0.004217 * amplitude
    0x0117, // (-474/10)dB = 0.004266 * amplitude
    0x011A, // (-473/10)dB = 0.004315 * amplitude
    0x011E, // (-472/10)dB = 0.004365 * amplitude
    0x0121, // (-471/10)dB = 0.004416 * amplitude
    0x0124, // (-470/10)dB = 0.004467 * amplitude
    0x0128, // (-469/10)dB = 0.004519 * amplitude
    0x012B, // (-468/10)dB = 0.004571 * amplitude
    0x012F, // (-467/10)dB = 0.004624 * amplitude
    0x0132, // (-466/10)dB = 0.004677 * amplitude
    0x0136, // (-465/10)dB = 0.004732 * amplitude
    0x0139, // (-464/10)dB = 0.004786 * amplitude
    0x013D, // (-463/10)dB = 0.004842 * amplitude
    0x0140, // (-462/10)dB = 0.004898 * amplitude
    0x0144, // (-461/10)dB = 0.004955 * amplitude
    0x0148, // (-460/10)dB = 0.005012 * amplitude
    0x014C, // (-459/10)dB = 0.005070 * amplitude
    0x0150, // (-458/10)dB = 0.005129 * amplitude
    0x0154, // (-457/10)dB = 0.005188 * amplitude
    0x0157, // (-456/10)dB = 0.005248 * amplitude
    0x015B, // (-455/10)dB = 0.005309 * amplitude
    0x015F, // (-454/10)dB = 0.005370 * amplitude
    0x0164, // (-453/10)dB = 0.005433 * amplitude
    0x0168, // (-452/10)dB = 0.005495 * amplitude
    0x016C, // (-451/10)dB = 0.005559 * amplitude
    0x0170, // (-450/10)dB = 0.005623 * amplitude
    0x0174, // (-449/10)dB = 0.005689 * amplitude
    0x0179, // (-448/10)dB = 0.005754 * amplitude
    0x017D, // (-447/10)dB = 0.005821 * amplitude
    0x0181, // (-446/10)dB = 0.005888 * amplitude
    0x0186, // (-445/10)dB = 0.005957 * amplitude
    0x018A, // (-444/10)dB = 0.006026 * amplitude
    0x018F, // (-443/10)dB = 0.006095 * amplitude
    0x0194, // (-442/10)dB = 0.006166 * amplitude
    0x0198, // (-441/10)dB = 0.006237 * amplitude
    0x019D, // (-440/10)dB = 0.006310 * amplitude
    0x01A2, // (-439/10)dB = 0.006383 * amplitude
    0x01A7, // (-438/10)dB = 0.006457 * amplitude
    0x01AC, // (-437/10)dB = 0.006531 * amplitude
    0x01B0, // (-436/10)dB = 0.006607 * amplitude
    0x01B6, // (-435/10)dB = 0.006683 * amplitude
    0x01BB, // (-434/10)dB = 0.006761 * amplitude
    0x01C0, // (-433/10)dB = 0.006839 * amplitude
    0x01C5, // (-432/10)dB = 0.006918 * amplitude
    0x01CA, // (-431/10)dB = 0.006998 * amplitude
    0x01CF, // (-430/10)dB = 0.007079 * amplitude
    0x01D5, // (-429/10)dB = 0.007161 * amplitude
    0x01DA, // (-428/10)dB = 0.007244 * amplitude
    0x01E0, // (-427/10)dB = 0.007328 * amplitude
    0x01E5, // (-426/10)dB = 0.007413 * amplitude
    0x01EB, // (-425/10)dB = 0.007499 * amplitude
    0x01F1, // (-424/10)dB = 0.007586 * amplitude
    0x01F6, // (-423/10)dB = 0.007674 * amplitude
    0x01FC, // (-422/10)dB = 0.007762 * amplitude
    0x0202, // (-421/10)dB = 0.007852 * amplitude
    0x0208, // (-420/10)dB = 0.007943 * amplitude
    0x020E, // (-419/10)dB = 0.008035 * amplitude
    0x0214, // (-418/10)dB = 0.008128 * amplitude
    0x021A, // (-417/10)dB = 0.008222 * amplitude
    0x0221, // (-416/10)dB = 0.008318 * amplitude
    0x0227, // (-415/10)dB = 0.008414 * amplitude
    0x022D, // (-414/10)dB = 0.008511 * amplitude
    0x0234, // (-413/10)dB = 0.008610 * amplitude
    0x023A, // (-412/10)dB = 0.008710 * amplitude
    0x0241, // (-411/10)dB = 0.008810 * amplitude
    0x0248, // (-410/10)dB = 0.008913 * amplitude
    0x024E, // (-409/10)dB = 0.009016 * amplitude
    0x0255, // (-408/10)dB = 0.009120 * amplitude
    0x025C, // (-407/10)dB = 0.009226 * amplitude
    0x0263, // (-406/10)dB = 0.009333 * amplitude
    0x026A, // (-405/10)dB = 0.009441 * amplitude
    0x0271, // (-404/10)dB = 0.009550 * amplitude
    0x0279, // (-403/10)dB = 0.009661 * amplitude
    0x0280, // (-402/10)dB = 0.009772 * amplitude
    0x0287, // (-401/10)dB = 0.009886 * amplitude
    0x028F, // (-400/10)dB = 0.010000 * amplitude
    0x0296, // (-399/10)dB = 0.010116 * amplitude
    0x029E, // (-398/10)dB = 0.010233 * amplitude
    0x02A6, // (-397/10)dB = 0.010351 * amplitude
    0x02AE, // (-396/10)dB = 0.010471 * amplitude
    0x02B6, // (-395/10)dB = 0.010593 * amplitude
    0x02BE, // (-394/10)dB = 0.010715 * amplitude
    0x02C6, // (-393/10)dB = 0.010839 * amplitude
    0x02CE, // (-392/10)dB = 0.010965 * amplitude
    0x02D6, // (-391/10)dB = 0.011092 * amplitude
    0x02DF, // (-390/10)dB = 0.011220 * amplitude
    0x02E7, // (-389/10)dB = 0.011350 * amplitude
    0x02F0, // (-388/10)dB = 0.011482 * amplitude
    0x02F9, // (-387/10)dB = 0.011614 * amplitude
    0x0301, // (-386/10)dB = 0.011749 * amplitude
    0x030A, // (-385/10)dB = 0.011885 * amplitude
    0x0313, // (-384/10)dB = 0.012023 * amplitude
    0x031D, // (-383/10)dB = 0.012162 * amplitude
    0x0326, // (-382/10)dB = 0.012303 * amplitude
    0x032F, // (-381/10)dB = 0.012445 * amplitude
    0x0339, // (-380/10)dB = 0.012589 * amplitude
    0x0342, // (-379/10)dB = 0.012735 * amplitude
    0x034C, // (-378/10)dB = 0.012882 * amplitude
    0x0356, // (-377/10)dB = 0.013032 * amplitude
    0x035F, // (-376/10)dB = 0.013183 * amplitude
    0x0369, // (-375/10)dB = 0.013335 * amplitude
    0x0374, // (-374/10)dB = 0.013490 * amplitude
    0x037E, // (-373/10)dB = 0.013646 * amplitude
    0x0388, // (-372/10)dB = 0.013804 * amplitude
    0x0393, // (-371/10)dB = 0.013964 * amplitude
    0x039D, // (-370/10)dB = 0.014125 * amplitude
    0x03A8, // (-369/10)dB = 0.014289 * amplitude
    0x03B3, // (-368/10)dB = 0.014454 * amplitude
    0x03BE, // (-367/10)dB = 0.014622 * amplitude
    0x03C9, // (-366/10)dB = 0.014791 * amplitude
    0x03D4, // (-365/10)dB = 0.014962 * amplitude
    0x03DF, // (-364/10)dB = 0.015136 * amplitude
    0x03EB, // (-363/10)dB = 0.015311 * amplitude
    0x03F7, // (-362/10)dB = 0.015488 * amplitude
    0x0402, // (-361/10)dB = 0.015668 * amplitude
    0x040E, // (-360/10)dB = 0.015849 * amplitude
    0x041A, // (-359/10)dB = 0.016032 * amplitude
    0x0426, // (-358/10)dB = 0.016218 * amplitude
    0x0433, // (-357/10)dB = 0.016406 * amplitude
    0x043F, // (-356/10)dB = 0.016596 * amplitude
    0x044C, // (-355/10)dB = 0.016788 * amplitude
    0x0458, // (-354/10)dB = 0.016982 * amplitude
    0x0465, // (-353/10)dB = 0.017179 * amplitude
    0x0472, // (-352/10)dB = 0.017378 * amplitude
    0x0480, // (-351/10)dB = 0.017579 * amplitude
    0x048D, // (-350/10)dB = 0.017783 * amplitude
    0x049A, // (-349/10)dB = 0.017989 * amplitude
    0x04A8, // (-348/10)dB = 0.018197 * amplitude
    0x04B6, // (-347/10)dB = 0.018408 * amplitude
    0x04C4, // (-346/10)dB = 0.018621 * amplitude
    0x04D2, // (-345/10)dB = 0.018836 * amplitude
    0x04E0, // (-344/10)dB = 0.019055 * amplitude
    0x04EF, // (-343/10)dB = 0.019275 * amplitude
    0x04FD, // (-342/10)dB = 0.019498 * amplitude
    0x050C, // (-341/10)dB = 0.019724 * amplitude
    0x051B, // (-340/10)dB = 0.019953 * amplitude
    0x052A, // (-339/10)dB = 0.020184 * amplitude
    0x053A, // (-338/10)dB = 0.020417 * amplitude
    0x0549, // (-337/10)dB = 0.020654 * amplitude
    0x0559, // (-336/10)dB = 0.020893 * amplitude
    0x0569, // (-335/10)dB = 0.021135 * amplitude
    0x0579, // (-334/10)dB = 0.021380 * amplitude
    0x0589, // (-333/10)dB = 0.021627 * amplitude
    0x0599, // (-332/10)dB = 0.021878 * amplitude
    0x05AA, // (-331/10)dB = 0.022131 * amplitude
    0x05BB, // (-330/10)dB = 0.022387 * amplitude
    0x05CC, // (-329/10)dB = 0.022646 * amplitude
    0x05DD, // (-328/10)dB = 0.022909 * amplitude
    0x05EE, // (-327/10)dB = 0.023174 * amplitude
    0x0600, // (-326/10)dB = 0.023442 * amplitude
    0x0612, // (-325/10)dB = 0.023714 * amplitude
    0x0624, // (-324/10)dB = 0.023988 * amplitude
    0x0636, // (-323/10)dB = 0.024266 * amplitude
    0x0648, // (-322/10)dB = 0.024547 * amplitude
    0x065B, // (-321/10)dB = 0.024831 * amplitude
    0x066E, // (-320/10)dB = 0.025119 * amplitude
    0x0681, // (-319/10)dB = 0.025410 * amplitude
    0x0694, // (-318/10)dB = 0.025704 * amplitude
    0x06A8, // (-317/10)dB = 0.026002 * amplitude
    0x06BB, // (-316/10)dB = 0.026303 * amplitude
    0x06CF, // (-315/10)dB = 0.026607 * amplitude
    0x06E3, // (-314/10)dB = 0.026915 * amplitude
    0x06F8, // (-313/10)dB = 0.027227 * amplitude
    0x070D, // (-312/10)dB = 0.027542 * amplitude
    0x0721, // (-311/10)dB = 0.027861 * amplitude
    0x0737, // (-310/10)dB = 0.028184 * amplitude
    0x074C, // (-309/10)dB = 0.028510 * amplitude
    0x0762, // (-308/10)dB = 0.028840 * amplitude
    0x0777, // (-307/10)dB = 0.029174 * amplitude
    0x078E, // (-306/10)dB = 0.029512 * amplitude
    0x07A4, // (-305/10)dB = 0.029854 * amplitude
    0x07BB, // (-304/10)dB = 0.030200 * amplitude
    0x07D2, // (-303/10)dB = 0.030549 * amplitude
    0x07E9, // (-302/10)dB = 0.030903 * amplitude
    0x0800, // (-301/10)dB = 0.031261 * amplitude
    0x0818, // (-300/10)dB = 0.031623 * amplitude
    0x0830, // (-299/10)dB = 0.031989 * amplitude
    0x0848, // (-298/10)dB = 0.032359 * amplitude
    0x0861, // (-297/10)dB = 0.032734 * amplitude
    0x087A, // (-296/10)dB = 0.033113 * amplitude
    0x0893, // (-295/10)dB = 0.033497 * amplitude
    0x08AC, // (-294/10)dB = 0.033884 * amplitude
    0x08C6, // (-293/10)dB = 0.034277 * amplitude
    0x08E0, // (-292/10)dB = 0.034674 * amplitude
    0x08FA, // (-291/10)dB = 0.035075 * amplitude
    0x0915, // (-290/10)dB = 0.035481 * amplitude
    0x0930, // (-289/10)dB = 0.035892 * amplitude
    0x094B, // (-288/10)dB = 0.036308 * amplitude
    0x0967, // (-287/10)dB = 0.036728 * amplitude
    0x0982, // (-286/10)dB = 0.037154 * amplitude
    0x099F, // (-285/10)dB = 0.037584 * amplitude
    0x09BB, // (-284/10)dB = 0.038019 * amplitude
    0x09D8, // (-283/10)dB = 0.038459 * amplitude
    0x09F5, // (-282/10)dB = 0.038905 * amplitude
    0x0A13, // (-281/10)dB = 0.039355 * amplitude
    0x0A31, // (-280/10)dB = 0.039811 * amplitude
    0x0A4F, // (-279/10)dB = 0.040272 * amplitude
    0x0A6D, // (-278/10)dB = 0.040738 * amplitude
    0x0A8C, // (-277/10)dB = 0.041210 * amplitude
    0x0AAB, // (-276/10)dB = 0.041687 * amplitude
    0x0ACB, // (-275/10)dB = 0.042170 * amplitude
    0x0AEB, // (-274/10)dB = 0.042658 * amplitude
    0x0B0C, // (-273/10)dB = 0.043152 * amplitude
    0x0B2C, // (-272/10)dB = 0.043652 * amplitude
    0x0B4D, // (-271/10)dB = 0.044157 * amplitude
    0x0B6F, // (-270/10)dB = 0.044668 * amplitude
    0x0B91, // (-269/10)dB = 0.045186 * amplitude
    0x0BB3, // (-268/10)dB = 0.045709 * amplitude
    0x0BD6, // (-267/10)dB = 0.046238 * amplitude
    0x0BF9, // (-266/10)dB = 0.046774 * amplitude
    0x0C1C, // (-265/10)dB = 0.047315 * amplitude
    0x0C40, // (-264/10)dB = 0.047863 * amplitude
    0x0C65, // (-263/10)dB = 0.048417 * amplitude
    0x0C89, // (-262/10)dB = 0.048978 * amplitude
    0x0CAE, // (-261/10)dB = 0.049545 * amplitude
    0x0CD4, // (-260/10)dB = 0.050119 * amplitude
    0x0CFA, // (-259/10)dB = 0.050699 * amplitude
    0x0D21, // (-258/10)dB = 0.051286 * amplitude
    0x0D48, // (-257/10)dB = 0.051880 * amplitude
    0x0D6F, // (-256/10)dB = 0.052481 * amplitude
    0x0D97, // (-255/10)dB = 0.053088 * amplitude
    0x0DBF, // (-254/10)dB = 0.053703 * amplitude
    0x0DE8, // (-253/10)dB = 0.054325 * amplitude
    0x0E11, // (-252/10)dB = 0.054954 * amplitude
    0x0E3B, // (-251/10)dB = 0.055590 * amplitude
    0x0E65, // (-250/10)dB = 0.056234 * amplitude
    0x0E90, // (-249/10)dB = 0.056885 * amplitude
    0x0EBB, // (-248/10)dB = 0.057544 * amplitude
    0x0EE6, // (-247/10)dB = 0.058210 * amplitude
    0x0F13, // (-246/10)dB = 0.058884 * amplitude
    0x0F3F, // (-245/10)dB = 0.059566 * amplitude
    0x0F6C, // (-244/10)dB = 0.060256 * amplitude
    0x0F9A, // (-243/10)dB = 0.060954 * amplitude
    0x0FC8, // (-242/10)dB = 0.061660 * amplitude
    0x0FF7, // (-241/10)dB = 0.062373 * amplitude
    0x1027, // (-240/10)dB = 0.063096 * amplitude
    0x1056, // (-239/10)dB = 0.063826 * amplitude
    0x1087, // (-238/10)dB = 0.064565 * amplitude
    0x10B8, // (-237/10)dB = 0.065313 * amplitude
    0x10E9, // (-236/10)dB = 0.066069 * amplitude
    0x111C, // (-235/10)dB = 0.066834 * amplitude
    0x114E, // (-234/10)dB = 0.067608 * amplitude
    0x1182, // (-233/10)dB = 0.068391 * amplitude
    0x11B5, // (-232/10)dB = 0.069183 * amplitude
    0x11EA, // (-231/10)dB = 0.069984 * amplitude
    0x121F, // (-230/10)dB = 0.070795 * amplitude
    0x1255, // (-229/10)dB = 0.071614 * amplitude
    0x128B, // (-228/10)dB = 0.072444 * amplitude
    0x12C2, // (-227/10)dB = 0.073282 * amplitude
    0x12FA, // (-226/10)dB = 0.074131 * amplitude
    0x1332, // (-225/10)dB = 0.074989 * amplitude
    0x136B, // (-224/10)dB = 0.075858 * amplitude
    0x13A4, // (-223/10)dB = 0.076736 * amplitude
    0x13DF, // (-222/10)dB = 0.077625 * amplitude
    0x141A, // (-221/10)dB = 0.078524 * amplitude
    0x1455, // (-220/10)dB = 0.079433 * amplitude
    0x1491, // (-219/10)dB = 0.080353 * amplitude
    0x14CE, // (-218/10)dB = 0.081283 * amplitude
    0x150C, // (-217/10)dB = 0.082224 * amplitude
    0x154B, // (-216/10)dB = 0.083176 * amplitude
    0x158A, // (-215/10)dB = 0.084140 * amplitude
    0x15CA, // (-214/10)dB = 0.085114 * amplitude
    0x160A, // (-213/10)dB = 0.086099 * amplitude
    0x164B, // (-212/10)dB = 0.087096 * amplitude
    0x168E, // (-211/10)dB = 0.088105 * amplitude
    0x16D0, // (-210/10)dB = 0.089125 * amplitude
    0x1714, // (-209/10)dB = 0.090157 * amplitude
    0x1758, // (-208/10)dB = 0.091201 * amplitude
    0x179E, // (-207/10)dB = 0.092257 * amplitude
    0x17E4, // (-206/10)dB = 0.093325 * amplitude
    0x182A, // (-205/10)dB = 0.094406 * amplitude
    0x1872, // (-204/10)dB = 0.095499 * amplitude
    0x18BB, // (-203/10)dB = 0.096605 * amplitude
    0x1904, // (-202/10)dB = 0.097724 * amplitude
    0x194E, // (-201/10)dB = 0.098855 * amplitude
    0x1999, // (-200/10)dB = 0.100000 * amplitude
    0x19E5, // (-199/10)dB = 0.101158 * amplitude
    0x1A32, // (-198/10)dB = 0.102329 * amplitude
    0x1A7F, // (-197/10)dB = 0.103514 * amplitude
    0x1ACE, // (-196/10)dB = 0.104713 * amplitude
    0x1B1D, // (-195/10)dB = 0.105925 * amplitude
    0x1B6E, // (-194/10)dB = 0.107152 * amplitude
    0x1BBF, // (-193/10)dB = 0.108393 * amplitude
    0x1C11, // (-192/10)dB = 0.109648 * amplitude
    0x1C65, // (-191/10)dB = 0.110917 * amplitude
    0x1CB9, // (-190/10)dB = 0.112202 * amplitude
    0x1D0E, // (-189/10)dB = 0.113501 * amplitude
    0x1D64, // (-188/10)dB = 0.114815 * amplitude
    0x1DBB, // (-187/10)dB = 0.116145 * amplitude
    0x1E13, // (-186/10)dB = 0.117490 * amplitude
    0x1E6C, // (-185/10)dB = 0.118850 * amplitude
    0x1EC7, // (-184/10)dB = 0.120226 * amplitude
    0x1F22, // (-183/10)dB = 0.121619 * amplitude
    0x1F7E, // (-182/10)dB = 0.123027 * amplitude
    0x1FDC, // (-181/10)dB = 0.124451 * amplitude
    0x203A, // (-180/10)dB = 0.125893 * amplitude
    0x209A, // (-179/10)dB = 0.127350 * amplitude
    0x20FA, // (-178/10)dB = 0.128825 * amplitude
    0x215C, // (-177/10)dB = 0.130317 * amplitude
    0x21BF, // (-176/10)dB = 0.131826 * amplitude
    0x2223, // (-175/10)dB = 0.133352 * amplitude
    0x2288, // (-174/10)dB = 0.134896 * amplitude
    0x22EE, // (-173/10)dB = 0.136458 * amplitude
    0x2356, // (-172/10)dB = 0.138038 * amplitude
    0x23BF, // (-171/10)dB = 0.139637 * amplitude
    0x2429, // (-170/10)dB = 0.141254 * amplitude
    0x2494, // (-169/10)dB = 0.142889 * amplitude
    0x2500, // (-168/10)dB = 0.144544 * amplitude
    0x256E, // (-167/10)dB = 0.146218 * amplitude
    0x25DD, // (-166/10)dB = 0.147911 * amplitude
    0x264D, // (-165/10)dB = 0.149624 * amplitude
    0x26BF, // (-164/10)dB = 0.151356 * amplitude
    0x2732, // (-163/10)dB = 0.153109 * amplitude
    0x27A6, // (-162/10)dB = 0.154882 * amplitude
    0x281B, // (-161/10)dB = 0.156675 * amplitude
    0x2892, // (-160/10)dB = 0.158489 * amplitude
    0x290B, // (-159/10)dB = 0.160325 * amplitude
    0x2984, // (-158/10)dB = 0.162181 * amplitude
    0x29FF, // (-157/10)dB = 0.164059 * amplitude
    0x2A7C, // (-156/10)dB = 0.165959 * amplitude
    0x2AFA, // (-155/10)dB = 0.167880 * amplitude
    0x2B79, // (-154/10)dB = 0.169824 * amplitude
    0x2BFA, // (-153/10)dB = 0.171791 * amplitude
    0x2C7C, // (-152/10)dB = 0.173780 * amplitude
    0x2D00, // (-151/10)dB = 0.175792 * amplitude
    0x2D86, // (-150/10)dB = 0.177828 * amplitude
    0x2E0D, // (-149/10)dB = 0.179887 * amplitude
    0x2E95, // (-148/10)dB = 0.181970 * amplitude
    0x2F1F, // (-147/10)dB = 0.184077 * amplitude
    0x2FAB, // (-146/10)dB = 0.186209 * amplitude
    0x3038, // (-145/10)dB = 0.188365 * amplitude
    0x30C7, // (-144/10)dB = 0.190546 * amplitude
    0x3158, // (-143/10)dB = 0.192752 * amplitude
    0x31EA, // (-142/10)dB = 0.194984 * amplitude
    0x327E, // (-141/10)dB = 0.197242 * amplitude
    0x3314, // (-140/10)dB = 0.199526 * amplitude
    0x33AB, // (-139/10)dB = 0.201837 * amplitude
    0x3444, // (-138/10)dB = 0.204174 * amplitude
    0x34DF, // (-137/10)dB = 0.206538 * amplitude
    0x357C, // (-136/10)dB = 0.208930 * amplitude
    0x361A, // (-135/10)dB = 0.211349 * amplitude
    0x36BB, // (-134/10)dB = 0.213796 * amplitude
    0x375D, // (-133/10)dB = 0.216272 * amplitude
    0x3801, // (-132/10)dB = 0.218776 * amplitude
    0x38A7, // (-131/10)dB = 0.221309 * amplitude
    0x394F, // (-130/10)dB = 0.223872 * amplitude
    0x39F9, // (-129/10)dB = 0.226464 * amplitude
    0x3AA5, // (-128/10)dB = 0.229087 * amplitude
    0x3B53, // (-127/10)dB = 0.231739 * amplitude
    0x3C03, // (-126/10)dB = 0.234423 * amplitude
    0x3CB5, // (-125/10)dB = 0.237137 * amplitude
    0x3D68, // (-124/10)dB = 0.239883 * amplitude
    0x3E1F, // (-123/10)dB = 0.242661 * amplitude
    0x3ED7, // (-122/10)dB = 0.245471 * amplitude
    0x3F91, // (-121/10)dB = 0.248313 * amplitude
    0x404D, // (-120/10)dB = 0.251189 * amplitude
    0x410C, // (-119/10)dB = 0.254097 * amplitude
    0x41CD, // (-118/10)dB = 0.257040 * amplitude
    0x4290, // (-117/10)dB = 0.260016 * amplitude
    0x4355, // (-116/10)dB = 0.263027 * amplitude
    0x441D, // (-115/10)dB = 0.266073 * amplitude
    0x44E7, // (-114/10)dB = 0.269153 * amplitude
    0x45B3, // (-113/10)dB = 0.272270 * amplitude
    0x4682, // (-112/10)dB = 0.275423 * amplitude
    0x4753, // (-111/10)dB = 0.278612 * amplitude
    0x4826, // (-110/10)dB = 0.281838 * amplitude
    0x48FC, // (-109/10)dB = 0.285102 * amplitude
    0x49D4, // (-108/10)dB = 0.288403 * amplitude
    0x4AAF, // (-107/10)dB = 0.291743 * amplitude
    0x4B8D, // (-106/10)dB = 0.295121 * amplitude
    0x4C6D, // (-105/10)dB = 0.298538 * amplitude
    0x4D4F, // (-104/10)dB = 0.301995 * amplitude
    0x4E34, // (-103/10)dB = 0.305492 * amplitude
    0x4F1C, // (-102/10)dB = 0.309030 * amplitude
    0x5007, // (-101/10)dB = 0.312608 * amplitude
    0x50F4, // (-100/10)dB = 0.316228 * amplitude
    0x51E4, // (-99/10)dB = 0.319890 * amplitude
    0x52D7, // (-98/10)dB = 0.323594 * amplitude
    0x53CC, // (-97/10)dB = 0.327341 * amplitude
    0x54C5, // (-96/10)dB = 0.331131 * amplitude
    0x55C0, // (-95/10)dB = 0.334965 * amplitude
    0x56BE, // (-94/10)dB = 0.338844 * amplitude
    0x57BF, // (-93/10)dB = 0.342768 * amplitude
    0x58C3, // (-92/10)dB = 0.346737 * amplitude
    0x59CA, // (-91/10)dB = 0.350752 * amplitude
    0x5AD5, // (-90/10)dB = 0.354813 * amplitude
    0x5BE2, // (-89/10)dB = 0.358922 * amplitude
    0x5CF2, // (-88/10)dB = 0.363078 * amplitude
    0x5E06, // (-87/10)dB = 0.367282 * amplitude
    0x5F1C, // (-86/10)dB = 0.371535 * amplitude
    0x6036, // (-85/10)dB = 0.375837 * amplitude
    0x6154, // (-84/10)dB = 0.380189 * amplitude
    0x6274, // (-83/10)dB = 0.384592 * amplitude
    0x6398, // (-82/10)dB = 0.389045 * amplitude
    0x64BF, // (-81/10)dB = 0.393550 * amplitude
    0x65EA, // (-80/10)dB = 0.398107 * amplitude
    0x6718, // (-79/10)dB = 0.402717 * amplitude
    0x684A, // (-78/10)dB = 0.407380 * amplitude
    0x697F, // (-77/10)dB = 0.412098 * amplitude
    0x6AB7, // (-76/10)dB = 0.416869 * amplitude
    0x6BF4, // (-75/10)dB = 0.421697 * amplitude
    0x6D34, // (-74/10)dB = 0.426580 * amplitude
    0x6E78, // (-73/10)dB = 0.431519 * amplitude
    0x6FBF, // (-72/10)dB = 0.436516 * amplitude
    0x710A, // (-71/10)dB = 0.441570 * amplitude
    0x7259, // (-70/10)dB = 0.446684 * amplitude
    0x73AC, // (-69/10)dB = 0.451856 * amplitude
    0x7503, // (-68/10)dB = 0.457088 * amplitude
    0x765E, // (-67/10)dB = 0.462381 * amplitude
    0x77BD, // (-66/10)dB = 0.467735 * amplitude
    0x7920, // (-65/10)dB = 0.473151 * amplitude
    0x7A87, // (-64/10)dB = 0.478630 * amplitude
    0x7BF2, // (-63/10)dB = 0.484172 * amplitude
    0x7D62, // (-62/10)dB = 0.489779 * amplitude
    0x7ED5, // (-61/10)dB = 0.495450 * amplitude
    0x804D, // (-60/10)dB = 0.501187 * amplitude
    0x81CA, // (-59/10)dB = 0.506991 * amplitude
    0x834A, // (-58/10)dB = 0.512861 * amplitude
    0x84D0, // (-57/10)dB = 0.518800 * amplitude
    0x8659, // (-56/10)dB = 0.524807 * amplitude
    0x87E8, // (-55/10)dB = 0.530884 * amplitude
    0x897A, // (-54/10)dB = 0.537032 * amplitude
    0x8B12, // (-53/10)dB = 0.543250 * amplitude
    0x8CAE, // (-52/10)dB = 0.549541 * amplitude
    0x8E4F, // (-51/10)dB = 0.555904 * amplitude
    0x8FF5, // (-50/10)dB = 0.562341 * amplitude
    0x91A0, // (-49/10)dB = 0.568853 * amplitude
    0x9350, // (-48/10)dB = 0.575440 * amplitude
    0x9504, // (-47/10)dB = 0.582103 * amplitude
    0x96BE, // (-46/10)dB = 0.588844 * amplitude
    0x987D, // (-45/10)dB = 0.595662 * amplitude
    0x9A41, // (-44/10)dB = 0.602560 * amplitude
    0x9C0A, // (-43/10)dB = 0.609537 * amplitude
    0x9DD9, // (-42/10)dB = 0.616595 * amplitude
    0x9FAD, // (-41/10)dB = 0.623735 * amplitude
    0xA186, // (-40/10)dB = 0.630957 * amplitude
    0xA365, // (-39/10)dB = 0.638263 * amplitude
    0xA549, // (-38/10)dB = 0.645654 * amplitude
    0xA733, // (-37/10)dB = 0.653131 * amplitude
    0xA923, // (-36/10)dB = 0.660693 * amplitude
    0xAB18, // (-35/10)dB = 0.668344 * amplitude
    0xAD13, // (-34/10)dB = 0.676083 * amplitude
    0xAF14, // (-33/10)dB = 0.683912 * amplitude
    0xB11B, // (-32/10)dB = 0.691831 * amplitude
    0xB328, // (-31/10)dB = 0.699842 * amplitude
    0xB53B, // (-30/10)dB = 0.707946 * amplitude
    0xB755, // (-29/10)dB = 0.716143 * amplitude
    0xB974, // (-28/10)dB = 0.724436 * amplitude
    0xBB9A, // (-27/10)dB = 0.732825 * amplitude
    0xBDC6, // (-26/10)dB = 0.741310 * amplitude
    0xBFF9, // (-25/10)dB = 0.749894 * amplitude
    0xC232, // (-24/10)dB = 0.758578 * amplitude
    0xC471, // (-23/10)dB = 0.767361 * amplitude
    0xC6B8, // (-22/10)dB = 0.776247 * amplitude
    0xC905, // (-21/10)dB = 0.785236 * amplitude
    0xCB59, // (-20/10)dB = 0.794328 * amplitude
    0xCDB3, // (-19/10)dB = 0.803526 * amplitude
    0xD015, // (-18/10)dB = 0.812831 * amplitude
    0xD27E, // (-17/10)dB = 0.822243 * amplitude
    0xD4EE, // (-16/10)dB = 0.831764 * amplitude
    0xD765, // (-15/10)dB = 0.841395 * amplitude
    0xD9E4, // (-14/10)dB = 0.851138 * amplitude
    0xDC6A, // (-13/10)dB = 0.860994 * amplitude
    0xDEF7, // (-12/10)dB = 0.870964 * amplitude
    0xE18C, // (-11/10)dB = 0.881049 * amplitude
    0xE429, // (-10/10)dB = 0.891251 * amplitude
    0xE6CD, // (-9/10)dB = 0.901571 * amplitude
    0xE979, // (-8/10)dB = 0.912011 * amplitude
    0xEC2D, // (-7/10)dB = 0.922571 * amplitude
    0xEEE9, // (-6/10)dB = 0.933254 * amplitude
    0xF1AD, // (-5/10)dB = 0.944061 * amplitude
    0xF47A, // (-4/10)dB = 0.954993 * amplitude
    0xF74F, // (-3/10)dB = 0.966051 * amplitude
    0xFA2C, // (-2/10)dB = 0.977237 * amplitude
    0xFD11, // (-1/10)dB = 0.988553 * amplitude
    0xFFFF, // 0dB
    };


// The two routines that follow convert from a linear AmpFactor in the
// range 65535/65536 to 1/65536 to a decibel range of -100.00 to -0.01
// and vice versa.
//
// The amp factors are expressed in parts per 65536 as a 16 bit numerator,
// i.e. actual amplification is (ampfactor)/65536.
//
// The decibels are expressed as parts per 100.  i.e. -100 means -1dB.
//
// Note that although a decibel is formally 10 * log10(x), the AmpFactor
// refers to voltages and the dB to powers, and power = v**2/r
// so the rule is dB = 20*log10(x)
//
// If you change one routine you will almost certainly have to change
// the other.  In an ideal world the routines would be inverses
// meaning that the following is true
//
// 	AmpFactor == DBToAmpFactor(AmpFactorToDB(AmpFactor))
//
// HOWEVER many iterations are made through the routines. The
// secondary objective is to minimise the drift such that
// successive iterations do not stray too far from the starting
// point.
//
// This is clearly impossible because the quantisations are
// quite different.  10**-.005 = 1.0115 or 65536->64786, so if
// we start from (say) 65000 then something nasty must happen.
// likewise the difference between an amp factor of 1/65536 and
// 2/65536 is about 6dB - so much for the nearest hundredth!
//
// From here on we'll call them DB (even though that should be a
// dekabell (10 bells) to avoid confusion with hungarian.
//

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
DWORD DBToAmpFactor( LONG lDB )
{
    DWORD dwFactor;

    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB-5)/10;		    // scaled to 1/10th dB units

    if (lDB > 0)    lDB = 0;        // upper boundary
    if (lDB < -964) return 0;  	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index
//    ASSERT(lDB >= 0);
//    ASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));

    dwFactor = (DWORD) tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
}

LONG AmpFactorToDB( DWORD dwFactor )
{

    LONG    lDB;

    int	    iMin;
    int	    iMax;
    int     iMiddle;

    iMin = 0;

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;

    //
    // Binary search through the table of AmpFactors.
    //
    // iMin and iMax specify the range in which the result can be found this
    // is initially the whole table.
    //
    // In each interation we reduce the range by half.
    //
    // Loop variant: iMax - iMin, which decreases in each iteration.
    // Invariant:  iMin <= iMax.
    // Exit condition: iMin = iMax.
    //
    while (iMin != iMax) {
//        ASSERT(iMin < iMax);

        iMiddle = (iMin + iMax) / 2;

        // Chose the half which includes dwFactor.
        if (dwFactor <= tblDBTenthsToAmpFactor[iMiddle])
            iMax = iMiddle;       // iMin does not change
        else
            iMin = iMiddle + 1;   // iMax does not change
    }

    lDB = (iMin - 964) * 10;

    return lDB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\dmusicproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.h
//
//  Contents: declaration for CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DMUSIC_PROXY_H__
#define _DMUSIC_PROXY_H__

#include "playerproxy.h"

class CTIMEPlayerDMusicProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEPlayerDMusicProxy* CreateDMusicProxy();
    
  protected:
    CTIMEPlayerDMusicProxy() {}
    virtual HRESULT Init();

};

#endif //_DMUSIC_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\decibels.h ===
//--------------------------------------------------------------------------;
//
//  File: decibels.cpp
//
//  Copyright (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//       utilities for converting volume/pan in decibel units to/from
//       the 0-0xffff (0-1000) range used by waveOutSetVolume (MCI) etc
//
//  Contents:
//
//  History:
//      06/15/95	SteveDav    plagiarised from Direct Sound
//
//--------------------------------------------------------------------------;
#ifndef _DECIBELS_H
#define _DECIBELS_H

LONG AmpFactorToDB( DWORD dwFactor );
DWORD DBToAmpFactor( LONG lDB );

#define AX_MIN_VOLUME -10000
#define AX_QUARTER_VOLUME -1200
#define AX_HALF_VOLUME -600
#define AX_THREEQUARTERS_VOLUME -240
#define AX_MAX_VOLUME 0

#define AX_BALANCE_LEFT -10000
#define AX_BALANCE_RIGHT 10000
#define AX_BALANCE_NEUTRAL 0

#define MAX_VOLUME_RANGE 1.0
#define MIN_VOLUME_RANGE 0.0

#endif /* _DECIBELS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\dshowcdproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: implementation of CTIMEDshowCDPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "dshowcdproxy.h"
#include "playercd.h"

#define SUPER CTIMEPlayerProxy

CTIMEDshowCDPlayerProxy* 
CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy()
{
    HRESULT hr;
    CTIMEDshowCDPlayerProxy * pProxy;

    pProxy = new CTIMEDshowCDPlayerProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEDshowCDPlayerProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEDshowCDPlayer(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\dmusicproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.cpp
//
//  Contents: implementation of CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "dmusicproxy.h"
#include "playerdmusic.h"

#define SUPER CTIMEPlayerProxy

CTIMEPlayerDMusicProxy* 
CTIMEPlayerDMusicProxy::CreateDMusicProxy()
{
    HRESULT hr = S_OK;
    CTIMEPlayerDMusicProxy * pProxy;

    pProxy = new CTIMEPlayerDMusicProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEPlayerDMusicProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEPlayerDMusic(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\dshowproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: declaration for CTIMEDshowPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DSHOW_PROXY_H__
#define _DSHOW_PROXY_H__

#include "playerproxy.h"

class CTIMEDshowPlayerProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEDshowPlayerProxy* CreateDshowPlayerProxy();
    
  protected:
    CTIMEDshowPlayerProxy() {}
    virtual HRESULT Init();

};

#endif //_DSHOW_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\dshowcdproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: declaration for CTIMEDshowCDPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DSHOWCD_PROXY_H__
#define _DSHOWCD_PROXY_H__

#include "playerproxy.h"

class CTIMEDshowCDPlayerProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEDshowCDPlayerProxy* CreateDshowCDPlayerProxy();
    
  protected:
    CTIMEDshowCDPlayerProxy() {}
    virtual HRESULT Init();

};

#endif //_DSHOW_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\externuuids.cpp ===
//+-----------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      src\time\src\externuuids.cpp
//
//  Contents:  UUID definitions for music center
//
//------------------------------------------------------------------------
#include "headers.h"
#include <initguid.h>
#include "mixerocx.h"
#include <ExternUUIDs.h>
#include <inc\qnetwork.h>

//
// originally in \mm\inc\manager.h
//
const CLSID    CLSID_MCMANAGER          = {0xcd103bcf,0x4846,0x11d3,{0xa2,0x0a,0x00,0xc0,0x4f,0xa3,0xb6,0x0c}};
const IID      IID_IMCManager           = {0x901B7025,0x4846,0x11d3,{0xa2,0x0a,0x00,0xc0,0x4f,0xa3,0xb6,0x0c}};

//
// originally in \mm\inc\dplayer.h
//
const CLSID    CLSID_DLXPLAY            = {0xcf94dff3,0x38ea,0x4343,{0x96,0x3e,0x41,0x0d,0xb6,0x0d,0xd9,0xb8}};
const IID      IID_IDLXPLAY             = {0x89301af7,0xeb8d,0x41f8,{0xbb,0x3d,0x6b,0xc2,0x25,0xda,0x31,0xc2}};
const IID      IID_IDLXPLAYEVENTSINK    = {0x89301af8,0xeb8d,0x41f8,{0xbb,0x3d,0x6b,0xc2,0x25,0xda,0x31,0xc2}};

//
// originally in \mm\shplay\shplay.h
//
const IID      IID_IMCPList             = {0xEBC54B0C,0x4091,0x11D3,{0xA2,0x08,0x00,0xC0,0x4F,0xA3,0xB6,0x0C}};

#include "mixerocx_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\dshowproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\dshowproxy.h
//
//  Contents: implementation of CTIMEDshowPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "dshowproxy.h"
#include "playerdshow.h"

#define SUPER CTIMEPlayerProxy

CTIMEDshowPlayerProxy* 
CTIMEDshowPlayerProxy::CreateDshowPlayerProxy()
{
    HRESULT hr;
    CTIMEDshowPlayerProxy * pProxy;

    pProxy = new CTIMEDshowPlayerProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEDshowPlayerProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEDshowPlayer(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\hwproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.h
//
//  Contents: declaration for CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _DSHOW_HW_PROXY_H__
#define _DSHOW_HW_PROXY_H__

#include "playerproxy.h"

class CTIMEDshowHWPlayerProxy : 
  public CTIMEPlayerProxy
{
  public:
    static CTIMEDshowHWPlayerProxy* CreateDshowHWPlayerProxy();
    
  protected:
    CTIMEDshowHWPlayerProxy() {}
    virtual HRESULT Init();

};

#endif //_DSHOW_HW_PROXY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\externuuids.h ===
//+-----------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      src\time\src\externuuids.h
//
//  Contents:  UUID and interface declarations for music center
//             
//             IDEALLY, THIS FILE SHOULD GO AWAY
//
//------------------------------------------------------------------------

#pragma once

// These are defined under different macro names inside of maguids.h

#define MCPLAYLIST_PROPERTY_ARTIST              L"Artist"
#define MCPLAYLIST_PROPERTY_TITLE               L"Title"
#define MCPLAYLIST_PROPERTY_COPYRIGHT           L"Copyright"

#define MCPLAYLIST_TRACKPROPERTY_ARTIST         L"Artist"
#define MCPLAYLIST_TRACKPROPERTY_TITLE          L"Title"
#define MCPLAYLIST_TRACKPROPERTY_FILENAME       L"Filename"
#define MCPLAYLIST_TRACKPROPERTY_COPYRIGHT      L"Copyright"
#define MCPLAYLIST_TRACKPROPERTY_RATING         L"Rating"

//
// originally in \mm\inc\deluxecd.h
//

// CD-ROM table-of-contents track count         
#ifndef MAXIMUM_NUMBER_TRACKS                   
#define MAXIMUM_NUMBER_TRACKS                   100             // 99 actual tracks + 1 leadout
#endif // MAXIMUM_NUMBER_TRACKS                 


// Table-of-contents                             
typedef struct 
{
    DWORD           dwType;                             // Track type
    DWORD           dwStartPosition;                    // Track starting position
} DLXCDROMTOCTRACK;

typedef struct 
{
    DWORD               dwTrackCount;                       // Track count
    DLXCDROMTOCTRACK    TrackData[MAXIMUM_NUMBER_TRACKS];   // Track data
} DLXCDROMTOC;


//
// originally in \mm\inc\manager.h
//
EXTERN_C const CLSID    CLSID_MCMANAGER;
EXTERN_C const IID      IID_IMCManager;


typedef interface IMCManager            IMCManager;
typedef IMCManager *	                LPMCMANAGER;

typedef interface IMCManagerChangeSink  IMCManagerChangeSink;
typedef IMCManagerChangeSink *		    LPMCMANAGERCHANGESINK;

//IMCPList is generated from the shplay\shplay.idl file into shplay\shplay.h
//         It isn't nice enough to create these typedefs for us, so we are
//         defining them here

    MIDL_INTERFACE("EBC54B0C-4091-11D3-A208-00C04FA3B60C")
    IMCPList : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tracks( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GetProperty( 
            BSTR PropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GetTrackProperty( 
            int TrackNumber,
            BSTR PropertyName,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load( 
            BSTR PlaylistName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( 
            BSTR PlaylistName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InsertTrack( 
            VARIANT FilenameOrNumber,
            short Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveTrack( 
            short Index) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadCDPlaylist( 
            LPUNKNOWN pChangeSink,
            HWND hwnd,
            LPUNKNOWN pRoot,
            void __RPC_FAR *pTOC,
            BOOL fOriginal) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadFromFile( 
            BSTR FileName) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            LPUNKNOWN pChangeSink,
            HWND hwnd,
            LPUNKNOWN pRoot) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveTrack( 
            short OldIndex,
            short NewIndex) = 0;
        
        virtual /* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Clone( 
            /* [retval][out] */ LPUNKNOWN __RPC_FAR *ppVal) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeFromCopy( 
            LPUNKNOWN pChangeSink,
            HWND hwnd,
            LPUNKNOWN pRoot,
            LPUNKNOWN pPlaylist,
            short PlaylistType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasMetaData( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
    };




typedef interface IMCPList              IMCPList;
typedef IMCPList *		                LPMCPLIST;
//



#undef INTERFACE
#define INTERFACE IMCManager

DECLARE_INTERFACE_(IMCManager, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			        (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			        (THIS) PURE;
    STDMETHOD_(ULONG,Release) 			        (THIS) PURE;

    // IMCManager methods
    STDMETHOD (GetCDPlaylist)                   (THIS_ DLXCDROMTOC* pTOC, IMCPList** ppPlaylist) PURE;
    STDMETHOD (GetNewPlaylist)                  (THIS_ IMCPList** ppPlaylist) PURE;
    STDMETHOD (RegisterChangeSink)              (THIS_ IMCManagerChangeSink* pSink) PURE;
    STDMETHOD_(DWORD,GetNumNamedPlaylists)      (THIS) PURE;
    STDMETHOD (BeginNamedPlaylistEnumeration)   (THIS_ DWORD dwIndex) PURE;
    STDMETHOD (EnumerateNamedPlaylist)          (THIS_ BSTR bstrName) PURE;
    STDMETHOD (EndNamedPlaylistEnumeration)     (THIS) PURE;
};


//
// originally in \mm\inc\dplayer.h
//
EXTERN_C const CLSID    CLSID_DLXPLAY;
EXTERN_C const IID      IID_IDLXPLAY;

typedef interface IDLXPlay		        IDLXPlay;
typedef IDLXPlay *	    		        LPDLXPLAY;

typedef interface IDLXPlayEventSink     IDLXPlayEventSink;
typedef IDLXPlayEventSink *		        LPDLXPLAYEVENTSINK;

#undef INTERFACE
#define INTERFACE IDLXPlay

DECLARE_INTERFACE_(IDLXPlay, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
                                        
    // IDLXPlay methods                 
    STDMETHOD (Initialize)              (THIS_ LPMCMANAGER pManager, LPDLXPLAYEVENTSINK pSink) PURE;
	STDMETHOD (get_GetCurrentPlaylist)  (THIS_ IMCPList* *pVal) PURE;
	STDMETHOD (SetRadioPlaylist)        (THIS_ IMCPList* pPlaylist) PURE;
	STDMETHOD (SetMusicPlaylist)        (THIS_ IMCPList* pPlaylist) PURE;
	STDMETHOD (get_Tracks)              (THIS_ short *pVal) PURE;
	STDMETHOD (get_CurrentTrack)        (THIS_ int *pVal) PURE;
	STDMETHOD (put_CurrentTrack)        (THIS_ int newVal) PURE;
	STDMETHOD (get_CurrentCD)           (THIS_ short *pVal) PURE;
	STDMETHOD (put_CurrentCD)           (THIS_ short newVal) PURE;
	STDMETHOD (get_GetCDPlaylist)       (THIS_ short Index, IMCPList **ppVal) PURE;
	STDMETHOD (get_GetMusicPlaylist)    (THIS_ IMCPList **ppVal) PURE;
	STDMETHOD (get_GetRadioPlaylist)    (THIS_ IMCPList **ppVal) PURE;
	STDMETHOD (get_NumCDs)              (THIS_ short *pVal) PURE;
	STDMETHOD (get_State)               (THIS_ short *pVal) PURE;
	STDMETHOD (PreviousTrack)           (THIS) PURE;
	STDMETHOD (NextTrack)               (THIS) PURE;
	STDMETHOD (Stop)                    (THIS) PURE;
	STDMETHOD (Pause)                   (THIS) PURE;
	STDMETHOD (Play)                    (THIS) PURE;
	STDMETHOD (OpenFiles)               (THIS) PURE;
	STDMETHOD (Options)                 (THIS) PURE;
	STDMETHOD (OnDraw)                  (THIS_  HDC hdc, RECT *pRect) PURE;
    STDMETHOD_(LRESULT,OnMessage)       (THIS_  UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled) PURE;
    STDMETHOD (SetUIInfo)               (THIS_  HWND hwndParent, RECT* pRect, IOleInPlaceSiteWindowless* pSite) PURE;
    STDMETHOD (BeginCacheTrack)         (THIS_  short CD, short Track, wchar_t* filename) PURE;
    STDMETHOD (CancelCache)             (THIS) PURE;
	STDMETHOD(get_Mute)                 (THIS_ BOOL *pVal) PURE;
	STDMETHOD(put_Mute)                 (THIS_ BOOL newVal) PURE;
	STDMETHOD(get_Volume)               (THIS_ float *pVal) PURE;
	STDMETHOD(put_Volume)               (THIS_ float newVal) PURE;
	STDMETHOD(get_PlayerMode)           (THIS_ short *pVal) PURE;
	STDMETHOD(put_PlayerMode)           (THIS_ short newVal) PURE;
    STDMETHOD(Eject)                    (THIS) PURE;
};



#undef INTERFACE
#define INTERFACE IDLXPlayEventSink

DECLARE_INTERFACE_(IDLXPlayEventSink, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 		    (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 		    (THIS) PURE;
    STDMETHOD_(ULONG,Release) 		    (THIS) PURE;
                                        
    // IDLXPlayEventSink methods        
	STDMETHOD (OnDiscInserted)          (THIS_  long CDID) PURE;
    STDMETHOD (OnDiscRemoved)           (THIS_  long CDID) PURE;
    STDMETHOD (OnPause)                 (THIS) PURE;
    STDMETHOD (OnStop)                  (THIS) PURE;
    STDMETHOD (OnPlay)                  (THIS) PURE;
    STDMETHOD (OnTrackChanged)          (THIS_ short NewTrack) PURE;
    STDMETHOD (OnCacheProgress)         (THIS_ short CD, short Track, short PercentCompleted) PURE;
    STDMETHOD (OnCacheComplete)         (THIS_ short CD, short Track, short Status) PURE;
};


//
// originally in \mm\shplay\shplay.h
//
EXTERN_C const IID      IID_IMCPList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\hwproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\hwproxy.cpp
//
//  Contents: implementation of CTIMEDshowHWPlayerProxy
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "hwproxy.h"
#include "playerhwdshow.h"

#define SUPER CTIMEPlayerProxy

CTIMEDshowHWPlayerProxy* 
CTIMEDshowHWPlayerProxy::CreateDshowHWPlayerProxy()
{
    HRESULT hr;
    CTIMEDshowHWPlayerProxy * pProxy;

    pProxy = new CTIMEDshowHWPlayerProxy();
    if (NULL == pProxy)
    {
        goto done;
    }

    hr = pProxy->Init();
    if (FAILED(hr))
    {
        delete pProxy;
        pProxy = NULL;
    }

done:
    return pProxy;
}

HRESULT
CTIMEDshowHWPlayerProxy::Init()
{
    HRESULT hr = S_OK;
    
    Assert(NULL == m_pBasePlayer);

    m_pBasePlayer = new CTIMEDshowHWPlayer(this);
    if (NULL == m_pBasePlayer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = SUPER::Init();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\mediaattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: mediaattr.cpp
//
//  Contents: ITIMEMediaElement attributes
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "mediaelm.h"
#include "tokens.h"
#include "attr.h"

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TME CTIMEMediaElement

                // Function Name // Class // Attr Accessor    // COM put_ fn  // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(TME_Src,          TME,    GetSrcAttr,         put_src,        get_src,        VARIANT);
TIME_PERSIST_FN(TME_Type,         TME,    GetTypeAttr,        put_type,       get_type,       VARIANT);
TIME_PERSIST_FN(TME_ClipBegin,    TME,    GetClipBeginAttr,   put_clipBegin,  get_clipBegin,  VARIANT);
TIME_PERSIST_FN(TME_ClipEnd,      TME,    GetClipEndAttr,     put_clipEnd,    get_clipEnd,    VARIANT);
TIME_PERSIST_FN(TME_Player,       TME,    GetPlayerAttr,      put_player,     get_player,     VARIANT);

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMEMediaElement)
                           // Attr Name     // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_SRC,          TME_Src )
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,         TME_Type )
    PERSISTENCE_MAP_ENTRY( WZ_CLIPBEGIN,    TME_ClipBegin )
    PERSISTENCE_MAP_ENTRY( WZ_CLIPEND,      TME_ClipEnd )
    PERSISTENCE_MAP_ENTRY( WZ_PLAYER,       TME_Player )

END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\loadgif.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\loadgif.cpp
//
//  Contents: gif decoder, copied from direct animation source: danim\src\appel\util\loadgif.cpp
//
//------------------------------------------------------------------------------------
#include "headers.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include <vector>
#define vector std::vector

/*lint ++flb*/

DeclareTag(tagImageDecode, "Image Decode", "Image Decode Filters");

const long COLORKEY_NOT_SET = -1;

/*-- 
Structs from IE img.hxx 
--*/

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   MemFree(_gifinfo.pstack);
   MemFree(_gifinfo.table[0]);
   MemFree(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      MemFree(curPgf->ppixels);
      MemFree(curPgf->pcolors);
      MemFree(curPgf->pbmi);
      MemFree(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout = 0;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return (lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        TraceTag((tagImageDecode, "bad gif colormap."));
                        return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if((input_code_size < MINIMUM_CODE_SIZE) || (input_code_size > 29))
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                MemFree( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                MemFree( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                MemFree( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) MemAlloc(Mt(Mem), (_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) MemAlloc(Mt(Mem), (_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) MemAlloc(Mt(Mem), (_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        MemFree(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        MemFree(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        MemFree(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    HRESULT hr;
    long index;
    
    if (_gifinfo.stacksize >= MAX_STACK_SIZE) 
        return 0;

    index = (_gifinfo.sp - _gifinfo.pstack);
    hr = MemRealloc(Mt(Mem), (void**)&(_gifinfo.pstack), (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(hr)
        return 0;
        
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    return &(_gifinfo.pstack[_gifinfo.stacksize]);
}

BOOL
CImgGif::growTables()
{
    HRESULT hr;

    hr = MemRealloc(Mt(Mem), (void**)&(_gifinfo.table[0]), (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(hr){
        return FALSE; 
    }
    
    hr =  MemRealloc(Mt(Mem), (void**)&(_gifinfo.table[1]), (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(hr){
        return FALSE; 
    }
 
    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return NULL;
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

    cbImage = padlen * height * sizeof(char);

    if ((cbImage > dwMaxGIFBits) ||
        (image = (unsigned char *) MemAllocClear(Mt(Mem), cbImage)) == NULL)
    {
        TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
        return NULL;
    }

    if (c == 1)
    {
        // Netscape seems to field these bogus GIFs by filling treating them
        // as transparent. While not the optimal way to simulate this effect,
        // we'll fake it by pushing the initial code size up to a safe value,
        // consuming the input, and returning a buffer full of the transparent
        // color or zero, if no transparency is indicated.
        if (initLWZ(MINIMUM_CODE_SIZE))
            while (readLWZ() >= 0);
        else
        {
            if (image)
                MemFree(image);

            TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
            return NULL;
        }

        if (_gifinfo.Gif89.transparent != -1)
            FillMemory(image, cbImage, _gifinfo.Gif89.transparent);
        else // fall back on the background color 
            FillMemory(image, cbImage, 0);

        return image;
    }
    else if (initLWZ(c) == FALSE)
    {
        MemFree(image);
        TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        return NULL;
    }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
            // message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                {
                    if (image)
                        MemFree(image);
                    goto abort;
                }

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                {
                    if (image)
                        MemFree(image);
                    goto abort;
                }

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
                // message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0);

    return image;

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) MemAllocClear(Mt(Mem), sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) MemAllocClear(Mt(Mem), sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
    HRESULT hr = S_OK;
    unsigned char buf[16];
    unsigned char c;
    unsigned char localColorMap[3][MAXCOLORMAPSIZE];
    long useGlobalColormap;
    long imageCount = 0;
    long imageNumber = 1;
    unsigned char *image = NULL;
    unsigned long i;
    GIFSCREEN GifScreen;
    long bitPixel;
    PGIFFRAME pgfLast = NULL;
    PGIFFRAME pgfNew;
    
    _gifinfo.ZeroDataBlock = 0;
    
    /*
    * Initialize GIF89 extensions
    */
    _gifinfo.Gif89.transparent = -1;
    _gifinfo.Gif89.delayTime = 5;
    _gifinfo.Gif89.inputFlag = -1;
    _gifinfo.Gif89.disposal = 0;
    _gifinfo.lGifLoc = 0;
    
    // initialize our animation fields
    _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
    _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
    _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
    _gad.cLoops = 0;                
    _gad.pgf = NULL;
    _gad.pcolorsGlobal = NULL;
    
    if (!Read(buf, 6))
    {
        TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
        hr = E_FAIL;
        goto done;  
    }
    
    if (!IsGifHdr(buf)) {
        TraceTag((tagImageDecode, "GIF: Malformed header\n"));
        hr = E_FAIL;
        goto done;
    }
    
    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;
    
    if (!Read(buf, 7))
    {
        TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
        hr = E_FAIL;
        goto done;
    }
    
    GifScreen.Width = LM_to_uint(buf[0], buf[1]);
    GifScreen.Height = LM_to_uint(buf[2], buf[3]);
    GifScreen.BitPixel = 2 << (buf[4] & 0x07);
    GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
    GifScreen.Background = buf[5];
    GifScreen.AspectRatio = buf[6];
    
    if (BitSet(buf[4], LOCALCOLORMAP))
    {                                                       /* Global Colormap */
        int scale = 65536 / MAXCOLORMAPSIZE;
        
        if (ReadColorMap(GifScreen.BitPixel, GifScreen.ColorMap))
        {
            TraceTag((tagImageDecode, "error reading global colormap\n"));
            hr = E_FAIL;
            goto done;
        }
        for (i = 0; i < GifScreen.BitPixel; i++)
        {
            int tmp;
            
            tmp = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peRed = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peGreen = (BYTE) (GifScreen.ColorMap[1][i]);
            _ape[i].peBlue = (BYTE) (GifScreen.ColorMap[2][i]);
            _ape[i].peFlags = (BYTE) 0;
        }
        for (i = GifScreen.BitPixel; i < MAXCOLORMAPSIZE; i++)
        {
            _ape[i].peRed = (BYTE) 0;
            _ape[i].peGreen = (BYTE) 0;
            _ape[i].peBlue = (BYTE) 0;
            _ape[i].peFlags = (BYTE) 0;
        }
    }
    
    if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)
    {
        float r;
        r = ((float) (GifScreen.AspectRatio) + (float) 15.0) / (float) 64.0;
        TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
    }
    
    for (;; ) // our appetite now knows no bounds save termination or error
    {
        if (!Read(&c, 1))
        {
            TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if (c == ';')
        {                                               /* GIF terminator */
            if (imageCount < imageNumber)
            {
                TraceTag((tagImageDecode, "No images found in file\n"));
                hr = E_FAIL;
                goto done;
            }
            break;
        }
        
        if (c == '!')
        {                                               /* Extension */
            if (!Read(&c, 1))
            {
                TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                hr = E_FAIL;
                goto done;
            }
            DoExtension(c);
            continue;
        }
        
        if (c != ',')
        {                                               /* Not a valid start character */
            break;
        }
        
        ++imageCount;
        
        if (!Read(buf, 9))
        {
            TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
            hr = E_FAIL;
            goto done;
        }
        
        useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);
        
        bitPixel = 1 << ((buf[8] & 0x07) + 1);
        
        /*
        * We only want to set width and height for the imageNumber
        * we are requesting.
        */
        if (imageCount == imageNumber)
        {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases
            
            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen.Width;
            rectLS.bottom = GifScreen.Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                    (rectImage.bottom == rectLS.bottom &&
                    rectImage.right == rectLS.right);
            }   
            
            if (!fGoofy87a && fNoSpill)
            {
                _xWidth = GifScreen.Width;  
                _yHeight = GifScreen.Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.
                
                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen.Width &&
                    LM_to_uint(buf[6], buf[7]) == GifScreen.Height) ||
                    fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }
                
                _xWidth = LM_to_uint(buf[4], buf[5]);
                _yHeight = LM_to_uint(buf[6], buf[7]);
            }
            
            _lTrans = _gifinfo.Gif89.transparent;
            
            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
        }
        
        if (!useGlobalColormap)
        {
            if (ReadColorMap(bitPixel, localColorMap))
            {
                TraceTag((tagImageDecode, "error reading local colormap\n"));
                hr = E_FAIL;
                goto done;
            }
        }
        
        // We allocate a frame record for each imag in the GIF stream, including
        // the first/primary image.
        pgfNew = (PGIFFRAME) MemAllocClear(Mt(Mem), sizeof(GIFFRAME));        
        if ( pgfNew == NULL )
        {
            TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if ( _gifinfo.Gif89.delayTime != -1 )
        {
            // we have a fresh control extension for this block
            
            // convert to milliseconds
            pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;
            
            
            //REVIEW(seanf): workaround to cope with 'degenerate animations' whose timing is set to some
            //                               small value becaue of the delays imposed by Netscape's animation process
            if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
            
        }
        else
        {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
            // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
        }
        
        pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
        pgfNew->left = LM_to_uint(buf[0], buf[1]);
        pgfNew->width = LM_to_uint(buf[4], buf[5]);
        pgfNew->height = LM_to_uint(buf[6], buf[7]);
        
        // Images that are offset, or do not cover the full logical screen are 'transparent' in the
        // sense that they require us to matte the frame onto the background.
        
        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
            pgfNew->top != 0 ||
            pgfNew->left != 0 ||
            (UINT)pgfNew->width != (UINT)GifScreen.Width ||
            (UINT)pgfNew->height != (UINT)GifScreen.Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }
        
        // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
        pgfNew->hrgnVis = NULL;
        pgfNew->iRgnKind = NULLREGION;
        
        if (!useGlobalColormap)
        {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;
            
            // MemAllocClear will set unused colors to <0,0,0,0>
            pgfNew->pcolors = (PALETTEENTRY *) MemAllocClear(Mt(Mem), MAXCOLORMAPSIZE * sizeof(PALETTEENTRY));
            if ( pgfNew->pcolors == NULL )
            {
                DeleteRgn( pgfNew->hrgnVis );
                MemFree( pgfNew );
                
                TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                hr = E_FAIL;
                goto done;
            }
            else
            {
                for (i = 0; i < (ULONG)bitPixel; ++i)
                {
                    pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                    pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                    pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                }
                pgfNew->cColors = bitPixel;
            }
        }
        else
        {
            if ( _gad.pcolorsGlobal == NULL )
            { // Whoa! Somebody's interested in the global color table
                // MemAllocClear will set unused colors to <0,0,0,0>
                _gad.pcolorsGlobal = (PALETTEENTRY *) MemAllocClear(Mt(Mem), MAXCOLORMAPSIZE * sizeof(PALETTEENTRY));
                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen.BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                {
                    CopyMemory(_gad.pcolorsGlobal, _ape,
                        GifScreen.BitPixel * sizeof(PALETTEENTRY) );
                }
                else
                {
                    DeleteRgn( pgfNew->hrgnVis );
                    MemFree( pgfNew );
                    TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    hr = E_FAIL;
                    goto done;  
                }
            }
            pgfNew->cColors = GifScreen.BitPixel;
            pgfNew->pcolors = _gad.pcolorsGlobal;
        }
        
        // Get this in here so that GifStrectchDIBits can use it during progressive
        // rendering.
        if ( _gad.pgf == NULL )
            _gad.pgf = pgfNew;
        
        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
            LM_to_uint(buf[6], buf[7]), // height
            BitSet(buf[8], INTERLACE),
            imageCount != imageNumber);
        
        if ( pgfNew->ppixels != NULL )
        {
            // Oh JOY of JOYS! We got the pixels!
            if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;
                
                _gad.fAnimated = TRUE; // say multi-image == animated
                
                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette
                    
                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }
                
                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    MemFree( pgfNew->pcolors );
                pgfNew->pcolors = NULL;
                
                pgfLast->pgfNext = pgfNew;
                
                // Do something to here to get the new frame on the screen.
                
                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
            else
            { // first frame
                _gad.pgf = pgfNew;
                
                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;
                
                if ( imageCount == imageNumber )
                    image = pgfNew->ppixels;
            }
            pgfLast = pgfNew;
        }
        
        // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
        // GCE for the next image
        _gifinfo.Gif89.delayTime = -1;
        
        }
        
        if ( imageCount > imageNumber )
            _gad.fAnimated = TRUE; // say multi-image == animated
        
#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
        // Indefinite stays indefinite.
        // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
        //           We'll keep it around inside this ifdef in case we decide we want it.
        if ( _gad.fLooped &&
            (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
            _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        
done:
        return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
            _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }
    
    return pbmi;
}


//+-----------------------------------------------------------------------
//
//  Member:    LoadGifImage
//
//  Overview:  Given an IStream, decode an image into an array of bitmaps
//
//  Arguments: pStream      data source
//             colorKeys    pointer to where to store colorKey data
//             numBitmaps   where to store number of bitmaps
//             delays       where to store delay array
//             loop         where to store number of times to loop
//             ppBitMaps    where to store bitmaps
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP **ppBitMaps)
{
    HRESULT hr = S_OK;
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif gifimage;
   gifimage._szFileName = NULL;
   gifimage._gifinfo.stream = stream;
   BYTE *pbBits = gifimage.ReadGIFMaster();

   if (pbBits) {
      gifimage._pbBits = pbBits;
      gifimage._gad.pgf->pbmi = gifimage.FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   vector<HBITMAP> vhbmp;
   vector<COLORREF> vcolorKey;
   vector<int> vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   HBITMAP *hImage = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage._gad.pgf;
   PGIFFRAME pgfOld = NULL;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;
   unsigned int disp = 0;
    int i = 0;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage._xWidth;
   fullHeight = gifimage._yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   if (NULL == pgf)
   {
       hr = E_FAIL;
       goto done;
   }

   while(1) 
   {     
      Assert(pgf);      
      pbmi = pgf->pbmi;
      if (pbmi == NULL)
      {
          hr = E_FAIL;
          goto done;
      }

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) 
      {
          hr = E_OUTOFMEMORY;
          goto done;
      }

      // Correctly composite bitmaps based on disposal method specified        
      disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = COLORKEY_NOT_SET;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      vcolorKey.push_back(colorKey);
      vhbmp.push_back(hbm);
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      vdelay.push_back(pgf->gced.uiDelayTime);      

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) 
          break;
      pgfOld = pgf;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   if (gifimage._gad.cLoops == 0 && gifimage._gad.fLooped != 0)
   {
        *loop = HUGE_VAL;
   }
   else
   {
        *loop = gifimage._gad.cLoops;
   }
   
   *numBitmaps = vhbmp.size();

   // Since the vector will go out of scope, move contents over to heap
   hImage  = (HBITMAP *)MemAlloc(Mt(Mem), vhbmp.size() * sizeof(HBITMAP)); 
   if (NULL == hImage)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *delays = (int*)MemAlloc(Mt(Mem), vhbmp.size() * sizeof(int)); 
   if (NULL == *delays)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *colorKeys = (COLORREF*)MemAlloc(Mt(Mem), sizeof(COLORREF) * vcolorKey.size() ); 
   if (NULL == *colorKeys)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   for(i=0; i < vhbmp.size(); i++) {
      hImage[i] = vhbmp[i];
      (*colorKeys)[i] = vcolorKey[i];
      (*delays)[i] = vdelay[i];
   }

   *ppBitMaps = hImage;

   hr = S_OK;
done:
   if (FAILED(hr))
   {
       MemFree(hImage);
       MemFree(*delays);
       MemFree(*colorKeys);
   }
   return hr;
}

/*lint --flb*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\imagedownload.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\imagedownload.h
//
//  Contents: classes for downloading images
//              CTableBuilder - a utility class to lazy load dlls
//              CImageDownload - Class to download Images
//              CImageDecodeEventSink - Class to recieve image download events
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _IMAGEDOWNLOAD_H
#define _IMAGEDOWNLOAD_H

#include <ocmm.h>
#include "stopstream.h"

class CImageDownload;

#include "playerimage.h"

#include "ddrawex.h"

#include "threadsafelist.h"

typedef HPALETTE (WINAPI *CREATESHPALPROC)(HDC);  
typedef HRESULT (WINAPI *GETINVCMSPPROC)(BYTE *, ULONG);
typedef HRESULT (WINAPI *CREATEURLMONPROC)(IMoniker*, LPWSTR, IMoniker**);
typedef HRESULT (WINAPI *DECODEIMGPROC)(IStream*, IMapMIMEToCLSID*, IImageDecodeEventSink*);
typedef BOOL (WINAPI * TRANSPARENTBLTPROC)(HDC hdcDesc, 
                                           int nXOriginDest, 
                                           int nYOriginDest,
                                           int nWidthDest,
                                           int nHeightDest,
                                           HDC hdcSrc,
                                           int nXOriginSrc,
                                           int nYOriginSrc,
                                           int nWidthSrc,
                                           int nHeightSrc,
                                           UINT crTransparent);

HRESULT
CreateMask(HDC hdcDest, 
           HDC hdcSrc, 
           LONG lWidthSrc, 
           LONG lHeightSrc, 
           COLORREF dwTransColor,
           HBITMAP * phbmpMask,
           bool bWin95Method = false);

HRESULT
MaskTransparentBlt(HDC hdcDest, 
                   LPRECT prcDest, 
                   HDC hdcSrc, 
                   LONG lWidthSrc, 
                   LONG lHeightSrc,
                   HBITMAP hbmpMask);
                                           
class CTableBuilder
{
  public:
    CTableBuilder();
    virtual ~CTableBuilder();

    HRESULT LoadShell8BitServices();
    HRESULT Create8BitPalette(IDirectDraw *pDirectDraw, IDirectDrawPalette **ppPalette);
    HRESULT CreateURLMoniker(IMoniker *pmkContext, LPWSTR szURL, IMoniker **ppmk);
    HRESULT ValidateImgUtil();
    HRESULT DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, IImageDecodeEventSink* pEventSink);
    HRESULT GetTransparentBlt(TRANSPARENTBLTPROC * pProc);
    
  private:
    HINSTANCE           m_hinstSHLWAPI;
    HINSTANCE           m_hinstURLMON;
    HINSTANCE           m_hinstIMGUTIL;
    HINSTANCE           m_hinstMSIMG32;

    CREATESHPALPROC     m_SHCreateShellPalette;
    CREATEURLMONPROC    m_CreateURLMoniker;
    DECODEIMGPROC       m_DecodeImage;
    TRANSPARENTBLTPROC  m_TransparentBlt;
    
    CritSect            m_CriticalSection;
}; // CTableBuilder


class CImageDownload : 
    public ITIMEMediaDownloader,
    public ITIMEImageRender,
    public IBindStatusCallback
{
  public:
    CImageDownload(CAtomTable * pAtomTable);
    virtual ~CImageDownload();

    
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk);

    void CancelDownload();

    STDMETHOD( LoadImage )( const WCHAR * pszFileName,
                            IUnknown *punkDirectDraw,
                            IDirectDrawSurface ** ppDXSurface,
                            CAnimatedGif ** ppAnimatedGif,
                            DWORD *pdwWidth,
                            DWORD *pdwHeight);

    //
    // ITIMEImportMedia
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEMediaDownloader
    //
    STDMETHOD(Init)(long lSrc);
    STDMETHOD(AddImportMedia)(ITIMEImportMedia * pImportMedia);
    STDMETHOD(RemoveImportMedia)(ITIMEImportMedia * pImportMedia);

    //
    // ITIMEImageRender
    //
    STDMETHOD(PutDirectDraw)(IUnknown * punkDD);
    STDMETHOD(Render)(HDC hdc, LPRECT pRect, LONG lFrameNum);
    STDMETHOD(GetSize)(DWORD * pdwWidth, DWORD * pdwHeight);
    STDMETHOD(NeedNewFrame)(double dblNewTime, LONG lOldFrame, LONG * plNewFrame, VARIANT_BOOL * pvb, double dblClipBegin, double dblClipEnd);
    STDMETHOD(GetDuration)(double * pdblDuration);
    STDMETHOD(GetRepeatCount)(double * pdblRepeatCount);

    //
    // IBindStatusCallback
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved);
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);

  protected:
    CImageDownload();
    STDMETHOD( LoadImageFromStream )( IStream *pStream,
                                      IUnknown *punkDirectDraw,
                                      IDirectDrawSurface **ppDDSurface,
                                      DWORD *pdwWidth,
                                      DWORD *pdwHeight);

    STDMETHOD( LoadGif )( IStream * pStream,
                          IUnknown * punkDirectDraw,
                          CAnimatedGif ** ppAnimatedGif,
                          DWORD *pdwWidth,
                          DWORD *pdwHeight,
                          DDPIXELFORMAT * pddpf = NULL);
    STDMETHOD( LoadBMP )( LPWSTR pszBMPFilename,
                          IUnknown * punkDirectDraw,
                          IDirectDrawSurface **ppDDSurface,
                          DWORD * pdwWidth,
                          DWORD * pdwHeight);



  private:
    CStopableStream *   m_pStopableStream;
    LONG                m_cRef;

    long                m_lSrc;

    CThreadSafeList * m_pList;

    DWORD                       m_nativeImageWidth;
    DWORD                       m_nativeImageHeight;

    HBITMAP                     m_hbmpMask;
    CComPtr<IDirectDrawSurface> m_spDDSurface;
    CComPtr<IDirectDraw3>       m_spDD3;

    CAnimatedGif               *m_pAnimatedGif;
    bool                        m_fMediaDecoded;
    bool                        m_fRemovedFromImportManager;
    bool                        m_fMediaCued;
    bool                        m_fAbortDownload;
    
    CritSect                    m_CriticalSection;
    double                      m_dblPriority;

    CAtomTable * GetAtomTable() { return m_pAtomTable; }
    CAtomTable                 *m_pAtomTable;
}; // CImageDownload


class CImageDecodeEventSink : public IImageDecodeEventSink
{
  public:
    CImageDecodeEventSink(IDirectDraw *pDDraw);
    virtual ~CImageDecodeEventSink();

    //=== IUnknown ===============================================
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface);

    //=== IImageDecodeEventSink ==================================
    STDMETHOD(GetSurface)( LONG nWidth, LONG nHeight, REFGUID bfid, 
                           ULONG nPasses, DWORD dwHints, IUnknown** ppSurface);
    STDMETHOD(OnBeginDecode)(DWORD* pdwEvents, ULONG* pnFormats, GUID** ppFormats);
    STDMETHOD(OnBitsComplete)();
    STDMETHOD(OnDecodeComplete)(HRESULT hrStatus);
    STDMETHOD(OnPalette)();
    STDMETHOD(OnProgress)(RECT* pBounds, BOOL bFinal);

    IDirectDrawSurface * Surface() { return m_spDDSurface; }
    DWORD Width() { return m_dwWidth; }
    DWORD Height() { return m_dwHeight; }

  protected:
    CImageDecodeEventSink();

  private:
    long                        m_lRefCount;
    CComPtr<IDirectDraw>        m_spDirectDraw;
    CComPtr<IDirectDrawSurface> m_spDDSurface;
    DWORD                       m_dwHeight;
    DWORD                       m_dwWidth;
}; // CImageDecodeEventSink


#endif // _IMAGEDOWNLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\imagedownload.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\imagedownload.h
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"

#include "imagedownload.h"
#include "playerimage.h"
#include "importman.h"

#include "loader.h"


CTableBuilder g_TableBuilder;

static const TCHAR IMGUTIL_DLL[] = _T("IMGUTIL.DLL");
static const TCHAR SHLWAPI_DLL[] = _T("SHLWAPI.DLL");
static const TCHAR URLMON_DLL[] = _T("URLMON.DLL");
static const TCHAR MSIMG32_DLL[] = _T("MSIMG32.DLL");

static const char DECODEIMAGE[] = "DecodeImage";
static const char SHCREATESHELLPALETTE[] = "SHCreateShellPalette";
static const char CREATEURLMONIKER[] = "CreateURLMoniker";
static const char TRANSPARENTBLT[] = "TransparentBlt";

static const unsigned int NUM_NONPALETTIZED_FORMATS = 3;
static const unsigned int NUM_PALETTIZED_FORMATS = 3;

extern HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP **ppBitMaps);

//+-----------------------------------------------------------------------
//
//  Member:    CTableBuilder
//
//  Overview:  Constructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CTableBuilder::CTableBuilder() :
    m_hinstSHLWAPI(NULL),
    m_hinstURLMON(NULL),
    m_hinstIMGUTIL(NULL),
    m_SHCreateShellPalette(NULL),
    m_CreateURLMoniker(NULL),
    m_DecodeImage(NULL), 
    m_hinstMSIMG32(NULL), 
    m_TransparentBlt(NULL)
{
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CTableBuilder
//
//  Overview:  Destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CTableBuilder::~CTableBuilder()
{
    if (m_hinstSHLWAPI)
    {
        FreeLibrary(m_hinstSHLWAPI);
        m_hinstSHLWAPI = NULL;
    }
    if (m_hinstURLMON)
    {
        FreeLibrary(m_hinstURLMON);
        m_hinstURLMON = NULL;
    }
    if (m_hinstIMGUTIL)
    {
        FreeLibrary(m_hinstIMGUTIL);
        m_hinstIMGUTIL = NULL;
    }
    if (m_hinstMSIMG32)
    {
        FreeLibrary(m_hinstMSIMG32);
        m_hinstMSIMG32 = NULL;
    }

    m_SHCreateShellPalette = NULL;
    m_CreateURLMoniker = NULL;
    m_DecodeImage = NULL;
    m_TransparentBlt = NULL;
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadShell8BitServices
//
//  Overview:  Load shlwapi.dll, save a function pointer to SHCreateShellPalette
//              call SHGetInverseCMAP
//
//  Arguments: void
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::LoadShell8BitServices()
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    if (m_hinstSHLWAPI != NULL)
    {
        hr = S_OK;
        goto done;
    }

    m_hinstSHLWAPI = LoadLibrary(SHLWAPI_DLL);  
    if (NULL == m_hinstSHLWAPI)
    {
        hr = E_FAIL;
        goto done;
    }

    m_SHCreateShellPalette = (CREATESHPALPROC)GetProcAddress(m_hinstSHLWAPI, SHCREATESHELLPALETTE);  
    if (NULL == m_SHCreateShellPalette)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        FreeLibrary(m_hinstSHLWAPI);
        m_hinstSHLWAPI = NULL;
        m_SHCreateShellPalette = NULL;
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Create8BitPalette
//
//  Overview:  Create a direct draw palette from SHCreateShellPalette
//
//  Arguments: pDirectDraw  pointer to direct draw
//             ppPalette    where to store the new palette
//
//  Returns:   S_OK on succees, otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::Create8BitPalette(IDirectDraw *pDirectDraw, IDirectDrawPalette **ppPalette)
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    PALETTEENTRY palentry[256];
    UINT iRetVal = NULL;;
    HPALETTE hpal = NULL;

    if (NULL == m_SHCreateShellPalette)
    {
        Assert(NULL != m_SHCreateShellPalette);
        hr = E_UNEXPECTED;
        goto done;
    }

    hpal = m_SHCreateShellPalette(NULL);
    if (NULL == hpal)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    iRetVal = GetPaletteEntries(hpal, 0, 256, palentry);
    if (NULL == iRetVal)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = pDirectDraw->CreatePalette(DDPCAPS_ALLOW256 | DDPCAPS_8BIT, palentry, ppPalette, NULL); //lint !e620
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (NULL != hpal)
    {
        DeleteObject(hpal);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CreateURLMoniker
//
//  Overview:  Load librarys URLMON, and calls CreateURLMoniker
//
//  Arguments: pmkContext   pointer to base context moniker
//             szURL        name to be parsed
//             ppmk         the IMoniker interface pointer
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::CreateURLMoniker(IMoniker *pmkContext, LPWSTR szURL, IMoniker **ppmk)
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    if (m_hinstURLMON == NULL)
    {
        m_hinstURLMON = LoadLibrary(URLMON_DLL);  
        if (NULL == m_hinstURLMON)
        {
            hr = E_FAIL;
            goto done;
        }
    }

    m_CreateURLMoniker = (CREATEURLMONPROC) ::GetProcAddress(m_hinstURLMON, CREATEURLMONIKER);
    if (NULL == m_CreateURLMoniker )
    {
        hr = E_FAIL;
        goto done;
    }

    hr = (*m_CreateURLMoniker)( pmkContext, szURL, ppmk );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetTransparentBlt
//
//  Overview:  Load librarys MSIMG32 and gets the TransparentBlt function
//
//  Arguments: pProc - where to store the function pointer
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::GetTransparentBlt( TRANSPARENTBLTPROC * pProc )
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    if (m_hinstMSIMG32 == NULL)
    {
        m_hinstMSIMG32 = LoadLibrary(MSIMG32_DLL);  
        if (NULL == m_hinstMSIMG32)
        {
            hr = E_FAIL;
            goto done;
        }
    }

    if (NULL == m_TransparentBlt)
    {
        m_TransparentBlt = (TRANSPARENTBLTPROC) ::GetProcAddress(m_hinstMSIMG32, TRANSPARENTBLT);
        if (NULL == m_TransparentBlt )
        {
            hr = E_FAIL;
            goto done;
        }
    }
    
    if (pProc)
    {
        *pProc = m_TransparentBlt;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ValidateImgUtil
//
//  Overview:  calls loadlibary on IMGUTIL.DLL
//
//  Arguments: void
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
// Need to make sure imgutil.dll is available for LoadImage to work. This function was added
// because of a problem with earlier versions (pre IE4) of urlmon.dll.
HRESULT 
CTableBuilder::ValidateImgUtil()
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;
    
    if (m_hinstIMGUTIL != NULL)
    {
        goto done;
    }

    m_hinstIMGUTIL = LoadLibrary(IMGUTIL_DLL);  
    if (NULL == m_hinstIMGUTIL)
    {
        hr = E_FAIL;
        goto done;
    }

    m_DecodeImage = (DECODEIMGPROC) ::GetProcAddress(m_hinstIMGUTIL, DECODEIMAGE);
    if(NULL == m_DecodeImage)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (NULL != m_hinstIMGUTIL)
        {
            FreeLibrary(m_hinstIMGUTIL);
            m_hinstIMGUTIL = NULL;
        }
        m_DecodeImage = NULL;
    }

    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    DecodeImage
//
//  Overview:  Calls IMGUTIL::DecodeImage to decode an image from a stream.
//
//  Arguments: pStream  stream to decode from
//             pMap     optional map from MIME to classid
//             pEventSink   object to recieve decode process
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, IImageDecodeEventSink* pEventSink )
{
    HRESULT hr = S_OK;

    if (m_hinstIMGUTIL == NULL)
    {
        Assert(NULL != m_hinstIMGUTIL);
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = (*m_DecodeImage)( pStream, pMap, pEventSink );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CImageDownload
//
//  Overview:  Constructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDownload::CImageDownload(CAtomTable * pAtomTable) :
  m_pStopableStream(NULL),
  m_cRef(0),
  m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
  m_pAnimatedGif(NULL),
  m_fMediaDecoded(false),
  m_fMediaCued(false),
  m_fRemovedFromImportManager(false),
  m_pList(NULL),
  m_dblPriority(INFINITE),
  m_nativeImageWidth(0),
  m_nativeImageHeight(0),
  m_pAtomTable(NULL),
  m_hbmpMask(NULL),
  m_fAbortDownload(false)
{
    if (NULL != pAtomTable)
    {
        m_pAtomTable = pAtomTable;
        m_pAtomTable->AddRef();
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CImageDownload
//
//  Overview:  Destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDownload::~CImageDownload()
{
    if (NULL != m_pStopableStream)
    {
        delete m_pStopableStream;
        m_pStopableStream = NULL;
    }

    if (NULL != m_pAnimatedGif)
    {
        m_pAnimatedGif->Release();
        m_pAnimatedGif = NULL;
    }
    
    if (NULL != m_pList)
    {
        IGNORE_HR(m_pList->Detach());
        m_pList->Release();
        m_pList = NULL;
    }
    
    if (NULL != m_pAtomTable)
    {
        m_pAtomTable->Release();
        m_pAtomTable = NULL;
    }

    if (m_hbmpMask)
    {
        DeleteObject(m_hbmpMask);
    }
}

STDMETHODIMP_(ULONG)
CImageDownload::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
} // AddRef


STDMETHODIMP_(ULONG)
CImageDownload::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }
    return l;
} // Release

STDMETHODIMP
CImageDownload::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_POINTER;
    }

    *ppv = NULL;

    if ( IsEqualGUID(riid, IID_IUnknown) )
    {
        *ppv = static_cast<ITIMEMediaDownloader*>(this);
    }
    else if ( IsEqualGUID(riid, IID_ITIMEImportMedia) )
    {
        *ppv = static_cast<ITIMEImportMedia*>(this);
    }
    else if ( IsEqualGUID(riid, IID_ITIMEMediaDownloader) )
    {
        *ppv = static_cast<ITIMEMediaDownloader*>(this);
    }
    else if ( IsEqualGUID(riid, IID_ITIMEImageRender) )
    {
        *ppv = static_cast<ITIMEImageRender*>(this);
    }
    else if (IsEqualGUID(riid, IID_IBindStatusCallback))
    {
        *ppv = static_cast<IBindStatusCallback*>(this);
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP
CImageDownload::Init(long lSrc)
{
    HRESULT hr = S_OK;

    Assert(NULL == m_pStopableStream);
    
    m_pStopableStream = new CStopableStream();
    if (NULL == m_pStopableStream)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    m_pList = new CThreadSafeList;
    if (NULL == m_pList)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    m_pList->AddRef();

    hr = m_pList->Init();
    if (FAILED(hr))
    {
        goto done;
    }

    m_lSrc = lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetPriority(double * dblPriority)
{
    HRESULT hr = S_OK;

    Assert(NULL != dblPriority);

    *dblPriority = m_dblPriority;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::AddImportMedia(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != pImportMedia);

    CritSectGrabber cs(m_CriticalSection);

    m_fAbortDownload = false;
    
    if ( m_fMediaDecoded )
    {
        IGNORE_HR(pImportMedia->CueMedia());
    }
    else 
    {
        double dblPriority;
        hr = pImportMedia->GetPriority(&dblPriority);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (dblPriority < m_dblPriority)
        {
            m_dblPriority = dblPriority;
            hr = GetImportManager()->RePrioritize(this);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        hr = m_pList->Add(pImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::RemoveImportMedia(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = E_FAIL;

    Assert(NULL != pImportMedia);

    hr = m_pList->Remove(pImportMedia);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_fRemovedFromImportManager && 0 == m_pList->Size())
    {
        Assert(NULL != GetImportManager());
        
        CancelDownload();

        hr = GetImportManager()->Remove(this);
        if (FAILED(hr))
        {
            goto done;
        }

        m_fRemovedFromImportManager = true;
    }


done:
    return hr;
}

STDMETHODIMP
CImageDownload::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::CueMedia()
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEImportMedia> spImportMedia;

    const WCHAR * cpchSrc = NULL;
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    // populate the image data
    hr = THR(LoadImage(cpchSrc, m_spDD3, &m_spDDSurface, &m_pAnimatedGif, &m_nativeImageWidth, &m_nativeImageHeight));

    {
        CritSectGrabber cs(m_CriticalSection);        
        m_fMediaDecoded = true;
    }

    while (S_OK == m_pList->GetNextElement(&spImportMedia, false))
    {
        if (spImportMedia != NULL)
        {
            if (FAILED(hr))
            {
                IGNORE_HR(spImportMedia->MediaDownloadError());
            }
            IGNORE_HR(spImportMedia->CueMedia());
        }

        hr = m_pList->ReturnElement(spImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }

        spImportMedia.Release();
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::MediaDownloadError()
{
    return S_OK;
}


STDMETHODIMP
CImageDownload::PutDirectDraw(IUnknown * punkDirectDraw)
{
    HRESULT hr = S_OK;
    Assert(m_spDD3 == NULL);

    hr = punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw3, &m_spDD3));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetSize(DWORD * pdwWidth, DWORD * pdwHeight)
{
    HRESULT hr = S_OK;
    if (NULL == pdwWidth || NULL == pdwHeight)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pdwWidth = m_nativeImageWidth;
    *pdwHeight = m_nativeImageHeight;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::Render(HDC hdc, LPRECT prc, LONG lFrameNum)
{
    HRESULT hr = S_OK;
    HDC hdcSrc = NULL;

    if ( m_spDDSurface )
    {
        hr = THR(m_spDDSurface->GetDC(&hdcSrc));
        if (FAILED(hr))
        {
            goto done;
        }

        if (NULL == m_hbmpMask)
        {            
            DDCOLORKEY ddColorKey;
            COLORREF rgbTransColor;

            hr = THR(m_spDDSurface->GetColorKey(DDCKEY_SRCBLT, &ddColorKey)); //lint !e620
            if (SUCCEEDED(hr) && ddColorKey.dwColorSpaceLowValue != -1 )
            {
                DDPIXELFORMAT ddpf;
                ZeroMemory(&ddpf, sizeof(ddpf));
                ddpf.dwSize = sizeof(ddpf);
                
                hr = THR(m_spDDSurface->GetPixelFormat(&ddpf));
                if (FAILED(hr))
                {
                    goto done;
                }
                
                if (8 == ddpf.dwRGBBitCount)
                {
                    CComPtr<IDirectDrawPalette> spDDPalette;
                    PALETTEENTRY pal;
                    
                    hr = THR(m_spDDSurface->GetPalette(&spDDPalette));
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = THR(spDDPalette->GetEntries(0, ddColorKey.dwColorSpaceLowValue, 1, &pal));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    rgbTransColor = RGB(pal.peRed, pal.peGreen, pal.peBlue);
                }
                else
                {
                    rgbTransColor = ddColorKey.dwColorSpaceLowValue;
                }
                
                hr = THR(CreateMask(hdc, 
                    hdcSrc, 
                    m_nativeImageWidth, 
                    m_nativeImageHeight, 
                    rgbTransColor, 
                    &m_hbmpMask,
                    true));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        
        hr = THR(MaskTransparentBlt(hdc, 
                                    prc, 
                                    hdcSrc, 
                                    m_nativeImageWidth, 
                                    m_nativeImageHeight, 
                                    m_hbmpMask));
                            
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if ( m_pAnimatedGif )
    {
        hr = THR(m_pAnimatedGif->Render(hdc, prc, lFrameNum));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetDuration
//
//  Overview:  If an animated gif is present, returns the duration of frames
//
//  Arguments: pdblDuration     where to store the time, in seconds
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDownload::GetDuration(double * pdblDuration)
{
    HRESULT hr = S_OK;

    if (NULL == pdblDuration)
    {
        hr = E_INVALIDARG;
        goto done;
    }
   
    if (m_pAnimatedGif)
    {
        double dblDuration;
        dblDuration = m_pAnimatedGif->CalcDuration();
        dblDuration /= 1000.0;
        *pdblDuration = dblDuration;
    }
    
    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    GetRepeatCount
//
//  Overview:  if an animated gif is present, returns the number of times to loop
//
//  Arguments: pdblRepeatCount      where to store the repeat count
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDownload::GetRepeatCount(double * pdblRepeatCount)
{
    HRESULT hr = S_OK;

    if (NULL == pdblRepeatCount)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_pAnimatedGif)
    {
        *pdblRepeatCount = m_pAnimatedGif->GetLoop();
    }
    
    hr = S_OK;
done:
    RRETURN(hr);
}

void
CImageDownload::CancelDownload()
{
    m_fAbortDownload = true;
    if (NULL != m_pStopableStream)
    {
        m_pStopableStream->SetCancelled();
    }

    return;
}

STDMETHODIMP
CImageDownload::NeedNewFrame(double dblCurrentTime, LONG lOldFrame, LONG * plNewFrame, VARIANT_BOOL * pvb, double dblClipBegin, double dblClipEnd)
{
    HRESULT hr = S_OK;
    
    if (NULL == plNewFrame)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    if (NULL == pvb)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pvb = VARIANT_FALSE;

    if (NULL != m_pAnimatedGif)
    {
        if (m_pAnimatedGif->NeedNewFrame(dblCurrentTime, lOldFrame, plNewFrame, dblClipBegin, dblClipEnd))
        {
            *pvb = VARIANT_TRUE;
        }
        else
        {
            *pvb = VARIANT_FALSE;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
// Function:   DownloadFile
//
// Overview:   Begins a blocking URLMON download for the given file name,
//             data downloaded is stored in an IStream
//
// Arguments:  pszFileName  URL for file to download
//             ppStream     Where to store the stream interface used to get the data
//
// Returns:    S_OK on download success, 
//
//------------------------------------------------------------------------
HRESULT
DownloadFile(const WCHAR * pszFileName, 
             IStream ** ppStream, 
             LPWSTR* ppszCacheFileName,
             IBindStatusCallback * pBSC)
{
    HRESULT hr = S_OK;
    LPWSTR pszTrimmedName = NULL;
    TCHAR szCacheFileName[MAX_PATH+1];
    CFileStream *pStream = NULL;
    
    if (!pszFileName || !ppStream)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *ppStream = NULL;
    
    pszTrimmedName = TrimCopyString(pszFileName);
    if (NULL == pszTrimmedName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = URLDownloadToCacheFileW(NULL, 
                                 pszTrimmedName, 
                                 szCacheFileName, 
                                 MAX_PATH, 
                                 0, 
                                 pBSC);
    if (FAILED(hr))
    {
        goto done;
    }

    pStream= new CFileStream ( NULL );
    if (NULL == pStream)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = pStream->Open(szCacheFileName, GENERIC_READ);
    if (FAILED(hr))
    {
        goto done;
    }

    if (ppszCacheFileName)
    {
        *ppszCacheFileName = CopyString(szCacheFileName);
        if (NULL == *ppszCacheFileName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    *ppStream = pStream;
    (*ppStream)->AddRef();

    hr = S_OK;
done:
    if (NULL != pszTrimmedName)
    {
        delete[] pszTrimmedName;
    }

    ReleaseInterface(pStream);
    
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadImage
//
//  Overview:  Loads an image into a direct draw surface OR CAnimatedGif
//
//  Arguments: pszFileName      path to image sources
//             pDirectDraw      pointer to direct draw object
//             ppDDSurface      where to store the decoded image
//             ppAnimatedGif    where to store decoded gif image
//             pdwWidth         where to store decoded image width
//             pdwHegiht        where to store decoded image height
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP CImageDownload::LoadImage(const WCHAR * pszFileName,
                                             IUnknown *pDirectDraw,
                                             IDirectDrawSurface ** ppDDSurface, 
                                             CAnimatedGif ** ppAnimatedGif,
                                             DWORD * pdwWidth, DWORD *pdwHeight)
{
    HRESULT hr = S_OK;
    CComPtr<IStream> spStream;
    
    LPWSTR pszTrimmedName = NULL;
    LPWSTR pszCacheFileName = NULL;
    
    if (!pszFileName || !ppDDSurface)
    {
        hr = E_POINTER;
        goto done;
    }
    
    pszTrimmedName = TrimCopyString(pszFileName);
    if (NULL == pszTrimmedName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = ::DownloadFile(pszTrimmedName, &spStream, &pszCacheFileName, this);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pStopableStream != NULL);
    m_pStopableStream->SetStream(spStream);

    hr = g_TableBuilder.ValidateImgUtil();
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (StringEndsIn(pszTrimmedName, L".gif"))
    {
        hr = LoadGif(m_pStopableStream, pDirectDraw, ppAnimatedGif, pdwWidth, pdwHeight);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (StringEndsIn(pszTrimmedName, L".bmp"))
    {
        hr = LoadBMP(pszCacheFileName, pDirectDraw, ppDDSurface, pdwWidth, pdwHeight);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = LoadImageFromStream(m_pStopableStream, pDirectDraw, ppDDSurface, pdwWidth, pdwHeight);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
done:
    delete[] pszTrimmedName;    
    delete[] pszCacheFileName;

    return hr;
} 

HRESULT
CreateSurfacesFromBitmaps(IUnknown * punkDirectDraw, 
                          HBITMAP * phBMPs, 
                          int numGifs, 
                          LONG lWidth, 
                          LONG lHeight, 
                          IDirectDrawSurface** ppDDSurfaces,
                          DDPIXELFORMAT * pddpf)
{
    HRESULT hr = S_OK;

    Assert(punkDirectDraw);
    Assert(phBMPs);
    Assert(ppDDSurfaces);

    CComPtr<IDirectDrawSurface> spDDSurface;
    HDC hdcSurface = NULL;

    CComPtr<IDirectDraw> spDirectDraw;
    int i = 0;
    
    hr = THR(punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw, &spDirectDraw)));
    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0; i < numGifs; i++)
    {
        BOOL bSucceeded = FALSE;
        HGDIOBJ hOldObj = NULL;
        HDC hdcBMP = NULL;

        hr = THR(CreateOffscreenSurface(spDirectDraw, &spDDSurface, pddpf, false, lWidth, lHeight));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(spDDSurface->GetDC(&hdcSurface));
        if (FAILED(hr))
        {
            goto done;
        }

        hdcBMP = CreateCompatibleDC(hdcSurface);
        if (NULL == hdcBMP)
        {
            hr = E_FAIL;
            goto done;
        }

        hOldObj = SelectObject(hdcBMP, phBMPs[i]);
        if (NULL == hOldObj)
        {
            hr = E_FAIL;
            DeleteDC(hdcBMP);
            goto done;
        }

        bSucceeded = BitBlt(hdcSurface, 0, 0, lWidth, lHeight, hdcBMP, 0, 0, SRCCOPY);
        if (FALSE == bSucceeded)
        {
            hr = E_FAIL;
            SelectObject(hdcBMP, hOldObj);
            DeleteDC(hdcBMP);
            goto done;
        }

        ppDDSurfaces[i] = spDDSurface;
        ppDDSurfaces[i]->AddRef();

        SelectObject(hdcBMP, hOldObj);
        DeleteDC(hdcBMP);

        hr = THR(spDDSurface->ReleaseDC(hdcSurface));
        if (FAILED(hr))
        {
            goto done;
        }

        spDDSurface.Release();
        hdcSurface = NULL;

#ifdef NEVER
        // debugging -- blt to the screen. jeffwall 8/30/99
        {
            HDC nulldc = GetDC(NULL);
            HDC surfacedc;
            hr = spDDSurface->GetDC(&surfacedc);
            BitBlt(nulldc, 0, 0, lWidth, lHeight, surfacedc, 0, 0, SRCCOPY);
            hr = spDDSurface->ReleaseDC(surfacedc);
            DeleteDC(nulldc);
        }
#endif
    }


    hr = S_OK;
done:
    if ( spDDSurface != NULL && hdcSurface != NULL)
    {
        THR(spDDSurface->ReleaseDC(hdcSurface));
    }

    return hr;
}

STDMETHODIMP
CImageDownload::LoadBMP(LPWSTR pszBMPFilename,
                        IUnknown * punkDirectDraw,
                        IDirectDrawSurface **ppDDSurface,
                        DWORD * pdwWidth,
                        DWORD * pdwHeight)
{
    HRESULT hr = S_OK;
    CComPtr<IDirectDraw> spDD;
    CComPtr<IDirectDrawSurface> spDDSurface;
    BITMAP bmpSrc;
    HBITMAP hbmpSrc = NULL;
    HGDIOBJ hbmpOld = NULL;
    HDC hdcDest = NULL;
    HDC hdcSrc = NULL;
    BOOL bRet;
    int iRet;

    hbmpSrc = (HBITMAP)::LoadImage(NULL, pszBMPFilename, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE);
    if (NULL == hbmpSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    
    ZeroMemory(&bmpSrc, sizeof(bmpSrc));    
    iRet = GetObject(hbmpSrc, sizeof(bmpSrc), &bmpSrc);
    if (0 == iRet)
    {
        hr = E_FAIL;
        goto done;
    }

    hdcSrc = CreateCompatibleDC(NULL);
    if (NULL == hdcSrc)
    {
        hr = E_FAIL;
        goto done;
    }

    hbmpOld = SelectObject(hdcSrc, hbmpSrc);
    if (NULL == hbmpOld)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw, &spDD)));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(CreateOffscreenSurface(spDD, &spDDSurface, NULL, false, bmpSrc.bmWidth, bmpSrc.bmHeight));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spDDSurface->GetDC(&hdcDest));
    if (FAILED(hr))
    {
        goto done;
    }
    
    bRet = BitBlt(hdcDest, 0, 0, bmpSrc.bmWidth, bmpSrc.bmHeight, hdcSrc, 0, 0, SRCCOPY);
    if (FALSE == bRet)
    {
        hr = E_FAIL;
        goto done;
    }

    // everything worked
    *pdwWidth = bmpSrc.bmWidth;
    *pdwHeight = bmpSrc.bmHeight;
    *ppDDSurface = spDDSurface;
    (*ppDDSurface)->AddRef();

    hr = S_OK;
done:
    if (hdcDest)
    {
        IGNORE_HR(spDDSurface->ReleaseDC(hdcDest));
    }
    if (hbmpOld)
    {
        SelectObject(hdcSrc, hbmpOld);
    }
    if (hdcSrc)
    {
        DeleteDC(hdcSrc);
    }
    if (hbmpSrc)
    {
        DeleteObject(hbmpSrc);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadGif
//
//  Overview:  Given an IStream, decode a gif into an allocated CAnimatedGif
//
//  Arguments: pStream      data source
//             ppAnimatedGif    where to store allocated CAnimatedGif
//             pdwWidth     where to store image width
//             pdwHeight    where to store image height
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDownload::LoadGif(IStream * pStream,
                          IUnknown * punkDirectDraw,
                          CAnimatedGif ** ppAnimatedGif,
                          DWORD *pdwWidth,
                          DWORD *pdwHeight,
                          DDPIXELFORMAT * pddpf /* = NULL */)
{
    HRESULT hr = S_OK;

    CAnimatedGif * pAnimatedGif = NULL;

    HBITMAP * phBMPs = NULL;
    int numGifs = 0;
    double loop = 0;
    int * pDelays = NULL;
    COLORREF * pColorKeys = NULL;
    IDirectDrawSurface ** ppDDSurfaces = NULL;
    int i = 0;

    if (NULL == ppAnimatedGif)
    {
        hr = E_POINTER;
        goto done;
    }
    if (NULL == pdwWidth || NULL == pdwHeight)
    {
        hr = E_POINTER;
        goto done;
    }

    pAnimatedGif = new CAnimatedGif;
    if (NULL == pAnimatedGif)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // self managed object, does its own deletion.
    pAnimatedGif->AddRef();
    hr = THR(pAnimatedGif->Init(punkDirectDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = LoadGifImage(pStream,
                      &pColorKeys,
                      &numGifs,
                      &pDelays,
                      &loop, 
                      &phBMPs);
    if (FAILED(hr))
    {
        goto done;
    }

    pAnimatedGif->PutNumGifs(numGifs);
    pAnimatedGif->PutDelays(pDelays);
    pAnimatedGif->PutLoop(loop);

    ppDDSurfaces = (IDirectDrawSurface**)MemAllocClear(Mt(Mem), numGifs*sizeof(IDirectDrawSurface*));
    if (NULL == ppDDSurfaces)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    pAnimatedGif->PutDDSurfaces(ppDDSurfaces);

    BITMAP bmpData;
    i = GetObject(phBMPs[0], sizeof(bmpData), &bmpData);
    if (0 == i)
    {
        hr = E_FAIL;
        goto done;
    }

    pAnimatedGif->PutWidth(bmpData.bmWidth);
    pAnimatedGif->PutHeight(bmpData.bmHeight);
    pAnimatedGif->PutColorKeys(pColorKeys);
    
    *pdwWidth = bmpData.bmWidth;
    *pdwHeight = bmpData.bmHeight;

    hr = THR(CreateSurfacesFromBitmaps(punkDirectDraw, phBMPs, numGifs, bmpData.bmWidth, bmpData.bmHeight, ppDDSurfaces, pddpf));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pAnimatedGif->CreateMasks();
    if (FAILED(hr))
    {
        goto done;
    }
    
#ifdef NEVER
    // debugging -- blt to screen. jeffwall 9/7/99
    for (i = 0; i < numGifs; i++)
    {
        // debugging -- blt to the screen. jeffwall 8/30/99
        HDC nulldc = GetDC(NULL);
        hr = GetLastError();
        HDC hdcFoo = CreateCompatibleDC(nulldc);
        hr = GetLastError();

        HGDIOBJ hOldObj = SelectObject(hdcFoo, phBMPs[i]);

        BitBlt(nulldc, 0, 0, bmpData.bmWidth, bmpData.bmHeight, hdcFoo, 0, 0, SRCCOPY);
        Sleep(pDelays[i]);

        SelectObject(hdcFoo, hOldObj);

        DeleteDC(hdcFoo);
        DeleteDC(nulldc);

    }
#endif

    *ppAnimatedGif = pAnimatedGif;

    hr = S_OK;
done:
    if (NULL != phBMPs)
    {
        for (i = 0; i < numGifs; i++)
        {
            if (NULL != phBMPs[i])
            {
                BOOL bSucceeded;
                bSucceeded = DeleteObject(phBMPs[i]);
                if (FALSE == bSucceeded)
                {
                    Assert(false && "A bitmap was still selected into a DC");
                }
            }
        }
        MemFree(phBMPs);
    }
    if (FAILED(hr))
    {
        if (NULL != pAnimatedGif)
        {
            pAnimatedGif->Release();
        }
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadImageFromStream
//
//  Overview:  Given an IStream, decode an image into a direct draw surface
//
//  Arguments: pStream      data source
//             pDirectDraw  pointer to direct draw
//             ppDDSurface  where to store the decoded image
//             pdwWidth     where to store image width
//             pdwHeight    where to store image height
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP CImageDownload::LoadImageFromStream(IStream *pStream,
                                                       IUnknown *pDirectDraw,
                                                       IDirectDrawSurface **ppDDSurface, 
                                                       DWORD *pdwWidth, DWORD *pdwHeight)
{
    HRESULT hr = S_OK;
    CComPtr <IDirectDraw> spDDraw;
    CImageDecodeEventSink * pImageEventSink = NULL;

    hr = g_TableBuilder.ValidateImgUtil();
    if (FAILED(hr)) 
    {
        goto done;
    }

    // validate arguments
    if (NULL == pStream)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (NULL == ppDDSurface)
    {
        hr = E_POINTER;
        goto done;
    }

    if (NULL == pDirectDraw)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = pDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw, &spDDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    pImageEventSink = new CImageDecodeEventSink(spDDraw);
    if (NULL == pImageEventSink)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    pImageEventSink->AddRef();

    //--- Using g_TableBuilder as it's a static class that performs lazy
    // loading of dlls.  Here we're loading ImgUtil.dll.
    hr = g_TableBuilder.DecodeImage(pStream, NULL, pImageEventSink);
    if (FAILED(hr))
    {
        goto done;
    }

    // it is possible for the previous call to succeed, but not to return a surface
    *ppDDSurface = pImageEventSink->Surface();
    if (NULL == (*ppDDSurface))
    {
        hr = E_FAIL;
        goto done;
    }

    (*ppDDSurface)->AddRef();

    *pdwWidth = pImageEventSink->Width();
    *pdwHeight = pImageEventSink->Height();

    hr = S_OK;
done:
    ReleaseInterface(pImageEventSink);
    return hr;
} 

STDMETHODIMP
CImageDownload::OnStartBinding( 
                                  /* [in] */ DWORD dwReserved,
                                  /* [in] */ IBinding __RPC_FAR *pib)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::GetPriority( 
                               /* [out] */ LONG __RPC_FAR *pnPriority)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnLowResource( 
                                 /* [in] */ DWORD reserved)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnProgress( 
                              /* [in] */ ULONG ulProgress,
                              /* [in] */ ULONG ulProgressMax,
                              /* [in] */ ULONG ulStatusCode,
                              /* [in] */ LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if (m_fAbortDownload)
    {
        hr = E_ABORT;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN1(hr, E_ABORT);
}

STDMETHODIMP
CImageDownload::OnStopBinding( 
                                 /* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::GetBindInfo( 
                               /* [out] */ DWORD __RPC_FAR *grfBINDF,
                               /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnDataAvailable( 
                                   /* [in] */ DWORD grfBSCF,
                                   /* [in] */ DWORD dwSize,
                                   /* [in] */ FORMATETC __RPC_FAR *pformatetc,
                                   /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnObjectAvailable( 
                                     /* [in] */ REFIID riid,
                                     /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------
//
//  Member:    CImageDecodeEventSink
//
//  Overview:  constructor
//
//  Arguments: pDDraw   pointer to direct draw object
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDecodeEventSink::CImageDecodeEventSink(IDirectDraw *pDDraw) :
    m_lRefCount(0),
    m_spDirectDraw(pDDraw),
    m_spDDSurface(NULL),
    m_dwWidth(0),
    m_dwHeight(0)
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CImageDecodeEventSink
//
//  Overview:  destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDecodeEventSink::~CImageDecodeEventSink()
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    QueryInterface
//
//  Overview:  COM casting method
//
//  Arguments: riid     interface requested
//             ppv      where to store interface
//
//  Returns:   S_OK if interface is supported, otherwise E_NOINTERFACE
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::QueryInterface(REFIID riid, void ** ppv)
{
    if (NULL == ppv)
    {
        return E_POINTER;
    }

    *ppv = NULL;

    if (IsEqualGUID(riid, IID_IUnknown))
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else if (IsEqualGUID(riid, IID_IImageDecodeEventSink))
    {
        *ppv = static_cast<IImageDecodeEventSink*>(this);
    }
    
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;

}

//+-----------------------------------------------------------------------
//
//  Member:    AddRef
//
//  Overview:  Increments object reference count
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CImageDecodeEventSink::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

//+-----------------------------------------------------------------------
//
//  Member:    Release
//
//  Overview:  Decrements object reference count.  Deletes object when =0
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CImageDecodeEventSink::Release()
{
    ULONG l = InterlockedDecrement(&m_lRefCount);
    if (l == 0)
        delete this;
    return l;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetSurface
//
//  Overview:  
//
//  Arguments: nWidth   image width
//             nHeight  image height
//             bfid     format for surface
//             nPasses  number of passes required, unused
//             dwHints  hints, unused
//             ppSurface    where to store created surface
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::GetSurface(LONG nWidth, LONG nHeight, REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown ** ppSurface)
{
    HRESULT hr = S_OK;

    if (NULL == ppSurface)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    *ppSurface = NULL;

    m_dwWidth = nWidth;
    m_dwHeight = nHeight;

    DDPIXELFORMAT ddpf;
    ZeroMemory(&ddpf, sizeof(ddpf));
    ddpf.dwSize = sizeof(ddpf);

    if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8))
    {
        ddpf.dwRGBBitCount = 8;
        ddpf.dwFlags |= DDPF_RGB;                   //lint !e620
        ddpf.dwFlags |= DDPF_PALETTEINDEXED8 ;      //lint !e620
    }
    else if (IsEqualGUID(bfid, BFID_RGB_24))
    {
        ddpf.dwFlags = DDPF_RGB;                    //lint !e620
        ddpf.dwRGBBitCount = 24;
        ddpf.dwBBitMask = 0x000000FF;
        ddpf.dwGBitMask = 0x0000FF00;
        ddpf.dwRBitMask = 0x00FF0000;
        ddpf.dwRGBAlphaBitMask = 0;
    }
    else if (IsEqualGUID(bfid, BFID_RGB_32))
    {
        ddpf.dwFlags = DDPF_RGB;                    //lint !e620
        ddpf.dwRGBBitCount = 32;
        ddpf.dwBBitMask = 0x000000FF;
        ddpf.dwGBitMask = 0x0000FF00;
        ddpf.dwRBitMask = 0x00FF0000;
        ddpf.dwRGBAlphaBitMask = 0;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = CreateOffscreenSurface(m_spDirectDraw, &m_spDDSurface, &ddpf, false, nWidth, nHeight);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (8 == ddpf.dwRGBBitCount)
    {
        CComPtr<IDirectDrawPalette> spDDPal;

        hr = g_TableBuilder.LoadShell8BitServices();
        if (FAILED(hr))
        {
            goto done;
        }

        hr = g_TableBuilder.Create8BitPalette(m_spDirectDraw, &spDDPal);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDDSurface->SetPalette(spDDPal);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = m_spDDSurface->QueryInterface(IID_TO_PPV(IUnknown, ppSurface));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnBeginDecode
//
//  Overview:  Determine which image formats are supported
//
//  Arguments: pdwEvents    which events this is interested in receiving
//             pnFormats    where to store number of formats supported
//             ppFormats    where to store GUIDs for supported formats (allocated here)
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnBeginDecode(DWORD * pdwEvents, ULONG * pnFormats, GUID ** ppFormats)
{
    HRESULT hr = S_OK;
    GUID *pFormats = NULL;

    if (pdwEvents == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    if (pnFormats == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    if (ppFormats == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    *pdwEvents = 0;
    *pnFormats = 0;
    *ppFormats = NULL;
    
    
    if (IsPalettizedDisplay())
    {
        pFormats = (GUID*)CoTaskMemAlloc(NUM_PALETTIZED_FORMATS * sizeof(GUID));
    }
    else
    {
        pFormats = (GUID*)CoTaskMemAlloc(NUM_NONPALETTIZED_FORMATS * sizeof(GUID));
    }
    if(pFormats == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    

    if (IsPalettizedDisplay())
    {
        pFormats[0] = BFID_INDEXED_RGB_8;
        pFormats[1] = BFID_RGB_24;
        pFormats[2] = BFID_RGB_32;
        *pnFormats = NUM_PALETTIZED_FORMATS;
    }
    else
    {
        pFormats[0] = BFID_RGB_32;
        pFormats[1] = BFID_RGB_24;
        pFormats[2] = BFID_INDEXED_RGB_8;
        *pnFormats = NUM_NONPALETTIZED_FORMATS;
    }
    
    *ppFormats = pFormats;
    *pdwEvents = IMGDECODE_EVENT_PALETTE|IMGDECODE_EVENT_BITSCOMPLETE
                |IMGDECODE_EVENT_PROGRESS|IMGDECODE_EVENT_USEDDRAW;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnBitsComplete
//
//  Overview:  when image bits are downloaded, called by filter
//
//  Arguments: void
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnBitsComplete()
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnDecodeComplete
//
//  Overview:  when image is decoded, called by filter
//
//  Arguments: hrStatus     unused
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnDecodeComplete(HRESULT hrStatus)
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnPalette
//
//  Overview:  when palette associated with surface changes, called by filter
//
//  Arguments: void
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnPalette()
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnProgress
//
//  Overview:  when incremental progress is made on decode, called by filter
//
//  Arguments: pBounds      rectangle where progress was made
//             bFinal       If this is the final pass for this rectangle
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnProgress(RECT *pBounds, BOOL bFinal)
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\mixerocx.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Tue May 11 16:16:59 1999
 */
/* Compiler settings for mixerocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mixerocx_h__
#define __mixerocx_h__

/* Forward Declarations */ 

#ifndef __IMixerOCXNotify_FWD_DEFINED__
#define __IMixerOCXNotify_FWD_DEFINED__
typedef interface IMixerOCXNotify IMixerOCXNotify;
#endif 	/* __IMixerOCXNotify_FWD_DEFINED__ */


#ifndef __IMixerOCX_FWD_DEFINED__
#define __IMixerOCX_FWD_DEFINED__
typedef interface IMixerOCX IMixerOCX;
#endif 	/* __IMixerOCX_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IMixerOCXNotify_INTERFACE_DEFINED__
#define __IMixerOCXNotify_INTERFACE_DEFINED__

/* interface IMixerOCXNotify */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMixerOCXNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81A3BD31-DEE1-11d1-8508-00A0C91F9CA0")
    IMixerOCXNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnInvalidateRect( 
            /* [in] */ LPCRECT lpcRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ ULONG ulStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataChange( 
            /* [in] */ ULONG ulDataFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMixerOCXNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMixerOCXNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMixerOCXNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMixerOCXNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnInvalidateRect )( 
            IMixerOCXNotify __RPC_FAR * This,
            /* [in] */ LPCRECT lpcRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatusChange )( 
            IMixerOCXNotify __RPC_FAR * This,
            /* [in] */ ULONG ulStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataChange )( 
            IMixerOCXNotify __RPC_FAR * This,
            /* [in] */ ULONG ulDataFlags);
        
        END_INTERFACE
    } IMixerOCXNotifyVtbl;

    interface IMixerOCXNotify
    {
        CONST_VTBL struct IMixerOCXNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMixerOCXNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMixerOCXNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMixerOCXNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMixerOCXNotify_OnInvalidateRect(This,lpcRect)	\
    (This)->lpVtbl -> OnInvalidateRect(This,lpcRect)

#define IMixerOCXNotify_OnStatusChange(This,ulStatusFlags)	\
    (This)->lpVtbl -> OnStatusChange(This,ulStatusFlags)

#define IMixerOCXNotify_OnDataChange(This,ulDataFlags)	\
    (This)->lpVtbl -> OnDataChange(This,ulDataFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMixerOCXNotify_OnInvalidateRect_Proxy( 
    IMixerOCXNotify __RPC_FAR * This,
    /* [in] */ LPCRECT lpcRect);


void __RPC_STUB IMixerOCXNotify_OnInvalidateRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCXNotify_OnStatusChange_Proxy( 
    IMixerOCXNotify __RPC_FAR * This,
    /* [in] */ ULONG ulStatusFlags);


void __RPC_STUB IMixerOCXNotify_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCXNotify_OnDataChange_Proxy( 
    IMixerOCXNotify __RPC_FAR * This,
    /* [in] */ ULONG ulDataFlags);


void __RPC_STUB IMixerOCXNotify_OnDataChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMixerOCXNotify_INTERFACE_DEFINED__ */


#ifndef __IMixerOCX_INTERFACE_DEFINED__
#define __IMixerOCX_INTERFACE_DEFINED__

/* interface IMixerOCX */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMixerOCX;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81A3BD32-DEE1-11d1-8508-00A0C91F9CA0")
    IMixerOCX : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDisplayChange( 
            /* [in] */ ULONG ulBitsPerPixel,
            /* [in] */ ULONG ulScreenWidth,
            /* [in] */ ULONG ulScreenHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatio( 
            /* [out] */ LPDWORD pdwPictAspectRatioX,
            /* [out] */ LPDWORD pdwPictAspectRatioY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoSize( 
            /* [out] */ LPDWORD pdwVideoWidth,
            /* [out] */ LPDWORD pdwVideoHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ LPDWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDraw( 
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECT prcDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDrawRegion( 
            /* [in] */ LPPOINT lpptTopLeftSC,
            /* [in] */ LPCRECT prcDrawCC,
            /* [in] */ LPCRECT lprcClip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IMixerOCXNotify __RPC_FAR *pmdns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnAdvise( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMixerOCXVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMixerOCX __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMixerOCX __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMixerOCX __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDisplayChange )( 
            IMixerOCX __RPC_FAR * This,
            /* [in] */ ULONG ulBitsPerPixel,
            /* [in] */ ULONG ulScreenWidth,
            /* [in] */ ULONG ulScreenHeight);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAspectRatio )( 
            IMixerOCX __RPC_FAR * This,
            /* [out] */ LPDWORD pdwPictAspectRatioX,
            /* [out] */ LPDWORD pdwPictAspectRatioY);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVideoSize )( 
            IMixerOCX __RPC_FAR * This,
            /* [out] */ LPDWORD pdwVideoWidth,
            /* [out] */ LPDWORD pdwVideoHeight);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMixerOCX __RPC_FAR * This,
            /* [out] */ LPDWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDraw )( 
            IMixerOCX __RPC_FAR * This,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECT prcDraw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDrawRegion )( 
            IMixerOCX __RPC_FAR * This,
            /* [in] */ LPPOINT lpptTopLeftSC,
            /* [in] */ LPCRECT prcDrawCC,
            /* [in] */ LPCRECT lprcClip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IMixerOCX __RPC_FAR * This,
            /* [in] */ IMixerOCXNotify __RPC_FAR *pmdns);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnAdvise )( 
            IMixerOCX __RPC_FAR * This);
        
        END_INTERFACE
    } IMixerOCXVtbl;

    interface IMixerOCX
    {
        CONST_VTBL struct IMixerOCXVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMixerOCX_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMixerOCX_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMixerOCX_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMixerOCX_OnDisplayChange(This,ulBitsPerPixel,ulScreenWidth,ulScreenHeight)	\
    (This)->lpVtbl -> OnDisplayChange(This,ulBitsPerPixel,ulScreenWidth,ulScreenHeight)

#define IMixerOCX_GetAspectRatio(This,pdwPictAspectRatioX,pdwPictAspectRatioY)	\
    (This)->lpVtbl -> GetAspectRatio(This,pdwPictAspectRatioX,pdwPictAspectRatioY)

#define IMixerOCX_GetVideoSize(This,pdwVideoWidth,pdwVideoHeight)	\
    (This)->lpVtbl -> GetVideoSize(This,pdwVideoWidth,pdwVideoHeight)

#define IMixerOCX_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define IMixerOCX_OnDraw(This,hdcDraw,prcDraw)	\
    (This)->lpVtbl -> OnDraw(This,hdcDraw,prcDraw)

#define IMixerOCX_SetDrawRegion(This,lpptTopLeftSC,prcDrawCC,lprcClip)	\
    (This)->lpVtbl -> SetDrawRegion(This,lpptTopLeftSC,prcDrawCC,lprcClip)

#define IMixerOCX_Advise(This,pmdns)	\
    (This)->lpVtbl -> Advise(This,pmdns)

#define IMixerOCX_UnAdvise(This)	\
    (This)->lpVtbl -> UnAdvise(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMixerOCX_OnDisplayChange_Proxy( 
    IMixerOCX __RPC_FAR * This,
    /* [in] */ ULONG ulBitsPerPixel,
    /* [in] */ ULONG ulScreenWidth,
    /* [in] */ ULONG ulScreenHeight);


void __RPC_STUB IMixerOCX_OnDisplayChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCX_GetAspectRatio_Proxy( 
    IMixerOCX __RPC_FAR * This,
    /* [out] */ LPDWORD pdwPictAspectRatioX,
    /* [out] */ LPDWORD pdwPictAspectRatioY);


void __RPC_STUB IMixerOCX_GetAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCX_GetVideoSize_Proxy( 
    IMixerOCX __RPC_FAR * This,
    /* [out] */ LPDWORD pdwVideoWidth,
    /* [out] */ LPDWORD pdwVideoHeight);


void __RPC_STUB IMixerOCX_GetVideoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCX_GetStatus_Proxy( 
    IMixerOCX __RPC_FAR * This,
    /* [out] */ LPDWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IMixerOCX_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCX_OnDraw_Proxy( 
    IMixerOCX __RPC_FAR * This,
    /* [in] */ HDC hdcDraw,
    /* [in] */ LPCRECT prcDraw);


void __RPC_STUB IMixerOCX_OnDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCX_SetDrawRegion_Proxy( 
    IMixerOCX __RPC_FAR * This,
    /* [in] */ LPPOINT lpptTopLeftSC,
    /* [in] */ LPCRECT prcDrawCC,
    /* [in] */ LPCRECT lprcClip);


void __RPC_STUB IMixerOCX_SetDrawRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCX_Advise_Proxy( 
    IMixerOCX __RPC_FAR * This,
    /* [in] */ IMixerOCXNotify __RPC_FAR *pmdns);


void __RPC_STUB IMixerOCX_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMixerOCX_UnAdvise_Proxy( 
    IMixerOCX __RPC_FAR * This);


void __RPC_STUB IMixerOCX_UnAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMixerOCX_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HDC_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HDC __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HDC_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HDC __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HDC_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HDC __RPC_FAR * ); 
void                      __RPC_USER  HDC_UserFree(     unsigned long __RPC_FAR *, HDC __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\mediaelm.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\mediaelm.h
//
//  Contents: TIME media behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _MEDIAELM_H
#define _MEDIAELM_H


#include "timeelmimpl.h"
#include "playerbase.h"
#include "playlistdelegator.h"
#include "mediaprivate.h"
#include "transsite.h"

interface ITransitionElement;
interface ITIMETransitionSite;

interface ITIMEPlayerSite
{
    //when players know their native size they call NegotiateSize. This allows the media
    //element to properly determine it's size.
    virtual void FireMediaEvent(PLAYER_EVENT plEvent) = 0;
    virtual HRESULT GetPropBag(IPropertyBag2 ** ppPropBag, IErrorLog ** ppErrorLog) = 0;
    virtual HRESULT NegotiateSize(RECT &nativeSize, RECT &finalSize, bool &fIsNative, bool fResetRs) = 0;
    virtual void InvalidateElement(LPCRECT lprect) = 0;
    virtual HRESULT PutNaturalRepeatCount(double dblRepeatCount) = 0;

    virtual HRESULT PutNaturalDuration(double dblNatDur) = 0;
    virtual HRESULT ClearNaturalDuration() = 0;
    virtual void ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool & fPlayAnimations) = 0;

    virtual bool isNaturalDuration() = 0;
    virtual void clearNaturalDuration() = 0;
    virtual void setNaturalDuration() = 0;
};


//+-------------------------------------------------------------------------------------
//
// CTIMEMediaElement
//
//--------------------------------------------------------------------------------------

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEMediaElement :
    public CTIMEElementImpl<ITIMEMediaElement2, &IID_ITIMEMediaElement2>,
    public CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>,
    public ISupportErrorInfoImpl<&IID_ITIMEMediaElement>,
    public IConnectionPointContainerImpl<CTIMEMediaElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEMediaElement>,
    public IPropertyNotifySink,
    public ITIMEPlayerSite,
    public IElementBehaviorRender,
    public IHTMLPainter,
    public IHTMLPainterOverlay,
    public ITIMETransitionSite,
    public ITIMEMediaNative,
    public ITIMEContentPlayerSite
{

  public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMEMediaElement();
    virtual ~CTIMEMediaElement();

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEMediaElement"); }
#endif

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // IElementBehaviorRender
    //

    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);
    STDMETHOD(HitTestPoint)(LPPOINT point,
                            IUnknown *pReserved,
                            BOOL *hit);

    virtual void InvalidateRenderInfo();

    //
    // IHTMLPainter
    //
    STDMETHOD(Draw)(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject);
    STDMETHOD(GetPainterInfo)(HTML_PAINTER_INFO* pInfo);
    STDMETHOD(HitTestPoint)(POINT pt, BOOL* pbHit, LONG *plPartID);
    STDMETHOD(OnResize)(SIZE size);


    //
    // IHTMLPainterOverlay

    STDMETHOD(OnMove)(RECT rcDevice);
    
    //
    // ITIMEMediaElement
    //

    // XML Attributes

    STDMETHOD(get_clipBegin)(VARIANT * pvar);
    STDMETHOD(put_clipBegin)(VARIANT var);

    STDMETHOD(get_clipEnd)(VARIANT * pvar);
    STDMETHOD(put_clipEnd)(VARIANT var);

    STDMETHOD(get_player)(VARIANT * clsid);
    STDMETHOD(put_player)(VARIANT clsid);
    
    STDMETHOD(get_src)(VARIANT * url);
    STDMETHOD(put_src)(VARIANT url);

    STDMETHOD(get_type)(VARIANT * type);
    STDMETHOD(put_type)(VARIANT type);
    
    // Properties

    STDMETHOD(get_abstract)(BSTR *abstract);

    STDMETHOD(get_author)(BSTR *auth);

    STDMETHOD(get_copyright)(BSTR *cpyrght);

    STDMETHOD(get_hasAudio)(VARIANT_BOOL * pvbVal);

    STDMETHOD(get_hasVisual)(VARIANT_BOOL * pvbVal);

    STDMETHOD(get_mediaDur)(double * dur);
    
    STDMETHOD(get_mediaHeight)(long *height);

    STDMETHOD(get_mediaWidth)(long *width);

    STDMETHOD(get_playerObject)(IDispatch **ppDisp);

    STDMETHOD(get_playList)(ITIMEPlayList** ppPlayList);

    STDMETHOD(get_rating)(BSTR *rate);

    STDMETHOD(get_title)(BSTR *title);

    STDMETHOD(get_hasPlayList)(VARIANT_BOOL * pvbVal);

    // Media Caps

    STDMETHOD(get_canSeek)(/*[out, retval]*/ VARIANT_BOOL * pvbVal);

    STDMETHOD(get_canPause)(/*[out, retval]*/ VARIANT_BOOL * pvbVal);
    
    STDMETHOD(get_earliestMediaTime)(VARIANT * earliestMediaTime);
    STDMETHOD(get_latestMediaTime)(VARIANT * latestMediaTime);
    STDMETHOD(put_minBufferedMediaDur)(VARIANT minBufferedMediaDur);
    STDMETHOD(get_minBufferedMediaDur)(VARIANT * minBufferedMediaDur);
    STDMETHOD(get_downloadTotal)(VARIANT * earliestMediaTime);
    STDMETHOD(get_downloadCurrent)(VARIANT * latestMediaTime);
    STDMETHOD(get_isStreamed)(VARIANT_BOOL * isStreamed);
    STDMETHOD(get_bufferingProgress)(VARIANT * bufferingProgress);
    STDMETHOD(get_hasDownloadProgress)(VARIANT_BOOL * hasDownloadProgress);
    STDMETHOD(get_mimeType)(BSTR *mimeType);
    STDMETHOD(seekToFrame)(long);
    STDMETHOD(decodeMimeType)(TCHAR * header, long headerSize, BSTR * mimeType);
    STDMETHOD(get_currentFrame)(long *currFrame);
    STDMETHOD(get_downloadProgress)(VARIANT * downloadProgress);

    //
    // ITIMETransitionSite
    //
    STDMETHOD(InitTransitionSite) (void);
    STDMETHOD(DetachTransitionSite) (void);
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b)
    { return CTIMEElementBase::SetDrawFlag(b); }
    STDMETHOD(get_node)(ITIMENode ** ppNode)
    { return CTIMEElementBase::get_node(ppNode); }
    STDMETHOD(get_timeParentNode)(ITIMENode  ** ppNode)
    { return CTIMEElementBase::get_timeParentNode(ppNode); }
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event)
    { return CTIMEElementBase::FireTransitionEvent(event); }

    //
    // ITIMEMediaNative
    //
    STDMETHOD(seekActiveTrack)(double dblSeekTime);
    STDMETHOD(get_activeTrackTime)(double *dblActiveTrackTime);

    //
    // ITIMEContentPlayerSite
    //
    STDMETHOD(GetEventRelaySite)(IUnknown **ppiEventRelaySite);

    //
    // IPersistPropertyBag2
    // 

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)(void) { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)(void) { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag, IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // IPropertyNotifySink methods
    //

    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);
    STDMETHODIMP Invoke(DISPID id,
                        REFIID riid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pvarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

    //
    // overridden member of CTIMEEventSite
    //

    STDMETHOD(onPauseEvent)(float time, float fOffset);

    //
    // Event Handlers
    //

    virtual void OnLoad();
    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnUpdate(double dblLocalTime, DWORD flags);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnRepeat(double dblLocalTime);
    virtual void OnUnload();
    virtual void OnSeek(double dblLocalTime);
    virtual void OnTEPropChange(DWORD tePropType);
    virtual void UpdateSync();
    HRESULT PauseTimeSubTree();


    //TimeAction methods

    virtual bool ToggleTimeAction(bool on);

    //
    // QI Map
    //

    BEGIN_COM_MAP(CTIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEMediaElement2)
        COM_INTERFACE_ENTRY(ITIMEMediaNative)
        COM_INTERFACE_ENTRY(ITIMEContentPlayerSite)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
        COM_INTERFACE_ENTRY(IElementBehaviorRender)
        COM_INTERFACE_ENTRY(IHTMLPainter)
        COM_INTERFACE_ENTRY(IHTMLPainterOverlay)
        COM_INTERFACE_ENTRY(ITIMETransitionSite)
    END_COM_MAP();

    //
    // Connection Point to allow IPropertyNotifySink
    //

    BEGIN_CONNECTION_POINT_MAP(CTIMEMediaElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    //

    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEMediaElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);

    //
    // Needed by CBvrBase
    //

    void * GetInstance() { return (ITIMEMediaElement *) this; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo) { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // Sizing flag

    //
    // Persistence helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void);

    //
    // Misc. methods
    //
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void    StopRootTime(MMTimeline * tl);

    bool                IsFilterAttached();
    virtual bool        IsMedia() const          { return true; }
    virtual TimeState   GetTimeState();
    virtual HRESULT     GetSyncMaster(double & dblNewSegmentTime,
                                      LONG & lNewRepeatCount,
                                      bool & bCueing);
    virtual HRESULT     GetSize(RECT *prcPos);
    virtual HRESULT     SetSize(const RECT *prcPos);
    STDMETHOD           (CascadedPropertyChanged)(bool fNotifyChildren);

    // Player Site methods.

    bool                isNaturalDuration()     { return m_fDurationIsNatural; }
    void                clearNaturalDuration()  { m_fDurationIsNatural = false; }
    void                setNaturalDuration()    { m_fDurationIsNatural = true; }
    virtual bool        ContainsMediaElement()  { return true; }

    HRESULT             GetPropBag(IPropertyBag2 ** ppPropBag, IErrorLog ** ppErrorLog);
    HRESULT             NegotiateSize(RECT &nativeSize, RECT &finalSize, bool &fIsNative, bool fResetRs = false);
    virtual void        InvalidateElement(LPCRECT lprect);
    virtual void        UpdatePlayerAudioProperties();
    void                NotifyTrackChange();
    void                FireTrackChangeEvent();
    void                FireMediaEvent(PLAYER_EVENT plEvent);
    HRESULT             PutNaturalRepeatCount(double dblRepeatCount);
    HRESULT             PutNaturalDuration(double dblNatDur);
    HRESULT             ClearNaturalDuration();
    void                ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool &fPlayAnimations);
    LPOLESTR            GetBaseHREF() { return m_baseHREF;}
    virtual HRESULT InitPlayer(CTIMEMediaElement *pelem, 
                        LPOLESTR base, 
                        LPOLESTR src, 
                        LPOLESTR lpMimeType);

    //
    // GetXXXAttr Accessors
    //

    CAttr<LPWSTR> & GetSrcAttr()        { return m_SASrc; } 
    CAttr<LPWSTR> & GetTypeAttr()       { return m_SASrcType; } 
    CAttr<LPWSTR> & GetPlayerAttr()     { return m_SAPlayer; } 
    CAttr<float>  & GetClipBeginAttr()  { return m_FAClipBegin; } 
    CAttr<float>  & GetClipEndAttr()    { return m_FAClipEnd; } 
    CAttr<LPWSTR> & GettransInAttr()    { return m_SAtransIn; }
    CAttr<LPWSTR> & GettransOutAttr()   { return m_SAtransOut; }

    //
    // Notification Helpers
    //

    void NotifyPropertyChanged(DISPID dispid);

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    BEGIN_TIME_EVENTMAP() 
        TEM_INIT_EVENTMANAGER_SITE() 
        TEM_REGISTER_EVENT(TE_ONBEGIN)
        TEM_REGISTER_EVENT(TE_ONPAUSE)
        TEM_REGISTER_EVENT(TE_ONRESUME)
        TEM_REGISTER_EVENT(TE_ONEND)
        TEM_REGISTER_EVENT(TE_ONRESYNC)
        TEM_REGISTER_EVENT(TE_ONREPEAT)
        TEM_REGISTER_EVENT(TE_ONREVERSE)
        TEM_REGISTER_EVENT(TE_ONMEDIACOMPLETE)
        TEM_REGISTER_EVENT(TE_ONOUTOFSYNC)
        TEM_REGISTER_EVENT(TE_ONSYNCRESTORED)
        TEM_REGISTER_EVENT(TE_ONMEDIAERROR)
        TEM_REGISTER_EVENT(TE_ONCODECERROR)
        TEM_REGISTER_EVENT(TE_ONRESET)
        TEM_REGISTER_EVENT(TE_ONSCRIPTCOMMAND)
        TEM_REGISTER_EVENT(TE_ONMEDIABARTARGET)
        TEM_REGISTER_EVENT(TE_ONURLFLIP)
        TEM_REGISTER_EVENT(TE_ONTRACKCHANGE)
        TEM_REGISTER_EVENT(TE_ONSEEK)
        TEM_REGISTER_EVENT(TE_ONTIMEERROR)
        TEM_REGISTER_EVENT(TE_ONMEDIAINSERTED)
        TEM_REGISTER_EVENT(TE_ONMEDIAREMOVED)

        TEM_REGISTER_EVENT_NOTIFICATION(TEN_LOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_UNLOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_READYSTATECHANGE)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_STOP)
    END_TIME_EVENTMAP()

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT GetNotifyConnection(IConnectionPoint **ppConnection);
    HRESULT InitPropertySink();
    HRESULT UnInitPropertySink();
    void UpdateClipTimes();
    HRESULT AllowCreateControl(BOOL *fAllowed, REFCLSID clsid);
    HRESULT AllowMixedContent(BOOL *fAllowed);
    void InitOnLoad();
    bool IsNativeSize();
    bool NeedSizeChange();

    //
    // Misc. methods
    //

    HRESULT Error();
    
    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    static DWORD            ms_dwNumTimeMediaElems;

  private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    HRESULT CreatePlayer(TOKEN playerToken);
    void RemovePlayer();

    void    GetBASEHREF();

    static HRESULT CreateExternalPlayer(CLSID clsid,
                                        ITIMEBasePlayer ** ppPlayer);
    
    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------
 
    // Attributes
    CAttr<LPWSTR>               m_SASrc;
    CAttr<LPWSTR>               m_SASrcType;
    CAttr<LPWSTR>               m_SAPlayer;     // Place holder for player attribute
    CAttr<float>                m_FAClipBegin;
    CAttr<float>                m_FAClipEnd;
    CAttr<long>                 m_LAClipBegin;
    CAttr<long>                 m_LAClipEnd;


    // Internal variables
    LPOLESTR                    m_baseHREF;
    DAComPtr<IServiceProvider>  m_sp;
    CLSID                       m_playerCLSID;

    DAComPtr<ITIMEBasePlayer>   m_Player;

    bool                        m_fLoading; // are we in Load persistence?

    bool                        m_fLoaded;
    bool                        m_fExternalPlayer;
    bool                        m_fHaveCLSID;
    bool                        m_fCreatePlayerError;
    DWORD                       m_mediaElementPropertyAccesFlags;
    RECT                        m_rcOrigSize;
    RECT                        m_rcMediaSize;
    bool                        m_fMediaSizeSet;
    DWORD                       m_dwAdviseCookie;
    bool                        m_fInOnChangedFlag;
    bool                        m_fDurationIsNatural;
    bool                        m_fLoadError;
    bool                        m_fEditModeFlag;  //cache of edit mode because it is expensive to query.
    bool                        m_fInPropLoad;
    TOKEN                       m_playerToken;
    bool                        m_fDetached;
    bool                        m_fNativeSize;
    bool                        m_fNativeSizeComputed;

    CComPtr<IHTMLPaintSite>     m_spPaintSite;
    CComPtr<IElementBehaviorSiteRender>    m_pBvrSiteRender;

    static TIME_PERSISTENCE_MAP PersistenceMap[];

    // for player persistance
    CComPtr<IPropertyBag2>      m_spPropBag;
    CComPtr<IErrorLog>          m_spErrorLog;

    // for sync
    CComPtr<ITIMEElement>       m_pSyncNode;
    CTIMEElementBase            *m_pSyncElem;
    bool                        m_fWaitForSync;
    bool                        m_fPauseForSync;
    bool                        m_fFirstPause;
    bool                        m_fIgnoreStyleChange;

    // playlist
    CPlayListDelegator * m_pPlayListDelegator;

}; // CTIMEMediaElement

//+---------------------------------------------------------------------------------
//  CTIMEMediaElement inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
HRESULT WINAPI
CTIMEMediaElement::InternalQueryInterface(CTIMEMediaElement* pThis,
                                          const _ATL_INTMAP_ENTRY* pEntries,
                                          REFIID iid,
                                          void** ppvObject)
{ 
    return BaseInternalQueryInterface(pThis,
                                      (void *) pThis,
                                      pEntries,
                                      iid,
                                      ppvObject); 
}


#endif /* _MEDIAELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\mediaelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mediaelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mediaelm.h"
#include "playerimage.h"
#include "playerproxy.h"
#if DBG == 1
#include "playerdshowtest.h"
#endif
#include "playerdvd.h"
#include "player.h"
#include "player2.h"
#include "dmusicproxy.h"
#include "playernative.h"
#include <mshtmdid.h>
#include "playlist.h"
#include "timeparser.h"
#include "..\tags\bodyelm.h"

// #define ALWAYSDS 1


bool ConvertToPixels(VARIANT *pvarValue, WCHAR *pAttribute);

// static class data.
DWORD CTIMEMediaElement::ms_dwNumTimeMediaElems = 0;

DeclareTag(tagMediaTimeElm, "TIME: Behavior", "CTIMEMediaElement methods")
DeclareTag(tagMediaTimeElmSync, "TIME: Behavior", "CTIMEMediaElement sync methods")
DeclareTag(tagMediaElementOnChanged, "TIME: Behavior", "CTIMEMediaElement OnChanged method")
DeclareTag(tagMediaTransitionSite, "TIME: Behavior", "CTIMEMediaElement transition site methods")

#define DEFAULT_M_SRC       NULL
#define DEFAULT_M_SRCTYPE   NULL

#if DBG == 1
#define TestPlayerCLSID L"{FAC64649-FD53-4A41-89B8-DA126CB9DD10}"
#endif

extern long g_LOGPIXELSX;
extern long g_LOGPIXELSY;

CTIMEMediaElement::CTIMEMediaElement()
: m_SASrc(DEFAULT_M_SRC),
  m_baseHREF(NULL),
  m_SASrcType(DEFAULT_M_SRCTYPE),
  m_SAPlayer(NULL),
  m_FAClipBegin(-1.0f),
  m_FAClipEnd(-1.0f),
  m_LAClipBegin(-1),
  m_LAClipEnd(-1),
  m_Player(NULL),
  m_fLoaded(false),
  m_fExternalPlayer(false),
  m_fCreatePlayerError(false),
  m_fHaveCLSID(false),
  m_mediaElementPropertyAccesFlags(0),
  m_fMediaSizeSet(false),
  m_dwAdviseCookie(0),
  m_fInOnChangedFlag(false),
  m_fDurationIsNatural(false),
  m_playerToken(NONE_TOKEN),
  m_playerCLSID(GUID_NULL),
  m_fLoadError(false),
  m_fInPropLoad(false),
  m_fEditModeFlag(false),
  m_fWaitForSync(false),
  m_fPauseForSync(false),
  m_fFirstPause(false),
  m_pPlayListDelegator(NULL),
  m_pSyncElem(NULL),
  m_fDetached(true),
  m_fNativeSize(false),
  m_fNativeSizeComputed(false),
  m_fLoading(false),
  m_fIgnoreStyleChange(false)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::CTIMEMediaElement()",
              this));

    m_clsid = __uuidof(CTIMEMediaElement);
    CTIMEMediaElement::ms_dwNumTimeMediaElems++;
    
    m_rcOrigSize.bottom = m_rcOrigSize.left = m_rcOrigSize.right = m_rcOrigSize.top = 0;
    m_rcMediaSize.bottom = m_rcMediaSize.left = m_rcMediaSize.right = m_rcMediaSize.top = 0;
}

CTIMEMediaElement::~CTIMEMediaElement()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::~CTIMEMediaElement()",
              this));
    
    delete [] m_SASrc.GetValue();
    delete [] m_SASrcType.GetValue();
    delete [] m_SAPlayer.GetValue();
    delete [] m_baseHREF;
    m_baseHREF = NULL;

    RemovePlayer();

    // Order dependency: this should happen only after RemovePlayer has been called
    if (m_pPlayListDelegator)
    {
        m_pPlayListDelegator->Release();
        m_pPlayListDelegator = NULL;
    }

    CTIMEMediaElement::ms_dwNumTimeMediaElems--;

} //lint !e1740

STDMETHODIMP
CTIMEMediaElement::onPauseEvent(float time, float fOffset)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::onPauseEvent()",
              this));
    HRESULT hr = S_OK;
    VARIANT_BOOL canPause;

    hr = THR(get_canPause(&canPause));
    if (FAILED(hr)) //if this fails, try to pause
    {
        canPause = VARIANT_TRUE;
    }

    if (canPause == VARIANT_TRUE)
    {
        IGNORE_HR(CTIMEElementBase::onPauseEvent(time, fOffset));
    }

  done:
    return S_OK;  //don't fail this call, it will return an error to script.
}

STDMETHODIMP
CTIMEMediaElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Init()",
              this));

    HRESULT hr = E_FAIL;

    CComPtr<IHTMLElement2> pElem2;
    VARIANT_BOOL varboolSuccess;

    m_fDetached = false;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

    m_sp = GetServiceProvider();
    if (!m_sp)
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - unable get QS"));
        hr = TIMESetLastError(DISP_E_TYPEMISMATCH, NULL);   
        goto done;
    }

    hr = CTIMEElementBase::GetSize(&m_rcOrigSize);
    if (FAILED(hr))
        goto done;

    hr = InitPropertySink();
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetElement() != NULL);
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = S_OK;
        goto done;
    }

    hr = pElem2->attachEvent( L"onresize", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pElem2->attachEvent( L"onmousemove", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pElem2->attachEvent( L"onmousedown", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pElem2->attachEvent( L"onmouseup", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fEditModeFlag = IsDocumentInEditMode();


    hr = pBehaviorSite->QueryInterface(IID_IElementBehaviorSiteRender, (void **) &m_pBvrSiteRender);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pBehaviorSite->QueryInterface(IID_IHTMLPaintSite, (void **) &m_spPaintSite);
    if (FAILED(hr))
    {
        // We don't want to fail since we will just use the old rendering interfaces..
        m_spPaintSite = NULL;
    }

    hr = S_OK;

done:
    return hr;
}

void
CTIMEMediaElement::RemovePlayer()
{
    // release reference on player's playlist object
    if (m_pPlayListDelegator)
    {
        m_pPlayListDelegator->DetachPlayList();
    }

    if (m_Player)
    {
        // Do an extra addref in case we get released between calls
        DAComPtr<ITIMEBasePlayer> pTmp = m_Player;
    
        // Release the pointer before calling stop since it can cause
        // us to be reentered and we do not want to cause an infinite loop
        m_Player.Release();

        pTmp->Stop();
        THR(pTmp->DetachFromHostElement());
    }

    m_fLoaded = false;
}

HRESULT
CTIMEMediaElement::CreateExternalPlayer(CLSID clsid,
                                        ITIMEBasePlayer ** ppPlayer)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppPlayer);
    
    if (IsEqualCLSID(clsid, __uuidof(MediaPlayerCLSID)))
    {
        *ppPlayer = NEW CTIMEPlayer(clsid);

        if (*ppPlayer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        (*ppPlayer)->AddRef();
    }
    else
    {
        CComPtr<IUnknown> pObj;

        hr = THR(::CreateObject(clsid,
                                IID_IUnknown,
                                (void **)&pObj));
        if (FAILED(hr))
        {
            goto done;
        }
    
        if (CTIMEPlayer2::CheckObject(pObj))
        {
            CTIMEPlayer2 * p2;
            
            hr = THR(CreateTIMEPlayer2(clsid,
                                       pObj,
                                       &p2));

            if (FAILED(hr))
            {
                goto done;
            }

            *ppPlayer = p2;
        }
        else if (CTIMEPlayer::CheckObject(pObj))
        {
            *ppPlayer = NEW CTIMEPlayer(clsid);

            if (*ppPlayer == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            (*ppPlayer)->AddRef();
        }
        else
        {
            hr = E_INVALIDARG;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEMediaElement::CreatePlayer(TOKEN playerToken)
{
    HRESULT hr = E_FAIL;
    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;
    BOOL fAllowed = FALSE;
    
    ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
    RemovePlayer();
    Assert(!m_fLoaded);

    if (GetMMBvr().IsDisabled())
    {
        GetMMBvr().Enable();
    }

    if(playerToken == NULL)
    {
#if DBG == 1
        CLSID clsidTest;
        CLSIDFromString(TestPlayerCLSID, &clsidTest);
        if (IsEqualCLSID(m_playerCLSID, clsidTest))
        {
            m_Player = NEW CTIMEPlayerNative(PLAYER_DSHOWTEST);
        } 
        else
#endif
        {
            if (fPlayVideo &&
                !IsEqualCLSID(m_playerCLSID,
                              GUID_NULL))
            {
                hr = AllowCreateControl(&fAllowed, m_playerCLSID);
                if (FAILED(hr) || (fAllowed == FALSE))
                {
                    hr = E_FAIL;
                    goto done;
                }
                hr = THR(CreateExternalPlayer(m_playerCLSID,
                                              &m_Player));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                m_Player = NEW CTIMEPlayerNative(PLAYER_NONE);
            }
        }
    }
#if DBG // 94850
    else if((playerToken == DSHOW_TOKEN) && fPlayVideo)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_DSHOW);
    }
#endif
    else if((playerToken == DVD_TOKEN) && fPlayVideo)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_DVD);
    }
    else if(playerToken == CD_TOKEN)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_CD);
    }
    else if(playerToken == NONE_TOKEN)
    {
        m_Player = NEW CTIMEPlayerNative(PLAYER_NONE);
    }

    if (!m_Player)
    {
        hr = E_FAIL;
        goto done;
    }

    if (IsReady())
    {
        InitOnLoad();
    }

    if (m_pPlayListDelegator)
    {
        CComPtr<ITIMEPlayList> spPlayList;

        hr = THR(m_Player->GetPlayList(&spPlayList));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        m_pPlayListDelegator->AttachPlayList(spPlayList);
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_fCreatePlayerError = true;
        RemovePlayer();
    }
    
    return hr;
}

void
CTIMEMediaElement::InvalidateElement(LPCRECT lprect)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::InvalidateElement",
              this));

    RECT rc;
    RECT *prcNew;

    // since we have incapatible types due to const.  Take the time and repack it.
    if (lprect == NULL)
    {
        prcNew = NULL;
    }
    else
    {
        ::CopyRect(&rc, lprect);
        prcNew = &rc;
    }

    if (m_spPaintSite)
    {
        m_spPaintSite->InvalidateRect(prcNew);
    }
    else if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->Invalidate(prcNew);
    }
}

bool
CTIMEMediaElement::IsNativeSize()
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs;
    CComPtr<IHTMLCurrentStyle> sc;
    CComPtr<IHTMLElement2> pEle2;
    VARIANT styleWidth, styleHeight;
    VARIANT crstyleWidth, crstyleHeight;
    VariantInit(&styleWidth);
    VariantInit(&styleHeight);
    VariantInit(&crstyleWidth);
    VariantInit(&crstyleHeight);
    long pixelWidth = 0, pixelHeight = 0;
    bool fstyleWidth = false, fstyleHeight = false;
    bool fnativeSize = true;

    if (m_fNativeSizeComputed == true)
    {
        fnativeSize = m_fNativeSize;
        goto done;
    }
   
    if(GetElement() == NULL)
    {
        goto done;
    }

    hr = GetElement()->get_style(&s);
    if (FAILED(hr) || s == NULL)
    {
        goto done;
    }
    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_currentStyle(&sc);
        if (FAILED(hr) || sc == NULL)
        {
            goto done;
        }
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        hr = sc->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
            }
        }

        hr = sc -> get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
            }
        }

    }


    if(rs != NULL)
    {
        hr = rs->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }

    if(fstyleWidth == false)
    {
        VariantClear(&styleWidth);
        hr = s->get_width(&styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }

    if(rs != NULL)
    {
        hr = rs->get_height(&styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }

    if(fstyleHeight == false)
    {
        VariantClear(&styleHeight);
        hr = s->get_height( &styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                }
            }
        }
    }
    
  done:

    m_fNativeSize = fnativeSize;
    m_fNativeSizeComputed = true;

    VariantClear(&styleWidth);
    VariantClear(&styleHeight);
    VariantClear(&crstyleWidth);
    VariantClear(&crstyleHeight);
 
    return fnativeSize;
}

HRESULT
CTIMEMediaElement::NegotiateSize(RECT &rctNativeSize, RECT &rctFinalSize, bool &fnativeSize, bool fResetRs)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs = NULL;
    CComPtr<IHTMLCurrentStyle> sc;
    CComPtr<IHTMLElement2> pEle2;
    VARIANT styleWidth, styleHeight;
    VARIANT crstyleWidth, crstyleHeight;
    VariantInit(&styleWidth);
    VariantInit(&styleHeight);
    VariantInit(&crstyleWidth);
    VariantInit(&crstyleHeight);
    CComVariant emptyVar;
    BSTR bstrWidth = SysAllocString(L"width");
    BSTR bstrHeight = SysAllocString(L"height");
    VARIANT_BOOL varStat;

    long pixelWidth = 0, pixelHeight = 0;
    RECT rc;
    bool fstyleWidth = false, fstyleHeight = false;
    
    rc.top = rc.left = 0;
    rc.right = rctNativeSize.right;
    rc.bottom = rctNativeSize.bottom;
    fnativeSize = true;

    if(GetElement() == NULL)
    {
        goto done;
    }

    hr = GetElement()->get_style(&s);
    if (FAILED(hr) || s == NULL)
    {
        goto done;
    }
    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        if(fResetRs)
        {
            m_fIgnoreStyleChange = true;
            hr = rs->removeAttribute(bstrWidth, VARIANT_FALSE, &varStat);
            hr = rs->removeAttribute(bstrHeight, VARIANT_FALSE, &varStat);
            m_fIgnoreStyleChange = false;
        }

        hr = pEle2->get_currentStyle(&sc);
        if (FAILED(hr) || sc == NULL)
        {
            goto done;
        }

        hr = sc->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
                fstyleWidth = true;
                if(ConvertToPixels(&styleWidth, L"height"))
                {
                    pixelWidth = styleWidth.fltVal; //lint !e524
                }
                else
                {
                    pixelWidth = rctNativeSize.right;
                }
                rc.right = pixelWidth;
            }
            else
            {
                pixelWidth = rctNativeSize.right;
            }
        }

        hr = sc -> get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                fnativeSize = false;
                fstyleHeight = true;
                if(ConvertToPixels(&styleHeight, L"height"))
                {
                    pixelHeight = styleHeight.fltVal; //lint !e524
                }
                else
                {
                    pixelHeight = rctNativeSize.bottom;
                }
                rc.bottom = pixelHeight;

            }
            else
            {
                pixelHeight = rctNativeSize.bottom;
            }
        }

        if(fstyleWidth && !fstyleHeight)
        {
            if (IsNativeSize() == false)
            {
                pixelHeight = rctNativeSize.bottom * ((float )pixelWidth) / ((float )rctNativeSize.right); //lint !e524
            }
            else
            {
                pixelHeight = rctNativeSize.bottom;
            }
            SetHeight(pixelHeight);
        }
        else if(!fstyleWidth && fstyleHeight)
        {
            if (IsNativeSize() == false)
            {
                pixelWidth = rctNativeSize.right * ((float )pixelHeight) / ((float )rctNativeSize.bottom); //lint !e524
            }
            else
            {
                pixelWidth = rctNativeSize.right;
            }
            SetWidth(pixelWidth);
        }
    }


    if(rs != NULL)
    {
        VariantClear(&styleWidth);
        hr = rs->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                    rc.right = pixelWidth;
                    fstyleWidth = true;
                }
            }
        }
    }

    if(fstyleWidth == false)
    {
        VariantClear(&styleWidth);
        hr = s->get_width(&styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelWidth(&pixelWidth);
                if (FAILED(hr))
                {
                    goto done;
                }
                if(pixelWidth != 0)
                {
                    fnativeSize = false;
                    rc.right = pixelWidth;
                    fstyleWidth = true;
                }
            }
        }
    }

    if(rs != NULL)
    {
        VariantClear(&styleHeight);
        hr = rs->get_height(&styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = rs->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                    rc.bottom = pixelHeight;
                    fstyleHeight = true;
                }
            }
        }
    }

    if(fstyleHeight == false)
    {
        VariantClear(&styleHeight);
        hr = s->get_height( &styleHeight);
        if((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") != 0)
            {
                hr = s->get_pixelHeight(&pixelHeight);
                if (FAILED(hr))
                {
                    goto done;
                }

                if(pixelHeight != 0)
                {
                    fnativeSize = false;
                    rc.bottom = pixelHeight;
                    fstyleHeight = true;
                }
            }
        }
    }
    
    if (GetParent() &&
        GetParent()->IsSequence())
    {
        // try and grab the parents style...if there is one...
        CComPtr<IHTMLElement> pParentElement = GetParent()->GetElement();
        CComPtr<IHTMLStyle>   pStyle;
        
        hr = pParentElement->get_style(&pStyle);
        if (SUCCEEDED(hr))
        {
            if (false == fstyleWidth)
            {
                hr = pStyle->get_pixelWidth( &pixelWidth);
                if (SUCCEEDED(hr))
                {
                    if (pixelWidth  != 0)
                    {
                        rc.right = pixelWidth;
                        fstyleWidth = true;
                    }
                }
            }
            if (false == fstyleHeight)
            {
                hr = pStyle->get_pixelHeight( &pixelHeight);
                if (SUCCEEDED(hr))
                {           
                    if (pixelHeight != 0)
                    {
                        rc.bottom = pixelHeight;
                        fstyleHeight = true;
                    } 
                }
            }
        }
    }
    
    if(fstyleWidth && !fstyleHeight)
    {
        rc.bottom *= ((float )pixelWidth) / ((float )rctNativeSize.right); //lint !e524
    }
    else if(!fstyleWidth && fstyleHeight)
    {
        rc.right *= ((float )pixelHeight) / ((float )rctNativeSize.bottom); //lint !e524
    }


    hr = S_OK;
done:

    TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::NegotiateSize(%d-%d)",
                  this,
                  rc.right - rc.left,
                  rc.bottom - rc.top));

    memcpy((void*)&m_rcMediaSize, (void*)&rctNativeSize, sizeof(rctNativeSize));
    if(fnativeSize)
    {
        if(rc.bottom != -1 && rc.right != -1)
        {
            THR(SetSize(&rc));
        }
    }
    rctFinalSize = rc;

    VariantClear(&styleWidth);
    VariantClear(&styleHeight);
    VariantClear(&crstyleWidth);
    VariantClear(&crstyleHeight);

    SysFreeString(bstrWidth);
    SysFreeString(bstrHeight);
 
    return hr;
}

HRESULT
CTIMEMediaElement::Error()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Error()",
              this));
    
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>::Error(str, IID_ITIMEMediaElement2, hr);
        delete [] str;
    }

    return hr;
}

STDMETHODIMP
CTIMEMediaElement::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Notify()",
              this));

    HRESULT hr;
    hr = THR(CTIMEElementBase::Notify(event, pVar));

    return hr;
}

STDMETHODIMP
CTIMEMediaElement::Detach()
{
    HRESULT hr;
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Detach()",
              this));

    m_fDetached = true;

    THR(UnInitPropertySink());
    
    if (NULL != GetElement())
    {
        CComPtr<IHTMLElement2> pElem2;
        hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
        if (SUCCEEDED(hr))
        {
            THR(pElem2->detachEvent(L"onresize", this));
            THR(pElem2->detachEvent(L"onmousemove", this));
            THR(pElem2->detachEvent(L"onmouseup", this));
            THR(pElem2->detachEvent(L"onmousedown", this));
        }
    }

    // This should be the done before calling RemovePlayer
    THR(CTIMEElementBase::Detach());

    RemovePlayer();

    m_sp.Release();
    m_spPaintSite.Release();
    m_pBvrSiteRender.Release();

    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::get_src(VARIANT * url)
{
    HRESULT hr;
    
    if (url == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(url))))
    {
        goto done;
    }
    
    V_VT(url) = VT_BSTR;
    V_BSTR(url) = SysAllocString(m_SASrc);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::InitPlayer(CTIMEMediaElement *pelem, 
                              LPOLESTR base, 
                              LPOLESTR src, 
                              LPOLESTR lpMimeType) 
{
    HRESULT hr = S_OK;
    double dblClipBegin = m_FAClipBegin.GetValue();
    double dblClipEnd= m_FAClipEnd.GetValue();
    long lClipBeginFrame = m_LAClipBegin.GetValue();
    long lClipEndFrame = m_LAClipEnd.GetValue();

    //this flag is used to turn elements off at creation.
    //it is not dynamic.
    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }

    if (dblClipEnd != -1 &&
        dblClipBegin != -1 &&
        dblClipEnd <= dblClipBegin)
    {
        dblClipEnd = -1;
    }
    if (lClipBeginFrame != -1 &&
        lClipEndFrame != -1 &&
        lClipEndFrame <= lClipBeginFrame)
    {
        lClipEndFrame = -1;
    }
     
    hr = m_Player->Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if(m_LAClipBegin.IsSet())
    {
        m_FAClipBegin.Reset(-1.0f);
        m_Player->SetClipBeginFrame(lClipBeginFrame);
    }
    if(m_LAClipEnd.IsSet())
    {
        m_FAClipEnd.Reset(-1.0f);
        m_Player->SetClipEndFrame(lClipEndFrame);
    }
    if(!m_fInPropLoad)
    {
        if (m_Player)
        {
            m_Player->ReadyStateNotify(L"OnLoad");
        }
    }

    if (m_Player)
    {
        m_Player->Reset();
    }
  
  done:    
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_src(VARIANT url)
{
    CComVariant v;
    HRESULT hr = E_FAIL;
    bool clearFlag = false;
    CComPtr<IHTMLStyle> rs = NULL;
    CComPtr<IHTMLElement2> pEle2;
    CComBSTR bstrWidth("width");
    CComBSTR bstrHeight("height");
    VARIANT_BOOL varStat;

    if(V_VT(&url) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &url);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    //clear the runtime size so media can resize to natural size.
    if(GetElement() == NULL)
    {
        goto done;
    }

    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        m_fIgnoreStyleChange = true;
        if(bstrWidth != NULL)
        {
            hr = rs->removeAttribute(bstrWidth, VARIANT_FALSE, &varStat);
        }
        if(bstrHeight != NULL)
        {
            hr = rs->removeAttribute(bstrHeight, VARIANT_FALSE, &varStat);
        }
        m_fIgnoreStyleChange = false;
    }

    delete [] m_SASrc.GetValue();

    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_SASrc.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SASrc.Reset(DEFAULT_M_SRC);
    }

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_SRC);


    GetBASEHREF();
    Assert(m_baseHREF != NULL);

    if (m_fLoaded)
    {
        RemovePlayer();
        hr = CreatePlayer(m_playerToken);
        if (FAILED(hr) || !m_Player)
        {
            hr = S_FALSE;
            goto done;
        }

        ClearNaturalDuration();
    }

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANPAUSE);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANSEEK);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASAUDIO);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASVISUAL);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIADUR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYLIST);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CTIMEMediaElement::get_player(VARIANT  * clsid)
{
    HRESULT hr;
    BSTR bstr = NULL;
    
    CHECK_RETURN_NULL(clsid);

    VariantClear(clsid);
    
    if (m_SAPlayer.GetValue() != NULL)
    {
        bstr = SysAllocString(m_SAPlayer.GetValue());
    }
    else if (IsEqualCLSID(m_playerCLSID, GUID_NULL))
    {
        hr = S_OK;
        goto done;
    }
    else
    {
        LPOLESTR ppsz = NULL;

        hr = THR(StringFromCLSID(m_playerCLSID, &ppsz));
        if (FAILED(hr))
        {
            goto done;
        }

        bstr = SysAllocString(ppsz);

        CoTaskMemFree(ppsz);
    }

    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    // set the VT only after above code succeeds
    V_VT(clsid) = VT_BSTR;
    V_BSTR(clsid) = bstr;
        
    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        SysFreeString(bstr);
    }
    
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_player(VARIANT vPlayer)
{
    HRESULT hr = S_OK;
    TOKEN playerTokenOld = m_playerToken;
    CLSID clsidOld = m_playerCLSID;
    
    m_playerToken = NULL;
    m_playerCLSID = GUID_NULL;
    m_SAPlayer.Reset(NULL);

    if(V_VT(&vPlayer) != VT_NULL)
    {
        CComVariant v;

        hr = THR(VariantChangeTypeEx(&v,
                                     &vPlayer,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR));
        if (SUCCEEDED(hr))
        {
            CTIMEParser pParser(&v);
            LPWSTR lpwStr = CopyString(V_BSTR(&v));

            if (lpwStr == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            m_SAPlayer.SetValue(lpwStr);

            IGNORE_HR(pParser.ParsePlayer(m_playerToken, m_playerCLSID));
        }
    }
    
    if (!m_fLoaded ||
        (playerTokenOld == m_playerToken &&
         IsEqualCLSID(clsidOld, m_playerCLSID)))
    {
        hr = S_OK;
        goto done;
    }

    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }
    
    RemovePlayer();

    hr = THR(CreatePlayer(m_playerToken));
    if (FAILED(hr) || !m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    InitOnLoad();
    
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANPAUSE);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANSEEK);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASAUDIO);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASVISUAL);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIADUR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYLIST);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        RemovePlayer();
    }

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYER);

    return hr;
}


STDMETHODIMP
CTIMEMediaElement::get_type(VARIANT * type)
{
    HRESULT hr;
    
    if (type == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(type))))
    {
        goto done;
    }
    
    V_VT(type) = VT_BSTR;
    V_BSTR(type) = SysAllocString(m_SASrcType);

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_type(VARIANT type)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;


    if(V_VT(&type) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &type);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    delete [] m_SASrcType.GetValue();

    //processing the attribute change should be done here
    if(!clearFlag)
    {
        m_SASrcType.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SASrcType.Reset(DEFAULT_M_SRCTYPE);
    }
    
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TYPE);

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_playerObject(IDispatch **ppDisp)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement::get_playerObject"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppDisp);

    if (!m_Player)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = m_Player->GetExternalPlayerDispatch(ppDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;    
}

void 
CTIMEMediaElement::OnLoad()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnLoad()",
              this));

    // Protect against reentrancy due to WMP pumping messages on shutdown,
    // which interferes with Trident's message loop and causes onload to be
    // called a second time in some cases
    if (m_bLoaded)
    {
        goto done;
    }

    CTIMEElementBase::OnLoad();

    if(m_Player)
    {
        m_Player->ReadyStateNotify(L"OnLoad");
    }

done:
    return;
}


void
CTIMEMediaElement::OnTEPropChange(DWORD tePropType)
{

    TraceTag((tagMediaTimeElm,
              "CTIMEElementBase(%lx)::OnTEPropChange(%#x)",
              this,
              tePropType));

    CTIMEElementBase::OnTEPropChange(tePropType);

    
    //this flag is used to turn elements off at creation.
    //it is not dynamic.
    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }

    if(m_Player)
    {
        m_Player->PropChangeNotify(tePropType);
    }
  done:
    return;
}

void
CTIMEMediaElement::OnSeek(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnSeek()",
              this));

    if (m_Player)
    {
        m_Player->Reset();
    }
    
    CTIMEElementBase::OnSeek(dblLocalTime);
}


HRESULT
CTIMEMediaElement::GetSyncMaster(double & dblNewSegmentTime,
                                 LONG & lNewRepeatCount,
                                 bool & bCueing)
{
    TraceTag((tagMediaTimeElmSync,
              "CTIMEMediaElement(%lx)::GetSyncMaster()",
              this));

    HRESULT hr;
    
    if (!m_fLoaded ||
        !m_fCachedSyncMaster ||
        !m_Player)
    {
        bCueing = !m_fLoaded;
        
        hr = S_FALSE;
        TraceTag((tagMediaTimeElmSync,
                  "CTIMEMediaElement(%lx)::GetSyncMaster():Disabled",
                  this));
        goto done;
    }
    
    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());
    
    double dblPlayerTime;
    hr = THR(m_Player->GetCurrentSyncTime(dblPlayerTime));
    if (S_OK != hr)
    {
        TraceTag((tagMediaTimeElmSync,
                  "CTIMEMediaElement(%lx)::GetSyncMaster():Error",
                  this));
        goto done;
    }
    
    if (dblPlayerTime < 0)
    {
        dblPlayerTime = 0;
    }
    
    dblNewSegmentTime = dblPlayerTime;
    lNewRepeatCount = TE_UNDEFINED_VALUE;
    
    if (m_Player &&
        m_Player->GetState() == PLAYER_STATE_CUEING)
    {
        bCueing = true;
    }
    
    TraceTag((tagMediaTimeElmSync,
              "CTIMEMediaElement(%lx)::GetSyncMaster():Enabled(%f)",
              this, dblPlayerTime));
    hr = S_OK;
  done:
    RRETURN2(hr, S_FALSE, E_NOTIMPL);
}

void
CTIMEMediaElement::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnBegin()",
              this));

    CTIMEElementBase::OnBegin(dblLocalTime, flags);
    
    Assert(NULL != m_mmbvr);

    if(m_Player)
    {
        m_Player->Start();
    }   

done:
    return;
}

HRESULT
CTIMEMediaElement::AllowCreateControl(BOOL *fAllowed, REFCLSID clsid)
{
    HRESULT hr = S_OK;
    CComPtr<IElementBehaviorSite> spElementBehaviorSite;
    CComPtr<IServiceProvider> spServProvider;
    CComPtr<IInternetSecurityManager> spSecMan;
    CComPtr<IHTMLDocument2> spDoc2;
    CComPtr<IHTMLLocation> spLocation;
    CComPtr<IDispatch> pDisp;
    CComBSTR pHref;
    DWORD dwPolicy = 0;

    *fAllowed = FALSE;

    spElementBehaviorSite = GetBvrSite();

    hr = THR(spElementBehaviorSite->QueryInterface(IID_TO_PPV(IServiceProvider, &spServProvider)));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spServProvider->QueryService(IID_IInternetSecurityManager, IID_TO_PPV(IInternetSecurityManager, &spSecMan));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&spDoc2));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spDoc2->get_location(&spLocation);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = spLocation->get_href(&pHref);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spSecMan->ProcessUrlAction(
                pHref,
                URLACTION_ACTIVEX_RUN,
                (BYTE *)&dwPolicy,
                sizeof(DWORD),
                (BYTE *)&clsid,
                sizeof(CLSID),
                0,
                0));
    if (FAILED(hr))
    {
        goto done;
    }

    *fAllowed = (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW);


done:
    return hr;
}

HRESULT
CTIMEMediaElement::AllowMixedContent(BOOL *fAllow)
{
    HRESULT hr = S_OK;
    CComPtr<ISecureUrlHost> spSecureUrlHost;
	CComPtr<IElementBehaviorSite> spElementBehaviorSite;
    DWORD dwFlags = 0;
    TCHAR pchExpUrl[4096];
    DWORD cchBuf;

    if(m_SASrc.GetValue() == NULL)
    {
        *fAllow = TRUE;
        hr = S_OK;
        goto done;
    }

    spElementBehaviorSite = GetBvrSite();
    hr = THR(spElementBehaviorSite->QueryInterface(IID_TO_PPV(ISecureUrlHost, &spSecureUrlHost)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoInternetCombineUrl(m_baseHREF, m_SASrc.GetValue(), 0xFFFFFFFF,
                                  pchExpUrl, 4096, &cchBuf, 0));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(fAllow, pchExpUrl, dwFlags);

done:
    return hr;
}

void 
CTIMEMediaElement::InitOnLoad()
{
    HRESULT hr = S_OK;

    if(m_fCreatePlayerError)
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        m_fCreatePlayerError = false;
        goto done;
    }

    if (m_fLoaded == false && m_Player)
    {
        BOOL fAllow = FALSE;

        hr = AllowMixedContent(&fAllow);
        if (FAILED(hr) || (fAllow == FALSE))
        {
            FireMediaEvent(PE_ONMEDIAERROR);
            hr = E_FAIL;
            goto done;
        }

        m_fLoaded = true;
        InitPlayer(this, m_baseHREF, m_SASrc, m_SASrcType);
    }
done:
    return;
}

void
CTIMEMediaElement::OnEnd(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnEnd()",
              this));

    CTIMEElementBase::OnEnd(dblLocalTime);
    
    if(m_Player)
    {
        m_Player->Stop();
    }
done:
    return;
}

void 
CTIMEMediaElement::OnUpdate(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnUpdate()",
              this));

    CTIMEElementBase::OnUpdate(dblLocalTime, flags);

    OnReset(dblLocalTime, flags);
    
done:
    return;

}

void
CTIMEMediaElement::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnReset()",
              this));
    
    CTIMEElementBase::OnReset(dblLocalTime, flags);
    
    if(m_Player)
    {
        m_Player->Reset();
    }

  done:

    return;
}

void
CTIMEMediaElement::OnPause(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnPause()",
              this));

    if(m_fWaitForSync && m_fFirstPause)
    {
        m_fFirstPause = false;
        goto done;
    }

    CTIMEElementBase::OnPause(dblLocalTime);

    if(m_Player)
    {
        m_Player->Pause();
    }

  done:
    return;
}

void
CTIMEMediaElement::OnResume(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnResume()",
              this));

    HRESULT hr = S_OK;

    CTIMEElementBase::OnResume(dblLocalTime);
        
    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());
    if(!m_Player)
    {
        goto done;
    }

    // If we can't get either segment time or media length, resume unconditionally,
    // else use the information to decide whether to pause 
    double dblSegmentTime;
    dblSegmentTime= m_mmbvr->GetSimpleTime();

    double dblMediaLength;
    dblMediaLength = 0.0;
    
    hr = THR(m_Player->GetMediaLength(dblMediaLength));
    if (FAILED(hr))
    {
        // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
        dblMediaLength = HUGE_VAL;
    }

    if (dblSegmentTime <= dblMediaLength)
    {        
        if (m_Player)
        {
            m_Player->Resume();
        }
    }
  done:
    return;

} // OnResume

void CTIMEMediaElement::OnRepeat(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnRepeat()",
              this));

    CTIMEElementBase::OnRepeat(dblLocalTime);

    if(m_Player)
    {
        m_Player->Repeat();
    }

  done:
    return;
}

void
CTIMEMediaElement::OnUnload()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnUnload()",
              this));

    if (m_Player)
    {
        // Do an extra addref in case we get released between calls
        DAComPtr<ITIMEBasePlayer> pTmp = m_Player;
    
        pTmp->Stop();
        pTmp->ReadyStateNotify(L"OnUnload");
    }

    CTIMEElementBase::OnUnload();
}

STDMETHODIMP
CTIMEMediaElement::get_clipBegin(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipBegin()",
              this));
    HRESULT hr = S_OK;
    TCHAR pSrcNr[ 20];
    long lClip;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    VariantInit(pvar);
    if(m_FAClipBegin.IsSet())
    {
        pvar->vt = VT_R8;
        pvar->dblVal = m_FAClipBegin;
    }
    else if(m_LAClipBegin.IsSet())
    {
        pvar->vt = VT_BSTR;
        lClip = m_LAClipBegin;
        _itow(lClip, pSrcNr, 10);
        if(lstrlenW(pSrcNr) <= 18)
        {
            StrCatW(pSrcNr, L"f");
        }
        V_BSTR(pvar) = SysAllocString(pSrcNr);
    }
    else
    {
        pvar->vt = VT_R8;
        pvar->dblVal = -1;
    }
    
    hr = S_OK;

done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_clipBegin(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipBegin()",
              this));
    long lbeginFrame = 0;
    bool fIsFrame= false;

    HRESULT hr = S_OK;
    float beginTime= 0.0;

    // reset to default
    m_FAClipBegin.Reset(-1.0f);
    m_LAClipBegin.Reset(-1);

    hr = VariantToTime(var, &beginTime, &lbeginFrame, &fIsFrame);
    if (FAILED(hr))
    {
        goto done;
    }

    if(!fIsFrame)
    {
        m_FAClipBegin.SetValue(beginTime);
    }
    else
    {
        m_LAClipBegin.SetValue(lbeginFrame);
    }
    
    UpdateClipTimes();

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CLIPBEGIN);
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_clipEnd(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipEnd()",
              this));
    HRESULT hr = S_OK;
    TCHAR pSrcNr[ 20];
    long lClip;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    VariantInit(pvar);
    if(m_FAClipEnd.IsSet())
    {
        pvar->vt = VT_R8;
        pvar->dblVal = m_FAClipEnd;
    }
    else if(m_LAClipEnd.IsSet())
    {
        pvar->vt = VT_BSTR;
        lClip = m_LAClipEnd;
        _itow(lClip, pSrcNr, 10);
        if(lstrlenW(pSrcNr) <= 18)
        {
            StrCatW(pSrcNr, L"f");
        }
        V_BSTR(pvar) = SysAllocString(pSrcNr);
    }
    else
    {
        pvar->vt = VT_R8;
        pvar->dblVal = -1;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::put_clipEnd(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipEnd()",
              this));
    long lendFrame = 0;
    bool fIsFrame= false;

    HRESULT hr = S_OK;
    float endTime = 0.0;

    // reset to default
    m_FAClipEnd.Reset(-1.0f);
    m_LAClipEnd.Reset(-1);

    hr = VariantToTime(var, &endTime, &lendFrame, &fIsFrame);
    if (FAILED(hr))
    {
        goto done;
    }

    if(!fIsFrame)
    {
        m_FAClipEnd.SetValue(endTime);
    }
    else
    {
        m_LAClipEnd.SetValue(lendFrame);
    }

    UpdateClipTimes();

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CLIPEND);
done:
    return hr;
}

HRESULT
CTIMEMediaElement::GetSize(RECT *prcPos)
{
    return CTIMEElementBase::GetSize(prcPos);
}

HRESULT 
CTIMEMediaElement::SetSize(const RECT *prcPos)
{
    HRESULT hr;

    hr = THR(UnInitPropertySink());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = CTIMEElementBase::SetSize(prcPos);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(InitPropertySink());
    if (FAILED(hr))
    {
        goto done;
    }
    if (m_fIsIE4)
    {
        RECT newRect;
        newRect.left = -1;
        newRect.top = -1;
        newRect.right = prcPos->right;
        newRect.bottom = prcPos->bottom;
        
        hr = m_pBvrSiteRender->Invalidate(&newRect);
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMediaElement::GetRenderInfo(LONG *pdwRenderInfo)
{
    // Return the layers we are interested in drawing
//    *pdwRenderInfo = BEHAVIORRENDERINFO_BEFORECONTENT; //BEHAVIORRENDERINFO_AFTERCONTENT;
    *pdwRenderInfo = BEHAVIORRENDERINFO_AFTERCONTENT | BEHAVIORRENDERINFO_SURFACE;
    return S_OK;
}

bool
CTIMEMediaElement::ToggleTimeAction(bool on)
{
    bool bRet = false;
    bRet = CTIMEElementBase::ToggleTimeAction(on);
    
    if (m_Player && on == false)
    {
        InvalidateElement(NULL);
    }
    return bRet;
}


STDMETHODIMP
CTIMEMediaElement::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagMediaTimeElm,
          "CTIMEMediaElement(%lx)::Draw()",
          this));

    HRESULT hr = S_OK;
    bool bIsActiveInEdit = true;  //only query this if the document is in edit mode. Otherwise assume it is true

    //it is possible that these have already gone away if we are asked to render after receiving the onUnload event.
    if (!m_mmbvr || !m_Player)
    {
        goto done;
    }

    if (m_fEditModeFlag)
    {
        bIsActiveInEdit = m_mmbvr->IsActive();

    }

    if (m_fLoaded && bIsActiveInEdit && !m_fDetached &&
        (m_timeAction.IsTimeActionOn() || GetTimeAction() != NONE_TOKEN) )
    {
        if (m_Player)
        {
            hr = THR(m_Player->Render(hdc, prc));
        }
        else
        {
            hr = S_OK;
        }
    }
done:
    return hr;        
}


STDMETHODIMP
CTIMEMediaElement::HitTestPoint(LPPOINT point,
                       IUnknown *pReserved,
                       BOOL *hit)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::HitTestPoint()",
              this));

    *hit = FALSE;

    return S_OK;
}

void scalePoint( long &x, long &y, HTML_PAINT_DRAW_INFO &DrawInfo)
{
    long xtemp, ytemp;

    xtemp = x * DrawInfo.xform.eM11 + y * DrawInfo.xform.eM21 + DrawInfo.xform.eDx; //lint !e524
    ytemp = x * DrawInfo.xform.eM12 + y * DrawInfo.xform.eM22 + DrawInfo.xform.eDy; //lint !e524

    x = xtemp;
    y = ytemp;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IHTMLPainter
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CTIMEMediaElement::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Draw()",
              this));

    HRESULT hr = S_OK;
    bool bIsActiveInEdit = true;  //only query this if the document is in edit mode. Otherwise assume it is true

    //it is possible that these have already gone away if we are asked to render after receiving the onUnload event.
    if (   (!m_mmbvr) || (!m_Player) 
        || (GetMMBvr().GetEnabled() == false) 
        || (GetDrawFlag() == VARIANT_FALSE))
    {
        goto done;
    }

    if (m_fEditModeFlag)
    {
        bIsActiveInEdit = m_mmbvr->IsActive();

    }

    if (HTMLPAINT_DRAW_USE_XFORM == lDrawFlags)
    {
        HTML_PAINT_DRAW_INFO DrawInfo;

        hr = m_spPaintSite->GetDrawInfo(HTMLPAINT_DRAWINFO_XFORM, &DrawInfo);

        TraceTag((tagMediaTimeElm, "xform DrawInfo: eM11:%g eM12:%g eM21:%g eM22:%g eDx:%g eDy:%g", DrawInfo.xform.eM11, DrawInfo.xform.eM12, DrawInfo.xform.eM21, DrawInfo.xform.eM22, DrawInfo.xform.eDx, DrawInfo.xform.eDy));
    
        if( (DrawInfo.xform.eM12 == 0) && (DrawInfo.xform.eM21 == 0))
        {
            TraceTag((tagError, "xform scale"));
            scalePoint(rcBounds.left, rcBounds.top, DrawInfo);
            scalePoint(rcBounds.right, rcBounds.bottom, DrawInfo);
        }
    }
    if (m_fLoaded && bIsActiveInEdit && !m_fDetached &&
        (m_timeAction.IsTimeActionOn() || GetTimeAction() != NONE_TOKEN) )
    {
        TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::PlayerDraw()",
                  this));
        if (m_Player)
        {
            hr = THR(m_Player->Render(hdc, &rcBounds));
        }
        else
        {
            hr = S_OK;
        }
    }
done:
    return hr;       
}


STDMETHODIMP
CTIMEMediaElement::OnMove(RECT rcDevice)
{
    HRESULT hr = S_OK;


    return hr;
}



STDMETHODIMP
CTIMEMediaElement::GetPainterInfo(HTML_PAINTER_INFO* pInfo)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::GetPainterInfo()",
              this));

    HRESULT hr = S_OK;

    if (NULL == pInfo)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pInfo->lFlags  |= HTMLPAINTER_SURFACE;
    pInfo->lFlags  |= HTMLPAINTER_SUPPORTS_XFORM;
    pInfo->lFlags  |= HTMLPAINTER_HITTEST;

    pInfo->lZOrder = HTMLPAINT_ZORDER_BELOW_FLOW;
    SetRect(&pInfo->rcExpand, 0, 0, 0, 0);

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::HitTestPoint(POINT pt, BOOL* pbHit, LONG *plPartID)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::HitTestPoint()",
              this));
    
    *pbHit = TRUE;
    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::OnResize(SIZE size)
{
    return S_OK;
}

void
CTIMEMediaElement::InvalidateRenderInfo()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::InvalidateRenderInfo",
              this));

    if (m_spPaintSite)
    {
        m_spPaintSite->InvalidatePainterInfo();
    }
    else if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->InvalidateRenderInfo();
    }

}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::OnPropertiesLoaded, CBaseBvr
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEMediaElement::OnPropertiesLoaded(void)
{
    HRESULT hr;
    // Once we've read the properties in, 
    // set up the timeline.  This is immutable
    // in script.
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::OnPropertiesLoaded"));

    m_fInPropLoad = true;
    hr = CTIMEElementBase::OnPropertiesLoaded();
    m_fInPropLoad = false;

    if (!m_fLoaded)
    {
        hr = CreatePlayer(m_playerToken);
        if (FAILED(hr) || !m_Player)
        {
            goto done;
        }

        if (GetElement())
        {
            CComBSTR pbstrReadyState;
            IHTMLElement *pEle = GetElement();
            hr = GetReadyState(pEle, &pbstrReadyState);
            if (FAILED(hr))
            {
                goto done;
            }
            if (StrCmpIW(pbstrReadyState, L"complete") == 0)
            {
                InitOnLoad();
                OnLoad();
            }
        }
    }

done:
    return hr;
} // OnPropertiesLoaded


//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

STDMETHODIMP
CTIMEMediaElement::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

bool
CTIMEMediaElement::NeedSizeChange()
{
    HRESULT hr = S_OK;
    bool bAutoSize = false;
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs;
    CComPtr<IHTMLCurrentStyle> sc;
    CComPtr<IHTMLElement2> pEle2;
    VARIANT styleWidth, styleHeight;
    
    VariantInit(&styleWidth);
    VariantInit(&styleHeight);

    hr = GetElement()->get_style(&s);
    if (FAILED(hr) || s == NULL)
    {
        goto done;
    }
    hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
    if(SUCCEEDED(hr))
    {
        hr = pEle2->get_currentStyle(&sc);
        if (FAILED(hr) || sc == NULL)
        {
            goto done;
        }
        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        hr = sc->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

        hr = sc -> get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

        VariantClear(&styleWidth); 
        hr = rs->get_width( &styleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleWidth.vt == VT_BSTR) && (styleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(styleWidth.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

        VariantClear(&styleHeight);
        hr = rs->get_height( &styleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((styleHeight.vt == VT_BSTR) && (styleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(styleHeight.bstrVal, L"auto") == 0)
            {
                bAutoSize = true;
            }
        }

    }


done:

    VariantClear(&styleWidth);
    VariantClear(&styleHeight);

    return bAutoSize;
}

STDMETHODIMP
CTIMEMediaElement::OnChanged(DISPID dispID)
{
    CComPtr<IHTMLStyle> s;
    CComPtr<IHTMLStyle> rs = NULL;
    CComPtr<IHTMLElement2> pEle2;
    HRESULT hr = S_OK;
    CComVariant svarStyleWidth, svarStyleHeight;
    long pixelWidth = 0, pixelHeight = 0;
    bool fstyleWidth = false, fstyleHeight = false;
    RECT rNativeSize, rElementSize;
    bool fisNative;

    if( m_fInOnChangedFlag)
        return S_OK;

    m_fInOnChangedFlag = true;

    switch(dispID)
    {
    case DISPID_IHTMLCURRENTSTYLE_TOP:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():TOP", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_LEFT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():LEFT", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_WIDTH:
    case DISPID_IHTMLCURRENTSTYLE_HEIGHT:
        if(m_fIgnoreStyleChange)
        {
            break;
        }
        if (m_rcMediaSize.right != 0 && m_rcMediaSize.bottom != 0 && NeedSizeChange() == true)
        {
            bool bNativeSize;
            RECT rcFinalSize;
            NegotiateSize(m_rcMediaSize, rcFinalSize, bNativeSize);
        }       
        break;
    case DISPID_IHTMLSTYLE_CSSTEXT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():TEXT", this));
        
        hr = GetElement()->get_style(&s);
        if (FAILED(hr) || s == NULL)
        {
            goto done;
        }
        hr = s->get_width( &svarStyleWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((svarStyleWidth.vt == VT_BSTR) && (svarStyleWidth.bstrVal != NULL))
        {
            if(StrCmpIW(svarStyleWidth.bstrVal, L"auto") != 0)
            {
                fstyleWidth = true;
                if(ConvertToPixels(&svarStyleWidth, L"width"))
                {
                    pixelWidth = svarStyleWidth.fltVal; //lint !e524
                    SetWidth(pixelWidth);
                }
            }
        }

        hr = s -> get_height( &svarStyleHeight);
        if (FAILED(hr))
        {
            goto done;
        }
        if ((svarStyleHeight.vt == VT_BSTR) && (svarStyleHeight.bstrVal != NULL))
        {
            if(StrCmpIW(svarStyleHeight.bstrVal, L"auto") != 0)
            {
                fstyleHeight = true;
                if(ConvertToPixels(&svarStyleHeight, L"height"))
                {
                    pixelHeight = svarStyleHeight.fltVal; //lint !e524
                    SetHeight(pixelHeight);
                }
            }
        }

        if(fstyleHeight || fstyleWidth)
        {
            goto done;
        }

        if(!m_Player)
        {
            goto done;
        }

        rNativeSize.top = rNativeSize.left = 0;

        hr = m_Player->GetNaturalWidth(&(rNativeSize.right));
        if(FAILED(hr) || rNativeSize.right == -1)
        {
            goto done;
        }
        hr = m_Player->GetNaturalHeight(&(rNativeSize.bottom));
        if(FAILED(hr) || rNativeSize.bottom == -1)
        {
            goto done;
        }
        VariantClear(&svarStyleWidth);
        VariantClear(&svarStyleHeight);
        hr = GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pEle2));
        if(FAILED(hr))
        {
            goto done;
        }

        hr = pEle2->get_runtimeStyle(&rs);
        if (FAILED(hr) || rs == NULL)
        {
            goto done;
        }

        svarStyleWidth = L"auto";
        svarStyleHeight = L"auto";

        IGNORE_HR(rs->put_width(svarStyleWidth));
        IGNORE_HR(rs->put_height(svarStyleHeight));

        NegotiateSize( rNativeSize, rElementSize, fisNative);

        break;
    default:
        break;
    }
done:
    m_fInOnChangedFlag = false;
    return hr;
}


HRESULT
CTIMEMediaElement::GetNotifyConnection(IConnectionPoint **ppConnection)
{
    HRESULT hr = S_OK;

    Assert(ppConnection != NULL);
    *ppConnection = NULL;

    IConnectionPointContainer *pContainer = NULL;
    IHTMLElement *pElement = GetElement();

    // Get connection point container
    hr = pElement->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pContainer));
    if(FAILED(hr))
        goto end;
    
    // Find the IPropertyNotifySink connection
    hr = pContainer->FindConnectionPoint(IID_IPropertyNotifySink, ppConnection);
    if(FAILED(hr))
        goto end;

end:
    ReleaseInterface( pContainer );

    return hr;
}

//*****************************************************************************

/**
* Initializes a property sink on the current style of the animated element so that
* can observe changes in width, height, visibility, zIndex, etc.
*/
HRESULT
CTIMEMediaElement::InitPropertySink()
{
    HRESULT hr = S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr))
        return hr;

    // Advise on it
    hr = pConnection->Advise(GetUnknown(), &m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

HRESULT
CTIMEMediaElement::UnInitPropertySink()
{
    HRESULT hr = S_OK;

    if (m_dwAdviseCookie == 0)
        return S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr) || pConnection == NULL )
        return hr;

    // Unadvise on it
    hr = pConnection->Unadvise(m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    m_dwAdviseCookie = 0;

    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::Invoke( DISPID id,
                           REFIID riid,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pDispParams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pExcepInfo,
                           UINT *puArgErr)
{
    CComPtr<IDispatch> pDisp;
    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLEventObj> pEventObj;
    CComPtr<IHTMLElement2> pElem2;
    HRESULT hr = S_OK;
    CComBSTR bstrEventName;
    RECT elementRect;

    long mousex = 0;
    long mousey = 0;


    if (id != 0) // we are only proccesing the onresize event. For other event we call the parent method.
    {
        hr = ITIMEDispatchImpl<ITIMEMediaElement2, &IID_ITIMEMediaElement2>::Invoke(
                            id, riid, lcid, wFlags, pDispParams, pvarResult, pExcepInfo, puArgErr);
        goto done;
    }

    hr = THR(GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&pWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWindow->get_event(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pEventObj->get_type(&bstrEventName);
    if (FAILED(hr))
    {
        goto done;
    }

    if (StrCmpIW(bstrEventName, L"resize") == 0)
    {
        TraceTag((tagMediaTimeElm, "CTIMEMediaElement::Invoke::resize"));

        hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
        if (FAILED(hr))
        {
            goto done;       
        }

        long lPixelWidth, lPixelHeight;

        hr = pElem2->get_clientWidth(&lPixelWidth);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = pElem2->get_clientHeight(&lPixelHeight);
        if (FAILED(hr))
        {
            goto done;
        }

        elementRect.top = elementRect.left = 0;
        elementRect.right = lPixelWidth;
        elementRect.bottom = lPixelHeight;

        if(!m_Player) 
        {
            hr = E_FAIL;
            goto done;
        }
        hr = THR(m_Player -> SetSize(&elementRect));
    }
    else if (StrCmpIW(bstrEventName, L"scroll") == 0)
    {
    }
    else if (StrCmpIW(bstrEventName, L"mousemove") == 0)
    {
        pEventObj -> get_offsetX(&mousex);
        pEventObj -> get_offsetY(&mousey);
        TraceTag((tagMediaTimeElm, "CTIMEMediaElement::Invoke..mosemove %d %d", mousex, mousey));
    }

    
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::UpdatePlayerAudioProperties, CTIMEElementBase
//
//  Synopsis:   This method is implemented by elements directly affected by audio
//              properties. It forces the cascaded volume and mute to be set on
//              the player.
//              
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
void 
CTIMEMediaElement::UpdatePlayerAudioProperties()
{
    CascadedPropertyChanged(false);
} // UpdatePlayerAudioProperties


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::CascadedPropertyChanged, CTIMEElementBase
//
//  Synopsis:   This method is implemented by elements directly affected by cascaded
//              properties. Cascaded volume/mute are first computed by recursing up
//              till the root, and then set on the player object. If the fNotifyChildren
//              argument is true, the notification is propagated to all our children.
//
//  Arguments:  [fNotifyChildren]   flag that indicates whether to propagate this notification
//                                  to children
//
//  Returns:    Failure     1. Properties could not be set on the player
//                          2. CTIMEElementBase::CascadedPropertyChanged failed
//
//              S_FALSE     Player has not yet been set
//
//              S_OK        Otherwise
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEMediaElement::CascadedPropertyChanged(bool fNotifyChildren)
{
    HRESULT hr;
    float   flVolume;
    bool    fMute;

    // this function maybe called before player has been set
    if (!m_Player || (GetMMBvr().GetEnabled() == false))
    {
        hr = S_FALSE;
        goto done;
    }

    GetCascadedAudioProps(&flVolume, &fMute);

    // set volume and mute
    if (m_Player)
    {
        IGNORE_HR(m_Player->SetVolume(flVolume));
    }

    if (m_Player)
    {
        IGNORE_HR(m_Player->SetMute(fMute ? VARIANT_TRUE : VARIANT_FALSE));
    }

    hr = S_OK;
done:
    // notify children always
    hr = THR(CTIMEElementBase::CascadedPropertyChanged(fNotifyChildren));

    return hr;
} // cascadedPropertyChanged


STDMETHODIMP 
CTIMEMediaElement::get_canSeek(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    HRESULT hr = S_OK;
    bool fcanSeek = false;

    CHECK_RETURN_NULL(pvbVal);
    *pvbVal = VARIANT_FALSE;

    if(!m_Player)
    {
        goto done;
    }

    hr = m_Player->CanSeek(fcanSeek);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    if (fcanSeek)
    {
        *pvbVal = VARIANT_TRUE;
    }
    else
    {
        *pvbVal = VARIANT_FALSE;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP 
CTIMEMediaElement::get_canPause(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    HRESULT hr = S_OK;
    bool bIsBroad;

    CHECK_RETURN_NULL(pvbVal);
    *pvbVal = VARIANT_FALSE;

    if(!m_Player)
    {
        goto done;
    }
    hr = m_Player->IsBroadcast(bIsBroad);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    if (bIsBroad)
    {
        *pvbVal = VARIANT_FALSE;
    }
    else
    {
        *pvbVal = VARIANT_TRUE;
    }

done:
    return S_OK;
}

STDMETHODIMP 
CTIMEMediaElement::get_title(/*[out, retval]*/ BSTR *name)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(name);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetTitle(name);
done:
    if (FAILED(hr))
    {
        *name = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_copyright(/*[out, retval]*/ BSTR *cpyrght)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(cpyrght);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetCopyright(cpyrght);
done:
    if (FAILED(hr))
    {
        *cpyrght = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_hasAudio(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    bool fhasAudio;
    CHECK_RETURN_NULL(pvbVal);
    HRESULT hr = S_OK;

    *pvbVal = VARIANT_FALSE;

    if(m_Player)
    {
        hr = m_Player->HasAudio(fhasAudio);
        if(FAILED(hr))
        {
            *pvbVal = VARIANT_FALSE;
            goto done;
        }
        if(fhasAudio)
        {
            *pvbVal = VARIANT_TRUE;
        }
        else
        {
            *pvbVal = VARIANT_FALSE;
        }
    }
done:
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_hasVisual(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    bool fhasVisual;
    CHECK_RETURN_NULL(pvbVal);
    HRESULT hr = S_OK;

    *pvbVal = VARIANT_FALSE;

    if(m_Player)
    {
        hr = m_Player->HasVisual(fhasVisual);
        if(FAILED(hr))
        {
            *pvbVal = VARIANT_FALSE;
            goto done;
        }
        if(fhasVisual)
        {
            *pvbVal = VARIANT_TRUE;
        }
        else
        {
            *pvbVal = VARIANT_FALSE;
        }
    }
done:
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_author(/*[out, retval]*/ BSTR *auth)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(auth);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetAuthor(auth);
done:
    if (FAILED(hr))
    {
        *auth = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_abstract(/*[out, retval]*/ BSTR *abstract)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(abstract);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetAbstract(abstract);
done:
    if (FAILED(hr))
    {
        *abstract = SysAllocString(L"");
    }
    return S_OK;
}


STDMETHODIMP 
CTIMEMediaElement::get_rating(/*[out, retval]*/ BSTR *rate)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(rate);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetRating(rate);
done:
    if (FAILED(hr))
    {
        *rate = SysAllocString(L"");
    }
    return S_OK;
}

//Playlist methods
STDMETHODIMP
CTIMEMediaElement::get_playList(/*[out, retval]*/ ITIMEPlayList** ppPlayList)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(ppPlayList);

    //
    // Do lazy creation of playlist object
    //

    if (!m_pPlayListDelegator)
    {
        CComObject<CPlayListDelegator> * pPlayListDelegator = NULL;

        // create the object
        hr = THR(CComObject<CPlayListDelegator>::CreateInstance(&pPlayListDelegator));
        if (FAILED(hr))
        {
            goto done;
        }
    
        // cache a pointer to the PlayList Delegator object
        pPlayListDelegator->AddRef();
        m_pPlayListDelegator = static_cast<CPlayListDelegator*>(pPlayListDelegator);

        // init the playlist
        if (m_Player)
        {
            CComPtr<ITIMEPlayList> spPlayList;

            hr = THR(m_Player->GetPlayList(&spPlayList));
            if (FAILED(hr) && hr != E_NOTIMPL)
            {
                THR(m_pPlayListDelegator->QueryInterface(IID_TO_PPV(ITIMEPlayList, ppPlayList)));
                hr = S_OK;
                goto done;
            }

            m_pPlayListDelegator->AttachPlayList(spPlayList);
        }
    }

    // return the requested interface
    hr = THR(m_pPlayListDelegator->QueryInterface(IID_TO_PPV(ITIMEPlayList, ppPlayList)));
    if (FAILED(hr))
    {
        // this should not happen
        Assert(false);
        goto done;
    }

    hr = S_OK;

  done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::get_hasPlayList(VARIANT_BOOL * pvbVal)
{
    CHECK_RETURN_NULL(pvbVal);
    
    *pvbVal = VARIANT_FALSE;

    if (m_Player)
    {
        bool fHasPlayList = false;
        IGNORE_HR(m_Player->HasPlayList(fHasPlayList));
        *pvbVal = (fHasPlayList ? VARIANT_TRUE : VARIANT_FALSE);
    }

    return S_OK;
}

STDMETHODIMP 
CTIMEMediaElement::get_mediaWidth(long *width)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(width);

    *width = -1;
    
    
    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if (m_Player)
    {
        hr = THR(m_Player->GetNaturalWidth(width));
        if (FAILED(hr))
        {
            *width = -1;
            hr = S_OK;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEMediaElement::get_mediaDur(double *dblDuration)
{
    HRESULT hr;

    CHECK_RETURN_NULL(dblDuration);

    *dblDuration = -1.0;

    if ((GetMMBvr().GetEnabled() == false))
    {
        hr = S_OK;
        goto done;
    }

    if (m_Player)
    {
        hr = THR(m_Player->GetMediaLength(*dblDuration));
        if (FAILED(hr))
        {
            *dblDuration = -1.0;
            hr = S_OK;
            goto done;
        }
        
        if (*dblDuration == 0.0)
        {
            bool bUnresolved = true;
            TimeValueSTLList & l = m_realEndValue.GetList();
            for (TimeValueSTLList::iterator iter = l.begin();
                 iter != l.end();
                 iter++)
            {
                TimeValue *p = (*iter);

                if (p->GetEvent() == NULL)
                {
                    bUnresolved = false;
                }        
            }

            if (bUnresolved == true)
            {
                *dblDuration = HUGE_VAL;
            }
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEMediaElement::get_mediaHeight(long *height)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(height);

    *height = -1;

    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if (m_Player)
    {
        hr = THR(m_Player->GetNaturalHeight(height));
        if (FAILED(hr))
        {
            *height = -1;
            hr = S_OK;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

void 
CTIMEMediaElement::FireMediaEvent(PLAYER_EVENT plEvent)
{
    //This should mean that a new list is available so the old one has to be cleared.
    //need to clear the natural duration of the element
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    switch(plEvent)
    {
      case PE_ONTRACKCOMPLETE:
        UpdatePlayerAudioProperties();
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
        break;
      case PE_ONMEDIACOMPLETE:
        if (m_pPlayListDelegator)
        {
            CComPtr<ITIMEPlayList> spPlayList;

            hr = THR(m_Player->GetPlayList(&spPlayList));
            if (FAILED(hr))
            {
                hr = S_OK;
                goto done;
            }

            m_pPlayListDelegator->AttachPlayList(spPlayList);
        }

        IGNORE_HR(FireEvents(TE_ONMEDIACOMPLETE, 0, NULL, NULL));
        FireTrackChangeEvent();
        UpdatePlayerAudioProperties();
        if (m_Player)
        {
            double dblLength = 0.0;
            hr = m_Player->GetMediaLength(dblLength);
            if (FAILED(hr))
            {
                goto done;
            }
            if (dblLength == 0.0 && m_FADur.IsSet() == false)
            {
                m_FADur.InternalSet(0.0);
            }
            NotifyPropertyChanged(DISPID_TIMEELEMENT_DUR);
        }
        break;
      case PE_ONMEDIAEND:
        break;
      case PE_ONMEDIAINSERTED:
        IGNORE_HR(FireEvents(TE_ONMEDIAINSERTED, 0, NULL, NULL));
        break;
      case PE_ONMEDIAREMOVED:
        IGNORE_HR(FireEvents(TE_ONMEDIAREMOVED, 0, NULL, NULL));
        break;
      case PE_ONMEDIALOADFAILED:
        break;
      case PE_ONRESIZE:
        break;
      case PE_ONMEDIATRACKCHANGED:
        NotifyTrackChange();
        FireTrackChangeEvent();
        break;
      case PE_METAINFOCHANGED:
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
        break;
      case PE_ONMEDIASLIPSLOW:
        TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::PE_ONMEDIASLIPSLOW()",
                  this));
        if(!IsSyncMaster())
        {
            fHaveTESpeed = GetTESpeed(flTeSpeed);
            if(fHaveTESpeed && (flTeSpeed < 0.0))
            {
                break;
            }
            IGNORE_HR(PauseTimeSubTree());
        }
        else
        {
            m_fWaitForSync = true;
        }
        IGNORE_HR(FireEvents(TE_ONOUTOFSYNC, 0, NULL, NULL));
        break;
      case PE_ONMEDIASLIPFAST:
        TraceTag((tagMediaTimeElm,
                  "CTIMEMediaElement(%lx)::PE_ONMEDIASLIPFAST()",
                  this));
        if(!IsSyncMaster())
        {
            fHaveTESpeed = GetTESpeed(flTeSpeed);
            if(fHaveTESpeed && (flTeSpeed < 0.0))
            {
                break;
            }
            m_fPauseForSync = true;
            m_Player->Pause();
            m_pSyncElem = this;
        }
        else
        {
            m_fPauseForSync = true;
        }
        IGNORE_HR(FireEvents(TE_ONOUTOFSYNC, 0, NULL, NULL));
        break;
      case PE_ONSYNCRESTORED:
        IGNORE_HR(FireEvents(TE_ONSYNCRESTORED, 0, NULL, NULL));
        break;
      case PE_ONMEDIAERRORCOLORKEY:
        //IGNORE_HR(FireEvents(TE_ONMEDIAERROR, 0, NULL, NULL));
        m_Player->LoadFailNotify(PE_ONMEDIAERRORCOLORKEY);
        break;
      case PE_ONMEDIAERRORRENDERFILE:
        IGNORE_HR(FireEvents(TE_ONMEDIAERROR, 0, NULL, NULL));
        m_Player->LoadFailNotify(PE_ONMEDIAERRORRENDERFILE);
        break;
      case PE_ONMEDIAERROR:
        IGNORE_HR(FireEvents(TE_ONMEDIAERROR, 0, NULL, NULL));
        if (IsSyncMaster())
        {
            PutCachedSyncMaster(false);
        }

        if ((m_FARepeatDur.IsSet() != m_FARepeat.IsSet()) &&
            (m_FADur.IsSet() == false) &&
            (m_SAEnd.IsSet() == false))
        {
            GetMMBvr().Disable();
        }
        else
        {
            GetMMBvr().PutNaturalDur(0.0);
        }

        break;
      case PE_ONCODECERROR:
        IGNORE_HR(FireEvents(TE_ONCODECERROR, 0, NULL, NULL));
        break;
      default:
        break;
    }
  done:
    return;
}

HRESULT
CTIMEMediaElement::PauseTimeSubTree()
{
    CTIMEElementBase *pelem = this;
    HRESULT hr = S_OK;
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::PauseTimeSubTree()",
              this));

    while(pelem)
    {
        if(!pelem->IsLocked())
        {
            break;
        }
        pelem = pelem -> GetParent();
    }

    if(pelem == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = pelem->QueryInterface(IID_ITIMEElement, (void **)&m_pSyncNode);
    if(SUCCEEDED(hr))
    {
        m_fWaitForSync = true;
        m_fFirstPause = true;
        pelem->base_pauseElement();
        m_pSyncElem = pelem;
    }

    hr = S_OK;

done:
    return hr;
}

void
CTIMEMediaElement::UpdateSync()
{
    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if(m_Player && m_fWaitForSync)
    {
        if(m_Player->UpdateSync())
        {
            TraceTag((tagMediaTimeElm,
                      "CTIMEMediaElement(%lx)::UpdateSync():ResumeSlow",
                      this));
            if(!IsSyncMaster())
            {
                if (m_pSyncElem != NULL)
                {
                    m_pSyncElem->base_resumeElement();
                    m_pSyncElem = NULL;
                    m_pSyncNode = NULL;
                }
            }
            FireMediaEvent(PE_ONSYNCRESTORED);
            m_fWaitForSync = false;
        }
    }
    else if(m_Player && m_fPauseForSync)
    {
        if(m_Player->UpdateSync())
        {
            TraceTag((tagMediaTimeElm,
                      "CTIMEMediaElement(%lx)::UpdateSync():ResumeFast",
                      this));
            if(!IsSyncMaster())
            {
                m_Player->Resume();
                m_pSyncElem = NULL;
            }
            m_fPauseForSync = false;
            FireMediaEvent(PE_ONSYNCRESTORED);
        }
    }
    if(m_Player)
    {
        m_Player->Tick();
    }
  done:
    return;
}


void 
CTIMEMediaElement::FireTrackChangeEvent()
{
    CComPtr<ITIMEPlayItem> pPlayItem;
    CComPtr<ITIMEPlayItem2> pPlayItem2;
    CComPtr<ITIMEPlayList> pPlayList;
    HRESULT hr = S_OK;
    static LPWSTR pNames[] = {L"Banner", L"Abstract", L"MoreInfo"};
    VARIANTARG pvars[3];
    bool bHasPlayList = false;

    pvars[0].vt = VT_I4;
    pvars[1].vt = VT_I4;
    pvars[2].vt = VT_I4;

    hr = m_Player->HasPlayList(bHasPlayList);

    if(FAILED(hr) || (!bHasPlayList))
    {
        goto done;
    }

    if (m_pPlayListDelegator == NULL)
    {
        hr = get_playList(&pPlayList);
        if (FAILED(hr) || m_pPlayListDelegator == NULL)
        {
            goto done;
        }
    }

    if (m_pPlayListDelegator)
    {
        CComPtr<ITIMEPlayList> spPlayList;

        hr = THR(m_Player->GetPlayList(&spPlayList));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        m_pPlayListDelegator->AttachPlayList(spPlayList);
    }

    hr = m_pPlayListDelegator->get_activeTrack(&pPlayItem);
    if (FAILED(hr))
    {
        goto done;
    }

    if (pPlayItem != NULL)
    {
        hr = THR(pPlayItem->QueryInterface(IID_ITIMEPlayItem2, (void **)&pPlayItem2));
        if (FAILED(hr))
        {
            goto done;
        }
    
        hr = pPlayItem2->get_banner(&(pvars[0].bstrVal));
        if (FAILED(hr))
        {
            goto done;
        }
        pvars[0].vt = VT_BSTR;

        hr = pPlayItem2->get_bannerAbstract(&(pvars[1].bstrVal));
        if (FAILED(hr))
        {
            goto done;
        }
        pvars[1].vt = VT_BSTR;

        hr = pPlayItem2->get_bannerMoreInfo(&(pvars[2].bstrVal));
        if (FAILED(hr))
        {
            goto done;
        }
        pvars[2].vt = VT_BSTR;
    

        IGNORE_HR(FireEvents(TE_ONTRACKCHANGE, 3, pNames, pvars));
        }
    
  done:

    if (pvars[0].vt == VT_BSTR)
    {
        SysFreeString(pvars[0].bstrVal);
        pvars[0].bstrVal = NULL;
    }
    
    if (pvars[1].vt == VT_BSTR)
    {
        SysFreeString(pvars[1].bstrVal);
        pvars[1].bstrVal = NULL;
    }
    
    if (pvars[2].vt == VT_BSTR)
    {
        SysFreeString(pvars[2].bstrVal);
        pvars[2].bstrVal = NULL;
    }
    return;

}

void 
CTIMEMediaElement::NotifyTrackChange()
{
    NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK);

    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
    NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
}


void 
CTIMEMediaElement::GetBASEHREF()
{
    HRESULT hr;
    long nLength,index;

    CComPtr<IDispatch>              spDisp;
    CComPtr<IHTMLDocument2>         spDoc;
    CComPtr<IHTMLElementCollection> spChildrenElementCollection;
    CComPtr<IHTMLElementCollection> spBASEElementCollection;
    CComPtr<IDispatch>              spChildrenDisp;
    CComPtr<IDispatch>              spElementDisp;
    CComPtr<IHTMLElement>           spElement;
    CComBSTR                        bstrBASE  = L"BASE";
    CComBSTR                        bstrHREF  = L"href";
    CComVariant                     varName(bstrBASE);
    CComVariant                     varIndex;
    CComVariant                     varValue;

 
    if (m_baseHREF)
    {
        delete m_baseHREF;
        m_baseHREF = NULL;
    }

    if (!GetElement())
    {
        goto done;
    }

    hr = THR(GetElement()->get_document(&spDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spDisp->QueryInterface(IID_IHTMLDocument2, (void **)&spDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDoc->get_all(&spChildrenElementCollection);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spChildrenElementCollection->tags(varName,&spChildrenDisp);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = spChildrenDisp->QueryInterface(IID_TO_PPV(IHTMLElementCollection, &spBASEElementCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    varIndex.Clear();
    varName.Clear();
    varIndex = 0;

    spBASEElementCollection->get_length(&nLength);

    for (index = 0; index < nLength; index++)
    {
        varIndex = index;
        varValue.Clear();
        hr = spBASEElementCollection->item(varName, varIndex, &spElementDisp);
        if (FAILED(hr))
        {
            goto done;
        }
   
        hr = spElementDisp->QueryInterface(IID_TO_PPV(IHTMLElement, &spElement));
        if (FAILED(hr))
        {
            goto done;
        }
   
        hr = spElement->getAttribute(bstrHREF,NULL, &varValue);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (varValue.bstrVal != NULL)
        {
            m_baseHREF = CopyString(varValue.bstrVal);
            goto done;
        }
    }

    if (m_baseHREF == NULL)
    {
        CComPtr<IHTMLDocument2> pDoc;
        CComPtr<IDispatch> pDisp;
        BSTR tempBstr = NULL;

        hr = THR(GetElement()->get_document(&pDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
        if (FAILED(hr))
        {
            goto done;
        }

        pDoc->get_URL(&tempBstr);
        m_baseHREF = CopyString(tempBstr);
        SysFreeString(tempBstr);
    }
done:
    return; 
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::GetTimeState
//
//  Synopsis:   Gets timeState from the base class (active, inactive or holding), and
//              if that is "active", checks for media specific sub-states (cueing, seeking)
//
//  Arguments:  
//
//  Returns:    
//
//------------------------------------------------------------------------------------

TimeState
CTIMEMediaElement::GetTimeState()
{ 
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::GetTimeState()",
              this));

    TimeState ts = CTIMEElementBase::GetTimeState();

    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    // 
    // If time node is active check player for sub-states (cueing, seeking)
    //

    if (TS_Active != ts)
    {
        goto done;
    }
    
    // check if cueing or seeking
    if (m_Player)
    {
        PlayerState playerState;

        playerState = m_Player->GetState();

        switch (playerState)
        {
          case PLAYER_STATE_CUEING:
            {
                ts = TS_Cueing;
                break;
            }

          case PLAYER_STATE_ACTIVE:
            {
                // do nothing (state is already set to active)
                break;
            }

          case PLAYER_STATE_SEEKING:
            {
                //
                // ISSUE: dilipk 9/21/99: need to hook this up (#88122)
                //

                Assert(false);
                break;
            }

          default:
            {
                // This can happen if the player cannot play the
                // media.  In this case just return active
                break;
            }
        } // switch
    }

  done:
    return ts;
}

void
CTIMEMediaElement::ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool &fPlayAnimations)
{
    Assert(GetBody());
    GetBody()->ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
}

STDMETHODIMP
CTIMEMediaElement::Load(IPropertyBag2 *pPropBag, IErrorLog *pErrorLog)
{
    HRESULT hr = S_OK;

    m_fLoading = true;

    m_spPropBag = pPropBag;
    m_spErrorLog = pErrorLog;

    hr = THR(::TimeLoad(this, CTIMEMediaElement::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Load(pPropBag, pErrorLog)); 
done:
    m_spPropBag.Release();
    m_spErrorLog.Release();
    
    m_fLoading = false;

    return hr;
}

STDMETHODIMP
CTIMEMediaElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    IGNORE_HR(::TimeSave(this, CTIMEMediaElement::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));

    IGNORE_HR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));

    if (m_Player)
    {
        IGNORE_HR(m_Player->Save(pPropBag, fClearDirty, fSaveAllProperties));
    }
done:
    return S_OK;
}

HRESULT
CTIMEMediaElement::GetPropBag(IPropertyBag2 ** ppPropBag, IErrorLog ** ppErrorLog)
{
    HRESULT hr = S_OK;

    if (NULL == ppPropBag || NULL == ppErrorLog)
    {
        hr = E_INVALIDARG;
    }

    *ppPropBag = m_spPropBag;
    *ppErrorLog = m_spErrorLog;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    PutNaturalRepeatCount
//
//  Overview:  If there is no repeatCount set, 
//             set the repeatCount on the engine directly
//
//  Arguments: dblRepeatCount   number of times to repeat
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CTIMEMediaElement::PutNaturalRepeatCount(double dblRepeatCount)
{
    HRESULT hr = S_OK;
    
    // This is incorrect and we will remove for now until we implement
    // strip repeat
#if SUPPORT_STRIP_REPEAT
    if (!m_FARepeat.IsSet())
    {
        hr = GetMMBvr().GetMMBvr()->put_repeatCount(dblRepeatCount);
        hr = GetMMBvr().Reset(false);
    }
#endif
    
    hr = S_OK;
done:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    PutNaturalDuration
//
//  Arguments: dblNatDur   natural duration
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CTIMEMediaElement::PutNaturalDuration(double dblNatDur)
{
    HRESULT hr = S_OK;
    
    hr = (GetMMBvr().PutNaturalDur(dblNatDur));
    if(FAILED(hr))
    {
        goto done;
    }
    setNaturalDuration();                        
    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ClearNaturalDuration
//
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
CTIMEMediaElement::ClearNaturalDuration()
{
    HRESULT hr = S_OK;
    
    hr = THR(GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE));
    if(FAILED(hr))
    {
        goto done;
    }
    clearNaturalDuration();
    hr = S_OK;
done:
    return hr;
}

void
CTIMEMediaElement::UpdateClipTimes()
{
    double dblDuration = 0.0;    
    double flBeginTime = -1;
    double flEndTime = -1;
    int clipBeginType = -1;
    int clipEndType = -1;
    LONGLONG lTemp;
    HRESULT hr = S_OK;

    if(m_FAClipBegin.IsSet())
    {
        flBeginTime = m_FAClipBegin.GetValue();
        clipBeginType = 1;
    }
    else if(m_LAClipBegin.IsSet())
    {
        lTemp = m_LAClipBegin.GetValue();
        if(m_Player)
        {
            hr = m_Player->ConvertFrameToTime(lTemp, flBeginTime);
            if(SUCCEEDED(hr))
            {
                clipBeginType = 2;
            }
            else
            {
                flBeginTime = -1.0;
            }
        }
    }
    if(m_FAClipEnd.IsSet())
    {
        flEndTime = m_FAClipEnd.GetValue();
        clipEndType = 1;
    }
    else if(m_LAClipEnd.IsSet())
    {
        lTemp = m_LAClipEnd.GetValue();
        if(m_Player)
        {
            hr = m_Player->ConvertFrameToTime(lTemp, flEndTime);
            if(SUCCEEDED(hr))
            {
                clipEndType = 2;
            }
            else
            {
                flEndTime = -1.0;
            }
        }
    }

    if (flEndTime != -1 &&
        flBeginTime != -1 &&
        flEndTime <= flBeginTime)
    {
        flEndTime = -1;
    }
    if (!m_fLoaded)
    {
        goto done;
    }
        
    if ((GetMMBvr().GetEnabled() == false))
    {
        goto done;
    }

    if (m_Player)
    {
        if(clipBeginType == 1)
        {
            m_Player->SetClipBegin(flBeginTime);
        }
        else if(clipBeginType == 2)
        {
            m_Player->SetClipBeginFrame(m_LAClipBegin.GetValue());
        }

        if(clipEndType == 1)
        {
            m_Player->SetClipEnd(flEndTime);
        }
        else if(clipEndType == 2)
        {
            m_Player->SetClipEndFrame(m_LAClipEnd.GetValue());
        }
    }

    if (flBeginTime == -1)
    {
        flBeginTime = 0.0;
    }
    if (flEndTime != -1)
    {
        dblDuration = (double)(flEndTime - flBeginTime);
    }
    else
    {
        dblDuration = HUGE_VAL;
        if (m_Player)
        {
            m_Player->GetMediaLength(dblDuration);
        }

        if (dblDuration < HUGE_VAL)
        {
            dblDuration = dblDuration - flBeginTime;
        }
    }
    if (dblDuration < HUGE_VAL)
    {
        if (dblDuration < 0.001)
        {
            //we cannot allow a smaller duration than this, if this repeats it could.
            //appear to hang the browser.
            dblDuration = 0.001;
        }

        PutNaturalDuration(dblDuration);
    }
  done:
    return;
}


//+-----------------------------------------------------------------------
//
//  String to pixel conversion functions.
//
//
// 
//
//------------------------------------------------------------------------
static const LPWSTR PX   = L"px";

#define HORIZ   true
#define VERT    false

typedef struct _VALUE_PAIR
{
    const WCHAR *wzName;
    bool         bValue;
} VALUE_PAIR;

#define VALUE_NOT_SET         -999.998

const VALUE_PAIR 
rgPropOr[] =
{
    { (L"backgroundPositionX"),     HORIZ  },
    { (L"backgroundPositionY"),     VERT   },
    { (L"borderBottomWidth"),       VERT   },
    { (L"borderLeftWidth"),         HORIZ  },
    { (L"borderRightWidth"),        HORIZ  },
    { (L"borderTopWidth"),          VERT   },
    { (L"bottom"),                  VERT   },
    { (L"height"),                  VERT   },
    { (L"left"),                    HORIZ  },
    { (L"letterSpacing"),           HORIZ  },
    { (L"lineHeight"),              VERT   },
    { (L"marginBottom"),            VERT   },
    { (L"marginLeft"),              HORIZ  },
    { (L"marginRight"),             HORIZ  },
    { (L"marginTop"),               VERT   },
    { (L"overflowX"),               HORIZ  },
    { (L"overflowY"),               VERT   },
    { (L"pixelBottom"),             VERT   },
    { (L"pixelHeight"),             VERT   },
    { (L"pixelLeft"),               HORIZ  },
    { (L"pixelRight"),              HORIZ  },
    { (L"pixelTop"),                VERT   },
    { (L"pixelWidth"),              HORIZ  },
    { (L"posBottom"),               VERT   },
    { (L"posHeight"),               VERT   },
    { (L"posLeft"),                 HORIZ  },
    { (L"posRight"),                HORIZ  },
    { (L"posTop"),                  VERT   },
    { (L"posWidth"),                HORIZ  },
    { (L"right"),                   HORIZ  },
    { (L"textIndent"),              HORIZ  },
    { (L"width"),                   HORIZ  }
}; // rgPropOr[]

#define SIZE_OF_VALUE_TABLE (sizeof(rgPropOr) / sizeof(VALUE_PAIR))



typedef struct _CONVERSION_PAIR
{
    WCHAR  *wzName;
    double  dValue;
} CONVERSION_PAIR;


const CONVERSION_PAIR 
rgPixelConv[] =
{
    // type , convertion to inches
    { (L"in"),   1.00  },
    { (L"cm"),   2.54  },
    { (L"mm"),  25.40  },
    { (L"pt"),  72.00  },
    { (L"pc"), 864.00  }
}; // 

#define SIZE_OF_CONVERSION_TABLE (sizeof(rgPixelConv) / sizeof(CONVERSION_PAIR))


///////////////////////////////////////////////////////////////
//  Name: CompareValuePairs
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
static int __cdecl
CompareValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((VALUE_PAIR*)pv1)->wzName,
                    ((VALUE_PAIR*)pv2)->wzName);
} 


///////////////////////////////////////////////////////////////
//  Name: ConvertToPixels
//
//  Abstract:
//    
///////////////////////////////////////////////////////////////
bool
ConvertToPixels(VARIANT *pvarValue, WCHAR *pAttribute)
{
    int  pixelPerInchVert, pixelPerInchHoriz, pixelFactor;
    LPOLESTR szTemp  = NULL;
    HDC hdc;
    double fVal = VALUE_NOT_SET;
    HRESULT hr;
    bool bReturn = false;

    pixelPerInchHoriz=pixelPerInchVert=0;
    if (pvarValue->vt != VT_BSTR)
    {
        // no conversion to do...just return.
        bReturn = true;
        goto done;
    }
    // see if we can just do a straight converstion.
    hr = VariantChangeTypeEx(pvarValue,pvarValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
    if (SUCCEEDED(hr))
    {
        bReturn = true;
        goto done;
    }

    // see if the bstr is empty
    if (ocslen(pvarValue->bstrVal) == 0)
    {
        SysFreeString(pvarValue->bstrVal);
        pvarValue->vt   = VT_R4;
        pvarValue->fltVal = 0;
        bReturn = true;
        goto done;
    }


    szTemp = CopyString(pvarValue->bstrVal);
    if (NULL == szTemp)
    {
        goto done;
    }

    hdc = GetDC(NULL);
    if (NULL != hdc)
    {
        pixelPerInchHoriz = g_LOGPIXELSX;
        pixelPerInchVert  = g_LOGPIXELSY;
        ReleaseDC(NULL, hdc);
    }


    // Determine the PixelFactor based on what the target is...
    {
        VALUE_PAIR valName;
        valName.wzName = pAttribute;

        VALUE_PAIR * pValPair = (VALUE_PAIR*)bsearch(&valName,
                                              rgPropOr,
                                              SIZE_OF_VALUE_TABLE,
                                              sizeof(VALUE_PAIR),
                                              CompareValuePairsByName);

        if (NULL == pValPair)
            pixelFactor = (pixelPerInchVert + pixelPerInchHoriz) /2;
        else
            pixelFactor = pValPair->bValue == HORIZ ? pixelPerInchHoriz : pixelPerInchVert;
    }


    {
        // See if we have PIXELS
        if (ConvertToPixelsHELPER(szTemp, PX, 1, 1, &fVal))
        {
            bReturn = true;
            goto done;
        }
     
        // Try to convert to Pixels.
        unsigned i;
        for(i=0; i < SIZE_OF_CONVERSION_TABLE;i++)
        {
            if (ConvertToPixelsHELPER(szTemp, rgPixelConv[i].wzName, rgPixelConv[i].dValue, pixelFactor, &fVal))
            {
                bReturn = true;
                goto done;
            }
        }
    }

done:
    if (fVal != VALUE_NOT_SET)
    {
        ::VariantClear(pvarValue);
        pvarValue->vt     = VT_R4;
        pvarValue->fltVal = fVal; //lint !e736
    }
    if (szTemp)
    {
        delete [] szTemp;
    }
    return bReturn;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEMediaElement::IsFilterAttached
//
//  Synopsis:   Returns true if a filter is attached to the HTML element
//
//  Arguments:  None
//
//  Returns:    true/false
//
//------------------------------------------------------------------------------------
bool                
CTIMEMediaElement::IsFilterAttached()
{
    bool fHasFilters = false;
    CComPtr<IHTMLFiltersCollection> pFilters;    
    long length = 0;
    HRESULT hr;

    if (GetElement())
    {
        hr = THR(GetElement()->get_filters(&pFilters));
        if (FAILED(hr))
        {
            goto done;
        }

        if (pFilters.p) 
        {
            hr = THR(pFilters->get_length(&length));
            if (FAILED(hr))
            {
                goto done;
            }

            if (length > 0)
            {
                fHasFilters = true;
            }            
        }
    }

done:
    return fHasFilters;
}

HRESULT
CTIMEMediaElement::StartRootTime(MMTimeline * tl)
{
    HRESULT hr = S_OK;

    IsNativeSize();

    hr = CTIMEElementBase::StartRootTime(tl);
    if(FAILED(hr))
    {
        goto done;
    }

    if(!IsSyncMaster())
    {
        SetSyncMaster(true);
    }


    if(m_sHasSyncMMediaChild == -1)
    {
        goto done;
    }

    RemoveSyncMasterFromBranch(*(m_pTIMEChildren + m_sHasSyncMMediaChild));

done:
    return hr;
}

void
CTIMEMediaElement::StopRootTime(MMTimeline * tl)
{
    CTIMEElementBase::StopRootTime(tl);

done:
    return;
}

void CTIMEMediaElement::NotifyPropertyChanged(DISPID dispid)
{
    CTIMEElementBase::NotifyPropertyChanged(dispid);

    // need this to work with proxy players that cannot fire events.
    // on specifying the source, we fire a ONMEDIACOMPLETE event
    // which should trigger some stuff for us.
    if (dispid == DISPID_TIMEMEDIAPLAYER_SRC)
    {
        FireMediaEvent(PE_ONMEDIACOMPLETE);
    }      
    else if (dispid == DISPID_TIMEPLAYLIST_ACTIVETRACK)
    {
        FireTrackChangeEvent();
    }
    else if (dispid == DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR)
    {
        FireMediaEvent(PE_ONMEDIAERROR);
    }

    
}

STDMETHODIMP
CTIMEMediaElement::get_earliestMediaTime(VARIANT * earliestMediaTime)
{
    HRESULT hr;
    double dblEarliest;
    
    if (earliestMediaTime == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetEarliestMediaTime(dblEarliest))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(earliestMediaTime))))
    {
        hr = S_FALSE;
        goto done;
    }

    earliestMediaTime->vt = VT_R8;
    earliestMediaTime->dblVal = dblEarliest;

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_latestMediaTime(VARIANT * latestMediaTime)
{
    HRESULT hr;
    double dblLatest;
    
    if (latestMediaTime == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetLatestMediaTime(dblLatest))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(latestMediaTime))))
    {
        hr = S_FALSE;
        goto done;
    }
    latestMediaTime->vt = VT_R8;
    latestMediaTime->dblVal = dblLatest;

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_minBufferedMediaDur(VARIANT * minBufferedMediaDur)
{
    HRESULT hr;
    
    if (minBufferedMediaDur == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(minBufferedMediaDur))))
    {
        hr = S_FALSE;
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::put_minBufferedMediaDur(VARIANT minBufferedMediaDur)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;

    if(V_VT(&minBufferedMediaDur) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &minBufferedMediaDur);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    if(!clearFlag)
    {
        //Set value
    }
    else
    {
        //Set value to default
    }

done:
    return S_OK;
}



STDMETHODIMP
CTIMEMediaElement::get_downloadTotal(VARIANT * downloadTotal)
{
    HRESULT hr;
    LONGLONG lldownloadTotal;
    
    if (downloadTotal == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetDownloadTotal(lldownloadTotal))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(downloadTotal))))
    {
        hr = S_FALSE;
        goto done;
    }

    downloadTotal->vt = VT_R8;
    downloadTotal->dblVal = lldownloadTotal; //ISSUE use LONGLONG variants, not tolerated by script.

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_downloadCurrent(VARIANT * downloadCurrent)
{
    HRESULT hr;
    LONGLONG lldownloadCurrent;
    
    if (downloadCurrent == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetDownloadCurrent(lldownloadCurrent))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(downloadCurrent))))
    {
        hr = S_FALSE;
        goto done;
    }
    downloadCurrent->vt = VT_R8;
    downloadCurrent->dblVal = lldownloadCurrent; //ISSUE use LONGLONG variants, not tolerated by script.

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_isStreamed(VARIANT_BOOL * isStreamed)
{
    HRESULT hr;
    bool fIsStreamed;
    
    if (isStreamed == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetIsStreamed(fIsStreamed))))
    {
        hr = S_FALSE;
        goto done;
    }

    if(fIsStreamed)
    {
        *isStreamed = VARIANT_TRUE;
    }
    else
    {
        *isStreamed = VARIANT_FALSE;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_bufferingProgress(VARIANT * bufferingProgress)
{
    HRESULT hr;
    double dblpctProgress = 0.0;
    
    if (bufferingProgress == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetBufferingProgress(dblpctProgress))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(bufferingProgress))))
    {
        goto done;
    }
    bufferingProgress->vt = VT_R8;
    bufferingProgress->dblVal = dblpctProgress;

    hr = S_OK;
  done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::get_hasDownloadProgress(VARIANT_BOOL * hasDownloadProgress)
{
    HRESULT hr;
    bool fhasDownloadProgress = true;
    
    if (hasDownloadProgress == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetHasDownloadProgress(fhasDownloadProgress))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (fhasDownloadProgress)
    {
        *hasDownloadProgress = VARIANT_TRUE;
    }
    else
    {
        *hasDownloadProgress = VARIANT_FALSE;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_downloadProgress(VARIANT * downloadProgress)
{
    HRESULT hr;
    double dblpctProgress = 0.0;
    
    if (downloadProgress == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetDownloadProgress(dblpctProgress))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(downloadProgress))))
    {
        goto done;
    }
    downloadProgress->vt = VT_R8;
    downloadProgress->dblVal = dblpctProgress;

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP 
CTIMEMediaElement::get_mimeType(/*[out, retval]*/ BSTR *mimeType)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(mimeType);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetMimeType(mimeType);
done:
    if (FAILED(hr))
    {
        *mimeType = SysAllocString(L"");
    }
    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::seekToFrame(long lframe)
{
    HRESULT hr = S_OK;
    double dblMediaTime = 0.0;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = m_Player->ConvertFrameToTime(lframe, dblMediaTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        goto done;
    }

    hr = base_seekSegmentTime(dblMediaTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }

done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::seekActiveTrack(double dblSeekTime)
{
    HRESULT hr = S_OK;
    double dblMediaTime = 0.0;
    CComPtr<ITIMEPlayList> spPlayList;
    CComPtr<ITIMEPlayItem> pItem;
    double dblTrackDur;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = THR(m_Player->GetPlayList(&spPlayList));
    if (SUCCEEDED(hr))
    {

        hr = spPlayList->get_activeTrack(&pItem);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }

        hr = pItem->get_dur(&dblTrackDur);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }

        if(dblSeekTime > dblTrackDur)
        {
            goto done;
        }

        hr = m_Player->GetPlaybackOffset(dblMediaTime);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = base_seekSegmentTime(dblMediaTime + dblSeekTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }

done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_activeTrackTime(double *dblActiveTrackTime)
{
    HRESULT hr = S_OK;
    double dblMediaTime = 0.0;
    CComPtr<ITIMEPlayList> spPlayList;
    CComPtr<ITIMEPlayItem> pItem;

    *dblActiveTrackTime = -1.0;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = THR(m_Player->GetPlayList(&spPlayList));
    if (SUCCEEDED(hr))
    {
        hr = m_Player->GetEffectiveOffset(dblMediaTime);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    *dblActiveTrackTime = GetMMBvr().GetSimpleTime() - dblMediaTime;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_currentFrame(long *currFrame)
{
    HRESULT hr = S_OK;
    LONGLONG lcurFrame = -1.0;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = m_Player->GetCurrentFrame(lcurFrame);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        *currFrame = -1;
        goto done;
    }

    *currFrame = lcurFrame;
done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::decodeMimeType(TCHAR * header, long headerSize, BSTR * mimeType)
{
    HRESULT hr = S_OK;
    CTIMEParser pParser(header);
    TCHAR *localHeader = NULL;

    if(header == NULL || headerSize < 4)
    {
        *mimeType = SysAllocString(L"");
        goto done;
    }

    CHECK_RETURN_SET_NULL(mimeType);

    hr = pParser.ParsePlayList(NULL, true);

    if(SUCCEEDED(hr))
    {
        *mimeType = SysAllocString(L"asx");
    }
    else
    {
        *mimeType = SysAllocString(L"");
    }

done:
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CTIMEMediaElement::InitTransitionSite (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTransitionSite,
              "CTIMEMediaElement(%p)::InitTransitionSite()",
              this));

    
    if (m_Player)
    {
        hr = THR(m_Player->NotifyTransitionSite(true));
    }

done :
    RRETURN(hr);
}

//*****************************************************************************

STDMETHODIMP
CTIMEMediaElement::DetachTransitionSite (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTransitionSite,
              "CTIMEMediaElement(%p)::DetachTransitionSite()",
              this));

    if (m_Player)
    {
        hr = THR(m_Player->NotifyTransitionSite(false));
    }

done :
    RRETURN(hr);
}

HRESULT 
CTIMEMediaElement::GetEventRelaySite (IUnknown **ppiEventRelaySite)
{
    HRESULT hr = S_OK;

    if (NULL == ppiEventRelaySite)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_pBvrSite)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = THR(m_pBvrSite->QueryInterface(IID_TO_PPV(IUnknown, ppiEventRelaySite)));
    if ( (FAILED(hr)) || (NULL == (*ppiEventRelaySite)) )
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\mpctnsite.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: mpctnsite.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------



#include "headers.h"
#include "mpctnsite.h"
#include "containerobj.h"

DeclareTag(tagMPContainerSite, "TIME: Players", "CMPContainerSite methods");

//DEFINE_GUID(DIID__MediaPlayerEvents,0x2D3A4C40,0xE711,0x11d0,0x94,0xAB,0x00,0x80,0xC7,0x4C,0x7E,0x95);

CMPContainerSite::CMPContainerSite()
: m_dwEventsCookie(0),
  m_fAutosize(false),
  m_lNaturalHeight(0),
  m_lNaturalWidth(0),
  m_fSized(false),
  m_pMPHost(NULL)
{
}

CMPContainerSite::~CMPContainerSite()
{
    CMPContainerSite::Detach();
}

HRESULT
CMPContainerSite::Init(CMPContainerSiteHost &pHost,
                       IUnknown * pCtl,
                       IPropertyBag2 *pPropBag,
                       IErrorLog *pErrorLog,
                       bool bSyncEvents)
{
    HRESULT hr;

    hr = THR(CContainerSite::Init(pHost,
                                  pCtl,
                                  pPropBag,
                                  pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pMPHost = &pHost;

    if (bSyncEvents)
    {
        DAComPtr<IConnectionPointContainer> pcpc;
        // establish ConnectionPoint for Events
        hr = THR(m_pIOleObject->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc)));
        if (FAILED(hr))
        {
            goto done;
        }
    

        hr = THR(pcpc->FindConnectionPoint(DIID_TIMEMediaPlayerEvents, &m_pcpEvents));
        if (FAILED(hr))
        {
            goto done;
        }

        Assert(m_pcpEvents);

        hr = THR(m_pcpEvents->Advise((IUnknown *)(IDispatch*)this, &m_dwEventsCookie));
        if (FAILED(hr))
        {
            m_pcpEvents.Release();
            m_dwEventsCookie = 0;
            goto done;
        }

        Assert(m_dwEventsCookie != 0);

        hr = THR(pcpc->FindConnectionPoint(DIID__MediaPlayerEvents, &m_pcpMediaEvents));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        hr = THR(m_pcpMediaEvents->Advise((IUnknown *)(IDispatch*)this, &m_dwMediaEventsCookie));
        if (FAILED(hr))
        {
            hr = S_OK;
            m_pcpMediaEvents.Release();
            m_dwMediaEventsCookie = 0;
            goto done;
        }

    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }

    RRETURN(hr);
}

void
CMPContainerSite::Detach()
{
    // disconnect events
    if ((m_pcpEvents) && (m_dwEventsCookie != 0))
    {
        m_pcpEvents->Unadvise(m_dwEventsCookie);
        m_pcpEvents.Release();
        m_dwEventsCookie = 0;
    }
    if ((m_pcpMediaEvents) && (m_dwMediaEventsCookie != 0))
    {
        m_pcpMediaEvents->Unadvise(m_dwMediaEventsCookie);
        m_pcpMediaEvents.Release();
        m_dwMediaEventsCookie = 0;
    }

    CContainerSite::Detach();

    m_pMPHost = NULL;
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

STDMETHODIMP
CMPContainerSite::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

STDMETHODIMP
CMPContainerSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagMPContainerSite, "CMPContainerSite::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

STDMETHODIMP
CMPContainerSite::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

STDMETHODIMP
CMPContainerSite::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
                         DISPPARAMS *pDispParams, VARIANT *pVarResult,
                         EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{ 
    TraceTag((tagMPContainerSite, "CMPContainerSite::Invoke(%08X, %04X)", dispIDMember, wFlags));
    HRESULT hr;

    hr = ProcessEvent(dispIDMember,
                      pDispParams->cArgs, 
                      pDispParams->rgvarg);

    if (FAILED(hr))
    {
        hr = CContainerSite::Invoke(dispIDMember,
                                    riid,
                                    lcid,
                                    wFlags,
                                    pDispParams,
                                    pVarResult,
                                    pExcepInfo,
                                    puArgErr);
    }
    
    return hr;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        
//************************************************************

STDMETHODIMP
CMPContainerSite::EnumConnectionPoints(IEnumConnectionPoints ** ppEnum)
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::EnumConnectionPoints"));

    if (ppEnum == NULL)
    {
        TraceTag((tagError, "CMPContainerSite::EnumConnectionPoints - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        Finds a connection point with a particular IID.
//************************************************************

STDMETHODIMP
CMPContainerSite::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::FindConnectionPoint"));

    if (ppCP == NULL)
    {
        TraceTag((tagError, "CMPContainerSite::FindConnectionPoint - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onbegin()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onbegin"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onend()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onend"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onresume()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onresume"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onpause()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onpause"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onmediaready()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onmediaready"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onmedialoadfailed()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onmedialoadfailed"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED));
}

HRESULT
CMPContainerSite::_OnPosRectChange(const RECT *prcPos)
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    RECT rcPos;
    long lNaturalHeight, lNaturalWidth;

    CopyRect(&rcPos, prcPos);
    
    if (/*m_fSized == true ||*/
        m_pMPHost == NULL)
    {
        hr = S_FALSE;
        goto done;
    }
    
    //determine the natural size
    lNaturalHeight = rcPos.bottom - rcPos.top;
    lNaturalWidth = rcPos.right - rcPos.left;

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = lNaturalWidth;
    nativeSize.bottom = lNaturalHeight;
    m_lNaturalWidth = lNaturalWidth;
    m_lNaturalHeight = lNaturalHeight;

    if(m_lNaturalWidth == 0 || m_lNaturalHeight == 0)
    {
        m_lNaturalWidth = m_lNaturalHeight = 0;
    }

    hr = THR(m_pMPHost->NegotiateSize(nativeSize, elementSize, m_fAutosize));
    
    if(lNaturalWidth == 0 || lNaturalHeight == 0)
    {
        hr = S_FALSE;
        goto done;
    }

    m_fSized = true;
    
    if (!m_fAutosize)
    {
        hr = THR(m_pHost->GetContainerSize(&rcPos));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = THR(m_pHost->SetContainerSize(&rcPos));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_pInPlaceObject->SetObjectRects(&rcPos, &rcPos));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
} // OnPosRectChange

HRESULT
CMPContainerSite::ProcessEvent(DISPID dispid,
                               long lCount, 
                               VARIANT varParams[])
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::ProcessEvent(%lx)",this));

    HRESULT hr = S_OK;

    if (!m_pHost)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_pHost->ProcessEvent(dispid,
                                   lCount,
                                   varParams));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:

    return hr;
}

HRESULT
CreateMPContainerSite(CMPContainerSiteHost &pHost,
                      IUnknown * pCtl,
                      IPropertyBag2 *pPropBag,
                      IErrorLog *pError,
                      bool bSyncEvents,
                      CMPContainerSite ** ppSite)
{
    CHECK_RETURN_SET_NULL(ppSite);
    
    HRESULT hr;
    CComObject<CMPContainerSite> *pNew;
    CComObject<CMPContainerSite>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->Init(pHost,
                            pCtl,
                            pPropBag,
                            pError,
                            bSyncEvents));
        if (SUCCEEDED(hr))
        {
            pNew->AddRef();
            *ppSite = pNew;
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\mpctnsite.h ===
//+___________________________________________________________________________________
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: mpctnsite.h
//
//  Contents: 
//
//____________________________________________________________________________________



#ifndef _MPCTNSITE_H
#define _MPCTNSITE_H

#include "containersite.h"
#include "mediaprivate.h"

#define TIMEMEDIAPLAYEREVENTS_OFFSET                            0x0900
#define DISPID_TIMEMEDIAPLAYEREVENTS_BASE                       (TIMEMEDIAPLAYEREVENTS_OFFSET)
//
// ITIMEMediaPlayerEvents
//
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN                    (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONEND                      (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME                   (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x03)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE                    (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x04)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY               (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x05)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED          (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x07)

class
ATL_NO_VTABLE
CMPContainerSiteHost
: public CContainerSiteHost
{
  public:
    virtual HRESULT NegotiateSize(RECT &nativeSize,
                                  RECT &finalSize,
                                  bool &fIsNative) = 0;
};

class CContainerSite;

class
__declspec(uuid("afe601dd-ecd1-450e-9b90-d48b56153b82"))
ATL_NO_VTABLE
CMPContainerSite :
    public CComCoClass<CMPContainerSite, &__uuidof(CMPContainerSite)>,
    public CContainerSite,
    public IConnectionPointContainer
{
  public:
    CMPContainerSite();
    virtual ~CMPContainerSite();

    HRESULT Init(CMPContainerSiteHost &pHost,
                 IUnknown * pCtl,
                 IPropertyBag2 *pPropBag,
                 IErrorLog *pErrorLog,
                 bool bSyncEvents);
    virtual void Detach();

    //
    // IUnknown Methods
    //
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints **ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint **ppCP);

    // IDispatch Methods
    STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
    STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
    STDMETHODIMP Invoke(DISPID disIDMember,
                        REFIID riid,
                        LCID lcid,
                        unsigned short wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pVarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

    BEGIN_COM_MAP(CMPContainerSite)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_IID(DIID_TIMEMediaPlayerEvents, IDispatch)
        COM_INTERFACE_ENTRY_IID(DIID__MediaPlayerEvents, IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(CContainerSite)
    END_COM_MAP();

    // event methods that can be fired on the container
    void onbegin();
    void onend();
    void onresume();
    void onpause();
    void onmediaready();
    void onmedialoadfailed();

    void ClearAutosizeFlag() { m_fAutosize = false; }
    void ClearSizeFlag() { m_fSized = false; }
    long GetNaturalHeight() const { return m_lNaturalHeight; }
    long GetNaturalWidth() const { return m_lNaturalWidth; }

  protected:
    HRESULT _OnPosRectChange(const RECT * prc);
    HRESULT ProcessEvent(DISPID dispid,
                         long lCount = 0, 
                         VARIANT varParams[] = NULL);

  protected:
    CMPContainerSiteHost            *m_pMPHost;
    DWORD                            m_dwEventsCookie;
    DWORD                            m_dwMediaEventsCookie;
    DAComPtr<IConnectionPoint>       m_pcpEvents;
    DAComPtr<IConnectionPoint>       m_pcpMediaEvents;
    long                             m_lNaturalHeight;
    long                             m_lNaturalWidth;
    bool                             m_fSized;
    bool                             m_fAutosize;
};

HRESULT
CreateMPContainerSite(CMPContainerSiteHost &pHost,
                      IUnknown * pCtl,
                      IPropertyBag2 *pPropBag,
                      IErrorLog *pError,
                      bool bSyncEvents,
                      CMPContainerSite ** ppSite);


#endif /* _MPCTNSITE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\mixerocx_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Tue May 11 16:16:59 1999
 */
/* Compiler settings for mixerocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif // !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMixerOCXNotify,0x81A3BD31,0xDEE1,0x11d1,0x85,0x08,0x00,0xA0,0xC9,0x1F,0x9C,0xA0);


MIDL_DEFINE_GUID(IID, IID_IMixerOCX,0x81A3BD32,0xDEE1,0x11d1,0x85,0x08,0x00,0xA0,0xC9,0x1F,0x9C,0xA0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Tue May 11 16:17:00 1999
 */
/* Compiler settings for mixerocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif // !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMixerOCXNotify,0x81A3BD31,0xDEE1,0x11d1,0x85,0x08,0x00,0xA0,0xC9,0x1F,0x9C,0xA0);


MIDL_DEFINE_GUID(IID, IID_IMixerOCX,0x81A3BD32,0xDEE1,0x11d1,0x85,0x08,0x00,0xA0,0xC9,0x1F,0x9C,0xA0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\player.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "player.h"
#include "mediaelm.h"
#include "playlist.h"
#include "timeparser.h"
#include "mediaprivate.h"

DeclareTag(tagMediaTimePlayer, "TIME: Players", "CTIMEPlayer methods")

CTIMEPlayer::CTIMEPlayer(CLSID clsid):
  m_cRef(0),
  m_fExternalPlayer(false),
  m_fSyncMaster(false),
  m_fRunning(false),
  m_fHolding(false),
  m_fActive(false),
  m_dblStart(0.0),
  m_playerCLSID(clsid),
  m_fLoadError(false),
  m_fNoPlaylist(true),
  m_fIsOutOfSync(false),
  m_fPlayListLoaded(false),
  m_syncType(sync_none),
  m_dblSyncTime(0.0),
  m_fHasSrc(false),
  m_fMediaComplete(false),
  m_fSpeedIsNegative(false),
  m_fIsStreamed(false)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::CTIMEPlayer()",
              this));

    VariantInit(&m_varClipBegin);
    V_VT(&m_varClipBegin) = VT_R8;
    V_R8(&m_varClipBegin) = 0.0;

    VariantInit(&m_varClipEnd);
    V_VT(&m_varClipEnd) = VT_R8;
    V_R8(&m_varClipEnd) = -1.0;
}


CTIMEPlayer::~CTIMEPlayer()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::~CTIMEPlayer()",
              this));

    // No functions are virtual in destructors so make it explicit
    // here.  All derived classes should do the same.
    
    CTIMEPlayer::DetachFromHostElement();

    VariantClear(&m_varClipBegin);
    VariantClear(&m_varClipEnd);
}

STDMETHODIMP_(ULONG)
CTIMEPlayer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayer::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

bool
CTIMEPlayer::CheckObject(IUnknown * pObj)
{
    HRESULT hr;
    bool bRet = false;
    
    CComPtr<ITIMEMediaPlayerOld> p;
            
    hr = THR(pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayerOld, &p)));
    if (SUCCEEDED(hr))
    {
        bRet = true;
        goto done;
    }

  done:
    return bRet;
}

HRESULT
CTIMEPlayer::Init(CTIMEMediaElement *pelem,
                  LPOLESTR base,
                  LPOLESTR src,
                  LPOLESTR lpMimeType,
                  double dblClipBegin,
                  double dblClipEnd)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Init)",
              this));
    
    HRESULT hr;
    IPropertyBag2 * pPropBag = NULL;
    IErrorLog * pErrorLog = NULL;
    LPOLESTR szSrc = NULL;

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHasSrc = (src != NULL);
    
    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(!m_pContainer);
    m_pContainer = NEW CContainerObj();
    if (!m_pContainer)
    {
        TraceTag((tagError,
                  "CTIMEPlayer::Init - unable to alloc mem for container services!!!"));
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->GetPropBag(&pPropBag, &pErrorLog));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = THR(m_pContainer->Init(m_playerCLSID, this, pPropBag, pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pContainer->SetMediaSrc(szSrc));
    if (FAILED(hr))
    {
        goto done;
    }

    SetClipBegin(dblClipBegin);
    SetClipEnd(dblClipEnd);

    hr = THR(CreatePlayList());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
    
  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }

    delete[] szSrc;

    return S_OK;
}

HRESULT
CTIMEPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::DetachFromHostElement)",
              this));   

    if (m_pContainer)
    {
        // Propogating this error wouldn't mean much 
        // to the caller since it is shutting down.
        IGNORE_HR(m_pContainer->Stop());
        IGNORE_HR(m_pContainer->DetachFromHostElement());
        m_pContainer.Release();
    }

    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();
    }

    return hr;
}

HRESULT
CTIMEPlayer::InitElementSize()
{
    HRESULT hr = S_OK;
    RECT rc;
    // add a method to get native video size.
    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetSize(&rc);
        if (FAILED(hr))
        {
            goto done;
        }

        if (m_pContainer)
        {
            m_pContainer->SetSize(&rc);
        }
    }

  done:
    return hr;
}

void
CTIMEPlayer::OnTick(double dblSegmentTime,
                    LONG lCurrRepeatCount)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

#ifdef NEW_TIMING_ENGINE
void
CTIMEPlayer::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnSync(%g, %g)",
              this,
              dbllastTime,
              dblnewTime));
    
    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    // if we are not the external player and not running, go away

    if (m_fRunning)
    {
        // get current time from player and
        // sync to this time
        double dblCurrentTime;
        dblCurrentTime = m_pContainer->GetCurrentTime();

        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::OnSync - player returned %g",
                  this,
                  dblCurrentTime));
    
        // If the current time is -1 then the player is not ready and we
        // should sync to the last time.  We also should not respect the
        // tolerance since the behavior has not started.
    
        if (dblCurrentTime < 0)
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player returned -1 - setting to dbllastTime (%g)",
                      this,
                      dbllastTime));
    
            dblCurrentTime = 0;
            // When we want this to actually hold at the begin value then enable
            // this code
            // dblCurrentTime = -HUGE_VAL;
        }
        else if (dblnewTime == HUGE_VAL)
        {
            if (dblCurrentTime >= (m_pTIMEElementBase->GetRealRepeatTime() - m_pTIMEElementBase->GetRealSyncTolerance()))
            {
                TraceTag((tagMediaTimePlayer,
                          "CTIMEPlayer(%lx)::OnSync - new time is ended and player w/i sync tolerance of end",
                          this));
    
                goto done;
            }
        }
        else if (fabs(dblnewTime - dblCurrentTime) <= m_pTIMEElementBase->GetRealSyncTolerance())
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player w/i sync tolerance (new:%g, curr:%g, diff:%g, tol:%g)",
                      this,
                      dblnewTime,
                      dblCurrentTime,
                      fabs(dblnewTime - dblCurrentTime),
                      m_pTIMEElementBase->GetRealSyncTolerance()));
    
            goto done;
        }
        
        if (m_fSyncMaster && m_fLoadError == false)
        {
            dblnewTime = dblCurrentTime;
        }
    }
    else if (!m_fRunning && m_pTIMEElementBase->IsDocumentInEditMode()) //lint !e774
    {
        // if we are paused and in edit mode, make sure
        // WMP has the latest time.
        double dblMediaLen = 0.0f;
        TraceTag((tagMediaTimePlayer,
                "CTIMEPlayer(%lx)::OnSync(SeekTo=%g m_fRunning=%d)",
                this,
                dbllastTime, m_fRunning));
        // GetMediaLength fails if duration is indefinite (e.g. live stream).
        if (FAILED(m_pContainer->GetMediaLength(dblMediaLen)))
        {
            goto done;
        }

        // Don't seek beyond duration of media clip. 
        if (dbllastTime > dblMediaLen)
        {
            goto done;
        }

        if (m_pContainer)
        {
            THR(m_pContainer->Seek(dbllastTime));
        }
    }
  done:
    return ;
}    
#endif

void
CTIMEPlayer::Start()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEPlayer::InternalStart()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::InternalStart()",
              this));

    HRESULT hr = S_OK;
    m_dblStart = 0.0;

    if(m_pContainer)
    {
        hr = m_pContainer->Start();
        TIMESetLastError(hr, NULL);
        m_fLoadError = false;
        if (FAILED(hr))
        {
            m_fLoadError = true;
        }
    }

    if (!m_fLoadError)
    {
        m_fRunning = true;
        m_fActive = true;
    }
    
}

void
CTIMEPlayer::Repeat()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Repeat()",
              this));
    InternalStart(); //consider doing update state.
}

void
CTIMEPlayer::Stop()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Stop()",
              this));

    m_fRunning = false;
    m_fActive = false;
    m_dblStart = 0.0;
    
    if(m_pContainer)
    {
        m_pContainer->Stop();
    }
}

void
CTIMEPlayer::Pause()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Pause()",
              this));

    if(m_fHolding)
    {
        return;
    }

    m_fRunning = false;

    if(m_pContainer)
    {
        m_pContainer->Pause();
    }
}

void
CTIMEPlayer::Resume()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Resume()",
              this));

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(m_fHolding)
    {
        goto done;
    }

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    if(m_pContainer && bIsActive && !bIsCurrPaused)
    {
        m_pContainer->Resume();
    }

    m_fRunning = true;

done:
    return;
}
    
HRESULT
CTIMEPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Render()",
              this));
    HRESULT hr = S_OK;
    int iPrevMode = 0;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    bool bIsOn = m_pTIMEElementBase->IsOn();
    bool bHasVisual = true;
    
    hr = THR(HasVisual(bHasVisual));
    if (SUCCEEDED(hr) && !bHasVisual)
    {
        hr = S_OK;
        goto done;
    }
    
    if (!m_pContainer)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    iPrevMode = SetStretchBltMode(hdc, COLORONCOLOR);
    if (0 == iPrevMode)
    {
        hr = E_FAIL;
        goto done;
    }

    if(bIsOn)
    {
        hr = THR(m_pContainer->Render(hdc, prc));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    if (0 != iPrevMode)
    {
        SetStretchBltMode(hdc, iPrevMode);
    }
    return hr;
}

HRESULT
CTIMEPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    // check to see if player is being used
    if (!m_pContainer)
    {
        return E_UNEXPECTED;
    }

    return m_pContainer->GetControlDispatch(ppDisp);
}

void 
CTIMEPlayer::GetClipBegin(double &pvar)
{
    HRESULT hr = S_OK;

    pvar = 0.0;
 
    if (m_varClipBegin.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&m_varClipBegin, &m_varClipBegin, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    pvar = m_varClipBegin.fltVal;

done:
    return;
}

void 
CTIMEPlayer::SetClipBegin(double var)
{
    CTIMEBasePlayer::SetClipBegin(var);
    
    VariantClear(&m_varClipBegin);
    V_VT(&m_varClipBegin) = VT_R8;
    V_R8(&m_varClipBegin) = var;
    
    if (m_pContainer)
    {
        IGNORE_HR(m_pContainer->clipBegin(m_varClipBegin));
    }

    Reset();

done:

    return;

}

void 
CTIMEPlayer::GetClipEnd(double &pvar)
{
    HRESULT hr = S_OK;

    pvar = -1.0;
    
    if (m_varClipBegin.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&m_varClipEnd, &m_varClipEnd, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    pvar = m_varClipEnd.fltVal;

done:
    return;

}

void 
CTIMEPlayer::SetClipEnd(double var)
{
    CTIMEBasePlayer::SetClipEnd(var);
    
    VariantClear(&m_varClipEnd);
    V_VT(&m_varClipEnd) = VT_R8;
    V_R8(&m_varClipEnd) = var;
    if (m_pContainer)
    {
        IGNORE_HR(m_pContainer->clipEnd(m_varClipEnd));
    }

done:

    return;
    
}

double 
CTIMEPlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;
    
    if (m_pContainer)
    {
        dblCurrentTime = m_pContainer->GetCurrentTime();
    }
    
    return dblCurrentTime;
}

HRESULT
CTIMEPlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (!m_pContainer || m_fLoadError || m_fHolding)
    {
        hr = S_FALSE;
        goto done;
    }

    if(m_pTIMEElementBase == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    if(!m_fNoPlaylist)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }
    
    if (!m_fActive)
    {
        dblSyncTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }
    
    dblSyncTime = m_pContainer->GetCurrentTime();

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMEPlayer::Seek(double dblTime)
{
    HRESULT hr = S_FALSE;

    if (m_pContainer)
    {
        hr = m_pContainer->Seek(dblTime);
    }

    return hr;
}

HRESULT
CTIMEPlayer::SetSize(RECT *prect)
{
    if(!m_pContainer) return E_FAIL;
    return m_pContainer -> SetSize(prect);
}


HRESULT
CTIMEPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (!m_pContainer)
    {
        return E_FAIL;
    }

    hr = m_pContainer -> GetMediaLength( dblLength);
    return hr;
}

HRESULT
CTIMEPlayer::GetEffectiveLength(double &dblLength)
{
    HRESULT hr;
    double dblClipEnd, dblClipBegin;

    if (!m_pContainer)
    {
        return E_FAIL;
    }

    hr = m_pContainer -> GetMediaLength( dblLength);
    if(FAILED(hr))
    {
        goto done;
    }

    GetClipEnd( dblClipEnd);
    if( dblClipEnd != -1.0)
    {
        dblLength = dblClipEnd;
    }
    GetClipBegin(dblClipBegin);
    dblLength -= dblClipBegin;

done:
    return hr;
}

HRESULT
CTIMEPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr;

    if (!m_pContainer)
    {
        return E_FAIL;
    }

    hr = m_pContainer -> CanSeek( fcanSeek);
    if(FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
CTIMEPlayer::CanSeekToMarkers(bool &fcanSeek)
{
    HRESULT hr;

    if (!m_pContainer)
    {
        fcanSeek = false;
        return E_FAIL;
    }
    hr = m_pContainer -> CanSeekToMarkers( fcanSeek);
    if(FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEPlayer::IsBroadcast(bool &fisBroadcast)
{
    HRESULT hr;

    if (!m_pContainer || m_fLoadError)
    {
        fisBroadcast = false;
        goto done;
    }

    hr = m_pContainer->IsBroadcast(fisBroadcast);
    if(FAILED(hr))
    {
        fisBroadcast = false;
        goto done;
    }

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::HasPlayList(bool &fHasPlayList)
{
    fHasPlayList = !m_fNoPlaylist;
    return S_OK;
}


HRESULT
CTIMEPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;
    TraceTag((tagError,
              "CTIMEPlayer(%lx)::SetSrc()\n",
              this));
    LPOLESTR szSrc = NULL;

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHasSrc = (src != NULL);
    m_fMediaComplete = false;

    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pContainer->SetMediaSrc(szSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if(m_fRunning == true)
    {
        Resume();
    }
    else if (m_fActive == true)
    {
        Resume();
        Pause();
    }
  done:
    delete[] szSrc;
    return hr;

}

HRESULT
CTIMEPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(pTitle);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipTitle));
        if (hr == S_OK)
        {
            *pTitle = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pTitle = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 


HRESULT
CTIMEPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pAuthor);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipAuthor));
        if (hr == S_OK)
        {
            *pAuthor = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pAuthor = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pCopyright);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipCopyright));
        if (hr == S_OK)
        {
            *pCopyright = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pCopyright = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 

HRESULT
CTIMEPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pBstrAbstract);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipDescription));
        if (hr == S_OK)
        {
            *pBstrAbstract = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pBstrAbstract = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 


HRESULT
CTIMEPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pBstrRating);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipRating));
        if (hr == S_OK)
        {
            *pBstrRating = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pBstrRating = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 

HRESULT
CTIMEPlayer::SetMute(VARIANT_BOOL varMute)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Mute";
    CComVariant         varResult;

    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt      = VT_BOOL;
    rgvarg[0].boolVal = varMute;

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;


    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
CTIMEPlayer::GetMute(VARIANT_BOOL *varMute)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName  = L"Mute";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
 
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }  
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_BOOL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    *varMute = varResult.boolVal;

done:
    return hr;
}

HRESULT
CTIMEPlayer::SetVolume(float flVolume)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Volume";
    CComVariant         varResult;
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt     = VT_R4;
    rgvarg[0].fltVal = VolumeLinToLog(flVolume);

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer::GetVolume(float *flVolume)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName  = L"Volume";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
 
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_R4, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    *flVolume = VolumeLogToLin(static_cast<long>(varResult.fltVal));

done:
    return hr;
}


HRESULT
CTIMEPlayer::SetRate(double dblRate)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Rate";
    CComVariant         varResult;
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt     = VT_R4;
    rgvarg[0].fltVal = (float)dblRate;

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer::GetRate(double &dblRate)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName  = L"Rate";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
 
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_R4, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    dblRate = varResult.fltVal;
done:
    return hr;
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458

HRESULT
CTIMEPlayer::GetBalance(float *flBal)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp; 
    DISPID              dispid;
    OLECHAR           * wsName  = L"Balance";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_R4, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    *flBal = BalanceLogToLin(static_cast<long>(varResult.fltVal));
done:
    return hr;
}


HRESULT
CTIMEPlayer::SetBalance(float flBal)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Balance";
    CComVariant         varResult;
    

    VARIANT rgvarg[1];
    rgvarg[0].vt     = VT_R4;
    rgvarg[0].fltVal = BalanceLinToLog(fabs(flBal));

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }    
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}
#endif

HRESULT
CTIMEPlayer::HasMedia(bool &bHasMedia)
{
    HRESULT hr;
    
    if(!m_pContainer || m_fLoadError)
    {
        bHasMedia = false;
        goto done;
    }

    hr = m_pContainer->HasMedia(bHasMedia);
    if(FAILED(hr))
    {
        bHasMedia = true;
        goto done;
    }

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::HasVisual(bool &bHasVideo)
{
    long height, width;

    GetNaturalHeight(&height);
    GetNaturalWidth(&width);

    if((height != -1) && (width != -1))
    {
        bHasVideo = true;
    }
    else
    {
        bHasVideo = false;
    }

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;

    bool fHasMedia = false;
    bool fHasVisual = true;

    hr = HasMedia(fHasMedia);
    if(FAILED(hr))
    {
        pMime = NULL;
        goto done;
    }

    hr = HasVisual(fHasVisual);
    if(FAILED(hr))
    {
        pMime = NULL;
        goto done;
    }

    if(fHasVisual)
    { 
        *pMime = SysAllocString(L"video/unknown");
    }
    else
    {
        *pMime = SysAllocString(L"audio/unknown");
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer::HasAudio(bool &bHasAudio)
{
    if (m_fLoadError == true || m_fHasSrc == false)
    {
        bHasAudio = false;
        goto done;
    }

    bHasAudio = true;

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::GetMediaPlayerInfo(LPWSTR *pwstr,  int mpInfoToReceive)
{
    HRESULT             hr = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName = L"GetMediaInfoString";
    CComVariant         varResult;

    *pwstr = NULL;
    
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt    = VT_I4;
    rgvarg[0].lVal  = mpInfoToReceive;

    DISPPARAMS dp;
    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if((*varResult.bstrVal) != NULL)
    {
        *pwstr = CopyString(V_BSTR(&varResult));
    }
    
    hr = S_OK;
  done:
    return hr;
} 

HRESULT 
CTIMEPlayer::CreatePlayList()
{
   TraceTag((tagMediaTimePlayer,
             "CTIMEPlayer(%lx)::CreatePlayList()",
             this));
   
    HRESULT hr;
    
    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = THR(CComObject<CPlayList>::CreateInstance(&pPlayList));
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = THR(pPlayList->Init(*this));
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEPlayer::FillPlayList(CPlayList *pPlayList)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDisp;
    VARIANT vCount;
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };
    DISPID dispid;
    LPOLESTR szCount = L"EntryCount";
    int i;

    VariantInit(&vCount);

    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }
    
    //currently this is only allowed using the WMP.
    if (m_pContainer->UsingWMP() == false)
    {
        hr = E_NOTIMPL;
        goto done;
    }

    hr = THR(m_pContainer->GetControlDispatch(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->GetIDsOfNames(IID_NULL, &szCount, 1, LOCALE_SYSTEM_DEFAULT, &dispid));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, &dispparams, &vCount, NULL, NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    if (vCount.vt != VT_I4)
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (vCount.lVal > 0)
    {
        m_fNoPlaylist = false;  //there is a playlist
        for (i = 1; i <= vCount.lVal; i++)
        {
            CComPtr<CPlayItem> pPlayItem;
            LPWSTR pwzStr;

            //create the playitem
            hr = THR(pPlayList->CreatePlayItem(&pPlayItem));
            if (FAILED(hr))
            {
                goto done; //can't create playitems.
            }
            
            //get the various parameters from the playlist to put in the playitem.

            //get the src
            hr = THR(GetPlayListInfo(i, L"HREF", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutSrc(pwzStr);
                delete [] pwzStr;
            }
            //get the title
            hr = THR(GetPlayListInfo(i, L"title", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutTitle(pwzStr);
                delete [] pwzStr;
            }
            //get the author
            hr = THR(GetPlayListInfo(i, L"author", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutAuthor(pwzStr);
                delete [] pwzStr;
            }
            //get the copyright
            hr = THR(GetPlayListInfo(i, L"copyright", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutCopyright(pwzStr);
                delete [] pwzStr;
            }
            //get the abstract
            hr = THR(GetPlayListInfo(i, L"abstract", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutAbstract(pwzStr);
                delete [] pwzStr;
            }
            //get the rating
            hr = THR(GetPlayListInfo(i, L"rating", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutRating(pwzStr);
                delete [] pwzStr;
            }

            //add the playitem to the playlist.
            IGNORE_HR(pPlayList->Add(pPlayItem, -1));
        }
    }
    else
    {
        m_fNoPlaylist = true;
    }

    VariantClear (&vCount);   
    m_fPlayListLoaded = true;

  done:
    return;
}

HRESULT 
CTIMEPlayer::GetPlayListInfo(long EntryNum, LPWSTR bstrParamName, LPWSTR *pwzValue)
{
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName = L"GetMediaParameter";
    CComVariant         varResult;
    HRESULT hr = S_OK;
    VARIANT rgvarg[2];
        
    *pwzValue = NULL;
    
    VariantInit(&rgvarg[0]);
    VariantInit(&rgvarg[1]);

    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    rgvarg[1].vt    = VT_I4;
    rgvarg[1].lVal  = EntryNum;
    rgvarg[0].vt    = VT_BSTR;
    rgvarg[0].bstrVal  = SysAllocString(bstrParamName);


    DISPPARAMS dp;
    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs             = 2;
    dp.rgvarg            = rgvarg;

    hr = pdisp->Invoke(dispid, 
                       IID_NULL, 
                       LCID_SCRIPTING, 
                       DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                       &dp, 
                       &varResult, 
                       NULL, 
                       NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if (varResult.vt != VT_BSTR)
    {
        hr = S_FALSE;
        goto done;
    }

    *pwzValue = CopyString(varResult.bstrVal);

    if (*pwzValue == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:

    VariantClear(&rgvarg[0]);
    VariantClear(&rgvarg[1]);

    return hr;

}

HRESULT
CTIMEPlayer::GetPlayList(ITIMEPlayList **ppPlayList)
{
    HRESULT hr = E_FAIL;
    
    CHECK_RETURN_SET_NULL(ppPlayList);

    hr = THR(CreatePlayList());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_playList)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_playList->QueryInterface(IID_ITIMEPlayList, (void**)ppPlayList));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEPlayer::GetActiveTrack(long *index)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDisp;
    LPOLESTR wsName = L"GetCurrentEntry";
    DISPID dispid;
    DISPPARAMS dp;
    VARIANT vRetVal;

    if (m_fNoPlaylist == true)
    {
        *index = -1;
        goto done;
    }

    hr = THR(GetExternalPlayerDispatch(&pDisp));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }


    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs             = 0;
    dp.rgvarg            = NULL;

    hr = pDisp->Invoke(dispid, 
                       IID_NULL, 
                       LCID_SCRIPTING, 
                       DISPATCH_METHOD,
                       &dp, 
                       &vRetVal, 
                       NULL, 
                       NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (vRetVal.vt != VT_I4)
    {
        hr = E_FAIL;
        goto done;
    }

    *index = vRetVal.lVal - 1; //change the index from 1-based to 0-based

  done:

    return hr;

}


HRESULT 
CTIMEPlayer::SetActiveTrack(long index)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDisp;
    LPOLESTR wsEntry = L"SetCurrentEntry";

    DISPID dispid;
    DISPPARAMS dp;
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };
    VARIANT rgvarg[1];
    VARIANT vCount;

    VariantInit(&vCount);

    LPOLESTR szCount = L"EntryCount";

    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (!m_pContainer->UsingWMP())
    {
        goto done;
    }

    hr = THR(GetExternalPlayerDispatch(&pDisp));

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_fPlayListLoaded == false)
    {
        m_pContainer->setActiveTrackOnLoad (index);
        goto done;
    }
    if (m_fNoPlaylist == false)
    {
        //this increment is applied because the media player uses a 1-based playlist and the
        //MSTIME playlist is a 0-based collection.
        index += 1;

        hr = THR(pDisp->GetIDsOfNames(IID_NULL, &szCount, 1, LOCALE_SYSTEM_DEFAULT, &dispid));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, &dispparams, &vCount, NULL, NULL));
        if (FAILED(hr))
        {
            goto done;
        }
        if (vCount.vt != VT_I4)
        {
            hr = E_FAIL;
            goto done;
        }

        if (vCount.lVal == 0) //this is the case of the media not being loaded yet
        {
            m_pContainer->setActiveTrackOnLoad (index-1);
            goto done;
        }

        if (vCount.lVal < index || index < 1)
        {
            //this is advancing past the end of the track, or trying to load a track that is past the beginning.
            hr =
                THR(m_pContainer->ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND, 0, NULL));
            VariantClear (&vCount);
            goto done;
        }
        VariantClear (&vCount);
        hr = pDisp->GetIDsOfNames(IID_NULL, &wsEntry, 1, LCID_SCRIPTING, &dispid);
        if (FAILED(hr))
        {
            goto done;
        }

        rgvarg[0].vt = VT_I4;
        rgvarg[0].lVal = index;

        dp.cNamedArgs        = 0;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = 1;
        dp.rgvarg            = rgvarg;

        hr = pDisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD,
                           &dp, 
                           NULL, 
                           NULL, 
                           NULL);
        VariantClear(&rgvarg[0]);
        if (FAILED(hr))
        {
            goto done;
        }

        if (!m_fRunning)
        {
            m_pContainer->Pause();
        }
    }
    else
    {
        if (index == 0)
        {
            //need to start the element if it is currently stopped
            if (!m_fActive)
            {
                if (m_pTIMEElementBase)
                {
                    m_pTIMEElementBase->BeginElement(0.0);         
                }
            }
            else
            {
                //rewind to the beginning of the track
                Seek(0.0);
            }
        }
        else
        {
            hr = THR(m_pContainer->ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND,
                                                0,
                                                NULL));
            //this is advancing off the track need to end.
        }
    }
    
    //need to start the element if it is currently stopped
    if (!m_fActive && m_pTIMEElementBase)
    {
        m_pTIMEElementBase->BeginElement(0.0);         
    }

    //
    // fire notification on playlist that active track has changed
    //

    hr = THR(CreatePlayList());
    if (SUCCEEDED(hr))
    {
        IGNORE_HR(m_playList->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK));
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT 
CTIMEPlayer::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;

    if (height == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *height = -1;
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pContainer->GetNaturalHeight(height));
    if (FAILED(hr))
    {
        goto done;
    }
  done:
    return hr;
}

HRESULT 
CTIMEPlayer::GetNaturalWidth(long *width)
{

    HRESULT hr = S_OK;

    if (width == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *width = -1;
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pContainer->GetNaturalWidth(width));
    if (FAILED(hr))
    {
        goto done;
    }
  done:
    return hr;
}


HRESULT
CTIMEPlayer::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bNeedActive = m_pTIMEElementBase->IsActive();
    bNeedPause = m_pTIMEElementBase->IsCurrPaused();
    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if( !bNeedActive) // see if we need to stop the media.
    {
        if( m_fActive && m_fRunning)
        {
            Stop();
        }
        m_dblSyncTime = 0.0;
        goto done;

    }
    m_dblSyncTime = GetCurrentTime();

    hr = GetRate(dblPlayerRate);
    if(SUCCEEDED(hr) && fHaveTESpeed)
    {
        if (flTeSpeed <= 0.0)
        {
            hr = S_OK;
            Pause();
            goto done;
        }
        if (dblPlayerRate != flTeSpeed)
        {
            IGNORE_HR(SetRate((double)flTeSpeed));
        }
    }

    dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    if (m_pContainer)
    {
        if( !m_fActive)
        {
            InternalStart(); // add a seek after this

            IGNORE_HR(Seek(dblSegTime));
        }
        else
        {
            //we need to be active so we also seek the media to it's correct position
            IGNORE_HR(Seek(dblSegTime));
        }
    }

    //Now see if we need to change the pause state.

    if( bNeedPause || m_fHolding)
    {
        if(!m_fIsOutOfSync)
        {
            if( m_fRunning)
            {
                Pause();
            }
        }
    }
    else
    {
        Resume();
    }
done:
    return hr;
}


void 
CTIMEPlayer::FireMediaEvent(PLAYER_EVENT plEvent)
{
    switch(plEvent)
    {
        case PE_ONMEDIACOMPLETE:
            ClearNaturalDuration();

            if (m_playList)
            {
                m_playList->Clear();
                m_playList->SetLoaded(false);

                FillPlayList(m_playList);

                m_playList->SetLoaded(true);
            }

            if (m_pTIMEElementBase)
            {
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
                m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
                m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
            }
            m_fLoadError = false;
            m_fMediaComplete = true;

        break;
        case PE_ONMEDIAERROR:
            m_fLoadError = true;
        break;
    }


    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->FireMediaEvent(plEvent);
    }
}

void
CTIMEPlayer::PropChangeNotify(DWORD tePropType)
{
    double dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol;
    bool bIsActive;
    double dblSimpleTime;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bIsActive = m_pTIMEElementBase->IsActive();
    dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    CTIMEBasePlayer::PropChangeNotify(tePropType);
    
    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_TIME",
                  this));
        if (bIsActive && !m_fIsOutOfSync && m_fMediaComplete)
        {   
            if(m_pContainer)
            {
                dblSyncTime = m_pContainer->GetCurrentTime();
                if (dblSyncTime != TIME_INFINITE)
                {
                    dblSyncTime -= m_dblClipStart;
                    if(fabs(dblSyncTime - dblSimpleTime) > dblSyncTol)
                    {
                        if(dblSyncTime < dblSimpleTime)
                        {
                            if(m_fRunning)
                            {
                                m_fIsOutOfSync = true;
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPSLOW);
                                m_syncType = sync_slow;
                            }
                        }
                        else
                        {
                            m_fIsOutOfSync = true;
                            m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPFAST);
                            m_syncType = sync_fast;
                        }
                    }
                }
            }
        }

    }
    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_SPEED",
                  this));
        fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
        hr = GetRate(dblPlayerRate);
        if(SUCCEEDED(hr) && fHaveTESpeed)
        {
            if (flTeSpeed <= 0.0)
            {
                Pause();
                goto done;
            } else if(!(m_pTIMEElementBase->IsCurrPaused()) && !m_fRunning && m_fSpeedIsNegative)
            {
                IGNORE_HR(THR(Seek(dblSimpleTime)));
                if(m_pContainer)
                {
                    m_pContainer->Resume();
                }
                m_fSpeedIsNegative = false;
            }

            if (dblPlayerRate != flTeSpeed)
            {
                IGNORE_HR(SetRate((double)flTeSpeed));
            }
        }
    }
  done:
    return;
}



bool
CTIMEPlayer::UpdateSync()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::UpdateSync()",
              this));

    bool fRet = true;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    double dblSyncTime;
    double dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bool bIsActive = m_pTIMEElementBase->IsActive();
    double dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    if(!m_pContainer)
    {
        goto done;
    }

    dblSyncTime = m_pContainer->GetCurrentTime();

    if (dblSyncTime == TIME_INFINITE)
    {
        goto done;
    }
    
    dblSyncTime -= m_dblClipStart;
    switch(m_syncType)
    {
        case sync_slow:
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::UpdateSync()slow",
                      this));
            if(!bIsActive || m_fHolding)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if(fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0 || (dblSyncTime > dblSimpleTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        case sync_fast:
            if(!bIsActive || m_fHolding)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if((fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0) || (dblSimpleTime > dblSyncTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        default:
            break;
    }
done:
    return fRet;
}


HRESULT
CTIMEPlayer::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;
    if (m_pContainer)
    {
        m_pContainer->Save(pPropBag, fClearDirty, fSaveAllProperties);
    }
    return hr;
}

void 
CTIMEPlayer::ReadyStateNotify(LPWSTR szReadyState)
{
    if (m_pContainer)
    {
        m_pContainer->ReadyStateNotify(szReadyState);
    }
    return;
}

HRESULT
CTIMEPlayer::GetPlayerSize(RECT *prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->GetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer::SetPlayerSize(const RECT *prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->SetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer::NegotiateSize(RECT &nativeSize,
                           RECT &finalSize,
                           bool &fIsNative,
                           bool fResetRs)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);

        hr = THR(m_pTIMEElementBase->NegotiateSize(nativeSize,
                                                   finalSize,
                                                   fIsNative,
                                                   fResetRs));
    }

    return hr;
}

HRESULT
CTIMEPlayer::FireEvents(TIME_EVENT TimeEvent, 
                        long lCount, 
                        LPWSTR szParamNames[], 
                        VARIANT varParams[])
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->FireEvents(TimeEvent,
                                                lCount, 
                                                szParamNames, 
                                                varParams));
    }
    if (TimeEvent == TE_ONMEDIAERROR)
    {
        m_fLoadError = true;
    }

    return hr;
}

HRESULT
CTIMEPlayer::FireEventNoErrorState(TIME_EVENT TimeEvent, 
                        long lCount, 
                        LPWSTR szParamNames[], 
                        VARIANT varParams[])
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->FireEvents(TimeEvent,
                                                lCount, 
                                                szParamNames, 
                                                varParams));
    }

    return hr;
}

PlayerState
CTIMEPlayer::GetState()
{
    PlayerState state = PLAYER_STATE_INACTIVE;
    
    if (m_pContainer)
    {
        state = m_pContainer->GetState();

        if (state == PLAYER_STATE_ACTIVE &&
            m_fHolding)
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}


HRESULT
CTIMEPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr;
    long lbufCount;

    fIsStreamed = false;

    if (!m_pContainer || m_fLoadError)
    {
        fIsStreamed = false;
        goto done;
    }

    if(m_fIsStreamed)
    {
        fIsStreamed = true;
        goto done;
    }


    hr = m_pContainer->BufferingCount(lbufCount);
    if(FAILED(hr))
    {
        fIsStreamed = false;
        goto done;
    }

    if(lbufCount > 0)
    {
        fIsStreamed = true;
        m_fIsStreamed = true;
    }

  done:
    return S_OK;
}



HRESULT
CTIMEPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr;
    double dblBuffeTime;

    if (!m_pContainer || m_fLoadError)
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    hr = m_pContainer->BufferingProgress(dblBufferingProgress);
    if(FAILED(hr))
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

  done:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\player.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYER_H
#define _PLAYER_H

#include "containerobj.h"
#include "playerbase.h"


class
__declspec(uuid("22d6f312-b0f6-11d0-94ab-0080c74c7e95"))
MediaPlayerCLSID {};

#define MP_INFINITY -1  //lint !e760

class CPlayList;
enum TIME_EVENT;

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEPlayer :
    public CTIMEBasePlayer
{
  public:
    CTIMEPlayer(CLSID clsid);
    ~CTIMEPlayer();

    HRESULT Init(CTIMEMediaElement *pelem, 
                 LPOLESTR base, 
                 LPOLESTR src, 
                 LPOLESTR lpMimeType, 
                 double dblClipBegin = -1.0, 
                 double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement (void);

    static bool CheckObject(IUnknown * pObj);

    // IUnknown Methods
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    virtual void PropChangeNotify(DWORD tePropType);
    virtual bool UpdateSync();
    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    void GetClipBegin(double &pvar);
    void SetClipBegin(double var);
    void GetClipEnd(double &pvar);
    void SetClipEnd(double var);
    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);


    bool SetSyncMaster(bool fSyncMaster);
    HRESULT SetSize(RECT *prect);

    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT GetEffectiveLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    PlayerState GetState();
    HRESULT CanSeekToMarkers(bool &fcanSeek);
    HRESULT IsBroadcast(bool &fisBroadcast);
    virtual HRESULT HasPlayList(bool &fhasPlayList);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);

    CContainerObj* GetContainerObj() { return m_pContainer; }
    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);


    HRESULT GetTitle(BSTR *pTitle);
    HRESULT GetAuthor(BSTR *pAuthor);
    HRESULT GetCopyright(BSTR *pCopyright);
    HRESULT GetAbstract(BSTR *pAbstract);
    HRESULT GetRating(BSTR *pAbstract);

    HRESULT GetRate(double &pdblRate);
    HRESULT SetRate(double dblRate);
    HRESULT GetVolume(float *pflVolume);
    HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    HRESULT GetBalance(float *pflBalance);
    HRESULT SetBalance(float flBalance);
#endif
    HRESULT GetMute(VARIANT_BOOL *pvarMute);
    HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT GetMimeType(BSTR *pMime);

    virtual HRESULT CueMedia() { return E_NOTIMPL; }

    HRESULT FireEvents(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[]);
    HRESULT FireEventNoErrorState(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[]);
    void FireMediaEvent(PLAYER_EVENT plEvent);

    CPlayList * GetPlayList() { return m_playList; } //lint !e1411

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);
    HRESULT GetPlayListInfo(long EntryNum, LPWSTR bstrParamName, LPWSTR *pbstrValue);

    HRESULT InitElementSize();

    virtual void ReadyStateNotify(LPWSTR szReadyState);
    //
    // persistance methods
    //
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //Helper method. Sould only used by CContainerObj::ProcessEvent();
    void SetHoldingFlag(void);
    void ClearHoldingFlag(void);

    HRESULT GetPlayerSize(RECT *prcPos);
    HRESULT SetPlayerSize(const RECT *prcPos);
    HRESULT NegotiateSize(RECT &nativeSize, RECT &finalSize, bool &fIsNative, bool fResetRs = false);
  protected:
    void InternalStart();
    HRESULT GetMediaPlayerInfo(LPWSTR *pwstr, int mpInfoToReceive);
    
    void FillPlayList(CPlayList *pPlayList);

    HRESULT SetActiveTrack(long index);
    HRESULT GetActiveTrack(long *index);

    HRESULT CreatePlayList();

    LONG m_cRef;
    CLSID               m_playerCLSID;
    DAComPtr<CContainerObj>      m_pContainer;
    bool                m_fExternalPlayer;
    DAComPtr<CPlayList> m_playList;   
    VARIANT             m_varClipBegin;
    VARIANT             m_varClipEnd;
    bool                m_fSyncMaster;
    bool                m_fRunning;
    bool                m_fHolding;
    double              m_dblStart;
    bool                m_fLoadError;
    bool                m_fActive;
    bool                m_fNoPlaylist;
    bool                m_fPlayListLoaded;
    bool                m_fIsOutOfSync;
    SYNC_TYPE_ENUM      m_syncType;
    double              m_dblSyncTime;
    bool                m_fHasSrc;
    bool                m_fMediaComplete;
    bool                m_fSpeedIsNegative;
    bool                m_fIsStreamed;
};

inline void
CTIMEPlayer::SetHoldingFlag()
{
    m_fHolding = true;
};
inline void
CTIMEPlayer::ClearHoldingFlag()
{
    m_fHolding = false;
};
#endif /* _PLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\player2.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "player2.h"
#include "mediaelm.h"
#include "containerobj.h"

DeclareTag(tagPlayer2, "API", "CTIMEPlayer2 methods");
DeclareTag(tagPlayer2sync, "sync", "CTIMEPlayer2 sync methods");

CTIMEPlayer2::CTIMEPlayer2()
: m_cRef(0),
  m_dwPropCookie(0),
  m_fActive(false),
  m_fRunning(false),
  m_fIsOutOfSync(false),
  m_dblSyncTime(0.0),
  m_syncType(sync_none)

{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::CTIMEPlayer2()",
              this));
}

CTIMEPlayer2::~CTIMEPlayer2()
{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::~CTIMEPlayer2()",
              this));

    CTIMEPlayer2::DetachFromHostElement();
}

STDMETHODIMP_(ULONG)
CTIMEPlayer2::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayer2::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

bool
CTIMEPlayer2::CheckObject(IUnknown * pObj)
{
    HRESULT hr;
    bool bRet = false;
    
    CComPtr<ITIMEMediaPlayer> p;
            
    hr = THR(pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayer, &p)));
    if (SUCCEEDED(hr))
    {
        bRet = true;
        goto done;
    }

  done:
    return bRet;
}

HRESULT
CTIMEPlayer2::InitPlayer2(CLSID clsid, IUnknown * pObj)
{
    HRESULT hr;

    Assert(!m_spPlayer);
    
    if (pObj)
    {
        hr = THR(pObj->QueryInterface(IID_ITIMEMediaPlayer,
                                      (void **) &m_spPlayer));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::Init(CTIMEMediaElement *pelem,
                   LPOLESTR base,
                   LPOLESTR src,
                   LPOLESTR lpMimeType,
                   double dblClipBegin,
                   double dblClipEnd)
{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::Init)",
              this));
    
    HRESULT hr;

    if (!m_spPlayer)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    hr = THR(CTIMEBasePlayer::Init(pelem,
                                   base,
                                   src,
                                   lpMimeType,
                                   dblClipBegin,
                                   dblClipEnd));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spPlayer->Init(this));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CreateContainer());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(InitPropSink());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(SetSrc(base, src));
    if (FAILED(hr))
    {
        goto done;
    }

    SetClipBegin(dblClipBegin);
    SetClipEnd(dblClipEnd);

    UpdateNaturalDur();
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }
    
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::DetachFromHostElement)",
              this));

    DeinitPropSink();
    
    if (m_spPlayer)
    {
        m_spPlayer->Detach();
        m_spPlayer.Release();
    }

    if(m_pSite)
    {
        m_pSite->Detach();
        m_pSite.Release();
    }
    
    return hr;
}

HRESULT
CTIMEPlayer2::CreateContainer()
{
    HRESULT hr;

    IPropertyBag2 * pPropBag = NULL;
    IErrorLog * pErrorLog = NULL;
    DAComPtr<ITIMEMediaPlayerControl> spMPCtl;
    DAComPtr<IUnknown> spCtl;
        
    Assert(m_spPlayer);
    
    hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerControl,
                                        (void **) &spMPCtl));
    if (FAILED(hr))
    {
        if (hr == E_NOINTERFACE)
        {
            hr = S_OK;
        }
        
        goto done;
    }

    hr = THR(spMPCtl->getControl(&spCtl));
    if (FAILED(hr) || !spCtl)
    {
        if (hr == E_NOTIMPL)
        {
            hr = S_OK;
        }
        
        goto done;
    }
    
    hr = THR(m_pTIMEElementBase->GetPropBag(&pPropBag, &pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(CreateMPContainerSite(*this,
                                   spCtl,
                                   pPropBag,
                                   pErrorLog,
                                   false,
                                   &m_pSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::InitPropSink()
{
    HRESULT hr;
    DAComPtr<IConnectionPoint> spCP;
    DAComPtr<IConnectionPointContainer> spCPC;
    
    Assert(m_spPlayer);
    
    hr = THR(m_spPlayer->QueryInterface(IID_IConnectionPointContainer,
                                        (void **) &spCPC));
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(spCP->Advise(GetUnknown(), &m_dwPropCookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEPlayer2::DeinitPropSink()
{
    HRESULT hr;
    DAComPtr<IConnectionPoint> spCP;
    DAComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spPlayer || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = THR(m_spPlayer->QueryInterface(IID_IConnectionPointContainer,
                                        (void **) &spCPC));
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spCP->Unadvise(m_dwPropCookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}

STDMETHODIMP
CTIMEPlayer2::get_timeElement(ITIMEElement ** ppElm)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppElm);

    if (!m_pTIMEElementBase)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(m_pTIMEElementBase->QueryInterface(IID_ITIMEElement,
                                                (void **) ppElm));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayer2::get_timeState(ITIMEState ** ppState)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppState);

    if (!m_pTIMEElementBase)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(m_pTIMEElementBase->base_get_currTimeState(ppState));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayer2::reportError(HRESULT errorhr,
                          BSTR errorStr)
{
    HRESULT hr = S_OK;

    TraceTag((tagError,
              "CTIMEPlayer2(%p)::reportError(%hr, %ls)",
              errorhr,
              errorStr));

    if (!m_pTIMEElementBase)
    {
        goto done;
    }
    
    m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR);

done:
    return hr;

}

void
CTIMEPlayer2::Start()
{
    HRESULT hr;

    if (!m_spPlayer)
    {
        hr = S_OK;
        goto done;
    }
    
    if (m_pSite)
    {
        hr = THR(m_pSite->Activate());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_spPlayer->begin());
    if (FAILED(hr))
    {
        goto done;
    }
    m_fActive = true;
    m_fRunning = true;

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        // Indicate failure
    }
}

void
CTIMEPlayer2::Stop()
{
    if (m_spPlayer)
    {
        IGNORE_HR(m_spPlayer->end());
    }

    if (m_pSite)
    {
        IGNORE_HR(m_pSite->Deactivate());
    }
    m_fActive = false;
    m_fRunning = false;
}

void
CTIMEPlayer2::Pause()
{
    if (m_spPlayer)
    {
        IGNORE_HR(m_spPlayer->pause());
    }
    m_fRunning = false;
}

void
CTIMEPlayer2::Resume()
{
    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();

    if (m_spPlayer && bIsActive && !bIsCurrPaused)
    {
        IGNORE_HR(m_spPlayer->resume());
    }
    m_fRunning = true;
}

void
CTIMEPlayer2::Repeat()
{
    if (m_spPlayer)
    {
        IGNORE_HR(m_spPlayer->repeat());
    }
}

HRESULT
CTIMEPlayer2::Reset()
{
    HRESULT hr = S_OK;

    if (m_pSite)
    {
        hr = THR(m_pSite->Activate());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    m_dblSyncTime = GetCurrentTime();
    if (m_spPlayer)
    {
        hr = m_spPlayer->reset();
    }
done:
    return hr;
}

HRESULT
CTIMEPlayer2::Seek(double dblTime)
{
    HRESULT hr = S_OK;

    if (m_spPlayer)
    {
        hr = m_spPlayer->seek(dblTime);
    }
    
    return hr;
}

//
//
//

void
CTIMEPlayer2::SetClipBegin(double dblClipBegin)
{
    CTIMEBasePlayer::SetClipBegin(dblClipBegin);

    if (m_spPlayer)
    {
        CComVariant v(dblClipBegin);
    
        m_spPlayer->put_clipBegin(v);
    }
} // putClipBegin

void 
CTIMEPlayer2::SetClipEnd(double dblClipEnd)
{
    CTIMEBasePlayer::SetClipEnd(dblClipEnd);

    if (m_spPlayer)
    {
        CComVariant v(dblClipEnd);
    
        m_spPlayer->put_clipEnd(v);
    }
} // putClipEnd

HRESULT
CTIMEPlayer2::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_spPlayer)
    {
        hr = m_spPlayer->put_src(szSrc);
    }

done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEPlayer2::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;
    DAComPtr<ITIMEMediaPlayerAudio> spMPAudio;

    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerAudio,
                                            (void **) &spMPAudio));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spMPAudio->put_volume(flVolume);
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer2::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    DAComPtr<ITIMEMediaPlayerAudio> spMPAudio;

    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerAudio,
                                            (void **) &spMPAudio));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spMPAudio->put_mute(varMute);
    }

done:
    return hr;
}

//
//
//

HRESULT
CTIMEPlayer2::GetAbstract(BSTR *pAbstract)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pAbstract);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_abstract(pAbstract);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pAuthor);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_author(pAuthor);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::CanPause(bool &fcanPause)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_canPause(&v);
    }

    fcanPause = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_canSeek(&v);
    }

    fcanSeek = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::GetEffectiveLength(double &dblLength)
{
    HRESULT hr = S_OK;
    
    dblLength = TIME_INFINITE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_clipDur(&dblLength);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pCopyright);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_copyright(pCopyright);
    }

    return hr;
}

double
CTIMEPlayer2::GetCurrentTime()
{
    double dblCurrTime = GetPlayerTime();

    if (dblCurrTime == -1)
    {
        dblCurrTime = 0.0;
    }

    return dblCurrTime;
}

HRESULT
CTIMEPlayer2::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(ppDisp);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_customObject(ppDisp);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::HasMedia(bool &hasMedia)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_hasVisual(&v);
        if (SUCCEEDED(hr) && v == VARIANT_FALSE)
        {
            hr = m_spPlayer->get_hasAudio(&v);
        }
    }

    hasMedia = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::HasVisual(bool &hasVisual)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_hasVisual(&v);
    }

    hasVisual = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::HasAudio(bool &hasAudio)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_hasAudio(&v);
    }

    hasAudio = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    
    dblLength = TIME_INFINITE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_mediaDur(&dblLength);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(height);
    *height = -1;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_mediaHeight(height);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetNaturalWidth(long *width)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(width);
    *width = -1;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_mediaWidth(width);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetPlayList(ITIMEPlayList **ppPlayList)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(ppPlayList);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_playList(ppPlayList);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetRating(BSTR *pRating)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pRating);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_rating(pRating);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetPlaybackOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    dblOffset = 0.0;

    return hr;
}

HRESULT
CTIMEPlayer2::GetEffectiveOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    double dblPosition;

    if (m_spPlayer)
    {
        m_spPlayer->get_currTime(&dblPosition);
        dblOffset = m_pTIMEElementBase->GetMMBvr().GetSimpleTime() - dblPosition;
    }

done:
    return hr;
}

PlayerState
CTIMEPlayer2::GetState()
{
    PlayerState ps = PLAYER_STATE_INACTIVE;
    
    if (m_spPlayer)
    {
        HRESULT hr;
        TimeState ts;
    
        hr = m_spPlayer->get_state(&ts);
        if (SUCCEEDED(hr))
        {
            switch(ts)
            {
              case TS_Inactive:
                ps = PLAYER_STATE_INACTIVE;
                break;
              case TS_Active:
                ps = PLAYER_STATE_ACTIVE;
                break;
              case TS_Cueing:
                ps = PLAYER_STATE_CUEING;
                break;
              case TS_Holding:
                ps = PLAYER_STATE_HOLDING;
                break;
              case TS_Seeking:
                ps = PLAYER_STATE_SEEKING;
                break;
            }
        }
    }

    return ps;
}

HRESULT
CTIMEPlayer2::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pTitle);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_title(pTitle);
    }

    return hr;
}

HRESULT 
CTIMEPlayer2::GetIsStreamed(bool &bIsStreamed)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbStreamed;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;

    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_isBuffered(&vbStreamed);
    }

    bIsStreamed = (vbStreamed == VARIANT_TRUE ? true : false);

done:
    return hr;
}

HRESULT 
CTIMEPlayer2::GetBufferingProgress(double &dblProgress)
{
    HRESULT hr = S_OK;
    long lProgress;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;
    
    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_bufferingProgress(&lProgress);
    }

    dblProgress = (double)lProgress;

done:
    return hr;
}

HRESULT
CTIMEPlayer2::GetHasDownloadProgress(bool &bHasDownloadProgress)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbProgress;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;
    
    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_hasDownloadProgress(&vbProgress);
    }

    bHasDownloadProgress = (vbProgress == VARIANT_TRUE ? true : false);

done:
    return hr;
}

HRESULT 
CTIMEPlayer2::GetDownloadProgress(double &dblProgress)
{
    HRESULT hr = S_OK;
    long lProgress;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;
    
    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_downloadProgress(&lProgress);
    }

    dblProgress = (double)lProgress;

done:
    return hr;
}

//
//
//

double
CTIMEPlayer2::GetPlayerTime()
{
    double dblCurrTime;

    if (m_spPlayer)
    {
        HRESULT hr;
        
        hr = THR(m_spPlayer->get_currTime(&dblCurrTime));
        if (hr != S_OK)
        {
            dblCurrTime = -1;
        }
    }
    else
    {
        dblCurrTime = -1;
    }
    
    return dblCurrTime;
}

HRESULT
CTIMEPlayer2::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;
    double dblTime = GetPlayerTime();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (!m_spPlayer)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }
    
    if (!m_fActive)
    {
        dblSyncTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }

    if (dblTime == -1)
    {
        hr = S_FALSE;
        goto done;
    }
    
    dblSyncTime = dblTime;

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMEPlayer2::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%lx)::Render()",
              this));

    HRESULT hr = S_OK;
    int iPrevMode = 0;
    bool bIsOn = m_pTIMEElementBase->IsOn();
    bool bHasVisual = true;
    
    hr = THR(HasVisual(bHasVisual));
    if (SUCCEEDED(hr) && !bHasVisual)
    {
        hr = S_OK;
        goto done;
    }
    
    if (!bIsOn)
    {
        hr = S_OK;
        goto done;
    }
    
    if (!m_pSite)
    {
        hr = S_OK;
        goto done;
    }
    
    iPrevMode = SetStretchBltMode(hdc, COLORONCOLOR);
    if (0 == iPrevMode)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = THR(m_pSite->Draw(hdc, prc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    if (0 != iPrevMode)
    {
        SetStretchBltMode(hdc, iPrevMode);
    }
    
    return hr;
}

HRESULT 
CTIMEPlayer2::SetSize(RECT *prect)
{
    HRESULT hr;
    
    if (!m_pSite)
    {
        hr = S_OK;
        goto done;
    }
    
    m_pSite->SetSize(prect);

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;

    hr = CanPause(bisBroad);
    if (FAILED(hr))
    {
        goto done;
    }

    bisBroad = !bisBroad;

done:
    return hr;
}

void
CTIMEPlayer2::PropChangeNotify(DWORD tePropType)
{
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol;
    bool bIsActive;
    double dblSimpleTime;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bIsActive = m_pTIMEElementBase->IsActive();
    dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    CTIMEBasePlayer::PropChangeNotify(tePropType);
    
    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        if (bIsActive && !m_fIsOutOfSync)
        {   
            if(m_spPlayer)
            {
                hr = m_spPlayer->get_currTime(&dblSyncTime);
                if(FAILED(hr))
                {
                    goto done;
                }
                TraceTag((tagPlayer2,
                          "CTIMEPlayer2(%lx)::PropChangeNotify(%g - %g):TE_PROPERTY_TIME",
                          this, dblSimpleTime, dblSyncTime));
                if (dblSyncTime != TIME_INFINITE)
                {
                    dblSyncTime -= m_dblClipStart;
                    if(fabs(dblSyncTime - dblSimpleTime) > dblSyncTol)
                    {
                        if(dblSyncTime < dblSimpleTime)
                        {
                            if(!m_fIsOutOfSync && m_fRunning)
                            {
                                m_fIsOutOfSync = true;
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPSLOW);
                                m_syncType = sync_slow;
                            }
                        }
                        else
                        {
                            if(!m_fIsOutOfSync)
                            {
                                m_fIsOutOfSync = true;
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPFAST);
                                m_syncType = sync_fast;
                            }
                        }
                    }
                    else
                    {
                        if(m_fIsOutOfSync)
                        {
                            m_fIsOutOfSync = false;
                            m_syncType = sync_none;

                        }
                    }
                }
            }
        }

    }
done:
    return;
}

void 
CTIMEPlayer2::ReadyStateNotify(LPWSTR szReadyState)
{
    // TODO: Need to fill this in
    return;
}

HRESULT
CTIMEPlayer2::HasPlayList(bool &fhasPlayList)
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEPlayList> spPlayList;

    fhasPlayList = false;

    if (m_spPlayer)
    {
        hr = m_spPlayer->get_playList(&spPlayList);
        if (SUCCEEDED(hr) && spPlayList.p)
        {
            fhasPlayList = TRUE;
        }
    }

    return hr;
}


bool 
CTIMEPlayer2::UpdateSync()
{
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bool bIsActive = m_pTIMEElementBase->IsActive();
    double dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
    bool fRet = true;
    TraceTag((tagPlayer2,
              "CTIMEPlayer(%lx)::UpdateSync()",
              this));

    if(!m_spPlayer)
    {
        goto done;
    }

    hr = m_spPlayer->get_currTime(&dblSyncTime);
    if(FAILED(hr))
    {
        goto done;
    }

    if (dblSyncTime == TIME_INFINITE)
    {
        goto done;
    }
    
    dblSyncTime -= m_dblClipStart;
    switch(m_syncType)
    {
        case sync_slow:
            TraceTag((tagPlayer2,
                      "CTIMEPlayer2(%lx)::UpdateSync()slow",
                      this));
            if(!bIsActive)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if(fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0 || (dblSyncTime > dblSimpleTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        case sync_fast:
            if(!bIsActive)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if((fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0) || (dblSimpleTime > dblSyncTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        default:
            break;
    }
done:
    return fRet;
}

//
// CContainerSiteHost
//

HRESULT
CTIMEPlayer2::GetContainerSize(LPRECT prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->GetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer2::SetContainerSize(LPCRECT prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->SetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer2::ProcessEvent(DISPID dispid,
                            long lCount, 
                            VARIANT varParams[])
{
    TraceTag((tagPlayer2, "CTIMEPlayer2::ProcessEvent(%lx)",this));

    HRESULT hr = S_OK;
#if 0
    if (NULL == m_pPlayer)
    {
        hr = E_NOTIMPL;
        goto done;
    }
    
    switch (dispid)
    {
      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
        m_pPlayer->FireMediaEvent(PE_ONMEDIAERROR);
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:

        SetMediaReadyFlag();
        ClearAutosizeFlag();
                
        //make the element visible here.
        if (m_setVisible)
        {
            SetVisibility(true);
        }

        if (m_bFirstOnMediaReady)
        {
            m_bFirstOnMediaReady = false;
                
            // This must happen before we set natural duration
            // since we detect playlist during this call
            m_pPlayer->FireMediaEvent(PE_ONMEDIACOMPLETE);
                    
            m_pPlayer->ClearNaturalDuration();

            UpdateNaturalDur(false);

            // if this is not a playlist, attempt to set the natural duration

            if (m_lActiveLoadedTrack != NOTRACKSELECTED)
            {
                if (m_pPlayer->GetPlayList())
                {
                    CComVariant vIndex(m_lActiveLoadedTrack);
                        
                    IGNORE_HR(m_pPlayer->GetPlayList()->put_activeTrack(vIndex));
                }

                m_lActiveLoadedTrack = NOTRACKSELECTED;
            }

            if (m_bStartOnLoad)
            {
                m_bStartOnLoad = false;
                Start();
            }

            if (m_bEndOnPlay)
            {
                Stop();
                m_bEndOnPlay = false;
            }
            if (m_bPauseOnPlay)
            {
                THR(m_pProxyPlayer->pause());
                m_bPauseOnPlay = false;
            }

            if (m_bSeekOnPlay)
            {
                IGNORE_HR(Seek(m_dblSeekTime));
                m_pPlayer->InvalidateElement(NULL);
                m_bSeekOnPlay = false;
            }

        }
        else
        {
            CPlayItem *pPlayItem = NULL;
                
            if (m_bPauseOnPlay)
            {
                hr = THR(m_pProxyPlayer->pause());
                if (FAILED(hr))
                {
                    TraceTag((tagError, "Pause failed"));
                }
                m_bPauseOnPlay = false;
            }

            if (m_pPlayer->GetPlayList())
            {
                //load the current info into the selected playitem.
                pPlayItem = m_pPlayer->GetPlayList()->GetActiveTrack();
                SetMediaInfo(pPlayItem);
            }

            //need notification here.
            m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
        }

        SetDuration();
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN:
        m_bActive = true;
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
        m_bActive = false;

        //need notification here.
        m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);

        if (m_bFirstOnMediaReady || UsingPlaylist())
        {
            UpdateNaturalDur(true);
        }
            
        if(m_pPlayer != NULL)
        {
            m_pPlayer->SetHoldingFlag();
        }

        break;

#define DISPID_SCRIPTCOMMAND 3001
      case DISPID_SCRIPTCOMMAND:
        // HACKHACK
        // Pick off the script command from WMP and repackage the event as our own.
        // This allows triggers to work.  The real fix is to add another event on
        // TIMEMediaPlayerEvents.
        if (m_fUsingWMP && lCount == 2) 
        {
            static LPWSTR pNames[] = {L"Param", L"scType"};
            hr = m_pPlayer->FireEvents(TE_ONSCRIPTCOMMAND, 
                                       lCount, 
                                       pNames, 
                                       varParams);
        }
        break;
      default:
        hr = E_NOTIMPL;
        goto done;
    }
#endif
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::GetExtendedControl(IDispatch **ppDisp)
{
    CHECK_RETURN_SET_NULL(ppDisp);

    return E_NOTIMPL;
}

HRESULT
CTIMEPlayer2::NegotiateSize(RECT &nativeSize,
                            RECT &finalSize,
                            bool &fIsNative)
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEPlayList> spPlayList;
    bool fResetSize = false;

    if (m_spPlayer)
    {
        hr = m_spPlayer->get_playList(&spPlayList);
        if (SUCCEEDED(hr))
        {
            if (spPlayList != NULL)
            {
                fResetSize = true;
            }
        }
    }

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->NegotiateSize(nativeSize,
                                                   finalSize,
                                                   fIsNative, fResetSize));
    }

    return hr;
}

//
// IServiceProvider interfaces
//
STDMETHODIMP
CTIMEPlayer2::QueryService(REFGUID guidService,
                           REFIID riid,
                           void** ppv)
{
    CHECK_RETURN_SET_NULL(ppv);
    
    // Just delegate to our service provider
    HRESULT hr;
    IServiceProvider * sp = GetServiceProvider();

    if (!sp)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(sp->QueryService(guidService,
                              riid,
                              ppv));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

//
// IPropertyNotifySink methods
//

STDMETHODIMP
CTIMEPlayer2::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayer2::OnChanged(DISPID dispID)
{
    if (!m_pTIMEElementBase)
    {
        goto done;
    }
    
    switch(dispID)
    {
      case DISPID_TIMEMEDIAPLAYER_ABSTRACT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
        break;
      case DISPID_TIMEMEDIAPLAYER_AUTHOR:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
        break;
      case DISPID_TIMEMEDIAPLAYER_CANPAUSE:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANPAUSE);
        break;
      case DISPID_TIMEMEDIAPLAYER_CANSEEK:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANSEEK);
        break;
      case DISPID_TIMEMEDIAPLAYER_CLIPDUR:
        UpdateNaturalDur();
        break;
      case DISPID_TIMEMEDIAPLAYER_COPYRIGHT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
        break;
      case DISPID_TIMEMEDIAPLAYER_CURRTIME:
        // m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CURRTIME);
        break;
      case DISPID_TIMEMEDIAPLAYER_CUSTOM_OBJECT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT);
        break;
      case DISPID_TIMEMEDIAPLAYER_HASAUDIO:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASAUDIO);
        break;
      case DISPID_TIMEMEDIAPLAYER_HASVISUAL:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASVISUAL);
        break;
      case DISPID_TIMEMEDIAPLAYER_MEDIADUR:
        UpdateNaturalDur();
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIADUR);
        break;
      case DISPID_TIMEMEDIAPLAYER_MEDIAHEIGHT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
        break;
      case DISPID_TIMEMEDIAPLAYER_MEDIAWIDTH:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
        break;
      case DISPID_TIMEMEDIAPLAYER_PLAYLIST:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYLIST);
        break;
      case DISPID_TIMEMEDIAPLAYER_RATING:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
        break;
      case DISPID_TIMEMEDIAPLAYER_SRC:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_SRC);
        break;
      case DISPID_TIMEMEDIAPLAYER_STATE:
        m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
        m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
        break;
      case DISPID_TIMEMEDIAPLAYER_TITLE:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
        break;
      case DISPID_TIMEPLAYLIST_ACTIVETRACK:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK);
        break;
      case DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR:
        reportError(S_FALSE, L"Media Load Failed");
        break;
    }

  done:
    return S_OK;
}

void
CTIMEPlayer2::UpdateNaturalDur()
{
    HRESULT hr;
    double dblMediaLength = TIME_INFINITE;
    
    if (!m_pTIMEElementBase)
    {
        goto done;
    }
    
    m_pTIMEElementBase->ClearNaturalDuration();
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_clipDur(&dblMediaLength);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (dblMediaLength <= 0.0 || dblMediaLength == TIME_INFINITE)
    {
        goto done;
    }
    
    IGNORE_HR(m_pTIMEElementBase->PutNaturalDuration(dblMediaLength));

  done:
    return;
}

HRESULT
CreateTIMEPlayer2(CLSID clsid,
                  IUnknown * pObj,
                  CTIMEPlayer2 ** ppPlayer2)
{
    CHECK_RETURN_SET_NULL(ppPlayer2);
    
    HRESULT hr;
    CComObject<CTIMEPlayer2> *pNew;
    CComObject<CTIMEPlayer2>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->InitPlayer2(clsid, pObj));
        if (SUCCEEDED(hr))
        {
            pNew->AddRef();
            *ppPlayer2 = pNew;
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playercd.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDSHOWCD_H
#define _PLAYERDSHOWCD_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>
#include "dshowcdproxy.h"

#include "importman.h"

#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEDshowCDPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEImportMedia,
    public ITIMEInternalEventSink,
    public IMixerOCXNotify
{
  public:
    CTIMEDshowCDPlayer(CTIMEDshowCDPlayerProxy * pProxy);
    virtual ~CTIMEDshowCDPlayer();

    HRESULT Init(CTIMEMediaElement *pelem,
                 LPOLESTR base,
                 LPOLESTR src,
                 LPOLESTR lpMimeType = NULL,
                 double dblClipBegin = -1.0,
                 double dblClipEnd = -1.0);//lint !e1735

  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();

    HRESULT BeginDownload();
    HRESULT GraphFinish();

    HRESULT ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR *pbstr);

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);

    BEGIN_COM_MAP(CTIMEDshowCDPlayer)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP();

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEInternalEventSink
    //
    STDMETHOD(InternalEvent)();
    
  protected:
    long    m_lSrc;
    bool m_fHasVideo;
    bool m_fDoneSetup;
    double m_dblSeekAtStart;
    bool m_fLoadError;
    bool m_fHasMedia;
    bool m_fRemoved;
    double m_dblMediaDur;

  private:

    // IMixerOCXNotify methods
    STDMETHOD(OnInvalidateRect)(LPCRECT lpcRect);
    STDMETHOD(OnStatusChange)(ULONG ulStatusFlags);
    STDMETHOD(OnDataChange)(ULONG ulDataFlags);

    void GraphStart(void);

    bool IsOvMConnected(IBaseFilter *pOvM);

    void SetStreamFlags(LPOLESTR src);
    HRESULT DisableAudioVideo();

    CComPtr<IBaseFilter> m_pCD;

    LPSTREAM                    m_pTIMEMediaPlayerStream;

    bool m_fUsingInterfaces;
    bool m_fNeedToDeleteInterfaces;

    bool m_fCanCueNow;
    
    bool m_fHavePriority;
    double m_dblPriority;
    HRESULT m_hrRenderFileReturn;

    CTIMEDshowCDPlayerProxy * m_pProxy;
    CritSect                m_CriticalSection;


    
  private:
    CTIMEDshowCDPlayer();
};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playercd.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playercd.h"
#include "mediaelm.h"
#include <wininet.h>
#include <inc\evcode.h>
#include "tags\bodyelm.h"

#define SecsToNanoSecs 10000000

#define OVLMixer L"Overlay Mixer"
#define CDFilter L"WMP CD Filter"

#define SOUND_OF_SILENCE -10000
// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowCDTimePlayer, "TIME: Players", "CTIMEDshowCDPlayer methods");
DeclareTag(tagDshowCDSyncTimePlayer, "TIME: Players", "CTIMEDshowCDPlayer sync methods");

EXTERN_GUID( CLSID_WMPCDFilter, 0xCA9067FF, 0x777D, 0x4B65, 0xAA, 0x5F, 0xC0, 0xB2, 0x7E, 0x3E, 0xC7, 0x5D );


CTIMEDshowCDPlayer::CTIMEDshowCDPlayer(CTIMEDshowCDPlayerProxy * pProxy) :
    m_fHasVideo(false),
    m_fDoneSetup(false),
    m_dblSeekAtStart(0.0),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_fNeedToDeleteInterfaces(false),
    m_fUsingInterfaces(false),
    m_fLoadError(false),
    m_fHasMedia(false),
    m_dblPriority(INFINITE),
    m_fCanCueNow(false),
    m_fHavePriority(false),
    m_hrRenderFileReturn(S_OK),
    m_dblMediaDur(-1.0),
    m_pProxy(pProxy)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::CTIMEDshowCDPlayer()",
              this));


}


CTIMEDshowCDPlayer::~CTIMEDshowCDPlayer()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::~CTIMEDshowCDPlayer()",
              this));

    m_pMediaContent = NULL;

    ReleaseGenericInterfaces();

    ReleaseInterface(m_pTIMEMediaPlayerStream);

    delete m_pProxy;
}

STDMETHODIMP_(ULONG)
CTIMEDshowCDPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDshowCDPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}


STDMETHODIMP
CTIMEDshowCDPlayer::OnInvalidateRect(LPCRECT lpcRect)
{

    TraceTag((tagDshowCDTimePlayer, "CTIMEDshowCDPlayer(%p)::OnInvalidateRect(%x)", this, lpcRect));

    ::PostMessage(m_pwndMsgWindow, WM_INVALIDATE, NULL, NULL);

    return S_OK;
}

STDMETHODIMP
CTIMEDshowCDPlayer::OnStatusChange(ULONG ulStatusFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CTIMEDshowCDPlayer::OnDataChange(ULONG ulDataFlags)
{
    return E_NOTIMPL;
}



HRESULT
CTIMEDshowCDPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::Init)",
              this));
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    m_pTIMEElementBase = pelem;

    hr = GetAtomTable()->AddNameToAtomTable(src, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitElementDuration();
    if (FAILED(hr))
    {
        goto done;
    }
    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }

    
    ClearNaturalDuration();

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    Assert(NULL != m_pTIMEElementBase->GetBody());
    
    hr = S_OK;
done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::DetachFromHostElement)",
              this));

    m_fRemoved = true;

    Assert(NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    CTIMEDshowBasePlayer::DetachFromHostElement();

    {
        CritSectGrabber cs(m_CriticalSection);
        
        if (false == m_fUsingInterfaces)
        {
            DeinitDshow();
        }
        else
        {
            m_fNeedToDeleteInterfaces = true;
        }
    }
    
    if (NULL != m_pTIMEElementBase->GetBody())
    {
        IGNORE_HR(m_pTIMEElementBase->GetBody()->RemoveInternalEventSink(this));
    }
    
    m_pTIMEElementBase = NULL;

    return hr;
}

void
CTIMEDshowCDPlayer::ReleaseSpecificInterfaces()
{
    m_pMediaContent = NULL;
    m_pCD = NULL;
}

void
CTIMEDshowCDPlayer::FreeSpecificData()
{

}

void
CTIMEDshowCDPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDshowCDPlayer::BuildGraph()
{
    HRESULT hr = S_OK;
    CComPtr<IFileSourceFilter> spSourceFilter;
    CComPtr<IEnumPins> spEnumPins;
    CComPtr<IPin> spPin;
    AM_MEDIA_TYPE mt;
    PIN_DIRECTION pinDir;
    ULONG ul;
    bool fFound = false;
    const WCHAR * cpchSrc = NULL;

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                          NULL,
                          CLSCTX_INPROC_SERVER, //lint !e655
                          IID_IGraphBuilder,
                          (void **)&m_pGB);
                          
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_WMPCDFilter, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pCD) ; //lint !e655
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pGB->AddFilter(m_pCD, CDFilter);
    if (FAILED(hr))
    {
        goto done;
    }

	hr = m_pCD->QueryInterface(IID_IFileSourceFilter, (LPVOID *) &spSourceFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSourceFilter->Load(cpchSrc, &mt);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pCD->EnumPins(&spEnumPins);
    if (FAILED(hr))
    {
        goto done;
    }

    while ((S_OK == spEnumPins->Next(1, &spPin, &ul)))
    {
        hr = spPin->QueryDirection(&pinDir);
        if(FAILED(hr))
        {
            goto done;
        }
        if(pinDir == PINDIR_OUTPUT)
        {
            fFound = true;
            break;
        }
        spPin.Release();
    }
    if(fFound == false)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pGB->Render(spPin);

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;

    m_fMediaComplete = false;
done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

class CSimplePB : public IMediaPropertyBag
{
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) { return E_NOINTERFACE; }
    STDMETHOD_(ULONG, AddRef)(THIS) { return 0; }
    STDMETHOD_(ULONG, Release)(THIS) { return 0; }
        
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) { return E_NOTIMPL; }
    STDMETHOD(EnumProperty) (ULONG iProperty, VARIANT *pvarName, VARIANT *pvarVal) { return E_NOTIMPL; } 
        
    LPCOLESTR m_pLookFor;
    BSTR *m_pbstrOut;

    STDMETHOD(Write) (LPCOLESTR pszPropName, VARIANT *pVar)
    {
        if (0 == wcscmp(m_pLookFor, pszPropName))
        {
            if (pVar->vt != VT_BSTR)
            {
                return E_NOTIMPL;
            }

            *m_pbstrOut = SysAllocString(pVar->bstrVal);
            if (NULL == m_pbstrOut)
            {
                return E_FAIL;
            }
        }

        return S_OK;
    }

    public:    
    CSimplePB() :
        m_pbstrOut(NULL), m_pLookFor(NULL) {}
    CSimplePB(LPCOLESTR pLookFor, BSTR *pbstrOut) :
        m_pbstrOut(pbstrOut), m_pLookFor(pLookFor) {}
};



HRESULT
CTIMEDshowCDPlayer::ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR * pbstr)
{
    IPersistMediaPropertyBag *pPMPB = NULL;
    if (S_OK == FindInterfaceOnGraph(pGraph, IID_IPersistMediaPropertyBag,
                                     (void **) &pPMPB))
    {
        CSimplePB pb(lpcwstrTag, pbstr);

        pPMPB->Save(&pb, FALSE, FALSE);

        pPMPB->Release();
    }

    return *pbstr ? S_OK : E_FAIL;
}

HRESULT
CTIMEDshowCDPlayer::InitElementSize()
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    if (m_bIsHTMLSrc)
    {
        hr = S_OK;
        goto done;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = 0;
    nativeSize.bottom = 0;
    
    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);
    
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{   
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::SetSrc()\n",
              this));
    
    return S_OK;

}

STDMETHODIMP
CTIMEDshowCDPlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // ISSUE : do we need this for cd's?
    *pVB_CanCue = m_fCanCueNow ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::CueMedia()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::CueMedia()",
              this));
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::MediaDownloadError()
{
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::BeginDownload()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    RRETURN(hr);
}

HRESULT
CTIMEDshowCDPlayer::GraphFinish()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    
    CComPtr<IHTMLElement2> spElement2;

    if (FAILED(m_hrRenderFileReturn))     
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        hr = m_hrRenderFileReturn;
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
     //can be used m_pIAMNetShowConfig->put_BufferingTime(1.0);
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetShowConfig,  (void **) &m_pIAMNetShowConfig);
    if (FAILED(hr))
    {
        m_pIAMNetShowConfig = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMExtendedSeeking, (void **) &m_pExSeeking);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetworkStatus, (void **) &m_pIAMNetStat);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    
    hr = GraphCue();
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
        if (FAILED(hr))
        {
            // IE4 path
            CComPtr<IElementBehaviorSite> spElementBehaviorSite;
            spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();
            
            CComPtr<IObjectWithSite> spSite;
            // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
            hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
            if (FAILED(hr))
            {
                goto done;
            }
            
            CComPtr<IOleWindow> spOleWindow;
            // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
            hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEDshowCDPlayer::Init - IE4 failure! unable to QI for IOleWindow on hosting Document"));
                goto done;
            }
        }
    }
    m_fMediaComplete = true;

    IGNORE_HR(this->InitElementDuration());
    
    m_pTIMEElementBase->InvalidateElement(NULL);
    FireMediaEvent(PE_ONMEDIACOMPLETE);

    InternalReset(true);

done:
    return hr;
}

//
// CTIMEDshowCDPlayer::IsOvMConnected(): Private method to detect if the video stream 
// is passing through the Overlay Mixer (i.e, is it connected?).
//
bool
CTIMEDshowCDPlayer::IsOvMConnected(IBaseFilter *pOvM)
{    
    IEnumPins   *pEnumPins;
    IPin        *pPin;
    IPin        *pPin2;
    ULONG        ul;
    HRESULT      hr;
    bool         bConnected = false;

    pOvM->EnumPins(&pEnumPins);
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul && bConnected == false)
    {
        hr = pPin->ConnectedTo(&pPin2);
        if (SUCCEEDED(hr) && pPin2)
        {
            bConnected = true;
            pPin2->Release();
        }
        pPin->Release();
    }
    pEnumPins->Release();
    
    return bConnected;
}

void
CTIMEDshowCDPlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

void
CTIMEDshowCDPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::GraphStart()",
              this));

    m_fLoadError = false;

    if (m_fMediaComplete == false)
    {
        goto done;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }

  done: 

    return;
}
    
HRESULT
CTIMEDshowCDPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::Render(%d-%d)",
              this,
              prc->right - prc->left,
              prc->bottom - prc->top));
    HRESULT hr = S_OK;
    
done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    Assert(prect != NULL);
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    LONGLONG mediaDur;
    dblLength = 0.0;

    if (m_pMC == NULL || m_pMP == NULL || m_pMS == NULL)
    {
        return E_FAIL;
    }

    if(m_dblMediaDur == -1.0)
    {
        hr = m_pMP->get_Duration(&dblLength);
        m_dblMediaDur = dblLength;
    }
    else
    {
        dblLength = m_dblMediaDur;
    }
done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    LONG canSeek;
    long seekFlags = 0;

    if (m_pIAMNetStat != NULL) //never seek asf's.
    {
        fcanSeek = false;
        goto done;
    }

    if (m_pExSeeking == NULL)
    {
        if (!m_pMP)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekBackward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekForward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        fcanSeek = true;
    }
    else
    {
        hr = m_pExSeeking->get_ExSeekCapabilities( &seekFlags);
        if (SUCCEEDED(hr)) 
        {
            if( seekFlags & AM_EXSEEK_CANSEEK)
            {
                fcanSeek = true;
                goto done;
            }
        }
        hr = S_OK;
        fcanSeek = false;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    if (NULL != pAuthor)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_AuthorName(pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/IART", pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    if (NULL != pTitle)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Title(pTitle);
            if (FAILED(hr))
            {
                *pTitle = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/INAM", pTitle);
            if (FAILED(hr))
            {
                hr = ReadContentProperty(m_pGB, L"INFO/ISBJ", pTitle);
                if (FAILED(hr))
                {
                    *pTitle = NULL;
                }
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    if (NULL != pCopyright)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Copyright(pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            // ISSUE : REfactor this down to dshow base class
            hr = ReadContentProperty(m_pGB, L"INFO/ICOP", pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }
    }
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrAbstract)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Description(pBstrAbstract);
            if (FAILED(hr))
            {
                *pBstrAbstract = NULL;
            }
        }
        else
        {
            *pBstrAbstract = NULL;
        }
    }
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrRating)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Rating(pBstrRating);
            if (FAILED(hr))
            {
                *pBstrRating = NULL;
            }
        }
        else
        {
            *pBstrRating = NULL;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
void  
CTIMEDshowCDPlayer::SetStreamFlags(LPOLESTR src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    
    m_bIsSAMISrc = false;
    m_bIsHTMLSrc = false;

    len = lstrlenW(src);
    if (len >= HTMLSTREAMSRCLEN)
    {
        memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));
    
        if (StrCmpIW(stream, HTMLSTREAMSRC) == 0)
        {
            m_bIsHTMLSrc = true;
        }
        if (StrCmpIW(stream, SAMISTREAMSRC) == 0)
        {
            m_bIsSAMISrc = true;
        }
    
    }
}

HRESULT
CTIMEDshowCDPlayer::DisableAudioVideo()
{
    HRESULT hr = E_FAIL;

    CComPtr<IBaseFilter> pMediaFilter;
    CComPtr<IPin> pPin;
    CComPtr<IEnumPins> pMediaPinEnum;
    
    //disconnect the video
    if (m_pMediaContent == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = m_pMediaContent->QueryInterface(IID_IBaseFilter, (void **)&pMediaFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMediaFilter->EnumPins(&pMediaPinEnum);
    if (!pMediaPinEnum)
    {
        goto done;
    }
    while(pMediaPinEnum->Next(1, &pPin, NULL) == S_OK)
    {
        if (pPin != NULL)
        {
            IGNORE_HR(pPin->Disconnect());
        }
    }
    
    //silence the audio
    if (m_pBasicAudio != NULL)
    {
        hr = THR(m_pBasicAudio->put_Volume(SOUND_OF_SILENCE));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP
CTIMEDshowCDPlayer::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowCDTimePlayer, "CTIMEDshowCDPlayer(%p)::InitializeElementAfterDownload",this));

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT 
CTIMEDshowCDPlayer::GetNaturalHeight(long *height)
{
    *height = (long)0;
    
    return S_OK;
}

HRESULT 
CTIMEDshowCDPlayer::GetNaturalWidth(long *width)
{
    *width = (long)0;

    return S_OK;
}

PlayerState
CTIMEDshowCDPlayer::GetState()
{
    PlayerState state;
    
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        if(!m_bMediaDone)
        {
            state = PLAYER_STATE_ACTIVE;
        }
        else
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}

STDMETHODIMP
CTIMEDshowCDPlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::Reset()
{
    return InternalReset(true);
}


HRESULT
CTIMEDshowCDPlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;
    long lseekFlags;

    // ISSUE : Does this type of content have markers?
    if( m_pExSeeking == NULL)
    {
        bcanSeekToM = false;
        goto done;
    }

    hr = m_pExSeeking->get_ExSeekCapabilities(&lseekFlags);
    if(FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }
    if(lseekFlags & AM_EXSEEK_MARKERSEEK)
    {
        bcanSeekToM = true;
    }
    else
    {
        bcanSeekToM = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::IsBroadcast(bool &fIsBroad)
{
    HRESULT hr = S_OK;

    fIsBroad = false;
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::HasAudio(bool &bHasAudio)
{

    if(m_pBasicAudio != NULL)
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pMS != NULL)
    {
        hr = m_pMS->GetRate(&dblRate);
    }

    return hr;
}


HRESULT
CTIMEDshowCDPlayer::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if((m_pMS != NULL) && (m_pIAMNetStat == NULL))
    {
        hr = m_pMS->SetRate(dblRate);
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::InternalEvent()
{
    m_fCanCueNow = true;

    Assert (NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->DataAvailable());
    
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;

    fIsStreamed = false;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;

    dblBufferingProgress = 0.0;
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;

    fHasDownloadProgress = false;
    hr = S_OK;
done:
    return hr;
}

void
CTIMEDshowCDPlayer::Block()
{
    if(m_pProxy)
    {
        m_pProxy->Block();
    }
}

void
CTIMEDshowCDPlayer::UnBlock()
{
    if(m_pProxy)
    {
        m_pProxy->UnBlock();
    }
}

bool
CTIMEDshowCDPlayer::CanCallThrough()
{
    if(m_pProxy)
    {
        return m_pProxy->CanCallThrough();
    }
    else
    {
        return true;
    }
}


bool
CTIMEDshowCDPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    bool fRet = false;
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite == NULL)
    {
       goto done;
    }

    if(m_pProxy)
    {
        m_pProxy->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }
    else if(m_pPlaybackSite && (pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
    {
        pNativePlayer->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }

done:
    return fRet;
}


HRESULT
CTIMEDshowCDPlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;
    
    *pMime = SysAllocString(L"audio/CD");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\player2.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player2.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYER2_H
#define _PLAYER2_H

#include "playerbase.h"
#include "mpctnsite.h"

class CTIMEMediaElement;
class CMPContainerSite;

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class
ATL_NO_VTABLE
CTIMEPlayer2 :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CTIMEBasePlayer,
    public ITIMEMediaPlayerSite,
    public CMPContainerSiteHost,
    public IServiceProvider,
    public IPropertyNotifySink
{
  public:
    CTIMEPlayer2();
    virtual ~CTIMEPlayer2();

    HRESULT InitPlayer2(CLSID clsid,
                        IUnknown * pObj);
    
    virtual HRESULT Init(CTIMEMediaElement *pelem,
                         LPOLESTR base,
                         LPOLESTR src,
                         LPOLESTR lpMimeType,
                         double dblClipBegin,
                         double dblClipEnd); //lint !e1735
    virtual HRESULT DetachFromHostElement (void);
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;

    // CContainerSiteHost
    virtual IHTMLElement * GetElement();
    virtual IServiceProvider * GetServiceProvider();

    virtual HRESULT Invalidate(LPCRECT prc);

    virtual HRESULT GetContainerSize(LPRECT prcPos);
    virtual HRESULT SetContainerSize(LPCRECT prcPos);
    
    virtual HRESULT ProcessEvent(DISPID dispid,
                                 long lCount, 
                                 VARIANT varParams[]);

    virtual HRESULT GetExtendedControl(IDispatch **ppDisp);

    // CMPContainerSiteHost
    virtual HRESULT NegotiateSize(RECT &nativeSize,
                                  RECT &finalSize,
                                  bool &fIsNative);

    // ITIMEMediaPlayerSite
    STDMETHOD(get_timeElement)(ITIMEElement ** ppElm);
    STDMETHOD(get_timeState)(ITIMEState ** ppState);
    STDMETHOD(reportError)(HRESULT errorhr,
                           BSTR errorStr);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    BEGIN_COM_MAP(CTIMEPlayer2)
        COM_INTERFACE_ENTRY(ITIMEMediaPlayerSite)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
    END_COM_MAP();

    static bool CheckObject(IUnknown * pObj);
    
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    virtual void Start();
    virtual void Stop();
    virtual void Pause();
    virtual void Resume();
    virtual void Repeat();
    virtual HRESULT Seek(double dblTime);

    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT CanSeek(bool &fcanSeek);
    virtual HRESULT CanPause(bool &fcanPause);
    virtual HRESULT IsBroadcast(bool &bisBroad);

    virtual HRESULT Reset();
    virtual PlayerState GetState();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();

    virtual HRESULT Render(HDC hdc, LPRECT prc);
    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);
    virtual HRESULT SetSize(RECT *prect);

    virtual HRESULT GetMediaLength(double &dblLength);
    virtual HRESULT GetEffectiveLength(double &dblLength);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void SetClipEnd(double dblClipEnd);
    virtual double GetCurrentTime();
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime);

    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    virtual HRESULT SetVolume(float flVolume);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pRating) ;

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);
    virtual HRESULT HasPlayList(bool &fhasPlayList);

    virtual HRESULT GetIsStreamed(bool &bIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblProgress);
    virtual HRESULT GetHasDownloadProgress(bool &bHasDownloadProgress);
    virtual HRESULT GetDownloadProgress(double &dblProgress);

  protected:
    HRESULT CreateContainer();
    HRESULT InitPropSink();
    void DeinitPropSink();
    double GetPlayerTime();
    void UpdateNaturalDur();
    
  protected:
    LONG m_cRef;
    DAComPtr<ITIMEMediaPlayer> m_spPlayer;
    DAComPtr<CMPContainerSite> m_pSite;
    DWORD m_dwPropCookie;

    bool m_fActive;
    bool m_fRunning;
    bool m_fIsOutOfSync;
    double m_dblSyncTime;
    SYNC_TYPE_ENUM m_syncType;
};

inline IHTMLElement *
CTIMEPlayer2::GetElement()
{
    return CTIMEBasePlayer::GetElement();
}

inline IServiceProvider *
CTIMEPlayer2::GetServiceProvider()
{
    return CTIMEBasePlayer::GetServiceProvider();
}

inline HRESULT
CTIMEPlayer2::Invalidate(LPCRECT prc)
{
    InvalidateElement(prc);
    return S_OK;
} 

HRESULT
CreateTIMEPlayer2(CLSID clsid,
                  IUnknown * pObj,
                  CTIMEPlayer2 ** ppPlayer2);

#endif /* _PLAYERBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdmusic.cpp ===
// player.cpp : Implementation of CTIMEPlayerDMusic

#include "headers.h"
#include <math.h>
#include "playerdmusic.h"
#include "decibels.h"
#include "importman.h"

DeclareTag(tagPlayerDMusic, "TIME: Players", "CTIMEPlayerDMusic methods");
DeclareTag(tagDMusicStaticHolder, "TIME: DMusicPlayer Static class", "CTIMEPlaerDMusicStaticHolder details");
DeclareTag(tagPlayerSyncDMusic, "TIME: Players", "CTIMEPlayerDMusic sync times");

//////////////////////////////////////////////////////////////////////
// declare DirectMusic IIDs so ATL CComPtrs can CoCreate/QI them

interface DECLSPEC_NOVTABLE __declspec(uuid("07d43d03-6523-11d2-871d-00600893b1bd")) IDirectMusicPerformance;
interface DECLSPEC_NOVTABLE __declspec(uuid("d2ac28bf-b39b-11d1-8704-00600893b1bd")) IDirectMusicComposer;


//////////////////////////////////////////////////////////////////////
// Global Constants

const double g_dblRefPerSec = 10000000;

static WCHAR g_motifName[] = L"motifName";

//////////////////////////////
// segmentType data: begin
static WCHAR g_segmentType[] = L"segmentType";
struct segmentTypeMapEntrie
{
    LPWSTR pstrName;    // Attribute Name
    SEG_TYPE_ENUM enumVal;
};
const segmentTypeMapEntrie segmentTypeMap[] =
{
    L"primary", seg_primary,
    L"secondary", seg_secondary,
    L"control", seg_control,
    L"MAX", seg_max
};
// segmentType data: end
//////////////////////////////

//////////////////////////////
// boundary data: begin
static WCHAR g_boundary[] = L"boundary";
struct boundaryMapEntrie
{
    LPWSTR pstrName;    // Attribute Name
    BOUNDARY_ENUM enumVal;
};
const boundaryMapEntrie boundaryMap[] =
{
    L"default", bound_default,
    L"immediate", bound_immediate,
    L"grid", bound_grid,
    L"beat", bound_beat,
    L"measure", bound_measure,
    L"MAX", bound_max
};
// boundary data: end
//////////////////////////////

//////////////////////////////
// boundary transitionType: begin
static WCHAR g_transitionType[] = L"transitionType";
struct transitionTypeMapEntrie
{
    LPWSTR pstrName;    // Attribute Name
    TRANS_TYPE_ENUM enumVal;
};
const transitionTypeMapEntrie transitionTypeMap[] =
{
    L"endandintro", trans_endandintro,
    L"intro", trans_intro,
    L"end", trans_end,
    L"break", trans_break,
    L"fill", trans_fill,
    L"regular", trans_regular,
    L"none", trans_none,
    L"MAX", trans_max
};
// boundary transitionType: end
//////////////////////////////

static WCHAR g_wszModulate[] = L"modulate";
static WCHAR g_wszLong[] = L"long";
static WCHAR g_wszImmediateEnd[] = L"immediateEnd";

/////////////////////////////////////////////////////////////////////////////
// CTIMEPlayerDMusic

CTIMEDMusicStaticHolder CTIMEPlayerDMusic::m_staticHolder;

#ifdef DBG
static LONG g_lDmusicObjects = 0;
#endif

CComPtr<IBindStatusCallback> g_spLoaderBindStatusCallback;

CTIMEPlayerDMusic::CTIMEPlayerDMusic(CTIMEPlayerDMusicProxy * pProxy) :
    m_rtStart(0),
    m_ePlaybackState(playback_stopped),
    m_eSegmentType(seg_primary),
    m_eBoundary(bound_default),
    m_eTransitionType(trans_endandintro),
    m_fTransModulate(false),
    m_fTransLong(false),
    m_fImmediateEnd(false),
    m_cRef(0),
    m_pTIMEMediaElement(NULL),
    m_bActive(false),
    m_fRunning(false),
    m_fAudioMute(false),
    m_rtPause(0),
    m_flVolumeSave(0.0),
    m_fLoadError(false),
    m_pwszMotif(NULL),
    m_fSegmentTypeSet(false),
    m_lSrc(0),
    m_lBase(0),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_fHavePriority(false),
    m_dblPriority(0),
    m_fUsingInterfaces(false),
    m_fNeedToReleaseInterfaces(false),
    m_fHaveCalledStaticInit(false),
    m_fAbortDownload(false),
    m_hrSetSrcReturn(S_OK),
    m_pProxy(pProxy),
    m_fHasSrc(false),
    m_fMediaComplete(false),
    m_dblPlayerRate(1.0),
    m_dblSpeedChangeTime(0.0),
    m_dblSyncTime(0.0),
    m_fSpeedIsNegative(false)
{
#ifdef DBG
    InterlockedIncrement(&g_lDmusicObjects);
#endif
}

CTIMEPlayerDMusic::~CTIMEPlayerDMusic()
{
    ReleaseInterfaces();
     
    m_pTIMEMediaElement = NULL;

    ReleaseInterface(m_pTIMEMediaPlayerStream);
    delete m_pProxy;
    delete [] m_pwszMotif;
#ifdef DBG
    InterlockedDecrement(&g_lDmusicObjects);
#endif
}

//////////////////////////////////////////////////////////////////////
// ITIMEMediaPlayer

HRESULT
CTIMEPlayerDMusic::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%p)::Init",
              this));

    HRESULT hr = E_FAIL;
    
    
    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHasSrc = (src != NULL);
    m_pTIMEMediaElement = pelem;

    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        hr = S_OK;
        goto done;
    }

    // initialize performer and composer interfaces

    m_fHaveCalledStaticInit = true;
    hr = m_staticHolder.Init();
    if (FAILED(hr))
    {
        goto done;
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetAtomTable());

    hr = GetAtomTable()->AddNameToAtomTable(src, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GetAtomTable()->AddNameToAtomTable(base, &m_lBase);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = ReadAttributes();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_fLoadError = false;
    hr = S_OK;
    
done:
    RRETURN( hr );
}

HRESULT
CTIMEPlayerDMusic::clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEPlayerDMusic::clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

void
CTIMEPlayerDMusic::Start()
{
    TraceTag((tagPlayerDMusic,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEPlayerDMusic::InternalStart()
{
    HRESULT hr = S_OK;
    bool fTransition = false;
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(m_pTIMEElementBase && m_pTIMEElementBase->IsThumbnail())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
    
    if (!m_staticHolder.GetPerformance() || !m_comIDMSegment || !m_staticHolder.GetComposer())
    {
        goto done;
    }
    
    // Release anything that was already playing, but don't stop it.
    // Primary segments will stop automatically when the new one plays.
    // Secondary segments should just continue even though they are about to be played again.
    if (m_comIDMSegmentState)
    {
        m_comIDMSegmentState.Release();
    }
    if (m_comIDMSegmentStateTransition)
    {
        m_comIDMSegmentStateTransition.Release();
    }
    
    // If we have been paused, the start point may be part way through but we want to start from the beginning.
    hr = m_comIDMSegment->SetStartPoint(0);
    if (FAILED(hr))
    {
        goto done;
    }
    fTransition = m_eSegmentType == seg_primary && m_eTransitionType != trans_none && SafeToTransition();
    if (fTransition)
    {
        // try and transition to new primary segment
        
        DWORD dwFlags = 0;
        switch (m_eBoundary)
        {
        case bound_default:             dwFlags = 0;                                            break;
        case bound_immediate:           dwFlags = DMUS_COMPOSEF_IMMEDIATE;      break;
        case bound_grid:                dwFlags = DMUS_COMPOSEF_GRID;           break;
        case bound_beat:                dwFlags = DMUS_COMPOSEF_BEAT;           break;
        case bound_measure:             dwFlags = DMUS_COMPOSEF_MEASURE;        break;
        }; //lint !e787
        
        WORD wCommand = 0;
        switch (m_eTransitionType)
        {
        case trans_endandintro:                 wCommand = DMUS_COMMANDT_ENDANDINTRO;           break;
        case trans_intro:                       wCommand = DMUS_COMMANDT_INTRO;                 break;
        case trans_end:                         wCommand = DMUS_COMMANDT_END;                   break;
        case trans_break:                       wCommand = DMUS_COMMANDT_BREAK;                 break;
        case trans_fill:                        wCommand = DMUS_COMMANDT_FILL;                  break;
        case trans_regular:                     wCommand = DMUS_COMMANDT_GROOVE;                break;
        }; //lint !e787
        
        if (m_fTransModulate)
        {
            dwFlags |= DMUS_COMPOSEF_MODULATE;
        }
        if (m_fTransLong)
        {
            dwFlags |= DMUS_COMPOSEF_LONG;
        }
        
        // If DirectX8 version, check to see if the segment is using an embedded audiopath
        if (m_staticHolder.GetHasVersion8DM())
        {
            if (m_eTransitionType == trans_intro)
            {
                // Check new segment

                // If the segment is set to play on its embedded audiopath, set DMUS_COMPOSEF_USE_AUDIOPATH
                DWORD dwDefault = 0;
                hr = m_comIDMSegment->GetDefaultResolution(&dwDefault);
                if (SUCCEEDED(hr) && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
                {
                    dwFlags |= DMUS_COMPOSEF_USE_AUDIOPATH;
                }
            }
            else
            {
                // Check old segment

                // Get current time
                MUSIC_TIME mtNow;
                hr = m_staticHolder.GetPerformance()->GetTime( NULL, &mtNow );

                // Get segment state at the current time
                CComPtr<IDirectMusicSegmentState> comIDMSegmentStateNow;
                if (SUCCEEDED(hr))
                {
                    hr = m_staticHolder.GetPerformance()->GetSegmentState( &comIDMSegmentStateNow, mtNow );
                }

                // Get segment from that segment state
                CComPtr<IDirectMusicSegment> comIDMSegmentNow;
                if (SUCCEEDED(hr) && comIDMSegmentStateNow)
                {
                    hr = comIDMSegmentStateNow->GetSegment( &comIDMSegmentNow );
                }

                // Get the segment's default flags
                DWORD dwDefault = 0;
                if (SUCCEEDED(hr) && comIDMSegmentNow )
                {
                    hr = comIDMSegmentNow->GetDefaultResolution(&dwDefault);
                }

                // If the segment was set to play on its embedded audiopath, set DMUS_COMPOSEF_USE_AUDIOPATH
                if (SUCCEEDED(hr) && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
                {
                    dwFlags |= DMUS_COMPOSEF_USE_AUDIOPATH;
                }

                if (comIDMSegmentNow)
                {
                    comIDMSegmentNow.Release();
                }

                if (comIDMSegmentStateNow)
                {
                    comIDMSegmentStateNow.Release();
                }
            }
        }
        hr = m_staticHolder.GetComposer()->AutoTransition(m_staticHolder.GetPerformance(), m_comIDMSegment, wCommand, dwFlags, NULL, NULL, &m_comIDMSegmentState, &m_comIDMSegmentStateTransition);
    }
    
    if (!fTransition || FAILED(hr))
    {
        // no transition - just play it
        
        DWORD dwFlags = 0;
        switch (m_eSegmentType)
        {
        case seg_primary:               dwFlags = 0;                                    break;
        case seg_secondary:             dwFlags = DMUS_SEGF_SECONDARY;  break;
        case seg_control:               dwFlags = DMUS_SEGF_CONTROL;    break;
        };  //lint !e787
        
        switch (m_eBoundary)
        {
        case bound_default:             dwFlags |= DMUS_SEGF_DEFAULT;   break;
        case bound_immediate:           dwFlags |= 0;                                   break;
        case bound_grid:                dwFlags |= DMUS_SEGF_GRID;              break;
        case bound_beat:                dwFlags |= DMUS_SEGF_BEAT;              break;
        case bound_measure:             dwFlags |= DMUS_SEGF_MEASURE;   break;
        };  //lint !e787

        // If DirectX8 version, check to see if the segment is using an embedded audiopath
        if (m_staticHolder.GetHasVersion8DM())
        {
            // If the segment is set to play on its embedded audiopath, set DMUS_SEGF_USE_AUDIOPATH
            DWORD dwDefault = 0;
            hr = m_comIDMSegment->GetDefaultResolution(&dwDefault);
            if (SUCCEEDED(hr) && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
            {
                dwFlags |= DMUS_SEGF_USE_AUDIOPATH;
            }
        }
        
        hr = m_staticHolder.GetPerformance()->PlaySegment(m_comIDMSegment, dwFlags, 0, &m_comIDMSegmentState); //lint !e747
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_staticHolder.GetPerformance()->GetTime(&m_rtStart, NULL);
        m_ePlaybackState = playback_playing;
    }
    
    m_bActive = true;
    m_fLoadError = false;
    
done:
    
    return;
}

void
CTIMEPlayerDMusic::Repeat()
{

    if(!m_fMediaComplete)
    {
        goto done;
    }
    InternalStart();
done:
    return;
}

void
CTIMEPlayerDMusic::Stop(void)
{
    HRESULT hr = S_OK;
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
    
    m_ePlaybackState = playback_stopped;
    
    if (m_staticHolder.GetPerformance())
    {
        bool fPlayingEndTransition = false;
        if (m_comIDMSegmentState)
        {
            bool fEnding = m_eSegmentType == seg_primary && m_eTransitionType != trans_none && !m_fImmediateEnd && SafeToTransition();

            // Only play an ending if either the transition segment or the main segment are playing
            if( m_comIDMSegmentStateTransition )
            {
                // If we played a transition segment, check if either the main segment state or the transition segment state are playing
                fEnding = fEnding && ((S_OK == m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState)) ||
                                      (S_OK == m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentStateTransition)));
            }
            else
            {
                // Otherwise, just check if the main segment state is playing
                fEnding = fEnding && (S_OK == m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState));
            }

            if (fEnding)
            {
                // try and play an ending
                hr = m_staticHolder.GetComposer()->AutoTransition(m_staticHolder.GetPerformance(), NULL, DMUS_COMMANDT_END, m_fTransLong ? DMUS_COMPOSEF_LONG : 0, NULL, NULL, NULL, NULL);

                if (SUCCEEDED(hr))
                {
                    fPlayingEndTransition = true;
                }
            }
            
            if (!fEnding || FAILED(hr))
            {
                DWORD dwFlags = 0;
                if (!m_fImmediateEnd)
                {
                    switch (m_eBoundary)
                    {
                    case bound_default:             dwFlags = DMUS_SEGF_MEASURE;            break;
                    case bound_immediate:           dwFlags = 0;                            break;
                    case bound_grid:                dwFlags = DMUS_SEGF_GRID;               break;
                    case bound_beat:                dwFlags = DMUS_SEGF_BEAT;               break;
                    case bound_measure:             dwFlags = DMUS_SEGF_MEASURE;            break;
                    }; //lint !e787
                }

                // stop immediately
                hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentState, 0, dwFlags);
            }
            
            m_comIDMSegmentState.Release();
        }
        
        if (m_comIDMSegmentStateTransition)
        {
            if (!fPlayingEndTransition)
            {
                hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentStateTransition, 0, 0);
            }

            m_comIDMSegmentStateTransition.Release();
        }
    }
    
    m_bActive = false;
    
done:
    return;
}

PlayerState 
CTIMEPlayerDMusic::GetState()
{
    PlayerState state;
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        state = PLAYER_STATE_ACTIVE;
        goto done;
    }
    
    //state = PLAYER_STATE_HOLDING;
    
done:
    
    return state;
}

void
CTIMEPlayerDMusic::Resume(void)
{
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if(!m_pTIMEElementBase)
    {
        goto done;
    }

    if(m_fSpeedIsNegative)
    {
        goto done;
    }
        
    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
            
    ResumeDmusic();

    m_fRunning = false;
    
done:
    return;
}

void
CTIMEPlayerDMusic::ResumeDmusic(void)
{
    HRESULT hr = S_OK;

    if (m_ePlaybackState == playback_paused)
    {
        REFERENCE_TIME rtElapsedBeforePause = m_rtPause - m_rtStart;
        
        // Resume the segment with the correct type.
        // Ignore all the other flags about transitions and playing on measure/beat boundaries because resume is an instantaneous sort of thing.
        DWORD dwFlags = 0;
        switch (m_eSegmentType)
        {
        case seg_primary:               dwFlags = 0;                    break;
        case seg_secondary:             dwFlags = DMUS_SEGF_SECONDARY;  break;
        case seg_control:               dwFlags = DMUS_SEGF_CONTROL;    break;
        };  //lint !e787
        hr = m_staticHolder.GetPerformance()->PlaySegment(m_comIDMSegment, dwFlags, 0, &m_comIDMSegmentState); //lint !e747
        if (FAILED(hr))
        {
            goto done;
        }
        hr = m_staticHolder.GetPerformance()->GetTime(&m_rtStart, NULL);
        if (FAILED(hr))
        {
            goto done;
        }
        m_rtStart -= rtElapsedBeforePause; // so time will continue counting from point where we left off
        
        m_ePlaybackState = playback_playing;
    }
done:
    return;
}

void
CTIMEPlayerDMusic::Pause(void)
{
    HRESULT hr = S_OK;
    bool fPausedDuringTransition = false;
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
    
    if (m_comIDMSegmentStateTransition)
    {
        // If pause happens while we were transitioning, then we'll stop playing and resume will start
        // playing the segment at its beginning.  (We aren't going to try and pick up where you left off
        // in the transition.)
        
        hr = m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentStateTransition);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (hr == S_OK)
        {
            fPausedDuringTransition = true;
            hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentStateTransition, 0, 0);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        m_comIDMSegmentStateTransition.Release();
    }
    
    if (m_comIDMSegmentState)
    {
        MUSIC_TIME mtStartTime = 0;
        MUSIC_TIME mtStartPoint = 0;
        if (!fPausedDuringTransition)
        {
            hr = m_comIDMSegmentState->GetStartTime(&mtStartTime);
            if (FAILED(hr))
            {
                goto done;
            }
            
            hr = m_comIDMSegmentState->GetStartPoint(&mtStartPoint);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        
        hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentState, 0, 0);
        if (FAILED(hr))
        {
            goto done;
        }
        
        MUSIC_TIME mtNow = 0;
        hr = m_staticHolder.GetPerformance()->GetTime(&m_rtPause, &mtNow);
        if (FAILED(hr))
        {
            goto done;
        }
        
        m_comIDMSegmentState.Release();
        hr = m_comIDMSegment->SetStartPoint(fPausedDuringTransition ? 0 : mtNow - mtStartTime + mtStartPoint);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_ePlaybackState = playback_paused;
    m_fRunning = false;
    
done:
    
    return;
}

void
CTIMEPlayerDMusic::OnTick(double dblSegmentTime, LONG lCurrRepeatCount)
{
    return;
}

STDMETHODIMP
CTIMEPlayerDMusic::put_CurrentTime(double   dblCurrentTime)
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerDMusic::get_CurrentTime(double* pdblCurrentTime)
{
#ifdef OUTTIME
    OutputDebugString("@ get_CurrentTime\n"); // 
#endif
    HRESULT hr = S_OK;
    
    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
        return E_POINTER;
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        // Pretend we're already done playing. This way the page will count for us.
        *pdblCurrentTime = HUGE_VAL;
        hr = S_OK;
        goto done;
    }

    if(!m_fMediaComplete)
    {
        *pdblCurrentTime = HUGE_VAL;
        hr = S_OK;
        goto done;
    }
    
    if (m_ePlaybackState == playback_playing)
    {
        if (!m_comIDMSegmentState)
            return E_FAIL;
        
        hr = m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState);
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNow = 0;
            hr = m_staticHolder.GetPerformance()->GetTime(&rtNow, 0);
            if (FAILED(hr))
                return hr;
            *pdblCurrentTime = (rtNow - m_rtStart) / g_dblRefPerSec;
        }
        else
        {
            *pdblCurrentTime = HUGE_VAL;
        }
    }
    else
    {
        if (m_ePlaybackState == playback_paused)
        {
            *pdblCurrentTime = (m_rtPause - m_rtStart) / g_dblRefPerSec;
        }
        else
        {
            *pdblCurrentTime = -HUGE_VAL;
        }
    }
    
#ifdef OUTTIME
    char msg[512] = "";
    sprintf(msg, "  reported time %f\n", *pdblCurrentTime);
    OutputDebugString(msg);
#endif
done:
    return hr;
}


STDMETHODIMP_(ULONG)
CTIMEPlayerDMusic::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayerDMusic::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

HRESULT
CTIMEPlayerDMusic::Render(HDC hdc, LPRECT prc)
{
    //E_NOTIMPL
    return S_OK;
}

HRESULT 
CTIMEPlayerDMusic::SetSize(RECT *prect)
{
    //E_NOTIMPL
    return S_OK;
}

HRESULT 
CTIMEPlayerDMusic::DetachFromHostElement (void)
{
    m_fAbortDownload = true;
    m_fRemoved = true;

    Assert(GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    {
        CritSectGrabber cs(m_CriticalSection);
    
        if (m_fUsingInterfaces)
        {
            m_fNeedToReleaseInterfaces = true;
        }
        else
        {
            ReleaseInterfaces();
        }
    }

    if (m_fHaveCalledStaticInit)
    {
        m_staticHolder.ReleaseInterfaces();
    }
    else
    {
        m_fHaveCalledStaticInit = false;  // no-op for breakpoints
    }
    
done:
    return S_OK;
}

HRESULT
CTIMEPlayerDMusic::ReleaseInterfaces()
{
    // Stop and release everything associated with this segment
    if (m_comIDMSegmentState)
    {
        m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentState, 0, 0);
        m_comIDMSegmentState.Release();
    }
    if (m_comIDMSegmentStateTransition)
    {
        m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentStateTransition, 0, 0);
        m_comIDMSegmentStateTransition.Release();
    }
    if (m_comIDMSegment)
    {
        m_comIDMSegment.Release();
    }
    
    RRETURN( S_OK );
}

HRESULT 
CTIMEPlayerDMusic::InitElementSize()
{
    //E_NOTIMPL
    return S_OK;
}


HRESULT
CTIMEPlayerDMusic::ReadAttributes()
{
    HRESULT hr = S_OK;

    VARIANT var;
    VARIANT varMotif;
    int i;

    VariantInit(&varMotif);

    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_motifName, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            VariantCopy(&varMotif, &var);
            m_pwszMotif = CopyString(varMotif.bstrVal);
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_segmentType, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            for(i = 0; i < (int)seg_max - (int)seg_primary; i++)
            {
                if(StrCmpIW(segmentTypeMap[i].pstrName, var.bstrVal) == 0)
                {
                    m_eSegmentType = segmentTypeMap[i].enumVal;
                    m_fSegmentTypeSet = true;
                    break;
                }
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_boundary, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            for(i = 0; i < (int)bound_max - (int)bound_default; i++)
            {
                if(StrCmpIW(boundaryMap[i].pstrName, var.bstrVal) == 0)
                {
                    m_eBoundary = boundaryMap[i].enumVal;
                    break;
                }
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_transitionType, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            for(i = 0; i < (int)trans_max - (int)trans_endandintro; i++)
            {
                if(StrCmpIW(transitionTypeMap[i].pstrName, var.bstrVal) == 0)
                {
                    m_eTransitionType = transitionTypeMap[i].enumVal;
                    break;
                }
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_wszModulate, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            if(StrCmpIW(L"true", var.bstrVal) == 0)
            {
                m_fTransModulate = true;
            }
            else if(StrCmpIW(L"false", var.bstrVal) == 0)
            {
                m_fTransModulate = false;
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_wszLong, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            if(StrCmpIW(L"true", var.bstrVal) == 0)
            {
                m_fTransLong = true;
            }
            else if(StrCmpIW(L"false", var.bstrVal) == 0)
            {
                m_fTransLong = false;
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_wszImmediateEnd, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            if(StrCmpIW(L"true", var.bstrVal) == 0)
            {
                m_fImmediateEnd = true;
            }
            else if(StrCmpIW(L"false", var.bstrVal) == 0)
            {
                m_fImmediateEnd = false;
            }
        }
        VariantClear(&var);
    }

    VariantClear(&varMotif);
    return S_OK;
}

HRESULT
CTIMEPlayerDMusic::SetSrc(LPOLESTR base, LPOLESTR src)
{
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%lx)::SetSrc()\n",
              this));

    HRESULT hr = S_OK;
    int trackNr = 0;
    
    BSTR bstrSrc = NULL;
    
    LPWSTR szSrc = NULL;
    
    m_fHasSrc = (src != NULL);
    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }
    
    Stop();
    
    if (!m_staticHolder.GetLoader() || !m_staticHolder.GetPerformance())
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    if (m_comIDMSegment)
    {
        // unload the previous segment's sounds
        
        // with DX8 components, the third parameter should be DMUS_SEG_ALLTRACKS // 
        for(trackNr = 0,hr = S_OK; SUCCEEDED(hr); trackNr++)
        {
            hr = m_comIDMSegment->SetParam(GUID_Unload, 0xFFFFFFFF, trackNr, 0, m_staticHolder.GetPerformance());
        }
        if( hr == DMUS_E_TRACK_NOT_FOUND)
        {
            hr = S_OK;
        }
        if (FAILED(hr))
        {
            goto done;
        }
        m_comIDMSegment.Release();
    }

    
    // Use a special interface on our loader that gets the segment and uses its URL as the base for
    // for resolving relative filenames that it in turn loads.
    bstrSrc = SysAllocString(szSrc);
    if (bstrSrc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }   
    
    hr = m_staticHolder.GetLoader()->GetSegment(bstrSrc, &m_comIDMSegment);
    SysFreeString(bstrSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    // If there's a reference to a motif, try and get it
    if (m_pwszMotif)
    {
        // get the current style
        IDirectMusicStyle *pStyle = NULL;
        hr = m_comIDMSegment->GetParam(GUID_IDirectMusicStyle, 0xFFFFFFFF, 0, 0, NULL, &pStyle);
        m_comIDMSegment.Release(); // This segment is no longer of interest. We just want the motif segment inside its style.
        if (FAILED(hr))
        {
            goto done;
        }
        

        hr = pStyle->GetMotif(m_pwszMotif, &m_comIDMSegment);
        pStyle->Release();
        pStyle = NULL;
        if (hr == S_FALSE)
        {
            hr = E_FAIL; // S_FALSE indicates the motif wan't found.  We'll treat that as a failure.
        }
        if (FAILED(hr))
        {
            m_comIDMSegment.Release();
            goto done;
        }
        
        // motifs play as secondary segments by default
        if (!m_fSegmentTypeSet)
        {
            m_eSegmentType = seg_secondary;
        }
    }
    
    // Download its DLS data
    // with DX8 components, the third parameter should be DMUS_SEG_ALLTRACKS // 
    for(trackNr = 0,hr = S_OK; SUCCEEDED(hr); trackNr++)
    {
        hr = m_comIDMSegment->SetParam(GUID_Download, 0xFFFFFFFF, trackNr, 0, m_staticHolder.GetPerformance()); // load the segment's sounds
    }
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        hr = S_OK; // it's OK if the track doesn't have bands of its own to download
    }
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%lx)::SetSrc() done\n",
              this));
    
done:
    if (FAILED(hr))
    {
        m_hrSetSrcReturn = hr;

        m_fLoadError = true;
    }

    delete[] szSrc;
    
    return hr;
}

STDMETHODIMP
CTIMEPlayerDMusic::put_repeat(long lTime)
{
    // Set the segment's repeat count.  This seems to be called when the repeat property of
    // the player object is set.  Note that this repeats based on the segment's internal loop
    // points -- not based on the repeat attribute on the media tag which is based on end/dur
    // attribute in the tag.
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
        return S_OK;
    if(!m_fMediaComplete)
    {
        return S_OK;
    }
    
    if (!m_comIDMSegment)
        return E_UNEXPECTED;
    
    return m_comIDMSegment->SetRepeats(lTime);
}

STDMETHODIMP
CTIMEPlayerDMusic::get_repeat(long* plTime)
{
    // Get the segment's repeat count.  This seems to be called when the repeat property of
    // the player object is read.  Note that this repeats based on the segment's internal loop
    // points -- not based on the repeat attribute on the media tag which is based on end/dur
    // attribute in the tag.
    
    if (IsBadWritePtr(plTime, sizeof(long*)))
        return E_POINTER;
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        *plTime = 1;
        return S_OK;
    }
    
    DWORD dwRepeats;
    HRESULT hr = m_comIDMSegment->GetRepeats(&dwRepeats);
    if (FAILED(hr))
        return hr;
    
    *plTime = dwRepeats;
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerDMusic::cue(void)
{
    return E_NOTIMPL;
}

//
// IDirectMusicPlayer
//

bool
CTIMEPlayerDMusic::SafeToTransition()
{
    // In DirectX 6.1, there is a bug (Windows NT Bugs 265900) where AutoTransition will GPF if
    // the currently-playing segment does not contain a chord track.  We need to detect this and
    // avoid trying to transition.

    if (m_staticHolder.GetVersionDM() == dmv_70orlater)
        return true; // bug is fixed

    MUSIC_TIME mtNow = 0;
    HRESULT hr = m_staticHolder.GetPerformance()->GetTime(NULL, &mtNow);
    if (FAILED(hr))
        return false;

    CComPtr<IDirectMusicSegmentState> comIDMSegmentStateCurrent;
    hr = m_staticHolder.GetPerformance()->GetSegmentState(&comIDMSegmentStateCurrent, mtNow);
    if (FAILED(hr) || !comIDMSegmentStateCurrent)
        return false;

    CComPtr<IDirectMusicSegment> comIDMSegmentCurrent;
    hr = comIDMSegmentStateCurrent->GetSegment(&comIDMSegmentCurrent);
    if (FAILED(hr) || !comIDMSegmentCurrent)
        return false;

    CComPtr<IDirectMusicTrack> comIDMTrackCurrentChords;
    hr = comIDMSegmentCurrent->GetTrack(CLSID_DirectMusicChordTrack, 0xFFFFFFFF, 0, &comIDMTrackCurrentChords);
    if (FAILED(hr) || !comIDMTrackCurrentChords)
        return false;

    // Whew!
    // We have a chord track so it is OK to do the transition.
    return true;
}

STDMETHODIMP
CTIMEPlayerDMusic::get_isDirectMusicInstalled(VARIANT_BOOL *pfInstalled)
{
    bool bIsInstalled = false;
    if (IsBadWritePtr(pfInstalled, sizeof(BOOL)))
        return E_POINTER;
    
    bIsInstalled = m_staticHolder.HasDM();

    if(bIsInstalled)
    {
        *pfInstalled = VARIANT_TRUE;
    }
    else
    {
        *pfInstalled = VARIANT_FALSE;
    }
    return S_OK;
}

double 
CTIMEPlayerDMusic::GetCurrentTime()
{
    HRESULT hr = S_OK;
    double dblCurrentTime = 0.0;

    if (!m_staticHolder.HasDM() || m_fMediaComplete == false)
    {
        dblCurrentTime = 0.0;
        goto done;
    }

    if (m_ePlaybackState == playback_playing)
    {
        if (!m_comIDMSegmentState)
        {
            dblCurrentTime = 0.0;
            goto done;
        }

        hr = m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState);
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNow = 0;
            hr = m_staticHolder.GetPerformance()->GetTime(&rtNow, 0);
            if (FAILED(hr))
            {
                dblCurrentTime = 0.0;
                goto done;
            }

            dblCurrentTime = ((rtNow - m_rtStart) / g_dblRefPerSec) * m_dblPlayerRate + m_dblSpeedChangeTime;
            TraceTag((tagPlayerSyncDMusic,
                      "CTIMEDshowPlayer(%lx)::SyncTime(%f)(%f)",
                      this, dblCurrentTime, m_dblSpeedChangeTime));

        }
        else
        {
            dblCurrentTime = 0.0;
            goto done;
        }
    }
    else
    {
        if (m_ePlaybackState == playback_paused)
        {
            dblCurrentTime = ((m_rtPause - m_rtStart) / g_dblRefPerSec) * m_dblPlayerRate + m_dblSpeedChangeTime;
        }
        else
        {
            dblCurrentTime = 0.0;
            goto done;
        }
    }

    hr = S_OK;

done:
    return dblCurrentTime;
}

HRESULT 
CTIMEPlayerDMusic::GetCurrentSyncTime(double & dblCurrentTime)
{
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if(m_pTIMEElementBase == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    if (!m_staticHolder.HasDM() || m_fLoadError)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }

    if(!m_bActive)
    {
        dblCurrentTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }

    dblCurrentTime = GetCurrentTime();

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT 
CTIMEPlayerDMusic::Seek(double dblTime)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEPlayerDMusic::GetMediaLength(double &dblLength)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEPlayerDMusic::CanSeek(bool &fcanSeek)
{
    fcanSeek = false;
    return S_OK;
}

HRESULT 
CTIMEPlayerDMusic::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;
    double dblSegTime;

    if(m_pTIMEMediaElement == NULL)
    {
        goto done;
    }

    bNeedActive = m_pTIMEMediaElement->IsActive();
    bNeedPause = m_pTIMEMediaElement->IsCurrPaused();
    
    if( !bNeedActive) // see if we need to stop the media.
    {
        Stop();
        m_dblSyncTime = 0.0;
        goto done;        
    }
    dblSegTime = m_pTIMEMediaElement->GetMMBvr().GetSimpleTime();
    m_dblSyncTime = GetCurrentTime();
    
    if( !m_bActive)
    {
        InternalStart();
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        if(dblSegTime == 0.0)
        {
            // Fix "IEv60: 31873: DMusic HTC: There is a double start when playback is in OnMediaComplete script"
            // by commenting out the below line:
            //InternalStart();
        }
        else
        {
            IGNORE_HR(Seek(dblSegTime));
        }
    }
    
    //Now see if we need to change the pause state.
    
    if( bNeedPause)
    {
        Pause();
    }
    else
    {
        Resume();
    }
done:
    return hr;
}

bool 
CTIMEPlayerDMusic::SetSyncMaster(bool fSyncMaster)
{
    return false;
}

HRESULT 
CTIMEPlayerDMusic::GetExternalPlayerDispatch(IDispatch** ppDisp)
{
    HRESULT hr = E_POINTER;
    
    //
    // TODO: add disp interface for access to extra properties/methods
    //
    
    if (!IsBadWritePtr(*ppDisp, sizeof(IDispatch*)))
    {
        *ppDisp = NULL;
        hr      = E_FAIL;
    }
    
    hr = this->QueryInterface(IID_IDispatch, (void **)ppDisp);

done:
    return hr;
}
HRESULT
CTIMEPlayerDMusic::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;
    long lVolume = -10000;

    if (NULL == pflVolume)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_staticHolder.GetPerformance() != NULL)
    {
        if (m_fAudioMute == true)
        {
            *pflVolume = m_flVolumeSave;
            goto done;
        }

        hr = m_staticHolder.GetPerformance()->GetGlobalParam(GUID_PerfMasterVolume, (void *)&lVolume, sizeof(long));
        *pflVolume = VolumeLogToLin(lVolume);   
    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}


HRESULT
CTIMEPlayerDMusic::SetRate(double dblRate)
{
    HRESULT hr = S_OK;
    float flRate = (float)dblRate;

    if((dblRate < 0.25) || (dblRate > 2.0))
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_staticHolder.GetPerformance() != NULL)
    {
        hr = m_staticHolder.GetPerformance()->SetGlobalParam(GUID_PerfMasterTempo, (void *)&flRate, sizeof(float));
        if(SUCCEEDED(hr))
        {
            if(!m_fSpeedIsNegative)
            {
                m_dblSpeedChangeTime = GetCurrentTime();
            }
            TraceTag((tagPlayerSyncDMusic,
                      "CTIMEDshowPlayer(%lx)::SetRate(%f)(%f)",
                      this, flRate, m_dblSpeedChangeTime));
            m_dblPlayerRate = flRate;
            hr = m_staticHolder.GetPerformance()->GetTime(&m_rtStart, NULL);
        }
    }
    else
    {
        hr = E_FAIL;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerDMusic::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (flVolume < 0.0 || flVolume > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }

    // if muted, overwrite saved volume and exit
    if (m_fAudioMute)
    {
        m_flVolumeSave = flVolume;
        goto done;
    }
    
    lVolume = VolumeLinToLog(flVolume);

    if (m_staticHolder.GetPerformance() != NULL)
    {
        hr = m_staticHolder.GetPerformance()->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lVolume, sizeof(long));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

HRESULT
CTIMEPlayerDMusic::GetMute(VARIANT_BOOL *pVarMute)
{
    HRESULT hr = S_OK;

    if (NULL == pVarMute)
    {
        hr = E_POINTER;
        goto done;
    }


    *pVarMute = m_fAudioMute?VARIANT_TRUE:VARIANT_FALSE;
done:
    return hr;
}

HRESULT
CTIMEPlayerDMusic::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    bool fMute = varMute?true:false;
    long lVolume;

    if (fMute == m_fAudioMute)
    {
        hr = S_OK;
        goto done;
    }

    if (fMute == true)
    {
        hr = GetVolume(&m_flVolumeSave);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = SetVolume(MIN_VOLUME_RANGE); //lint !e747
    }
    else
    {
        //
        // cannot use SetVolume here because it depends on mute state
        //

        if (m_staticHolder.GetPerformance() == NULL)
        {
            hr = E_FAIL;
            goto done;
        }

        lVolume = VolumeLinToLog(m_flVolumeSave);

        THR(hr = m_staticHolder.GetPerformance()->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lVolume, sizeof(long)));
    }

    // update state
    m_fAudioMute = fMute;

done:
    return hr;
}


HRESULT
CTIMEPlayerDMusic::HasVisual(bool &bHasVisual)
{
    bHasVisual = false;
    return S_OK;
}

HRESULT
CTIMEPlayerDMusic::HasAudio(bool &bHasAudio)
{
    if (m_staticHolder.HasDM() && (m_fLoadError == false) && (m_fHasSrc == true))
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }

    return S_OK;
}


STDMETHODIMP
CTIMEPlayerDMusic::CueMedia()
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::CueMedia(%p)", this));

    // we don't own the de / allocation for these pointers
    const WCHAR* wszSrc = NULL;
    const WCHAR* wszBase = NULL;

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic(%p)::CueMedia()", this));

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;

    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(GetAtomTable());

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &wszSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GetAtomTable()->GetNameFromAtom(m_lBase, &wszBase);
    if (FAILED(hr))
    {
        goto done;
    }

    m_pProxy->Block();

    {
        CritSectGrabber cs(m_CriticalSection);
    
        m_fUsingInterfaces = true;

        if (m_fRemoved || m_fNeedToReleaseInterfaces)
        {
            TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::CueMedia(%p) should tear down", this));
            ReleaseInterfaces();
            m_pProxy->UnBlock();
            hr = S_OK;
            goto done;
        }
    }

    {
        CritSectGrabber cs(m_staticHolder.GetCueMediaCriticalSection());
        g_spLoaderBindStatusCallback = this;
        IGNORE_HR(SetSrc((WCHAR*)wszBase, (WCHAR*)wszSrc));
        g_spLoaderBindStatusCallback = NULL;
    }
    
    {
        CritSectGrabber cs(m_CriticalSection);

        m_fUsingInterfaces = false;

        if (m_fNeedToReleaseInterfaces)
        {
            ReleaseInterfaces();
            m_pProxy->UnBlock();
            hr = S_OK;
            goto done;
        }
    }

    m_pProxy->UnBlock();

    // this call is marshalled back to a time thread
    hr = THR(spTIMEMediaPlayer->InitializeElementAfterDownload());

    hr = S_OK;
done:
    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::CueMedia(%p) done", this));

    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::MediaDownloadError()
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerDMusic::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::InitializeElementAfterDownload(%p)", this));

    if (m_fRemoved)
    {
        TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::InitializeElementAfterDownload(%p) exiting early", this));
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(m_hrSetSrcReturn))
    {
        if (m_pTIMEMediaElement)
        {
            m_pTIMEMediaElement->FireMediaEvent(PE_ONMEDIAERROR);
        }
    }
    else
    {
        m_fMediaComplete = true;
        if (m_pTIMEMediaElement)
        {
           m_pTIMEMediaElement->FireMediaEvent(PE_ONMEDIACOMPLETE);
        }
        Reset();
    }
    
    hr = S_OK;
done:

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::InitializeElementAfterDownload(%p) done", this));

    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;

    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    

    hr = S_OK;
done:
    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::GetMediaDownloader(ITIMEMediaDownloader ** ppMediaDownloader)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppMediaDownloader);

    *ppMediaDownloader = NULL;

    hr = S_FALSE;
done:
    RRETURN1( hr, S_FALSE );
}

STDMETHODIMP
CTIMEPlayerDMusic::PutMediaDownloader(ITIMEMediaDownloader * pMediaDownloader)
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;
    
    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;

    hr = S_OK;
done:
    RRETURN( hr );
}


void
CTIMEPlayerDMusic::PropChangeNotify(DWORD tePropType)
{
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        TraceTag((tagPlayerDMusic,
                  "CTIMEDshowPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_SPEED",
                  this));
        fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
        if(fHaveTESpeed)
        {
            if (flTeSpeed <= 0.0)
            {
                m_fSpeedIsNegative = true;
                m_dblSpeedChangeTime = GetCurrentTime();
                Pause();
                goto done;
            }
            IGNORE_HR(SetRate((double)flTeSpeed)); //this has to be called before clearing 
                                                   //m_fSpeedIsNegative
            
            if(!(m_pTIMEElementBase->IsCurrPaused()) && m_fSpeedIsNegative)
            {
                m_fSpeedIsNegative = false;
                ResumeDmusic();
            }
        }
    }
done:
    return;
}


HRESULT
CTIMEPlayerDMusic::GetMimeType(BSTR *pmime)
{
    HRESULT hr = S_OK;

    *pmime = SysAllocString(L"audio/dmusic");
    return hr;
}


STDMETHODIMP
CTIMEPlayerDMusic::OnStartBinding( 
                                  /* [in] */ DWORD dwReserved,
                                  /* [in] */ IBinding __RPC_FAR *pib)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::GetPriority( 
                               /* [out] */ LONG __RPC_FAR *pnPriority)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnLowResource( 
                                 /* [in] */ DWORD reserved)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnProgress( 
                              /* [in] */ ULONG ulProgress,
                              /* [in] */ ULONG ulProgressMax,
                              /* [in] */ ULONG ulStatusCode,
                              /* [in] */ LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if (m_fAbortDownload)
    {
        hr = E_ABORT;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN1(hr, E_ABORT);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnStopBinding( 
                                 /* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::GetBindInfo( 
                               /* [out] */ DWORD __RPC_FAR *grfBINDF,
                               /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnDataAvailable( 
                                   /* [in] */ DWORD grfBSCF,
                                   /* [in] */ DWORD dwSize,
                                   /* [in] */ FORMATETC __RPC_FAR *pformatetc,
                                   /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnObjectAvailable( 
                                     /* [in] */ REFIID riid,
                                     /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


CTIMEDMusicStaticHolder::CTIMEDMusicStaticHolder()
{
    InitialState();
}

CTIMEDMusicStaticHolder::~CTIMEDMusicStaticHolder()
{
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%lx)::DetachFromHostElement() -- closing performance\n",
              this));

    LONG oldRef = 0;

    oldRef = InterlockedExchange(&m_lRef, 1); // we really want to release this time
    if (0 != oldRef)
    {
        Assert(0 == oldRef);
    }

    Assert(NULL == m_pLoader);
    Assert(m_comIDMusic == NULL);
    Assert(m_comIDMPerformance == NULL);
    Assert(m_comIDMComposer == NULL);

    ReleaseInterfaces();
}

void
CTIMEDMusicStaticHolder::InitialState()
{
    m_comIDMusic = NULL;
    m_comIDMPerformance = NULL;
    m_comIDMComposer = NULL;
    
    m_eVersionDM = dmv_61; // set to dmv_70orlater if certain interfaces are detected when DirectMusic is initialized
    m_fHaveInitialized = false;
    m_eHasDM = dm_unknown;
    m_fHasVersion8DM = false;
    m_pLoader = NULL;

    LONG oldRef = InterlockedExchange(&m_lRef, 0);
    if (0 != oldRef)
    {
        Assert(0 == oldRef);
    }
}

void
CTIMEDMusicStaticHolder::ReleaseInterfaces()
{    
    LONG l = InterlockedDecrement(&m_lRef);
    if (l > 0)
    {
        return;
    }
    Assert(l >= 0);

    TraceTag((tagDMusicStaticHolder, "Entering CueMediaCriticalSection"));

    CritSectGrabber cs2(m_CueMediaCriticalSection);
    CritSectGrabber cs(m_CriticalSection);

    TraceTag((tagDMusicStaticHolder, "entering release"));
    // Close loader
    if (m_pLoader)
    {
        TraceTag((tagDMusicStaticHolder, "loader"));
        m_pLoader->ClearCache(GUID_DirectMusicAllTypes);
        TraceTag((tagDMusicStaticHolder, "loader2"));
        m_pLoader->Release();
        TraceTag((tagDMusicStaticHolder, "loader3"));

        m_pLoader = NULL;
        TraceTag((tagDMusicStaticHolder, "loader done"));
    }

    // Release the ports
    if (m_comIDMusic)
    {
        m_comIDMusic->Activate(FALSE);
    }

    // Close performance
    if (m_comIDMPerformance)
    {
        // Stop everything that's playing.  Even though the individual segments
        // were stopped--meaning they won't play new notes--they may have played notes
        // previously that are still being held.  This cuts everything off.
        m_comIDMPerformance->Stop(NULL, NULL, 0, 0);
        
        m_comIDMPerformance->CloseDown();
    }

    // Composer and Performance are released automatically
    m_comIDMusic = NULL;
    m_comIDMPerformance = NULL;
    m_comIDMComposer = NULL;
        
    // make sure all the state is reset
    InitialState();
    TraceTag((tagDMusicStaticHolder, "Out of release"));
}

// Test whether DirectMusic is installed by attempting to open the registry key for CLSID_DirectMusicPerformance.
bool 
CTIMEDMusicStaticHolder::HasDM()
{
    CritSectGrabber cs(m_CriticalSection); 

    if (m_eHasDM == dm_unknown)
    {
        HKEY hkey = NULL;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, _T("CLSID\\{D2AC2881-B39B-11D1-8704-00600893B1BD}"), 0, KEY_EXECUTE, &hkey))
        {
            RegCloseKey(hkey);
            m_eHasDM = dm_yes;
        }
        else
        {
            m_eHasDM = dm_no;
        }
    }
    
    return m_eHasDM == dm_yes;
}

HRESULT
CTIMEDMusicStaticHolder::Init()
{
    HRESULT hr = S_OK;

    CritSectGrabber cs(m_CriticalSection);

    InterlockedIncrement(&m_lRef);

    if (m_fHaveInitialized)
    {
        RRETURN(S_OK);
    }
    {
        // another thread may have initialized while this one was waiting
        if (m_fHaveInitialized)
        {
            hr = S_OK;
            goto done;
        }

        // do work
            
        // Create and init loader
        if (!m_pLoader)
        {
            m_pLoader = new CLoader();
            if (!m_pLoader)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            hr = m_pLoader->Init();
            if (FAILED(hr))
            {
                delete m_pLoader;
                m_pLoader = NULL;
                goto done;
            }
        }
        
        // Create and init performance
        if (!m_comIDMPerformance)
        {
            hr = CoCreateInstance(CLSID_DirectMusicPerformance,
                NULL,
                CLSCTX_INPROC, //lint !e655
                IID_IDirectMusicPerformance,
                (void **)&m_comIDMPerformance);
            if (FAILED(hr))
            {
                goto done;
            }
            
            // QI to see if DirectX 8.0 is present.
            m_fHasVersion8DM = false;
            CComPtr<IDirectMusicPerformance8> comIDMusicPerformance8;
            hr = m_comIDMPerformance->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void**>(&comIDMusicPerformance8));
            if (SUCCEEDED(hr))
            {
                // Try and initialize the DirectX 8.0 performance, and use a Stereo (no reverb) audiopath with 80 PChannels
                hr = comIDMusicPerformance8->InitAudio(&m_comIDMusic, NULL, NULL, DMUS_APATH_DYNAMIC_STEREO, 80, DMUS_AUDIOF_ALL, NULL); 
                if (SUCCEEDED(hr))
                {
                    m_eVersionDM = dmv_70orlater;
                    m_fHasVersion8DM = true;
                }
            }

            if( !m_fHasVersion8DM )
            {
                hr = m_comIDMPerformance->Init(&m_comIDMusic, NULL, NULL);
                if (FAILED(hr))
                {
                    goto done;
                }
            
                // QI to see if DirectX 7.0 is present.
                // This is a bit bizarre as far as COM goes.  IID_IDirectMusic2 and IID_IDirectMusicPerformance2 are special IID's that
                //    are supported only by DirectX 7.0.  These don't return a different interface.  However, the mere act of doing the
                //    QI has the side effect of placing DirectMusic in a special mode that fixes certain DLS bugs that were present in
                //    DirectX 6.1.
                // So we are doing two things here.
                // - Determining if DirectX 7.0 or later is present.
                // - Placing DirectMusic in a mode that fixes certain bugs.  We aren't going to obsess over strict DirectX 6.1
                //   compatibility because an increasing majority of people will have DirectX 7.0 or later.
                CComPtr<IDirectMusic> comIDMusic2;
                hr = m_comIDMusic->QueryInterface(IID_IDirectMusic2, reinterpret_cast<void**>(&comIDMusic2));
                if (SUCCEEDED(hr))
                {
                    CComPtr<IDirectMusicPerformance> comIDMPerformance2;
                    hr = m_comIDMPerformance->QueryInterface(IID_IDirectMusicPerformance2, reinterpret_cast<void**>(&comIDMPerformance2));
                    if (SUCCEEDED(hr))
                        m_eVersionDM = dmv_70orlater;
                }

                // Create the software synth port.
                CComPtr<IDirectMusicPort> comIDMPort;
                DMUS_PORTPARAMS dmos;
                ZeroMemory(&dmos, sizeof(DMUS_PORTPARAMS));
                dmos.dwSize = sizeof(DMUS_PORTPARAMS);
                dmos.dwChannelGroups = 5; // create 5 channel groups on the port
                dmos.dwEffectFlags = 0;
                dmos.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_EFFECTS;
                hr = m_comIDMusic->CreatePort(CLSID_DirectMusicSynth, &dmos, &comIDMPort, NULL);
                if (FAILED(hr))
                {
                    goto done;
                }
                // Succeeded in creating the port.  Activate it and add it to the performance.
                hr = m_comIDMusic->Activate(TRUE);
                if (FAILED(hr))
                {
                    goto done;
                }
            
                hr = m_comIDMPerformance->AddPort(comIDMPort);
                if (FAILED(hr))
                {
                    goto done;
                }
            
                // Assign a block of 16 PChannels to this port.
                // Block 0, port pPort, and group 1 means to assign
                // PChannels 0-15 to group 1 on port pPort.
                // PChannels 0-15 correspond to the standard 16
                // MIDI channels.
                hr = m_comIDMPerformance->AssignPChannelBlock( 0, comIDMPort, 1 );
                if (FAILED(hr))
                {
                    goto done;
                }
            
                // asign the other 4 groups
                hr = m_comIDMPerformance->AssignPChannelBlock( 1, comIDMPort, 2 );
                if (FAILED(hr))
                {
                    goto done;
                }
                hr = m_comIDMPerformance->AssignPChannelBlock( 2, comIDMPort, 3 );
                if (FAILED(hr))
                {
                    goto done;
                }
                hr = m_comIDMPerformance->AssignPChannelBlock( 3, comIDMPort, 4 );
                if (FAILED(hr))
                {
                    goto done;
                }
                hr = m_comIDMPerformance->AssignPChannelBlock( 4, comIDMPort, 5 );
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        
        // Create the composer
        if (!m_comIDMComposer)
        {
            hr = CoCreateInstance(CLSID_DirectMusicComposer,
                NULL,
                CLSCTX_INPROC, //lint !e655
                IID_IDirectMusicComposer,
                (void **)&m_comIDMComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        m_fHaveInitialized = true;
    }        
            
    hr = S_OK;
done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdmusic.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _DMUSICPLAYER_H
#define _DMUSICPLAYER_H

#include "playerbase.h"
#include "mstimep.h"
#include "dmusici.h"
#include "loader.h"
#include "mediaelm.h"
#include "dmusicproxy.h"

class CTIMEMediaElement;

typedef enum SEG_TYPE_ENUM
{
    seg_primary,
    seg_secondary,
    seg_control,
    seg_max
}; //lint !e612

typedef enum BOUNDARY_ENUM 
{
    bound_default,
    bound_immediate,
    bound_grid,
    bound_beat,
    bound_measure,
    bound_queue,
    bound_max
}; //lint !e612

typedef enum TRANS_TYPE_ENUM
{
    trans_endandintro,
    trans_intro,
    trans_end,
    trans_break,
    trans_fill,
    trans_regular,
    trans_none,
    trans_max
}; //lint !e612

class CTIMEDMusicStaticHolder;
enum enumHasDM { dm_unknown, dm_yes, dm_no };
enum enumVersionDM { dmv_61, dmv_70orlater };

/////////////////////////////////////////////////////////////////////////////
// CTIMEPlayerDMusic

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195"))
CTIMEPlayerDMusic :
    public CTIMEBasePlayer,
    public CComObjectRootEx<CComSingleThreadModel>,
    public ITIMEDispatchImpl<ITIMEDMusicPlayerObject, &IID_ITIMEDMusicPlayerObject>,
    public ITIMEImportMedia,
    public IBindStatusCallback
{
  public:
    CTIMEPlayerDMusic(CTIMEPlayerDMusicProxy * pProxy);
    virtual ~CTIMEPlayerDMusic();

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    BEGIN_COM_MAP(CTIMEPlayerDMusic)        
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
    END_COM_MAP();

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };


    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement (void);
    HRESULT InitElementSize();
    HRESULT SetSize(RECT *prect);
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT clipBegin(VARIANT varClipBegin);
    HRESULT clipEnd(VARIANT varClipEnd);

    
    void OnTick(double dblSegmentTime,
                LONG lCurrRepeatCount);

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    HRESULT Reset();
    void PropChangeNotify(DWORD tePropType);

    bool SetSyncMaster(bool fSyncMaster);

    HRESULT SetRate(double dblRate);
    HRESULT GetVolume(float *pflVolume);
    HRESULT SetVolume(float flVolume);
    HRESULT GetMute(VARIANT_BOOL *pvarMute);
    HRESULT SetMute(VARIANT_BOOL varMute);
    HRESULT HasVisual(bool &fHasVideo);
    HRESULT HasAudio(bool &fHasAudio);
    HRESULT GetMimeType(BSTR *pMime);
    
    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    PlayerState GetState();

    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);
    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    STDMETHOD(put_repeat)(long   lTime);
    STDMETHOD(get_repeat)(long* plTime);
    STDMETHOD(cue)(void);
        
    // IUnknown Methods
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);


    //
    // IDirectMusicPlayer
    //
    STDMETHOD(get_isDirectMusicInstalled)(VARIANT_BOOL *pfInstalled);

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppMediaDownloader);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pMediaDownloader);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // IBindStatusCallback methods
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved);
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);
    
  protected:
    bool SafeToTransition();
    void InternalStart();
    void ResumeDmusic();

    // playback settings
    SEG_TYPE_ENUM m_eSegmentType;
    BOUNDARY_ENUM m_eBoundary;
    TRANS_TYPE_ENUM m_eTransitionType;
    bool m_fTransModulate;
    bool m_fTransLong;
    bool m_fImmediateEnd;

    // segment to play
    CComPtr<IDirectMusicSegment> m_comIDMSegment;

    // current playback state
    enum { playback_stopped, playback_paused, playback_playing } m_ePlaybackState;
    CComPtr<IDirectMusicSegmentState> m_comIDMSegmentState; // segment state of segment if it has been played
    CComPtr<IDirectMusicSegmentState> m_comIDMSegmentStateTransition; // segment state of a transition to the segment if it has been played
    REFERENCE_TIME m_rtStart; // time at which segment was played
    REFERENCE_TIME m_rtPause; // time at which playback was paused

  private:
    static CTIMEDMusicStaticHolder m_staticHolder;

    HRESULT ReadAttributes();
    HRESULT ReleaseInterfaces();
    CTIMEPlayerDMusic();
    
    LONG                   m_cRef;
    CTIMEMediaElement      *m_pTIMEMediaElement;
    bool                    m_bActive;
    bool                    m_fRunning;
    bool                    m_fAudioMute;
    float                   m_flVolumeSave;
    bool                    m_fLoadError;
    bool                    m_fMediaComplete;
    bool                    m_fHaveCalledStaticInit;
    bool                    m_fAbortDownload;

    long                    m_lSrc;
    long                    m_lBase;
    IStream                *m_pTIMEMediaPlayerStream;

    bool                    m_fRemoved;
    bool                    m_fHavePriority;
    double                  m_dblPriority;
    double                  m_dblPlayerRate;
    double                  m_dblSpeedChangeTime;
    double                  m_dblSyncTime;
    bool                    m_fSpeedIsNegative;


    bool                    m_fUsingInterfaces;
    bool                    m_fNeedToReleaseInterfaces;
    HRESULT                 m_hrSetSrcReturn;
    
    CritSect                m_CriticalSection;

    WCHAR                  *m_pwszMotif;
    bool                    m_fHasSrc;

    // used later if it's a motif in order to set secondary by default
    bool                    m_fSegmentTypeSet;

    CTIMEPlayerDMusicProxy *m_pProxy;
};

class CTIMEDMusicStaticHolder
{
  public:
    CTIMEDMusicStaticHolder();
    virtual ~CTIMEDMusicStaticHolder();

    HRESULT Init();
    
    IDirectMusicPerformance * GetPerformance() { CritSectGrabber cs(m_CriticalSection); return m_comIDMPerformance; }
    IDirectMusicComposer * GetComposer() { CritSectGrabber cs(m_CriticalSection); return m_comIDMComposer; }
    CLoader * GetLoader() { CritSectGrabber cs(m_CriticalSection); return m_pLoader; }
    enumVersionDM GetVersionDM() { CritSectGrabber cs(m_CriticalSection); return m_eVersionDM; }
    bool GetHasVersion8DM() { CritSectGrabber cs(m_CriticalSection); return m_fHasVersion8DM; }
    
    bool HasDM();
    
    void ReleaseInterfaces();

    CritSect&   GetCueMediaCriticalSection() { return m_CueMediaCriticalSection; }
    
  private:
    CritSect                            m_CriticalSection;
    CritSect                            m_CueMediaCriticalSection;
    
    bool                                m_fHaveInitialized;

    CComPtr<IDirectMusic>               m_comIDMusic;
    CComPtr<IDirectMusicPerformance>    m_comIDMPerformance;
    CComPtr<IDirectMusicComposer>       m_comIDMComposer;
    CLoader                            *m_pLoader;

    enumVersionDM                       m_eVersionDM;
    bool                                m_fHasVersion8DM;
    enumHasDM                           m_eHasDM;

    LONG                                m_lRef;

    void InitialState();
};

#endif /* _DMUSICPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerbase.h"
#include "decibels.h"
#include "mediaelm.h"


CTIMEBasePlayer::CTIMEBasePlayer() :
    m_pTIMEElementBase(NULL),
    m_dblPriority(INFINITE),
    m_fHavePriority(false),
    m_dblClipStart(valueNotSet),
    m_dblClipEnd(valueNotSet),
    m_lClipStartFrame(valueNotSet),
    m_lClipEndFrame(valueNotSet),
    m_pAtomTable(NULL),
    m_pPlaybackSite(NULL)
{
    ;
}

CTIMEBasePlayer::~CTIMEBasePlayer()
{
    if (m_pAtomTable)
    {
        ReleaseInterface(m_pAtomTable);
    }
    m_pTIMEElementBase = NULL;
}

HRESULT
CTIMEBasePlayer::Init(CTIMEMediaElement *pelem,
                      LPOLESTR base,
                      LPOLESTR src,
                      LPOLESTR lpMimeType,
                      double dblClipBegin,
                      double dblClipEnd)
{
    HRESULT hr = S_OK;

    m_pTIMEElementBase = pelem;

    if (pelem)
    {
        Assert(NULL == m_pAtomTable);
        m_pAtomTable = pelem->GetAtomTable();
        if (m_pAtomTable)
        {
            m_pAtomTable->AddRef();
        }
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEBasePlayer::GetAuthor(BSTR *pAuthor)
{
    pAuthor = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetTitle(BSTR *pTitle)
{
    pTitle = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetCopyright(BSTR *pCopyright)
{
    pCopyright = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetAbstract(BSTR *pAbstract)
{
    pAbstract = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetRating(BSTR *pRating)
{
    pRating = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetVolume(float *flVolume)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::SetVolume(float flVolume)
{
    return E_NOTIMPL;
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458
HRESULT
CTIMEBasePlayer::GetBalance(float *flBal)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::SetBalance(float flBal)
{
    return E_NOTIMPL;
}
#endif

HRESULT
CTIMEBasePlayer::GetMute(VARIANT_BOOL *varMute)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::SetMute(VARIANT_BOOL varMute)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::GetPlayList(ITIMEPlayList **ppPlayList)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::SetActiveTrack(long index)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::GetActiveTrack(long *index)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::GetNaturalHeight(long *height)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::GetNaturalWidth(long *width)
{
    return E_NOTIMPL;
}


HRESULT 
CTIMEBasePlayer::onMouseDown(long x, long y)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::onMouseMove(long x, long y)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CppDsPlay
//
//
// BalanceLogToLin
//
// Balance has the same range as the volume but is signed (ie range is twice
// as big). In our conversions we can use the VolumeLogToLin/LinToLog methods
// but need to scale the returned values by half.
//
float
CTIMEBasePlayer::BalanceLogToLin(long LogValue)
{
    float LinKnobValue;

    if (LogValue > 0 )
    {
        //
        // - need to invert the LogValue for VolumeLogToLin
        // - scale the value by 1/2 because of doubly sized range
        // - offset the value at the middle MIN_VOLUME_RANGE to MAX_VOLUME_RANGE
        //
        LinKnobValue = MAX_VOLUME_RANGE - (VolumeLogToLin(-LogValue) - MIN_VOLUME_RANGE) / 2.0 + MIN_VOLUME_RANGE;
    }
    else
    {
        LinKnobValue = (VolumeLogToLin(LogValue) - MIN_VOLUME_RANGE) / 2.0 + MIN_VOLUME_RANGE;
    }
    return LinKnobValue;
}

/////////////////////////////////////////////////////////////////////////////
// CppDsPlay
//
// BalanceLinToLog
//
long
CTIMEBasePlayer::BalanceLinToLog(float LinKnobValue)
{
    long LogValue;

    // In which half is the value?
    if (LinKnobValue > (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2)
    {
        // upper half
        //
        // - invert LogValue for VolumeLinToLog
        // - remove offset (which is at middle of knob range) and scale by 2
        // - add MIN_VOLUME_RANGE offset
        LogValue = - VolumeLinToLog(
            ((MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) -
            (LinKnobValue - (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2) * 2 +
            MIN_VOLUME_RANGE)); //lint !e736 !e747
    }
    else
    {
        // lower half
        LogValue = VolumeLinToLog(
            ((LinKnobValue - MIN_VOLUME_RANGE) * 2 + MIN_VOLUME_RANGE)); //lint !e736 !e747
    }

    return LogValue;
}
//
// VolumeLinToLog
//
// Map linear value (MIN_VOLUME_RANGE - MAX_VOLUME_RANGE) to
// logarithmic values (AX_MIN_VOLUME - AX_MAX_VOLUME)
long
CTIMEBasePlayer::VolumeLinToLog(float LinKnobValue)
{
    long lLinMin = DBToAmpFactor(AX_MIN_VOLUME);
    long lLinMax = DBToAmpFactor(AX_MAX_VOLUME);

    long lLinTemp = (LinKnobValue - MIN_VOLUME_RANGE) * (lLinMax - lLinMin)
        / (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) + lLinMin; //lint !e524

    long LogValue = AmpFactorToDB(lLinTemp );
    return LogValue;
}

//
// VolumeLogToLin
//
// Map logarithmic values (AX_MIN_VOLUME - AX_MAX_VOLUME) to
// linear value (MIN_VOLUME_RANGE - MAX_VOLUME_RANGE)
//
float
CTIMEBasePlayer::VolumeLogToLin(long LogValue)
{
    long lLinMin = DBToAmpFactor(AX_MIN_VOLUME);
    long lLinMax = DBToAmpFactor(AX_MAX_VOLUME);

    float LinKnobValue = (((LONG) DBToAmpFactor(LogValue) - lLinMin) *
        (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / (lLinMax - lLinMin) + MIN_VOLUME_RANGE); //lint !e736

    return LinKnobValue;
}

PlayerState
CTIMEBasePlayer::GetState()
{
    return PLAYER_STATE_UNKNOWN;
}

HRESULT
CTIMEBasePlayer::Reset()
{
    HRESULT hr = S_OK;
    return hr;
}

bool
CTIMEBasePlayer::UpdateSync()
{
    return true;
}

void
CTIMEBasePlayer::Tick()
{
    return;
}

HRESULT
CTIMEBasePlayer::InitElementSize()
{
    return S_OK;
}

HRESULT
CTIMEBasePlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    bcanSeekToM = false;
    return S_OK;
}


HRESULT
CTIMEBasePlayer::CanPause(bool &bcanPause)
{
    bcanPause = true;
    return S_OK;
}

HRESULT
CTIMEBasePlayer::HasPlayList(bool &fhasPlayList)
{
    fhasPlayList = false;
    return S_OK;
}

HRESULT
CTIMEBasePlayer::IsBroadcast(bool &bisBroad)
{
    bisBroad = false;
    return S_OK;
}

HRESULT
CTIMEBasePlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = false;
    return S_FALSE;
}

HRESULT
CTIMEBasePlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = false;
    return S_FALSE;
}

HRESULT
CTIMEBasePlayer::HasAudio(bool &bHasAudio)
{
    bHasAudio = false;
    return S_FALSE;
}

double
CTIMEBasePlayer::GetClipBegin()
{
    double dblClipBegin;

    if(m_dblClipStart != valueNotSet)
    {
        dblClipBegin = m_dblClipStart;
    }
    else
    {
        dblClipBegin = 0.0;
    }

    return dblClipBegin;
}

void 
CTIMEBasePlayer::GetClipBegin(double &dblClipBegin)
{

    if(m_dblClipStart != valueNotSet)
    {
        dblClipBegin = m_dblClipStart;
    }
    else
    {
        dblClipBegin = 0.0;
    }

} // getClipBegin

void
CTIMEBasePlayer::SetClipBegin(double dblClipBegin)
{
    if (dblClipBegin < 0.0)
    {
        dblClipBegin = 0.0;
    }
    
    m_dblClipStart = dblClipBegin;
} // putClipBegin

void
CTIMEBasePlayer::GetClipEnd(double &dblClipEnd)
{
    dblClipEnd = m_dblClipEnd;

} // getClipEnd

void 
CTIMEBasePlayer::SetClipEnd(double dblClipEnd)
{
    if (dblClipEnd < 0.0)
    {
        dblClipEnd = -1;
    }
    
    m_dblClipEnd = dblClipEnd;

    return;
} // putClipEnd

void 
CTIMEBasePlayer::GetClipBeginFrame(long &lClipBegin)
{

    lClipBegin = m_lClipStartFrame;

} // getClipBegin

void
CTIMEBasePlayer::SetClipBeginFrame(long lClipBegin)
{
    if (lClipBegin < 0)
    {
        lClipBegin = 0.0;
    }
    
    m_lClipStartFrame = lClipBegin;
} // putClipBegin

void
CTIMEBasePlayer::GetClipEndFrame(long &lClipEnd)
{
    lClipEnd = m_lClipEndFrame;

} // getClipEnd

void 
CTIMEBasePlayer::SetClipEndFrame(long lClipEnd)
{
    if (lClipEnd < 0.0)
    {
        lClipEnd = -1;
    }
    
    m_lClipEndFrame = lClipEnd;

    return;
} // putClipEnd

HRESULT
CTIMEBasePlayer::GetRate(double &dblRate)
{
    HRESULT hr = E_NOTIMPL;

    dblRate = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::SetRate(double dblRate)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;
    return hr;
}

void
CTIMEBasePlayer::PropChangeNotify(DWORD tePropType)
{
    if (m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    if ((tePropType & TE_PROPERTY_ISON) != 0)
    {
        m_pTIMEElementBase->InvalidateElement(NULL);
    }

  done:
    return;
}

void 
CTIMEBasePlayer::ReadyStateNotify(LPWSTR szReadyState)
{
    return; //E_NOTIMPL;
}


HRESULT
CTIMEBasePlayer::GetEffectiveLength(double &dblLength)
{
    HRESULT hr;

    hr = GetMediaLength(dblLength);
    if(FAILED(hr))
    {
        goto done;
    }

    if(m_dblClipEnd != valueNotSet)
    {
        dblLength = m_dblClipEnd;
    }
    if(m_dblClipStart != valueNotSet)
    {
        dblLength -= m_dblClipStart;
    }
    
done:
    return hr;
}

bool
CTIMEBasePlayer::IsActive() const
{
    bool bRet = false;

    if (m_pTIMEElementBase)
    {
        bRet = m_pTIMEElementBase->IsActive();
    }

    return bRet;
}


bool
CTIMEBasePlayer::IsPaused() const
{
    bool bRet = false;

    if (m_pTIMEElementBase)
    {
        bRet = m_pTIMEElementBase->IsPaused();
    }

    return bRet;
}

bool
CTIMEBasePlayer::IsParentPaused() const
{
    bool bRet = false;

    if (m_pTIMEElementBase && m_pTIMEElementBase->GetParent())
    {
        bRet = m_pTIMEElementBase->GetParent()->IsPaused();
    }

    return bRet;
}

IHTMLElement *
CTIMEBasePlayer::GetElement()
{
    IHTMLElement * pRet = NULL;

    if (m_pTIMEElementBase)
    {
        pRet = m_pTIMEElementBase->GetElement();
    }

    return pRet;
}

IServiceProvider *
CTIMEBasePlayer::GetServiceProvider()
{
    IServiceProvider * pRet = NULL;

    if (m_pTIMEElementBase)
    {
        pRet = m_pTIMEElementBase->GetServiceProvider();
    }

    return pRet;
}

void
CTIMEBasePlayer::InvalidateElement(LPCRECT lprect)
{
    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->InvalidateElement(lprect);
    }
}

void
CTIMEBasePlayer::PutNaturalDuration(double dblNatDur)
{
    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->PutNaturalDuration(dblNatDur);
    }
}

void
CTIMEBasePlayer::ClearNaturalDuration()
{
    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->ClearNaturalDuration();
    }
}

void
CTIMEBasePlayer::LoadFailNotify(PLAYER_EVENT reason)
{
    return;
}
double
CTIMEBasePlayer::GetElapsedTime() const
{
    double dblRet = 0.0;

    if (m_pTIMEElementBase)
    {
        dblRet = m_pTIMEElementBase->GetTESimpleTime();
    }

    return dblRet;
}

HRESULT
CTIMEBasePlayer::GetEarliestMediaTime(double &dblEarliestMediaTime)
{
    HRESULT hr = E_NOTIMPL;

    dblEarliestMediaTime = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::GetLatestMediaTime(double &dblLatestMediaTime)
{
    HRESULT hr = E_NOTIMPL;

    dblLatestMediaTime = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::GetMinBufferedMediaDur(double &dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;

    dblMinBufferedMediaDur = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::SetMinBufferedMediaDur(double dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetDownloadTotal(LONGLONG &lldlTotal)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;
    fIsStreamed = false;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;
    dblBufferingProgress = 0.0;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    fHasDownloadProgress = false;
    return hr;
}

HRESULT 
CTIMEBasePlayer::GetDownloadProgress(double &dblDownloadProgress)
{
    HRESULT hr = S_OK;
    dblDownloadProgress = 0.0;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = E_NOTIMPL;
    pMime = NULL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetCurrentFrame(LONGLONG &lFrameNr)
{
    HRESULT hr = E_NOTIMPL;
    lFrameNr = -1;
    return hr;
}

HRESULT
CTIMEBasePlayer::ConvertFrameToTime(LONGLONG iFrame, double &dblTime)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

void
CTIMEBasePlayer::SetPlaybackSite(CTIMEBasePlayer *pSite)
{
    m_pPlaybackSite = pSite;
}

void 
CTIMEBasePlayer::FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer)
{
}

HRESULT
CTIMEBasePlayer::GetPlaybackOffset(double &dblOffset)
{
    HRESULT hr = E_NOTIMPL;
    dblOffset = 0.0;

    return hr;
}


HRESULT
CTIMEBasePlayer::GetEffectiveOffset(double &dblOffset)
{
    HRESULT hr = E_NOTIMPL;
    dblOffset = 0.0;

    return hr;
}

HRESULT 
CTIMEBasePlayer::NotifyTransitionSite (bool fTransitionToggle)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdshow.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerdshow.h"
#include "mediaelm.h"
#include <wininet.h>
#include <inc\evcode.h>
#include "tags\bodyelm.h"

class
__declspec(uuid("22d6f312-b0f6-11d0-94ab-0080c74c7e95"))
MediaPlayerCLSID {};

#define SecsToNanoSecs 10000000

#define OVLMixer L"Overlay Mixer"

#define SOUND_OF_SILENCE -10000
// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowTimePlayer, "TIME: Players", "CTIMEDshowPlayer methods");
DeclareTag(tagDshowSyncTimePlayer, "TIME: Players", "CTIMEDshowPlayer sync methods");

CTIMEDshowPlayer::CTIMEDshowPlayer(CTIMEDshowPlayerProxy * pProxy) :
    m_fHasVideo(false),
    m_fDoneSetup(false),
    m_pIMixerOCX(NULL),
    m_dblSeekAtStart(0.0),
    m_nativeVideoWidth(0),
    m_nativeVideoHeight(0),
    m_displayVideoWidth(0),
    m_displayVideoHeight(0),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_fNeedToDeleteInterfaces(false),
    m_fUsingInterfaces(false),
    m_fLoadError(false),
    m_fHasMedia(false),
    m_dblPriority(INFINITE),
    m_fCanCueNow(false),
    m_fHavePriority(false),
    m_hrRenderFileReturn(S_OK),
    m_pProxy(pProxy)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::CTIMEDshowPlayer()",
              this));


}


CTIMEDshowPlayer::~CTIMEDshowPlayer()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::~CTIMEDshowPlayer()",
              this));

    m_pMediaContent = NULL;
    if (m_pIMixerOCX != NULL)
    {
        m_pIMixerOCX->UnAdvise();
    }
    m_pIMixerOCX = NULL;

    ReleaseGenericInterfaces();

    ReleaseInterface(m_pTIMEMediaPlayerStream);

    m_pOvM = NULL;

    delete m_pProxy;
}

STDMETHODIMP_(ULONG)
CTIMEDshowPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDshowPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}


STDMETHODIMP
CTIMEDshowPlayer::OnInvalidateRect(LPCRECT lpcRect)
{

    TraceTag((tagDshowTimePlayer, "CTIMEDshowPlayer(%lx)::OnInvalidateRect(%x)", this, lpcRect));

    ::PostMessage(m_pwndMsgWindow, WM_INVALIDATE, NULL, NULL);

    return S_OK;
}

STDMETHODIMP
CTIMEDshowPlayer::OnStatusChange(ULONG ulStatusFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CTIMEDshowPlayer::OnDataChange(ULONG ulDataFlags)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEDshowPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::Init)",
              this));
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;
    
    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }
    if (src == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(NULL != GetImportManager());

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }

    ClearNaturalDuration();

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    Assert(NULL != m_pTIMEElementBase->GetBody());
    hr = m_pTIMEElementBase->GetBody()->AddInternalEventSink(this, 0.0);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::DetachFromHostElement)",
              this));

    if(m_fDetached)
    {
        goto done;
    }

    m_fRemoved = true;
    m_fDetached = true;

    if (m_spOpenProgress)
    {
        m_spOpenProgress->AbortOperation();
        m_spOpenProgress = NULL;
    }

    Assert(NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    CTIMEDshowBasePlayer::DetachFromHostElement();

    {
        CritSectGrabber cs(m_CriticalSection);
        
        if (false == m_fUsingInterfaces)
        {
            DeinitDshow();
        }
        else
        {
            m_fNeedToDeleteInterfaces = true;
        }
    }
    
    if (NULL != m_pTIMEElementBase->GetBody())
    {
        IGNORE_HR(m_pTIMEElementBase->GetBody()->RemoveInternalEventSink(this));
    }
    
    m_pTIMEElementBase = NULL;
    NullAtomTable();

done:
    return hr;
}

void
CTIMEDshowPlayer::ReleaseSpecificInterfaces()
{
    m_pMediaContent = NULL;
    if (m_pIMixerOCX != NULL)
    {
        m_pIMixerOCX->UnAdvise();
        m_pIMixerOCX->Release();
        m_pIMixerOCX = NULL;
    }
}

void
CTIMEDshowPlayer::FreeSpecificData()
{

}

void
CTIMEDshowPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDshowPlayer::BuildGraph()
{
    HRESULT hr = S_OK;

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                          NULL,
                          CLSCTX_INPROC_SERVER, //lint !e655
                          IID_IGraphBuilder,
                          (void **)&m_pGB);
    // dshow not installed
    if (hr == REGDB_E_CLASSNOTREG)
    {
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                              NULL,
                              CLSCTX_INPROC_SERVER, //lint !e655
                              IID_IGraphBuilder,
                              (void **)&m_pGB);
    }
    if (FAILED(hr))
    {
        goto done;
    }

    // If we need to teardown while in RenderFile, use this interface:
    IGNORE_HR(m_pGB->QueryInterface(IID_TO_PPV(IAMOpenProgress, &m_spOpenProgress)));

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;

    if (m_pOvM == NULL)
    {
        hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        // dshow not installed
        if (hr == REGDB_E_CLASSNOTREG)
        {
            CComPtr<IUnknown> pObj;
            hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                                  IID_IUnknown,
                                  (void **)&pObj));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        }
        if (FAILED(hr) || m_pOvM == NULL)
        {
            goto done;
        }
    }

    hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    if (hr == E_NOINTERFACE)
    {
        // dshow dll is there, but its not properly registered
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            m_pOvM.Release();
            goto done;
        }

        hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    }
    if (FAILED(hr) || m_pIMixerOCX == NULL)
    {
        m_pOvM.Release();
        goto done;
    }
    hr = m_pIMixerOCX->Advise(SAFECAST(this, IMixerOCXNotify*));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pGB->AddFilter(m_pOvM, OVLMixer);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fMediaComplete = false;
done:
    return hr;
}


HRESULT
CTIMEDshowPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

class CSimplePB : public IMediaPropertyBag
{
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) { return E_NOINTERFACE; }
    STDMETHOD_(ULONG, AddRef)(THIS) { return 0; }
    STDMETHOD_(ULONG, Release)(THIS) { return 0; }
        
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) { return E_NOTIMPL; }
    STDMETHOD(EnumProperty) (ULONG iProperty, VARIANT *pvarName, VARIANT *pvarVal) { return E_NOTIMPL; } 
        
    LPCOLESTR m_pLookFor;
    BSTR *m_pbstrOut;

    STDMETHOD(Write) (LPCOLESTR pszPropName, VARIANT *pVar)
    {
        if (0 == wcscmp(m_pLookFor, pszPropName))
        {
            if (pVar->vt != VT_BSTR)
            {
                return E_NOTIMPL;
            }

            *m_pbstrOut = SysAllocString(pVar->bstrVal);
            if (NULL == m_pbstrOut)
            {
                return E_FAIL;
            }
        }

        return S_OK;
    }

    public:    
    CSimplePB() :
        m_pbstrOut(NULL), m_pLookFor(NULL) {}
    CSimplePB(LPCOLESTR pLookFor, BSTR *pbstrOut) :
        m_pbstrOut(pbstrOut), m_pLookFor(pLookFor) {}
};



HRESULT
CTIMEDshowPlayer::ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR * pbstr)
{
    IPersistMediaPropertyBag *pPMPB = NULL;
    if (S_OK == FindInterfaceOnGraph(pGraph, IID_IPersistMediaPropertyBag,
                                     (void **) &pPMPB))
    {
        CSimplePB pb(lpcwstrTag, pbstr);

        pPMPB->Save(&pb, FALSE, FALSE);

        pPMPB->Release();
    }

    return *pbstr ? S_OK : E_FAIL;
}

HRESULT
CTIMEDshowPlayer::SetUpHdc()
{
    HRESULT hr = S_OK;

    if (IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pIMixerOCX->GetVideoSize(&m_nativeVideoWidth, &m_nativeVideoHeight);
        if (FAILED(hr))
        {
            goto done;
        }

        m_fHasVideo = true;
    }
    else //if we only have audio: native size is 0 0
    {
        m_nativeVideoWidth = 0;
        m_nativeVideoHeight = 0;
    }
    m_fDoneSetup = true;
done:

    return hr;
}

HRESULT
CTIMEDshowPlayer::InitElementSize()
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;
    bool fResetRs = false;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    if (m_bIsHTMLSrc)
    {
        hr = S_OK;
        goto done;
    }

    if(m_pPlaybackSite && (m_pPlaybackSite->GetNativePlayer() != NULL))
    {
        fResetRs = true;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeVideoWidth;
    nativeSize.bottom = m_nativeVideoHeight;
    IGNORE_HR(SetMixerSize( &nativeSize));
    
    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative, fResetRs);
    m_displayVideoHeight = m_nativeVideoHeight;
    m_displayVideoWidth = m_nativeVideoWidth;
    
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{   
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetSrc()\n",
              this));
    
    LPOLESTR szSrc = NULL;
    HRESULT hr = S_OK;

    //create and initialize the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    DeinitDshow();
    m_fLoadError = false;
    if (src == NULL)
    {
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }


    if (!InternetCrackUrlW(szSrc, lstrlenW(szSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        SetStreamFlags(URLComp.lpszExtraInfo);

        lpszPath = NEW OLECHAR [URLComp.dwUrlPathLength + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        StrCpyNW(lpszPath, URLComp.lpszUrlPath, URLComp.dwUrlPathLength + 1);            
        lpszPath[URLComp.dwUrlPathLength] = 0;

        hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        delete [] lpszPath;
        lpszPath = NULL;
    }
    else
    {
        hr = THR(m_pGB->RenderFile(szSrc, NULL));
    }
    if (FAILED(hr)) // this fall through catches media load failed errors from either call to RenderFile above.
    {
        m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
        goto done;
    }


    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }


    //InitElementDuration();
    hr = m_pMC->Run();
    if (FAILED(hr))
    {
        goto done;
    } 

    if (m_fRunning == false)
    {
        Pause();
    }
    else
    {
        Resume();
    }

    ClearNaturalDuration();

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }
    delete[] szSrc;
    
    return hr;

}

STDMETHODIMP
CTIMEDshowPlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = m_fCanCueNow ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::CueMedia()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::CueMedia()",
              this));
    HRESULT hr = S_OK;

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;
    CComPtr<IStream> spStream;
    
    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pProxy);

    {   
        // Mark the dshow interfaces in use in order to 
        // prevent us from releasing via a callback from
        // dshow from reentering with a DetachFromHostElement
        // call.
        //
        CritSectGrabber cs(m_CriticalSection);

        m_fUsingInterfaces = true;
    }
    
    Block();

    IGNORE_HR(BeginDownload());

    UnBlock();
    
    hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    {
        // Relinquish our hold on the dshow-related interfaces.
        // This is to prevent reentrancy from dshow back into
        // DetachFromHostElement.
        CritSectGrabber cs(m_CriticalSection);

        if (m_fNeedToDeleteInterfaces)
        {
            DeinitDshow();
            m_fNeedToDeleteInterfaces = false;
        }
    
        m_fUsingInterfaces = false;
    }
    
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::MediaDownloadError()
{
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::BeginDownload()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    CComPtr<IHTMLElement2> spElement2;

    const WCHAR * cpchSrc = NULL;
    WCHAR * beckified = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if(GetAtomTable() == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pGB == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        long l = 0;
        lpszPath = NEW OLECHAR [lstrlenW(cpchSrc) + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }   
        l = lstrlenW(cpchSrc);
        StrCpyNW(lpszPath, cpchSrc, l - URLComp.dwExtraInfoLength + 1);            
        lpszPath[l - URLComp.dwExtraInfoLength + 1] = 0;
        //StrCpyNW(lpszPath, URLComp.lpszUrlPath, lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength);            
        //lpszPath[lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength] = 0;

// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL(lpszPath);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        }
        delete [] lpszPath;
        lpszPath = NULL;

        SetStreamFlags(URLComp.lpszExtraInfo);
    }
    else
    {
        if (m_pGB == NULL)
        {
            hr = E_FAIL;
            goto done;
        }
// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL((WCHAR *)cpchSrc);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(cpchSrc, NULL));
        }
    }

    if (FAILED(hr))
    {
        // this fall through catches media load 
        // failed errors from either call to RenderFile above.
        m_hrRenderFileReturn = hr;
    }

    hr = S_OK;
done:

    delete[] beckified;
    RRETURN(hr);
}

HRESULT
CTIMEDshowPlayer::GraphFinish()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    
    CComPtr<IHTMLElement2> spElement2;

    if (FAILED(m_hrRenderFileReturn))     
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        hr = m_hrRenderFileReturn;
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    if (!IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pGB->RemoveFilter(m_pOvM);
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
     //can be used m_pIAMNetShowConfig->put_BufferingTime(1.0);
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetShowConfig,  (void **) &m_pIAMNetShowConfig);
    if (FAILED(hr))
    {
        m_pIAMNetShowConfig = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMExtendedSeeking, (void **) &m_pExSeeking);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetworkStatus, (void **) &m_pIAMNetStat);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GraphCue();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
        if (FAILED(hr))
        {
            // IE4 path
            CComPtr<IElementBehaviorSite> spElementBehaviorSite;
            spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();
            
            CComPtr<IObjectWithSite> spSite;
            // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
            hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
            if (FAILED(hr))
            {
                goto done;
            }
            
            CComPtr<IOleWindow> spOleWindow;
            // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
            hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEDshowPlayer::Init - IE4 failure! unable to QI for IOleWindow on hosting Document"));
                goto done;
            }
        }
    }

done:
    return hr;
}

//
// CTIMEDshowPlayer::IsOvMConnected(): Private method to detect if the video stream 
// is passing through the Overlay Mixer (i.e, is it connected?).
//
bool
CTIMEDshowPlayer::IsOvMConnected(IBaseFilter *pOvM)
{    
    IEnumPins   *pEnumPins;
    IPin        *pPin;
    IPin        *pPin2;
    ULONG        ul;
    HRESULT      hr;
    bool         bConnected = false;

    pOvM->EnumPins(&pEnumPins);
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul && bConnected == false)
    {
        hr = pPin->ConnectedTo(&pPin2);
        if (SUCCEEDED(hr) && pPin2)
        {
            bConnected = true;
            pPin2->Release();
        }
        pPin->Release();
    }
    pEnumPins->Release();
    
    return bConnected;
}

void
CTIMEDshowPlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

void
CTIMEDshowPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::GraphStart()",
              this));

    m_fLoadError = false;

    if (m_fMediaComplete == false)
    {
        goto done;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }

  done: 

    return;
}
    
HRESULT
CTIMEDshowPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::Render(%d-%d)",
              this,
              prc->right - prc->left,
              prc->bottom - prc->top));
    HRESULT hr = S_OK;
    int iOrigBltMode;
    bool bIsOn;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }
        
    bIsOn = m_pTIMEElementBase->IsOn();

    // Protect against render calls before the player is ready to render.
    // Not oding this causes a BVT failure.
    if(!m_fDoneSetup)
    {
        goto done;
    }

    iOrigBltMode = SetStretchBltMode(hdc, COLORONCOLOR);
    if (0 == iOrigBltMode)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_fHasVideo && bIsOn)
    {
        m_pIMixerOCX->OnDraw(hdc, prc);
    }

    SetStretchBltMode(hdc, iOrigBltMode);
    
done:
    return hr;
}


// Helper functions..

HRESULT
CTIMEDshowPlayer::SetMixerSize(RECT *prect)
{
    HRESULT hr = S_OK;
    POINT pt;

    if (m_pIMixerOCX == NULL)
    {
        return S_OK;
    }
    pt.x = pt.y = 0;
    hr = m_pIMixerOCX->SetDrawRegion(&pt, prect, prect);

    return hr;
}

HRESULT
CTIMEDshowPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    Assert(prect != NULL);
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = m_pMP->get_Duration(&dblLength);
    return hr;
}


HRESULT
CTIMEDshowPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    LONG canSeek;
    long seekFlags = 0;

    if (m_pExSeeking == NULL)
    {
        if (!m_pMP)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekBackward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekForward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        fcanSeek = true;
    }
    else
    {
        hr = m_pExSeeking->get_ExSeekCapabilities( &seekFlags);
        if (SUCCEEDED(hr)) 
        {
            if( seekFlags & AM_EXSEEK_CANSEEK)
            {
                fcanSeek = true;
                goto done;
            }
        }
        hr = S_OK;
        fcanSeek = false;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    if (NULL != pAuthor)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_AuthorName(pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/IART", pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    if (NULL != pTitle)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Title(pTitle);
            if (FAILED(hr))
            {
                *pTitle = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/INAM", pTitle);
            if (FAILED(hr))
            {
                hr = ReadContentProperty(m_pGB, L"INFO/ISBJ", pTitle);
                if (FAILED(hr))
                {
                    *pTitle = NULL;
                }
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    if (NULL != pCopyright)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Copyright(pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/ICOP", pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }
    }
    return hr;
}


HRESULT
CTIMEDshowPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrAbstract)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Description(pBstrAbstract);
            if (FAILED(hr))
            {
                *pBstrAbstract = NULL;
            }
        }
        else
        {
            *pBstrAbstract = NULL;
        }
    }
    return hr;
}


HRESULT
CTIMEDshowPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrRating)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Rating(pBstrRating);
            if (FAILED(hr))
            {
                *pBstrRating = NULL;
            }
        }
        else
        {
            *pBstrRating = NULL;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
void  
CTIMEDshowPlayer::SetStreamFlags(LPOLESTR src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    
    m_bIsSAMISrc = false;
    m_bIsHTMLSrc = false;

    len = lstrlenW(src);
    if (len >= HTMLSTREAMSRCLEN)
    {
        memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));
    
        if (StrCmpIW(stream, HTMLSTREAMSRC) == 0)
        {
            m_bIsHTMLSrc = true;
        }
        if (StrCmpIW(stream, SAMISTREAMSRC) == 0)
        {
            m_bIsSAMISrc = true;
        }
    
    }
}

HRESULT
CTIMEDshowPlayer::DisableAudioVideo()
{
    HRESULT hr = E_FAIL;

    CComPtr<IBaseFilter> pMediaFilter;
    CComPtr<IPin> pPin;
    CComPtr<IEnumPins> pMediaPinEnum;
    
    //disconnect the video
    if (m_pMediaContent == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = m_pMediaContent->QueryInterface(IID_IBaseFilter, (void **)&pMediaFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMediaFilter->EnumPins(&pMediaPinEnum);
    if (!pMediaPinEnum)
    {
        goto done;
    }
    while(pMediaPinEnum->Next(1, &pPin, NULL) == S_OK)
    {
        if (pPin != NULL)
        {
            IGNORE_HR(pPin->Disconnect());
        }
    }
    
    //silence the audio
    if (m_pBasicAudio != NULL)
    {
        hr = THR(m_pBasicAudio->put_Volume(SOUND_OF_SILENCE));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP
CTIMEDshowPlayer::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimePlayer, "CTIMEDshowPlayer(%lx)(%x)::InitializeElementAfterDownload",this));

    const WCHAR * cpchSrc = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;

    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if (m_fRemoved)
    {
        hr = E_FAIL;
        m_pMC->Stop();
        goto done;
    }

    hr = this->GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    m_fMediaComplete = true;

    FireMediaEvent(PE_ONMEDIACOMPLETE);
    
    IGNORE_HR(this->InitElementDuration());
    
    m_pTIMEElementBase->InvalidateElement(NULL);

    InternalReset(true);
    
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:

    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    
    hr = S_OK;
done:
    return hr;
}

HRESULT 
CTIMEDshowPlayer::GetNaturalHeight(long *height)
{
    if (m_nativeVideoHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeVideoHeight;
    }
    
    return S_OK;
}

HRESULT 
CTIMEDshowPlayer::GetNaturalWidth(long *width)
{
    if (m_nativeVideoWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeVideoWidth;
    }

    return S_OK;
}

PlayerState
CTIMEDshowPlayer::GetState()
{
    PlayerState state;
    
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        if(!m_bMediaDone)
        {
            state = PLAYER_STATE_ACTIVE;
        }
        else
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}

STDMETHODIMP
CTIMEDshowPlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::Reset()
{
    return InternalReset(true);
}


HRESULT
CTIMEDshowPlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;
    long lseekFlags;

    if( m_pExSeeking == NULL)
    {
        bcanSeekToM = false;
        goto done;
    }

    hr = m_pExSeeking->get_ExSeekCapabilities(&lseekFlags);
    if(FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }
    if(lseekFlags & AM_EXSEEK_MARKERSEEK)
    {
        bcanSeekToM = true;
    }
    else
    {
        bcanSeekToM = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbVal;

    if(m_fMediaComplete == false)
    {
        bisBroad = false;
        goto done;
    }

    if( m_pIAMNetStat == NULL)
    {
        bisBroad = false;
        goto done;
    }

    hr = m_pIAMNetStat->get_IsBroadcast(&vbVal);
    if(FAILED(hr))
    {
        bisBroad = false;
        goto done;
    }
    if(vbVal)
    {
        bisBroad = true;
    }
    else
    {
        bisBroad = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDshowPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::HasAudio(bool &bHasAudio)
{

    if(m_pBasicAudio != NULL)
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pMS != NULL)
    {
        hr = m_pMS->GetRate(&dblRate);
    }

    return hr;
}


HRESULT
CTIMEDshowPlayer::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if((m_pMS != NULL) && (m_pIAMNetStat == NULL))
    {
        hr = m_pMS->SetRate(dblRate);
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::InternalEvent()
{
    m_fCanCueNow = true;

    Assert (NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->DataAvailable());
    
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;

    if (m_pIAMNetStat)
    {
        fIsStreamed = true;
    }
    else
    {
        fIsStreamed = false;
    }

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;
    long lbProg;

    if (!m_pIAMNetStat)
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    if (FAILED(m_pIAMNetStat->get_BufferingProgress( &lbProg)))
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    dblBufferingProgress = (double )lbProg;

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    bool fIsStreamed;

    if(FAILED(hr = GetIsStreamed(fIsStreamed)))
    {
        goto done;
    }

    if (fIsStreamed)
    {
        fHasDownloadProgress = false;
    }
    else
    {
        fHasDownloadProgress = true;
    }

    hr = S_OK;
done:
    return hr;
}

void
CTIMEDshowPlayer::Block()
{
    if(m_pProxy)
    {
        m_pProxy->Block();
    }
}

void
CTIMEDshowPlayer::UnBlock()
{
    if(m_pProxy)
    {
        m_pProxy->UnBlock();
    }
}

bool
CTIMEDshowPlayer::CanCallThrough()
{
    if(m_pProxy)
    {
        return m_pProxy->CanCallThrough();
    }
    else
    {
        return true;
    }
}

bool
CTIMEDshowPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    bool fRet = false;
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite == NULL)
    {
       goto done;
    }

    if(m_pProxy)
    {
        m_pProxy->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }
    else if(m_pPlaybackSite && (pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
    {
        pNativePlayer->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }

done:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdshow.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDSHOW_H
#define _PLAYERDSHOW_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>
#include "dshowproxy.h"

#include "importman.h"

#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEDshowPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEImportMedia,
    public ITIMEInternalEventSink,
    public IMixerOCXNotify
{
  public:
    CTIMEDshowPlayer(CTIMEDshowPlayerProxy * pProxy);
    virtual ~CTIMEDshowPlayer();

    HRESULT Init(CTIMEMediaElement *pelem,
                 LPOLESTR base,
                 LPOLESTR src,
                 LPOLESTR lpMimeType = NULL,
                 double dblClipBegin = -1.0,
                 double dblClipEnd = -1.0);//lint !e1735

  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();

    HRESULT BeginDownload();
    HRESULT GraphFinish();

    HRESULT ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR *pbstr);

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);

    BEGIN_COM_MAP(CTIMEDshowPlayer)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP();

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEInternalEventSink
    //
    STDMETHOD(InternalEvent)();
    
  protected:
    long    m_lSrc;
    bool m_fHasVideo;
    bool m_fDoneSetup;
    double m_dblSeekAtStart;
    bool m_fLoadError;
    bool m_fHasMedia;
    bool m_fRemoved;

  private:

    // IMixerOCXNotify methods
    STDMETHOD(OnInvalidateRect)(LPCRECT lpcRect);
    STDMETHOD(OnStatusChange)(ULONG ulStatusFlags);
    STDMETHOD(OnDataChange)(ULONG ulDataFlags);

    HRESULT SetMixerSize(RECT *prect);
    HRESULT SetUpHdc();

    void GraphStart(void);

    bool IsOvMConnected(IBaseFilter *pOvM);

    void SetStreamFlags(LPOLESTR src);
    HRESULT DisableAudioVideo();

    IMixerOCX *m_pIMixerOCX;
    DWORD m_nativeVideoWidth;
    DWORD m_nativeVideoHeight;
    DWORD m_displayVideoWidth;
    DWORD m_displayVideoHeight;

    LPSTREAM                    m_pTIMEMediaPlayerStream;

    bool m_fUsingInterfaces;
    bool m_fNeedToDeleteInterfaces;

    bool m_fCanCueNow;
    
    bool m_fHavePriority;
    double m_dblPriority;
    HRESULT m_hrRenderFileReturn;

    CTIMEDshowPlayerProxy * m_pProxy;
    CritSect                m_CriticalSection;
    
  private:
    CTIMEDshowPlayer();
};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdshowbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerdshowbase.h"
#include "mediaelm.h"
#include "decibels.h"
#include <mmreg.h>
#include "codec.h"
#include <inc\evcode.h>

DeclareTag(tagDshowBaseTimePlayer, "TIME: Media", "CTIMEDshowBasePlayer methods");
DeclareTag(tagDownloadCodec, "TIME: Media", "Download Codec");

#define SecsToNanoSecs 10000000

CTIMEDshowBasePlayer::CTIMEDshowBasePlayer() :
    m_fRunning(false),
    m_bActive(false),
    m_bMediaDone(false),
    m_fIsOutOfSync(false),
    m_pOvM(NULL),
    m_pMediaContent(NULL),
    m_cRef(0),
    m_pMC(NULL),
    m_pGB(NULL),
    m_pME(NULL),
    m_pMEx(NULL),
    m_pMP(NULL),
    m_pMS(NULL),
    m_pBasicAudio(NULL),
    m_fAudioMute(false),
    m_flVolumeSave(0.0),
    m_pwndMsgWindow(NULL),
    m_clsidDownloaded(GUID_NULL),
    m_hwndDocument(NULL),
    m_bIsHTMLSrc(false),
    m_bIsSAMISrc(false),
    m_fMediaComplete(false),
    m_fFiredComplete(false),
    m_dblSyncTime(0.0),
    m_syncType(sync_none),
    m_fSpeedIsNegative(false),
    m_pNativePlayer(NULL),
    m_fDetached(false)

{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::CTIMEDshowBasePlayer()",
              this));


}

CTIMEDshowBasePlayer::~CTIMEDshowBasePlayer()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::~CTIMEDshowBasePlayer()",
              this));
    m_pwndMsgWindow = NULL;
    m_hwndDocument = NULL;
}


STDMETHODIMP_(ULONG)
CTIMEDshowBasePlayer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEDshowBasePlayer::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }
    return l;
}

HRESULT
CTIMEDshowBasePlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    // Cache here since we cannot call it back during codec download
    m_hwndDocument = GetDocumentHwnd(pelem->GetDocument());

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::DetachFromHostElement)",
              this));

    m_hwndDocument = NULL;
    
    return hr;
}

void
CTIMEDshowBasePlayer::DeinitDshow()
{
    (void)::SetWindowLongPtr(m_pwndMsgWindow, GWLP_USERDATA, (LONG_PTR)NULL);
    (void)::PostMessage(m_pwndMsgWindow, WM_CLOSE, NULL, NULL);

    ReleaseSpecificInterfaces();
    ReleaseGenericInterfaces();
    FreeSpecificData();

}

HRESULT
CTIMEDshowBasePlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = BuildGraph();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetGenericInterfaces();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetSpecificInterfaces();
    if (FAILED(hr))
    {
        goto done;
    }


done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetGenericInterfaces()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::GetGenericInterfaces()",
              this));
    HRESULT hr = S_OK;
    CComPtr<IObjectWithSite> spSite;
    IUnknown *pSite;

    hr = m_pGB->QueryInterface(IID_IMediaControl, (void **)&m_pMC);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaEvent, (void **)&m_pME);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IAMOpenProgress, (void **)&m_pOP);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaEventEx, (void **)&m_pMEx);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaPosition, (void **)&m_pMP);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaSeeking, (void **)&m_pMS);
    if (FAILED(hr))
    {
        goto done;
    }
    if ( m_pMEx != NULL)
    {
        THR(m_pMEx -> SetNotifyWindow((OAHWND)m_pwndMsgWindow, WM_GRAPHNOTIFY, NULL));
    }

    hr = m_pGB->QueryInterface(IID_IObjectWithSite, (void **)&spSite);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = QueryInterface(IID_IUnknown, (void **)&pSite);
    if (FAILED(hr))
    {
        goto done;
    }

    if(pSite)
    {
        hr = spSite->SetSite(pSite);
        pSite->Release();
    }


done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::ReleaseGenericInterfaces()
{
    m_pBasicAudio = NULL;
    m_pMP = NULL;
    m_pMS = NULL;
    m_pOP = NULL;
    m_pMEx = NULL;
    m_pME = NULL;
    m_pGB = NULL;
    m_pMC = NULL;

    return S_OK;
}


HRESULT
CTIMEDshowBasePlayer::FindInterfaceOnGraph(IUnknown *pUnkGraph, REFIID riid, void **ppInterface)
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IBaseFilter> pFilter;
    CComPtr<IEnumFilters> pEnum;
    CComPtr<IFilterGraph> pFilterGraph;

    if (!ppInterface)
    {
        hr = E_FAIL;
        goto done;
    }
    *ppInterface= NULL;

    if (!pUnkGraph)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = pUnkGraph->QueryInterface(IID_IFilterGraph, (void **)&pFilterGraph);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pFilterGraph->EnumFilters(&pEnum);
    if (!pEnum)
    {
        goto done;
    }

    hr = E_NOINTERFACE;
    
    // find the first filter in the graph that supports riid interface
    while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(riid, ppInterface);
        pFilter.Release();
    }
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (NULL == pflVolume)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pBasicAudio != NULL)
    {
        if (m_fAudioMute == true)
        {
            *pflVolume = m_flVolumeSave;
            goto done;
        }

        hr = m_pBasicAudio->get_Volume(&lVolume);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflVolume = VolumeLogToLin(lVolume);
        
    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::SetVolume(float flVolume, bool bMute /*=false*/)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (flVolume < 0.0 || flVolume > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }

    // if muted, overwrite saved volume and exit
    if ((m_fAudioMute || m_bIsHTMLSrc || m_bIsSAMISrc) && !bMute) //if bMute == true then set the volume
    {
        m_flVolumeSave = flVolume;
        goto done;
    }
    
    lVolume = VolumeLinToLog(flVolume);

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Volume(lVolume));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::SetVolume(float flVolume)
{
    return SetVolume(flVolume, false);
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458
HRESULT
CTIMEDshowBasePlayer::GetBalance(float *pflBal)
{
    HRESULT hr = S_OK;
    long lBal;

    if (NULL == pflBal)
    {
        hr = E_POINTER;
        goto done;
    }


    if (m_pBasicAudio != NULL)
    {
        hr = m_pBasicAudio->get_Balance(&lBal);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflBal = BalanceLogToLin(lBal);
        
    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::SetBalance(float flBal)
{
    HRESULT hr = S_OK;
    long lBal = 0;

    if (flBal < 0.0 || flBal > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }
    lBal = BalanceLinToLog(fabs(flBal));

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Balance(lBal));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}
#endif

HRESULT
CTIMEDshowBasePlayer::GetMute(VARIANT_BOOL *pVarMute)
{
    HRESULT hr = S_OK;

    if (NULL == pVarMute)
    {
        hr = E_POINTER;
        goto done;
    }


    *pVarMute = m_fAudioMute?VARIANT_TRUE:VARIANT_FALSE;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    bool fMute = varMute?true:false;
    long lVolume;

    if (fMute == m_fAudioMute)
    {
        //need to call SetVolume again without caching the old volume
        //this is a fix for bug #6605.
        if (fMute == true)
        {
            hr = SetVolume(MIN_VOLUME_RANGE, true); 
        }
        goto done;
    }

    if (fMute == true)
    {
        hr = GetVolume(&m_flVolumeSave);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = SetVolume(MIN_VOLUME_RANGE, false); //lint !e747
    }
    else
    {
        //
        // cannot use SetVolume here because it depends on mute state
        //

        if (m_pBasicAudio == NULL)
        {
            hr = E_FAIL;
            goto done;
        }

        lVolume = VolumeLinToLog(m_flVolumeSave);

        THR(hr = m_pBasicAudio->put_Volume(lVolume));
    }

    // update state
    m_fAudioMute = fMute;

done:
    return hr;
}

#if DBG == 1
HRESULT
CTIMEDshowBasePlayer::getFilterTime(double &time)
{
    HRESULT hr = S_OK;
    REFTIME reftime;

    if (m_pMP != NULL)
    {
        hr = m_pMP->get_CurrentPosition(&reftime);
        time = reftime;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT
CTIMEDshowBasePlayer::getFilterState(int &state)
{
    HRESULT hr = S_OK;
    OAFilterState filtState;

    if (m_pMC != NULL)
    {
        hr = m_pMC->GetState(10, &filtState);
        if(FAILED(hr))
        {
            state = -1;
            goto done;
        }
        switch(filtState)
        {
            case State_Stopped:
                state = 0;
                break;
            case State_Running:
                state = 1;
                break;
            case State_Paused:
                state = 2;
                break;
            default:
                state = -1;
                break;
        }
    }
    else
    {

        hr = E_UNEXPECTED;
        state = -1;
    }

done:
    return hr;
}
#endif

HRESULT
CTIMEDshowBasePlayer::CreateMessageWindow()
{
    static const TCHAR szClassName[] = TEXT("CTIMEDshowBasePlayerWindow");
    HRESULT hr = S_OK;

    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);



    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpszClassName = szClassName;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = _Module.GetModuleInstance();

    (void)::RegisterClassEx(&wc);

    m_pwndMsgWindow = CreateWindow(
    szClassName,
    _T("VRCtlWindow"),
    0, 0, 0, 0, 0,
    (HWND)NULL, (HMENU)NULL,
    _Module.GetModuleInstance(),
    this);
    if ( m_pwndMsgWindow == NULL)
    {
        hr = E_FAIL;
    }

    return hr;
}

LRESULT CALLBACK
CTIMEDshowBasePlayer::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CTIMEDshowBasePlayer *lpThis;

    switch(uMsg)
    {
    case WM_CREATE:
        {
            TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowBasePlayer::OVMixerWindowProc::WM_CREATE"));
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpcs->lpCreateParams);
            return 0;
        }
    case WM_INVALIDATE:
        {
            //check GetWindowLongPtr for 64 bit comp.
            lpThis = (CTIMEDshowBasePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowBasePlayer(%lx)::OVMixerWindowProc::WM_INVALIDATE", lpThis));
            if (lpThis != NULL)
            {
                if (NULL != lpThis->m_pTIMEElementBase)
                {
                    lpThis->m_pTIMEElementBase->InvalidateElement(NULL);
                }
            }
            return 0;
        }
    case WM_GRAPHNOTIFY:
        {
            lpThis = (CTIMEDshowBasePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (lpThis != NULL)
            {
                if (NULL != lpThis->m_pTIMEElementBase)
                {
                    lpThis->ProcessGraphEvents();
                }
            }
            return 0;
        }
    case WM_CODECERROR:
        {
            lpThis = (CTIMEDshowBasePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (lpThis)
            {
                if (lpThis->m_pTIMEElementBase)
                {
                    lpThis->m_pTIMEElementBase->FireMediaEvent(PE_ONCODECERROR);
                }
            }
        }
    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

HRESULT
CTIMEDshowBasePlayer::UnableToRender(IPin *pPin)
{
    HRESULT hr;

    hr = THR(DownloadCodec(pPin));
    if (S_OK != hr)
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

//
// IServiceProvider interfaces
//
STDMETHODIMP
CTIMEDshowBasePlayer::QueryService(REFGUID guidService,
                                   REFIID riid,
                                   void** ppv)
{
    return E_NOINTERFACE;
}

//========================================================================
//
// GetAMediaType
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT GetAMediaType( IPin * ppin, CLSID & MajorType, CLSID & SubType)
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    /* Set defaults */
    MajorType = CLSID_NULL;
    SubType = CLSID_NULL;

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) {
        return hr;    // Dumb or broken filters don't get connected.
    }

    _ASSERTE (pEnumMediaTypes!=NULL);

    /* Put the first major type and sub type we see into the structure.
       Thereafter if we see a different major type or subtype then set
       the major type or sub type to CLSID_NULL, meaning "dunno".
       If we get so that both are dunno, then we might as well return (NYI).
    */

    BOOL bFirst = TRUE;

    for ( ; ; ) {

        AM_MEDIA_TYPE *pMediaType = NULL;
        ULONG ulMediaCount = 0;

        /* Retrieve the next media type
           Need to delete it when we've done.
        */
        hr = pEnumMediaTypes->Next(1, &pMediaType, &ulMediaCount);
        _ASSERTE(SUCCEEDED(hr));
        if (FAILED(hr)) {
            MajorType = CLSID_NULL;
            SubType = CLSID_NULL;
            pEnumMediaTypes->Release();
            return NOERROR;    // we can still plough on
        }

        if (ulMediaCount==0) {
            pEnumMediaTypes->Release();
            return NOERROR;       // normal return
        }

        if (bFirst) {
            MajorType = pMediaType[0].majortype;
            SubType = pMediaType[0].subtype;
            bFirst = FALSE;
        } else {
            if (SubType != pMediaType[0].subtype) {
                SubType = CLSID_NULL;
            }
            if (MajorType != pMediaType[0].majortype) {
                MajorType = CLSID_NULL;
            }
        }
        
        if (pMediaType->cbFormat != 0) {
            CoTaskMemFree(pMediaType->pbFormat);
        }
        CoTaskMemFree(pMediaType);

        // stop if we have a type
        if (SubType != CLSID_NULL) {
            pEnumMediaTypes->Release();
            return NOERROR;
        }
    }

    // NOTREACHED
    
} // GetAMediaType


// {6B6D0800-9ADA-11d0-A520-00A0D10129C0}
EXTERN_GUID(CLSID_NetShowSource, 
0x6b6d0800, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

EXTERN_GUID(CLSID_SourceStub, 
0x6b6d0803, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

HRESULT
CTIMEDshowBasePlayer::DownloadCodec(IPin * pPin)
{
    TraceTag((tagDownloadCodec,
              "CTIMEDshowBasePlayer(%p)::DownloadCodec()",
              pPin));

    HRESULT hr;
    DWORD dwVerLS = 0, dwVerMS = 0;
    CLSID clsidWanted;
    DAComPtr<IBindCtx> spBindCtx;
    DAComPtr<IBaseFilter> spFilter;
    DAComPtr<CDownloadCallback> spCallback;

    // Should we check a registry key to see if we are allowed to do this?
#if 0
    // Check registry setting to see if codec download is enabled
    CRegKey RegKey;
    DWORD dwNoCodecDwnL = 0;

    DWORD dwResult = RegKey.Open( HKEY_CURRENT_USER, gszPoliciesWMPPath, KEY_READ );
    if ( dwResult == ERROR_SUCCESS )
    {
        dwResult = RegKey.QueryValue( dwNoCodecDwnL, _T( "NoCodecDownload" ));
        if( dwResult == ERROR_SUCCESS )
        {
            if (dwNoCodecDwnL == 1)
            {
                RegKey.Close();
                return E_FAIL; // Don't download anything
            }
        }
        RegKey.Close();
    }
#endif
    
    {
        CLSID clsidMajor;
        // get the first media type from this pin....
        hr = THR(GetAMediaType(pPin, clsidMajor, clsidWanted));
        if (FAILED(hr))
        {
            goto codec_error;
        }
        
        if (clsidMajor == MEDIATYPE_LMRT)
        {
            TraceTag((tagDownloadCodec,
                      "CTIMEDshowBasePlayer(%p)::DownloadCodec(): auto-downloading known major type(LMRT)",
                      pPin));
            clsidWanted = clsidMajor;
        }
        else if (clsidMajor == CLSID_NetShowSource)
        {
            TraceTag((tagDownloadCodec,
                      "CTIMEDshowBasePlayer(%p)::DownloadCodec(): auto-downloading known major type(NetShowSource)",
                      pPin));
            clsidWanted = clsidMajor;
        }
        else if (clsidMajor != MEDIATYPE_Video &&
                 clsidMajor != MEDIATYPE_Audio &&
                 clsidMajor != CLSID_SourceStub) {
            TraceTag((tagDownloadCodec,
                      "CTIMEDshowBasePlayer(%p)::DownloadCodec(): auto-downloading only supported for audio and video",
                      pPin));
            hr = E_FAIL;
            goto codec_error;
        }
    }

    if (clsidWanted == MEDIASUBTYPE_MPEG1AudioPayload)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Hack: we know we don't want to download MPEG-1 audio, try layer 3",
                  pPin));
        
        clsidWanted.Data1 = WAVE_FORMAT_MPEGLAYER3;
    }

    if (clsidWanted == CLSID_NULL)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Couldn't guess a CLSID to try to download",
                  pPin));
        hr = E_FAIL;
        goto codec_error;
    }

    // !!! perhaps keep track of last codec we tried to download and
    // don't try again immediately, to prevent ugly looping?
    if (clsidWanted == m_clsidDownloaded)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Already thought we downloaded this codec!",
                  pPin));

#if 0
        // fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
        // any good?
        BSTR bstrError = FormatBSTR(IDS_ERR_BROKEN_CODEC, NULL);

        if (bstrError) {
            // !!! hack, should we really NotifyEvent through the graph?
            ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG_PTR) bstrError, FALSE);
        }
#endif
        
        hr = E_FAIL;
        goto codec_error;
    }
    
    {
        WCHAR guidstr[50];
        StringFromGUID2(clsidWanted, guidstr, 50);
        
        TCHAR szKeyName[60];
        
        wsprintf(szKeyName, TEXT("CLSID\\%ls"), guidstr);
        CRegKey crk;
        
        LONG    lr;
        lr = crk.Open(HKEY_CLASSES_ROOT, szKeyName, KEY_READ);
        if(ERROR_SUCCESS == lr)
        {
            crk.QueryValue(dwVerMS, _T("VerMS"));
            crk.QueryValue(dwVerLS, _T("VerLS"));
            
            // ask for a version just past what we have already....
            ++dwVerLS;
            
            crk.Close();
        }
    
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Trying to download GUID %ls",
                  pPin,
                  guidstr));
    }

#if 0
    SetStatusMessage(NULL, IDS_DOWNLOADINGCODEC);
#endif

    //  This API is our friend....
    //  STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
    //        LPCWSTR szCODE, DWORD dwFileVersionMS, 
    //        DWORD dwFileVersionLS, LPCWSTR szTYPE,
    //        LPBINDCTX pBindCtx, DWORD dwClsContext,
    //        LPVOID pvReserved, REFIID riid, LPVOID * ppv);

    // issue: is this CLASSID just the same as the minor type?

    {
        CComObject<CDownloadCallback> * pCallback;
        hr = THR(CComObject<CDownloadCallback>::CreateInstance(&pCallback));
        if (FAILED(hr))
        {
            goto done;
        }

        // This gives us a reference
        spCallback = pCallback;
    }
    
    spCallback->m_hwnd = m_hwndDocument;
    
    // which of these should we use?  Depends whether a BindCtx is passed in...
    // STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
    //                            IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
    // STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
    //                            IBindCtx **ppBC, DWORD reserved);                                                     

    hr = THR(CreateAsyncBindCtx(0, spCallback, NULL, &spBindCtx));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoGetClassObjectFromURL(clsidWanted, NULL, dwVerMS, dwVerLS, NULL,
                                     spBindCtx, CLSCTX_INPROC, NULL, IID_IBaseFilter,
                                     (void **) &spFilter));

    TraceTag((tagDownloadCodec,
              "CTIMEDshowBasePlayer(%p)::DownloadCodec(): CoGetClassObjectFromURL returned %hr",
              pPin,
              hr));

    if (hr == S_ASYNCHRONOUS)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): asynchronous download - wait for completion",
                  pPin));

        // !!! wait here until it finishes?
        for (;;)
        {
            HANDLE ev = spCallback->m_evFinished;

            if (ev == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
            
            DWORD dwResult = MsgWaitForMultipleObjects(1,
                                                       &ev,
                                                       FALSE,
                                                       INFINITE,
                                                       QS_ALLINPUT);
            if (dwResult == WAIT_OBJECT_0)
            {
                break;
            }
            
            Assert(dwResult == WAIT_OBJECT_0 + 1);
            //  Eat messages and go round again
            MSG Message;
            while (PeekMessage(&Message,NULL,0,0,PM_REMOVE))
            {
                if (Message.message == WM_QUIT)
                {
                    break;
                }
                
                TranslateMessage(&Message);
                DispatchMessage(&Message);
            }
        }
        
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Finished waiting.... m_pUnk is %x, hr = %hr",
                  pPin,
                  spCallback->m_pUnk,
                  spCallback->m_hrBinding));

        hr = spCallback->m_hrBinding;
        if (SUCCEEDED(hr))
        {
            spFilter.Release();
            hr = spCallback->m_pUnk->QueryInterface(IID_IBaseFilter, (void **) &spFilter);
        }
    }
    
    spCallback.Release();
    spBindCtx.Release();

    if (SUCCEEDED(hr))
    {
        spFilter.Release();     // graph will re-instantiate the filter, we hope
    }
    else
    {
        // oh well, we didn't get one.
    }

    if (REGDB_E_CLASSNOTREG == hr)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Hack: treating ClassNotReg as success, and hoping....",
                  pPin));
        hr = S_OK;
    }

    if (FAILED(hr))
    {
#if 0
        // fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
        // any good?
        BSTR bstrError = NULL;
        
        if( FACILITY_CERT == HRESULT_FACILITY( hr ) )
        {
            bstrError = FormatBSTR( IDS_ERR_CODEC_NOT_TRUSTED, NULL );
        }
        else
        {
            bstrError = FormatBSTR(IDS_ERR_NO_CODEC, NULL);
        }

        if (bstrError)
        {
            // !!! hack, should we really NotifyEvent through the graph?
            ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG_PTR) bstrError, FALSE);
        }
#endif

        goto done;
    }
    
    m_clsidDownloaded = clsidWanted; // avoid infinite loop

    hr = S_OK;
    goto done;

codec_error:
    ::PostMessage(m_pwndMsgWindow, WM_CODECERROR, NULL, NULL);

  done:
    RRETURN(hr);
}


HRESULT
CTIMEDshowBasePlayer::GetAvailableTime(double &dblEarliest, double &dblLatest)
{
    HRESULT hr = S_OK;

    LONGLONG learliest, llatest;

    if( m_pMS == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pMS->GetAvailable( &learliest, &llatest);
    if( FAILED(hr))
    {
        goto done;
    }

    dblEarliest = ((double )learliest) / SecsToNanoSecs;
    dblLatest = ((double) llatest) / SecsToNanoSecs;

done:
        return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetEarliestMediaTime(double &dblEarliestMediaTime)
{
    HRESULT hr = S_OK;

    double dblLatest;

    hr = GetAvailableTime( dblEarliestMediaTime, dblLatest);

    if(FAILED(hr))
    {
        dblEarliestMediaTime = -1.0;
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetLatestMediaTime(double &dblLatestMediaTime)
{
    HRESULT hr = S_OK;

    double dblEarliest;

    hr = GetAvailableTime( dblEarliest, dblLatestMediaTime);

    if(FAILED(hr))
    {
        dblLatestMediaTime = -1.0;
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetMinBufferedMediaDur(double &dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;

    dblMinBufferedMediaDur = -1.0;
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::SetMinBufferedMediaDur(double dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetDownloadTotal(LONGLONG &lldlTotal)
{
    HRESULT hr = S_OK;
    LONGLONG lldlCurrent;

    if(m_pOP == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(m_pOP->QueryProgress(&lldlTotal, &lldlCurrent)))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    HRESULT hr = S_OK;
    LONGLONG lldlTotal;

    if(m_pOP == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(m_pOP->QueryProgress(&lldlTotal, &lldlCurrent)))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GetMimeTypeFromGraph(BSTR *pmime)
{
    HRESULT hr = S_OK;
    CComPtr<IFileSourceFilter> spSourceFilter;
    LPOLESTR pFileName;
    AM_MEDIA_TYPE mediaType;
    bool fIsStreamed;
    bool fHasVideo;

    if(m_pGB == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IFileSourceFilter, (void **)&spSourceFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSourceFilter->GetCurFile (&pFileName, &mediaType);
    if (FAILED(hr))
    {
        goto done;
    }

    if (mediaType.subtype == MEDIATYPE_Midi)
    {
        // This is a MIDI format.
        *pmime = SysAllocString(L"audio/midi");
        hr = S_OK;
        goto done;
    }

    if(mediaType.majortype != MEDIATYPE_Stream)
    {
        // If not stream do not know
        // ISSIUE: asf source filters do not return the correct mediaType,
        // so we test for the asf filter by checking for streamed media.
        hr = GetIsStreamed(fIsStreamed);
        if(FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }
        hr = HasVisual(fHasVideo);
        if(FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }

        if(fIsStreamed)
        {
            //We have asf, now check for video or audio only.

            if (fHasVideo)
            {
                *pmime = SysAllocString(L"video/x-ms-asf");
            }
            else
            {
                *pmime = SysAllocString(L"audio/x-ms-asf");
            }

            goto done;
        }

        if (fHasVideo)
        {
            *pmime = SysAllocString(L"video/unknown");
        }
        else
        {
            *pmime = SysAllocString(L"audio/unknown");
        }

        hr = S_OK;
        goto done;
    }

    // majortype is stream, use subtypes to figure out MIME type.

    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_AIFF))
    {
        // set mime
        *pmime = SysAllocString(L"audio/aiff");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_Avi))
    {
        // set mime
        *pmime = SysAllocString(L"video/avi");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_Asf))
    {
        // set mime
        // ISSUE discriminate video and audio
        *pmime = SysAllocString(L"video/x-ms-asf");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_AU))
    {
        // set mime
        *pmime = SysAllocString(L"audio/au");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_DssAudio))
    {
        // set mime
        *pmime = SysAllocString(L"audio/dss");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_DssVideo))
    {
        // set mime
        *pmime = SysAllocString(L"video/dss");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1Audio))
    {
        // set mime
        *pmime = SysAllocString(L"audio/mpeg");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1System))
    {
        // set mime
        *pmime = SysAllocString(L"video/mpeg");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1Video))
    {
        // set mime
        *pmime = SysAllocString(L"video/mpeg");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1VideoCD))
    {
        // set mime
        *pmime = SysAllocString(L"video/dat");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_WAVE))
    {
        // set mime
        *pmime = SysAllocString(L"audio/wav");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_QTMovie))
    {
        // set mime
        *pmime = SysAllocString(L"video/quicktime");
        hr = S_OK;
        goto done;
    }

    hr = HasVisual(fHasVideo);
    if(FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    if (fHasVideo)
    {
        *pmime = SysAllocString(L"video/unknown");
    }
    else
    {
        *pmime = SysAllocString(L"audio/unknown");
    }

    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::InitElementDuration()
{
    HRESULT hr = S_OK;
    double mediaLength;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }
    if(m_pPlaybackSite)
    {
        // ISSUE this test is to check if we are a playitem. Need to 
        // refine the test.
        hr = S_OK;
        goto done;
    }

    hr = GetMediaLength( mediaLength);
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_dblClipEnd != valueNotSet)
    {
        if (m_dblClipEnd - GetClipBegin() == 0)
        {
            SetNaturalDuration(0.0);
        }
        else
        {
            SetNaturalDuration(m_dblClipEnd - GetClipBegin());
        }
    }
    else 
    {
        SetNaturalDuration(mediaLength - GetClipBegin());
    }

done:

    return hr;
}


HRESULT
CTIMEDshowBasePlayer::InternalReset(bool bSeek)
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;
    double dblMediaTime = 0.0;
    CTIMEPlayerNative *pNativePlayer;
    double dblOffset = 0.0;

    if(!CanCallThrough())
    {
        goto done;
    }

    if(m_fDetached)
    {
        goto done;
    }

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    if(m_pPlaybackSite)
    {
        if((pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
        {
            hr = pNativePlayer->GetPlayItemOffset(dblOffset);
            if(FAILED(hr))
            {
                dblOffset = 0.0;
            }
        }
    }


    bNeedActive = m_pTIMEElementBase->IsActive();
    bNeedPause = m_pTIMEElementBase->IsCurrPaused();
    //bIsLocked = m_pTIMEElementBase->IsLocked();
    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(!m_fMediaComplete)
    {
        TraceTag((tagError, "CTIMEDshowHWPlayer(%lx)(%x)::Reset",this));
        goto done;
    }

    TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowHWPlayer(%lx)(%x)::Reset",this));
    dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
    IGNORE_HR(m_pMP->get_CurrentPosition(&dblMediaTime));

    // make sure that this media can cue now
    IGNORE_HR(InternalEvent());
    
    if( !bNeedActive) // see if we need to stop the media.
    {
        // removed pause here
        m_dblSyncTime = 0.0;
        Pause();
        goto done;

    }
    m_dblSyncTime = GetCurrentTime();

    hr = GetRate(dblPlayerRate);
    if(SUCCEEDED(hr) && fHaveTESpeed)
    {
        if (flTeSpeed <= 0.0)
        {
            hr = S_OK;
            Pause();
            goto done;
        }
        if (dblPlayerRate != flTeSpeed)
        {
            IGNORE_HR(SetRate((double)flTeSpeed));
        }
    }

    dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime() - dblOffset;

    if( !m_bActive)
    {
        if (m_pIAMNetStat != NULL) //euristic to get asf's to start correctly.
        {
            Stop();
            IGNORE_HR(m_pMP->put_CurrentPosition( 0.0));
        }
        else if(dblMediaTime != dblSegTime && bSeek)
        {
            IGNORE_HR(THR(ForceSeek(dblSegTime))); //this does not seek asf's
        }
        InternalStart();
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        if(dblMediaTime != dblSegTime && bSeek)
        {
            IGNORE_HR(THR(Seek(dblSegTime))); //this does not seek asf's
        }
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        if(!m_fIsOutOfSync)
        {
            Pause();
        }
    }
    else
    {
        if( !m_fRunning)
        {
            Resume();
        }
    }
done:
    return hr;
}


void
CTIMEDshowBasePlayer::InternalStart()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::InternalStart()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        goto done;
    }

    GraphStart();
    
    m_fRunning = true;
    m_bActive = true;
    m_bMediaDone = false;
done:
    return;
}


HRESULT
CTIMEDshowBasePlayer::Seek(double dblTime)
{
    HRESULT hr = S_OK;
    double dblMediaLength = 0;
    double dblClipStart;

    if (m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = THR(GetEffectiveLength(dblMediaLength));
    if (FAILED(hr))
    {
        // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
        dblMediaLength = HUGE_VAL;
    }

    dblClipStart = GetClipBegin();
    //dblClipStart = 0;

    if (dblMediaLength > dblTime)
    {
        hr = m_pMP->put_CurrentPosition( dblTime + dblClipStart);
    }
    else
    {
        hr = THR(m_pMP->put_CurrentPosition(dblMediaLength - 0.33));
        m_bMediaDone = true;
    }

done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::ForceSeek(double dblTime)
{
    HRESULT hr = S_OK;
    double dblMediaLength = 0;
    double dblClipStart;

    if (m_pMP == NULL)
    {
        return E_FAIL;
    }
    if (m_pIAMNetStat != NULL) //never seek asf's.
    {
        if(dblTime != 0.0)
        {
            hr = S_OK;
            goto done;
        }
        Stop();
        IGNORE_HR(m_pMP->put_CurrentPosition( 0.0));
        InternalStart();
        hr = S_OK;
        goto done;
    }

    hr = THR(GetEffectiveLength(dblMediaLength));
    if (FAILED(hr))
    {
        // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
        dblMediaLength = HUGE_VAL;
    }

    dblClipStart = GetClipBegin();
    //dblClipStart = 0;

    if (dblMediaLength > dblTime)
    {
        hr = m_pMP->put_CurrentPosition( dblTime + dblClipStart);
    }
    else
    {
        hr = THR(m_pMP->put_CurrentPosition(dblMediaLength - 0.33));
        m_bMediaDone = true;
    }

done:
    return hr;
}

void
CTIMEDshowBasePlayer::Start()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    m_pTIMEElementBase->InvalidateElement(NULL);
    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEDshowBasePlayer::Stop()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Stop()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    if ((m_fMediaComplete == true) && !m_bMediaDone)
    {
        m_pMC->Stop();
    }

    m_fRunning = false;
    m_bActive = false;
    m_pTIMEElementBase->InvalidateElement(NULL);
}

void
CTIMEDshowBasePlayer::Pause()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Pause()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    if ((m_fMediaComplete == true) && !m_bMediaDone)
    {
        m_pMC->Pause();
    }
    m_fRunning = false;
}

void
CTIMEDshowBasePlayer::Resume()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Resume()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(m_fIsOutOfSync && m_syncType == sync_fast)
    {
        goto done;
    }

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    m_pTIMEElementBase->InvalidateElement(NULL);
    if( bIsActive && !bIsCurrPaused)
    {
        if ((m_fMediaComplete == true) && !m_bMediaDone)
        {
            m_pMC->Run();
        }
        m_fRunning = true;
        m_bActive = true;
    }

done:
    return;
}

void
CTIMEDshowBasePlayer::Repeat()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Resume()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }
    if (m_pIAMNetStat != NULL) //euristic to get asf's to repeat.
    {
        Stop();
        IGNORE_HR(m_pMP->put_CurrentPosition( 0.0));
        InternalStart();
    }
    else
    {
        Stop();
        IGNORE_HR(m_pMP->put_CurrentPosition( GetClipBegin()));
        InternalStart();
    }

}


double 
CTIMEDshowBasePlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;

    if (m_pMP == NULL)
    {
        return dblCurrentTime;
    }
    m_pMP -> get_CurrentPosition( &dblCurrentTime);
    dblCurrentTime -= GetClipBegin();
       
    return dblCurrentTime;
}

HRESULT
CTIMEDshowBasePlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (m_bMediaDone)
    {
        hr = S_FALSE;
        goto done;
    }

    if(m_pTIMEElementBase == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }

    if(!m_bActive || ((!CanCallThrough())))
    {
        TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowPlayer(%lx)::GetCurrentSyncTime::Not active(%f)",
            this,
            m_dblSyncTime));
        dblSyncTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }

    if(m_pMP != NULL)
    {
        m_pMP -> get_CurrentPosition( &dblSyncTime);
        dblSyncTime -= GetClipBegin();
    }
    else
    {
        hr = S_FALSE;
        goto done;
    }
    TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowPlayer(%lx)::GetCurrentSyncTime::Is active(%f)",
        this,
        dblSyncTime));

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CTIMEDshowBasePlayer::InternalEvent()
{
    return S_OK;
}

#define EC_FILE_CLOSED			    0x44

void
CTIMEDshowBasePlayer::ProcessGraphEvents()
{
    long lEventCode;
    LONG_PTR lParam1, lParam2;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if (NULL == m_pTIMEElementBase)
    {
        goto done;
    }

    while((m_pME != NULL) && (SUCCEEDED(m_pME->GetEvent(&lEventCode, &lParam1, &lParam2, 0) )))
    {
        TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowHWPlayer(%lx)(%x)::OVMixerWindowProc::WM_GRAPHNOTIFY",
            this, lEventCode));
        switch(lEventCode)
        {
        case EC_COMPLETE:
            {
                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_COMPLETE"));
                m_fRunning = false;
                m_bMediaDone = true;
                m_pTIMEElementBase->InvalidateElement(NULL);
                FireMediaEvent(PE_ONMEDIAEND);
                break;
            }
        case EC_PAUSED:
            {
                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_PAUSED"));
                if (m_fFiredComplete == true)
                {
                    break;
                }
                m_fFiredComplete = true;
                if(m_pMS)
                {
                    THR(m_pMS->SetTimeFormat(&frameFormat));
                }

                break;
            }
        case EC_OLE_EVENT:
            {

                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_OLE_EVENT:(%Ls)"));
                                
                if (StrCmpIW(L"sami", (BSTR)lParam1) == 0)
                {
                    if (m_bIsSAMISrc == true)
                    {
                        CComPtr <IHTMLElement> pEle = m_pTIMEElementBase->GetElement();
                        if (pEle != NULL)
                        {
                            IGNORE_HR(pEle->put_innerText((BSTR)lParam2));
                        }
                    }

                }
                else if (StrCmpIW(L"MediaBarTarget", (BSTR)lParam1) == 0)
                {
                    static LPWSTR pNames[] = {L"URL"};
                    VARIANTARG pvars[1];
                    pvars[0].vt = VT_BSTR;
                    pvars[0].bstrVal = (BSTR)lParam2;
                    IGNORE_HR(m_pTIMEElementBase->FireEvents(TE_ONMEDIABARTARGET, 
                                                             1, 
                                                             pNames, 
                                                             pvars));
                }
                else if (StrCmpIW(L"URL", (BSTR)lParam1) == 0)
                {
                    static LPWSTR pNames[] = {L"URL"};
                    VARIANTARG pvars[1];
                    pvars[0].vt = VT_BSTR;
                    pvars[0].bstrVal = (BSTR)lParam2;
                    IGNORE_HR(m_pTIMEElementBase->FireEvents(TE_ONURLFLIP, 
                                                             1, 
                                                             pNames, 
                                                             pvars));
                }
                else
                {
                    //TODO:  it looks like our existing content is not valid, how do we correct the content?
                    // currently if it isn't something else that is valid, it will be treated as an event.
                    static LPWSTR pNames[] = {L"Param", L"scType"};
                    VARIANTARG pvars[2];
                    pvars[1].vt = VT_BSTR;
                    pvars[1].bstrVal = (BSTR)lParam1;
                    pvars[0].vt = VT_BSTR;
                    pvars[0].bstrVal = (BSTR)lParam2;
                    IGNORE_HR(m_pTIMEElementBase->FireEvents(TE_ONSCRIPTCOMMAND, 
                                                        2, 
                                                        pNames, 
                                                        pvars));

                }


                break;
            }
        case EC_BUFFERING_DATA:
            {
                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_BUFFERING_DATA"));
                break;
            }
        case EC_FILE_CLOSED:
                m_fRunning = false;
                m_bMediaDone = true;
                FireMediaEvent(PE_ONMEDIAEND);
            break;
        default:
            TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_OTHER:(%x)", lEventCode));
            break;
        }
        if(m_pME != NULL)
        {
            m_pME->FreeEventParams(lEventCode, lParam1, lParam2);
        }
    }
done:
    return;
}

bool
CTIMEDshowBasePlayer::UpdateSync()
{
    double dblSyncTime;
    double dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bool bIsActive = m_pTIMEElementBase->IsActive();
    double dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
    bool fRet = true;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::UpdateSync()",
              this));

    if(m_pMP == NULL)
    {
        goto done;
    }

    m_pMP -> get_CurrentPosition( &dblSyncTime);
    dblSyncTime -= GetClipBegin();
    switch(m_syncType)
    {
        case sync_slow:
            TraceTag((tagDshowBaseTimePlayer,
                      "CTIMEDshowPlayer(%lx)::UpdateSync()slow",
                      this));
            if(!bIsActive || m_bMediaDone)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if(fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0 || (dblSyncTime > dblSimpleTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        case sync_fast:
            if(!bIsActive || m_bMediaDone)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if((fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0) || (dblSimpleTime > dblSyncTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        default:
            break;
    }
done:
    return fRet;
}

void
CTIMEDshowBasePlayer::PropChangeNotify(DWORD tePropType)
{
    double dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol;
    bool bIsActive;
    double dblSimpleTime;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bIsActive = m_pTIMEElementBase->IsActive();
    dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        TraceTag((tagDshowBaseTimePlayer,
                  "CTIMEDshowPlayer(%lx)::PropChangeNotify(%d):TE_PROPERTY_TIME",
                  this, m_fIsOutOfSync));
        if(m_pPlaybackSite)
        {
            // ISSUE this test is to check if we are a playitem. Need to 
            // refine the test.
            goto done;
        }

        if (!m_bMediaDone && bIsActive && !m_fIsOutOfSync && m_fMediaComplete)
        {   
            if(m_pMP != NULL)
            {
                m_pMP -> get_CurrentPosition( &dblSyncTime);
                dblSyncTime -= GetClipBegin();
                if(fabs(dblSyncTime - dblSimpleTime) > dblSyncTol)
                {
                    if(dblSyncTime < dblSimpleTime)
                    {
                        if(m_fRunning)
                        {
                            m_fIsOutOfSync = true;
                            FireMediaEvent(PE_ONMEDIASLIPSLOW);
                            m_syncType = sync_slow;
                        }
                    }
                    else
                    {
                        m_fIsOutOfSync = true;
                        FireMediaEvent(PE_ONMEDIASLIPFAST);
                        m_syncType = sync_fast;
                    }
                }
            }
        }

    }
    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        TraceTag((tagDshowBaseTimePlayer,
                  "CTIMEDshowPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_SPEED",
                  this));
        fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
        hr = GetRate(dblPlayerRate);
        if(SUCCEEDED(hr) && fHaveTESpeed)
        {
            if (flTeSpeed <= 0.0)
            {
                Pause();
                m_fSpeedIsNegative = true;
                goto done;
            } else if(!(m_pTIMEElementBase->IsCurrPaused()) && !m_fRunning && m_fSpeedIsNegative)
            {
                IGNORE_HR(THR(ForceSeek(dblSimpleTime)));
                if(m_pMC != NULL)
                {
                    m_pMC->Run();
                }
                m_fSpeedIsNegative = false;
            }

            if (dblPlayerRate != flTeSpeed)
            {
                IGNORE_HR(SetRate((double)flTeSpeed));
            }
        }
    }
  done:
    return;
}

void 
CTIMEDshowBasePlayer::FireMediaEvent(PLAYER_EVENT plEvent)
{
    CTIMEPlayerNative *pNativePlayer;

    if(!FireProxyEvent(plEvent))
    {
        m_pTIMEElementBase->FireMediaEvent(plEvent);
    }
}

void
CTIMEDshowBasePlayer::SetNaturalDuration(double dblMediaLength)
{
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite)
    {
        if((pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
        {
            pNativePlayer->SetNaturalDuration(dblMediaLength);
        }
        else
        {
            m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblMediaLength);
            m_pTIMEElementBase->setNaturalDuration();
        }
    }
    else
    {
            m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblMediaLength);
            m_pTIMEElementBase->setNaturalDuration();
    }
}

void
CTIMEDshowBasePlayer::ClearNaturalDuration()
{
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite)
    {
        if((pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
        {
            pNativePlayer->ClearNaturalDuration();
        }
        else
        {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
        m_pTIMEElementBase->clearNaturalDuration();
        }
    }
    else
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
        m_pTIMEElementBase->clearNaturalDuration();
    }
}

HRESULT
CTIMEDshowBasePlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;
    
    hr = GetMimeTypeFromGraph(pMime);
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::ConvertFrameToTime(LONGLONG iFrame, double &dblTime)
{
    HRESULT hr = S_OK;
    LONGLONG lTime;
    bool fHasVisual;
    LONGLONG ltBase = GetClipBegin() * SecsToNanoSecs;
    LONGLONG lfBase;

    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if(FAILED(HasVisual(fHasVisual)))
    {
        hr = E_FAIL;
        goto done;
    }

    if(!fHasVisual)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pMS == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));

    hr = m_pMS->ConvertTimeFormat(&lfBase, &frameFormat, ltBase, &mediaTimeFormat);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_pMS->ConvertTimeFormat(&lTime, &mediaTimeFormat, lfBase + iFrame, &frameFormat);
    if(FAILED(hr))
    {
        goto done;
    }

    dblTime = ((double )lTime) / SecsToNanoSecs;
    dblTime -= GetClipBegin();
    Assert(dblTime > 0);

done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GraphCue(void)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_NoPositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_NoPositioning;
    LONGLONG startFrame = m_lClipStartFrame;
    LONGLONG endFrame = m_lClipEndFrame;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::GraphCue()",
              this));
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if (m_dblClipEnd != valueNotSet)
    {
        endTime = (LONGLONG)(m_dblClipEnd * SecsToNanoSecs);
        endFlags = AM_SEEKING_AbsolutePositioning;
        m_lClipEndFrame = valueNotSet;
    }
    else if(m_lClipEndFrame != valueNotSet)
    {
        THR(hr = m_pMS->SetTimeFormat(&frameFormat));
        hr = m_pMS->ConvertTimeFormat(&endTime, &mediaTimeFormat, endFrame, &frameFormat);
        if(SUCCEEDED(hr))
        {
            endFlags = AM_SEEKING_AbsolutePositioning;
            m_dblClipEnd = ((double )endTime) / SecsToNanoSecs;
        }
        else
        {
            m_dblClipEnd = valueNotSet;
        }
    }

    if (m_pIAMNetStat == NULL)
    {
        if (m_dblClipStart != valueNotSet)
        {
            startTime = (LONGLONG)(m_dblClipStart * SecsToNanoSecs);
            startFlags = AM_SEEKING_AbsolutePositioning;
            m_lClipStartFrame = valueNotSet;
        }
        else if(m_lClipStartFrame != valueNotSet)
        {
            THR(hr = m_pMS->SetTimeFormat(&frameFormat));
            hr = m_pMS->ConvertTimeFormat(&startTime, &mediaTimeFormat, startFrame, &frameFormat);
            if(SUCCEEDED(hr))
            {
                startFlags = AM_SEEKING_AbsolutePositioning;
                m_dblClipStart = ((double )startTime) / SecsToNanoSecs;
            }
            else
            {
                m_dblClipStart = valueNotSet;
            }
        }
    }

    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    if ( startFlags != AM_SEEKING_NoPositioning || endFlags != AM_SEEKING_NoPositioning)
    {
        THR(hr = m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //removed run call here.

    hr = S_OK;
done:
    return hr;
}


void
CTIMEDshowBasePlayer::SetClipBeginFrame(long lClipBegin)
{
    LONGLONG startTime = 0;
    LONGLONG startFrame = 0;
    DWORD startFlags = AM_SEEKING_AbsolutePositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_NoPositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipBegin()",
              this));

    m_lClipStartFrame = lClipBegin;
    m_dblClipStart = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    startFrame = m_lClipStartFrame;
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    hr = m_pMS->ConvertTimeFormat(&startTime, &mediaTimeFormat, startFrame, &frameFormat);

    if (m_pIAMNetStat != NULL)
    {
        goto done;
    }

    m_dblClipStart = ((double )startTime) / SecsToNanoSecs;
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();

done:
    return;
} // putClipBegin

void 
CTIMEDshowBasePlayer::SetClipEndFrame(long lClipEnd)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_NoPositioning;
    LONGLONG endTime = 0;
    LONGLONG endFrame = m_lClipEndFrame;
    DWORD endFlags = AM_SEEKING_AbsolutePositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipEnd()",
              this));

    m_lClipEndFrame = lClipEnd;
    m_dblClipEnd = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    endFrame = m_lClipEndFrame;
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    hr = m_pMS->ConvertTimeFormat(&endTime, &mediaTimeFormat, endFrame, &frameFormat);

    m_dblClipEnd = ((double )endTime) / SecsToNanoSecs;
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();
done:
    return;
} // putClipEnd


void
CTIMEDshowBasePlayer::SetClipBegin(double dblClipBegin)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_AbsolutePositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_NoPositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipBegin()",
              this));

    m_dblClipStart = dblClipBegin;
    m_lClipStartFrame = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    if (m_pIAMNetStat == NULL)
    {
        startTime = (LONGLONG)(m_dblClipStart * SecsToNanoSecs);
    }
    else
    {
        goto done;
    }
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();

done:
    return;
} // putClipBegin

void 
CTIMEDshowBasePlayer::SetClipEnd(double dblClipEnd)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_NoPositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_AbsolutePositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipEnd()",
              this));

    m_dblClipEnd = dblClipEnd;
    m_lClipEndFrame = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    endTime = (LONGLONG)(m_dblClipEnd * SecsToNanoSecs);
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();
done:
    return;
} // putClipEnd

HRESULT
CTIMEDshowBasePlayer::GetCurrentFrame(LONGLONG &lFrameNr)
{
    HRESULT hr = S_OK;
    bool fHasVisual;
    LONGLONG lmediaTime;

    lFrameNr = -1;

    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if(FAILED(HasVisual(fHasVisual)))
    {
        hr = E_FAIL;
        goto done;
    }

    if(!fHasVisual)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pMS == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if(!m_fMediaComplete)
    {
        lFrameNr = -1;
        goto done;
    }


    hr = m_pMS->GetCurrentPosition(&lFrameNr);
    if(FAILED(hr))
    {
        lFrameNr = -1;
    }

done:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdvd.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDVD_H
#define _PLAYERDVD_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>



#define WM_DVDGRAPHNOTIFY (WM_USER + 1)

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEDVDPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEDispatchImpl<ITIMEDVDPlayerObject, &IID_ITIMEDVDPlayerObject>

{
  public:
    CTIMEDVDPlayer();
    virtual ~CTIMEDVDPlayer();

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    HRESULT InitElementDuration();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);


    STDMETHOD(upperButtonSelect)();
    STDMETHOD(lowerButtonSelect)();
    STDMETHOD(leftButtonSelect)();
    STDMETHOD(rightButtonSelect)();
    STDMETHOD(buttonActivate)();
    STDMETHOD(gotoMenu)();

    
    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);
    void SetCLSID(REFCLSID clsid);


    HRESULT Render(HDC hdc, LPRECT prc);
    HRESULT Reset();
    virtual void Tick();

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    double GetChapterTime();
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);

    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);
    virtual HRESULT GetMimeType(BSTR *pMime);

    virtual HRESULT CueMedia() { return E_NOTIMPL; }

    BEGIN_COM_MAP(CTIMEDVDPlayer)
        COM_INTERFACE_ENTRY(ITIMEDVDPlayerObject)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP();


  private:
    HRESULT SetUpDDraw();
    HRESULT SetUpWindow();
    HRESULT SetUpMainWindow();
    HRESULT SetUpVideoOffsets();
    void PropagateOffsets();

    void GraphStart(void);

    //dvd specific graph interfaces
    CComPtr<IDvdInfo> m_pDvdI;
    CComPtr<IDvdControl> m_pDvdC;
    CComPtr<IDvdGraphBuilder> m_pDvdGB;
    CComPtr<IDDrawExclModeVideo> m_pDDEX;

    CComPtr<IVideoWindow> m_pVW;
    HWND m_hWnd;
    LPDIRECTDRAW m_pDD; // ddraw object
    LPDIRECTDRAWSURFACE m_pDDS; // primary ddraw surface
    COLORREF m_clrKey;     // color key

    static LONG m_fDVDPlayer;

    RECT m_elementSize;
    long m_lPixelPosLeft;
    long m_lPixelPosTop;
    bool m_fHasVideo;
    bool m_fLoaded;
    double m_dblSeekAtStart;
    bool m_fAudioMute;
    float m_flVolumeSave;

    DWORD m_nativeVideoWidth;
    DWORD m_nativeVideoHeight;
    long m_lscrollOffsetx;
    long m_lscrollOffsety;
    RECT m_deskRect;
};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdshowtest.h ===
#if DBG == 1
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYERDSHOWTEST_H
#define _PLAYERDSHOWTEST_H

#include "playerdshow.h"
#include "TimeEng.h"
#include "MediaPrivate.h"

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

__declspec(selectany) const TCHAR *ResourceString = _T("2");
// This is needed for the template ITIMEDispatchImpl

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEDshowTestPlayer :
    public CTIMEDshowPlayer,
    public ITIMEDispatchImpl<ITIMEDshowTestPlayerObject, &IID_ITIMEDshowTestPlayerObject, ResourceString>
{
  public:
    CTIMEDshowTestPlayer();
    virtual ~CTIMEDshowTestPlayer();

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);


    BEGIN_COM_MAP(CTIMEDshowTestPlayer)
        COM_INTERFACE_ENTRY(ITIMEDshowTestPlayerObject)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP();

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd);
    STDMETHOD(CueMedia)();

    STDMETHOD(get_mediaTime)(double *time);
    STDMETHOD(get_mediaState)(int *state);
    STDMETHOD(pause)();
    STDMETHOD(resume)();
    STDMETHOD(get_mediaRate)(double *dblRate);
    STDMETHOD(put_mediaRate)(double dblRate);
    STDMETHOD(get_peerSyncFlag)(VARIANT_BOOL *flag);

    void Resume();
};

#endif /* _PLAYERDSHOWTEST_H */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdvd.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerdvd.h"
#include "mediaelm.h"
#include <inc\evcode.h>
#include <inc\dvdevcod.h>
#include <inc\mpconfig.h>
#include "decibels.h"

#include "ddrawex.h"

#define SecsToNanoSecs 10000000

#define OVLMixer L"Overlay Mixer"

LONG CTIMEDVDPlayer::m_fDVDPlayer = 0;

// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

GUID IID_IDDrawNonExclModeVideo = {
            0xec70205c,0x45a3,0x4400,{0xa3,0x65,0xc4,0x47,0x65,0x78,0x45,0xc7}};

DeclareTag(tagDVDTimePlayer, "TIME: Players", "CTIMEDVDPlayer methods");

CTIMEDVDPlayer::CTIMEDVDPlayer() :
    m_pDvdGB(NULL),
    m_pVW(NULL),
    m_pDvdI(NULL),
    m_pDvdC(NULL),
    m_pDDEX(NULL),
    m_pDDS(NULL),
    m_pDD(NULL),
    m_fHasVideo(false),
    m_fLoaded(false),
    m_dblSeekAtStart(0.0),
    m_nativeVideoWidth(0),
    m_nativeVideoHeight(0),
    m_fAudioMute(false),
    m_flVolumeSave(0.0),
    m_hWnd(0),
    m_lPixelPosLeft(0),
    m_lPixelPosTop(0),
    m_lscrollOffsetx(0),
    m_lscrollOffsety(0)

{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::CTIMEDVDPlayer()",
              this));

    m_clrKey = RGB(0x10, 0x00, 0x10);
    m_elementSize.bottom = 0;
    m_elementSize.left = 0;
    m_elementSize.top = 0;
    m_elementSize.right = 0;
    m_deskRect.bottom = 0;
    m_deskRect.left = 0;
    m_deskRect.top = 0;
    m_deskRect.right = 0;

}


CTIMEDVDPlayer::~CTIMEDVDPlayer()
{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::~CTIMEDVDPlayer()",
              this));
    //dvd specific interfaces
    m_pDvdC = NULL;
    m_pDvdI = NULL;
    m_pDDEX = NULL;
    m_pVW = NULL;

    ReleaseGenericInterfaces();

    m_pDvdGB = NULL;

    if (m_pDDS != NULL)
    {
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }

    m_hWnd = 0;
}

STDMETHODIMP_(ULONG)
CTIMEDVDPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDVDPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}


HRESULT
CTIMEDVDPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::Init)",
              this));
    HRESULT hr = S_OK;
    AM_DVD_RENDERSTATUS Status;
    IMixerPinConfig  *pMPC = NULL;
    LONG llock;

    m_pTIMEElementBase = pelem;

    CComPtr<IHTMLElement2> spElement2;

    if (m_fLoaded)
    {
        return hr;
    }
    llock = InterlockedExchange(&m_fDVDPlayer , 1);
    if(llock == 1)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = SetUpDDraw();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pDvdGB->RenderDvdVideoVolume(NULL, AM_DVD_HWDEC_PREFER, &Status);
    if (FAILED(hr))
    {
        goto done;
    }

    //hr = SetUpWindow();
    //if (FAILED(hr))
    //{
     //   goto done;
    //}
    hr = m_pDvdGB->GetDvdInterface(IID_IMixerPinConfig, (LPVOID *) &pMPC);

    if (SUCCEEDED(hr))
    {

        COLORKEY clr;
        clr.KeyType = CK_RGB ;
        clr.LowColorValue = m_clrKey;
        clr.HighColorValue = m_clrKey;

        hr = pMPC->SetColorKey(&clr);

        pMPC->Release() ;
    }

    hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
    hr = m_pDvdGB->GetDvdInterface(IID_IDvdControl, (LPVOID *)&m_pDvdC) ;
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDvdGB->GetDvdInterface(IID_IDvdInfo, (LPVOID *)&m_pDvdI) ;
    if (FAILED(hr))
    {
        goto done;
    }

    // tell OM layer to set volume and mute

    hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
    if (FAILED(hr))
    {
        // IE4 path
        CComPtr<IElementBehaviorSite> spElementBehaviorSite;
        spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();

        CComPtr<IObjectWithSite> spSite;
        // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
        hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
        if (FAILED(hr))
        {
            goto done;
        }

        CComPtr<IOleWindow> spOleWindow;
        // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
        hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEDVDPlayer::OnLoad - IE4 failure! unable to QI for IOleWindow on hosting Document"));
            goto done;
        }
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        goto done;
    }
    m_fMediaComplete = true;

    IGNORE_HR(this->InitElementDuration());

    m_pTIMEElementBase->InvalidateElement(NULL);
    FireMediaEvent(PE_ONMEDIACOMPLETE);

    InternalReset(true);

    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }
    m_fLoaded = true;

done:
    if (FAILED(hr))
    {
        if (m_pTIMEElementBase)
        {
            FireMediaEvent(PE_ONMEDIAERROR);;
        }
    }
    return hr;
}

HRESULT
CTIMEDVDPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::DetachFromHostElement)",
              this));

    InterlockedExchange(&m_fDVDPlayer , 0);

    DeinitDshow();

    return hr;
}

void
CTIMEDVDPlayer::ReleaseSpecificInterfaces()
{
    m_pDvdC = NULL;
    m_pDvdI = NULL;
    m_pDDEX = NULL;
    m_pVW = NULL;
}

void
CTIMEDVDPlayer::FreeSpecificData()
{
    m_pDvdGB = NULL;

    if (m_pDDS != NULL)
    {
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }
}

void
CTIMEDVDPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDVDPlayer::SetUpMainWindow()
{
    CComPtr<IHTMLElement> pHTMLElem = m_pTIMEElementBase->GetElement();
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IDispatch> pDisp;
    CComPtr<IOleWindow> pOleWindow;
    HRESULT hr = S_OK;

    hr = pHTMLElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pOleWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pOleWindow->GetWindow(&m_hWnd);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::BuildGraph()
{
    HRESULT hr = S_OK;

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_DvdGraphBuilder, NULL, CLSCTX_INPROC,
        IID_IDvdGraphBuilder, (LPVOID *)&m_pDvdGB);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDvdGB->GetFiltergraph(&m_pGB);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = SetUpMainWindow();
    if (FAILED(hr))
    {
        goto done;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;
done:
    return hr;
}


HRESULT
CTIMEDVDPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

HRESULT
CTIMEDVDPlayer::InitElementSize()
{
    DWORD aspectX, aspectY;
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    if( m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    m_pDDEX->GetNativeVideoProps(&m_nativeVideoWidth, &m_nativeVideoHeight, &aspectX, &aspectY);

    if (m_nativeVideoWidth != 0 || m_nativeVideoHeight != 0)
    {
        m_fHasVideo = true;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeVideoWidth;
    nativeSize.bottom = m_nativeVideoHeight;

    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);

    m_elementSize.right = elementSize.right;
    m_elementSize.bottom = elementSize.bottom;

    PropagateOffsets();

done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::InitElementDuration()
{
    HRESULT hr = S_OK;
    double mediaLength;

    hr = THR(GetMediaLength( mediaLength));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pTIMEElementBase->GetMMBvr().PutNaturalDur(mediaLength));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pTIMEElementBase->setNaturalDuration();
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;

    return hr;
}


HRESULT
CTIMEDVDPlayer::SetUpWindow()
{
    HRESULT hr = S_OK;

    hr = m_pMC->QueryInterface(IID_IVideoWindow, (void **)&m_pVW);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pVW->put_Owner((OAHWND)m_hWnd);
    if (FAILED(hr))
    {
        goto done;
    }
    m_pVW->put_WindowStyle(WS_CHILD);
    if (FAILED(hr))
    {
        goto done;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetUpDDraw()
{

    HRESULT hr = E_UNEXPECTED;

    if (m_pDD != NULL)
    {
        // see if we went through this already
        return(hr);
    }

    hr = DirectDrawCreate(NULL, &m_pDD, NULL);
    //hr = m_pTIMEElementBase->GetServiceProvider()->QueryService(SID_SDirectDraw3, IID_TO_PPV(IDirectDraw, &m_pDD));
    if (FAILED(hr))
    {
        goto done;
    }

    if (FAILED(hr))
    {

        return(hr);
    }

    hr = m_pDD->SetCooperativeLevel(m_hWnd, DDSCL_NORMAL); //lint !e620

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    DDSURFACEDESC ddsd;
    ::ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);

    ddsd.dwFlags = DDSD_CAPS; //lint !e620
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; //lint !e620

    hr = m_pDD->CreateSurface(&ddsd, &m_pDDS, NULL);

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    LPDIRECTDRAWCLIPPER pClipper; // clipper for our ddraw object

    hr = m_pDD->CreateClipper(0, &pClipper, NULL);

    if (FAILED(hr))
    {

        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }/* end of if statement */

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    hr = pClipper->SetHWnd(0, m_hWnd);

    if (FAILED(hr))
    {

        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }


        if (pClipper != NULL)
        {
            pClipper->Release();
            pClipper = NULL;
        }

        return(hr);
    }


    hr = m_pDDS->SetClipper(pClipper);

    if (FAILED(hr))
    {
        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        if (pClipper != NULL)
        {
            pClipper->Release();
            pClipper = NULL;
        }

        return(hr);
        }

    pClipper->Release();
    hr = m_pDvdGB->GetDvdInterface(IID_IDDrawExclModeVideo, (LPVOID *)&m_pDDEX);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawObject(m_pDD);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawSurface(m_pDDS);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return(hr);
}/* end of function SetupDDraw */

void
CTIMEDVDPlayer::OnTick(double dblSegmentTime,
                       LONG lCurrRepeatCount)
{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

void
CTIMEDVDPlayer::SetCLSID(REFCLSID clsid)
{
}

void
CTIMEDVDPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;

    if(m_pMC == NULL)
    {
        goto done;
    }

    hr = m_pMC->Run();
    if (FAILED(hr))
    {
        if (m_pTIMEElementBase)
        {
            FireMediaEvent(PE_ONMEDIAERROR);
        }
    }
done:
    return;
}

HRESULT
CTIMEDVDPlayer::SetUpVideoOffsets()
{
    CComPtr<IDispatch> pDisp;
    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLElement> pBody;
    CComPtr<IHTMLElement> pElem;
    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLWindow2> pWin2;
    CComPtr<IHTMLWindow4> pWin4;
    CComPtr<IHTMLFrameBase> pFrameBase;
    CComPtr<IHTMLElement> pFrameElem;
    long lscrollOffsetyc = 0, lscrollOffsetxc = 0, lPixelPosTopc = 0, lPixelPosLeftc = 0;

    HRESULT hr = S_OK;

    if(m_pTIMEElementBase == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    m_lscrollOffsety = m_lscrollOffsetx = m_lPixelPosTop = m_lPixelPosLeft = 0;

    hr = THR(m_pTIMEElementBase->GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDoc->get_body(&pBody);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientWidth(&(m_elementSize.right));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientHeight(&(m_elementSize.bottom));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = WalkUpTree(m_pTIMEElementBase->GetElement(), lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = pDoc->get_parentWindow(&pWin2);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWin2->QueryInterface(IID_IHTMLWindow4, (void **)&pWin4));
    if (FAILED(hr) || pWin4 == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pWin4->get_frameElement(&pFrameBase);
    if (FAILED(hr) || pFrameBase == NULL)
    {
        goto done;
    }

    hr = THR(pFrameBase->QueryInterface(IID_IHTMLElement, (void **)&pFrameElem));
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(WalkUpTree(pFrameElem, lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc));

done:
    m_lscrollOffsety = lscrollOffsetyc;
    m_lscrollOffsetx = lscrollOffsetxc;
    m_lPixelPosTop = lPixelPosTopc;
    m_lPixelPosLeft = lPixelPosLeftc;

    return hr;
}

void
CTIMEDVDPlayer::PropagateOffsets()
{
    RECT localRect;
    RECT videoRect;
    HRESULT hr;

    videoRect.top = 0;
    videoRect.left = 0;
    videoRect.right = 10000;
    videoRect.bottom = 10000;

    if(m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    localRect.top = m_lPixelPosTop - m_lscrollOffsety;
    localRect.left = m_lPixelPosLeft - m_lscrollOffsetx;
    localRect.bottom = localRect.top + m_elementSize.bottom;
    localRect.right = localRect.left + m_elementSize.right;
    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&localRect, 2);

    if((localRect.bottom == m_deskRect.bottom) &&
        (localRect.top == m_deskRect.top) &&
        (localRect.left == m_deskRect.left) &&
        (localRect.right == m_deskRect.right))
    {
        goto done;
    }

    GetRelativeVideoClipBox(localRect, m_elementSize, videoRect, 10000);

    m_deskRect = localRect;

    THR(m_pDDEX->SetDrawParameters(&videoRect, &localRect));
done:
    return;
}


void
CTIMEDVDPlayer::Tick()
{
    bool bIsOn = false;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bIsOn = m_pTIMEElementBase->IsOn();

    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer(%lx)(%x)::Tick",this));
    PropagateOffsets();

done:
    return;
}


HRESULT
CTIMEDVDPlayer::Render(HDC hdc, LPRECT prc)
{
    HBRUSH hbr = ::CreateSolidBrush(m_clrKey);

    bool bIsOn = false;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bIsOn = m_pTIMEElementBase->IsOn();
    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    if (hbr && bIsOn)
    {
        ::FillRect(hdc, prc, hbr);
    }

done:
    if(hbr != NULL)
    {
        ::DeleteObject(hbr);
    }
    return S_OK;
}


// Helper functions..

double
CTIMEDVDPlayer::GetChapterTime()
{
    double dblCurrentTime = 0;
    HRESULT hr = S_OK;
    DVD_PLAYBACK_LOCATION pDVDLocation;
    DVD_TIMECODE *pDVDTime;

    hr = m_pDvdI->GetCurrentLocation(&pDVDLocation);
    if (FAILED(hr))
    {
        goto done;
    }

    pDVDTime = (DVD_TIMECODE *)(&pDVDLocation.TimeCode);
    dblCurrentTime = pDVDTime->Seconds1 + 10 * pDVDTime->Seconds10;
    dblCurrentTime += 60 * pDVDTime->Minutes1 + 600 * pDVDTime->Minutes10;
    dblCurrentTime += 3600 * pDVDTime->Hours1 + 36000 * pDVDTime->Hours10;
done:
    return dblCurrentTime;
}

HRESULT
CTIMEDVDPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;
    RECT rc;
    RECT videoRect;

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    Assert(prect != NULL);

    m_elementSize.right = prect->right;
    m_elementSize.bottom = prect->bottom;
    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    rc.top = m_lPixelPosTop - m_lscrollOffsety;
    rc.left = m_lPixelPosLeft - m_lscrollOffsetx;
    rc.bottom = rc.top + prect->bottom;
    rc.right = rc.left + prect->right;

    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&rc, 2);

    GetRelativeVideoClipBox(rc, m_elementSize, videoRect, 10000);

    hr = m_pDDEX->SetDrawParameters(&videoRect, &rc);

done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = m_pMP->get_Duration(&dblLength);
    return hr;
}


HRESULT
CTIMEDVDPlayer::CanSeek(bool &fcanSeek)
{
    LONG canSeek;
    HRESULT hr = S_OK;

    if(m_pMP == NULL)
    {
        fcanSeek = false;
        goto done;
    }

    hr = m_pMP->CanSeekBackward(&canSeek);
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }
    if (canSeek == 0)
    {
        fcanSeek = false;
        goto done;
    }
    hr = m_pMP->CanSeekForward(&canSeek);
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }
    if (canSeek == 0)
    {
        fcanSeek = false;
        goto done;
    }
    fcanSeek = true;
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;


    return hr;
}

HRESULT
CTIMEDVDPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;


    return hr;
}

HRESULT
CTIMEDVDPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT
CTIMEDVDPlayer::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (NULL == pflVolume)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pBasicAudio == NULL)
    {
        if(m_pDvdGB != NULL)
        {
            hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&m_pBasicAudio);
            if (FAILED(hr))
            {
                m_pBasicAudio = NULL;
            }
        }
    }
    if (m_pBasicAudio != NULL)
    {
        if (m_fAudioMute == true)
        {
            *pflVolume = m_flVolumeSave;
            goto done;
        }

        hr = m_pBasicAudio->get_Volume(&lVolume);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflVolume = VolumeLogToLin(lVolume);

    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}


HRESULT
CTIMEDVDPlayer::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;
    long lVolume = -10000;

    if (flVolume < 0.0 || flVolume > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }
    lVolume = VolumeLinToLog(flVolume);

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Volume(lVolume));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458
HRESULT
CTIMEDVDPlayer::GetBalance(float *pflBal)
{
    HRESULT hr = S_OK;
    long lBal;

    if (NULL == pflBal)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pBasicAudio == NULL)
    {
        hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&m_pBasicAudio);
        if (FAILED(hr))
        {
            m_pBasicAudio = NULL;
        }
    }

    if (m_pBasicAudio != NULL)
    {
        hr = m_pBasicAudio->get_Balance(&lBal);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflBal = BalanceLogToLin(lBal);

    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetBalance(float flBal)
{
    HRESULT hr = S_OK;
    long lBal = 0;

    if (flBal < 0.0 || flBal > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }
    lBal = BalanceLinToLog(fabs(flBal));

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Balance(lBal));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}
#endif

HRESULT
CTIMEDVDPlayer::GetMute(VARIANT_BOOL *pVarMute)
{
    HRESULT hr = S_OK;

    if (NULL == pVarMute)
    {
        hr = E_POINTER;
        goto done;
    }


    *pVarMute = m_fAudioMute?VARIANT_TRUE:VARIANT_FALSE;
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    bool fMute = varMute?true:false;

    if (fMute == m_fAudioMute)
    {
        hr = S_OK;
        goto done;
    }

    if (fMute == true)
    {
        hr = GetVolume(&m_flVolumeSave);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = SetVolume(MIN_VOLUME_RANGE); //lint !e747
    }
    else
    {
        hr = SetVolume(m_flVolumeSave);
    }
    m_fAudioMute = fMute;
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::upperButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::upperButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->UpperButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::lowerButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::lowerButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->LowerButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::leftButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::leftButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->LeftButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::rightButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::rightButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->RightButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::buttonActivate()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::activateButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->ButtonActivate();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::gotoMenu()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::gotoMenu"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->MenuCall(DVD_MENU_Root);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::gotoMenu::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;
    hr = this->QueryInterface(IID_IDispatch, (void **)ppDisp);

    return hr;
}

HRESULT
CTIMEDVDPlayer::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;


    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bNeedActive = m_pTIMEElementBase->IsActive();
    bNeedPause = m_pTIMEElementBase->IsCurrPaused();

    if( !bNeedActive) // see if we need to stop the media.
    {
        Stop();
        goto done;

    }

    if( !m_bActive)
    {
        InternalStart();
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        if(!m_fIsOutOfSync)
        {
            Pause();
        }
    }
    else
    {
        if( !m_fRunning)
        {
            Resume();
        }
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDVDPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDVDPlayer::HasAudio(bool &bHasAudio)
{

    bHasAudio = true; // ISSUE DSHOW because audio interface not present for DVD always return true.
    return S_OK;
}

HRESULT
CTIMEDVDPlayer::GetNaturalHeight(long *height)
{
    if (m_nativeVideoHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeVideoHeight;
    }

    return S_OK;
}

HRESULT
CTIMEDVDPlayer::GetNaturalWidth(long *width)
{
    if (m_nativeVideoWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeVideoWidth;
    }

    return S_OK;
}

void
CTIMEDVDPlayer::Block()
{
    return;
}

void
CTIMEDVDPlayer::UnBlock()
{
    return;
}

bool
CTIMEDVDPlayer::CanCallThrough()
{
    return true;
}


bool
CTIMEDVDPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    return false;
}


HRESULT
CTIMEDVDPlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;

    *pMime = SysAllocString(L"video/DVD");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerhwdshow.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "playerhwdshow.h"
#include "mediaelm.h"
#include <wininet.h>
#include <inc\evcode.h>
#include "tags\bodyelm.h"
#include <inc\mpconfig.h>
#include <ddraw.h>
#include <ddrawex.h>

class
__declspec(uuid("22d6f312-b0f6-11d0-94ab-0080c74c7e95"))
MediaPlayerCLSID {};

#define SecsToNanoSecs 10000000
#define UnitOverlayStretchRatio 1000

#define OVLMixer L"Overlay Mixer"

#define SOUND_OF_SILENCE -10000
// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowTimeHWPlayer, "TIME: Players", "CTIMEDshowHWPlayer methods");

CTIMEDshowHWPlayer::CTIMEDshowHWPlayer(CTIMEDshowHWPlayerProxy * pProxy) :
  m_fHasVideo(false),
  m_fDoneSetup(false),
  m_pIMixerOCX(NULL),
  m_dblSeekAtStart(0.0),
  m_nativeVideoWidth(0),
  m_nativeVideoHeight(0),
  m_displayVideoWidth(0),
  m_displayVideoHeight(0),
  m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
  m_pTIMEMediaPlayerStream(NULL),
  m_fRemoved(false),
  m_fNeedToDeleteInterfaces(false),
  m_fUsingInterfaces(false),
  m_fLoadError(false),
  m_fHasMedia(false),
  m_dblPriority(INFINITE),
  m_fCanCueNow(false),
  m_fHavePriority(false),
  m_lPixelPosLeft(0),
  m_lPixelPosTop(0),
  m_lscrollOffsetx(0),
  m_lscrollOffsety(0),
  m_hrRenderFileReturn(S_OK),
  m_pProxy(pProxy),
  m_pDD(NULL),
  m_pDDS(NULL),
  m_pClipper(NULL),
  m_hWnd(NULL),
  m_bIsHTMLSrc(false),
  m_bIsSAMISrc(false)
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::CTIMEDshowHWPlayer()",
              this));

    if (IsPalettizedDisplay())
    {
        m_clrKey = RGB(0xff, 0x00, 0xff);
    }
    else
    {
        m_clrKey = RGB(0x10, 0x00, 0x10);
    }
    m_elementSize.bottom = 0;
    m_elementSize.left = 0;
    m_elementSize.top = 0;
    m_elementSize.right = 0;
    m_deskRect.bottom = 0;
    m_deskRect.left = 0;
    m_deskRect.top = 0;
    m_deskRect.right = 0;

}


CTIMEDshowHWPlayer::~CTIMEDshowHWPlayer()
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::~CTIMEDshowHWPlayer()",
              this));

    if(m_pClipper != NULL)
    {
        m_pClipper->SetClipList(NULL, 0);
        m_pClipper->Release();
        m_pClipper = NULL;
    }

    if (m_pDDS != NULL)
    {
        m_pDDS->SetClipper(NULL);
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }

    m_pMediaContent = NULL;
    m_pIMixerOCX = NULL;
    m_pOvM = NULL;

    ReleaseGenericInterfaces();

    ReleaseInterface(m_pTIMEMediaPlayerStream);

    delete m_pProxy;
}

STDMETHODIMP_(ULONG)
CTIMEDshowHWPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDshowHWPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}

HRESULT
CTIMEDshowHWPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::Init)",
              this));
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;
    CComPtr<IUnknown> spDirectDraw;
    CComPtr<IDirectDraw> spDD;
    DDCAPS ddCaps;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    ZeroMemory(&ddCaps, sizeof(DDCAPS));
    ddCaps.dwSize = sizeof(DDCAPS);

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;


    hr = m_pTIMEElementBase->GetServiceProvider()->QueryService(SID_SDirectDraw3, IID_TO_PPV(IUnknown, &spDirectDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDirectDraw->QueryInterface(IID_IDirectDraw, (void**)&spDD);
    if (SUCCEEDED(hr))
    {
        hr = spDD->GetCaps(&ddCaps, NULL);
        if(SUCCEEDED(hr))
        {
            if (!(ddCaps.dwCaps & DDCAPS_OVERLAY)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKX)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKY)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHX)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHY)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if(ddCaps.dwMinOverlayStretch > 0)
            {
                hr = E_FAIL;
                goto done;
            }

        }
    }
    
    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }
    if (src == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(NULL != GetImportManager());

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }

    ClearNaturalDuration();

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    Assert(NULL != m_pTIMEElementBase->GetBody());
    hr = m_pTIMEElementBase->GetBody()->AddInternalEventSink(this, 0.0);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
        delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::DetachFromHostElement)",
              this));

    if(m_fDetached)
    {
        goto done;
    }

    m_fRemoved = true;
    m_fDetached = true;

    if  (m_spOpenProgress)
    {
        m_spOpenProgress->AbortOperation();
        m_spOpenProgress = NULL;
    }

    Assert(NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    CTIMEDshowBasePlayer::DetachFromHostElement();

    {
        CritSectGrabber cs(m_CriticalSection);
        if (false == m_fUsingInterfaces)
        {
            DeinitDshow();
        }
        else
        {
            m_fNeedToDeleteInterfaces = true;
        }
    }
    
    if (NULL != m_pTIMEElementBase->GetBody())
    {
        IGNORE_HR(m_pTIMEElementBase->GetBody()->RemoveInternalEventSink(this));
    }
    
    m_pTIMEElementBase = NULL;
    NullAtomTable();
done:
    return hr;
}

void
CTIMEDshowHWPlayer::ReleaseSpecificInterfaces()
{
    m_pMediaContent = NULL;
    if (m_pIMixerOCX != NULL)
    {
        // why not release here?
        // m_pIMixerOCX.Release();
        m_pIMixerOCX = NULL;
    }

    if(m_pDDEX != NULL)
    {
        IGNORE_HR(m_pDDEX->SetDDrawObject(NULL));
        IGNORE_HR(m_pDDEX->SetDDrawSurface(NULL));   
        m_pDDEX.Release();
        m_pDDEX = NULL;
    }

    if(m_pClipper != NULL)
    {
        m_pClipper->SetClipList(NULL, 0);
        IGNORE_HR(m_pClipper->SetHWnd(0, NULL));
        m_pClipper->Release();
        m_pClipper = NULL;
    }

    if (m_pDDS != NULL)
    {
        m_pDDS->SetClipper(NULL);
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }
}

void
CTIMEDshowHWPlayer::FreeSpecificData()
{

}

void
CTIMEDshowHWPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDshowHWPlayer::BuildGraph()
{
    HRESULT hr = S_OK;

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                          NULL,
                          CLSCTX_INPROC_SERVER, //lint !e655
                          IID_IGraphBuilder,
                          (void **)&m_pGB);
    // dshow not installed
    if (hr == REGDB_E_CLASSNOTREG)
    {
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                              NULL,
                              CLSCTX_INPROC_SERVER, //lint !e655
                              IID_IGraphBuilder,
                              (void **)&m_pGB);
    }
    if (FAILED(hr))
    {
        goto done;
    }
    hr = SetUpMainWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(m_pGB->QueryInterface(IID_TO_PPV(IAMOpenProgress, &m_spOpenProgress)));
    
done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;
    if (m_pOvM == NULL)
    {
        hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        // dshow not installed
        if (hr == REGDB_E_CLASSNOTREG)
        {
            CComPtr<IUnknown> pObj;
            hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                                  IID_IUnknown,
                                  (void **)&pObj));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        }
        if (FAILED(hr) || m_pOvM == NULL)
        {
            goto done;
        }
    }

    hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    if (hr == E_NOINTERFACE)
    {
        // dshow dll is there, but its not properly registered
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            m_pOvM.Release();
            goto done;
        }

        hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    }
    if (FAILED(hr) || m_pIMixerOCX == NULL)
    {
        m_pOvM.Release();
        goto done;
    }

    hr = m_pGB->AddFilter(m_pOvM, OVLMixer);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = SetUpDDraw(m_pIMixerOCX);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fMediaComplete = false;
done:
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

class CSimplePB : public IMediaPropertyBag
{
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) { return E_NOINTERFACE; }
    STDMETHOD_(ULONG, AddRef)(THIS) { return 0; }
    STDMETHOD_(ULONG, Release)(THIS) { return 0; }
        
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) { return E_NOTIMPL; }
    STDMETHOD(EnumProperty) (ULONG iProperty, VARIANT *pvarName, VARIANT *pvarVal) { return E_NOTIMPL; } 
        
    LPCOLESTR m_pLookFor;
    BSTR *m_pbstrOut;

    STDMETHOD(Write) (LPCOLESTR pszPropName, VARIANT *pVar)
    {
        if (0 == wcscmp(m_pLookFor, pszPropName))
        {
            if (pVar->vt != VT_BSTR)
            {
                return E_NOTIMPL;
            }

            *m_pbstrOut = SysAllocString(pVar->bstrVal);
            if (NULL == m_pbstrOut)
            {
                return E_FAIL;
            }
        }

        return S_OK;
    }

    public:    
    CSimplePB() :
        m_pbstrOut(NULL), m_pLookFor(NULL) {}
    CSimplePB(LPCOLESTR pLookFor, BSTR *pbstrOut) :
        m_pbstrOut(pbstrOut), m_pLookFor(pLookFor) {}
};



HRESULT
CTIMEDshowHWPlayer::ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR * pbstr)
{
    IPersistMediaPropertyBag *pPMPB = NULL;
    if (S_OK == FindInterfaceOnGraph(pGraph, IID_IPersistMediaPropertyBag,
                                     (void **) &pPMPB))
    {
        CSimplePB pb(lpcwstrTag, pbstr);

        pPMPB->Save(&pb, FALSE, FALSE);

        pPMPB->Release();
    }

    return *pbstr ? S_OK : E_FAIL;
}

HRESULT
CTIMEDshowHWPlayer::SetUpHdc()
{
    HRESULT hr = S_OK;

    if (IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pIMixerOCX->GetVideoSize(&m_nativeVideoWidth, &m_nativeVideoHeight);
        if (FAILED(hr))
        {
            goto done;
        }

        m_fHasVideo = true;
    }
    else //if we only have audio: native size is 0 0
    {
        m_nativeVideoWidth = 0;
        m_nativeVideoHeight = 0;
    }
    m_fDoneSetup = true;
done:

    return hr;
}

HRESULT
CTIMEDshowHWPlayer::InitElementSize()
{
    DWORD aspectX, aspectY;
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }
    
    if( m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    m_pDDEX->GetNativeVideoProps(&m_nativeVideoWidth, &m_nativeVideoHeight, &aspectX, &aspectY);

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeVideoWidth;
    nativeSize.bottom = m_nativeVideoHeight;
    
    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);

    m_elementSize.right = elementSize.right;
    m_elementSize.bottom = elementSize.bottom;

    PropagateOffsets();

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{   
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::SetSrc()\n",
              this));
    
    LPOLESTR szSrc = NULL;
    HRESULT hr = S_OK;

    //create and initialize the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    DeinitDshow();
    m_fLoadError = false;
    if (src == NULL)
    {
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }


    if (!InternetCrackUrlW(szSrc, lstrlenW(szSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        SetStreamFlags(URLComp.lpszExtraInfo);

        lpszPath = NEW OLECHAR [URLComp.dwUrlPathLength + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        StrCpyNW(lpszPath, URLComp.lpszUrlPath, URLComp.dwUrlPathLength + 1);
        lpszPath[URLComp.dwUrlPathLength] = 0;

        hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        delete [] lpszPath;
        lpszPath = NULL;
    }
    else
    {
        hr = THR(m_pGB->RenderFile(szSrc, NULL));
    }
    if (FAILED(hr)) // this fall through catches media load failed errors from either call to RenderFile above.
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        goto done;
    }


    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }


    //InitElementDuration();
    hr = m_pMC->Run();
    if (FAILED(hr))
    {
        goto done;
    } 

    if (m_fRunning == false)
    {
        Pause();
    }
    else
    {
        Resume();
    }

    ClearNaturalDuration();

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }
    delete[] szSrc;
    
    return hr;

}

STDMETHODIMP
CTIMEDshowHWPlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = m_fCanCueNow ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::CueMedia()
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::CueMedia()",
              this));
    HRESULT hr = S_OK;

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;
    CComPtr<IStream> spStream;
    
    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pProxy);

    {
        CritSectGrabber cs(m_CriticalSection);

        m_fUsingInterfaces = true;
    }

    Block();
    
    IGNORE_HR(BeginDownload());

    UnBlock();
    
    hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    {
        CritSectGrabber cs(m_CriticalSection);

        if (m_fNeedToDeleteInterfaces)
        {
            DeinitDshow();
            m_fNeedToDeleteInterfaces = false;
        }

        m_fUsingInterfaces = false;
    }
    return hr;
}


STDMETHODIMP
CTIMEDshowHWPlayer::MediaDownloadError()
{
    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::BeginDownload()
{
    HRESULT hr = S_OK;

    const WCHAR * cpchSrc = NULL;
    WCHAR * beckified = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if(GetAtomTable() == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pGB == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        long l = 0;
        lpszPath = NEW OLECHAR [lstrlenW(cpchSrc) + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }   
        l = lstrlenW(cpchSrc);
        StrCpyNW(lpszPath, cpchSrc, l - URLComp.dwExtraInfoLength + 1);            
        lpszPath[l - URLComp.dwExtraInfoLength + 1] = 0;
        //StrCpyNW(lpszPath, URLComp.lpszUrlPath, lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength);            
        //lpszPath[lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength] = 0;

        if (m_pGB == NULL)
        {
            hr = E_FAIL;
            goto done;
        }
// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL(lpszPath);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        }
        delete [] lpszPath;
        lpszPath = NULL;

        SetStreamFlags(URLComp.lpszExtraInfo);
    }
    else
    {
        if (m_pGB == NULL)
        {
            hr = E_FAIL;
            goto done;
        }
// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL((WCHAR *)cpchSrc);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(cpchSrc, NULL));
        }
    }

    if (FAILED(hr))
    {
        // this fall through catches media load 
        // failed errors from either call to RenderFile above.
        m_hrRenderFileReturn = hr;
    }

    hr = S_OK;
done:

    delete[] beckified;
    RRETURN(hr);
}

HRESULT
CTIMEDshowHWPlayer::GraphFinish()
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx::GraphFinish()",
              this));

    HRESULT hr = S_OK;
    
    CComPtr<IHTMLElement2> spElement2;
    CComPtr<IMixerPinConfig> pMPC;
    CComPtr<IPin> pPin;
    CComPtr<IFilterGraph> spFG;
    CComPtr<IBaseFilter> spBF;

    if (FAILED(m_hrRenderFileReturn))     
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        hr = m_hrRenderFileReturn;
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    hr = m_pOvM->FindPin(L"Input0", &pPin);
    if (SUCCEEDED(hr))
    {
        pPin->QueryInterface(IID_IMixerPinConfig, (LPVOID *) &pMPC);
        if (SUCCEEDED(hr))
        {
            COLORKEY clr;
            clr.KeyType = CK_RGB ;
            clr.LowColorValue = m_clrKey;
            clr.HighColorValue = m_clrKey;

            hr = pMPC->SetColorKey(&clr);
            if(FAILED(hr))
            {
                FireMediaEvent(PE_ONMEDIAERRORCOLORKEY);
                goto done;
            }
            hr = pMPC->SetAspectRatioMode(AM_ARMODE_STRETCHED);
        }
    }


    hr = m_pGB->QueryInterface(IID_IFilterGraph, (void **)&spFG);
    if(SUCCEEDED(hr))
    {
        hr = spFG->FindFilterByName(L"Video Renderer", &spBF);
        if(SUCCEEDED(hr))
        {
            FireMediaEvent(PE_ONMEDIAERRORCOLORKEY);
            goto done;
        }

    }

    if (!IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pGB->RemoveFilter(m_pOvM);
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
     //can be used m_pIAMNetShowConfig->put_BufferingTime(1.0);
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetShowConfig,  (void **) &m_pIAMNetShowConfig);
    if (FAILED(hr))
    {
        m_pIAMNetShowConfig = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMExtendedSeeking, (void **) &m_pExSeeking);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetworkStatus, (void **) &m_pIAMNetStat);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GraphCue();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
        if (FAILED(hr))
        {
            // IE4 path
            CComPtr<IElementBehaviorSite> spElementBehaviorSite;
            spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();
            
            CComPtr<IObjectWithSite> spSite;
            // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
            hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
            if (FAILED(hr))
            {
                goto done;
            }
            
            CComPtr<IOleWindow> spOleWindow;
            // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
            hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEDshowHWPlayer::Init - IE4 failure! unable to QI for IOleWindow on hosting Document"));
                goto done;
            }
        }
    }

done:
    return hr;
}

//
// CTIMEDshowHWPlayer::IsOvMConnected(): Private method to detect if the video stream 
// is passing through the Overlay Mixer (i.e, is it connected?).
//
bool
CTIMEDshowHWPlayer::IsOvMConnected(IBaseFilter *pOvM)
{    
    IEnumPins   *pEnumPins;
    IPin        *pPin;
    IPin        *pPin2;
    ULONG        ul;
    HRESULT      hr;
    bool         bConnected = false;

    pOvM->EnumPins(&pEnumPins);
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul && bConnected == false)
    {
        hr = pPin->ConnectedTo(&pPin2);
        if (SUCCEEDED(hr) && pPin2)
        {
            bConnected = true;
            pPin2->Release();
        }
        pPin->Release();
    }
    pEnumPins->Release();
    
    return bConnected;
}

void
CTIMEDshowHWPlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}


void
CTIMEDshowHWPlayer::SetCLSID(REFCLSID clsid) 
{
}

void
CTIMEDshowHWPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::GraphStart()",
              this));

    m_fLoadError = false;

    if (m_fMediaComplete == false)
    {
        goto done;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        FireMediaEvent(PE_ONMEDIAERRORCOLORKEY);
        goto done;
    }

  done: 

    return;
}
    
HRESULT
CTIMEDshowHWPlayer::Render(HDC hdc, LPRECT prc)
{
    HBRUSH hbr = ::CreateSolidBrush(m_clrKey);

    bool bIsOn;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }
        
    bIsOn = m_pTIMEElementBase->IsOn();

    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    if (hbr)
    {
        ::FillRect(hdc, prc, hbr);
    }

done:
    if(hbr != NULL)
    {
        ::DeleteObject(hbr);
    }
    return S_OK;
}


// Helper functions..


HRESULT
CTIMEDshowHWPlayer::SetMixerSize(RECT *prect)
{
    HRESULT hr = S_OK;
    POINT pt;

    if (m_pIMixerOCX == NULL)
    {
        return S_OK;
    }
    pt.x = pt.y = 0;
    hr = m_pIMixerOCX->SetDrawRegion(&pt, prect, prect);

    return hr;
}

HRESULT
CTIMEDshowHWPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;
    RECT rc;
    RECT videoRect;

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    Assert(prect != NULL);

    m_elementSize.right = prect->right;
    m_elementSize.bottom = prect->bottom;
    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    rc.top = m_lPixelPosTop - m_lscrollOffsety;
    rc.left = m_lPixelPosLeft - m_lscrollOffsetx;
    rc.bottom = rc.top + prect->bottom;
    rc.right = rc.left + prect->right;

    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&rc, 2);

    GetRelativeVideoClipBox(rc, m_elementSize, videoRect, 10000);

    hr = m_pDDEX->SetDrawParameters(&videoRect, &rc);

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = m_pMP->get_Duration(&dblLength);
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    LONG canSeek;
    long seekFlags = 0;

    if (m_pExSeeking == NULL)
    {
        if (!m_pMP)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekBackward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekForward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        fcanSeek = true;
    }
    else
    {
        hr = m_pExSeeking->get_ExSeekCapabilities( &seekFlags);
        if (SUCCEEDED(hr)) 
        {
            if( seekFlags & AM_EXSEEK_CANSEEK)
            {
                fcanSeek = true;
                goto done;
            }
        }
        hr = S_OK;
        fcanSeek = false;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    if (NULL != pAuthor)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_AuthorName(pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/IART", pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    if (NULL != pTitle)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Title(pTitle);
            if (FAILED(hr))
            {
                *pTitle = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/INAM", pTitle);
            if (FAILED(hr))
            {
                hr = ReadContentProperty(m_pGB, L"INFO/ISBJ", pTitle);
                if (FAILED(hr))
                {
                    *pTitle = NULL;
                }
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    if (NULL != pCopyright)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Copyright(pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/ICOP", pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }
    }
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrAbstract)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Description(pBstrAbstract);
            if (FAILED(hr))
            {
                *pBstrAbstract = NULL;
            }
        }
        else
        {
            *pBstrAbstract = NULL;
        }
    }
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrRating)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Rating(pBstrRating);
            if (FAILED(hr))
            {
                *pBstrRating = NULL;
            }
        }
        else
        {
            *pBstrRating = NULL;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
void  
CTIMEDshowHWPlayer::SetStreamFlags(LPOLESTR src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    
    m_bIsSAMISrc = false;
    m_bIsHTMLSrc = false;

    len = lstrlenW(src);
    if (len >= HTMLSTREAMSRCLEN)
    {
        memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));
    
        if (StrCmpIW(stream, HTMLSTREAMSRC) == 0)
        {
            m_bIsHTMLSrc = true;
        }
        if (StrCmpIW(stream, SAMISTREAMSRC) == 0)
        {
            m_bIsSAMISrc = true;
        }
    
    }
}

HRESULT
CTIMEDshowHWPlayer::DisableAudioVideo()
{
    HRESULT hr = E_FAIL;

    CComPtr<IBaseFilter> pMediaFilter;
    CComPtr<IPin> pPin;
    CComPtr<IEnumPins> pMediaPinEnum;
    
    //disconnect the video
    if (m_pMediaContent == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = m_pMediaContent->QueryInterface(IID_IBaseFilter, (void **)&pMediaFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMediaFilter->EnumPins(&pMediaPinEnum);
    if (!pMediaPinEnum)
    {
        goto done;
    }
    while(pMediaPinEnum->Next(1, &pPin, NULL) == S_OK)
    {
        if (pPin != NULL)
        {
            IGNORE_HR(pPin->Disconnect());
        }
    }
    
    //silence the audio
    if (m_pBasicAudio != NULL)
    {
        hr = THR(m_pBasicAudio->put_Volume(SOUND_OF_SILENCE));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP
CTIMEDshowHWPlayer::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimeHWPlayer, "CTIMEDshowHWPlayer(%lx)(%x)::InitializeElementAfterDownload",this));

    const WCHAR * cpchSrc = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if (m_fRemoved)
    {
        hr = E_FAIL;
        m_pMC->Stop();
        goto done;
    }
    
    hr = this->GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    m_fMediaComplete = true;

    FireMediaEvent(PE_ONMEDIACOMPLETE);
    
    IGNORE_HR(this->InitElementDuration());
    
    m_pTIMEElementBase->InvalidateElement(NULL);

    InternalReset(true);

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:

    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    
    hr = S_OK;
done:
    return hr;
}

HRESULT 
CTIMEDshowHWPlayer::GetNaturalHeight(long *height)
{
    if (m_nativeVideoHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeVideoHeight;
    }
    
    return S_OK;
}

HRESULT 
CTIMEDshowHWPlayer::GetNaturalWidth(long *width)
{
    if (m_nativeVideoWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeVideoWidth;
    }

    return S_OK;
}

PlayerState
CTIMEDshowHWPlayer::GetState()
{
    PlayerState state;
    
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        if(!m_bMediaDone)
        {
            state = PLAYER_STATE_ACTIVE;
        }
        else
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}

STDMETHODIMP
CTIMEDshowHWPlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::Reset()
{
    return InternalReset(true);
}

HRESULT
CTIMEDshowHWPlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;
    long lseekFlags;

    if( m_pExSeeking == NULL)
    {
        bcanSeekToM = false;
        goto done;
    }

    hr = m_pExSeeking->get_ExSeekCapabilities(&lseekFlags);
    if(FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }
    if(lseekFlags & AM_EXSEEK_MARKERSEEK)
    {
        bcanSeekToM = true;
    }
    else
    {
        bcanSeekToM = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbVal;

    if(m_fMediaComplete == false)
    {
        bisBroad = false;
        goto done;
    }

    if( m_pIAMNetStat == NULL)
    {
        bisBroad = false;
        goto done;
    }

    hr = m_pIAMNetStat->get_IsBroadcast(&vbVal);
    if(FAILED(hr))
    {
        bisBroad = false;
        goto done;
    }
    if(vbVal)
    {
        bisBroad = true;
    }
    else
    {
        bisBroad = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::HasAudio(bool &bHasAudio)
{

    if(m_pBasicAudio != NULL)
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }
    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pMS != NULL)
    {
        hr = m_pMS->GetRate(&dblRate);
    }

    return hr;
}


HRESULT
CTIMEDshowHWPlayer::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if((m_pMS != NULL) && (m_pIAMNetStat == NULL))
    {
        hr = m_pMS->SetRate(dblRate);
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::InternalEvent()
{
    m_fCanCueNow = true;

    Assert (NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->DataAvailable());
    
    return S_OK;
}


HRESULT
CTIMEDshowHWPlayer::SetUpMainWindow()
{
    CComPtr<IHTMLElement> pHTMLElem = m_pTIMEElementBase->GetElement();
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IDispatch> pDisp;
    CComPtr<IOleWindow> pOleWindow;
    HRESULT hr = S_OK;

    hr = pHTMLElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pOleWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pOleWindow->GetWindow(&m_hWnd);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::SetUpDDraw(IMixerOCX *pIMixerOCX)
{

    HRESULT hr = E_UNEXPECTED;
    
    if (m_pDD != NULL)
    {
        // see if we went through this already
        return(hr); 
    }

    hr = DirectDrawCreate(NULL, &m_pDD, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = m_pDD->SetCooperativeLevel(m_hWnd, DDSCL_NORMAL); //lint !e620

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    DDSURFACEDESC ddsd;
    ::ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);

    ddsd.dwFlags = DDSD_CAPS; //lint !e620
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; //lint !e620

    hr = m_pDD->CreateSurface(&ddsd, &m_pDDS, NULL);

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }


    hr = m_pDD->CreateClipper(0, &m_pClipper, NULL);

    if (FAILED(hr))
    {

        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }/* end of if statement */

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    hr = m_pClipper->SetHWnd(0, m_hWnd);

    if (FAILED(hr))
    {
        if(m_pClipper != NULL)
        {
            m_pClipper->SetClipList(NULL, 0);
            m_pClipper->Release();
            m_pClipper = NULL;
        }

        if (m_pDDS != NULL)
        {
            m_pDDS->SetClipper(NULL);
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }


    hr = m_pDDS->SetClipper(m_pClipper);

    if (FAILED(hr))
    {
        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        if (m_pClipper != NULL)
        {
            m_pClipper->Release();
            m_pClipper = NULL;
        }

        return(hr);
    }


    hr = pIMixerOCX->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *)&m_pDDEX);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawObject(m_pDD);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawSurface(m_pDDS);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return(hr);
}/* end of function SetupDDraw */


HRESULT
CTIMEDshowHWPlayer::SetUpVideoOffsets()
{
    CComPtr<IDispatch> pDisp;
    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLElement> pBody;
    CComPtr<IHTMLElement> pElem;
    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLWindow2> pWin2;
    CComPtr<IHTMLWindow4> pWin4;
    CComPtr<IHTMLFrameBase> pFrameBase;
    CComPtr<IHTMLElement> pFrameElem;
    long lscrollOffsetyc = 0, lscrollOffsetxc = 0, lPixelPosTopc = 0, lPixelPosLeftc = 0;

    HRESULT hr = S_OK;
    m_lscrollOffsety = m_lscrollOffsetx = m_lPixelPosTop = m_lPixelPosLeft = 0;

    hr = THR(m_pTIMEElementBase->GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDoc->get_body(&pBody);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientWidth(&(m_elementSize.right));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientHeight(&(m_elementSize.bottom));
    if (FAILED(hr))
    {
        goto done;
    }


    hr = WalkUpTree(m_pTIMEElementBase->GetElement(), lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = pDoc->get_parentWindow(&pWin2);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWin2->QueryInterface(IID_IHTMLWindow4, (void **)&pWin4));
    if (FAILED(hr) || pWin4 == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pWin4->get_frameElement(&pFrameBase);
    if (FAILED(hr) || pFrameBase == NULL)
    {
        goto done;
    }

    hr = THR(pFrameBase->QueryInterface(IID_IHTMLElement, (void **)&pFrameElem));
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(WalkUpTree(pFrameElem, lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc));

done:
    m_lscrollOffsety = lscrollOffsetyc;
    m_lscrollOffsetx = lscrollOffsetxc;
    m_lPixelPosTop = lPixelPosTopc;
    m_lPixelPosLeft = lPixelPosLeftc;

    return hr;
}

void
CTIMEDshowHWPlayer::PropagateOffsets()
{
    RECT localRect;
    RECT videoRect;
    HRESULT hr;

    videoRect.top = 0;
    videoRect.left = 0;
    videoRect.right = 10000;
    videoRect.bottom = 10000;

    if(m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    localRect.top = m_lPixelPosTop - m_lscrollOffsety;
    localRect.left = m_lPixelPosLeft - m_lscrollOffsetx;
    localRect.bottom = localRect.top + m_elementSize.bottom;
    localRect.right = localRect.left + m_elementSize.right;
    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&localRect, 2);

    if((localRect.bottom == m_deskRect.bottom) &&
        (localRect.top == m_deskRect.top) &&
        (localRect.left == m_deskRect.left) &&
        (localRect.right == m_deskRect.right))
    {
        goto done;
    }

    GetRelativeVideoClipBox(localRect, m_elementSize, videoRect, 10000);

    m_deskRect = localRect;

    THR(m_pDDEX->SetDrawParameters(&videoRect, &localRect));
done:
    return;
}


void
CTIMEDshowHWPlayer::Tick()
{
    bool bIsOn = m_pTIMEElementBase->IsOn();

    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    TraceTag((tagDshowTimeHWPlayer, "CTIMEDshowHWPlayer(%lx)(%x)::Tick",this));
    PropagateOffsets();

done:
    return;
}


HRESULT
CTIMEDshowHWPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;

    if (m_pIAMNetStat)
    {
        fIsStreamed = true;
    }
    else
    {
        fIsStreamed = false;
    }

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;
    long lbProg;

    if (!m_pIAMNetStat)
    {
        hr = E_FAIL;
        dblBufferingProgress = 0.0;
        goto done;
    }

    if (FAILED(m_pIAMNetStat->get_BufferingProgress( &lbProg)))
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    dblBufferingProgress = (double )lbProg;

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    bool fIsStreamed;

    if(FAILED(hr = GetIsStreamed(fIsStreamed)))
    {
        goto done;
    }

    if (fIsStreamed)
    {
        fHasDownloadProgress = false;
    }
    else
    {
        fHasDownloadProgress = true;
    }

    hr = S_OK;
done:
    return hr;
}

void
CTIMEDshowHWPlayer::Block()
{
    if(m_pProxy)
    {
        m_pProxy->Block();
    }
}

void
CTIMEDshowHWPlayer::UnBlock()
{
    if(m_pProxy)
    {
        m_pProxy->UnBlock();
    }
}

bool
CTIMEDshowHWPlayer::CanCallThrough()
{
    if(m_pProxy)
    {
        return m_pProxy->CanCallThrough();
    }
    else
    {
        return false;
    }
}

bool
CTIMEDshowHWPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    bool fRet = false;
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite == NULL)
    {
       goto done;
    }
    
    if(m_pProxy)
    {
        m_pProxy->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }
    else if(m_pPlaybackSite && (pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
    {
        pNativePlayer->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }

done:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdshowbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDSHOWBASE_H
#define _PLAYERDSHOWBASE_H

#include "playerbase.h"
#include "playernative.h"
#include <strmif.h>
#include <uuids.h>
#include <control.h>
#include <strmif.h>
#include <inc\qnetwork.h>

#define WM_INVALIDATE (WM_USER + 0)
#define WM_GRAPHNOTIFY (WM_USER + 1)
#define WM_CODECERROR (WM_USER + 2)

class CTIMEMediaElement;

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
EXTERN_GUID(IID_IAMFilterGraphCallback,0x56a868fd,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);

interface IAMFilterGraphCallback : public IUnknown
{
    // S_OK means rendering complete, S_FALSE means "retry now".
    virtual HRESULT UnableToRender(IPin *pPin) = 0;

    // other methods?
};

class CTIMEDshowBasePlayer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CTIMEBasePlayer,
    public IAMFilterGraphCallback,
    public IServiceProvider
{
  public:
    CTIMEDshowBasePlayer();
    virtual ~CTIMEDshowBasePlayer();
    HRESULT Init(CTIMEMediaElement *pelem,
                 LPOLESTR base,
                 LPOLESTR src,
                 LPOLESTR lpMimeType,
                 double dblClipBegin,
                 double dblClipEnd);

    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void SetClipEnd(double dblClipEnd);

  protected:
    HRESULT InitDshow();
    void DeinitDshow();
    virtual HRESULT BuildGraph() = 0;
    virtual HRESULT GetSpecificInterfaces() = 0;
    virtual void ReleaseSpecificInterfaces() = 0;
    virtual void FreeSpecificData() = 0;
    HRESULT GetGenericInterfaces();
    HRESULT ReleaseGenericInterfaces();

    HRESULT FindInterfaceOnGraph(IUnknown * pUnkGraph, REFIID riid, void **ppInterface);
    HRESULT GetMimeTypeFromGraph(BSTR *pvarMime);
    void SetNaturalDuration(double dblMediaLength);
    void ClearNaturalDuration();
    HRESULT InitElementDuration();
    void FireMediaEvent(PLAYER_EVENT plEvent);
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent) = 0;

    virtual void Block() = 0;
    virtual void UnBlock() = 0;
    virtual bool CanCallThrough() = 0;

    HRESULT InternalReset(bool bSeek);
    virtual void GraphStart(void) = 0;
    void InternalStart();
    HRESULT ForceSeek(double dblTime);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)=0;
    
    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume, bool bMute /*= false*/);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT ConvertFrameToTime(LONGLONG iFrame, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);

    virtual HRESULT GetAvailableTime(double &dblEarliest, double &dblLatest);

    BEGIN_COM_MAP(CTIMEDshowBasePlayer)
        COM_INTERFACE_ENTRY(IAMFilterGraphCallback)
        COM_INTERFACE_ENTRY(IServiceProvider)
        //COM_INTERFACE_ENTRY_CHAIN(CTIMEBasePlayer)
    END_COM_MAP();

    STDMETHOD(InternalEvent)();

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);

    void PropChangeNotify(DWORD tePropType);
    bool UpdateSync();

    void SetNativePlayer(CTIMEPlayerNative *pNativePlayer)
    { m_pNativePlayer = pNativePlayer;}

  protected:
    HRESULT CreateMessageWindow();
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void ProcessGraphEvents();

    // IAMFilterGraphCallback
    HRESULT UnableToRender(IPin *pPin);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

#if DBG == 1
    HRESULT getFilterTime(double &time);
    HRESULT getFilterState(int &state);
#endif

    HRESULT DownloadCodec(IPin * pPin);

    HRESULT GraphCue(void);

    LONG m_cRef;
    bool m_fAudioMute;
    float m_flVolumeSave;
    bool m_bIsHTMLSrc;
    bool m_bIsSAMISrc;

    bool m_fRunning;
    bool m_bActive;
    bool m_bMediaDone;
    bool m_fIsOutOfSync;
    SYNC_TYPE_ENUM m_syncType;

    //generic graph interfaces
    CComPtr<IGraphBuilder> m_pGB;
    CComPtr<IMediaControl> m_pMC;
    CComPtr<IMediaEventEx> m_pMEx;
    CComPtr<IMediaEvent> m_pME;
    CComPtr<IMediaPosition> m_pMP;
    CComPtr<IMediaSeeking> m_pMS;
    CComPtr<IAMOpenProgress> m_pOP;
    CComPtr<IBasicAudio> m_pBasicAudio;

    CComPtr<IAMMediaContent> m_pMediaContent;;
    CComPtr<IBaseFilter> m_pOvM;
    CComPtr<IAMNetShowConfig> m_pIAMNetShowConfig;
    CComPtr<IAMExtendedSeeking> m_pExSeeking;
    CComPtr<IAMNetworkStatus> m_pIAMNetStat;
    CComPtr<IAMOpenProgress> m_spOpenProgress;

    HWND m_pwndMsgWindow;
    CLSID m_clsidDownloaded;
    HWND m_hwndDocument;
    bool m_fMediaComplete;
    bool m_fFiredComplete;
    double m_dblSyncTime;
    bool m_fSpeedIsNegative;
    bool m_fDetached;

    CTIMEPlayerNative *m_pNativePlayer;

};


#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerdshowtest.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#if DBG == 1

#include "playerdshowtest.h"
#include "mediaelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowTestTimePlayer, "TIME: Players", "CTIMEDshowTestPlayer methods");

CTIMEDshowTestPlayer::CTIMEDshowTestPlayer() :
    CTIMEDshowPlayer(NULL)
{
}

CTIMEDshowTestPlayer::~CTIMEDshowTestPlayer()
{
    TraceTag((tagDshowTestTimePlayer,
              "CTIMEDshowTestPlayer(%lx)::~CTIMEDshowTestPlayer()",
              this));

}


STDMETHODIMP
CTIMEDshowTestPlayer::CueMedia()
{
    TraceTag((tagDshowTestTimePlayer,
              "CTIMEDshowPlayer(%lx)::CueMedia()",
              this));
    HRESULT hr = S_OK;


    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowTestPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowTestTimePlayer,
              "CTIMEDshowPlayer(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;
    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    if (src == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = BeginDownload();
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitElementDuration();
    if (FAILED(hr))
    {
        goto done;
    }
    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:

    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowTestPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;
    hr = this->QueryInterface(IID_IDispatch, (void **)ppDisp);
    *ppDisp = static_cast<IDispatch*>(this);
    // ISSUE (mikhaill) -- the double definition of *ppDisp
    // + compiler warning (bug 104324)

    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::get_mediaTime(double *time)
{
    HRESULT hr = S_OK;
    double filterTime;

    hr = getFilterTime(filterTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        *time = -1.0;
    }
    else
    {
        *time = filterTime;
    }
    return hr;
}


STDMETHODIMP
CTIMEDshowTestPlayer::get_mediaState(int *state)
{
    HRESULT hr = S_OK;

    getFilterState(*state);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::pause()
{
    HRESULT hr = S_OK;
    if (m_pMC == NULL || m_pMP == NULL)
    {
        return hr;
    }

    if (m_fMediaComplete == true)
    {
        m_pMC->Pause();
    }
    return hr;
}


STDMETHODIMP
CTIMEDshowTestPlayer::resume()
{
    HRESULT hr = S_OK;
    Resume();
    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::get_mediaRate(double *dblRate)
{
    HRESULT hr = S_OK;

    hr = GetRate(*dblRate);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        *dblRate = -1.0;
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::put_mediaRate(double dblRate)
{
    HRESULT hr = S_OK;

    hr = SetRate(dblRate);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }

    return hr;
}



void
CTIMEDshowTestPlayer::Resume()
{

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    if( (bIsActive && !bIsCurrPaused) || m_fIsOutOfSync)
    {
        if (m_fMediaComplete == true)
        {
            m_pMC->Run();
        }
        m_fRunning = true;
    }

done:
    return;
}


STDMETHODIMP
CTIMEDshowTestPlayer::get_peerSyncFlag(VARIANT_BOOL *flag)
{
    HRESULT hr = S_OK;
    bool fsync;

    if(m_pTIMEElementBase == NULL)
    {
        *flag = VARIANT_FALSE;
        goto done;
    }

    fsync = m_pTIMEElementBase->IsSyncMaster();
    if(fsync)
    {
        *flag = VARIANT_TRUE;
    }
    else
    {
        *flag = VARIANT_FALSE;
    }

done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerhwdshow.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERHWDSHOW_H
#define _PLAYERHWDSHOW_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>
#include "hwproxy.h"

#include "importman.h"

#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEDshowHWPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEImportMedia,
    public ITIMEInternalEventSink
{
  public:
    CTIMEDshowHWPlayer(CTIMEDshowHWPlayerProxy * pProxy);
    virtual ~CTIMEDshowHWPlayer();

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType = NULL, double dblClipBegin = -1.0, double dblClipEnd = -1.0);//lint !e1735

  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();
    HRESULT BeginDownload();
    HRESULT GraphFinish();

    HRESULT ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR *pbstr);

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);
    void SetCLSID(REFCLSID clsid);

    HRESULT Reset();
    virtual void Tick();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);

    BEGIN_COM_MAP(CTIMEDshowHWPlayer)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP();

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEInternalEventSink
    //
    STDMETHOD(InternalEvent)();

  protected:
    HRESULT SetUpMainWindow();
    HRESULT SetUpDDraw(IMixerOCX *pIMixerOCX); 
    HRESULT SetUpVideoOffsets();
    void PropagateOffsets();
  protected:
    long    m_lSrc;
    bool m_fHasVideo;
    bool m_fDoneSetup;
    double m_dblSeekAtStart;
    bool m_fLoadError;
    bool m_fHasMedia;
    bool m_fRemoved;

  private:

    CTIMEDshowHWPlayer();
    
    HRESULT SetMixerSize(RECT *prect);
    HRESULT SetUpHdc();

    void GraphStart(void);

    bool IsOvMConnected(IBaseFilter *pOvM);

    void SetStreamFlags(LPOLESTR src);
    HRESULT DisableAudioVideo();

    bool m_bIsHTMLSrc;
    bool m_bIsSAMISrc;

    CComPtr<IMixerOCX> m_pIMixerOCX;
    DWORD m_nativeVideoWidth;
    DWORD m_nativeVideoHeight;
    DWORD m_displayVideoWidth;
    DWORD m_displayVideoHeight;

    LPSTREAM                    m_pTIMEMediaPlayerStream;

    bool m_fUsingInterfaces;
    bool m_fNeedToDeleteInterfaces;

    bool m_fCanCueNow;
    
    bool m_fHavePriority;
    double m_dblPriority;

    CComPtr<IDDrawExclModeVideo> m_pDDEX;

    HWND m_hWnd;
    LPDIRECTDRAW m_pDD; // ddraw object
    LPDIRECTDRAWSURFACE m_pDDS; // primary ddraw surface
    LPDIRECTDRAWCLIPPER m_pClipper; // clipper for our ddraw object
    COLORREF m_clrKey;     // color key

    RECT m_elementSize;
    long m_lPixelPosLeft;
    long m_lPixelPosTop;
    long m_lscrollOffsetx;
    long m_lscrollOffsety;
    RECT m_deskRect;

    HRESULT m_hrRenderFileReturn;
    
    CTIMEDshowHWPlayerProxy * m_pProxy;
    CritSect                m_CriticalSection;

};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerimage.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYERIMAGE_H
#define _PLAYERIMAGE_H

#include "playerbase.h"
#include "mstimep.h"

class CAnimatedGif;

#include "imagedownload.h"

#include "ddrawex.h"

/////////////////////////////////////////////////////////////////////////////
// CAnimatedGif
class CAnimatedGif
{
  public:
    CAnimatedGif();
    virtual ~CAnimatedGif();
    
    HRESULT Init(IUnknown * punkDirectDraw);

    ULONG AddRef();
    ULONG Release();

    HRESULT     Render(HDC hdc, LPRECT prc, LONG lFrameNum);

    bool        NeedNewFrame(double dblCurrentTime, LONG lOldFrame, LONG * plNewFrame, double dblClipBegin, double dblClipEnd);

    IDirectDrawSurface **  GetDDSurfaces() { return m_ppDDSurfaces; }
    void        PutDDSurfaces(IDirectDrawSurface ** ppDDSurfaces) { Assert(NULL == m_ppDDSurfaces); if (NULL != m_ppDDSurfaces) return; m_ppDDSurfaces = ppDDSurfaces; }    
    
    int         GetNumGifs() { return m_numGifs; }
    void        PutNumGifs(int numGifs) { Assert(0 == m_numGifs); if (0 != m_numGifs) return; m_numGifs = numGifs; }
    
    int      *  GetDelays() { return m_pDelays; }
    void        PutDelays(int * pDelays) { Assert(NULL == m_pDelays); if (NULL != m_pDelays) return; m_pDelays = pDelays; }

    double      GetLoop() { return m_loop; }
    void        PutLoop(double loop) { Assert(0 == m_loop); if (0 != m_loop) return; m_loop = loop; }

    void        PutWidth(LONG lWidth) { m_lWidth = lWidth; }
    void        PutHeight(LONG lHeight) { m_lHeight = lHeight; }

    double      CalcDuration();

    void        PutColorKeys(COLORREF * pColorKeys) { Assert(0 == m_pColorKeys); if (0 != m_pColorKeys) return; m_pColorKeys = pColorKeys; }
    COLORREF *  GetColorKeys() { return m_pColorKeys; }    

    HRESULT     CreateMasks();

  protected:
    bool        ClippedNeedNewFrame(double dblCurrentTime, LONG lOldFrame, LONG * plNewFrame, double dblClipBegin, double dblClipEnd);
    bool        CalculateFrame(double dblTime, LONG lOldFrame, LONG * plNewFrame);
    
  private:
    IDirectDrawSurface ** m_ppDDSurfaces;

    HBITMAP     *m_phbmpMasks;

    COLORREF    *m_pColorKeys;
    int          m_numGifs;
    int         *m_pDelays;
    double       m_loop;

    LONG         m_lHeight;
    LONG         m_lWidth;

    CComPtr<IDirectDraw3> m_spDD3;
    double       m_dblTotalDur;

    LONG m_cRef;
};

/////////////////////////////////////////////////////////////////////////////
// CTIMEImagePlayer

class CTIMEImagePlayer :
    public CTIMEBasePlayer,
    public ITIMEImportMedia
{
  public:
    CTIMEImagePlayer();
    ~CTIMEImagePlayer();
  public:

    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk);

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement(void);
    HRESULT InitElementSize();
    
    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    virtual void PropChangeNotify(DWORD tePropType);

    
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    HRESULT HasVisual(bool &fHasVideo);
    HRESULT HasAudio(bool &fHasAudio);
    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);
    HRESULT GetMimeType(BSTR *pMime);

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppMediaDownloader);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pMediaDownloader);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

  protected:
    void InternalStart();

    
  private:

    DWORD                       m_nativeImageWidth;
    DWORD                       m_nativeImageHeight;

    long                        m_lSrc;

    CComPtr<ITIMEMediaDownloader>   m_spMediaDownloader;
    CComPtr<ITIMEImageRender>   m_spImageRender;
    LPSTREAM                    m_pTIMEMediaPlayerStream;

    RECT                        m_elemRect;
    double                      m_dblCurrentTime;

    bool                        m_fRemoved;
    LONG                        m_lFrameNum;
    bool                        m_fLoadError;

    bool m_fHavePriority;
    double m_dblPriority;
    LONG m_cRef;
};


#endif /* _PLAYERIMAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playermc.cpp ===
//+-----------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      src\time\src\playermc.cpp
//
//  Contents:  The music center player.
//
//------------------------------------------------------------------------
#include "headers.h"
#include "playermc.h"
#include "externuuids.h"
#include "mediaelm.h"
#include "playlist.h"

///// uncomment-out this line to turn on Debug spew for this player
//DeclareTag(tagMCPlayer, "Debug", "General debug output");   //lint !e19
DeclareTag(tagMCPlayer, "TIME: Players", "Music Center player");      //lint !e19

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::~CTIMEMCPlayer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CTIMEMCPlayer::~CTIMEMCPlayer()
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::~CTIMEMCPlayer"));
    // These should have been NULL'd in DetachFromHostElement.  If they were not, something 
    // went wrong above us.
    Assert(NULL == m_pcTIMEElem);
    Assert(NULL == m_spMCManager.p);
    Assert(NULL == m_spMCPlayer.p);
    m_pcTIMEElem = NULL;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::CTIMEMCPlayer
//
//  Overview:  constructor
//
//  Arguments: pTIMEElem    pointer to our TIME element
//
//  Returns:   
//
//------------------------------------------------------------------------
CTIMEMCPlayer::CTIMEMCPlayer() :
    m_cRef(0),
    m_spMCManager(),
    m_spMCPlayer(),
    m_fInitialized(false),
    m_dblLocalTime(0.0),
    m_pcTIMEElem(NULL)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::CTIMEMCPlayer"));
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetExternalPlayerDispatch, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: ppDisp
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetExternalPlayerDispatch(IDispatch** ppDisp)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetExternalPlayerDispatch"));
    
    HRESULT hr = E_POINTER;

    //
    // TODO: add disp interface for access to extra properties/methods
    //

    if (!IsBadWritePtr(ppDisp, sizeof(IDispatch*)))
    {
        *ppDisp = NULL;
        hr      = E_FAIL;
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::AddRef, IUnknown
//
//  Overview:  standard non-thread-safe AddRef
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CTIMEMCPlayer::AddRef(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::AddRef"));
    return ++m_cRef;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Release, IUnknown
//
//  Overview:  standard non-thread-safe Release
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CTIMEMCPlayer::Release(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Release"));

    Assert(m_cRef > 0);  // very rare case

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Release --> deleting object"));
    delete this;
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::QueryInterface, IUnknown
//
//  Overview:  
//
//  Arguments: refiid   IID of requested interface
//             ppunk    out param for resulting interface pointer
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CTIMEMCPlayer::QueryInterface(REFIID refiid, void** ppv)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::QueryInterface"));
    if ( NULL == ppv )
    {
        Assert(false);
        return E_POINTER;
    }

    if (IsEqualIID(refiid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
        return S_OK;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Init, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Init"));
    HRESULT hr = E_FAIL;

    if (m_fInitialized)
    {
        hr = S_OK;
        goto done;
    }

    m_pcTIMEElem = pelem;

    hr = THR(CoCreateInstance(CLSID_MCMANAGER, NULL, CLSCTX_INPROC_SERVER, IID_IMCManager, 
            reinterpret_cast<void**>(&m_spMCManager)));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoCreateInstance(CLSID_DLXPLAY, NULL, CLSCTX_INPROC_SERVER, IID_IDLXPLAY,
            reinterpret_cast<void**>(&m_spMCPlayer)));

    if (FAILED(hr))
    {
        m_spMCManager = NULL;
        goto done;
    }

    hr = THR(m_spMCPlayer->Initialize(m_spMCManager, static_cast<IDLXPlayEventSink*>(this)));
    if (FAILED(hr))
    {
        m_spMCPlayer  = NULL;
        m_spMCManager = NULL;
        goto done;
    }

    m_fInitialized = true;

    // The media is always ready.
    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIACOMPLETE);
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::DetachFromHostElement, CTIMEBasePlayer
//
//  Overview:  called when detaching our behavior from the DOM
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::DetachFromHostElement(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::DetachFromHostElement()"));
    HRESULT hr = S_OK;

    m_fInitialized  = false;
    m_spMCManager   = NULL;
    m_spMCPlayer    = NULL;

    // The reference back to the element is a weak one.
    m_pcTIMEElem = NULL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnTick, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dblSegmentTime
//             lCurrRepeatCount
//
//  Returns:   
//
//------------------------------------------------------------------------
void
CTIMEMCPlayer::OnTick(double dblSegmentTime,
                      LONG lCurrRepeatCount)
{
    TraceTag((tagMCPlayer,
              "CTIMEMCPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
    //
    // cache dbllastTime for return in GetCurrentTime
    //

    m_dblLocalTime = dblSegmentTime;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnSync, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dbllastTime
//             dblnewTime
//
//  Returns:   
//
//------------------------------------------------------------------------
#ifdef NEW_TIMING_ENGINE
void 
CTIMEMCPlayer::OnSync(double dbllastTime, double& dblnewTime)
{
    // we don't really want to know every time OnSync is called
//    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnSync"));

    //
    // cache dbllastTime for return in GetCurrentTime
    //

    m_dblLocalTime = dbllastTime;
}
#endif


HRESULT 
CTIMEMCPlayer::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive = m_pcTIMEElem->IsActive();
    bool bNeedPause = m_pcTIMEElem->IsCurrPaused();

    if(!bNeedActive) // see if we need to stop the media.
    {
        Stop();
        goto done;
    }
    Start();

    if (bNeedPause)
    {
        Pause();
    }
    
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Start, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dblLocalTime
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Start()
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Start()"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Play());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Stop, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Stop(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Stop()"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Stop());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Pause, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Pause(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Pause"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Pause());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Resume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Resume(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Resume"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Play());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Resume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Repeat(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Repeat"));

    Start();
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Render, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Render"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::put_src, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: src
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetSrc"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetSize, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: prect
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetSize(RECT *prect)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetSize"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetCurrentTime, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
double  
CTIMEMCPlayer::GetCurrentTime()
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetCurrentTime"));

    //
    // TODO: return a meaningful time
    //
    
    return m_dblLocalTime;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetCurrentSyncTime, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT
CTIMEMCPlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;

    hr = S_FALSE;
  done:
    RRETURN1(hr, S_FALSE);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Seek, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dblTime
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::Seek(double dblTime)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Seek()"));
    HRESULT hr = E_NOTIMPL;

    //
    // TODO: add seek support
    //

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetMediaLength, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: rdblLength
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetMediaLength(double& rdblLength)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetMediaLength()"));
    HRESULT hr = S_OK;

    //
    // TODO: return a meaningful media length
    //
    rdblLength  = HUGE_VAL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::CanSeek, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: rfcanSeek
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::CanSeek(bool& rfcanSeek)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::CanSeek"));
    HRESULT hr = S_OK;

    //
    // TODO: add seek support
    //
    rfcanSeek = false;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    EnsureStringInVariant
//
//  Overview:  Tells us whether we have or can make a string out of this variant
//
//  Arguments: in/out variant
//
//  Returns:   bool
//
//------------------------------------------------------------------------
static bool 
EnsureStringInVariant (CComVariant *pvarParam)
{
    bool bRet = true;

    if (VT_BSTR != V_VT(pvarParam))
    {
        if (FAILED(THR(pvarParam->ChangeType(VT_BSTR))))
        {
            bRet = false;
            goto done;
        }
    }

done :
    return bRet;
} // EnsureStringInVariant

//+-----------------------------------------------------------------------
//
//  Method:    MakeEmptyStringInVariant
//
//  Overview:  Put an empty string into this variant
//
//  Arguments: in/out variant
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
static HRESULT
MakeEmptyStringInVariant (CComVariant *pvarParam)
{
    HRESULT hr;

    pvarParam->Clear();

    V_BSTR(pvarParam) = ::SysAllocString(L"");
    if (NULL == V_BSTR(pvarParam))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    V_VT(pvarParam) = VT_BSTR;

    hr = S_OK;
done :
    RRETURN1(hr,E_OUTOFMEMORY);
} // EnsureStringInVariant

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetPropertyFromDevicePlaylist
//
//  Overview:  
//
//  Arguments: pbstrParam
//
//  Returns:   S_OK, E_ACCESSDENIED, E_OUTOFMEMORY, E_POINTER
//
//------------------------------------------------------------------------
HRESULT
CTIMEMCPlayer::GetPropertyFromDevicePlaylist (LPOLESTR wzPropertyName, BSTR *pbstrOut)
{
    HRESULT hr;
    CComPtr<IMCPList> spimcPlaylist;
    CComVariant varParam;

    if (NULL == pbstrOut)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = THR(m_spMCPlayer->get_GetCurrentPlaylist(&spimcPlaylist));
    if (FAILED(hr))
    {
        // @@ Need to define the proper error mapping.
        hr = E_ACCESSDENIED;
        goto done;
    }

    hr = THR(spimcPlaylist->get_GetProperty(wzPropertyName, &varParam));
    if (FAILED(hr))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Make sure we pass a string back, even if it is an empty one.
    if (EnsureStringInVariant(&varParam))
    {
        *pbstrOut = ::SysAllocString(V_BSTR(&varParam));
    }
    else
    {
        hr = MakeEmptyStringInVariant(&varParam);
        if (FAILED(hr))
        {
            goto done;
        }
        *pbstrOut = ::SysAllocString(V_BSTR(&varParam));
    }

    if (NULL == (*pbstrOut))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN3(hr, E_ACCESSDENIED, E_OUTOFMEMORY, E_POINTER);
} // CTIMEMCPlayer::GetPropertyFromDevicePlaylist

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getAuthor, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pbstrAuthor
//
//  Returns:   S_OK, S_FALSE, E_ACCESSDENIED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetAuthor(BSTR* pbstrAuthor)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::getAuthor"));
   
    return GetPropertyFromDevicePlaylist(MCPLAYLIST_PROPERTY_ARTIST, pbstrAuthor);
} // CTIMEMCPlayer::getAuthor

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getTitle, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pbstrTitle
//
//  Returns:   S_OK, S_FALSE, E_ACCESSDENIED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetTitle(BSTR* pbstrTitle)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetTitle"));
    return GetPropertyFromDevicePlaylist(MCPLAYLIST_PROPERTY_TITLE, pbstrTitle);
} // CTIMEMCPlayer::getTitle

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getCopyright, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pbstrCopyright
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetCopyright(BSTR* pbstrCopyright)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetCopyright"));
    return GetPropertyFromDevicePlaylist(MCPLAYLIST_PROPERTY_COPYRIGHT, pbstrCopyright);
} // CTIMEMCPlayer::getCopyright

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getVolume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pflVolume
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetVolume(float* pflVolume)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetVolume"));
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pflVolume, sizeof(float)))
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    //
    // TODO: volume support won't work until we give the MC stuff an HWND 
    //
    hr = THR(m_spMCPlayer->get_Volume(pflVolume));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetVolume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: flVolume
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetVolume(float flVolume)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetVolume"));
    HRESULT hr = E_UNEXPECTED;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    //
    // TODO: volume support won't work until we give the MC stuff an HWND 
    //
    hr = THR(m_spMCPlayer->put_Volume(flVolume));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetBalance, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pflBalance
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetBalance(float* pflBalance)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetBalance"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetBalance, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: flBalance
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetBalance(float flBalance)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetBalance"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetMute, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pvarMute
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetMute(VARIANT_BOOL* pvarMute)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetMute"));
    HRESULT hr      = E_UNEXPECTED;
    BOOL    bMute   = FALSE;

    if (IsBadWritePtr(pvarMute, sizeof(VARIANT_BOOL)))
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(m_spMCPlayer->get_Mute(&bMute));
    if (FAILED(hr))
    {
        goto done;
    }

    if (bMute)
    {
        *pvarMute = VARIANT_TRUE;
    }
    else
    {
        *pvarMute = VARIANT_FALSE;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetMute, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: varMute
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetMute(VARIANT_BOOL varMute)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetMute"));
    HRESULT hr = E_UNEXPECTED;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (VARIANT_TRUE == varMute)
    {
        m_spMCPlayer->put_Mute(TRUE);
    }
    else
    {
        m_spMCPlayer->put_Mute(FALSE);
    }

done:
    return hr;
}

//
// Playlist methods
//

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::fillPlayList, CTIMEBasePlayer
//
//  Overview:  Translate IMCPList entries into ITIMEPlayItem entries
//
//  Arguments: Number of tracks, incoming music center playlist, outgoing ITIMEPlaylist interface
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CTIMEMCPlayer::TranslateMCPlaylist (short siNumTracks, IMCPList *pimcPlayList,
                                    CPlayList *pitimePlayList)
{
    HRESULT hr;
    
    for (short si = 0; si < siNumTracks; si++)
    {
        CComPtr <CPlayItem> pPlayItem;
        CComVariant varParam;

        //create the playitem
        hr = THR(pitimePlayList->CreatePlayItem(&pPlayItem));
        if (hr != S_OK)
        {
            goto done; //can't create playitems.
        }
        
        // get the various parameters from the playlist to put in the playitem.
        // We do not require any of the items to be correctly translated from
        // the native playlist format.  They are not always present.

        // Track title
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_TITLE, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutTitle(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track artist
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_ARTIST, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutAuthor(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track filename into the src field
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_FILENAME, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutSrc(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track copyright 
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_COPYRIGHT, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutCopyright(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track rating 
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_RATING, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutRating(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        pitimePlayList->Add(pPlayItem, -1);
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_OUTOFMEMORY);
} // CTIMEMCPlayer::TranslatePlaylist

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::fillPlayList, CTIMEBasePlayer
//
//  Overview:  Fill the ITIMEPlayList from the music center's playlist service.
//
//  Arguments: outgoing ITIMEPlaylist interface
//
//  Returns:   S_OK, E_ACCESSDENIED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::FillPlayList(CPlayList *pPlayList)
{
    HRESULT hr;

    // If we're not yet initialized, just eat the request.
    if (m_fInitialized)
    {
        short siNumTracks = 0;
        CComPtr<IMCPList> spimcPlaylist;

        Assert(NULL != m_spMCPlayer.p);
        hr = THR(m_spMCPlayer->get_Tracks(&siNumTracks));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }
        
        hr = THR(m_spMCPlayer->get_GetCurrentPlaylist(&spimcPlaylist));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }

        hr = TranslateMCPlaylist(siNumTracks, spimcPlaylist, pPlayList);
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_ACCESSDENIED, E_OUTOFMEMORY);
} // CTIMEMCPlayer::fillPlayList


//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::setActiveTrack, CTIMEBasePlayer
//
//  Overview:  Change the active track on the device.
//
//  Arguments: track index
//
//  Returns:   S_OK, E_ACCESSDENIED
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetActiveTrack (long index)
{
    HRESULT hr;

    // If we're not yet initialized, just eat the request.
    if (m_fInitialized)
    {
        Assert(NULL != m_spMCPlayer.p);
        // @@ Force a bad index into here.
        hr = THR(m_spMCPlayer->put_CurrentTrack(index));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_ACCESSDENIED);
} // CTIMEMCPlayer::setActiveTrack

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getActiveTrack, CTIMEBasePlayer
//
//  Overview:  Query the active track on the device.
//
//  Arguments: Pointer to track index VARIANT
//
//  Returns:   S_OK, E_POINTER, E_INVALIDARG, E_ACCESSDENIED
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetActiveTrack (long *pvarIndex)
{
    HRESULT hr;

    *pvarIndex = -1;
    
    // If we're not yet initialized, just eat the request.
    if (m_fInitialized)
    {
        int iCurrentTrack = 0;

        Assert(NULL != m_spMCPlayer.p);
        hr = THR(m_spMCPlayer->get_CurrentTrack(&iCurrentTrack));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }

        *pvarIndex = iCurrentTrack;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_ACCESSDENIED, E_INVALIDARG, E_POINTER);
} // CTIMEMCPlayer::getActiveTrack


//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnDiscInserted, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CDID
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnDiscInserted(long CDID)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnDiscInserted"));
    HRESULT hr = S_OK;

    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIACOMPLETE);
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIAINSERTED);
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnDiscRemoved, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CDID
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnDiscRemoved(long CDID)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnDiscRemoved"));
    HRESULT hr = S_OK;

    // When the disc is removed, we need to tell the playlist to update.
    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIACOMPLETE);
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIAREMOVED);
        //IGNORE_HR(m_pcTIMEElem->FireEvents(TE_ONMEDIAREMOVED, 0, NULL, NULL));
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnPause, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnPause(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnPause"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnStop, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnStop(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnStop"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnPlay, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnPlay(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnPlay"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnTrackChanged, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: NewTrack
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnTrackChanged(short NewTrack)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnTrackChanged"));
    HRESULT hr = S_OK;

    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnCacheProgress, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CD               
//             Track            
//             PercentComplete  
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnCacheProgress(short CD, short Track, short PercentCompleted)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnCacheProgress"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnCacheComplete, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CD       
//             Track    
//             Status   
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnCacheComplete(short CD, short Track, short Status)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnCacheComplete"));
    HRESULT hr = S_OK;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playermc.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\playermc.h
//
//  Contents: HTML+TIME Player for the Music Center 
//
//------------------------------------------------------------------------------------

#pragma once

#include "playerbase.h"
#include "externuuids.h"

class CTIMEMediaElement;

class CTIMEMCPlayer :
    public CTIMEBasePlayer,
    public IDLXPlayEventSink
{
public:
    virtual ~CTIMEMCPlayer();
    CTIMEMCPlayer();

    //
    // IUnknown Methods
    //
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD(QueryInterface)(REFIID refiid, void** ppv);

    //
    // CTIMEBasePlayer methods
    //
    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);
    void    Start();
    void    Stop();
    void    Pause();
    void    Resume();
    void    Repeat();
    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT* prect);

    double  GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool& fcanSeek);

    HRESULT GetAuthor(BSTR* pAuthor);
    HRESULT GetTitle(BSTR* pTitle);
    HRESULT GetCopyright(BSTR* pCopyright);

    HRESULT GetVolume(float* pflVolume);
    HRESULT SetVolume(float flVolume);
    HRESULT GetBalance(float* pflBalance);
    HRESULT SetBalance(float flBalance);
    HRESULT GetMute(VARIANT_BOOL* pvarMute);
    HRESULT SetMute(VARIANT_BOOL varMute);

    //
    // Playlist methods
    //
    HRESULT FillPlayList(CPlayList *pPlayList);
    HRESULT SetActiveTrack(long index);
    HRESULT GetActiveTrack(long *index);

    //
    // IDLXPlayEventSink methods
    //
        STDMETHOD(OnDiscInserted)(long CDID);
    STDMETHOD(OnDiscRemoved)(long CDID);
    STDMETHOD(OnPause)(void);
    STDMETHOD(OnStop)(void);
    STDMETHOD(OnPlay)(void);
    STDMETHOD(OnTrackChanged)(short NewTrack);
    STDMETHOD(OnCacheProgress)(short CD, short Track, short PercentCompleted);
    STDMETHOD(OnCacheComplete)(short CD, short Track, short Status);

    virtual HRESULT CueMedia() { return E_NOTIMPL; }

protected:


    HRESULT GetPropertyFromDevicePlaylist (LPOLESTR wzPropertyName, BSTR *pbstrOut);
    HRESULT TranslateMCPlaylist (short siNumTracks, IMCPList *pimcPlayList, CPlayList *pitimePlayList);

    ULONG               m_cRef;
    CComPtr<IMCManager> m_spMCManager;
    CComPtr<IDLXPlay>   m_spMCPlayer;
    CTIMEMediaElement  *m_pcTIMEElem;
    bool                m_fInitialized;
    double              m_dblLocalTime;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playernative.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYERNATIVE_H
#define _PLAYERNATIVE_H

#include "playerbase.h"
#include "playlist.h"
#include "wmpcd.h"
#include "importman.h"

class CTIMEMediaElement;
typedef enum PlayerType
{
    PLAYER_IMAGE,
    PLAYER_DSHOW,
    PLAYER_WMP,
    PLAYER_DMUSIC,
    PLAYER_DVD,
    PLAYER_CD,
    PLAYER_DSHOWTEST,
    PLAYER_NONE
} tagPlayerType;

typedef enum AsynchronousTypes
{
    PLAYLIST_CD,
    PLAYLIST_ASX,
    MIMEDISCOVERY_ASYNCH,
    ASYNC_NONE
} tagAsynchronousTypes;
    

typedef std::list<ITIMEBasePlayer*> PlayerList;
typedef std::list<double> DurList;
typedef std::list<bool> ValidList;

typedef HRESULT (WINAPI *WMPGETCDDEVICELISTP)(IWMPCDDeviceList **ppList);  
//STDAPI WMPGetCDDeviceList( IWMPCDDeviceList **ppList );

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195"))
CTIMEPlayerNative :
    public CTIMEBasePlayer,
    public CComObjectRootEx<CComSingleThreadModel>,
    public ITIMEImportMedia,
    public IBindStatusCallback
{
  public:
    CTIMEPlayerNative(PlayerType playerType);
    virtual ~CTIMEPlayerNative();

    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };

    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    virtual HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    virtual HRESULT DetachFromHostElement (void);
    virtual CTIMEPlayerNative *GetNativePlayer();
    
    virtual void Start();
    virtual void Stop();
    virtual void Pause();
    virtual void Resume();
    virtual void Repeat();
    virtual HRESULT Reset();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();
    virtual void Tick();
    virtual void LoadFailNotify(PLAYER_EVENT reason);
    virtual void FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer = NULL);
    virtual HRESULT Render(HDC hdc, LPRECT prc);

    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    virtual HRESULT SetSize(RECT *prect);

    virtual bool SetSyncMaster(bool fSyncMaster);

    virtual double GetCurrentTime();
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime);
    virtual HRESULT Seek(double dblTime);
    virtual HRESULT GetMediaLength(double &dblLength);
    virtual HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void SetClipEnd(double dblClipEnd);
    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);

    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT HasPlayList(bool &fhasPlayList);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);

    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);

    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT ConvertFrameToTime(LONGLONG iFrame, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);

    // 
    // ITIMEPlayerIntegration methods
    //
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle);

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);

    // These are to make our internal implementation of playlists work
    // with all players
    virtual HRESULT SetActiveTrack(long index);
    virtual HRESULT GetActiveTrack(long *index);
    void SetNaturalDuration(double dblMediaLength);
    void ClearNaturalDuration();
    HRESULT GetPlayItemOffset(double &dblOffset);
    HRESULT GetPlayItemSeekOffset(double &dblOffset);

    virtual HRESULT onMouseMove(long x, long y);
    virtual HRESULT onMouseDown(long x, long y);

    BEGIN_COM_MAP(CTIMEPlayerNative)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
    END_COM_MAP();

    //
    // IBindStatusCallback
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved);
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);


    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

  protected:
    HRESULT InternalSetActiveTrack(long index, bool fCheckSkip = true);
    void RemovePlayer();
    void RemovePlayList();
    void BuildPlayer(PlayerType playerType);
    HRESULT PlayerTypeFromMimeType(LPWSTR pszMime, LPOLESTR lpBase, LPOLESTR src, LPOLESTR lpMimeType, PlayerType * pType);
    PlayerType GetPlayerType(LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType);
    bool FindDVDPlayer();
    HRESULT LoadAsx(WCHAR * pszFileName, WCHAR **ppwFileContent);
    HRESULT CreatePlayList(WCHAR *ppwFileContent, std::list<LPOLESTR> &asxList);
    HRESULT AddToPlayList(CPlayList *pPlayList, WCHAR *pwFileContent, std::list<LPOLESTR> &asxList);
    HRESULT CreateCDPlayList();
    void TryNaturalDur();
    void SetEffectiveDur(bool finished);
    void ResetEffectiveDur();
    HRESULT StartFileDownload(LPOLESTR pFileName, AsynchronousTypes playListType);
    void GetPlayerNumber(double dblSeekTime, int &iPlNr);
    bool IsDownloadAsx(TCHAR *pwFileContent);
    CComPtr<ITIMEBasePlayer> m_pPlayer;
    bool m_fCanChangeSrc;
    PlayerType m_playerType;
    bool m_fHardware;

    static LONG m_fHPlayer;
    static LONG m_fHaveCD;

    //Player parameter block
    LPOLESTR m_lpsrc;
    LPOLESTR m_lpbase;
    LPOLESTR m_lpmimetype;
    double m_dblClipBegin;
    double m_dblClipEnd;

    LPOLESTR m_pszDiscoveredMimeType;

    bool m_fAbortDownload;
    DAComPtr<CPlayList> m_playList;
    PlayerList playerList;
    ValidList m_validList;
    DurList m_durList;
    DurList m_effectiveDurList;
    ValidList m_playedList;
    int m_iCurrentPlayItem;
    bool m_fFiredMediaComplete;
    int m_iChangeUp;
    bool m_fNoNaturalDur;
    bool m_fHandlingEvent;
    bool m_fDownloadError;
    bool m_fRemoved;

    HINSTANCE m_hinstWMPCD;
    WMPGETCDDEVICELISTP m_WMPGetCDDeviceList;

    LPSTREAM m_pTIMEMediaPlayerStream;
    bool m_fHavePriority;
    double m_dblPriority;
    long m_lSrc;
   
    AsynchronousTypes m_eAsynchronousType;

    CComPtr<IXMLDOMDocument> m_spXMLDoc;


  private:
    LONG m_cRef;
    CTIMEPlayerNative();
};

#endif /* _PLAYERBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playernative.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playernative.h"
#include "playerimage.h"
#include "playerdshow.h"
#include "playerhwdshow.h"
#include "player.h"
#include "playerdvd.h"
#include "playercd.h"
#include "playerdshowtest.h"
#include "mediaelm.h"
#include "dshowproxy.h"
#include "dshowcdproxy.h"
#include "hwproxy.h"
#include "msxml.h"
#include "dmusicproxy.h"

#include "bindstatuscallback.h"


static WCHAR g_wszHardware[] = L"hardware";

static const TCHAR WMPCD_DLL[] = _T("WMPCD.DLL");
static const char WMPGETCDDEVICELIST[] = "WMPGetCDDeviceList";
static WCHAR g_urlAddress[] = L"http://windowsmedia.com/redir/QueryTOC.asp?cd=";

DeclareTag(tagPlayerNative, "TIME: Players", "CTIMEPlayerNative methods");
DeclareTag(tagPlayerNativeEffDur, "TIME: Players", "CTIMEPlayerNative effective dur methods");
DeclareTag(tagPlayerNativeEffSync, "TIME: Players", "CTIMEPlayerNative effective sync methods");


LONG CTIMEPlayerNative::m_fHPlayer = 0;
LONG CTIMEPlayerNative::m_fHaveCD = 0;

CTIMEPlayerNative::CTIMEPlayerNative(PlayerType playerType) :
    m_cRef(0),
    m_fCanChangeSrc(false),
    m_playerType(playerType),
    m_fHardware(true),
    m_lpsrc(NULL),
    m_lpbase(NULL),
    m_lpmimetype(NULL),
    m_dblClipBegin(0.0),
    m_dblClipEnd(-1.0),
    m_fAbortDownload(false),
    m_iCurrentPlayItem(-1),
    m_fFiredMediaComplete(false),
    m_iChangeUp(1),
    m_fNoNaturalDur(false),
    m_hinstWMPCD(NULL),
    m_WMPGetCDDeviceList(NULL),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_dblPriority(INFINITE),
    m_fHavePriority(false),
    m_fHandlingEvent(false),
    m_eAsynchronousType(ASYNC_NONE),
    m_fDownloadError(false),
    m_fRemoved(false),
    m_pszDiscoveredMimeType(NULL)
{
    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::CTIMEPlayerNative()",
              this));

    //
    // CD Player disabled
    // bug 18665
    // 
    // NOTE: technically we should be ok here since Init is called and we
    // dont let a PLAYER_CD be set inside Init (through GetPlayerType).
    // but just to be safe...
    //
    if (m_playerType == PLAYER_CD)
    {
        m_playerType = PLAYER_NONE;
    }

}

CTIMEPlayerNative::~CTIMEPlayerNative()
{
    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::~CTIMEPlayerNative()",
              this));

    m_lpsrc = NULL;
    m_lpbase = NULL;
    m_lpmimetype = NULL;

    delete [] m_pszDiscoveredMimeType;
    m_pszDiscoveredMimeType = NULL;

    ReleaseInterface(m_pTIMEMediaPlayerStream);
}


HRESULT
CTIMEPlayerNative::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetExternalPlayerDispatch(ppDisp);
    }

    return hr;
}

void
CTIMEPlayerNative::RemovePlayList()
{
    PlayerList::iterator iPlayer;

    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();

        for(iPlayer = playerList.begin(); iPlayer != playerList.end(); iPlayer++)
        {
            if((*iPlayer) == NULL)
            {
                continue;
            }
            (*iPlayer)->Stop();
            if((*iPlayer) != m_pPlayer)
            {
                THR((*iPlayer)->DetachFromHostElement());
            }
            (*iPlayer)->Release();
        }
    }
}

void
CTIMEPlayerNative::RemovePlayer()
{
    if (m_pPlayer)
    {
        m_pPlayer->Stop();
        THR(m_pPlayer->DetachFromHostElement());
        m_pPlayer.Release();
        if(m_fHardware)
        {
            InterlockedExchange(&m_fHPlayer , 0);
        }
        if(m_fHaveCD)
        {
            InterlockedExchange(&m_fHaveCD , 0);
        }

    }
}

void
CTIMEPlayerNative::BuildPlayer(PlayerType playerType)
{
    LONG llock;
    bool fHasDvd;
    HRESULT hr = S_OK;

    RemovePlayer();

    switch(playerType)
    {
    case PLAYER_IMAGE:
        m_pPlayer = NEW CTIMEImagePlayer();
        m_fHardware = false;
        break;
    case PLAYER_DMUSIC:
        m_pPlayer = CTIMEPlayerDMusicProxy::CreateDMusicProxy();
        m_fHardware = false;
        break;
    case PLAYER_DVD:
        m_pPlayer = NEW CTIMEDVDPlayer();
        m_fHardware = false;
        break;
    case PLAYER_CD:
        m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
        m_fHardware = false;
        break;
#if DBG == 1
    case PLAYER_DSHOWTEST:
        CComObject<CTIMEDshowTestPlayer> * pTestPlayer;

        hr = THR(CComObject<CTIMEDshowTestPlayer>::CreateInstance(&pTestPlayer));
        if (hr != S_OK)
        {
            break;
        }

        m_pPlayer = (CTIMEBasePlayer *)pTestPlayer;
        m_fHardware = false;
        break;
#endif
    case PLAYER_WMP:
        m_pPlayer = NEW CTIMEPlayer(__uuidof(MediaPlayerCLSID));
        m_fCanChangeSrc = true;
        m_fHardware = false;
        break;
    case PLAYER_DSHOW:
        fHasDvd = FindDVDPlayer();
        if(m_fHardware && !fHasDvd)
        {
            llock = InterlockedExchange(&m_fHPlayer , 1);
            if(llock == 0)
            {
                m_pPlayer = CTIMEDshowHWPlayerProxy::CreateDshowHWPlayerProxy();
            }
            else
            {
                m_fHardware = false;
                m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
            }
        }
        else
        {
            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
        }
        break;
    default:
        break;
    }
}

HRESULT
DiscoverMimeType(LPWSTR pszBase, LPWSTR pszSrc, LPWSTR * ppszDiscoveredMimeType)
{
    HRESULT     hr = S_OK;
    LPOLESTR    pszUrl = NULL;

    LPOLESTR    lpszPath = NULL;
    URL_COMPONENTSW URLComp;
    LPOLESTR    MimeType = NULL;

    Assert(ppszDiscoveredMimeType);
    *ppszDiscoveredMimeType = NULL;


    hr = THR(::TIMECombineURL(pszBase, pszSrc, &pszUrl));
    if (!pszUrl)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }
    
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;
    
    if (!InternetCrackUrlW(pszUrl, lstrlenW(pszUrl), 0, &URLComp))
    {
        hr = S_FALSE;
        goto done;
    }
    lpszPath = NEW OLECHAR [URLComp.dwUrlPathLength + 1];
    if (lpszPath == NULL)
    {
        hr = S_FALSE;
        goto done;
    }
    StrCpyNW(lpszPath, URLComp.lpszUrlPath, URLComp.dwUrlPathLength + 1);            
    lpszPath[URLComp.dwUrlPathLength] = 0;
    
    
    // Try to discover 
    hr = THR(::TIMEFindMimeFromData(NULL, lpszPath, NULL, NULL, NULL, 0, &MimeType, 0));
    if (SUCCEEDED(hr))
    {
        (*ppszDiscoveredMimeType) = ::CopyString(MimeType);
        
        if (NULL == (*ppszDiscoveredMimeType))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    if (FAILED(hr))
    {
        // could not discover mime type from extension.  return NULL mime type and S_OK
        (*ppszDiscoveredMimeType) = NULL;
        hr = S_OK;
        goto done;
    }
    
    hr = S_OK;
done:
    if (NULL != MimeType)
    {
        CoTaskMemFree(MimeType);
        MimeType = NULL;
    }
    delete [] pszUrl;
    delete [] lpszPath;
    RRETURN1(hr, S_FALSE);
}


PlayerType
CTIMEPlayerNative::GetPlayerType(LPOLESTR lpBase, LPOLESTR src, LPOLESTR lpMimeType)
{
    PlayerType foundPlayer = PLAYER_NONE;

    LPOLESTR pEntryRef = NULL;
    HRESULT hr = S_OK;
    LONG lHaveCD;
    LPWSTR pszDiscoveredMimeType = NULL;

    //
    // CD Player disabled
    // bug 18665
    // 
    if (m_playerType != PLAYER_NONE)
    {
        if (m_playerType == PLAYER_CD)
        {
            goto done;
        }
        foundPlayer = m_playerType;
        goto done;
    }


#if 0 // remove this to enable CD Player
    if(m_playerType != PLAYER_NONE)
    {
        if((m_playerType == PLAYER_CD) && (src == NULL))
        {
            lHaveCD = InterlockedExchange(&m_fHaveCD , 1);

            if(lHaveCD == 1)
            {
                hr = E_FAIL;
                goto done;
            }

            hr = CreateCDPlayList();
            if(FAILED(hr))
            {
                goto done;
            }
        }

        foundPlayer = m_playerType;
        goto done;
    }
#endif // remove this to enable CD Player

    if(lpMimeType == NULL)
    {
        hr = THR(DiscoverMimeType(lpBase, src, &pszDiscoveredMimeType));
        if (S_FALSE == hr)
        {
            foundPlayer = PLAYER_WMP;
            hr = S_OK;
            goto done;
        }
        else if ((S_OK == hr) && 
                 ((NULL == pszDiscoveredMimeType) || (0 == StrCmpIW(pszDiscoveredMimeType, L"text/asp"))))
        {
            // could not discover mime type from extension alone.  Need to start a download.
        
            LPOLESTR szSrc = NULL;

            hr = THR(::TIMECombineURL(lpBase, src, &szSrc));
            if (!szSrc)
            {
                hr = E_FAIL;
                goto done;
            }
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
            StartFileDownload(szSrc, MIMEDISCOVERY_ASYNCH);
        
            foundPlayer = PLAYER_DSHOW;

            delete [] szSrc;
            goto done;
        }
        if (FAILED(hr))
        {
            goto done;
        }
        hr = THR(PlayerTypeFromMimeType(pszDiscoveredMimeType, lpBase, src, lpMimeType, &foundPlayer));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = THR(PlayerTypeFromMimeType(lpMimeType, lpBase, src, lpMimeType, &foundPlayer));
        if (FAILED(hr))
        {
            goto done;
        }
    }


    hr = S_OK;
done:
    delete [] pszDiscoveredMimeType;

    return foundPlayer;
}

HRESULT
CTIMEPlayerNative::PlayerTypeFromMimeType(LPWSTR pszMimeType, LPOLESTR lpBase, LPOLESTR src, LPOLESTR lpMimeType, PlayerType * pType)
{   
    HRESULT hr = S_OK;

    PlayerType foundPlayer = PLAYER_NONE;

    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;

    Assert(pType);
    *pType = PLAYER_NONE;

    m_pTIMEElementBase->ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);

    if (NULL == pszMimeType)
    {
        if (fPlayVideo)
        {
            foundPlayer = PLAYER_DSHOW;
        }
        // else PLAYER_NONE, set above
        goto done;
    }


    // The cheezy WMF test is necessary because urlmon does not consider
    // wmf files to have 'image' mimetypes.
    if (   (StrCmpNW(L"image", pszMimeType , 5) == 0)
        || (IsWMFSrc(src, pszMimeType, lpMimeType)))
    {
        if (fShowImages)
        {
            foundPlayer = PLAYER_IMAGE;
        }
    }
    else if (   IsASXSrc(src, pszMimeType, lpMimeType)
             || IsM3USrc(src, pszMimeType, lpMimeType)
             || IsWAXSrc(src, pszMimeType, lpMimeType)
             || IsWVXSrc(src, pszMimeType, lpMimeType)
             || IsWMXSrc(src, pszMimeType, lpMimeType)
             || IsLSXSrc(src, pszMimeType, lpMimeType))
    {
        if (IsASXSrc(src, pszMimeType, lpMimeType) ||
            IsLSXSrc(src, pszMimeType, lpMimeType) ||
            IsWMXSrc(src, pszMimeType, lpMimeType))
        {
            LPOLESTR szSrc = NULL;

            hr = THR(::TIMECombineURL(lpBase, src, &szSrc));
            if (!szSrc)
            {
                hr = E_FAIL;
                goto done;
            }
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            StartFileDownload(szSrc, PLAYLIST_ASX);

            foundPlayer = PLAYER_DSHOW;
            delete[] szSrc;
        }
        else if (fPlayVideo)
        {
            foundPlayer = PLAYER_WMP;
        }
    }
    else if (fPlayVideo)
    {
        foundPlayer = PLAYER_DSHOW;
    }

    hr = S_OK;
done:
    if (S_OK == hr)
    {
        *pType = foundPlayer;
    }

    RRETURN(hr);
}

HRESULT
CTIMEPlayerNative::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;
    CComPtr <IHTMLElement> pEle;
    LPOLESTR pSrc = NULL;
    PlayerList::iterator iPlayer;
    int size;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(CTIMEBasePlayer::Init(pelem,
                                   base,
                                   src,
                                   lpMimeType,
                                   dblClipBegin,
                                   dblClipEnd));
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHardware = true;
    
    pEle = m_pTIMEElementBase->GetElement();
    if (pEle != NULL)
    {
        CComBSTR bstrHardware = g_wszHardware;
        VARIANT vHardware;
        VariantInit(&vHardware);
        hr = pEle->getAttribute(bstrHardware, 0, &vHardware);
        if (SUCCEEDED(hr))
        {
            if (vHardware.vt != VT_BSTR)
            {
                hr = VariantChangeType(&vHardware, &vHardware, 0, VT_BSTR);
            }
            if (SUCCEEDED(hr))
            {
                if (StrCmpIW(vHardware.bstrVal, L"false") == 0)
                {
                    m_fHardware = false;
                }
            }
        }
        VariantClear(&vHardware);
    }

    if(m_fHardware)
    {
        if(m_pTIMEElementBase->IsDocumentInEditMode())
        {
            m_fHardware = false;
        }
    }

    if(base != NULL)
    {
        delete [] m_lpbase;
        m_lpbase = CopyString(base);
    }
    if(src != NULL)
    {
        delete [] m_lpsrc;
        m_lpsrc = CopyString(src);
    }
    if(lpMimeType != NULL)
    {
        delete [] m_lpmimetype;
        m_lpmimetype = CopyString(lpMimeType);
    }

    m_playerType = GetPlayerType(base, src, lpMimeType);

    if(m_eAsynchronousType == ASYNC_NONE)
    {
        BuildPlayer(m_playerType);
        if (m_pPlayer)
        {
            hr = m_pPlayer->Init(pelem, base, src, NULL, dblClipBegin, dblClipEnd);
            if(FAILED(hr))
            {
                if(m_fHardware == true)
                {
                    RemovePlayer();
                    m_fHardware = false;
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    hr = m_pPlayer->Init(pelem, base, src, NULL, dblClipBegin, dblClipEnd);
                    if(FAILED(hr))
                    {
                        goto done;
                    }
                }
                else
                {
                    goto done;
                }
            }

            m_dblClipEnd = dblClipEnd;
            m_dblClipBegin = dblClipBegin;
        }

    }
    else if(m_playerType == PLAYER_CD)
    {
        BuildPlayer(m_playerType);

        if(m_playList && m_pPlayer)
        {
            CPlayItem * pItem = m_playList->GetItem(0);
            if (pItem == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        
            pSrc = (LPOLESTR)(pItem->GetSrc());
            if(pSrc == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
            m_fHardware = false;

            playerList.resize(m_playList->GetLength(), NULL);
            m_durList.resize(m_playList->GetLength(), -1.0);
            m_effectiveDurList.resize(m_playList->GetLength(), 0.0);
            m_validList.resize(m_playList->GetLength(), true);
            m_playedList.resize(m_playList->GetLength(), false);
            m_pPlayer->SetPlaybackSite(this);

            iPlayer = playerList.begin();
            (*iPlayer) = m_pPlayer;
            m_pPlayer->AddRef();
            m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);
            dblClipBegin = valueNotSet;
            dblClipEnd = valueNotSet;

            hr = m_pPlayer->Init(m_pTIMEElementBase, NULL, src, NULL, dblClipBegin, dblClipEnd);

            delete [] m_lpbase;
            delete [] m_lpmimetype;
            delete [] m_lpsrc;
            m_lpbase = NULL;
            m_lpsrc = CopyString(pSrc);
            m_lpmimetype = NULL;
            m_dblClipEnd = dblClipEnd;
            m_dblClipBegin = dblClipBegin;
            m_iCurrentPlayItem = 0;
        }

    }    

    m_dblClipEnd = dblClipEnd;
    m_dblClipBegin = dblClipBegin;

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }

    RRETURN(hr);
}

HRESULT
CTIMEPlayerNative::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::DetachFromHostElement)",
              this));

    m_fRemoved = true;

    RemovePlayList();
    RemovePlayer();

    delete[] m_lpbase;
    m_lpbase = NULL;
    delete[] m_lpsrc;
    m_lpsrc = NULL;
    delete[] m_lpmimetype;
    m_lpmimetype = NULL;

    if(m_hinstWMPCD)
    {
        FreeLibrary(m_hinstWMPCD);
        m_hinstWMPCD = NULL;
    }
    m_WMPGetCDDeviceList = NULL;

    return hr;
}

void
CTIMEPlayerNative::Start()
{
    if(m_playList)
    {
        InternalSetActiveTrack(0, false);
        /////////////////////////////////////////////////////////////////////////////////////
        //need to reset the effect dur list after setting the active track because
        //setting the active track will cause the last element that played to set an 
        //effect dur into the effective dur list.
        /////////////////////////////////////////////////////////////////////////////////////
        ResetEffectiveDur();
        Reset();
    }
    else if(m_pPlayer)
    {
        m_pPlayer->Start();
    }
}

void
CTIMEPlayerNative::Stop()
{
    if(m_playList)
    {
        if(m_iCurrentPlayItem < m_playList->GetLength())
        {
            if(m_pPlayer)
            {
                m_pPlayer->Pause();
            }
        }
    }
    else if(m_pPlayer)
    {
        m_pPlayer->Stop();
    }
}

void
CTIMEPlayerNative::Pause()
{
    if(m_pPlayer)
    {
        m_pPlayer->Pause();
    }
}

void
CTIMEPlayerNative::Resume()
{
    if(m_pPlayer)
    {
        m_pPlayer->Resume();
    }
}

void
CTIMEPlayerNative::Repeat()
{
    if(m_playList)
    {
        ResetEffectiveDur();
        InternalSetActiveTrack(0, false);
    }
    else if(m_pPlayer)
    {
        m_pPlayer->Repeat();
    }
}

HRESULT
CTIMEPlayerNative::Reset()
{
    HRESULT hr = S_OK;
    double dblSegTime = 0.0;
    int iPlayerNr;
    int i = 0;
    PlayerList::iterator iPlayer;
    ValidList::iterator iValid;
    CPlayItem * pItem;
    LPOLESTR psrc = NULL;
    DurList::iterator iEfDur;
    DurList::iterator iDur;
    ValidList::iterator iPlayed;


    if(m_playList && m_pPlayer)
    {
        if(m_pTIMEElementBase == NULL)
        {
            goto done;
        }

        if(m_iCurrentPlayItem >= m_playList->GetLength())
        {
            goto done;
        }

        for(iEfDur = m_effectiveDurList.begin(), iDur = m_durList.begin(), i = 0, iPlayed = m_playedList.begin();
            iEfDur != m_effectiveDurList.end(); iEfDur++, iDur++, i++, iPlayed++)
        {
            if(i < m_iCurrentPlayItem)
            {
                (*iEfDur) = (*iDur);
                (*iPlayed) = true;
            }
            else
            {
                (*iPlayed) = false;
                (*iEfDur) = 0.0;
            }
        }

        dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
        GetPlayerNumber(dblSegTime, iPlayerNr);

        if((iPlayerNr == m_iCurrentPlayItem) && (iPlayerNr != -1))
        {
            hr = m_pPlayer->Reset();
            goto done;
        }

        if(m_iCurrentPlayItem >= 0)
        {
            iPlayer = playerList.begin();
            iValid = m_validList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iPlayer++;
                iValid++;
            }

            if((*iValid))
            {
                (*iPlayer)->Stop();
                THR((*iPlayer)->DetachFromHostElement());
                (*iPlayer)->Release();
                (*iPlayer) = NULL;
                m_pPlayer = NULL;
                m_iCurrentPlayItem = -1;
            }
        }

        if(iPlayerNr == -1)
        {
            goto done;
        }

        m_iCurrentPlayItem = iPlayerNr;

        iPlayer = playerList.begin();
        for(i = m_iCurrentPlayItem; i > 0; i--)
        {
            iPlayer++;
        }

        for(iEfDur = m_effectiveDurList.begin(), iDur = m_durList.begin(), i = 0, iPlayed = m_playedList.begin();
            iEfDur != m_effectiveDurList.end(); iEfDur++, iDur++, i++, iPlayed++)
        {
            if(i < m_iCurrentPlayItem)
            {
                (*iEfDur) = (*iDur);
                (*iPlayed) = true;
            }
            else
            {
                (*iPlayed) = false;
                (*iEfDur) = 0.0;
            }
        }

        pItem = m_playList->GetItem(m_iCurrentPlayItem);
        if(pItem)
        {
            psrc = (LPOLESTR)pItem->GetSrc();
        }
        switch(m_playerType)
        {
            case PLAYER_CD:
                m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                m_fHardware = false;
                break;
            case PLAYER_DSHOW:
                m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                m_fHardware = false;
                break;
        }
        m_pPlayer->SetPlaybackSite(this);
        hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
        (*iPlayer) = m_pPlayer;
        m_pPlayer->AddRef();
        m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);

    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->Reset();
    }
done:
    return hr;
}

bool
CTIMEPlayerNative::SetSyncMaster(bool fSyncMaster)
{
    return true;
}

double
CTIMEPlayerNative::GetCurrentTime()
{
    double dblCurrTime = 0.0;
    double dblOffset = 0.0;
    HRESULT hr = S_OK;

    if(m_playList)
    {
        dblCurrTime = m_pPlayer->GetCurrentTime();
        hr = GetPlayItemOffset(dblOffset);
        if(FAILED(hr))
        {
            goto done;
        }

        dblCurrTime += dblOffset;
    }
    else if(m_pPlayer)
    {
        dblCurrTime = m_pPlayer->GetCurrentTime();
    }
done:
    return dblCurrTime;
}

void
CTIMEPlayerNative::GetPlayerNumber(double dblSeekTime, int &iPlNr)
{
    iPlNr = -1;
    DurList::iterator iDur;
    int i = 0;

    if(dblSeekTime == 0.0)
    {
        iPlNr = 0;
        goto done;
    }

    for(iDur = m_durList.begin(), i = 0; iDur != m_durList.end(); iDur++, i++)
    {
        if((*iDur) == -1.0)
        {
            break;
        }

        if(dblSeekTime < (*iDur))
        {
            iPlNr = i;
            break;
        }

        dblSeekTime -= (*iDur);
    }
done:
    return;
}

HRESULT
CTIMEPlayerNative::GetPlayItemOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    DurList::iterator iEfDur;
    int i;

    dblOffset = 0.0;

    if(!m_playList)
    {
        goto done;
    }

    if((m_iCurrentPlayItem == -1) || (m_iCurrentPlayItem >= m_playList->GetLength()))
    {
        hr = E_FAIL;
        goto done;
    }

    for(iEfDur = m_effectiveDurList.begin(), i = 0;
        iEfDur != m_effectiveDurList.end(); iEfDur++, i++)
    {
        dblOffset += (*iEfDur);
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::GetPlayItemSeekOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    DurList::iterator iDur;
    DurList::iterator iEfDur;
    int i;

    dblOffset = 0.0;

    if(!m_playList)
    {
        goto done;
    }

    if((m_iCurrentPlayItem == -1) || (m_iCurrentPlayItem >= m_playList->GetLength()))
    {
        hr = E_FAIL;
        goto done;
    }

    for(iDur = m_durList.begin(), i = 0;
        iDur != m_durList.end(), i < m_iCurrentPlayItem; iDur++, i++)
    {
        dblOffset += (*iDur);
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::GetPlaybackOffset(double &dblOffset)
{
    HRESULT hr = S_OK;

    hr = GetPlayItemSeekOffset(dblOffset);

    return hr;
}


HRESULT
CTIMEPlayerNative::GetEffectiveOffset(double &dblOffset)
{
    HRESULT hr = S_OK;

    hr = GetPlayItemOffset(dblOffset);

    return hr;
}

HRESULT
CTIMEPlayerNative::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr = S_OK;
    double dblOffset = 0.0;
    dblSyncTime = 0.0;

    if(m_playList)
    {
        if((m_iCurrentPlayItem == -1) || (m_pPlayer == NULL))
        {
            hr = S_FALSE;
            goto done;
        }

        hr = m_pPlayer->GetCurrentSyncTime(dblSyncTime);
        if(S_OK != hr)
        {
            TraceTag((tagPlayerNativeEffSync,
                      "CTIMEPlayerNative(%lx)::CTIMEPlayerNative::sync()-failes player(%d)",
                      this, m_iCurrentPlayItem));
            hr = S_FALSE;
            goto done;
        }

        hr = GetPlayItemOffset(dblOffset);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }

        TraceTag((tagPlayerNativeEffSync,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative::sync()-unadjusted(%d - %g)",
                  this, m_iCurrentPlayItem, dblSyncTime));
        dblSyncTime += dblOffset;
        TraceTag((tagPlayerNativeEffSync,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative::sync()-adjusted(%d - %g)",
                  this, m_iCurrentPlayItem, dblSyncTime));

    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetCurrentSyncTime(dblSyncTime);
    }
    else
    {
        hr = S_OK;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::Seek(double dblTime)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->Seek(dblTime);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    DurList::iterator iDur;

    dblLength = 0.0;   
    if(m_playList)
    {
        for(iDur = m_durList.begin(); iDur != m_durList.end(); iDur++)
        {
            if((*iDur) == -1.0)
            {
                dblLength = HUGE_VAL;
                break;
            }
            dblLength += (*iDur);
        }      
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetMediaLength(dblLength);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->CanSeek(fcanSeek);
    }
    return hr;
}

PlayerState
CTIMEPlayerNative::GetState()
{
    if (m_pPlayer)
    {
        return m_pPlayer->GetState();
    }

    return CTIMEBasePlayer::GetState();
}

HRESULT
CTIMEPlayerNative::HasMedia(bool &hasMedia)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->HasMedia(hasMedia);
    }
    else
    {
        hasMedia = false;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::HasVisual(bool &hasVisual)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->HasVisual(hasVisual);
    }
    else
    {
        hasVisual = false;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::HasAudio(bool &hasAudio)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->HasAudio(hasAudio);
    }
    else
    {
        hasAudio = false;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::Render(HDC hdc, LPRECT prc)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->Render(hdc, prc);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        if(m_fCanChangeSrc)
        {
            hr = m_pPlayer->SetSrc(base, src);
            goto done;
        }
        RemovePlayer();
    }

    BuildPlayer(m_playerType);
    if( m_pPlayer)
    {
        hr = m_pPlayer->Init(m_pTIMEElementBase, base, src, NULL, m_dblClipStart, m_dblClipEnd);
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayerNative::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetSize(prect);
    }
    return hr;
}


STDMETHODIMP_(ULONG)
CTIMEPlayerNative::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayerNative::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

HRESULT
CTIMEPlayerNative::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->IsBroadcast(bisBroad);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetRate(dblRate);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetRate(dblRate);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;
    *height = -1;
    if(m_pPlayer)
    {
        hr = m_pPlayer->GetNaturalHeight(height);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetNaturalWidth(long *width)
{
    HRESULT hr = S_OK;
    *width = -1;
    if(m_pPlayer)
    {
        hr = m_pPlayer->GetNaturalWidth(width);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pAuthor);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetAuthor();
            if(pcString != NULL)
            {
                *pAuthor = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetAuthor(pAuthor);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetAuthor(pAuthor);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcTitle;

    Assert(pTitle);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcTitle = pPlayItem->GetTitle();
            if(pcTitle != NULL)
            {
                *pTitle = SysAllocString(pcTitle);
            }
            else
            {
                hr = m_pPlayer->GetTitle(pTitle);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetTitle(pTitle);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pCopyright);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetCopyright();
            if(pcString != NULL)
            {
                *pCopyright = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetCopyright(pCopyright);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetCopyright(pCopyright);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CTIMEPlayerNative::GetAbstract(BSTR *pAbstract)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pAbstract);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetAbstract();
            if(pcString != NULL)
            {
                *pAbstract = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetAbstract(pAbstract);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetAbstract(pAbstract);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CTIMEPlayerNative::GetRating(BSTR *pRating)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pRating);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetRating();
            if(pcString != NULL)
            {
                *pRating = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetRating(pRating);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetRating(pRating);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetVolume(pflVolume);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetVolume(flVolume);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetMute(VARIANT_BOOL *pvarMute)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetMute(pvarMute);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetMute(varMute);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetPlayList(ITIMEPlayList **ppPlayList)
{
    HRESULT hr = S_OK;
    
    if (m_playList)
    {
        hr = THR(m_playList->QueryInterface(IID_ITIMEPlayList, (void**)ppPlayList));
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetPlayList(ppPlayList);
    }
    else
    {
        hr = E_FAIL;
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayerNative::SetActiveTrack(long index)
{
    return InternalSetActiveTrack(index);
}

HRESULT 
CTIMEPlayerNative::InternalSetActiveTrack(long index, bool fCheckSkip)
{
    CPlayItem * pItem;
    LPOLESTR psrc = NULL;
    PlayerList::iterator iPlayer;
    ValidList::iterator iValid;
    bool fDone = false;
    int iOrigTrack = m_iCurrentPlayItem;
    bool fOk = false;
    HRESULT hr = S_OK;
    int i;

    if(!m_playList)
    {
        hr = E_FAIL;
        goto done;
    }

    if(index >= m_playList->GetLength())
    {
        hr = E_FAIL;
        goto done;
    }

    if((m_iCurrentPlayItem >= 0) && fCheckSkip)
    {
        pItem = m_playList->GetItem(m_iCurrentPlayItem);
        if(pItem)
        {
            if(!pItem->GetCanSkip())
            {
                hr = S_OK;
                goto done;
            }
        }
    }

    SetEffectiveDur(false);
    //TryNaturalDur();

    if((index == m_iCurrentPlayItem) || (m_iCurrentPlayItem == -1))
    {
        if(m_iCurrentPlayItem == -1)
        {
            m_iCurrentPlayItem = index;
        }
        if(m_pPlayer)
        {
            m_pPlayer->Repeat();
        }
        else
        {
            iPlayer = playerList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iPlayer++;
            }
            pItem = m_playList->GetItem(m_iCurrentPlayItem);
            if(pItem)
            {
                psrc = (LPOLESTR)pItem->GetSrc();
            }
            switch(m_playerType)
            {
                case PLAYER_CD:
                    m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                    m_fHardware = false;
                    break;
                case PLAYER_DSHOW:
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    m_fHardware = false;
                    break;
            }
            m_pPlayer->SetPlaybackSite(this);
            (*iPlayer) = m_pPlayer;
            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
            m_pPlayer->AddRef();
        }
        hr = S_OK;
        goto done;
    }
    if(index > m_iCurrentPlayItem)
    {
        m_iChangeUp = 1;
    }
    else
    {
        m_iChangeUp = -1;
    }

    //need to check that track changing is possible
    iValid = m_validList.begin();
    for(i = m_iCurrentPlayItem; i > 0; i--)
    {
        iValid++;
    }
    if(m_iChangeUp == 1)
    {
        if(m_iCurrentPlayItem == (m_playList->GetLength() - 1))
        {
            hr = S_OK;
            goto done;
        }
        for(i = m_iCurrentPlayItem + 1; i < m_playList->GetLength(); i++)
        {
            iValid++;
            if((*iValid) == true)
            {
                fOk = true;
                break;
            }
        }
    }
    else
    {
        if(m_iCurrentPlayItem == 0)
        {
            hr = S_OK;
            goto done;
        }

        for(i = m_iCurrentPlayItem - 1; i >= 0; i--)
        {
            iValid--;
            if((*iValid) == true)
            {
                fOk = true;
                break;
            }
        }

    }

    if(!fOk)
    {
        hr = S_OK;
        goto done;
    }

    i = m_iCurrentPlayItem = index;

    iPlayer = playerList.begin();
    iValid = m_validList.begin();

    for(i = m_iCurrentPlayItem; i > 0; i--)
    {
        iPlayer++;
        iValid++;
    }
    if(m_pPlayer)
    {
        m_pPlayer->Stop();
        m_pPlayer->DetachFromHostElement();
    }

    while(!fDone)
    {
        if((*iPlayer) != NULL)
        {
            if((*iValid) == false)
            {
                m_iCurrentPlayItem += m_iChangeUp;
                if(m_iChangeUp == 1)
                {
                    if(m_iCurrentPlayItem == m_playList->GetLength())
                    {
                        m_iCurrentPlayItem = iOrigTrack;
                        fDone = true;
                        continue;
                    }
                    iValid++;
                    iPlayer++;
                }
                else
                {
                    if(m_iCurrentPlayItem < 0)
                    {
                        m_iCurrentPlayItem = iOrigTrack;
                        fDone = true;
                        continue;
                    }
                    iValid--;
                    iPlayer--;
                }
                continue;
            }
            //m_pPlayer = (*iPlayer); // Replace player

            (*iPlayer)->Stop();
            THR((*iPlayer)->DetachFromHostElement());
            (*iPlayer)->Release();
            (*iPlayer) = NULL;
            pItem = m_playList->GetItem(m_iCurrentPlayItem);
            if(pItem)
            {
                psrc = (LPOLESTR)pItem->GetSrc();
            }
            switch(m_playerType)
            {
                case PLAYER_CD:
                    m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                    m_fHardware = false;
                    break;
                case PLAYER_DSHOW:
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    m_fHardware = false;
                    break;
            }
            m_pPlayer->SetPlaybackSite(this);
            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
            (*iPlayer) = m_pPlayer;
            m_pPlayer->AddRef();

            fDone = true;
        }
        else
        {
            pItem = m_playList->GetItem(m_iCurrentPlayItem);
            if(pItem)
            {
                psrc = (LPOLESTR)pItem->GetSrc();
            }
            switch(m_playerType)
            {
                case PLAYER_CD:
                    m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                    m_fHardware = false;
                    break;
                case PLAYER_DSHOW:
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    m_fHardware = false;
                    break;
            }
            m_pPlayer->SetPlaybackSite(this);
            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
            (*iPlayer) = m_pPlayer;
            m_pPlayer->AddRef();
            fDone = true;
        }
    }
    //m_pPlayer->Repeat();
    m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);

done:
    return S_OK;
}


HRESULT 
CTIMEPlayerNative::GetActiveTrack(long *index)
{
    *index = m_iCurrentPlayItem;
    return S_OK;
}


HRESULT
CTIMEPlayerNative::onMouseMove(long x, long y)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->onMouseMove(x, y);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::onMouseDown(long x, long y)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->onMouseDown(x, y);
    }
    return hr;
}


void
CTIMEPlayerNative::PropChangeNotify(DWORD tePropType)
{
    if(m_pPlayer)
    {
        m_pPlayer->PropChangeNotify(tePropType);
    }
    return;
}

void 
CTIMEPlayerNative::ReadyStateNotify(LPWSTR szReadyState)
{
    //
    // Disable h/w rendering if filters attached. Filters can be queried only after onload
    //

    if (0 == StrCmpIW(szReadyState, L"onload"))
    {
        if (m_pTIMEElementBase == NULL)
        {
            goto done;
        }

        Assert(m_pTIMEElementBase);

        if (m_fHardware && m_pTIMEElementBase->IsFilterAttached())
        {
            RemovePlayer();
            m_fHardware = false;
            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
            if(m_pPlayer)
            {
                IGNORE_HR(m_pPlayer->Init(m_pTIMEElementBase, m_lpbase, m_lpsrc, NULL, m_dblClipBegin, m_dblClipEnd));
            }
        }
    }

    if(m_pPlayer)
    {
        m_pPlayer->ReadyStateNotify(szReadyState);
    }
  done:
    return;
}


bool 
CTIMEPlayerNative::UpdateSync()
{
    if(m_pPlayer)
    {
        return m_pPlayer->UpdateSync();
    }
    return true;
}

void
CTIMEPlayerNative::Tick()
{
    if(m_pPlayer)
    {
        m_pPlayer->Tick();
    }
    return;
}

void
CTIMEPlayerNative::SetClipBegin(double dblClipBegin)
{
    CTIMEBasePlayer::SetClipBegin(dblClipBegin);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipBegin(dblClipBegin);
    }
} // putClipBegin

void 
CTIMEPlayerNative::SetClipEnd(double dblClipEnd)
{
    CTIMEBasePlayer::SetClipEnd(dblClipEnd);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipEnd(dblClipEnd);
    }
} // putClipEnd

void
CTIMEPlayerNative::SetClipBeginFrame(long lClipBegin)
{
    CTIMEBasePlayer::SetClipBeginFrame(lClipBegin);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipBeginFrame(lClipBegin);
    }
} // putClipBegin

void 
CTIMEPlayerNative::SetClipEndFrame(long lClipEnd)
{
    CTIMEBasePlayer::SetClipEnd(lClipEnd);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipEndFrame(lClipEnd);
    }
} // putClipEnd

void
CTIMEPlayerNative::LoadFailNotify(PLAYER_EVENT reason)
{

    switch(reason)
    {
    case PE_ONMEDIAERRORCOLORKEY:
        if (m_fHardware)
        {
            RemovePlayer();
            m_fHardware = false;
            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
            if (m_pPlayer)
            {
                IGNORE_HR(m_pPlayer->Init(m_pTIMEElementBase, m_lpbase, m_lpsrc, NULL, m_dblClipBegin, m_dblClipEnd));
            }
        }
        break;
    }
    return;
}

/////////////////////////////////////////////////////////////////////////
//
// NotifyTransitionSite : from ITIMEPlayerIntegration
//
// Tells us that we need to teardown and rebuild
// if this playback site is to be filtered.
//
/////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEPlayerNative::NotifyTransitionSite (bool fTransitionToggle)
{
    // @@ ISSUE - does it make sense to force a 
    // teardown and rebuild when we might be able to use
    // hardware again?  If so, we'd need a way to do that.
    if (fTransitionToggle)
    {
        // Overloading the colorkey error method to effect
        // teardown and rebuild h/w to s/w.
        LoadFailNotify(PE_ONMEDIAERRORCOLORKEY);
    }

    return S_OK;
} // NotifyTransitionSite

bool
CTIMEPlayerNative::FindDVDPlayer()
{
    int i;
    bool fFound = false;
    CTIMEElementBase *pElm = (CTIMEElementBase *)(m_pTIMEElementBase->GetBody());
    CTIMEElementBase *pcElm = NULL;
    std::list<CTIMEElementBase*> nodeList;
    CComPtr <IHTMLElement> pEle;
    VARIANT vHardware;
    HRESULT hr = S_OK;

    VariantInit(&vHardware);

    nodeList.push_back(pElm);

    while( nodeList.size() > 0)
    {
        pElm = nodeList.front();
        if(pElm == NULL)
        {
            break;
        }
        nodeList.pop_front();
        pEle = pElm->GetElement();
        if(pEle == NULL)
        {
            break;
        }

        hr = pEle->getAttribute(L"player", 0, &vHardware);
        if (SUCCEEDED(hr))
        {
            if (vHardware.vt != VT_BSTR)
            {
                hr = VariantChangeType(&vHardware, &vHardware, 0, VT_BSTR);
            }
            if (SUCCEEDED(hr))
            {
                if (StrCmpIW(vHardware.bstrVal, L"DVD") == 0)
                {
                    fFound = true;
                    break;
                }
            }
        }
        VariantClear(&vHardware);

        for(i = 0; i < pElm->GetImmediateChildCount(); i++)
        {
            pcElm = pElm->GetChild(i);
            nodeList.push_back(pcElm);
        }
        pElm = NULL;
        pEle = NULL;
    }

    VariantClear(&vHardware);

    return fFound;
}


HRESULT
CTIMEPlayerNative::GetEarliestMediaTime(double &dblEarliestMediaTime)
{
    HRESULT hr = S_OK;
    dblEarliestMediaTime = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetEarliestMediaTime(dblEarliestMediaTime);
    }
done:
    return hr;
}


HRESULT
CTIMEPlayerNative::GetLatestMediaTime(double &dblLatestMediaTime)
{
    HRESULT hr = S_OK;
    dblLatestMediaTime = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetLatestMediaTime(dblLatestMediaTime);
    }
done:
    return hr;
}


HRESULT
CTIMEPlayerNative::GetMinBufferedMediaDur(double &dblMinBufferedMediaDur)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetMinBufferedMediaDur(dblMinBufferedMediaDur);
    }
    return hr;
}


HRESULT
CTIMEPlayerNative::SetMinBufferedMediaDur(double dblMinBufferedMediaDur)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetMinBufferedMediaDur(dblMinBufferedMediaDur);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetDownloadTotal(LONGLONG &lldlTotal)
{
    HRESULT hr = S_OK;
    lldlTotal = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetDownloadTotal(lldlTotal);
    }
    return hr;
}


HRESULT
CTIMEPlayerNative::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    HRESULT hr = S_OK;
    lldlCurrent = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetDownloadCurrent(lldlCurrent);
    }
    return hr;
}


HRESULT
CTIMEPlayerNative::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;
    fIsStreamed = false;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetIsStreamed(fIsStreamed);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetBufferingProgress(dblBufferingProgress);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    fHasDownloadProgress = false;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetHasDownloadProgress(fHasDownloadProgress);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetMimeType(pMime);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::ConvertFrameToTime(LONGLONG iFrame, double &dblTime)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->ConvertFrameToTime(iFrame, dblTime);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetCurrentFrame(LONGLONG &lFrameNr)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetCurrentFrame(lFrameNr);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::HasPlayList(bool &fhasPlayList)
{
    fhasPlayList = false;
    
    if (m_playList)
    {
        fhasPlayList = true;
    }
    else if(m_pPlayer)
    {
        m_pPlayer->HasPlayList(fhasPlayList);
    }

    return S_OK;
}

HRESULT
CTIMEPlayerNative::LoadAsx(WCHAR * pszFileName, WCHAR **ppwFileContent)
{
    HRESULT hr = S_OK;
    LPWSTR pszTrimmedName = NULL;
    TCHAR szCacheFileName[MAX_PATH+1];
    TCHAR *pwFileContent = NULL;
    OFSTRUCT fileStruct;
    BOOL fReadOk;
    char *pcFileContent = NULL;
    DWORD iFileLen, iHigh, iRead;
    HANDLE hFile;

    if (!pszFileName)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    pszTrimmedName = TrimCopyString(pszFileName);
    if (NULL == pszTrimmedName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = URLDownloadToCacheFileW(NULL, 
                                 pszTrimmedName, 
                                 szCacheFileName, 
                                 MAX_PATH, 
                                 0, 
                                 this);
    if (FAILED(hr))
    {
        goto done;
    }

    //fileNameLen = wcslen(szCacheFileName);
    //pcFileName = new char( fileNameLen + 1);
    //WideCharToMultiByte(CP_ACP, 0, szCacheFileName, -1, pcFileName, fileNameLen, NULL, NULL);


    hFile = CreateFileW(szCacheFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        DWORD errorRes = GetLastError();
        hr = E_FAIL;
        goto done;
    }

    iFileLen = GetFileSize(hFile, NULL);

    pcFileContent = new char[iFileLen + 1];
    
    //Windows 656588 Prefix fix. a-thkesa // check for the return value.
    //new may return NULL.
    if(pcFileContent)
    {
        fReadOk = ReadFile(hFile, pcFileContent, iFileLen, &iRead, NULL);
        *(pcFileContent + iRead) = 0;

        pwFileContent = new TCHAR[iRead + 1];
        if(pwFileContent)
        {
             MultiByteToWideChar(CP_ACP, 0, pcFileContent, -1, pwFileContent, iRead);
             *(pwFileContent + iRead) = 0;
        }
        else
        {
             hr = E_OUTOFMEMORY;
        }
        delete[] pcFileContent;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }// End Fix

    CloseHandle(hFile);

    *ppwFileContent = pwFileContent;

done:
    delete [] pszTrimmedName;
    return hr;
}

HRESULT
CTIMEPlayerNative::AddToPlayList(CPlayList *pPlayList, WCHAR *pwFileContent, std::list<LPOLESTR> &asxList)
{
    HRESULT hr = S_OK;
    CTIMEParser pParser(pwFileContent);

    pParser.ParsePlayList(m_playList, false, &asxList);


#if DBG == 1
    for(long i = 0; i < m_playList->GetLength(); i++)
    {
        CPlayItem * pItem = m_playList->GetItem(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwStr;
            
            TraceTag((tagError, "<Entry>"));
            lpwStr = pItem->GetTitle();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Title:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAuthor();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Author:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAbstract();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Abstract:<%S>", lpwStr));
            }
            lpwStr = pItem->GetSrc();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  HREF:<%S>", lpwStr));
            }
            TraceTag((tagError, "</Entry>"));
        }
    }
#endif

    return hr;
}

HRESULT
CTIMEPlayerNative::CreatePlayList(WCHAR *pwFileContent, std::list<LPOLESTR> &asxList)
{
    CTIMEParser pParser(pwFileContent);
    HRESULT hr;
    
    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = THR(CComObject<CPlayList>::CreateInstance(&pPlayList));
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = THR(pPlayList->Init(*this));
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    hr = pParser.ParsePlayList(m_playList, false, &asxList);

#if DBG == 1

    if (m_playList)
    {
        for(long i = 0; i < m_playList->GetLength(); i++)
        {
            CPlayItem * pItem = m_playList->GetItem(i);
            if (pItem != NULL)
            {
                LPCWSTR lpwStr;
                
                TraceTag((tagError, "<Entry>"));
                lpwStr = pItem->GetTitle();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  Title:<%S>", lpwStr));
                }
                lpwStr = pItem->GetAuthor();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  Author:<%S>", lpwStr));
                }
                lpwStr = pItem->GetAbstract();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  Abstract:<%S>", lpwStr));
                }
                lpwStr = pItem->GetSrc();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  HREF:<%S>", lpwStr));
                }
                TraceTag((tagError, "</Entry>"));
            }
        }
    }
#endif

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::CreateCDPlayList()
{
    HRESULT hr;
    CComPtr<IWMPCDDeviceList>   spList;
    CComPtr<IWMPCDDevice>       spDevice;
    CComPtr<IWMPCDMediaInfo>    spMediaInfo;
    DWORD trackCount;
    CComPtr<CPlayItem> pPlayItem;
    int i;
    TCHAR *pSrc, pSrcNr[ 10];
    TCHAR *pTitle, *pMetaAddress = NULL;
    CComBSTR bstrCdIdentifier;
    int iLen;


    m_hinstWMPCD = LoadLibrary(WMPCD_DLL);
    if(m_hinstWMPCD)
    {
        m_WMPGetCDDeviceList = (WMPGETCDDEVICELISTP)GetProcAddress(m_hinstWMPCD, WMPGETCDDEVICELIST);
        if(m_WMPGetCDDeviceList)
        {
            hr = m_WMPGetCDDeviceList( &spList );
            if(FAILED(hr))
            {
                goto done;
            }
            hr = spList->GetDevice( 0, &spDevice );
            if(FAILED(hr))
            {
                goto done;
            }

            //  This call simply forces the device info block to be initialized.
            //
            hr = spDevice->GetMediaInfo( &spMediaInfo );
            if(FAILED(hr))
            {
                goto done;
            }

            hr = spMediaInfo->GetTrackCount(&trackCount);
            if(FAILED(hr))
            {
                goto done;
            }

            hr = spMediaInfo->GetDiscIdentifier( &bstrCdIdentifier);
            if(SUCCEEDED(hr))
            {
                iLen = lstrlenW(g_urlAddress) + lstrlenW(bstrCdIdentifier);
                pMetaAddress = new TCHAR[iLen + 1];
                StrCpyW(pMetaAddress, g_urlAddress);
                StrCatW(pMetaAddress, bstrCdIdentifier);
            }

        }
    }
	else
	{
		hr = E_FAIL;
		goto done;
	}
    
    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = THR(CComObject<CPlayList>::CreateInstance(&pPlayList));
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = THR(pPlayList->Init(*this));
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    for( i = 0; i < trackCount; i++)
    {
        hr = THR(m_playList->CreatePlayItem(&pPlayItem));
        if (FAILED(hr))
        {
            goto done; //can't create playitems.
        }
        IGNORE_HR(m_playList->Add(pPlayItem, -1));

        _itow(i + 1, pSrcNr, 10);

        pSrc = new TCHAR[lstrlenW(L"wmpcd://0/") + lstrlenW( pSrcNr) + 1];
        StrCpyW(pSrc, L"wmpcd://0/");
        StrCatW(pSrc, pSrcNr);
        pPlayItem->PutSrc(pSrc);
        delete [] pSrc;

        pTitle = new TCHAR[lstrlenW(L"Title:") + lstrlenW( pSrcNr) + 1];
        StrCpyW(pTitle, L"Title:");
        StrCatW(pTitle, pSrcNr);
        pPlayItem->PutTitle(pTitle);
        pPlayItem.Release();
        delete [] pTitle;
    }

    if(pMetaAddress)
    {
        StartFileDownload(pMetaAddress, PLAYLIST_CD);
        delete [] pMetaAddress;
    }

#if DBG == 1
    for(long i = 0; i < m_playList->GetLength(); i++)
    {
        CPlayItem * pItem = m_playList->GetItem(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwStr;
            
            TraceTag((tagError, "<Entry>"));
            lpwStr = pItem->GetTitle();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Title:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAuthor();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Author:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAbstract();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Abstract:<%S>", lpwStr));
            }
            lpwStr = pItem->GetSrc();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  HREF:<%S>", lpwStr));
            }
            TraceTag((tagError, "</Entry>"));
        }
    }
#endif

done:

    if(FAILED(hr))
    {
        m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIAERROR);
    }

    return hr;
}

void 
CTIMEPlayerNative::FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer)
{
    CPlayItem * pItem = NULL;
    LPOLESTR psrc = NULL;
    HRESULT hr = S_OK;
    PlayerList::iterator iPlayer;
    ValidList::iterator iValid;
    DurList::iterator iDur;
    DurList::iterator iEfDur;
    ValidList::iterator iPlayed;
    int i;
    bool fDone = false;
    double dblMediaDur = 0.0;
    m_fHandlingEvent = true;
    bool fDonePlayList = false;
    RECT rctNativeSize;
    RECT rctFinalSize;
    bool fnativeSize;
    LPCWSTR pcTitle;
    BSTR pTitle = NULL;

    if(m_pPlayer == NULL)
    {
        goto done;
    }

    if(m_pPlayer != pBasePlayer)
    {
        goto done;
    }

    switch(plEvent)
    {
        case PE_ONMEDIAEND:
            if(!m_playList)
            {
                break;
            }

            SetEffectiveDur(true);

            m_iChangeUp = 1;
            m_iCurrentPlayItem++;
            if(m_iCurrentPlayItem >= m_playList->GetLength())
            {
                //end off play list
                TryNaturalDur();
                break;
            }

            iPlayer = playerList.begin();
            iValid = m_validList.begin();
            iPlayed = m_playedList.begin();
            iDur = m_durList.begin();
            iEfDur = m_effectiveDurList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iPlayer++;
                iValid++;
                iPlayed++;
                iDur++;
                iEfDur++;
            }
            if((*iPlayer) == NULL)
            {
                pItem = m_playList->GetItem(m_iCurrentPlayItem);
                if(pItem)
                {
                    psrc = (LPOLESTR)pItem->GetSrc();
                }
                switch(m_playerType)
                {
                    case PLAYER_CD:
                        m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                        m_fHardware = false;
                        break;
                    case PLAYER_DSHOW:
                        m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                        m_fHardware = false;
                        break;
                }
                m_pPlayer->SetPlaybackSite(this);
                hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
                (*iPlayer) = m_pPlayer;
                m_pPlayer->AddRef();
                m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);
                fDone = true;
            }
            else
            {
                if((*iValid))
                {
                    (*iPlayer)->Stop(); //Replace player
                    THR((*iPlayer)->DetachFromHostElement());
                    (*iPlayer)->Release();
                    (*iPlayer) = NULL;
                    pItem = m_playList->GetItem(m_iCurrentPlayItem);
                    if(pItem)
                    {
                        psrc = (LPOLESTR)pItem->GetSrc();
                    }
                    switch(m_playerType)
                    {
                        case PLAYER_CD:
                            m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                            m_fHardware = false;
                            break;
                        case PLAYER_DSHOW:
                            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                            m_fHardware = false;
                            break;
                    }
                    m_pPlayer->SetPlaybackSite(this);
                    hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
                    (*iPlayer) = m_pPlayer;
                    m_pPlayer->AddRef();


                    m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);

                    rctNativeSize.top = rctNativeSize.left = 0;
                    rctNativeSize.right = rctNativeSize.bottom = -1;
                    m_pTIMEElementBase->NegotiateSize(rctNativeSize, rctFinalSize, fnativeSize, true);
                }
                else
                {
                    (*iValid) = false;
                    (*iDur) = 0.0;
                    (*iEfDur) = 0.0;
                    (*iPlayed) = true;

                    if(m_iCurrentPlayItem == (m_playList->GetLength() - 1))
                    {
                        //end off play list
                        m_iCurrentPlayItem++;
                        TryNaturalDur();
                        break;
                    }
                    InternalSetActiveTrack(m_iCurrentPlayItem + 1, false);
                }
            }

            break;
        case PE_ONMEDIACOMPLETE:
            if(!m_fFiredMediaComplete)
            {
                m_fFiredMediaComplete = true;
                m_pTIMEElementBase -> FireMediaEvent(plEvent);
            }
            if(!m_playList)
            {
                break;
            }

            m_pTIMEElementBase -> FireMediaEvent(PE_ONTRACKCOMPLETE);
            m_playList->SetLoadedFlag(true);
            iPlayer = playerList.begin();
            iValid = m_validList.begin();
            iDur = m_durList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iValid++;
                iDur++;
                iPlayer++;
            }
            (*iValid) = true;
            pItem = m_playList->GetItem(m_iCurrentPlayItem);

            hr = m_pPlayer->GetEffectiveLength(dblMediaDur);
            if(FAILED(hr))
            {
                m_fNoNaturalDur = true;
            }
            else
            {
                (*iDur) = dblMediaDur;
                if(pItem)
                {
                    pItem->PutDur(dblMediaDur);
                }
            }

            if(pItem)
            {
                pcTitle = pItem->GetTitle();
                if(pcTitle == NULL)
                {
                    hr = m_pPlayer->GetTitle(&pTitle);
                    if(SUCCEEDED(hr))
                    {
                        if(pTitle == NULL)
                        {
                            break;
                        }
                        IGNORE_HR(pItem->PutTitle(pTitle));
                    }
                }
            }


            //TryNaturalDur();

            break;
        case PE_ONMEDIAERROR:
            if(!m_playList)
            {
                m_pTIMEElementBase -> FireMediaEvent(plEvent);
                break;
            }
            iValid = m_validList.begin();
            iDur = m_durList.begin();
            iEfDur = m_effectiveDurList.begin();
            iPlayed = m_playedList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iValid++;
                iDur++;
                iPlayed++;
                iEfDur++;
            }
            (*iValid) = false;
            (*iDur) = 0.0;
            (*iEfDur) = 0.0;
            (*iPlayed) = true;

            if(m_iCurrentPlayItem == (m_playList->GetLength() - 1))
            {
                //end off play list
                m_iCurrentPlayItem++;
                TryNaturalDur();
                break;
            }
            InternalSetActiveTrack(m_iCurrentPlayItem + m_iChangeUp, false);
            break;
        default:
            m_pTIMEElementBase -> FireMediaEvent(plEvent);
            break;
    }
done:
    m_fHandlingEvent = false;
    return;
}

void
CTIMEPlayerNative::SetEffectiveDur(bool finished)
{
    DurList::iterator iEfDur;
    ValidList::iterator iValid;
    ValidList::iterator iPlayed;
    int i;
    double dblEffDur = 0.0;
    HRESULT hr = S_OK;
    double dblMediaDur = 0.0;

    if(!m_pPlayer)
    {
        goto done;
    }

    if(m_iCurrentPlayItem == -1)
    {
        goto done;
    }

    iEfDur = m_effectiveDurList.begin();
    iValid = m_validList.begin();
    iPlayed = m_playedList.begin();
    for(i = m_iCurrentPlayItem; i > 0; i--)
    {
        iValid++;
        iEfDur++;
        iPlayed++;
    }

    if(*iValid != true)
    {
        goto done;
    }

    (*iPlayed) = true;

    hr = m_pPlayer->GetEffectiveLength(dblMediaDur);
    if(FAILED(hr))
    {
        dblMediaDur = 0.0;
    }

    if(finished)
    {
        *iEfDur += dblMediaDur;
        dblEffDur = *iEfDur;
        TraceTag((tagPlayerNativeEffDur,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative()-finished item(%d - %g)",
                  this, m_iCurrentPlayItem, dblEffDur));

    }
    else
    {
        *iEfDur += m_pPlayer->GetCurrentTime();
        dblEffDur = *iEfDur;
        TraceTag((tagPlayerNativeEffDur,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative()-notfinished item(%d - %g)",
                  this, m_iCurrentPlayItem, dblEffDur));
    }

done:
    return;
}

void
CTIMEPlayerNative::ResetEffectiveDur()
{
    DurList::iterator iEfDur;
    ValidList::iterator iPlayed;

    m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
    m_pTIMEElementBase->clearNaturalDuration();
    for(iEfDur = m_effectiveDurList.begin(), iPlayed = m_playedList.begin();
        iEfDur != m_effectiveDurList.end(); iEfDur++, iPlayed++)
    {
        (*iEfDur) = 0.0;
        (*iPlayed) = false;
    }
}

void
CTIMEPlayerNative::TryNaturalDur()
{
    DurList::iterator iEfDur;
    ValidList::iterator iPlayed;
    double dblTotalDur = 0.0;
    bool fSetNaturalDur = true;

    if(m_fNoNaturalDur)
    {
        goto done;
    }

    for(iEfDur = m_effectiveDurList.begin(), iPlayed = m_playedList.begin();
        iEfDur != m_effectiveDurList.end(); iEfDur++, iPlayed++)
    {
        if((*iPlayed) == false)
        {
            fSetNaturalDur = false;
            break;
        }
        dblTotalDur += (*iEfDur);
    }

    if(fSetNaturalDur)
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblTotalDur);
        m_pTIMEElementBase->setNaturalDuration();
    }

done:
    return;
}

void
CTIMEPlayerNative::SetNaturalDuration(double dblMediaLength)
{
    if(!m_playList)
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblMediaLength);
        m_pTIMEElementBase->setNaturalDuration();
    }
}

void
CTIMEPlayerNative::ClearNaturalDuration()
{
    if(!m_playList)
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
        m_pTIMEElementBase->clearNaturalDuration();
    }
}


CTIMEPlayerNative *
CTIMEPlayerNative::GetNativePlayer()
{
    return this;
}


STDMETHODIMP
CTIMEPlayerNative::OnStartBinding( 
                                  /* [in] */ DWORD dwReserved,
                                  /* [in] */ IBinding __RPC_FAR *pib)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::GetPriority( 
                               /* [out] */ LONG __RPC_FAR *pnPriority)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnLowResource( 
                                 /* [in] */ DWORD reserved)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnProgress( 
                              /* [in] */ ULONG ulProgress,
                              /* [in] */ ULONG ulProgressMax,
                              /* [in] */ ULONG ulStatusCode,
                              /* [in] */ LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if (m_fAbortDownload)
    {
        hr = E_ABORT;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN1(hr, E_ABORT);
}

STDMETHODIMP
CTIMEPlayerNative::OnStopBinding( 
                                 /* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::GetBindInfo( 
                               /* [out] */ DWORD __RPC_FAR *grfBINDF,
                               /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnDataAvailable( 
                                   /* [in] */ DWORD grfBSCF,
                                   /* [in] */ DWORD dwSize,
                                   /* [in] */ FORMATETC __RPC_FAR *pformatetc,
                                   /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnObjectAvailable( 
                                     /* [in] */ REFIID riid,
                                     /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


STDMETHODIMP
CTIMEPlayerNative::CueMedia()
{
    TraceTag((tagPlayerNative,
              "CTIMEDshowPlayer(%lx)::CueMedia()",
              this));
    const WCHAR * cpchSrc = NULL;
    HRESULT hr = S_OK;
    TCHAR szCacheFileName[MAX_PATH+1];
    BOOL fReadOk;
    VARIANT_BOOL bXmlFlag;
    VARIANT fileName;
    LPOLESTR szSrc = NULL;
    WCHAR *pwcFileContent = NULL;
    LPOLESTR pEntryRef = NULL;
    std::list<LPOLESTR> asxList;
    std::list<LPOLESTR> fileNameList;
    std::list<LPOLESTR>::iterator iFileList;

    TCHAR *pwFileContent = NULL;
    OFSTRUCT fileStruct;
    char *pcFileContent = NULL;
    DWORD iFileLen, iHigh, iRead;
    HANDLE hFile;


    VariantInit(&fileName);

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;
    CComPtr<IStream> spStream;
    
    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    switch(m_eAsynchronousType)
    {
    case PLAYLIST_CD:
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,  IID_IXMLDOMDocument, (void**)&m_spXMLDoc);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = URLDownloadToCacheFileW(NULL, 
                                     cpchSrc, 
                                     szCacheFileName, 
                                     MAX_PATH, 
                                     0, 
                                     this);
        if (FAILED(hr))
        {
            hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
            goto done;
        }

        V_VT(&fileName) = VT_BSTR;
        V_BSTR(&fileName) = SysAllocString(szCacheFileName);
        hr = m_spXMLDoc->load(fileName, &bXmlFlag);
        if (FAILED(hr))
        {
            hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
            goto done;
        }
        break;
    case PLAYLIST_ASX:
            hr = LoadAsx((WCHAR *)cpchSrc, &pwcFileContent);
            if(FAILED(hr))
            {
                m_fDownloadError = true;
                hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
                goto done;
            }
            hr = CreatePlayList(pwcFileContent, asxList);
            if(FAILED(hr))
            {
                m_fDownloadError = true;
                hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
                goto done;
            }
            delete [] pwcFileContent;
            pwcFileContent = NULL;

            while(!asxList.empty())
            {
                pEntryRef = asxList.back();
                asxList.pop_back();

                for(iFileList = asxList.begin(); iFileList != asxList.end(); iFileList++)
                {
                    if(StrCmpIW((*iFileList), pEntryRef) == 0)
                    {
                        continue;
                    }
                }

                fileNameList.push_back(pEntryRef);

                hr = LoadAsx(pEntryRef, &pwcFileContent);

                pEntryRef = NULL;
                if(FAILED(hr))
                {
                    hr = S_OK;
                    break;
                }
                pEntryRef = NULL;
                if(!m_playList)
                {
                    hr = S_OK;
                    break;
                }
                hr = AddToPlayList(m_playList, pwcFileContent, asxList);
                if(FAILED(hr))
                {
                    hr = S_OK;
                    break;
                }
                delete [] pwcFileContent;
                pwcFileContent = NULL;
            }
            break;
    case MIMEDISCOVERY_ASYNCH:
        {
            // could not determine mime type from the extension.  Try to download the file to get type
            TCHAR szCacheFileName[MAX_PATH+1];
            
            CComPtr<CTIMEBindStatusCallback> pbsc;
            hr = CTIMEBindStatusCallback::CreateTIMEBindStatusCallback(&pbsc);
            if (FAILED(hr))
            {
                goto done;
            }
            
            pbsc->StopAfter(BINDSTATUS_MIMETYPEAVAILABLE);
            
            // this bind is being E_ABORTed - therefore, ignore the error.
            IGNORE_HR(URLDownloadToCacheFileW(NULL, cpchSrc, szCacheFileName, MAX_PATH, 0, pbsc));
            
            Assert(NULL == m_pszDiscoveredMimeType);
            m_pszDiscoveredMimeType = pbsc->GetStatusText() ? ::CopyString(pbsc->GetStatusText()) : NULL;
            if (NULL == m_pszDiscoveredMimeType)
            {
                // either out of memory, or we weren't able to get the mime type.
                hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
                goto done;
            }

            if(StrCmpIW(m_pszDiscoveredMimeType, L"video/x-ms-asf") == 0)
            {
                hFile = CreateFileW(szCacheFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                if(hFile == INVALID_HANDLE_VALUE)
                {
                    break;
                }

                iFileLen = GetFileSize(hFile, NULL);
                if(iFileLen > 1024)
                {
                    iFileLen = 1024;
                }

                pcFileContent = new char[iFileLen + 1];
                fReadOk = ReadFile(hFile, pcFileContent, iFileLen, &iRead, NULL);
                if((fReadOk == 0) || (iFileLen == 0))
                {
                    m_fDownloadError = true;
                    goto done;
                }

                *(pcFileContent + iRead) = 0;

                pwFileContent = new TCHAR[iRead + 1];
                MultiByteToWideChar(CP_ACP, 0, pcFileContent, -1, pwFileContent, iRead);
                *(pwFileContent + iRead) = 0;

                if(IsDownloadAsx(pwFileContent))
                {
                    delete[] m_pszDiscoveredMimeType;
                    m_pszDiscoveredMimeType = ::CopyString( L"asx");
                }
            }

            break;
        }
    default:
        break;
    }

    hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    delete [] m_pszDiscoveredMimeType;
    m_pszDiscoveredMimeType = NULL;

    delete [] pwcFileContent;
    pwcFileContent = NULL;

    delete [] pcFileContent;
    pcFileContent = NULL;

    delete [] pwFileContent;
    pwFileContent = NULL;

    VariantClear(&fileName);

    while(!fileNameList.empty())
    {
        pEntryRef = fileNameList.front();
        fileNameList.pop_front();
        delete [] pEntryRef;
        pEntryRef = NULL;
    }
    return hr;
}

bool
CTIMEPlayerNative::IsDownloadAsx(TCHAR *pwFileContent)
{
    CTIMEParser pParser(pwFileContent);
    HRESULT hr;
    bool fRet = true;

    hr = pParser.ParsePlayList(NULL, true, NULL);
    if(FAILED(hr))
    {
        fRet = false;
    }
    return fRet;
}

STDMETHODIMP
CTIMEPlayerNative::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;
/*
    Assert(NULL != plID);

    *plID = m_lSrc;
*/
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEPlayerNative::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;

    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CTIMEPlayerNative::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEPlayerNative::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}


STDMETHODIMP
CTIMEPlayerNative::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEPlayerNative::MediaDownloadError()
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerNative::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    CComPtr<IXMLDOMDocument> spXMLDoc;
    CComPtr<IXMLDOMNodeList> spXMLNodeList;
    IXMLDOMNode *pCurrNode, *pChildNode;
    IXMLDOMNodeList *pChildList = NULL;
    DOMNodeType nodeType;
    long i, lTrackNr;
    long j, lChildNr;
    long lactiveTrack = 0;
    CComBSTR trackTag = SysAllocString(L"track");
    CComBSTR bstrName;
    CComBSTR bstrText;
    VARIANT varVal;
    int iPlLen = 0, iLoopLen = 0;
    CPlayItem *pItem;
    LPOLESTR pBase, pSrc;
    PlayerList::iterator iPlayer;
    double dblClipBegin, dblClipEnd;

    TraceTag((tagPlayerNative, "CTIMEDshowPlayer(%lx)(%x)::InitializeElementAfterDownload",this));

    if(m_fRemoved)
    {
        hr = E_FAIL;
        goto done;
    }

    switch(m_eAsynchronousType)
    {
    case PLAYLIST_CD:
        if(!m_playList)
        {
            goto done;
        }

        if(m_fDownloadError)
        {
            break;
        }

        GetActiveTrack(&lactiveTrack);

        hr = m_spXMLDoc->getElementsByTagName(trackTag, &spXMLNodeList);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spXMLNodeList->get_length(&lTrackNr);
        if (FAILED(hr))
        {
            goto done;
        }

        iPlLen = m_playList->GetLength();
        if(iPlLen < lTrackNr)
        {
            iLoopLen = iPlLen;
        }
        else
        {
            iLoopLen = lTrackNr;
        }

        for(i = 0; i < iLoopLen; i++)
        {
            CPlayItem * pItem = m_playList->GetItem(i);

            if(pItem == NULL)
            {
                continue;
            }

            hr = spXMLNodeList->get_item(i, &pCurrNode);
            if(FAILED(hr))
            {
                continue;
            }
            hr = pCurrNode->get_nodeType(&nodeType);
            if(FAILED(hr))
            {
                continue;
            }
            if(nodeType != NODE_ELEMENT)
            {
                pCurrNode->Release();
                continue;
            }
            hr = pCurrNode->get_childNodes(&pChildList);
            if(FAILED(hr))
            {
                continue;
            }
            hr = pChildList->get_length(&lChildNr);
            if (FAILED(hr))
            {
                continue;
            }
            for(j = 0; j < lChildNr; j++)
            {
                hr = pChildList->get_item(j, &pChildNode);
                if (FAILED(hr))
                {
                    pChildNode->Release();
                    continue;
                }

                hr = pChildNode->get_nodeName(&bstrName);
                if (FAILED(hr))
                {
                    pChildNode->Release();
                    continue;
                }
                hr = pChildNode->get_text(&bstrText);
                if (FAILED(hr))
                {
                    pChildNode->Release();
                    continue;
                }
                if(i == lactiveTrack)
                {
                    m_pTIMEElementBase -> FireMediaEvent(PE_METAINFOCHANGED);
                }

                if(StrCmpIW(bstrName, L"name") == 0)
                {
                    pItem->PutTitle(bstrText);
                }

                if(StrCmpIW(bstrName, L"author") == 0)
                {
                    pItem->PutAuthor(bstrText);
                }

                pChildNode->Release();
            }
            pCurrNode->Release();
        }

        m_spXMLDoc.Release();
        m_spXMLDoc = NULL;
        break;
    case PLAYLIST_ASX:

        if(m_fDownloadError)
        {
            m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIAERROR);
            break;
        }

        if(m_playList)
        {
            //m_pPlayer->SetNativePlayer(this);
            CPlayItem * pItem = m_playList->GetItem(0);
            if (pItem == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        
            pSrc = (LPOLESTR)(pItem->GetSrc());
            if(pSrc == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
            m_fHardware = false;
        }

        BuildPlayer(m_playerType);

        if(m_playList && m_pPlayer)
        {
            playerList.resize(m_playList->GetLength(), NULL);
            m_durList.resize(m_playList->GetLength(), -1.0);
            m_effectiveDurList.resize(m_playList->GetLength(), 0.0);
            m_validList.resize(m_playList->GetLength(), true);
            m_playedList.resize(m_playList->GetLength(), false);
            m_pPlayer->SetPlaybackSite(this);

            iPlayer = playerList.begin();
            (*iPlayer) = m_pPlayer;
            m_pPlayer->AddRef();
            m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);
            dblClipBegin = valueNotSet;
            dblClipEnd = valueNotSet;

            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), pSrc, NULL, dblClipBegin, dblClipEnd);
            delete [] m_lpbase;
            m_lpbase = NULL;
            delete [] m_lpsrc;
            m_lpsrc = CopyString(pSrc);
            delete [] m_lpmimetype;
            m_lpmimetype = NULL;
            m_dblClipEnd = dblClipEnd;
            m_dblClipBegin = dblClipBegin;
            m_iCurrentPlayItem = 0;

        }

        break;
    case MIMEDISCOVERY_ASYNCH:
        {
            if (NULL == m_pszDiscoveredMimeType)
            {
                if (m_pTIMEElementBase != NULL)
                {
                    m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
                }
                hr = E_FAIL;
                goto done;
            }

            hr = THR(PlayerTypeFromMimeType(m_pszDiscoveredMimeType, m_lpbase, m_lpsrc, m_lpmimetype, &m_playerType));
            if (FAILED(hr))
            {
                goto done;
            }

            BuildPlayer(m_playerType);
            if (m_pPlayer)
            {
                const WCHAR * cpchSrc = NULL;
                LPOLESTR pszSrc = NULL;
                hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
                if (FAILED(hr))
                {
                    goto done;
                }

                pszSrc = ::CopyString(cpchSrc);
                if (NULL == pszSrc)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }
                delete[] m_lpsrc;
                m_lpsrc = CopyString(pszSrc);

                hr = THR(m_pPlayer->Init(m_pTIMEElementBase, NULL, pszSrc, m_lpmimetype, m_dblClipBegin, m_dblClipEnd));
                if (FAILED(hr))
                {
                    if(m_fHardware == true)
                    {
                        RemovePlayer();
                        m_fHardware = false;
                        m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                        hr = m_pPlayer->Init(m_pTIMEElementBase, NULL, pszSrc, m_lpmimetype, m_dblClipBegin, m_dblClipEnd);
                        delete [] pszSrc;
                        pszSrc = NULL;
                        if(FAILED(hr))
                        {
                            if (m_pTIMEElementBase != NULL)
                            {
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
                            }
                            goto done;
                        }
                    }
                    else
                    {
                        delete [] pszSrc;
                        pszSrc = NULL;
                    }
                    goto done;
                }
                else
                {
                    delete [] pszSrc;
                    pszSrc = NULL;
                }
            }

            break;
        }
    default:
       break;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::StartFileDownload(LPOLESTR pFileName, AsynchronousTypes eaType)
{
    HRESULT hr = S_OK;

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        m_pTIMEMediaPlayerStream = NULL;
    }

    if(m_pTIMEMediaPlayerStream == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(pFileName, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(NULL != GetImportManager());
    m_eAsynchronousType = eaType;

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerimage.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998-1999
//
//  File: src\time\media\playerimage.cpp
//
//  Contents: implementation of CTIMEImagePlayer and CAnimatedGif
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "playerimage.h"
#include "mediaelm.h"

#include "importman.h"

extern const long COLORKEY_NOT_SET = -1;

DeclareTag(tagImageTimePlayer, "TIME: Players", "CTIMEImagePlayer methods")

CTIMEImagePlayer::CTIMEImagePlayer() :
    m_cRef(0),
    m_nativeImageWidth(0),
    m_nativeImageHeight(0),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_lFrameNum(0),
    m_dblCurrentTime(0),
    m_dblPriority(INFINITE),
    m_fHavePriority(false),
    m_fLoadError(false)
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::CTIMEImagePlayer()",
              this));

    m_elemRect.top = m_elemRect.left = m_elemRect.right = m_elemRect.bottom = 0;

}

CTIMEImagePlayer::~CTIMEImagePlayer()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::~CTIMEImagePlayer()",
              this));
    m_pTIMEElementBase = NULL;

    ReleaseInterface(m_pTIMEMediaPlayerStream);
}


STDMETHODIMP_(ULONG)
CTIMEImagePlayer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
} // AddRef


STDMETHODIMP_(ULONG)
CTIMEImagePlayer::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
} // Release

STDMETHODIMP
CTIMEImagePlayer::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_POINTER;
    }

    *ppv = NULL;

    if ( IsEqualGUID(riid, IID_IUnknown) )
    {
        *ppv = static_cast<ITIMEImportMedia*>(this);
    }
    if ( IsEqualGUID(riid, IID_ITIMEImportMedia) )
    {
        *ppv = static_cast<ITIMEImportMedia*>(this);
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

HRESULT
CTIMEImagePlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != GetAtomTable());
    Assert(NULL != GetImportManager());
    Assert(NULL != m_pTIMEMediaPlayerStream);

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    // to prevent race condition, this should go 
    // after clipbegin and end have been set (105345)
    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }
      
    hr = S_OK;
done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEImagePlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::DetachFromHostElement",
              this));

    m_fRemoved = true;

    // remove this from m_spMediaDownloader
    if (m_spMediaDownloader != NULL)
    {
        IGNORE_HR(m_spMediaDownloader->RemoveImportMedia(this));
    }

    m_spMediaDownloader.Release();

    m_spImageRender.Release();
    
    m_pTIMEElementBase = NULL;
    NullAtomTable();

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEImagePlayer::InitElementSize()
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeImageWidth;
    nativeSize.bottom = m_nativeImageHeight;

    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);
    
    hr = S_OK;
done:
    return hr;
}


HRESULT 
CTIMEImagePlayer::GetNaturalHeight(long *height)
{
    if (m_nativeImageHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeImageHeight;
    }
    
    return S_OK;
}

HRESULT 
CTIMEImagePlayer::GetNaturalWidth(long *width)
{
    if (m_nativeImageWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeImageWidth;
    }

    return S_OK;
}


HRESULT
CTIMEImagePlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::SetSrc()\n",
              this));

    return hr;

}

STDMETHODIMP
CTIMEImagePlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::CueMedia()
{
    HRESULT hr = S_OK;

    TraceTag((tagImageTimePlayer, "CTIMEImagePlayer(%lx)::CueMedia()", this));

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;

    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    // this call is marshalled back to a time thread
    hr = THR(spTIMEMediaPlayer->InitializeElementAfterDownload());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::MediaDownloadError()
{
    m_fLoadError = true;
    return S_OK;
}

STDMETHODIMP
CTIMEImagePlayer::InitializeElementAfterDownload()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::InitializeElementAfterDownload()",
              this));

    HRESULT hr = S_OK;

    double dblDuration = 0.0;  // in seconds
    double dblRepeatCount = 0;

    if (m_fLoadError == true)
    {        
        if (m_pTIMEElementBase != NULL)
        {
            m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
        }
        hr = E_FAIL;
        goto done;
    }

    if (m_fRemoved)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spImageRender->GetRepeatCount(&dblRepeatCount);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spImageRender->GetDuration(&dblDuration);
    if (FAILED(hr))
    {
        goto done;
    }
        
    m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIACOMPLETE);

    {
        dblDuration = dblDuration * (dblRepeatCount + 1); //the gif's use a 0-based repeat count, so need to add one for correct duration.
        
        if (valueNotSet != m_dblClipEnd)
        {
            dblDuration = m_dblClipEnd;
        }
        dblDuration -= GetClipBegin();

        m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblDuration);
        m_pTIMEElementBase->setNaturalDuration();                        
    }
    
    hr = m_spImageRender->GetSize(&m_nativeImageWidth, &m_nativeImageHeight);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }

    m_pTIMEElementBase->InvalidateElement(NULL);

    hr = S_OK;
done:
    return hr;
}

void
CTIMEImagePlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));

    HRESULT hr = S_OK;
    VARIANT_BOOL vb = VARIANT_FALSE;

    bool bIsOn = m_pTIMEElementBase->IsOn();

    if (m_spImageRender != NULL && bIsOn)
    {
        m_dblCurrentTime = dblSegmentTime;
        
        hr = m_spImageRender->NeedNewFrame(m_dblCurrentTime, m_lFrameNum, &m_lFrameNum, &vb, GetClipBegin(), m_dblClipEnd);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (VARIANT_FALSE != vb)
        {
            m_pTIMEElementBase->InvalidateElement(NULL);
        }
    } 

    hr = S_OK;
done:
    return;    
}

void
CTIMEImagePlayer::Start()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEImagePlayer::InternalStart()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Start()",
              this));

    HRESULT hr = S_OK;

    hr = m_pTIMEElementBase->GetSize(&m_elemRect);
    if (FAILED(hr))
    {
        goto done;
    }    

    m_pTIMEElementBase->InvalidateElement(NULL);

done:
    return;
}

void
CTIMEImagePlayer::Stop()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Stop()",
              this));
}

void
CTIMEImagePlayer::Pause()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Pause()",
              this));
}

void
CTIMEImagePlayer::Resume()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Resume()",
              this));
}
    
void
CTIMEImagePlayer::Repeat()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Repeat()",
              this));
    Start();
}
    
HRESULT
CTIMEImagePlayer::Render(HDC hdc, LPRECT prc)
{
    HRESULT hr = S_OK;
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Render()",
              this));
    bool bIsOn = m_pTIMEElementBase->IsOn();

    if (m_spImageRender != NULL && bIsOn)
    {
        hr = THR(m_spImageRender->Render(hdc, prc, m_lFrameNum));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}


// Helper functions..

double 
CTIMEImagePlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;
       
    return dblCurrentTime;
}

HRESULT
CTIMEImagePlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;

    hr = S_FALSE;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMEImagePlayer::Seek(double dblTime)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT
CTIMEImagePlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    m_elemRect.bottom = prect->bottom;
    m_elemRect.left = prect->left;
    m_elemRect.right = prect->right;
    m_elemRect.top = prect->top;

    m_pTIMEElementBase->InvalidateElement(NULL);

    return hr;
}

HRESULT
CTIMEImagePlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    fcanSeek = true;

    return hr;
}


HRESULT
CTIMEImagePlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    double dblDuration = 0.0;
    double dblRepeatCount = 1;

    if (m_spImageRender)
    {
        hr = m_spImageRender->GetRepeatCount(&dblRepeatCount);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spImageRender->GetDuration(&dblDuration);
        if (FAILED(hr))
        {
            dblDuration = HUGE_VAL;
            goto done;
        }
    }
    
    
  done:

    dblLength = dblDuration;
    if (dblRepeatCount > 0.0 && dblLength != HUGE_VAL)
    {
        dblLength *= (dblRepeatCount + 1); //animate GIF's use a zero base repeat count.  Need to add one to get the correct duration
    }

    return S_OK;
}


STDMETHODIMP
CTIMEImagePlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    if (NULL == plID)
    {
        hr = E_POINTER;
        goto done;
    }

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppMediaDownloader)
{
    HRESULT hr = S_OK;

    Assert(m_spMediaDownloader == NULL);

    CComPtr<IUnknown> spDirectDraw;
    CImageDownload * pImageDownload = NULL;

    if ( m_spMediaDownloader )
    {
        hr = E_FAIL;
        goto done;
    }

    pImageDownload = new CImageDownload(GetAtomTable());
    if (pImageDownload == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }   

    pImageDownload->AddRef();

    hr = pImageDownload->Init(m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pImageDownload->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, &m_spMediaDownloader));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEImageRender, &m_spImageRender));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pTIMEElementBase->GetServiceProvider()->QueryService(SID_SDirectDraw3, IID_TO_PPV(IUnknown, &spDirectDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spImageRender->PutDirectDraw(spDirectDraw);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spMediaDownloader->AddImportMedia(this);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, ppMediaDownloader));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    ReleaseInterface(pImageDownload);
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::PutMediaDownloader(ITIMEMediaDownloader * pMediaDownloader)
{
    HRESULT hr = S_OK;

    Assert(m_spMediaDownloader == NULL);
    if (NULL == pMediaDownloader)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    m_spMediaDownloader = pMediaDownloader;

    hr = m_spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEImageRender, &m_spImageRender));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


void
CTIMEImagePlayer::PropChangeNotify(DWORD tePropType)
{
    double dblSegTime = 0.0;
    LONG lcurrRepCount = 0;

    CTIMEBasePlayer::PropChangeNotify(tePropType);

    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        TraceTag((tagImageTimePlayer,
                  "CTIMEImagePlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_TIME",
                  this));
        if (m_pTIMEElementBase)
        {
            dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
            lcurrRepCount = m_pTIMEElementBase->GetMMBvr().GetCurrentRepeatCount();
        }

        OnTick(dblSegTime, lcurrRepCount);
    }
done:
    return;
}


HRESULT
CTIMEImagePlayer::HasVisual(bool &bHasVisual)
{
    bHasVisual = true;
    return S_OK;
}

HRESULT
CTIMEImagePlayer::HasAudio(bool &bHasAudio)
{

    bHasAudio = false;

    return S_OK;
}

HRESULT
CTIMEImagePlayer::GetMimeType(BSTR *pmime)
{
    HRESULT hr = S_OK;

    *pmime = SysAllocString(L"image/unknown");
    return hr;
}


static const int ANIMATED_GIF_DUR_NOT_SET = -1;

//+-----------------------------------------------------------------------
//
//  Member:    CAnimatedGif
//
//  Overview:  Constructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CAnimatedGif::CAnimatedGif() :
    m_cRef(0),
    m_ppDDSurfaces(NULL),
    m_phbmpMasks(NULL),
    m_numGifs(0),
    m_pDelays(NULL),
    m_loop(0),
    m_pColorKeys(NULL),
    m_dblTotalDur(ANIMATED_GIF_DUR_NOT_SET),
    m_lHeight(0),
    m_lWidth(0)
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    CAnimatedGif
//
//  Overview:  destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CAnimatedGif::~CAnimatedGif()
{
    Assert(0 == m_cRef);

    int i;
    
    if (NULL != m_ppDDSurfaces)
    {
        for (i = 0; i < m_numGifs; i++)
        {
            if (m_ppDDSurfaces[i] != NULL)
            {
                m_ppDDSurfaces[i]->Release();
            }
        }
    }

    if (NULL != m_ppDDSurfaces)
    {
        MemFree(m_ppDDSurfaces);
    }
    if (NULL != m_pDelays)
    {
        MemFree(m_pDelays);
    }
    if (NULL != m_pColorKeys)
    {
        MemFree(m_pColorKeys);
    }
    if (NULL != m_phbmpMasks)
    {
        for (i = 0; i < m_numGifs; i++)
        {
            if (NULL != m_phbmpMasks[i])
            {
                BOOL bSucceeded;
                bSucceeded = DeleteObject(m_phbmpMasks[i]);
                if (FALSE == bSucceeded)
                {
                    Assert(false && "A mask bitmap was still selected into a DC");
                }
            }
        }
        MemFree(m_phbmpMasks);
    }

}

HRESULT
CAnimatedGif::Init(IUnknown * punkDirectDraw)
{
    HRESULT hr = S_OK;

    hr = punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw3, &m_spDD3));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    AddRef
//
//  Overview:  Increment reference count
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
ULONG
CAnimatedGif::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//+-----------------------------------------------------------------------
//
//  Member:    Release
//
//  Overview:  Decrement reference count, delete this when 0
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
ULONG
CAnimatedGif::Release()
{
    ULONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
        delete this;

    return l;
}


//+-----------------------------------------------------------------------
//
//  Member:    NeedNewFrame
//
//  Overview:  Decide if a new frame is needed for this image at this time
//
//  Arguments: dblNewTime   time to decide if new frame is needed for
//             iOldFrame    old frame number
//             piNewFrame   where to store new frame number
//             dblClipBegin Clip start time
//             dblClipEnd   Clip end time
//
//  Returns:   true if new frame is needed, otherwise false
//
//------------------------------------------------------------------------
bool
CAnimatedGif::NeedNewFrame(double dblNewTime, LONG lOldFrame, LONG * plNewFrame, double dblClipBegin, double dblClipEnd)
{
    Assert(NULL != plNewFrame);
    if (HUGE_VAL == dblNewTime)
    {
        return false;
    }
    if (dblNewTime < 0)
    {
        return false;
    }

    *plNewFrame = lOldFrame;

    CalcDuration();

    dblNewTime *= 1000; // milliseconds used here
    
    Assert (0.0 != m_dblTotalDur);

    long lReps = static_cast<long>((dblNewTime - 1) / m_dblTotalDur);

    if (lReps >= 1)
    {
        dblNewTime -= lReps * m_dblTotalDur;
    }

    // add in any clip begin time
    dblNewTime += dblClipBegin * 1000;  //dblClipBegin is expressed in seconds

    if (dblNewTime > m_dblTotalDur)
    {
        // the addition of the clipBegin pushed us over the strip duration.
        dblNewTime -= m_dblTotalDur;
    }

    return CalculateFrame(dblNewTime, lOldFrame, plNewFrame);
}

//+-----------------------------------------------------------------------
//
//  Member:    CalculateFrame
//
//  Overview:  Walk the frame times to determine frame number
//
//  Arguments: dblNewTime   time to decide if new frame is needed for
//             iOldFrame    old frame number
//             piNewFrame   where to store new frame number
//
//  Returns:   true if new frame is needed, otherwise false
//
//------------------------------------------------------------------------
bool
CAnimatedGif::CalculateFrame(double dblTime, LONG lOldFrame, LONG * plNewFrame)
{
    LONG i = 0;
    if ((dblTime < 0.0) || (dblTime > m_dblTotalDur))
    {
        return false;
    }
    
    if (dblTime == m_dblTotalDur)
    {
        i = m_numGifs - 1;
        goto done;
    }
    
    while (dblTime >= 0)
    {
        dblTime -= m_pDelays[i];
        i++;
        Assert(i <= m_numGifs);
    }
    i--; // go back to the previous frame (the one we are currently in)

    Assert(i < m_numGifs);
    Assert(i >= 0);
    
    if (lOldFrame == i)
    {
        return false; // we are still on the current frame
    }
  done:
    *plNewFrame = i;
    return true;
}

//+-----------------------------------------------------------------------
//
//  Member:    CalcDuration
//
//  Overview:  Sum the array of delays into member variable first time
//             following times, just return member variable
//
//  Arguments: void
//
//  Returns:   total time for 1 repitition of gif in milliseconds
//
//------------------------------------------------------------------------
double
CAnimatedGif::CalcDuration()
{
    int i = 0;

    if (NULL == m_pDelays)
    {
        return INFINITE;
    }

    if (ANIMATED_GIF_DUR_NOT_SET == m_dblTotalDur)
    {
        m_dblTotalDur = 0;
        for (i = 0; i < m_numGifs; i++)
        {
            m_dblTotalDur += m_pDelays[i];
        }
    }
    return m_dblTotalDur;
}

//+-----------------------------------------------------------------------
//
//  Member:    Render
//
//  Overview:  Render the given frame of the image
//
//  Arguments: hdc  where to render too
//             prc  bounding rectangle
//             lFrameNum    Which frame to render
//
//  Returns:   S_OK on Success, otherwise error code
//             S_FALSE if surfaces should be recreated
//
//------------------------------------------------------------------------
HRESULT
CAnimatedGif::Render(HDC hdc, LPRECT prc, LONG lFrameNum)
{
    HRESULT hr = S_OK;
    HDC hdcSrc;
    
    if (lFrameNum < 0 || lFrameNum >= m_numGifs)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    if (NULL == prc)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (NULL == m_phbmpMasks)
    {
        hr = CreateMasks();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    Assert(m_ppDDSurfaces);
    Assert(m_phbmpMasks);

    hr = THR(m_ppDDSurfaces[lFrameNum]->GetDC(&hdcSrc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(MaskTransparentBlt(hdc, prc, hdcSrc, m_lWidth, m_lHeight, m_phbmpMasks[lFrameNum]));

    IGNORE_HR(m_ppDDSurfaces[lFrameNum]->ReleaseDC(hdcSrc));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
CAnimatedGif::CreateMasks()
{
    HRESULT hr = E_FAIL;

    int i = 0;
    HDC hdcSrc = NULL;

    Assert(NULL != m_pColorKeys);
    Assert(0 < m_numGifs);

    if (m_phbmpMasks)
    {
        hr = S_OK;
        goto done;
    }

    Assert(NULL == m_phbmpMasks);

    m_phbmpMasks = (HBITMAP*)MemAllocClear(Mt(Mem), m_numGifs * sizeof(HBITMAP));
    if (NULL == m_phbmpMasks)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    for (i = 0; i < m_numGifs; i++)
    {
        hr = THR(m_ppDDSurfaces[i]->GetDC(&hdcSrc));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = CreateMask(NULL, hdcSrc, m_lWidth, m_lHeight, m_pColorKeys[i], &(m_phbmpMasks[i]));
        
        IGNORE_HR(m_ppDDSurfaces[i]->ReleaseDC(hdcSrc));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CreateMask(HDC hdcDest, 
           HDC hdcSrc, 
           LONG lWidthSrc, 
           LONG lHeightSrc, 
           COLORREF rgbTransparent,
           HBITMAP * phbmpMask,
           bool bWin95Method /* = false */)
{
    HRESULT hr = S_OK;
    
    HDC hdcMask = NULL;
    HBITMAP hbmpMask = NULL;
    HGDIOBJ hbmpOrig = NULL;
    COLORREF prevBkColorSrc = CLR_INVALID;
    
    if (NULL == phbmpMask || NULL == hdcSrc)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *phbmpMask = NULL;
    
    if (COLORKEY_NOT_SET == rgbTransparent)
    {
        hr = S_OK;
        goto done;
    }

    prevBkColorSrc = SetBkColor(hdcSrc, rgbTransparent);
    if (CLR_INVALID == prevBkColorSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    
    // create the DC for the mask
    hdcMask = CreateCompatibleDC(hdcDest);
    if (NULL == hdcMask)
    {
        hr = E_FAIL;
        goto done;
    }
    hbmpMask = CreateCompatibleBitmap(hdcMask, lWidthSrc, lHeightSrc);
    if (NULL == hbmpMask)
    {
        hr = E_FAIL;
        goto done;
    }

    hbmpOrig = SelectObject(hdcMask, hbmpMask);

    if (TIMEIsWin95() || bWin95Method)
    {
        COLORREF rgbWhite = RGB(255, 255, 255);
        COLORREF rgbBlack = RGB(0, 0, 0);
        COLORREF rgbColor;

        for (int j = 0; j < lHeightSrc; j++)
        {
            for (int i = 0; i < lWidthSrc; i++)
            {
                rgbColor = GetPixel(hdcSrc, i, j);
                if (rgbColor == rgbTransparent)
                {
                    SetPixel(hdcMask, i, j, rgbWhite);
                }
                else
                {
                    SetPixel(hdcMask, i, j, rgbBlack);
                }
            }
        }
    }
    else
    {
        // Create the mask
        BitBlt(hdcMask, 0, 0, lWidthSrc, lHeightSrc, hdcSrc, 0, 0, SRCCOPY);
    }

#ifdef NEVER
    // jeffwall 04/03/00 debugging blt to screen
    {
        HDC nullDC = GetDC(NULL);

        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc, hdcMask, 0, 0, SRCCOPY);

        DeleteDC(nullDC);
    }
#endif

    hr = S_OK;
done:
    if (CLR_INVALID != prevBkColorSrc)
        SetBkColor(hdcSrc, prevBkColorSrc);

    if (hbmpOrig)
        SelectObject(hdcMask, hbmpOrig);
    if (hdcMask)
        DeleteDC(hdcMask);

    if (S_OK == hr && phbmpMask)
        *phbmpMask = hbmpMask;
    else if (NULL != hbmpMask)
        DeleteObject(hbmpMask);
        
    RRETURN(hr);
}
           
                          
HRESULT
MaskTransparentBlt(HDC hdcDest, 
                   LPRECT prcDest, 
                   HDC hdcSrc, 
                   LONG lWidthSrc, 
                   LONG lHeightSrc,
                   HBITMAP hbmpMask)
{
    HRESULT hr = S_OK;

    HDC hdcMask = NULL;
    HGDIOBJ hbmpOrig = NULL;

    COLORREF prevBkColorDest = CLR_INVALID;
    COLORREF prevTextColorDest = CLR_INVALID;

    int iOrigBltMode = 0;

    int top, left, width, height;

    if (NULL == prcDest || NULL == hdcDest || NULL == hdcSrc)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    top = prcDest->top;
    left = prcDest->left;
    width = prcDest->right - prcDest->left;
    height = prcDest->bottom - prcDest->top;
    
    iOrigBltMode = SetStretchBltMode(hdcDest, COLORONCOLOR);
    if (0 == iOrigBltMode)
    {
        hr = E_FAIL;
        goto done;
    }

    if (NULL == hbmpMask)
    {
        StretchBlt(hdcDest, left, top, width, height,
                   hdcSrc, 0, 0, lWidthSrc, lHeightSrc, SRCCOPY);
        hr = S_OK;
        goto done;
    }
    
    prevBkColorDest = SetBkColor(hdcDest, RGB(255, 255, 255));
    if (CLR_INVALID == prevBkColorDest)
    {
        hr = E_FAIL;
        goto done;
    }
    prevTextColorDest = SetTextColor(hdcDest, RGB(0, 0, 0));
    if (CLR_INVALID == prevTextColorDest)
    {
        hr = E_FAIL;
        goto done;
    }

    // create the DC for the mask
    hdcMask = CreateCompatibleDC(hdcDest);
    if (NULL == hdcMask)
    {
        hr = E_FAIL;
        goto done;
    }

    hbmpOrig = SelectObject(hdcMask, hbmpMask);
    if (NULL == hbmpOrig)
    {
        hr = E_FAIL;
        goto done;
    }

#ifdef NEVER
    // jeffwall 03/20/00 - debugging blt to screen
    {
        HDC nullDC = GetDC(NULL);
        
        // transparentblt to the screen
        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc,
               hdcSrc, 0, 0, SRCINVERT);
        
        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc,
               hdcMask, 0, 0, SRCAND);
        
        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc,
               hdcSrc, 0, 0, SRCINVERT);
    
        DeleteDC(nullDC);
    }
#endif

    StretchBlt(hdcDest, left, top, width, height,
               hdcSrc, 0, 0, lWidthSrc, lHeightSrc, SRCINVERT);

    StretchBlt(hdcDest, left, top, width, height,
               hdcMask, 0, 0, lWidthSrc, lHeightSrc, SRCAND);

    StretchBlt(hdcDest, left, top, width, height,
               hdcSrc, 0, 0, lWidthSrc, lHeightSrc, SRCINVERT);

    hr = S_OK;
done:
    if (hbmpOrig)
    {
        SelectObject(hdcMask, hbmpOrig);
    }
    if (hdcMask)
    {
        DeleteDC(hdcMask);
    }

    if (CLR_INVALID != prevBkColorDest)
    {
        SetBkColor(hdcDest, prevBkColorDest);
    }
    if (CLR_INVALID != prevTextColorDest)
    {
        SetTextColor(hdcDest, prevTextColorDest);
    }

    if (0 != iOrigBltMode)
    {
        SetStretchBltMode(hdcDest, iOrigBltMode);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\playerproxy.h
//
//  Contents: implementation of CTIMEPlayerProxy
//
//------------------------------------------------------------------------------------
#include "headers.h"

#include "playerproxy.h"

DeclareTag(tagPlayerProxy, "TIME: PlayerProxy", "CTIMEPlayerProxy method")

#define ENTER_METHOD \
    Assert(NULL != m_pBasePlayer); \
    CritSectGrabber cs(m_CriticalSection);


CTIMEPlayerProxy::CTIMEPlayerProxy() :
  m_pBasePlayer(NULL),
  m_pNativePlayer(NULL),
  m_fBlocked(false)
{
}

CTIMEPlayerProxy::~CTIMEPlayerProxy()
{
    m_pBasePlayer = NULL;
}

HRESULT
CTIMEPlayerProxy::Init()
{
    return S_OK;
}

STDMETHODIMP_(ULONG)
CTIMEPlayerProxy::AddRef()
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->AddRef();
}
STDMETHODIMP_(ULONG)
CTIMEPlayerProxy::Release()
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->Release();
}

STDMETHODIMP
CTIMEPlayerProxy::QueryInterface(REFIID riid, void ** ppunk)
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->QueryInterface(riid, ppunk);
}

HRESULT
CTIMEPlayerProxy::Init(CTIMEMediaElement* pelem,
                       LPOLESTR base, 
                       LPOLESTR src, 
                       LPOLESTR lpMimeType, 
                       double dblClipBegin, 
                       double dblClipEnd)
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
}

HRESULT
CTIMEPlayerProxy::DetachFromHostElement()
{
    m_pNativePlayer = NULL;
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->DetachFromHostElement();
}

HRESULT
CTIMEPlayerProxy::GetExternalPlayerDispatch(IDispatch** ppDisp)
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->GetExternalPlayerDispatch(ppDisp);
}

void
CTIMEPlayerProxy::Block()
{
    ENTER_METHOD

    m_fBlocked = true;
}

void
CTIMEPlayerProxy::UnBlock()
{
    ENTER_METHOD

    m_fBlocked = false;
}

bool
CTIMEPlayerProxy::CanCallThrough()
{
    return !m_fBlocked;
}

ITIMEBasePlayer*
CTIMEPlayerProxy::GetInterface()
{
    return m_pBasePlayer;
}

void
CTIMEPlayerProxy::SetPlaybackSite(CTIMEBasePlayer *pSite)
{
    m_pNativePlayer = pSite;
    if(m_pBasePlayer)
    {
        m_pBasePlayer->SetPlaybackSite(pSite);
    }
}

void
CTIMEPlayerProxy::FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer)
{
    CComPtr<ITIMEBasePlayer> spbasePlayer = static_cast<ITIMEBasePlayer*>(this);

    if(m_pNativePlayer)
    {
        m_pNativePlayer->FireMediaEvent(plEvent, spbasePlayer);
    }
}


#define DEFINE_METHOD(method) \
HRESULT \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
    \
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
    \
    RRETURN(hr); \
}

#define DEFINE_METHOD1(method, type1, arg1) \
HRESULT \
CTIMEPlayerProxy::method(type1 arg1) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
\
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(arg1); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
\
    RRETURN( hr ); \
}

#define DEFINE_METHOD2(method, type1, arg1, type2, arg2) \
HRESULT \
CTIMEPlayerProxy::method(type1 arg1, type2 arg2) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
\
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(arg1, arg2); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
\
    RRETURN( hr ); \
}

#define DEFINE_METHOD3(method, type1, arg1, type2, arg2, type3, arg3) \
HRESULT \
CTIMEPlayerProxy::method(type1 arg1, type2 arg2, type3 arg3) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
\
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(arg1, arg2, arg3); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
\
    RRETURN( hr ); \
}

#define DEFINE_METHOD_(returntype, method) \
returntype \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    returntype retval = 0; \
    \
    if (CanCallThrough()) \
    { \
        retval = m_pBasePlayer->method(); \
    } \
    return retval; \
}

#define DEFINE_METHOD_SPECIAL(returntype, defaultvalue, method) \
returntype \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    returntype retval = defaultvalue; \
    \
    if (CanCallThrough()) \
    { \
        retval = m_pBasePlayer->method(); \
    } \
    return retval; \
}

#define DEFINE_METHOD1_void(method, type1, arg1) \
void \
CTIMEPlayerProxy::method(type1 arg1) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    if (CanCallThrough()) \
    { \
        m_pBasePlayer->method(arg1); \
    } \
    return; \
}

#define DEFINE_METHOD_void(method) \
void \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    if (CanCallThrough()) \
    { \
        m_pBasePlayer->method(); \
    } \
    return; \
}


DEFINE_METHOD_void(Start);
DEFINE_METHOD_void(Stop);
DEFINE_METHOD_void(Pause);
DEFINE_METHOD_void(Resume);
DEFINE_METHOD_void(Repeat);
DEFINE_METHOD1(Seek, double, dblTime);

DEFINE_METHOD1(HasMedia, bool&, fHasMedia);
DEFINE_METHOD1(HasVisual, bool&, fHasVideo);
DEFINE_METHOD1(HasAudio, bool&, fHasAudio);
DEFINE_METHOD1(CanSeek, bool&, fCanSeek);
DEFINE_METHOD1(CanPause, bool&, fCanPause);
DEFINE_METHOD1(CanSeekToMarkers, bool&, bcanSeekToM);
DEFINE_METHOD1(IsBroadcast, bool&, bisBroad);
DEFINE_METHOD1(HasPlayList, bool&, fHasPlayList);

//DEFINE_METHOD(Reset);
//DEFINE_METHOD_SPECIAL(PlayerState, PLAYER_STATE_UNKNOWN, GetState);
DEFINE_METHOD1_void(PropChangeNotify, DWORD, tePropType);
DEFINE_METHOD1_void(ReadyStateNotify, LPWSTR, szReadyState);
DEFINE_METHOD_(bool, UpdateSync);
DEFINE_METHOD_void(Tick);

DEFINE_METHOD2(Render, HDC, hdc, LPRECT, prc);
DEFINE_METHOD1(GetNaturalHeight, long*, plHeight);
DEFINE_METHOD1(GetNaturalWidth, long*, plWidth);
DEFINE_METHOD1(SetSize, RECT*, prect);

DEFINE_METHOD1(GetMediaLength, double&,  dblLength);
DEFINE_METHOD1(GetEffectiveLength, double&, dblLength);
DEFINE_METHOD1_void(GetClipBegin, double&, dblClipBegin);
DEFINE_METHOD1_void(SetClipBegin, double, dblClipBegin);
DEFINE_METHOD1_void(GetClipEnd, double&, dblClipEnd);
DEFINE_METHOD1_void(SetClipEnd, double, dblClipEnd);
DEFINE_METHOD1_void(GetClipBeginFrame, long&, lClipBegin);
DEFINE_METHOD1_void(SetClipBeginFrame, long, lClipBegin);
DEFINE_METHOD1_void(GetClipEndFrame, long&, lClipEnd);
DEFINE_METHOD1_void(SetClipEndFrame, long, lClipEnd);
DEFINE_METHOD_(double, GetCurrentTime); //lint !e123
//DEFINE_METHOD1(GetCurrentSyncTime, double&, dblSyncTime);
DEFINE_METHOD1(SetRate, double, dblRate);
DEFINE_METHOD1(GetRate, double&, dblRate);
DEFINE_METHOD1(GetEarliestMediaTime, double&, dblEarliestMediaTime);
DEFINE_METHOD1(GetLatestMediaTime, double&, dblLatestMediaTime);
DEFINE_METHOD1(SetMinBufferedMediaDur, double, dblMinBufferedMediaDur);
DEFINE_METHOD1(GetMinBufferedMediaDur, double&, dblMinBufferedMediaDur);
//DEFINE_METHOD1(GetDownloadTotal, LONGLONG&, lldlTotal);
//DEFINE_METHOD1(GetDownloadCurrent, LONGLONG&, lldlCurrent);
DEFINE_METHOD1(GetIsStreamed, bool&, fIsStreamed);
DEFINE_METHOD1(GetBufferingProgress, double&, dblBufferingProgress);
//DEFINE_METHOD1(GetHasDownloadProgress, bool&, fHasDownloadProgress);
DEFINE_METHOD1(GetMimeType, BSTR*, pAuthor);
DEFINE_METHOD2(ConvertFrameToTime, LONGLONG, iFrame, double&, dblTime);
DEFINE_METHOD1(GetCurrentFrame, LONGLONG&, frameNR);
DEFINE_METHOD1(GetPlaybackOffset, double&, dblOffset);
DEFINE_METHOD1(GetEffectiveOffset, double&, dblOffset);


DEFINE_METHOD2(SetSrc, LPOLESTR, base, LPOLESTR, src);
DEFINE_METHOD1(GetAuthor, BSTR*, pAuthor);
DEFINE_METHOD1(GetTitle, BSTR*, pTitle);
DEFINE_METHOD1(GetCopyright, BSTR*, pCopyright);
DEFINE_METHOD1(GetAbstract, BSTR*, pAbstract);
DEFINE_METHOD1(GetRating, BSTR*, pRating);
DEFINE_METHOD1(GetVolume, float*, pflVolume);
DEFINE_METHOD1(SetVolume, float, flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
DEFINE_METHOD1(GetBalance, float*, pflBalance);
DEFINE_METHOD1(SetBalance, float, flBalance);
#endif
DEFINE_METHOD1(GetMute, VARIANT_BOOL *, pvarMute);
DEFINE_METHOD1(SetMute, VARIANT_BOOL, varMute);
DEFINE_METHOD3(Save, IPropertyBag2*, pPropBag, BOOL, fClearDirty, BOOL, fSaveAllProperties);

DEFINE_METHOD1(GetPlayList, ITIMEPlayList**, ppPlayList);

DEFINE_METHOD2(onMouseMove, long, x, long, y);
DEFINE_METHOD2(onMouseDown, long, x, long, y);

DEFINE_METHOD1_void(LoadFailNotify, PLAYER_EVENT, reason);


PlayerState
CTIMEPlayerProxy::GetState()
{
    ENTER_METHOD

    return m_pBasePlayer->GetState();
}

HRESULT
CTIMEPlayerProxy::Reset()
{
    ENTER_METHOD

    return m_pBasePlayer->Reset();
}

HRESULT
CTIMEPlayerProxy::GetCurrentSyncTime(double & dblSyncTime)
{
    ENTER_METHOD

    return m_pBasePlayer->GetCurrentSyncTime(dblSyncTime);
}



HRESULT
CTIMEPlayerProxy::GetDownloadTotal(LONGLONG &lldlTotal)
{
    ENTER_METHOD

    return m_pBasePlayer->GetDownloadTotal(lldlTotal);
}

HRESULT
CTIMEPlayerProxy::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    ENTER_METHOD

    return m_pBasePlayer->GetDownloadCurrent(lldlCurrent);
}


HRESULT
CTIMEPlayerProxy::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    ENTER_METHOD

    return m_pBasePlayer->GetHasDownloadProgress(fHasDownloadProgress);
}

HRESULT
CTIMEPlayerProxy::GetDownloadProgress(double &dblDownloadProgress)
{
    ENTER_METHOD

    return m_pBasePlayer->GetDownloadProgress(dblDownloadProgress);
}

HRESULT 
CTIMEPlayerProxy::NotifyTransitionSite (bool fTransitionToggle)
{
    ENTER_METHOD

    return m_pBasePlayer->NotifyTransitionSite(fTransitionToggle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playlist.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "playlist.h"
#include "util.h"
#include "playerbase.h"

DeclareTag(tagPlayList, "TIME: Behavior", "CPlayList methods")
DeclareTag(tagPlayItem, "TIME: Behavior", "CPlayItem methods")

//*******************************************************************************
// *  CPlayList
// *******************************************************************************
CPlayList::CPlayList()
: m_rgItems(NULL),
  m_player(NULL),
  m_fLoaded(false)
{
    TraceTag((tagPlayList,
          "CPlayList(%lx)::CPlayList()",
          this));
}

///////////////////////////////////////////////////////////////
//  Name: ~CPlayList
// 
//  Abstract:  Handles destruction of the items array and
//             releasing all pointers in the array
///////////////////////////////////////////////////////////////
CPlayList::~CPlayList()
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::~CPlayList()",
        this));

    Deinit();

    delete m_rgItems;
    m_rgItems = NULL;
    m_player = NULL;
}

///////////////////////////////////////////////////////////////
//  Name: Init
// 
//  Abstract:  Handles allocation of the items array if it 
//             is ever accessed.
///////////////////////////////////////////////////////////////
HRESULT
CPlayList::Init(CTIMEBasePlayer & player)
{
    HRESULT hr;

    m_player = &player;
    
    if (m_rgItems == NULL)
    {
        m_rgItems = new CPtrAry<CPlayItem *>;
        if (m_rgItems == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}

void
CPlayList::Deinit()
{
    m_player = NULL;

    Clear();
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoaded(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;

        if (m_fLoaded && V_VT(&m_vNewTrack) != VT_NULL)
        {
            IGNORE_HR(put_activeTrack(m_vNewTrack));
        }

        m_vNewTrack.Clear();
    }
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoadedFlag(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;
    }
}

///////////////////////////////////////////////////////////////
//  Name: get_length
// 
//  Abstract:  returns the size of the array
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get_length(long *len)
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::get_length()",
        this));
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(len);

    *len = GetLength();

    hr = S_OK;

  done:

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: get__newEnum
// 
//  Abstract:  Creates the IEnumVARIANT class for this
//             collection.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get__newEnum(IUnknown** p)
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::get__newEnum()",
        this));

    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(p);

    hr = THR(CComObject<CPlayListEnum>::CreateInstance(&pNewEnum));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*this);

    hr = THR(pNewEnum->QueryInterface(IID_IUnknown, (void **)p));
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: item
// 
//  Abstract:  returns the item requested by the pvarIndex.  
//             varIndex must be a valid integer value.or 
//             valid string title
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::item(VARIANT varIndex, ITIMEPlayItem **pPlayItem)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::item()",
              this));

    HRESULT hr;
    VARIANT vIndex;

    CHECK_RETURN_SET_NULL(pPlayItem);

    VariantInit(&vIndex);

    hr = THR(VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_I4));
    if (SUCCEEDED(hr)) //handle the case of an index.
    {
        if (vIndex.lVal >= 0 && vIndex.lVal < m_rgItems->Size())
        {
            *pPlayItem = m_rgItems->Item(vIndex.lVal);
        } 
    }
    else
    {
        long lIndex;
        
        hr = THR(VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_BSTR));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        lIndex = GetIndex(vIndex.bstrVal);
        if (lIndex != -1)
        {
            *pPlayItem = m_rgItems->Item(lIndex);
        }
    }
    
    if (*pPlayItem != NULL)
    {
        (*pPlayItem)->AddRef();
    } 
    
    hr = S_OK;
  done:

    VariantClear(&vIndex);
    return hr;
}

STDMETHODIMP
CPlayList::put_activeTrack(/*[in]*/ VARIANT vTrack)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::put_activeTrack()",
              this));
    
    CComPtr <ITIMEPlayItem> pPlayItem;
    long index;
    HRESULT hr;

    // If not active then just ignore everything
    if (m_player == NULL ||
        !m_player->IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    // if this is not loaded, then delay setting of the track
    if (!m_fLoaded)
    {
        m_vNewTrack = vTrack;
        hr = S_OK;
        goto done; 
    }

    hr = item(vTrack, &pPlayItem);    
    if (FAILED(hr))
    {
        goto done;
    }

    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(pPlayItem->get_index(&index));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_player->SetActiveTrack(index));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayList::get_activeTrack(/*[out, retval]*/ ITIMEPlayItem **pPlayItem)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::get_activeTrack()",
              this));

    HRESULT hr;
    CPlayItem * p;

    CHECK_RETURN_SET_NULL(pPlayItem);

    if (m_player == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    p = GetActiveTrack();
    if (p == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(p->QueryInterface(IID_ITIMEPlayItem,
                               (void **) pPlayItem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//Advances the active Track by one
STDMETHODIMP
CPlayList::nextTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(pPlayItem->get_index(&lIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_player->SetActiveTrack(lIndex + 1));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//moves the active track to the previous track
STDMETHODIMP
CPlayList::prevTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(pPlayItem->get_index(&lIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    if (lIndex > 0) //if this is not the first track
    {
        lIndex--;
    }

    hr = THR(m_player->SetActiveTrack(lIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//returns the duration of the entire playlist if it is known or -1 if it is not.
STDMETHODIMP
CPlayList::get_dur(double *dur)
{
    HRESULT hr;
    int i;
    double totalDur = 0;

    CHECK_RETURN_NULL(dur);

    *dur = TIME_INFINITE;

    //loop through all playitems.  
    for (i = 0; i < GetLength(); i++)
    {
        double duration;
        CPlayItem * pPlayItem = GetItem(i);

        hr = THR(pPlayItem->get_dur(&duration));
        if (FAILED(hr))
        {
            goto done;          
        }
        
        if (duration == TIME_INFINITE)
        {
            goto done;      
        }
        
        totalDur += duration;
    }
    
    *dur = totalDur;

    hr = S_OK;
  done:
    return hr;
}

// ========================================
// Internal functions
// ========================================


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayList::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayList::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = THR(NotifyPropertySinkCP(pICP, dispid));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged


CPlayItem *
CPlayList::GetActiveTrack()
{
    HRESULT hr;
    long l;
    CPlayItem * ppiRet = NULL;
    
    hr = THR(m_player->GetActiveTrack(&l));
    if (FAILED(hr))
    {
        goto done;
    }

    ppiRet = GetItem(l);
  done:
    return ppiRet;
}

CPlayItem *
CPlayList::GetItem(long index)
{
    CPlayItem * ppiRet = NULL;

    if (index >= 0 && index < m_rgItems->Size())
    {
        ppiRet = m_rgItems->Item(index);
    }

    return ppiRet;
}

HRESULT
CPlayList::Add(CPlayItem *pPlayItem, long index)
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::add()",
        this));
    HRESULT hr = S_OK;

    if (pPlayItem == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pPlayItem->AddRef();
    if (index == -1)
    {
        m_rgItems->Append(pPlayItem);
    }
    else
    {
        m_rgItems->Insert(index, pPlayItem);
    }

    // notify that length changed
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH));

    SetIndex();
  done:
    return hr;
}


HRESULT
CPlayList::Remove(long index)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::remove()",
              this));
    HRESULT hr;
    
    if (index >= 0 && index < m_rgItems->Size())
    {
        m_rgItems->Item(index)->Deinit();
        m_rgItems->ReleaseAndDelete(index);
    }

    // notify that length changed
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH));

    SetIndex();
    hr = S_OK;
  done:
    return hr;
}


//empties the current playlist.
void
CPlayList::Clear()
{
    if (m_rgItems)
    {
        while (m_rgItems->Size() > 0)
        {   //release and delete the first element of the list until there are no more elements
            m_rgItems->Item(0)->Deinit();
            m_rgItems->ReleaseAndDelete(0);  //release the 
        }
    }

    m_vNewTrack.Clear();
}


////////////////////////////////////////////////////////////////////////////////
// creates an empty playitem.  The info in this needs to be filled by the player.
// This also needs to be added to the playlist collection by the player.
////////////////////////////////////////////////////////////////////////////////
HRESULT
CPlayList::CreatePlayItem(CPlayItem **pPlayItem)
{   
    TraceTag((tagPlayList,
              "CPlayList(%lx)::createPlayItem()",
              this));

    HRESULT hr;
    CComObject<CPlayItem> * pItem;
    
    Assert(pPlayItem != NULL);

    hr = THR(CComObject<CPlayItem>::CreateInstance(&pItem));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pItem->Init(*this);

    *pPlayItem = static_cast<CPlayItem *>(pItem);
    pItem->AddRef();
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CPlayList::SetIndex()
{
    long i = 0;
    long length = m_rgItems->Size();

    for (i = length-1; i >= 0; i--)
    {
        m_rgItems->Item(i)->PutIndex(i);
    }
}

long 
CPlayList::GetIndex(LPOLESTR lpstrTitle)
{
    long curIndex = -1;

    for(long i = GetLength()-1; i >= 0; i--)
    {
        CPlayItem * pItem = m_rgItems->Item(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwTitle = pItem->GetTitle();
            
            if (lpwTitle != NULL &&
                StrCmpIW(lpwTitle, lpstrTitle) == 0)
            {
                curIndex = i;
                break;
            }
        }
    }

    return curIndex;
}

//*******************************************************************************
// *  CActiveElementEnum
// *******************************************************************************
CPlayListEnum::CPlayListEnum()
: m_lCurElement(0)
{
}



CPlayListEnum::~CPlayListEnum()
{
}


///////////////////////////////////////////////////////////////
//  Name: Clone
// 
//  Abstract:  Creates a new instance of this object and 
//             sets the m_lCurElement in the new object to
//             the same value as this object.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Clone(IEnumVARIANT **ppEnum)
{
    TraceTag((tagPlayList,
              "CPlayListEnum(%lx)::Clone()",
              this));

    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(ppEnum);

    hr = THR(CComObject<CPlayListEnum>::CreateInstance(&pNewEnum));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*m_playList);

    pNewEnum->SetCurElement(m_lCurElement);

    hr = THR(pNewEnum->QueryInterface(IID_IEnumVARIANT, (void **)ppEnum));
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: Next
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Next(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched)
{
    HRESULT hr = S_OK;
    unsigned long i = 0;
    long iCount = 0;
    
    CHECK_RETURN_NULL(rgVar);
    
    //initialize the list
    for (i = 0; i < celt; i++)
    {
        VariantInit(&rgVar[i]);   
    }

    for (i = 0; i < celt; i++)
    {    
        if (m_lCurElement < m_playList->GetLength())
        {
            CPlayItem * pPlayItem = m_playList->GetItem(m_lCurElement);

            Assert(pPlayItem != NULL);
            
            rgVar[i].vt = VT_DISPATCH;
            hr = THR(pPlayItem->QueryInterface(IID_IDispatch, (void **) &(rgVar[i].pdispVal)));
            if (FAILED(hr))
            {
                goto done;
            }

            m_lCurElement++;
            iCount++;
        }
        else
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = S_OK;
  done:
    if (pCeltFetched != NULL)
    {
        *pCeltFetched = iCount;
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Reset
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Reset()
{    
    m_lCurElement = 0;
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Skip
// 
//  Abstract:  Skips the specified number of elements in the list.
//             This returns S_FALSE if there are not enough elements
//             in the list to skip.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Skip(unsigned long celt)
{
    HRESULT hr;
    long lLen = m_playList->GetLength();
    
    m_lCurElement += (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: SetCurElement
// 
//  Abstract:  Sets the current index to the value specified
//             by celt.
///////////////////////////////////////////////////////////////
void
CPlayListEnum::SetCurElement(unsigned long celt)
{
    long lLen = m_playList->GetLength();

    m_lCurElement = (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
    }

    return;
}

//////////////////////////////////////////////////////
//  CPlayItem methods
//
CPlayItem::CPlayItem()
:   m_pPlayList(NULL),
    m_src(NULL),
    m_title(NULL),
    m_copyright(NULL),
    m_author(NULL),
    m_abstract(NULL),
    m_rating(NULL),
    m_lIndex(-1),
    m_dur(valueNotSet),
    m_fCanSkip(true),
    m_banner(NULL),
    m_bannerAbstract(NULL),
    m_bannerMoreInfo(NULL)
{
    TraceTag((tagPlayList,
              "CPlayItem(%lx)::CPlayItem()",
              this));
}

CPlayItem::~CPlayItem() 
{
    TraceTag((tagPlayList,
        "CPlayItem(%lx)::~CPlayItem()",
        this));

    m_pPlayList = NULL;
    delete [] m_src;
    delete [] m_title;
    delete [] m_copyright;
    delete [] m_author;
    delete [] m_abstract;
    delete [] m_rating;
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
}

void 
CPlayItem::PutDur(double dur)
{ 
    m_dur = dur; 

    // notify that playlist's dur has changed
    if (m_pPlayList)
    {
        IGNORE_HR(m_pPlayList->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_DUR));
    }

    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_DUR));
}


void 
CPlayItem::PutIndex(long index) 
{ 
    m_lIndex = index; 
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_INDEX));
}


STDMETHODIMP
CPlayItem::setActive()
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::setActive()",
              this));

    VARIANT vIndex;
    HRESULT hr = S_OK;

    VariantInit(&vIndex);
    vIndex.vt = VT_I4;
    vIndex.lVal = m_lIndex;

    hr = m_pPlayList->put_activeTrack(vIndex);
    VariantClear(&vIndex);
    if (FAILED(hr))
    {   
        goto done;
    }   

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CPlayItem::get_index(long *index)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_index()",
              this));

    HRESULT hr;

    CHECK_RETURN_NULL(index);

    *index = m_lIndex;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CPlayItem::get_dur(double *dur)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_dur()",
              this));

    HRESULT hr;

    CHECK_RETURN_NULL(dur);

    if (valueNotSet == m_dur)
    {
        *dur = TIME_INFINITE;
    }
    else
    {
        *dur = m_dur;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CPlayItem::get_src(LPOLESTR *src)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_src()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(src);

    *src = SysAllocString(m_src?m_src:L"");

    if (*src == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_title(LPOLESTR *title)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_title()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(title);

    *title = SysAllocString(m_title?m_title:L"");
    if (*title == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_copyright(LPOLESTR *cpyrght)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_copyright()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(cpyrght);

    *cpyrght = SysAllocString(m_copyright?m_copyright:L"");
    if (*cpyrght == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}


STDMETHODIMP
CPlayItem::get_author(LPOLESTR *auth)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_author()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(auth);

    *auth = SysAllocString(m_author?m_author:L"");
    if (*auth == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_banner(LPOLESTR *banner)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_banner()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(banner);

    *banner = SysAllocString(m_banner?m_banner:L"");
    if (*banner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_bannerAbstract(LPOLESTR *abstract)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_bannerAbstract()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_bannerAbstract?m_bannerAbstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_bannerMoreInfo(LPOLESTR *moreInfo)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_bannerMoreInfo()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(moreInfo);

    *moreInfo = SysAllocString(m_bannerMoreInfo?m_bannerMoreInfo:L"");
    if (*moreInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_abstract(LPOLESTR *abstract)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_abstract()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_abstract?m_abstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_rating(LPOLESTR *rate)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_rating()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(rate);

    *rate = SysAllocString(m_rating?m_rating:L"");
    if (*rate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}


HRESULT
CPlayItem::PutSrc(LPOLESTR src)
{
    HRESULT hr;
    
    delete m_src;
    m_src = NULL;
    
    if (src)
    {
        m_src = CopyString(src);
        if (m_src == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_SRC));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutTitle(LPOLESTR title)
{
    HRESULT hr;
    
    delete m_title;
    m_title = NULL;
    
    if (title)
    {
        m_title = CopyString(title);
        if (m_title == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_TITLE));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutCopyright(LPOLESTR copyright)
{
    HRESULT hr;
    
    delete m_copyright;
    m_copyright = NULL;
    
    if (copyright)
    {
        m_copyright = CopyString(copyright);
        if (m_copyright == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_COPYRIGHT));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutAuthor(LPOLESTR author)
{
    HRESULT hr;
    
    delete m_author;
    m_author = NULL;
    
    if (author)
    {
        m_author = CopyString(author);
        if (m_author == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_AUTHOR));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutAbstract(LPOLESTR abstract)
{
    HRESULT hr;
    
    delete m_abstract;
    m_abstract = NULL;
    
    if (abstract)
    {
        m_abstract = CopyString(abstract);
        if (m_abstract == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_ABSTRACT));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutRating(LPOLESTR rating)
{
    HRESULT hr;
    
    delete m_rating;
    m_rating = NULL;
    
    if (rating)
    {
        m_rating = CopyString(rating);
        if (m_rating == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_RATING));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT 
CPlayItem::PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo)
{

    HRESULT hr;
    
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
    
    m_banner = NULL;
    m_bannerAbstract = NULL;
    m_bannerMoreInfo = NULL;
    
    if (banner)
    {
        m_banner = CopyString(banner);
        if (m_banner == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (abstract)
        {
            m_bannerAbstract = CopyString(abstract);
            if (m_bannerAbstract == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
        
        if (moreInfo)
        {
            m_bannerMoreInfo = CopyString(moreInfo);
            if (m_bannerMoreInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_BANNER));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayItem::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayItem::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = THR(NotifyPropertySinkCP(pICP, dispid));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playerproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\playerproxy.h
//
//  Contents: declaration for CTIMEPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _PLAYERDSHOWPROXY_H__
#define _PLAYERDSHOWPROXY_H__

#include "playerbase.h"

class CTIMEPlayerProxy :
    public ITIMEBasePlayer
{

  protected:
    // This class should never be NEW'ed.  
    // Instead create a specific proxy class derived from this class.
    CTIMEPlayerProxy();

  public:
    virtual ~CTIMEPlayerProxy();

    void Block();
    void UnBlock();
    bool CanCallThrough();
    ITIMEBasePlayer *GetInterface();

    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk);
    virtual HRESULT Init(CTIMEMediaElement *pelem, 
                         LPOLESTR base, 
                         LPOLESTR src, 
                         LPOLESTR lpMimeType = NULL, 
                         double dblClipBegin = -1.0, 
                         double dblClipEnd = -1.0);
    virtual HRESULT DetachFromHostElement (void);
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);
    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual void Start();
    virtual void Stop();
    virtual void Pause();
    virtual void Resume();
    virtual void Repeat();
    virtual HRESULT Seek(double dblTime);
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT CanSeek(bool &fcanSeek);
    virtual HRESULT CanPause(bool &fcanPause);
    virtual HRESULT CanSeekToMarkers(bool &bcanSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT HasPlayList(bool &fHasPlayList);

    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: END
    //////////////////////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Reset();
    virtual PlayerState GetState();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();
    virtual void Tick();
    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Render(HDC hdc, LPRECT prc);
    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);
    virtual HRESULT SetSize(RECT *prect);
    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetMediaLength(double &dblLength);
    virtual HRESULT GetEffectiveLength(double &dblLength);
    virtual void GetClipBegin(double &dblClipBegin);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void GetClipEnd(double &dblClipEnd);
    virtual void SetClipEnd(double dblClipEnd);
    virtual void GetClipBeginFrame(long &lClibBeginFrame);
    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void GetClipEndFrame(long &lClipEndFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);
    virtual double GetCurrentTime();
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);
    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PROPERTY ACCESSORS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pRating) ;
    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    //////////////////////////////////////////////////////////////////////////
    // PROPERTY METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle);
    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PLAYLIST METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);
    //////////////////////////////////////////////////////////////////////////
    // PLAYLIST METHODS: END
    //////////////////////////////////////////////////////////////////////////

    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT ConvertFrameToTime(LONGLONG iFrame, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);
    virtual HRESULT GetDownloadProgress(double &dblDownloadProgress);

    virtual HRESULT onMouseMove(long x, long y);
    virtual HRESULT onMouseDown(long x, long y);

    virtual void LoadFailNotify(PLAYER_EVENT reason);
    virtual void SetPlaybackSite(CTIMEBasePlayer *pSite);
    virtual void FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer = NULL);

  protected:
    virtual HRESULT Init();

    ITIMEBasePlayer *m_pBasePlayer;
    CTIMEBasePlayer *m_pNativePlayer;

  private:

    CritSect            m_CriticalSection;
    bool                m_fBlocked;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playlistdelegator.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: playlistdelegator.cpp
//
//  Contents: playlist object that delegates to the player's playlist object
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "playlistdelegator.h"


//+-------------------------------------------------------------------------------------
//
// CPlayListDelegator methods
//
//--------------------------------------------------------------------------------------

    
CPlayListDelegator::CPlayListDelegator() :
    m_pPlayList(NULL),
    m_dwAdviseCookie(0)
{

}


CPlayListDelegator::~CPlayListDelegator()
{
    DetachPlayList();
}


void 
CPlayListDelegator::AttachPlayList(ITIMEPlayList * pPlayList)
{
    // detach from the old play list
    DetachPlayList();

    if (pPlayList)
    {
        // cache the pointer 
        pPlayList->AddRef();
        m_pPlayList = pPlayList;

        // sign up for prop change notification
        IGNORE_HR(InitPropertySink());
    }
}


void 
CPlayListDelegator::DetachPlayList()
{
    if (m_pPlayList)
    {
        // unadvise prop change
        UnInitPropertySink();

        // release the cached ptr
        m_pPlayList->Release();
        m_pPlayList = NULL;
    }
}


HRESULT
CPlayListDelegator::GetPlayListConnectionPoint(IConnectionPoint **ppCP)
{
    HRESULT hr = E_FAIL;
    CComPtr<IConnectionPointContainer> spCPC;

    Assert(ppCP != NULL);

    CHECK_RETURN_SET_NULL(ppCP);

    if (!m_pPlayList)
    {
        goto done;
    }

    // Get connection point container
    hr = m_pPlayList->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &spCPC));
    if(FAILED(hr))
    {
        goto done;
    }
    
    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink, ppCP);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
CPlayListDelegator::InitPropertySink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;

    // Find the IPropertyNotifySink connection
    hr = THR(GetPlayListConnectionPoint(&spCP));
    if(FAILED(hr))
    {
        goto done;
    }

    // Advise on it
    hr = spCP->Advise(GetUnknown(), &m_dwAdviseCookie);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
CPlayListDelegator::UnInitPropertySink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;

    if (0 == m_dwAdviseCookie)
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = THR(GetPlayListConnectionPoint(&spCP));
    if(FAILED(hr) || NULL == spCP.p)
    {
        goto done;
    }

    // Unadvise on it
    hr = spCP->Unadvise(m_dwAdviseCookie);
    if (FAILED(hr))
    {
        goto done;
    }

    m_dwAdviseCookie = 0;

    hr = S_OK;
done:
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayListDelegator::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayListDelegator::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = THR(NotifyPropertySinkCP(pICP, dispid));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged


//+-------------------------------------------------------------------------------------
//
// ITIMEPlayList methods
//
//--------------------------------------------------------------------------------------

    
STDMETHODIMP
CPlayListDelegator::put_activeTrack(VARIANT vTrack)
{
    HRESULT hr = S_OK;

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->put_activeTrack(vTrack));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::get_activeTrack(ITIMEPlayItem **ppPlayItem)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(ppPlayItem);

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get_activeTrack(ppPlayItem));
    }

    RRETURN(hr);
}

    
STDMETHODIMP
CPlayListDelegator::get_dur(double * pdblDur)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(pdblDur);
    
    *pdblDur = 0;

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get_dur(pdblDur));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::item(VARIANT varIndex, ITIMEPlayItem ** ppPlayItem)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(ppPlayItem);

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->item(varIndex, ppPlayItem));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::get_length(long * plLength)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(plLength);

    *plLength = 0;

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get_length(plLength));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::get__newEnum(IUnknown** p)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(p);

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get__newEnum(p));
    }

    RRETURN(hr);
}


//Advances the active Track by one
STDMETHODIMP
CPlayListDelegator::nextTrack()
{
    HRESULT hr = S_OK;
    
    if (GetPlayList())
    {
        hr = THR(GetPlayList()->nextTrack());
    }

    RRETURN(hr);
}


//moves the active track to the previous track
STDMETHODIMP
CPlayListDelegator::prevTrack() 
{
    HRESULT hr = S_OK;
    
    if (GetPlayList())
    {
        hr = THR(GetPlayList()->prevTrack());
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------------------
//
// IPropertyNotifySink methods
//
//--------------------------------------------------------------------------------------

STDMETHODIMP
CPlayListDelegator::OnRequestEdit(DISPID dispID)
{
    RRETURN(S_OK);
}


STDMETHODIMP
CPlayListDelegator::OnChanged(DISPID dispID)
{
    return THR(NotifyPropertyChanged(dispID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\playlistdelegator.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: playlistdelegator.h
//
//  Contents: playlist object that delegates to the player's playlist object
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _PLAYLISTDELEGATOR_H
#define _PLAYLISTDELEGATOR_H


//+-------------------------------------------------------------------------------------
//
// CPlayListDelegator
//
//--------------------------------------------------------------------------------------

class
__declspec(uuid("2e6c4d81-2b2a-49c6-8158-2b8280d28e00")) 
CPlayListDelegator :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayListDelegator, &__uuidof(CPlayListDelegator)>,
    public ITIMEDispatchImpl<ITIMEPlayList, &IID_ITIMEPlayList>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayList>,
    public IConnectionPointContainerImpl<CPlayListDelegator>,
    public IPropertyNotifySinkCP<CPlayListDelegator>,
    public IPropertyNotifySink
{
  public:
    
    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CPlayListDelegator();
    virtual ~CPlayListDelegator();

    void AttachPlayList(ITIMEPlayList * pPlayList);
    void DetachPlayList();

#if DBG
    const _TCHAR * GetName() { return __T("CPlayListDelegator"); }
#endif

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    // 
    // ITIMEPlayList methods
    //
        
    STDMETHOD(put_activeTrack)(VARIANT vTrack);
    STDMETHOD(get_activeTrack)(ITIMEPlayItem **pPlayItem);
        
    STDMETHOD(get_dur)(double *dur);

    STDMETHOD(item)(VARIANT varIndex,
                    ITIMEPlayItem **pPlayItem);

    STDMETHOD(get_length)(long* len);

    STDMETHOD(get__newEnum)(IUnknown** p);

    STDMETHOD(nextTrack)(); //Advances the active Track by one
    STDMETHOD(prevTrack)(); //moves the active track to the previous track

    //
    // IPropertyNotifySink methods
    //

    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    //    
    // QI & CP Map
    //

    BEGIN_COM_MAP(CPlayListDelegator)
        COM_INTERFACE_ENTRY(ITIMEPlayList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

    BEGIN_CONNECTION_POINT_MAP(CPlayListDelegator)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

  private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    HRESULT NotifyPropertyChanged(DISPID dispid);

    HRESULT GetPlayListConnectionPoint(IConnectionPoint **ppCP);
    HRESULT InitPropertySink();
    HRESULT UnInitPropertySink();
  
    ITIMEPlayList * GetPlayList() { return m_pPlayList; };

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    ITIMEPlayList * m_pPlayList;
    DWORD m_dwAdviseCookie;

}; //  CPlayListDelegator


#endif /* _PLAYLISTDELEGATOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\stopstream.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: stopstream.h
//
//  Contents: stoppable implementation of IStream
//
//------------------------------------------------------------------------------------

#ifndef _STOPSTREAM__H
#define _STOPSTREAM__H

class CStopableStream : public IStream
{
  public:
    CStopableStream() : m_spStream(NULL), m_fCancelled(false) {;}
    virtual ~CStopableStream() {;}

    void SetStream(IStream * pStream) { m_spStream = pStream; }

    STDMETHOD(QueryInterface)(REFGUID riid, void ** ppv)
    {
        return m_spStream->QueryInterface(riid, ppv);
    }

    STDMETHOD_(ULONG, AddRef)(void)
    {
        return m_spStream->AddRef();
    }

    STDMETHOD_(ULONG, Release)(void)
    {
        return m_spStream->Release();
    }

    // ISequentialStream
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead) 
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Read(pv, cb, pcbRead);
    }

        
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Write(pv, cb, pcbWritten);
    }

    // IStream
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Seek(dlibMove, dwOrigin, plibNewPosition);
    }

    virtual HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ ULARGE_INTEGER libNewSize)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->SetSize(libNewSize);
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
    }

    virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Commit(grfCommitFlags);
    }
        
    virtual HRESULT STDMETHODCALLTYPE Revert( void)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Revert();
    }
        
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->LockRegion(libOffset, cb, dwLockType);
    }
        
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->UnlockRegion(libOffset, cb, dwLockType);
    }
        
    virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Stat(pstatstg, grfStatFlag);
    }
        
    virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Clone(ppstm);
    }

    bool Cancelled() { return m_fCancelled; }
    void SetCancelled() { m_fCancelled = true; }

  private:
    CComPtr<IStream>    m_spStream;
    bool                m_fCancelled;
};

#endif // _STOPSTREAM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\wmsbuffer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Jun 16 13:10:02 2000
 */
/* Compiler settings for .\wmsbuffer.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif 	/* __INSSBuffer_FWD_DEFINED__ */


#ifndef __INSSBuffer2_FWD_DEFINED__
#define __INSSBuffer2_FWD_DEFINED__
typedef interface INSSBuffer2 INSSBuffer2;
#endif 	/* __INSSBuffer2_FWD_DEFINED__ */


#ifndef __IWMSBufferAllocator_FWD_DEFINED__
#define __IWMSBufferAllocator_FWD_DEFINED__
typedef interface IWMSBufferAllocator IWMSBufferAllocator;
#endif 	/* __IWMSBufferAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsbuffer_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_INSSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBufferAllocator, 0x61103CA4,0x2033,0x11d2,0x9E,0xF1,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_INSSBuffer2, 0x4f528693, 0x1035, 0x43fe, 0xb4, 0x28, 0x75, 0x75, 0x61, 0xad, 0x3a, 0x68);
#define IWMSBuffer INSSBuffer



extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_s_ifspec;

#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

/* interface INSSBuffer */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3524-03D7-11d2-9EED-006097D2D7CF")
    INSSBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        END_INTERFACE
    } INSSBufferVtbl;

    interface INSSBuffer
    {
        CONST_VTBL struct INSSBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer_GetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_SetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB INSSBuffer_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetMaxLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetMaxLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBuffer_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);


void __RPC_STUB INSSBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBufferAndLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetBufferAndLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer2_INTERFACE_DEFINED__
#define __INSSBuffer2_INTERFACE_DEFINED__

/* interface INSSBuffer2 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F528693-1035-43fe-B428-757561AD3A68")
    INSSBuffer2 : public INSSBuffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties);
        
        END_INTERFACE
    } INSSBuffer2Vtbl;

    interface INSSBuffer2
    {
        CONST_VTBL struct INSSBuffer2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer2_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer2_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer2_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer2_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer2_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer2_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer2_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer2_GetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [out] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_GetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer2_SetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [in] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_SetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer2_INTERFACE_DEFINED__ */


#ifndef __IWMSBufferAllocator_INTERFACE_DEFINED__
#define __IWMSBufferAllocator_INTERFACE_DEFINED__

/* interface IWMSBufferAllocator */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_IWMSBufferAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61103CA4-2033-11d2-9EF1-006097D2D7CF")
    IWMSBufferAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocatePageSizeBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBufferAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocatePageSizeBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IWMSBufferAllocatorVtbl;

    interface IWMSBufferAllocator
    {
        CONST_VTBL struct IWMSBufferAllocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBufferAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSBufferAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSBufferAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSBufferAllocator_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer)

#define IWMSBufferAllocator_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocateBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocatePageSizeBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocatePageSizeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSBufferAllocator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\flash\nstdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\proxy\proxybaseimpl.h ===
#pragma once

#include <math.h>
#include <datimeid.h>
#include <comutil.h>


EXTERN_C const IID IID_ITIMEMediaPlayer;
EXTERN_C const IID DIID_TIMEMediaPlayerEvents;

HRESULT WINAPI HandleQI_IConnectionPointContainer(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw);

class CConnectionPointContainer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IConnectionPointContainerImpl<CConnectionPointContainer>,
    public IConnectionPointImpl<CConnectionPointContainer, &DIID_TIMEMediaPlayerEvents, CComDynamicUnkArray>,
    public IUnknown
{
public:
    CConnectionPointContainer()
    {
    }

    virtual ~CConnectionPointContainer()
    {
    }
    //
    // this class is needed to keep the IConnectionPoint::Unadvise method from 
    // colliding with the IOleObject::Unadvise method.
    //

protected:
    BEGIN_COM_MAP(CConnectionPointContainer)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CConnectionPointContainer)
        CONNECTION_POINT_ENTRY(DIID_TIMEMediaPlayerEvents)
    END_CONNECTION_POINT_MAP()
};

/*
IUnknown
ITIMEMediaPlayer
IOleObject
IViewObject2
IDispatch
IConnectionPointContainer
IRunnableObject
IServiceProvider
IOleInPlaceObject
IOleInPlaceObjectWindowless
IOleInPlaceActiveObject
IOleInPlaceSiteWindowless
IServiceProvider
IServiceProvider
IOleInPlaceObject
*/

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
class CProxyBaseImpl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CProxyBaseImpl<T_pCLSID, T_pLIBID>, T_pCLSID>,
    public CComControl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IDispatchImpl<ITIMEProxyPlayer, &IID_ITIMEProxyPlayer, T_pLIBID>,
    public IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IOleInPlaceObjectWindowlessImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IViewObjectExImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IRunnableObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IOleClientSite,
    public IOleControlSite,
    public IOleInPlaceFrame,
    public IOleInPlaceSiteWindowless,
    public IOleContainer,
    public IServiceProvider,
    public IBindHost,
    public IOleInPlaceActiveObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IAdviseSink,
    public ITIMEMediaPlayer
{
protected:
    

    //
    // TIME-related state
    //
    DWORD       m_dwLastRefTime;
    double      m_dblTime;
    bool        m_fSuspended;
    bool        m_fInitialized;
    bool        m_fMediaReady;
    CComBSTR    m_bstrSrc;

    //
    // contained control related state
    //
    DWORD       m_dwCtrlAdviseToken;

    //
    // interfaces from our container
    //
    CComPtr<IOleInPlaceSiteWindowless>  m_pContOleInPlaceSiteWindowless;
    CComPtr<IServiceProvider>           m_pContServiceProvider;

    //
    // interfaces from our contained control
    //
    CComPtr<IUnknown>                   m_pCtrlUnknown;
    CComPtr<IOleObject>                 m_pCtrlOleObject;
    CComPtr<IViewObject>                m_pCtrlViewObject;
    CComPtr<IOleInPlaceObject>          m_pCtrlOleInPlaceObject;


    STDMETHOD(CreateControl)(REFCLSID rclsid, REFIID riid, void** ppv);

    CComPtr<CComObject<CConnectionPointContainer> >     m_pCPC;
    STDMETHOD(GetCPC)(CComObject<CConnectionPointContainer>** ppCCO);

public:

    //
    // TODO: make this protected if possible
    //
    static HRESULT WINAPI HandleQI_IConnectionPointContainer(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw);

    CProxyBaseImpl();
    virtual ~CProxyBaseImpl();

    //
    // TODO: label these
    //
    STDMETHOD(CreateContainedControl)() = 0;
    STDMETHOD(Advise)(IAdviseSink* pAdvSink, DWORD* pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);


        STDMETHOD(DoVerbInPlaceActivate)(LPCRECT prcPosRect, HWND hwndParent);

    //
    // IViewObject overloads
    //
    STDMETHOD(Draw)(DWORD dwAspect, LONG lindex, void* pvAspect, DVTARGETDEVICE* ptd, HDC hicTargetDev, HDC hdcDraw, 
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds, BOOL (__stdcall* pfnContinue)(ULONG_PTR), DWORD dwContinue);

    //
    // IOleObject overloads
    //

    STDMETHOD(SetClientSite)(IOleClientSite* pClientSite);
        STDMETHOD(Close)(DWORD dwSaveOption);

    //
    // IOleInPlaceObject overloads
    //
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect, LPCRECT lprcClipRect);
        STDMETHOD(InPlaceDeactivate)(void);

    //
    // IAdviseSink
    //
    STDMETHOD_(void,OnClose)();
    STDMETHOD_(void,OnDataChange)(FORMATETC* pFormatetc, STGMEDIUM* pStgmed);
    STDMETHOD_(void,OnRename)(IMoniker* pmk);
    STDMETHOD_(void,OnSave)();
    STDMETHOD_(void,OnViewChange)(DWORD dwAspect, LONG lindex);

    //
    // IOleWindow
    //
    STDMETHOD(GetWindow)(HWND* phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);  // optional

    //
    // IOleInPlaceSite
    //
    STDMETHOD(CanInPlaceActivate)();
    STDMETHOD(OnInPlaceActivate)();
    STDMETHOD(OnUIActivate)();
    STDMETHOD(GetWindowContext)(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, RECT* lprcPosRect,
                                RECT* lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD(Scroll)(SIZE scrollExtent);
    STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD(OnInPlaceDeactivate)();
    STDMETHOD(DiscardUndoState)();
    STDMETHOD(DeactivateAndUndo)();
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

    //
    // IOleInPlaceSiteEx
    //
    STDMETHOD(OnInPlaceActivateEx)(BOOL* pfNoRedraw, DWORD dwFlags);
    STDMETHOD(OnInPlaceDeactivateEx)(BOOL fNoRedraw);
    STDMETHOD(RequestUIActivate)();

    //
    // IOleInPlaceSiteWindowless
    //
    STDMETHOD(CanWindowlessActivate)(void);
    STDMETHOD(GetCapture)(void);
    STDMETHOD(SetCapture)(BOOL fCapture);
    STDMETHOD(GetFocus)(void);
    STDMETHOD(SetFocus)(BOOL fFocus);
    STDMETHOD(GetDC)(LPCRECT pRect, DWORD grfFlags, HDC* phDC);
    STDMETHOD(ReleaseDC)(HDC hDC);
    STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase);
    STDMETHOD(InvalidateRgn)(HRGN hRGN, BOOL fErase);
    STDMETHOD(ScrollRect)(int dx, int dy, LPCRECT pRectScroll, LPCRECT pRectClip);
    STDMETHOD(AdjustRect)(LPRECT prc);
    STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

    //
    // IOleInPlaceUIWindow
    //  
    STDMETHOD(GetBorder)(LPRECT lprectBorder);   // not required
    STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS pborderwidths);  // not required
    STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS pborderwidths);      // not required
    STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);
    STDMETHOD(InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);  // not required
    STDMETHOD(SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject); // not required
    STDMETHOD(RemoveMenus)(HMENU hmenuShared); // not required
    STDMETHOD(SetStatusText)(LPCOLESTR pszStatusText); // not required
    STDMETHOD(EnableModeless)(BOOL fEnable); // optional
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg, WORD wID); // not required

    //
    // IOleControlSite
    //
    STDMETHOD(OnControlInfoChanged)();
    STDMETHOD(LockInPlaceActive)(BOOL fLock);   // optional
    STDMETHOD(GetExtendedControl)(IDispatch** ppDisp);  // not required
    STDMETHOD(TransformCoords)(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags);
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg, DWORD dwID);
    STDMETHOD(OnFocus)(BOOL fGotFocus);
    STDMETHOD(ShowPropertyFrame)();   // not required

    //
    // IParseDisplayName
    //
    STDMETHOD(ParseDisplayName)(IBindCtx* pbc, LPOLESTR pszDisplayName, ULONG* pchEaten, IMoniker** ppmkOut); // not required

    //
    // IOleContainer
    //
    STDMETHOD(EnumObjects)(DWORD grfFlags, IEnumUnknown** ppenum); // not required
    STDMETHOD(LockContainer)(BOOL fLock); // not required

    //
    // IOleClientSite
    //
    STDMETHOD(SaveObject)(); // not required
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk); // not required
    STDMETHOD(GetContainer)(IOleContainer** ppContainer);
    STDMETHOD(ShowObject)();
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)();

    //
    // IServiceProvider
    //
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void** ppv);

    //
    // IBindHost
    //
    STDMETHOD(CreateMoniker)(LPOLESTR szName, IBindCtx* pBC, IMoniker** ppmk, DWORD dwReserved);
    STDMETHOD(MonikerBindToObject)(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj);
    STDMETHOD(MonikerBindToStorage)(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj);

    //
    // ITIMEMediaPlayer
    //
    STDMETHOD(Init)(void);
    STDMETHOD(clipBegin)(VARIANT varClipBegin);
    STDMETHOD(clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(tick)(void);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);
    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(get_src)(BSTR* pbstrURL);
    STDMETHOD(put_repeat)(long   lTime);
    STDMETHOD(get_repeat)(long* plTime);
    STDMETHOD(cue)(void);

    //
    // ITIMEProxyPlayer
    //
    STDMETHOD(get_playerObject)(IDispatch** ppdispPlayerObject);

BEGIN_COM_MAP(CProxyBaseImpl)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IOleClientSite)
    COM_INTERFACE_ENTRY(IOleInPlaceFrame)
    COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
    COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
    COM_INTERFACE_ENTRY(IOleContainer)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IBindHost)
    COM_INTERFACE_ENTRY(IOleControlSite)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceSiteWindowless)
    COM_INTERFACE_ENTRY2(IOleInPlaceActiveObject, IOleInPlaceActiveObjectImpl<CProxyBaseImpl>)
    COM_INTERFACE_ENTRY2(IOleInPlaceObject, IOleInPlaceObjectWindowlessImpl<CProxyBaseImpl>)
    COM_INTERFACE_ENTRY2(IViewObject2, IViewObjectExImpl<CProxyBaseImpl>)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IRunnableObject)
    COM_INTERFACE_ENTRY_FUNC(IID_IConnectionPointContainer, 0, HandleQI_IConnectionPointContainer)
END_COM_MAP()

BEGIN_MSG_MAP(CProxyBaseImpl) //lint !e1735 !e522
END_MSG_MAP() //lint !e725 !e550 !e529

};

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CreateControl(REFCLSID rclsid, REFIID riid, void** ppv)
{
    ATLTRACE(_T("CreateControl\n"));

    if (IsBadWritePtr(ppv, sizeof(void*)))
        return E_POINTER;


    HRESULT hr = S_OK;

    hr = CoCreateInstance(rclsid, NULL, CLSCTX_INPROC, IID_IUnknown, 
            reinterpret_cast<void**>(&m_pCtrlUnknown));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(IID_IOleObject, 
            reinterpret_cast<void**>(&m_pCtrlOleObject));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(IID_IViewObject, 
            reinterpret_cast<void**>(&m_pCtrlViewObject));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(IID_IOleInPlaceObject, 
            reinterpret_cast<void**>(&m_pCtrlOleInPlaceObject));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(riid, ppv);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Advise(IAdviseSink* pAdvSink, DWORD* pdwConnection)
{
    HRESULT hr = S_OK;
    ATLTRACE(_T("Advise\n"));
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::Advise(pAdvSink, pdwConnection);
    if (FAILED(hr))
        return hr;

    //
    //
    //
    ASSERT(NULL == m_dwCtrlAdviseToken);
    if (m_pCtrlOleObject == NULL)
    {
        hr = S_OK;
        return hr;
    }
    hr = m_pCtrlOleObject->Advise(static_cast<IAdviseSink*>(this), &m_dwCtrlAdviseToken);
    //
    //
    //

    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Unadvise(DWORD dwConnection)
{
    HRESULT hr = S_OK;
    ATLTRACE(_T("Unadvise\n"));
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::Unadvise(dwConnection);
    if (FAILED(hr))
        return hr;

    //
    //
    //
    if (m_pCtrlOleObject && m_dwCtrlAdviseToken)
    {
        hr = m_pCtrlOleObject->Unadvise(m_dwCtrlAdviseToken);
    }
    //
    //
    //

    m_dwCtrlAdviseToken = 0;
    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    ATLTRACE(_T("DoVerbInPlaceActivate\n"));
    HRESULT hr = S_OK;

//    hr = InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::DoVerbInPlaceActivate(prcPosRect, hwndParent);
    if (FAILED(hr))
        return hr;

    //
    // activate contained control
    //

    if (m_pCtrlOleObject == NULL)
    {
        hr = E_POINTER;
        return hr;
    }
    hr = m_pCtrlOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, static_cast<IOleClientSite*>(this),
        0, hwndParent, prcPosRect);
        return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Draw(DWORD dwAspect, 
    LONG lindex, 
    void* pvAspect, 
    DVTARGETDEVICE* ptd, 
    HDC hicTargetDev, 
    HDC hdcDraw, 
    LPCRECTL lprcBounds, 
    LPCRECTL lprcWBounds, 
    BOOL (__stdcall* pfnContinue)(ULONG_PTR), 
    DWORD dwContinue)
{
    ATLTRACE(_T("Draw\n"));
    HRESULT hr = S_OK;
    hr = m_pCtrlViewObject->Draw(dwAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetClientSite(IOleClientSite* pClientSite)
{
    ATLTRACE(_T("SetClientSite\n"));
    HRESULT hr      = S_OK;

    //
    // TODO: do we need this call to the super?
    //
    hr = IOleObjectImpl<CProxyBaseImpl>::SetClientSite(pClientSite);
    if (FAILED(hr))
        goto exit;

    if (NULL == pClientSite)
    {
        ATLTRACE(_T("setting null client site\n"));

        if (m_pCtrlOleObject.p)
        {
            m_pCtrlOleObject->SetClientSite(NULL);
        }

        m_dwLastRefTime                 = 0;
        m_dblTime                       = 0.0;
        m_fSuspended                    = false;
        m_fInitialized                  = false;
        m_fMediaReady                   = false;
        m_bstrSrc.Empty();
        m_dwCtrlAdviseToken             = 0;
        m_pContOleInPlaceSiteWindowless = 0;
        m_pContServiceProvider          = 0;
        m_pCtrlUnknown                  = 0;
        m_pCtrlOleObject                = 0;
        m_pCtrlViewObject               = 0;
        m_pCtrlOleInPlaceObject         = 0;

        hr = S_OK;
        goto exit;
    }

    hr = pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, 
            reinterpret_cast<void**>(&m_pContOleInPlaceSiteWindowless));
    if (FAILED(hr))
        goto exit;

    hr = pClientSite->QueryInterface(IID_IServiceProvider,
            reinterpret_cast<void**>(&m_pContServiceProvider));
    if (FAILED(hr))
        goto exit;

    hr = CreateContainedControl();
    if (FAILED(hr))
        goto exit;

    if (m_pCtrlOleObject)
    {
        m_pCtrlOleObject->SetClientSite(this);
    }

    m_fInitialized = true;

exit:
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnClose()
{
    ATLTRACE(_T("OnClose\n"));
        m_spOleAdviseHolder->SendOnClose();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnDataChange(FORMATETC* pFormatetc, STGMEDIUM* pStgmed)
{
    ATLTRACE(_T("OnDataChange\n"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnRename(IMoniker* pmk)
{
    ATLTRACE(_T("OnRename\n"));
        m_spOleAdviseHolder->SendOnRename(pmk);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnSave()
{
    ATLTRACE(_T("OnSave\n"));
        m_spOleAdviseHolder->SendOnSave();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnViewChange(DWORD dwAspect, LONG lindex)
{
    ATLTRACE(_T("OnViewChange\n"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetWindow(HWND* phwnd)
{
    ATLTRACE(_T("GetWindow\n"));
    return m_pContOleInPlaceSiteWindowless->GetWindow(phwnd);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ContextSensitiveHelp(BOOL fEnterMode)  // optional
{
    ATLTRACE(_T("ContextSensitiveHelp\n"));
    return m_pContOleInPlaceSiteWindowless->ContextSensitiveHelp(fEnterMode);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CanInPlaceActivate()
{
    ATLTRACE(_T("CanInPlaceActivate\n"));
    return m_pContOleInPlaceSiteWindowless->CanInPlaceActivate();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceActivate()
{
    ATLTRACE(_T("OnInPlaceActivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnUIActivate()
{
    ATLTRACE(_T("OnUIActivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetWindowContext(IOleInPlaceFrame **ppFrame,
  IOleInPlaceUIWindow **ppDoc,
  RECT* lprcPosRect,
  RECT* lprcClipRect,
  LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    ATLTRACE(_T("GetWindowContext\n"));
    HRESULT hr = S_OK;
    CComPtr<IOleInPlaceFrame>       pFrame;
    CComPtr<IOleInPlaceUIWindow>    pDoc;

    hr = m_pContOleInPlaceSiteWindowless->GetWindowContext(&pFrame, &pDoc, lprcPosRect, lprcClipRect, lpFrameInfo);
    if (FAILED(hr))
        return hr;

    //
    // NOTE: since flash doesn't seem to care about these pointers,
    //       we're not going to give them to it so that it can't get
    //       around the proxy and directly muck with our container.
    //

    *ppFrame    = NULL;
    *ppDoc      = NULL;

    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Scroll(SIZE scrollExtent)
{
    ATLTRACE(_T("Scroll\n"));
    return m_pContOleInPlaceSiteWindowless->Scroll(scrollExtent);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnUIDeactivate(BOOL fUndoable)
{
    ATLTRACE(_T("OnUIDeactivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceDeactivate()
{
    ATLTRACE(_T("OnInPlaceDeactivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::DiscardUndoState()
{
    ATLTRACE(_T("DiscardUndoState\n"));
    return m_pContOleInPlaceSiteWindowless->DiscardUndoState();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::DeactivateAndUndo()
{
    ATLTRACE(_T("DeactivateAndUndo\n"));
    return m_pContOleInPlaceSiteWindowless->DeactivateAndUndo();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnPosRectChange(LPCRECT lprcPosRect)
{
    ATLTRACE(_T("OnPosRectChange\n"));
    return m_pContOleInPlaceSiteWindowless->OnPosRectChange(lprcPosRect);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceActivateEx(BOOL* pfNoRedraw, DWORD dwFlags)
{
    ATLTRACE(_T("OnInPlaceActivateEx\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    ATLTRACE(_T("OnInPlaceDeactivateEx\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RequestUIActivate()
{
    ATLTRACE(_T("RequestUIActivate\n"));
    return m_pContOleInPlaceSiteWindowless->RequestUIActivate();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CanWindowlessActivate(void)
{
    ATLTRACE(_T("CanWindowlessActivate\n"));
    return m_pContOleInPlaceSiteWindowless->CanWindowlessActivate();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetCapture(void)
{
    ATLTRACE(_T("GetCapture\n"));
    return m_pContOleInPlaceSiteWindowless->GetCapture();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetCapture(BOOL fCapture)
{
    ATLTRACE(_T("SetCapture\n"));
    return m_pContOleInPlaceSiteWindowless->SetCapture(fCapture);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetFocus(void)
{
    ATLTRACE(_T("GetFocus\n"));
    return m_pContOleInPlaceSiteWindowless->GetFocus();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetFocus(BOOL fFocus)
{
    ATLTRACE(_T("SetFocus\n"));
    return m_pContOleInPlaceSiteWindowless->SetFocus(fFocus);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetDC(LPCRECT pRect, DWORD grfFlags, HDC* phDC)
{
    ATLTRACE(_T("GetDC\n"));
    return m_pContOleInPlaceSiteWindowless->GetDC(pRect, grfFlags, phDC);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ReleaseDC(HDC hDC)
{
    ATLTRACE(_T("ReleaseDC\n"));
    return m_pContOleInPlaceSiteWindowless->ReleaseDC(hDC);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InvalidateRect(LPCRECT pRect, BOOL fErase)
{
    ATLTRACE(_T("InvalidateRect\n"));
    return m_pContOleInPlaceSiteWindowless->InvalidateRect(pRect, fErase);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InvalidateRgn(HRGN hRGN, BOOL fErase)
{
    ATLTRACE(_T("InvalidateRgn\n"));
    return m_pContOleInPlaceSiteWindowless->InvalidateRgn(hRGN, fErase);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ScrollRect(int dx, int dy, LPCRECT pRectScroll, LPCRECT pRectClip)
{
    ATLTRACE(_T("ScrollRect\n"));
    return m_pContOleInPlaceSiteWindowless->ScrollRect(dx, dy, pRectScroll, pRectClip);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::AdjustRect(LPRECT prc)
{
    ATLTRACE(_T("AdjustRect\n"));
    return m_pContOleInPlaceSiteWindowless->AdjustRect(prc);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
{
    ATLTRACE(_T("OnDefWindowMessage\n"));
    return m_pContOleInPlaceSiteWindowless->OnDefWindowMessage(msg, wParam, lParam, plResult);
}






template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetBorder(LPRECT lprectBorder)   // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::GetBorder"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)  // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::RequestBorderSpace"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)      // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetBorderSpace"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetActiveObject"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)  // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::InsertMenus"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetMenu"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RemoveMenus(HMENU hmenuShared) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::RemoveMenus"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetStatusText(LPCOLESTR pszStatusText) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetStatusText"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::EnableModeless(BOOL fEnable) // optional
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::EnableModeless"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::TranslateAccelerator(LPMSG lpmsg, WORD wID) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::TranslateAccelerator"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnControlInfoChanged()
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::OnControlInfoChanged"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::LockInPlaceActive(BOOL fLock)   // optional
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::LockInPlaceActive"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetExtendedControl(IDispatch** ppDisp)  // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::GetExtendedControl"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::TransformCoords(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::TransformCoords"));
}






template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::TranslateAccelerator(LPMSG lpmsg, DWORD dwID)
{
    return S_FALSE;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnFocus(BOOL fGotFocus)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::OnFocus"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ShowPropertyFrame()   // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::ShowPropertyFrame"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ParseDisplayName(IBindCtx* pbc, LPOLESTR pszDisplayName, ULONG* pchEaten, IMoniker** ppmkOut) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::ParseDisplayName"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::EnumObjects(DWORD grfFlags, IEnumUnknown** ppenum) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::EnumObjects"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::LockContainer(BOOL fLock) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::LockContainer"));
}





template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SaveObject() // not required
{
    ATLTRACE(_T("SaveObject\n"));
    return m_spClientSite->SaveObject();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk) // not required
{
    ATLTRACE(_T("GetMoniker\n"));
    return m_spClientSite->GetMoniker(dwAssign, dwWhichMoniker, ppmk);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetContainer(IOleContainer** ppContainer)
{
    ATLTRACE(_T("GetContainer\n"));
    return m_spClientSite->GetContainer(ppContainer);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ShowObject()
{
    ATLTRACE(_T("ShowObject\n"));
    return m_spClientSite->ShowObject();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnShowWindow(BOOL fShow)
{
    ATLTRACE(_T("OnShowWindow\n"));
    return m_spClientSite->OnShowWindow(fShow);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RequestNewObjectLayout()
{
    ATLTRACE(_T("RequestNewObjectLayout\n"));
    return m_spClientSite->RequestNewObjectLayout();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::QueryService(REFGUID guidService, REFIID riid, void** ppv)
{
    ATLTRACE(_T("QueryService\n"));
    if (!m_pContServiceProvider)
    {
        return S_OK;
    }

    return m_pContServiceProvider->QueryService(guidService, riid, ppv);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CreateMoniker(LPOLESTR szName, IBindCtx* pBC, IMoniker** ppmk, DWORD dwReserved)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::CreateMoniker"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::MonikerBindToObject(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::MonikerBindToObject"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::MonikerBindToStorage(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::MonikerBindToStorage"));
}

//
// ITIMEMediaPlayer
//

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Init(void)
{
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::clipBegin(VARIANT varClipBegin)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::clipBegin"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::clipEnd(VARIANT varClipEnd)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::clipEnd"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::begin(void)
{
    m_fSuspended    = false;
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = 0;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::end(void)
{
    m_fSuspended = true;
    m_dblTime    = -HUGE_VAL;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::resume(void)
{
    m_fSuspended    = false;
    m_dwLastRefTime = timeGetTime();
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::pause(void)
{
    m_fSuspended = true;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::tick(void)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::tick"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::put_CurrentTime(double   dblCurrentTime)
{
    m_dblTime = dblCurrentTime;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_CurrentTime(double* pdblCurrentTime)
{
    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
        return E_POINTER;

    if (!m_fSuspended)
    {
        DWORD   dwNow;
        long    lDiff;

        dwNow   = timeGetTime();
        lDiff   = dwNow - m_dwLastRefTime;
        m_dwLastRefTime = dwNow;

        if (lDiff < 0)
            lDiff = -lDiff;

        m_dblTime += (lDiff / 1000.0);
    }

    *pdblCurrentTime = m_dblTime;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::put_src(BSTR   bstrURL)
{
    m_bstrSrc = bstrURL;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_src(BSTR* pbstrURL)
{
    if (IsBadWritePtr(pbstrURL, sizeof(BSTR)))
        return E_POINTER;

    *pbstrURL = m_bstrSrc.Copy();
    if (NULL == *pbstrURL)
        return E_OUTOFMEMORY;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::put_repeat(long   lTime)
{
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_repeat(long* plTime)
{
    if (IsBadWritePtr(plTime, sizeof(long*)))
        return E_POINTER;

    *plTime = 1;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::cue(void)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::cue"));
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    ATLTRACE(_T("SetObjectRects\n"));
    HRESULT                     hr = S_OK;
    CComPtr<IOleInPlaceObject>  pInPlaceObject;

    if (!m_fInitialized)
        return E_UNEXPECTED;

    if (!m_pCtrlOleInPlaceObject)
    {
        return S_OK;
    }

    hr = m_pCtrlOleInPlaceObject->SetObjectRects(lprcPosRect, lprcClipRect);
    return hr;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
CProxyBaseImpl<T_pCLSID, T_pLIBID>::CProxyBaseImpl() :
    m_dwLastRefTime(0),
    m_dblTime(0),
    m_fSuspended(false),
    m_fInitialized(false),
    m_fMediaReady(false),
    m_bstrSrc(),
    m_dwCtrlAdviseToken(0),
    m_pContOleInPlaceSiteWindowless(0),
    m_pContServiceProvider(0),
    m_pCtrlUnknown(0),
    m_pCtrlOleObject(0),
    m_pCtrlViewObject(0),
    m_pCtrlOleInPlaceObject(0)
{
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
CProxyBaseImpl<T_pCLSID, T_pLIBID>::~CProxyBaseImpl()
{
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InPlaceDeactivate(void)
{
    ATLTRACE(_T("InPlaceDeactivate\n"));
    HRESULT hr = S_OK;
    hr = IOleInPlaceObjectWindowlessImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::InPlaceDeactivate();
    if (FAILED(hr))
        return hr;

    if (!m_pCtrlOleInPlaceObject)
    {
        return S_OK;
    }

    hr = m_pCtrlOleInPlaceObject->InPlaceDeactivate();
    return hr;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Close(DWORD dwSaveOption)
{
    ATLTRACE(_T("Close\n"));
    HRESULT hr = S_OK;
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::Close(dwSaveOption);
    if (FAILED(hr))
        return hr;

    if (m_pCtrlOleObject == NULL)
    {
        hr = E_POINTER;
        return hr;
    }
    hr = m_pCtrlOleObject->Close(dwSaveOption);
    return hr;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetCPC(CComObject<CConnectionPointContainer>** ppCCO)
{
    if (IsBadWritePtr(ppCCO, sizeof(CComObject<CConnectionPointContainer>*)))
        return E_POINTER;

    if (m_pCPC == NULL)
    {
        //
        // TODO: check for failure
        //
        CComObject<CConnectionPointContainer>::CreateInstance(&m_pCPC);
    }

    *ppCCO = m_pCPC;
    m_pCPC.p->AddRef();
    return S_OK;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT WINAPI CProxyBaseImpl<T_pCLSID, T_pLIBID>::HandleQI_IConnectionPointContainer(
    void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw)
{
    HRESULT hr;
    CComObject<CConnectionPointContainer>* pCPC;

    CProxyBaseImpl<T_pCLSID, T_pLIBID>*  pClass = 
        reinterpret_cast<CProxyBaseImpl<T_pCLSID, T_pLIBID>*>(pv);

    hr = pClass->GetCPC(&pCPC);
    if (FAILED(hr))
        return hr;

    return pCPC->QueryInterface(riid, ppv);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_playerObject(IDispatch** ppdispPlayerObject)
{
    HRESULT hr = S_OK;

    if (IsBadWritePtr(ppdispPlayerObject, sizeof(IDispatch*)))
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pCtrlOleObject == NULL)
    {
        hr = E_POINTER;
        return hr;
    }
    m_pCtrlUnknown->QueryInterface(IID_IDispatch, 
        reinterpret_cast<void**>(ppdispPlayerObject));

    hr = S_OK;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\time\media\wmpcd.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Jun 16 13:10:13 2000
 */
/* Compiler settings for .\wmpcd.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmpcd_h__
#define __wmpcd_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMPCDMediaInfo_FWD_DEFINED__
#define __IWMPCDMediaInfo_FWD_DEFINED__
typedef interface IWMPCDMediaInfo IWMPCDMediaInfo;
#endif 	/* __IWMPCDMediaInfo_FWD_DEFINED__ */


#ifndef __IWMPCDDeviceList_FWD_DEFINED__
#define __IWMPCDDeviceList_FWD_DEFINED__
typedef interface IWMPCDDeviceList IWMPCDDeviceList;
#endif 	/* __IWMPCDDeviceList_FWD_DEFINED__ */


#ifndef __IWMPCDDevice_FWD_DEFINED__
#define __IWMPCDDevice_FWD_DEFINED__
typedef interface IWMPCDDevice IWMPCDDevice;
#endif 	/* __IWMPCDDevice_FWD_DEFINED__ */


#ifndef __IWMPCDMixer_FWD_DEFINED__
#define __IWMPCDMixer_FWD_DEFINED__
typedef interface IWMPCDMixer IWMPCDMixer;
#endif 	/* __IWMPCDMixer_FWD_DEFINED__ */


#ifndef __IWMPCDReader_FWD_DEFINED__
#define __IWMPCDReader_FWD_DEFINED__
typedef interface IWMPCDReader IWMPCDReader;
#endif 	/* __IWMPCDReader_FWD_DEFINED__ */


#ifndef __IWMPCDRecorder_FWD_DEFINED__
#define __IWMPCDRecorder_FWD_DEFINED__
typedef interface IWMPCDRecorder IWMPCDRecorder;
#endif 	/* __IWMPCDRecorder_FWD_DEFINED__ */


#ifndef __IWMPCDDeviceCallback_FWD_DEFINED__
#define __IWMPCDDeviceCallback_FWD_DEFINED__
typedef interface IWMPCDDeviceCallback IWMPCDDeviceCallback;
#endif 	/* __IWMPCDDeviceCallback_FWD_DEFINED__ */


#ifndef __IWMPCDReaderCallback_FWD_DEFINED__
#define __IWMPCDReaderCallback_FWD_DEFINED__
typedef interface IWMPCDReaderCallback IWMPCDReaderCallback;
#endif 	/* __IWMPCDReaderCallback_FWD_DEFINED__ */


#ifndef __IWMPCDRecorderCallback_FWD_DEFINED__
#define __IWMPCDRecorderCallback_FWD_DEFINED__
typedef interface IWMPCDRecorderCallback IWMPCDRecorderCallback;
#endif 	/* __IWMPCDRecorderCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"
#include "wmsbuffer.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmpcd_0000 */
/* [local] */ 










HRESULT STDMETHODCALLTYPE WMPCreateCDURL( DWORD iDevice, DWORD iTrack, BSTR *pbstrURL );
HRESULT STDMETHODCALLTYPE WMPParseCDURL( LPCWSTR pszURL, DWORD *piDevice, DWORD *piTrack );
HRESULT STDMETHODCALLTYPE WMPGetCDDeviceList( IWMPCDDeviceList **ppList );
HRESULT STDMETHODCALLTYPE WMPCreateCDRecorder( IUnknown *pUnknown, LPCWSTR pszPath, DWORD cRate, DWORD fl, IWMPCDRecorderCallback *pCallback, IWMPCDRecorder **ppRecorder );
HRESULT STDMETHODCALLTYPE WMPFireCDMediaChange( WCHAR chDrive, BOOL fMediaPresent );
HRESULT STDMETHODCALLTYPE WMPCalibrateCDDevice( void );

#define WMPCD_MAX_BLOCK_READ    16
#define WMPCD_MAX_DEVICE_NAME   64

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0001
    {	WMPCD_DEVICE_PLAY_DIGITAL	= 0x1,
	WMPCD_DEVICE_PLAY_CORRECT_ERRORS	= 0x2,
	WMPCD_DEVICE_RECORD_DIGITAL	= 0x4,
	WMPCD_DEVICE_RECORD_CORRECT_ERRORS	= 0x8,
	WMPCD_DEVICE_DEFAULT	= 0x4000
    }	WMPCD_DEVICE_OPTIONS;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0002
    {
    WCHAR szName[ 64 ];
    }	WMPCD_DEVICE_INFO;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0003
    {
    DWORD flOptions;
    double fRateNormal;
    double fRateCorrection;
    DWORD ccBlockRead;
    DWORD acBlockRead[ 16 ];
    DWORD cBlockOffset;
    }	WMPCD_TEST_INFO;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0004
    {	WMPCD_READER_CORRECT_ERRORS	= 0x1
    }	WMPCD_READER_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0005
    {	WMPCD_RECORD_DRM	= 0x1,
	WMPCD_RECORD_CORRECT_ERRORS	= 0x2
    }	WMPCD_RECORDER_FLAGS;

typedef /* [public][public][public][public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0006
    {
    DWORD iBlock;
    DWORD cBlock;
    }	WMPCD_EXTENT;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0007
    {
    DWORD fl;
    WMPCD_EXTENT ext;
    }	WMPCD_DISC_INFO;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0008
    {
    DWORD fl;
    WMPCD_EXTENT ext;
    }	WMPCD_TRACK_INFO;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0009
    {	WMPCD_DIGITAL_READER	= 0,
	WMPCD_ANALOG_SAMPLER	= WMPCD_DIGITAL_READER + 1,
	WMPCD_ANALOG_MONITOR	= WMPCD_ANALOG_SAMPLER + 1
    }	WMPCD_READER_TYPE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0010
    {	WMPCD_READER_STOPPED	= 0,
	WMPCD_READER_STARTED	= WMPCD_READER_STOPPED + 1,
	WMPCD_READER_PAUSED	= WMPCD_READER_STARTED + 1
    }	WMPCD_READER_STATE;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0011
    {
    WMPCD_READER_TYPE rt;
    DWORD cbBuffer;
    DWORD cBuffer;
    LONGLONG cTick;
    }	WMPCD_READER_INFO;



extern RPC_IF_HANDLE __MIDL_itf_wmpcd_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmpcd_0000_v0_0_s_ifspec;

#ifndef __IWMPCDMediaInfo_INTERFACE_DEFINED__
#define __IWMPCDMediaInfo_INTERFACE_DEFINED__

/* interface IWMPCDMediaInfo */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDMediaInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("536E6234-732A-40A4-AA7C-00012BFB53DB")
    IWMPCDMediaInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDiscInfo( 
            /* [out] */ WMPCD_DISC_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiscIdentifier( 
            /* [out] */ BSTR __RPC_FAR *pbstrIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrackCount( 
            /* [out] */ DWORD __RPC_FAR *pcTrack) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrackInfo( 
            /* [in] */ DWORD iTrack,
            /* [out] */ WMPCD_TRACK_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrackURL( 
            /* [in] */ DWORD iTrack,
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDMediaInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDMediaInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDMediaInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDiscInfo )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [out] */ WMPCD_DISC_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDiscIdentifier )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrackCount )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcTrack);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrackInfo )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [in] */ DWORD iTrack,
            /* [out] */ WMPCD_TRACK_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrackURL )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [in] */ DWORD iTrack,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        END_INTERFACE
    } IWMPCDMediaInfoVtbl;

    interface IWMPCDMediaInfo
    {
        CONST_VTBL struct IWMPCDMediaInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDMediaInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDMediaInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDMediaInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDMe