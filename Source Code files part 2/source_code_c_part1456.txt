rce\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\cpecbobj.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      cpecbobj.h 

   Abstract:
      Defines the implementation object for cpECB object

   Author:

       Murali R. Krishnan    ( MuraliK )    1-Aug-1996

   Project:
   
       Internet Application Server DLL

--*/

# ifndef _CPECBOBJ_HXX_
# define _CPECBOBJ_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/

#include "resource.h"       // main symbols
#include <iisextp.h>


/************************************************************
 *   Type Definitions  
 ************************************************************/

typedef BOOL (WINAPI * PFN_GET_SERVER_VARIABLE) ( HCONN       hConn,
                                                  LPSTR       lpszVariableName,
                                                  LPVOID      lpvBuffer,
                                                  LPDWORD     lpdwSize );

typedef BOOL (WINAPI * PFN_WRITE_CLIENT)  ( HCONN      ConnID,
                                            LPVOID     Buffer,
                                            LPDWORD    lpdwBytes,
                                            DWORD      dwReserved );

typedef BOOL (WINAPI * PFN_READ_CLIENT)  ( HCONN      ConnID,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize );

typedef BOOL (WINAPI * PFN_SERVER_SUPPORT_FUNCTION)( HCONN      hConn,
                                                     DWORD      dwHSERRequest,
                                                     LPVOID     lpvBuffer,
                                                     LPDWORD    lpdwSize,
                                                     LPDWORD    lpdwDataType );


class CcpECBObject : 
    public IcpECB,
    public CComObjectBase<&CLSID_cpECB>
{
public:
    CcpECBObject();
    ~CcpECBObject();

BEGIN_COM_MAP(CcpECBObject)
    COM_INTERFACE_ENTRY(IcpECB)
END_COM_MAP()

// Use DECLARE_NOT_AGGREGATABLE(CcpEBObject) if you don't want your object
// to support aggregation

DECLARE_AGGREGATABLE(CcpECBObject)

private:
   PFN_SERVER_SUPPORT_FUNCTION  m_pfnServerSupportFunc;
   PFN_READ_CLIENT              m_pfnReadClient;
   PFN_WRITE_CLIENT             m_pfnWriteClient;
   PFN_GET_SERVER_VARIABLE      m_pfnGetServerVariable; 
   BOOL                         m_fValid;

public:
    STDMETHOD( SetECB) (IN int cbSize, IN unsigned char * pBuf);
    STDMETHOD( GetECB) (OUT int * pcbSize, OUT unsigned char * pBuf);
    STDMETHOD( WriteClient) ( IN long  ConnID,
                              IN int cbSize, 
                              IN unsigned char * pBuf,
                              IN long  dwReserved);
    
};

# endif // _CPECBOBJ_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "cpECB_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>



//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\cpecbobj.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       cpecbobj.cpp

   Abstract:

       This module defines the functions for CcpECB Object

   Author:

       Murali R. Krishnan    ( MuraliK )     1-Aug-1996 

   Project:

       Internet Application Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "stdafx.h"
#include "cpecb.h"
#include "cpecbobj.h"
// # include <vipmem.h>
#include <iisext.h>

# include "dbgutil.h"

extern CRITICAL_SECTION   g_csInitLock;


/************************************************************
 *    Functions 
 ************************************************************/

CcpECBObject::CcpECBObject()
    : m_pfnServerSupportFunc( NULL),
      m_pfnReadClient       ( NULL),
      m_pfnWriteClient      ( NULL),
      m_pfnGetServerVariable( NULL),
      m_fValid              ( FALSE)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "creating CcpECBObject() ==>%08x\n",
                    this));
    }
} // CcpECBObject::CcpECBObject()


CcpECBObject::~CcpECBObject()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "deleting CcpECBObject() ==>%08x\n",
                    this));
    }
} // CcpECBObject::~CcpECBObject()



STDMETHODIMP 
CcpECBObject::SetECB(
    IN int cbSize,
    IN unsigned char* pBuf)
{
    HRESULT hr = S_OK;

    if (cbSize != sizeof(EXTENSION_CONTROL_BLOCK))
        return E_INVALIDARG;
    
    if ( !m_fValid) {

        //
        // This is the first call for initialization. Do a good job of init.
        // 
        
        EnterCriticalSection( &g_csInitLock);

        if ( !m_fValid) {
            
            EXTENSION_CONTROL_BLOCK * pecb = (EXTENSION_CONTROL_BLOCK *) pBuf;
            
            // initialize if only no other thread has done initiatlization yet
            m_pfnServerSupportFunc = pecb->ServerSupportFunction;
            m_pfnReadClient        = pecb->ReadClient;
            m_pfnWriteClient       = pecb->WriteClient;
            m_pfnGetServerVariable = pecb->GetServerVariable;
            
            m_fValid = TRUE;
        }
        LeaveCriticalSection( &g_csInitLock);
    }

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::SetECB(%08x) return %08x\n",
                    this, pBuf, hr));
    }
    
    return hr;
} // CcpECBObject::SetECB()



STDMETHODIMP CcpECBObject::GetECB(
    OUT int* cbSize,
    OUT unsigned char* pBuf)
{
    HRESULT hr = (m_fValid) ? S_OK : E_POINTER;

    if ( m_fValid ) {

        // There is no ECB to fill out. just return failure for these calls
        // the IcpECB object has become the Isapi Sink object (08/27/96)
        hr = E_FAIL;
    }

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::GetECB(%08x) return %08x\n",
                    this, pBuf, hr));
    }
    
    return hr;
} // CcpECBObject::GetECB()




STDMETHODIMP 
CcpECBObject::WriteClient(
                          IN long  ConnID,
                          IN int   cbSize,
                          IN unsigned char* pBuf,
                          IN long  dwReserved)
/*++
  This function forwards all the calls 
  to the Original ISAPI WriteClient callback (from ECB)

  Arguments:
    ConnID  - connection ID for identifying the connection 
    cbSize  - count of bytes to send to the client
    pBuf    - pointer to Buffer containing data
    dwReserved - DWORD containing additional flags for transmission of data.
    
  Returns:
    HRESULT - indicating success/failure.
--*/
{
    HRESULT hr = S_OK;

    if ( !m_fValid || !(m_pfnWriteClient)((LPVOID) ConnID, 
                                          pBuf, (LPDWORD)&cbSize,
                                          (DWORD ) dwReserved)
         ) { 
        hr = E_FAIL;
    }
         
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::WriteClient(%08x, cb=%d) => %08x\n",
                    this, pBuf, cbSize, hr));
    }
    
    return (hr);
} // CcpECBObject::WriteClient()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = cpecb
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I$(SDKINC)

CLIENT_STUB     =$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(IDL_FILE_NAME)_p.c
HEADER_FILE     =$(IDL_FILE_NAME).h
TLB_FILE        =$(IDL_FILE_NAME).tlb

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(TLB_FILE) dlldata.c

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)


#
#  MIDL Compile stuff
# 
$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS) $(TLB_FILE):  .\$(IDL_FILE_NAME).idl
    midl -Oi -error allocation -error ref $(IDL_FLAGS) $(CPP) .\$(IDL_FILE_NAME).idl  $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "hreq_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\ecb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cpECB.rc
//
#define IDS_CPECB_DESC	1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>



//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hreq.rc
//
#define IDS_HREQ_DESC	1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = hreq
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I$(SDKINC)

CLIENT_STUB     =$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(IDL_FILE_NAME)_p.c
HEADER_FILE     =$(IDL_FILE_NAME).h
TLB_FILE        =$(IDL_FILE_NAME).tlb
DLL_DATA        =dlldata.c

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(TLB_FILE) $(DLL_DATA)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)


#
#  MIDL Compile stuff
# 
$(TARGETS):  .\$(IDL_FILE_NAME).idl
    midl -Oi -error allocation -error ref $(IDL_FLAGS) $(CPP) $(INCS) .\$(IDL_FILE_NAME).idl

#  /header $(HEADER_FILE) /tlb $(TLB_FILE) /dlldata $(DLL_DATA) /iid $(IID_STUB) /proxy $(PROXY_STUB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat\object\makefile.inc ===
# Dummy makefile.inc file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat\proxy\makefile.inc ===
# Dummy makefile.inc file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\hreq.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       hreq.cpp

   Abstract:
      This module defines the DLL main and additional book-keeping
      functions for ATL based COM Interface

   Author:

       Murali R. Krishnan  5-Sept-1996

   Environment:

   Project:
       Internet Application Server
--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "stdafx.h"

#include "resource.h"
#include "initguid.h"

#include "hreq.h"
#include "hreqobj.hxx"
#include "dlldatax.h"

#define IID_DEFINED
#include "hreq_i.c"
# include "dbgutil.h"

/************************************************************
 *    Global Variables
 ************************************************************/

// Define the variables for ATL

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_HttpRequest, 
                     CHttpRequestObject, 
                     "CHttpRequest.RequestObject.1", 
                     "CHttpRequest.RequestObject.1", 
                     IDS_HREQ_DESC, 
                     THREADFLAGS_BOTH)
END_OBJECT_MAP()

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *    Functions 
 ************************************************************/

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {

        CREATE_DEBUG_PRINT_OBJECT( "hreq");
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            
            return ( FALSE);
        }
        
        SET_DEBUG_FLAGS( DEBUG_OBJECT | DEBUG_ERROR | DEBUG_IID);

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();

        DELETE_DEBUG_PRINT_OBJECT();
    }
        
    return TRUE;    // ok

} // DllMain()



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow()


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    IF_DEBUG( IID) {
        
        DBGPRINTF(( DBG_CONTEXT, "GetClassObject( %08x, %08x, %08x)\n",
                    rclsid, riid, ppv));
    }

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    hr = _Module.GetClassObject(rclsid, riid, ppv);

    IF_DEBUG( IID) {

        DBGPRINTF(( DBG_CONTEXT, "GetClassObject() returns %08x. (ppv=%08x)\n",
                    hr, *ppv));
    }

    return ( hr);
} // DllGetClassObject()


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = S_OK;
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.UpdateRegistry(TRUE);
    return hRes;

} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.RemoveRegistry();
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllUnregisterServer();
#endif
    return hRes;
} // DllUnregisterServer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat\object\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


# if DBG 

extern     DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
               g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS()) 


# else   // DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
               g_dwDebugFlags = (dwDefault)

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0) 

# endif // DBG


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\hreq\hreqobj.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
   
       hreqobj.cpp

   Abstract:
       This module defines the functions for CHttpRequestObject

   Author:

       Murali R. Krishnan    ( MuraliK )     5-Sept-1996 

   Environment:
    
       Win32

   Project:

       Internet Application Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "stdafx.h"
#include "hreq.h"
#include "hreqobj.hxx"
#include <iisext.h>

# include "dbgutil.h"


/************************************************************
 *    Functions 
 ************************************************************/


CHttpRequestObject::CHttpRequestObject()
    : m_pecb         ( NULL),
      m_hConn        ( NULL),
      m_fValid       ( FALSE)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "Creating CHRequestObj() ==> %08x\n",
                    this));
    }
    
} // CHttpRequestObject::CHttpRequestObject()


CHttpRequestObject::~CHttpRequestObject()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "deleting CHttpRequestObject() ==>%08x\n",
                    this));
    }

} // CHttpRequestObject::~CHttpRequestObject()


STDMETHODIMP
CHttpRequestObject::SetECB(IN long lpECB)
{
    HRESULT hr = S_OK;
    EXTENSION_CONTROL_BLOCK * pECB = (EXTENSION_CONTROL_BLOCK * ) lpECB;

    DBG_ASSERT( pECB != NULL);
    
    if ( pECB == NULL) {
        hr = ( E_POINTER);
    } else {
        if (pECB->cbSize != sizeof(EXTENSION_CONTROL_BLOCK)) {
            hr = E_INVALIDARG;
        } else {
            m_pecb   = pECB;
            m_hConn  = pECB->ConnID;
            m_fValid = TRUE;
        }
    } 

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::SetECB(%08x) return %08x\n",
                    this, lpECB, hr));
    }

    return ( hr);
} // CHttpRequestObject::SetECB()


STDMETHODIMP 
CHttpRequestObject::GetECB( OUT long * lpECB)
{
    EXTENSION_CONTROL_BLOCK * pECB = (EXTENSION_CONTROL_BLOCK * ) lpECB;

    HRESULT hr = (m_fValid) ? S_OK : E_POINTER;

    //
    // This is broken now :(
    //

    hr = E_NOTIMPL;

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::GetECB(%08x) return %08x\n",
                    this, lpECB, hr));
    }
    
    return hr;
} // CHttpRequestObject::GetECB()


STDMETHODIMP 
CHttpRequestObject::WriteClient(
                                IN int   cbSize,
                                IN unsigned char* pBuf,
                                IN long  dwReserved)
/*++
  This function forwards all the calls 
  to the Original ISAPI WriteClient callback (from ECB)

  Arguments:
    cbSize  - count of bytes to send to the client
    pBuf    - pointer to Buffer containing data
    dwReserved - DWORD containing additional flags for transmission of data.
    
  Returns:
    HRESULT - indicating success/failure.
--*/
{
    HRESULT hr = S_OK;

    DBG_ASSERT( m_pecb != NULL);

    if ( !m_fValid || !(m_pecb->WriteClient)( m_pecb->ConnID, 
                                              pBuf, (LPDWORD)&cbSize,
                                              (DWORD ) dwReserved)
         ) {
        
        hr = E_FAIL;
    }
         
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::WriteClient(%08x, cb=%d) => %08x\n",
                    this, pBuf, cbSize, hr));
    }
    
    return (hr);
} // CHttpRequestObject::WriteClient()



STDMETHODIMP
CHttpRequestObject::GetServerVariable( IN LPCSTR  pszName,
                                       IN int     cbSize,
                                       OUT unsigned char* pchBuf,
                                       OUT int *  pcbReturn
                                       )
{
    HRESULT hr = S_OK;

    if ( (NULL == pszName) || 
         (NULL == pchBuf)  ||
         (NULL == pcbReturn)
         ) {
        
        hr = ( E_POINTER);
    } else {

        *pcbReturn = cbSize;

        // We should fix GetServerVariable() to take LPCSTR :(
        if ( !m_fValid || 
             !(m_pecb->GetServerVariable)( m_pecb->ConnID, 
                                           (LPSTR ) pszName, 
                                           (LPVOID) pchBuf,
                                           (LPDWORD)pcbReturn
                                           )
             ) {
            
            hr = E_FAIL;
        }
    }


    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::GetServerVariable(%s, cb=%d, %08x, %08x) =>"
                    " %08x\n",
                    this, pszName, cbSize, pchBuf, pcbReturn, hr));
    }
    
    return ( hr);
} // CHttpRequestObject::GetServerVariable()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat\object\isat.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       isat.cpp

   Abstract:
      This module defines the DLL main and additional book-keeping
      functions for ATL based COM Interface for Internet Server Application 
       Test Object

   Author:

       Murali R. Krishnan  6-Sept-1996

   Environment:
       Win32 

   Project:
       Internet Application Server
--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "stdafx.hxx"

#include "resource.h"
#include "initguid.h"

#include "isat.h"
#include "isatobj.hxx"

#define IID_DEFINED
#include "isat_i.c"
# include "dbgutil.h"

/************************************************************
 *    Global Variables
 ************************************************************/

// Define the variables for ATL

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_InetServerApp, 
                     CInetServerAppObject, 
                     "ISA.InetServerAppObject.1", 
                     "ISA.InetServerAppObject.1", 
                     IDS_ISAT_DESC, 
                     THREADFLAGS_BOTH)
END_OBJECT_MAP()

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *    Functions 
 ************************************************************/

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {

        CREATE_DEBUG_PRINT_OBJECT( "isat");
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            
            return ( FALSE);
        }
        
        SET_DEBUG_FLAGS( DEBUG_OBJECT | DEBUG_ERROR | DEBUG_IID);

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();

        DELETE_DEBUG_PRINT_OBJECT();
    }
        
    return TRUE;    // ok

} // DllMain()



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow()


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    IF_DEBUG( IID) {
        
        DBGPRINTF(( DBG_CONTEXT, "GetClassObject( %08x, %08x, %08x)\n",
                    rclsid, riid, ppv));
    }

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    hr = _Module.GetClassObject(rclsid, riid, ppv);

    IF_DEBUG( IID) {

        DBGPRINTF(( DBG_CONTEXT, "GetClassObject() returns %08x. (ppv=%08x)\n",
                    hr, *ppv));
    }

    return ( hr);
} // DllGetClassObject()


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = S_OK;
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.UpdateRegistry(TRUE);
    return hRes;

} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.RemoveRegistry();
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllUnregisterServer();
#endif
    return hRes;
} // DllUnregisterServer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat\object\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by isat.rc
//
#define IDS_ISAT_DESC	1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat1\object\makefile.inc ===
# Dummy makefile.inc file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat1\object\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n", 
    //                     GUID_EXPAND( pMyGuid)));


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat1\object\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by isat.rc
//
#define IDS_ISAT_DESC	1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat1\proxy\makefile.inc ===
# Dummy makefile.inc file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat\object\isatobj.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       isatobj.cpp

   Abstract:

       This module defines the functions for CInetServerAppObject

   Author:

       Murali R. Krishnan    ( MuraliK )     6-Sept-1996 

   Project:

       Internet Application Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "windows.h"
# include "stdafx.hxx"
# include "isat.h"
# include "isatobj.hxx"

#include <iisext.h>

#define IID_DEFINED
#include "hreq.h"
#include "hreq_i.c"
# include "dbgutil.h"


char sg_rgchOutput[] = 
   "HTTP/1.0 200 OK\r\n"
   "Content-Type: text/html\r\n"
   "\r\n<html>\r\n"
   "<h1>\nHello from CInetServerAppObject (%08x)\r\n</h1>"
   "<pre> %s </pre>"
   "</html>\r\n";

# define MAX_REPLY_SIZE   (1024)
# define MAX_HTTP_HEADER_SIZE  (800)

/************************************************************
 *    Functions 
 ************************************************************/

/************************************************************
 *  Member functions of  CComIsapi
 ************************************************************/


CInetServerAppObject::CInetServerAppObject()
    : m_pHttpRequest   ( NULL)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "creating CInetServerAppObject() ==>%08x\n",
                    this));
    }

    return;
} // CInetServerAppObject::CInetServerAppObject()



CInetServerAppObject::~CInetServerAppObject()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "deleting CInetServerAppObject() ==>%08x\n",
                    this));
    }

    if ( NULL != m_pHttpRequest) { 
        
        m_pHttpRequest->Release();
        m_pHttpRequest = NULL;
    }

} // CInetServerAppObject::CInetServerAppObject()


STDMETHODIMP
CInetServerAppObject::SetContext( IN IUnknown * punkRequest)
{
    HRESULT hr = E_POINTER;

    if ( NULL != punkRequest) { 

        // Obtain the Request object itself
        hr = punkRequest->QueryInterface(IID_IHttpRequest, 
                                         (void**)&m_pHttpRequest);
    }
        
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "CISAObject[%08x]::SetContext("
                    " punkReq = %08x"
                    ") pHttpReq = %08x =>hr=%08x\n"
                    ,
                    this, punkRequest, m_pHttpRequest, hr));
    }

    return (hr);

} // CInetServerAppObject::SetContext()



STDMETHODIMP
CInetServerAppObject::ProcessRequest( OUT unsigned long * pdwStatus)
{
    HRESULT hr;
    
    if ( NULL == m_pHttpRequest) {
        hr = E_POINTER;
    } else {
        char  rgchReply[MAX_REPLY_SIZE];
        char  rgchAllHttp[MAX_HTTP_HEADER_SIZE];
        int   cbSize = sizeof(rgchAllHttp);

        // 
        // 1. Obtain all the HTTP headers
        // 2. Format the output block 
        // 3. WriteClient() to send the response to client
        //
        
        rgchAllHttp[0] = '\0';  // init
        hr = m_pHttpRequest->GetServerVariable( "ALL_RAW",
                                                cbSize,
                                                (unsigned char * )rgchAllHttp,
                                                &cbSize);
        if ( !SUCCEEDED( hr)) {
            
            cbSize = wsprintfA( rgchAllHttp,
                                " %08x::GetServerVariable() failed. HR=%08x\n",
                                m_pHttpRequest, hr);
        }
        
        cbSize = wsprintfA( rgchReply, sg_rgchOutput, this, rgchAllHttp);
        DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
        hr = m_pHttpRequest->WriteClient( cbSize, (unsigned char *) rgchReply, 0);
    }

    DBG_ASSERT( NULL != pdwStatus);

    *pdwStatus = (SUCCEEDED( hr) ? HSE_STATUS_SUCCESS: HSE_STATUS_ERROR);
    
    return S_OK;
} // CInetServerAppObjet::ProcessRequest()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat1\object\dofunc.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
     dofunc.cxx

   Abstract:
     This module contains the support functions for 
      Internet Server Application test object.

   Author:

       Murali R. Krishnan    ( MuraliK )     05-Dec-1996 

   Environment:
       User Mode - Win32
       
   Project:

       Internet Application Server Test DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "windows.h"
# include "stdafx.hxx"
# include "isat.h"
# include "isatobj.hxx"

#include <iisext.h>
# include "dofunc.hxx"


/************************************************************
 *    Functions 
 ************************************************************/

char sg_rgchOutputVar[] = 
   "<html><title> ISA Test: Display Variables\r\n"
   "<h1>\nHello from CInetServerAppObject():%s\r\n</h1>"
   "<pre>%s = %s</pre>"
   "</html>\r\n";



HRESULT
do_get_var(
           IN IIsaResponse * pResp, 
           IN IIsaRequest *  pReq,
           IN LPCSTR         pszVariable
           )
{
    HRESULT hr;
    CHAR   rgchReply[ MAX_REPLY_SIZE];
    CHAR   pchValue[MAX_HTTP_HEADER_SIZE];
    unsigned long cbValue = sizeof(pchValue);

    hr = pReq->GetServerVariable( pszVariable, cbValue, 
                                  (unsigned char * ) pchValue, &cbValue);
    
    if ( !SUCCEEDED( hr)) {

        wsprintfA( rgchReply, "GetServerVariable( %s) failed\n",
                   pszVariable);
        
        hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        
    } else {
        unsigned long  cbSize;
        
        hr = pResp->SendHeader( (unsigned char *) sg_rgch200OK,
                                (unsigned char *) sg_rgchTextHtml);
        
        if ( SUCCEEDED( hr)) {
            strcat( pchValue, "\r\n" );
            
            cbSize = wsprintfA( rgchReply, sg_rgchOutputVar, 
                                "GET_VAR",
                                pszVariable, pchValue);
            DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
            hr = pResp->WriteClient( cbSize, 
                                     (unsigned char *) rgchReply, 
                                     &cbSize);
        } else {
            cbSize = strlen( sg_rgchSendHeaderFailed);
            hr = pResp->WriteClient( cbSize, 
                                     (unsigned char * ) 
                                     sg_rgchSendHeaderFailed, 
                                     &cbSize);
        }
    }

    return ( hr);
} // do_get_var()



HRESULT
do_server_var(
    IN IIsaResponse * pResp, 
    IN IIsaRequest *  pReq,
    IN LPCSTR         pszVariable
    )
{
    HRESULT hr;
    CHAR   rgchReply[ MAX_REPLY_SIZE];
    IIsaRequestDictionary * psvDict = NULL;

    hr = pReq->ServerVariables( &psvDict);
    
    if ( !SUCCEEDED( hr)) {

        wsprintfA( rgchReply, "Req::ServerVariables( %08x) failed\n",
                   &psvDict);
        
        hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        
    } else {

        CHAR   pchValue[MAX_HTTP_HEADER_SIZE];
        unsigned long cbValue = sizeof(pchValue);
        unsigned long  cbSize;
        
        //
        // get the item for given variable 
        //  after terminating the first one at the '=' sign
        //
        LPSTR pszX = (LPSTR ) strchr(pszVariable, '=');
        pszX = (( pszX != NULL)? pszX : 
                (CHAR * ) ( pszVariable + strlen( pszVariable))
                );
        *pszX = '\0';

        hr = psvDict->Item( pszVariable, cbValue, 
                            (unsigned char * ) pchValue, 
                            &cbValue);

        if ( SUCCEEDED( hr)) {
            
            hr = pResp->SendHeader( (unsigned char *) sg_rgch200OK,
                                    (unsigned char *) sg_rgchTextHtml);
            
            if ( SUCCEEDED( hr)) {
                strcat( pchValue, "\r\n" );
                
                cbSize = wsprintfA( rgchReply, sg_rgchOutputVar, 
                                    "SERVER_VAR",
                                    pszVariable, pchValue);
                DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
                hr = pResp->WriteClient( cbSize, 
                                         (unsigned char *) rgchReply, 
                                         &cbSize);
            } else {
                cbSize = strlen( sg_rgchSendHeaderFailed);
                hr = pResp->WriteClient( cbSize, 
                                         (unsigned char * ) 
                                         sg_rgchSendHeaderFailed, 
                                         &cbSize);
            }
        } else {

            wsprintfA( rgchReply, "Req::ServerVariables( %08x, %s) failed\n",
                       &psvDict, pszVariable);
        
            hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        }

        psvDict->Release();
    }

    return ( hr);
} // do_server_var()



HRESULT
do_query_string(
    IN IIsaResponse * pResp, 
    IN IIsaRequest *  pReq,
    IN LPCSTR         pszVariable
    )
{
    HRESULT hr;
    CHAR   rgchReply[ MAX_REPLY_SIZE];
    IIsaRequestDictionary * psvDict = NULL;

    hr = pReq->QueryString( &psvDict);
    
    if ( !SUCCEEDED( hr)) {

        wsprintfA( rgchReply, "Req::QueryString( %08x) failed\n",
                   &psvDict);
        
        hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        
    } else {

        CHAR   pchValue[MAX_HTTP_HEADER_SIZE];
        unsigned long cbValue = sizeof(pchValue);
        unsigned long  cbSize;
        
        //
        // get the item for given variable 
        //  after terminating the first one at the '=' sign
        //
        LPSTR pszX = (LPSTR ) strchr(pszVariable, '=');
        pszX = (( pszX != NULL)? pszX : 
                (CHAR * ) ( pszVariable + strlen( pszVariable))
                );
        *pszX = '\0';

        hr = psvDict->Item( pszVariable, cbValue, 
                            (unsigned char * ) pchValue, 
                            &cbValue);

        if ( SUCCEEDED( hr)) {
            
            hr = pResp->SendHeader( (unsigned char *) sg_rgch200OK,
                                    (unsigned char *) sg_rgchTextHtml);
            
            if ( SUCCEEDED( hr)) {
                strcat( pchValue, "\r\n" );
                
                cbSize = wsprintfA( rgchReply, sg_rgchOutputVar, 
                                    "QUERY_STRING",
                                    pszVariable, pchValue);
                DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
                hr = pResp->WriteClient( cbSize, 
                                         (unsigned char *) rgchReply, 
                                         &cbSize);
            } else {
                cbSize = strlen( sg_rgchSendHeaderFailed);
                hr = pResp->WriteClient( cbSize, 
                                         (unsigned char * ) 
                                         sg_rgchSendHeaderFailed, 
                                         &cbSize);
            }
        } else {

            wsprintfA( rgchReply, "Req::QueryString( %08x, %s) failed\n",
                       &psvDict, pszVariable);
        
            hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        }

        psvDict->Release();
    }

    return ( hr);
} // do_query_string()




HRESULT
do_post_form(
    IN IIsaResponse * pResp, 
    IN IIsaRequest *  pReq,
    IN LPCSTR         pszVariable
    )
{
    HRESULT hr;
    CHAR   rgchReply[ MAX_REPLY_SIZE];
    IIsaRequestDictionary * psvDict = NULL;

    hr = pReq->Form( &psvDict);
    
    if ( !SUCCEEDED( hr)) {

        wsprintfA( rgchReply, "Req::Form( %08x) failed\n",
                   &psvDict);
        
        hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        
    } else {

        CHAR   pchValue[MAX_HTTP_HEADER_SIZE];
        unsigned long cbValue = sizeof(pchValue);
        unsigned long  cbSize;
        
        //
        // get the item for given variable 
        //  after terminating the first one at the '=' sign
        //
        LPSTR pszX = (LPSTR ) strchr(pszVariable, '=');
        pszX = (( pszX != NULL)? pszX : 
                (CHAR * ) ( pszVariable + strlen( pszVariable))
                );
        *pszX = '\0';

        hr = psvDict->Item( pszVariable, cbValue, 
                            (unsigned char * ) pchValue, 
                            &cbValue);

        if ( SUCCEEDED( hr)) {
            
            hr = pResp->SendHeader( (unsigned char *) sg_rgch200OK,
                                    (unsigned char *) sg_rgchTextHtml);
            
            if ( SUCCEEDED( hr)) {
                strcat( pchValue, "\r\n" );
                
                cbSize = wsprintfA( rgchReply, sg_rgchOutputVar, 
                                    "POST_FORM",
                                    pszVariable, pchValue);
                DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
                hr = pResp->WriteClient( cbSize, 
                                         (unsigned char *) rgchReply, 
                                         &cbSize);
            } else {
                cbSize = strlen( sg_rgchSendHeaderFailed);
                hr = pResp->WriteClient( cbSize, 
                                         (unsigned char * ) 
                                         sg_rgchSendHeaderFailed, 
                                         &cbSize);
            }
        } else {

            wsprintfA( rgchReply, "Req::Form( %08x, %s) failed\n",
                       &psvDict, pszVariable);
        
            hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        }

        psvDict->Release();
    }

    return ( hr);
} // do_post_form()



HRESULT
do_certificate_access(
    IN IIsaResponse * pResp, 
    IN IIsaRequest *  pReq
    )
{
    HRESULT hr;
    CHAR   rgchReply[ MAX_REPLY_SIZE];
    CHAR   pchCert[MAX_HTTP_HEADER_SIZE];
    unsigned long cbCert = sizeof(pchCert);
    unsigned long dwFlags;
    unsigned long  cbSize;
    
    //
    // 1. Do the client certificate first
    //

    hr = pReq->ClientCertificate( cbCert - 1, 
                                  (unsigned char * ) pchCert, 
                                  &cbCert,
                                  &dwFlags);
    
    if ( !SUCCEEDED( hr)) {

        wsprintfA( rgchReply, "[%08x]::ClientCertificate() failed. "
                   " BytesReqd = %d\n",
                   pReq, cbCert);
        
        hr = SendMessageToClient( pResp, pReq, rgchReply, hr);
        
        return ( hr);
    } 

    pchCert[cbCert] = '\0';

    // Send the client certificate over
    
    hr = pResp->SendHeader( (unsigned char *) sg_rgch200OK,
                            (unsigned char *) sg_rgchTextHtml);
    
    if ( SUCCEEDED( hr)) {
        
        cbSize = 
            wsprintfA( 
                      rgchReply,
                      "<html><title> ISA Test: Display Certificates</title>"
                      "<h1>\nHello from CInetServerAppObject(%08x):%s<p></h1>"
                      " Flags = %08x; Size = %d bytes<p>"
                      "<pre>%s</pre>"
                      , pReq, "Client Certificate",
                      dwFlags, cbCert,
                      pchCert
                      );

        DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
        hr = pResp->WriteClient( cbSize, 
                                 (unsigned char *) rgchReply, 
                                 &cbSize);
    } else {
        cbSize = strlen( sg_rgchSendHeaderFailed);
        hr = pResp->WriteClient( cbSize, 
                                 (unsigned char * ) 
                                 sg_rgchSendHeaderFailed, 
                                 &cbSize);
    }


    //
    // 2. Do the server certificate second
    //

    cbCert = sizeof( pchCert);
    hr = pReq->ServerCertificate( cbCert - 1, 
                                  (unsigned char * ) pchCert, 
                                  &cbCert,
                                  &dwFlags);
    
    if ( !SUCCEEDED( hr)) {

        cbSize = 
            wsprintfA( rgchReply, 
                       " [%08x]::ServerCertificate() failed. BytesReqd = %d\n",
                       pReq, cbCert);
        
        hr = pResp->WriteClient( cbSize, 
                                 (unsigned char * ) rgchReply,
                                 &cbSize);
        return ( hr);
    } 

    pchCert[cbCert] = '\0';

    if ( SUCCEEDED( hr)) {
        
        cbSize = 
            wsprintfA( 
                      rgchReply,
                      "<html><title> ISA Test: Display Certificates</title>"
                      "<h1>\nHello from CInetServerAppObject(%08x):%s<p></h1>"
                      " Flags = %08x; Size = %d bytes<p>"
                      "<pre>%s</pre>"
                      , pReq, "Server Certificate",
                      dwFlags, cbCert,
                      pchCert
                      );
        
        DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
        hr = pResp->WriteClient( cbSize, 
                                 (unsigned char *) rgchReply, 
                                 &cbSize);
    } else {
        cbSize = strlen( sg_rgchSendHeaderFailed);
        hr = pResp->WriteClient( cbSize, 
                                 (unsigned char * ) 
                                 sg_rgchSendHeaderFailed, 
                                 &cbSize);
    }
    
    return ( hr);
} // do_certificate_access()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat1\object\isat.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       isat.cpp

   Abstract:
      This module defines the DLL main and additional book-keeping
      functions for ATL based COM Interface for Internet Server Application 
       Test Object

   Author:

       Murali R. Krishnan  4-Nov-1996

   Environment:
       Win32 

   Project:
       Internet Application Server
--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "stdafx.hxx"

#include "resource.h"
#include "initguid.h"

#include "isat.h"
#include "isatobj.hxx"

#define IID_DEFINED
#include "isat_i.c"

#define DEFAULT_TRACE_FLAGS     (DEBUG_OBJECT | DEBUG_ERROR | DEBUG_IID)

# include "dbgutil.h"

/************************************************************
 *    Global Variables
 ************************************************************/

// Define the variables for ATL

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_InetServerApp, 
                     CInetServerAppObject, 
                     "ISA.InetServerAppObject.1", 
                     "ISA.InetServerAppObject.1", 
                     IDS_ISAT_DESC, 
                     THREADFLAGS_BOTH)
END_OBJECT_MAP()

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisIsAtGuid, 
0x784d8930, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *    Functions 
 ************************************************************/

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( "isat");
#else
        CREATE_DEBUG_PRINT_OBJECT( "isat", IisIsAtGuid);
#endif
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            
            return ( FALSE);
        }

#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS( DEBUG_OBJECT | DEBUG_ERROR | DEBUG_IID);
#endif

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();

        DELETE_DEBUG_PRINT_OBJECT();
    }
        
    return TRUE;    // ok

} // DllMain()



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow()


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    IF_DEBUG( IID) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "GetClassObject(" GUID_FORMAT ", " GUID_FORMAT ", %08x)\n",
                    GUID_EXPAND( &rclsid),
                    GUID_EXPAND( &riid),
                    ppv));
    }

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    hr = _Module.GetClassObject(rclsid, riid, ppv);

    IF_DEBUG( IID) {

        DBGPRINTF(( DBG_CONTEXT, "GetClassObject() returns %08x. (ppv=%08x)\n",
                    hr, *ppv));
    }

    return ( hr);
} // DllGetClassObject()


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = S_OK;
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.UpdateRegistry(TRUE);
    return hRes;

} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.RemoveRegistry();
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllUnregisterServer();
#endif
    return hRes;
} // DllUnregisterServer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "sobj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isattest\isainst.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      isainst.cpp

   Abstract:
      This module defines the functions for Internet Server Application
        Instance and Instance Pool

   Author:

       Murali R. Krishnan    ( MuraliK )     9-Sept-1996 

   Environment:
       Win32 
       
   Project:

       Internet Application Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "isainst.hxx"
# include "dbgutil.h"

# ifdef MTX_ENABLED
#include <vipapi.h>
# endif // MTX_ENABLED

#define IID_DEFINED

# ifdef MTX_ENABLED

#include <txctx.h>
#include <txctx_i.c>

# endif // MTX_ENABLED

#include "isat_i.c"
#include "hreq_i.c"

/************************************************************
 *    Functions 
 ************************************************************/

PISA_INSTANCE
CreateNewInstance( IN LPCLSID pclsid);



/************************************************************
 *  Member functions of ISA_INSTANCE
 ************************************************************/

ISA_INSTANCE::ISA_INSTANCE(VOID)
    : m_fInUse   ( FALSE),
      m_pIsa     ( NULL),
      m_pHttpReq ( NULL),
      m_fInstantiated ( FALSE)
{

    InitializeListHead( &m_listEntry);

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Created ISA_INSTANCE %08x\n",
                    this));
    }

} // ISA_INSTANCE::ISA_INSTANCE()

ISA_INSTANCE::~ISA_INSTANCE(VOID)
{
    DBG_ASSERT( !m_fInUse);

    if ( m_pIsa != NULL) {
        m_pIsa->Release();
        m_pIsa = NULL;
    }

    if ( m_pHttpReq != NULL) { 
        m_pHttpReq->Release();
        m_pHttpReq = NULL;
    }

    m_fInUse = FALSE;
    m_fInstantiated = FALSE;

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Deleted ISA_INSTANCE %08x\n",
                    this));
    }

} // ISA_INSTANCE::~ISA_INSTANCE()



BOOL
ISA_INSTANCE::Instantiate( IN LPCLSID pclsid)
{
    HRESULT hr;
    DBG_ASSERT( !m_fInstantiated);
    DBG_ASSERT( NULL == m_pIsa);
    DBG_ASSERT( NULL == m_pHttpReq);
    DBG_ASSERT( NULL != pclsid);

    m_clsidIsa = *pclsid;

# ifdef VIPER
    // Get a Viper transaction context object (should only do once)
    hr = CoCreateInstance(CLSID_TransactionContextEx, NULL,
                          CLSCTX_SERVER, 
                          IID_ITransactionContextEx, (void**)&m_pTxContext);
    if (!SUCCEEDED(hr)) goto Err;
# endif

    
#ifndef VIPER
    hr = CoCreateInstance(m_clsidIsa, NULL,
                          CLSCTX_SERVER, IID_IInetServerApp, 
                          (void ** ) &m_pIsa);
#else
    // Create the COMISAPI instance that wraps the ISAPI DLL
    hr = m_pTxContext->CreateInstance( m_clisidIsa, IID_IInetServerApp, 
                                       (void **) &m_pIsa);
# endif NO_VIPER
    if (!SUCCEEDED(hr)) goto Err;
        
    // NYI: Wrap the ECB in a Viper context property 
    hr = CoCreateInstance(CLSID_HttpRequest, NULL, CLSCTX_SERVER, 
                          IID_IHttpRequest, (void **) &m_pHttpReq);
    if (!SUCCEEDED(hr)) goto Err;

    // store the context in the created ISA instance
    hr = m_pIsa->SetContext( m_pHttpReq);
    if (!SUCCEEDED(hr)) goto Err;

Err:
    if (!SUCCEEDED(hr)) {

        Print();

        DBGPRINTF(( DBG_CONTEXT, " Error = %0x8x\n", hr));

#ifdef VIPER
        if (m_pTxContext) {
            m_pTxContext->Release();
            m_ppTxContext = NULL;
        }
#endif // VIPER

        if ( m_pIsa) {
            m_pIsa->Release();
            m_pIsa = NULL;
        }

        if ( m_pHttpReq) {
            m_pHttpReq->Release();
            m_pHttpReq = NULL;
        }
    } else {
        m_fInstantiated = TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[%08x]::Instantiate( %08x) returns hr=%08x \n",
                this, pclsid, hr
                ));
    
    return ( (SUCCEEDED(hr)? TRUE : FALSE));

} // ISA_INSTANCE::Instantiate()



HRESULT 
ISA_INSTANCE::ProcessRequest(IN EXTENSION_CONTROL_BLOCK * pecb, 
                             OUT LPDWORD pdwStatus)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( m_fInstantiated);
    DBG_ASSERT( NULL != m_pIsa);
    DBG_ASSERT( NULL != m_pHttpReq);
    DBG_ASSERT( !m_fInUse);

    m_fInUse = TRUE;
    hr = m_pHttpReq->SetECB( (long ) pecb);
    if ( SUCCEEDED( hr)) {
        hr = m_pIsa->ProcessRequest( pdwStatus);
    }

    m_fInUse = FALSE;

    IF_DEBUG( OBJECT) {
        DBGPRINTF(( DBG_CONTEXT,
                    "[%08x]ISA_INSTANCE::ProcessRequest() returns %08x"
                    ,
                    this, hr));
    }

    return ( hr);
} // ISA_INSTANCE::ProcessRequest()



void
ISA_INSTANCE::Print(VOID) const
{
    DBGPRINTF(( DBG_CONTEXT, 
                "ISA_INSTANCE(%08x):"
                " pIsa=%08x; pHttpReq=%08x; "
                " fInUse=%d; fInstantiated=%d"
                "\n"
                ,
                this, m_pIsa, m_pHttpReq, 
                m_fInUse, m_fInstantiated
                ));
    return;
} // ISA_INSTANCE::Print()



/************************************************************
 *  Member functions of ISA_INSTANCE
 ************************************************************/

ISA_INSTANCE_POOL::ISA_INSTANCE_POOL(VOID)
    : m_fInstantiated ( FALSE),
      m_nFreeEntries  ( 0),
      m_nActiveEntries( 0)
{

    m_rgchProgId[0] = L'\0';
    
    InitializeCriticalSection( & m_csLock);
    InitializeListHead( &m_lActiveEntries);
    InitializeListHead( &m_lFreeEntries);

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Created ISA_INSTANCE_POOL %08x\n",
                    this));
    }

} // ISA_INSTANCE_POOL::ISA_INSTANCE_POOL()


ISA_INSTANCE_POOL::~ISA_INSTANCE_POOL(VOID)
{
    PLIST_ENTRY pl;

    DBG_ASSERT( IsListEmpty( &m_lActiveEntries));
    DBG_ASSERT( 0 == m_nActiveEntries);

    // free up all the instances in the pool
    for( pl = m_lFreeEntries.Flink; 
         pl != &m_lFreeEntries; 
         m_nFreeEntries-- ) {
        
        PLIST_ENTRY plNext;

        PISA_INSTANCE pisaInstance = 
            CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);

        plNext = pl->Flink;

        DBG_ASSERT( pisaInstance);
        RemoveEntryList( pl);
        delete pisaInstance;
        pl = plNext;

    } // for

    DBG_ASSERT( IsListEmpty(&m_lFreeEntries));
    DBG_ASSERT( 0 == m_nFreeEntries);
    
    m_fInstantiated = FALSE;

    DeleteCriticalSection( & m_csLock);

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Deleted ISA_INSTANCE_POOL %08x\n",
                    this));
    }

} // ISA_INSTANCE_POOL::~ISA_INSTANCE_POOL()



VOID
ISA_INSTANCE_POOL::Print(VOID)
{
    PLIST_ENTRY pl;
    
    DBGPRINTF(( DBG_CONTEXT, 
                "ISA_INSTANCE_POOL (%08x):"
                " ProgId = %ws. Instantiated=%d"
                " Instances #Free = %d; #Active = %d"
                "\n"
                ,
                this, m_rgchProgId,
                m_fInstantiated,
                m_nFreeEntries, m_nActiveEntries
                ));

    Lock();
    // Print all free entries
    DBGPRINTF(( DBG_CONTEXT, " Free Entries \n"));
    for( pl = m_lFreeEntries.Flink; pl != &m_lFreeEntries; 
         pl = pl->Flink) {
        
        PISA_INSTANCE pisaInstance = 
            CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);
        
        pisaInstance->Print();
    } // for

    // Print all active entries
    DBGPRINTF(( DBG_CONTEXT, " Active Entries \n"));
    for( pl = m_lActiveEntries.Flink; pl != &m_lActiveEntries; 
         pl = pl->Flink) {
        
        PISA_INSTANCE pisaInstance = 
            CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);
        
        pisaInstance->Print();
    } // for

    Unlock();

    return;
} // ISA_INSTANCE_POOL::Print()



BOOL
ISA_INSTANCE_POOL::Instantiate( IN LPCWSTR pszProgId)
/*++
  ISA_INSTANCE_POOL::Instantiate()

  o  This function instantiates the instance pool. It stores the 
     program ID supplied as well as the class ID for the given object.
     In the future new instances maybe created in this instance pool
     using these values.

  Arguments:
    pszProgId - pointer to null-terminated-string containing the ProgID
                  for instance objects

  Returns:
    TRUE on success and FALSE if there is any error.
--*/
{
    HRESULT hr;
    DBG_ASSERT( !m_fInstantiated);
    DBG_ASSERT( m_rgchProgId[0] == L'\0');

    // Get the clsid for the instance
    hr = CLSIDFromProgID( pszProgId, &m_clsidIsa);

    if (!SUCCEEDED(hr)) {

        Print();

        DBGPRINTF(( DBG_CONTEXT, 
                    "ISA_INSTANCE_POOL::Instantiate(%ws) Error = %0x8x\n", 
                    pszProgId, hr));
    } else {
        // make a local copy of the ProgId
        lstrcpynW( m_rgchProgId, pszProgId,
                   (sizeof( m_rgchProgId) - 1)/sizeof(WCHAR));
        m_fInstantiated = TRUE;
    }

    return ( (SUCCEEDED(hr)? TRUE : FALSE));

} // ISA_INSTANCE_POOL::Instantiate()



PISA_INSTANCE
ISA_INSTANCE_POOL::GetInstance(void)
{
    PISA_INSTANCE pisa = NULL;

    DBG_ASSERT( m_fInstantiated);

    //
    // 1. Look for a free instance
    // 2. If a free one is found, 
    //        move it to active list and return pointer for the same
    // 3. If no free instance is found, create a new instance
    // 4. Send the new instance off to the caller after putting it in
    //     the active list.
    //

    if ( m_nFreeEntries > 0) {
        
        // Aha! there may be free entries, lock and pull one out.
        Lock();
        
        if ( m_nFreeEntries > 0) {
            // remove an item from the list
            PLIST_ENTRY pl = m_lFreeEntries.Flink;
            RemoveEntryList( pl);
            
            pisa = CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);
            DBG_ASSERT( pisa != NULL);
            m_nFreeEntries--;
            DBG_ASSERT( m_nFreeEntries >= 0);

            InsertTailList( &m_lActiveEntries, pl);
            m_nActiveEntries++;
            DBG_ASSERT( m_nActiveEntries > 0);
        }
        Unlock();
    }

    if ( NULL == pisa) {

        // we did not find an item. we need to create a new instance

        // create a new instance
        pisa = CreateNewInstance( &m_clsidIsa);

        if ( pisa != NULL) {
            
            // Successfully created  a new instance. Add it to the list.
            Lock();
            InsertTailList( &m_lActiveEntries, &pisa->m_listEntry);
            m_nActiveEntries++;
            DBG_ASSERT( m_nActiveEntries > 0);
            Unlock();
        } else {
            
            // there was an error in creating the instance.
        }
    }

    return ( pisa);
 
} // ISA_INSTANCE_POOL::GetInstance()



BOOL
ISA_INSTANCE_POOL::ReleaseInstance( PISA_INSTANCE pisaInstance)
{
    DBG_ASSERT( NULL != pisaInstance);
    
    //
    // 1. Remove the request from the active list
    // 2. Add this new item to the free list
    // 3. Adjust the counts appropriately
    //

    Lock();

    DBG_ASSERT( m_nActiveEntries > 0);
    RemoveEntryList( &pisaInstance->m_listEntry);
    m_nActiveEntries--;
    DBG_ASSERT( m_nActiveEntries >= 0);
    
    InsertHeadList( &m_lFreeEntries, &pisaInstance->m_listEntry);
    m_nFreeEntries++;
    DBG_ASSERT( m_nFreeEntries > 0);
    
    Unlock();

    return (TRUE);
} // ISA_INSTANCE_POOL::ReleaseInstance()



PISA_INSTANCE
CreateNewInstance( IN LPCLSID pclsid)
{
    PISA_INSTANCE pisa;
    
    pisa = new ISA_INSTANCE();
    if ( NULL == pisa ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "Creating ISA_INSTANCE failed. \n"
                    ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    } else {
        if ( !pisa->Instantiate( pclsid )) {
            
            DBGPRINTF(( DBG_CONTEXT,
                        "[%08x]::Instantiate( %08x) failed. Error=%d \n",
                        pisa, pclsid, GetLastError()
                        ));
     
            delete pisa;
            pisa = NULL;
        }
    }

    return ( pisa);
} // CreateNewInstance()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isattest\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN) 

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isattest\isattest.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :
       isattest.cpp

   Abstract:
       This module defines the Test ISAPI DLL for driving 
         InetServerApp
 
   Author:

       Murali R. Krishnan    ( MuraliK )     6-Sept-1996 

   Project:

       Internet Application Server DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "isainst.hxx"
#include <objbase.h>

# include "dbgutil.h"


# define PSZ_PROGID_TEST1   L"MSISA.Test1"

/************************************************************
 *     Variable Declarations
 ************************************************************/
# ifdef COINIT_NOEX
static DWORD g_dwTLSIndex = (DWORD)-1;    // COM initialization flag
# endif // COINIT_NOEX

BOOL   g_fComInit = FALSE;

ISA_INSTANCE_POOL * g_pisaPool = NULL;

DECLARE_DEBUG_PRINTS_OBJECT();                  
DECLARE_DEBUG_VARIABLE();

HRESULT 
IsapiToISA( EXTENSION_CONTROL_BLOCK * pECB, LPDWORD pdwStatus);

const  char PSZ_FAILURE_MSG[] = "<HTML> This call failed\n</HTML>";
# define LEN_PSZ_FAILURE_MSG (sizeof(PSZ_FAILURE_MSG) - 1)


/************************************************************
 *     Functions
 ************************************************************/

extern "C"
BOOL 
WINAPI DllMain(HINSTANCE    hinstDll,
               DWORD        fdwReason,
               LPVOID       lpvContext
               )
/*++
  DllMain()

  o  This function isinvoked when this DLL is loaded/unloaded.
     Since IIS thread pools, we will not reliably get DLL_THREAD_ATTACH
     messages. Avoid problems by acquiring all resources on DLL_PROCESS_ATTACH
     and deallocating them on DLL_PROCESS_DETACH

  Arguments:
    hinstDll - Handle for this DLL instance
    fdwReason - flags indicating the Reason for call
    lpvContext - special context value for the call

  Returns:
    TRUE on success and FALSE if there is any error
--*/
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH: {

        HRESULT hr;

        CREATE_DEBUG_PRINT_OBJECT( "isapi");
        if ( !VALID_DEBUG_PRINT_OBJECT()) { 
            return ( FALSE);
        }
        SET_DEBUG_FLAGS( DEBUG_ERROR);


#ifdef COINIT_NOEX
        // allocate thread local storage
        if ((g_dwTLSIndex = TlsAlloc()) == -1)
            return FALSE;

# else
        hr = CoInitializeEx( NULL, 
                             (COINIT_MULTITHREADED | 
                              COINIT_DISABLE_OLE1DDE |
                              COINIT_SPEED_OVER_MEMORY)
                             );
        g_fComInit = (hr == S_OK);

        DBGPRINTF(( DBG_CONTEXT, 
                    "\tCoInitializeEx( NULL, %08x) returns %08x\n",
                    (COINIT_MULTITHREADED | 
                     COINIT_DISABLE_OLE1DDE |
                     COINIT_SPEED_OVER_MEMORY),
                    hr
                    ));
# endif // ifndef COINIT_NOEX

        // IIS thread pools, we don't want thread notifications
        // so disable them to improve performance
        DisableThreadLibraryCalls(hinstDll);
        break;
    }
    
    case DLL_PROCESS_DETACH:

#ifdef COINIT_NOEX 
        if (g_dwTLSIndex != -1)
            TlsFree(g_dwTLSIndex);
# else
        if (g_pisaPool) {
            delete g_pisaPool;
            g_pisaPool = NULL;
        }

        if ( g_fComInit) { 
            CoUninitialize();
        }
# endif // COINIT_NOEX
        
        DELETE_DEBUG_PRINT_OBJECT();
        break;
    }
    
    return TRUE;
} // DllMain()




extern "C" 
BOOL WINAPI
GetExtensionVersion(HSE_VERSION_INFO* pVer)
/*++
  GetExtensionVerion()
  o  Standard Entry point called by IIS as the first entry.
      It is called only once. It is called in the system context.
      The ISAPI application can register its version information with IIS.
      
  Arugments:
    pVer - pointer to Internet Server Application Version Inforamtion
    
  Returns:
    TRUE on success and FALSE on failure.
--*/
{
    BOOL fRet = TRUE;
    pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    strncpy(pVer->lpszExtensionDesc, "Test InetServerApp Object", 
            HSE_MAX_EXT_DLL_NAME_LEN);

    g_pisaPool = new ISA_INSTANCE_POOL();
    if ( NULL == g_pisaPool ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "Creating ISA_INSTANCE_POOL failed. \n"
                    ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        fRet = FALSE;
    } else {
        if ( !g_pisaPool->Instantiate( PSZ_PROGID_TEST1 )) {
            
            DBGPRINTF(( DBG_CONTEXT,
                        "[%08x]::Instantiate( %ws) failed. Error=%d \n",
                        g_pisaPool, PSZ_PROGID_TEST1, GetLastError()
                        ));
     
            delete g_pisaPool;
            g_pisaPool = NULL;
            fRet = FALSE;
        }
    }

    DBGPRINTF(( DBG_CONTEXT, 
                "GetExtensionVersion(%08x) returns with value %d. App=%s\n",
                pVer, fRet, pVer->lpszExtensionDesc));


    return (fRet);
} // GetExtensionVersion()




extern "C"
BOOL WINAPI
TerminateExtension( IN DWORD dwFlags)
/*++
  TerminateExtension()
  o  Standard Entry point called by IIS as the last function.
      It is called to request the unload of the ISAPI dll.
      
  Arugments:
    dwFlags - DWORD flags indicating the state of the unload.

  Returns:
    TRUE on success -> means that the DLL can be unloaded
    and FALSE if the DLL should not be unloaded yet.
--*/
{
    DBGPRINTF(( DBG_CONTEXT, "TerminateExtension (%08x)\n", dwFlags));

    // if (# current requests > 0) then do not stop.
    if ( NULL != g_pisaPool) {
        g_pisaPool->Print();
        DBG_ASSERT( g_pisaPool->NumActive() == 0);
    }

    return ( TRUE);
} // TerminateExtension()




extern "C"
DWORD WINAPI
HttpExtensionProc( EXTENSION_CONTROL_BLOCK* pECB)
/*++
  HttpExtensionProc()
  o  The main function for processing the ISAPI application requests.
     For each request to this DLL,
      IIS formats an ECB and invokes this function.
      This funciton is responsible for executing or failing the request.
 
  Arguments:
   pECB - pointer to ECB - the extension control block containing the 
          most frequently used variables for IIS requests.

  Returns:
   DWORD containig the HSE_STATUS_* codes.
--*/
{
    DWORD dwRet = HSE_STATUS_SUCCESS;

    try {
        if (!SUCCEEDED(IsapiToISA(pECB, &dwRet))) {
            dwRet = HSE_STATUS_ERROR;               
        }
    }
    catch(...) {
        DBG_ASSERT(FALSE);
        
        DWORD cbMsg = LEN_PSZ_FAILURE_MSG;
        pECB->WriteClient( pECB->ConnID, 
                           (LPVOID )PSZ_FAILURE_MSG, 
                           &cbMsg, 0);
        dwRet = HSE_STATUS_ERROR;
    }
    
    return dwRet;
} // HttpExtensionProc()



HRESULT 
IsapiToISA(EXTENSION_CONTROL_BLOCK* pECB, DWORD* pdwStatus)
/*++
  IsapiToISA
  o  This function finds and ISA_INSTANCE and dispatches a HttpRequest
     to the ISA instance for execution. Once the execution completes,
     this function returns the status to the caller.

  Arguments:
    pECB - pointer to ISAPI Extension Control Block.
    pdwStatus - pointer to DWORD which will contain status on return.

  Returns:
    HRESULT
--*/
{ 
    HRESULT hr = E_FAIL;
    PISA_INSTANCE pisa;

    DBG_ASSERT( NULL != g_pisaPool);

    if ( g_pisaPool == NULL) {

        // we should not have been here.
        DBG_ASSERT( FALSE);
        *pdwStatus = HSE_STATUS_ERROR;
    } else {
        PISA_INSTANCE pisa = g_pisaPool->GetInstance();

        if ( NULL != pisa ) {
            hr = pisa->ProcessRequest( pECB, pdwStatus);
            DBG_REQUIRE( g_pisaPool->ReleaseInstance( pisa));
        } else {
            hr = E_NOINTERFACE;
        }
    }
        
    return hr;
} // IsapiToISA()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>



//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN)

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000
# define DEBUG_PARSING             0x00008000



//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n", 
    //                     GUID_EXPAND( pMyGuid)));

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\isat1\object\isatobj.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       isatobj.cpp

   Abstract:

       This module defines the functions for CInetServerAppObject

   Author:

       Murali R. Krishnan    ( MuraliK )     4-Nov-1996 

   Project:

       Internet Application Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "windows.h"
# include "stdafx.hxx"
# include "isat.h"
# include "isatobj.hxx"

#include <iisext.h>

# include "dofunc.hxx"

#include "sobj_i.c"


char sg_rgch200OK[] = "200 OK";
char sg_rgchTextHtml[] = "Content-Type: text/html\r\n\r\n";

char sg_rgchOutput[] =
   "<html>\r\n"
   "<h1>\nHello from CInetServerAppObject (%08x)\r\n</h1>"
   "<pre>%s</pre>"
   "</html>\r\n";


char sg_rgchSendHeaderFailed[] = 
   "<html><title> ISA Failed: Sending Header Failed\r\n"
   "</html>\r\n";

/************************************************************
 *    Functions 
 ************************************************************/
HRESULT
SendUsage( IN IIsaResponse * pResp, 
           IN IIsaRequest *  pReq
           );

HRESULT
DoAction( IN IIsaResponse * pResp, 
          IN IIsaRequest *  pReq,
          IN LPCSTR         pszAction
          );

HRESULT
GetPathInfo( IN IIsaResponse * pResp,IN IIsaRequest * pReq,  
             OUT CHAR * pszPathInfo, IN DWORD cbs);

          
/************************************************************
 *  Member functions of  CComIsapi
 ************************************************************/


CInetServerAppObject::CInetServerAppObject()
    : m_pRequest   ( NULL),
      m_pResponse  ( NULL)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "Creating CInetServerAppObject() ==>%08x\n",
                    this));
    }

    return;
} // CInetServerAppObject::CInetServerAppObject()



CInetServerAppObject::~CInetServerAppObject()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "Deleting CInetServerAppObject() ==>%08x\n",
                    this));
    }

    if ( NULL != m_pRequest) { 
        
        m_pRequest->Release();
        m_pRequest = NULL;
    }

    if ( NULL != m_pResponse) { 
        
        m_pResponse->Release();
        m_pResponse = NULL;
    }

} // CInetServerAppObject::CInetServerAppObject()


STDMETHODIMP
CInetServerAppObject::SetContext( 
    IN IUnknown * punkRequest,
    IN IUnknown * punkResponse
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != punkRequest) { 

        // Obtain the Request object itself
        hr = punkRequest->QueryInterface(IID_IIsaRequest, 
                                         (void**)&m_pRequest);
    }

    if ( SUCCEEDED( hr) && NULL != punkResponse) { 

        // Obtain the Request object itself
        hr = punkResponse->QueryInterface(IID_IIsaResponse, 
                                         (void**)&m_pResponse);
    }
        
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "CISAObject[%08x]::SetContext("
                    " punkRequest  = %08x,"
                    " punkResponse = %08x"
                    ") => m_pRequest = %08x,"
                    " m_pResponse = %08x,"
                    " hr=%08x\n"
                    ,
                    this, punkRequest, punkResponse,
                    m_pRequest, m_pResponse,
                    hr
                    ));
    }

    return (hr);

} // CInetServerAppObject::SetContext()



STDMETHODIMP
CInetServerAppObject::ProcessRequest( OUT unsigned long * pdwStatus)
{
    HRESULT hr;
    
    if ( (NULL == m_pRequest) ||
         (NULL == m_pResponse)
         ) {
        hr = E_POINTER;
    } else {
        char  rgchQuery[MAX_HTTP_HEADER_SIZE];
        unsigned long cbSize = sizeof( rgchQuery);
        
        // 1. Obtain the query string to determine what was requested
        // 2. Take action based on the query string
        
        rgchQuery[0] = '\0';
        hr = m_pRequest->GetServerVariable( "QUERY_STRING",
                                            cbSize,
                                            (unsigned char * )rgchQuery,
                                            &cbSize);

        if ( !SUCCEEDED( hr)) {
            
            hr = SendMessageToClient( m_pResponse, m_pRequest, 
                                      "GetServerVariable() failed",
                                      hr);
        } else {

            hr = DoAction( m_pResponse, m_pRequest, rgchQuery);
            
            if ( !SUCCEEDED( hr)) {
                hr = SendMessageToClient( m_pResponse, m_pRequest,
                                          "DoAction() failed",
                                          hr);
            }
        }
    }

    DBG_ASSERT( NULL != pdwStatus);

    *pdwStatus = (SUCCEEDED( hr) ? HSE_STATUS_SUCCESS: HSE_STATUS_ERROR);
    
    return hr;
} // CInetServerAppObjet::ProcessRequest()




HRESULT
SendMessageToClient( IN IIsaResponse * pResp, 
                     IN IIsaRequest *  pReq,
                     IN LPCSTR         pszMsg,
                     IN HRESULT        hrError
                     )
{
    HRESULT hr;
    
    // send the header
    hr = pResp->SendHeader( (unsigned char *) sg_rgch200OK,
                            (unsigned char *) sg_rgchTextHtml);

    if ( SUCCEEDED( hr)) {

        CHAR rgchResp[ MAX_REPLY_SIZE];
        CHAR rgchReply[ MAX_REPLY_SIZE];
        unsigned long cbSize;
        
        cbSize = wsprintfA( rgchResp,
                            " Req=%08x; %s. HR=%08x\n",
                            pReq, pszMsg, hrError);
        
        cbSize = wsprintfA( rgchReply, sg_rgchOutput, pResp, rgchResp);
        DBG_ASSERT( cbSize < MAX_REPLY_SIZE);
        hr = (pResp->WriteClient( cbSize, 
                                  (unsigned char *) rgchReply, 
                                  &cbSize)
              );
    }

    return ( hr);
} // SendMessageToClient()


HRESULT
DoAction( IN IIsaResponse * pResp, 
          IN IIsaRequest *  pReq,
          IN LPCSTR         pszAction
          )
{
    HRESULT hr = S_OK;

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF(( DBG_CONTEXT, "<-- DoAction( Resp:%08x, Req:%08x, %s)\n",
                    pResp, pReq, pszAction
                    ));
    }

    if ( !_strnicmp( pszAction, "GET_VAR", 7 )) {

        CHAR * pchVar;

        // if variable specified send the variable. Otherwise send ALL_HTTP
        pchVar = strchr( pszAction + 7, '&');
        pchVar = (pchVar != NULL) ? (pchVar + 1) : "ALL_HTTP";

        hr = do_get_var( pResp, pReq, pchVar);

    } // GET_VAR
    else
    if ( !_strnicmp( pszAction, "SERVER_VAR", 10 )) {

        // this will use the ServerVariables dictionary item from request obj

        CHAR  chVar[10];
        CHAR * pchVar;

        // if variable specified send the variable. Otherwise send ALL_HTTP
        pchVar = strchr( pszAction + 10, '&');
        if ( pchVar != NULL) { 
            pchVar = pchVar + 1;
        } else { 
            strcpy( chVar, "ALL_HTTP");
            pchVar = (LPSTR ) chVar;
        }

        hr = do_server_var( pResp, pReq, pchVar);

    } // SERVER_VAR
    else
    if ( !_strnicmp( pszAction, "QSTR", 4)) {

        // this will use the QueryString dictionary item from request obj

        CHAR  chVar[10];
        CHAR * pchVar;

        // if variable specified send the specific variable. 
        //  Otherwise send QSTR's value
        //
        //  Since we fetch the action from the Query String, it is hard 
        //  to test for all combinations of QueryString values.
        //  Even the first one is fine for now.

        pchVar = strchr( pszAction + 4, '&');
        if ( pchVar != NULL) { 
            pchVar = pchVar + 1;
        } else { 
            strcpy( chVar, "QSTR");
            pchVar = (LPSTR ) chVar;
        }

        hr = do_query_string( pResp, pReq, pchVar);

    } // SERVER_VAR
    else
    if ( !_strnicmp( pszAction, "CERT", 4)) {

        // this will test the certificate access from the application

        hr = do_certificate_access( pResp, pReq);

    } // SERVER_VAR
    else
    if ( !_strnicmp( pszAction, "POST", 4 )) {
        
        // this will use the ServerVariables dictionary item from request obj

        CHAR  chVar[10];
        CHAR * pchVar;

        // if variable specified send the variable. Otherwise send ALL_HTTP
        pchVar = strchr( pszAction + 4, '&');
        if ( pchVar != NULL) { 
            pchVar = pchVar + 1;
        } else { 
            strcpy( chVar, "pdata1");
            pchVar = (LPSTR ) chVar;
        }

        hr = do_post_form( pResp, pReq, pchVar);

    } // POST FORM
    else if ( !_strnicmp( pszAction, "REDIRECT", 8 )) {
            
        char  * pszURL;
        
        // the location follows the command. extract and use it for redirect
        pszURL = strchr( pszAction, '&');
        pszURL = (pszURL != NULL) ? (pszURL + 1) : "http://localhost/";
        hr = pResp->Redirect((unsigned char * ) 
                             (( *pszURL == '/') ? (pszURL+1) : pszURL)
                             );
    }
    else  if ( !_strnicmp( pszAction, "SEND_URL", 8 )) {

        char  pszURL[MAX_HTTP_HEADER_SIZE];
        
        hr = GetPathInfo( pResp, pReq, pszURL, MAX_HTTP_HEADER_SIZE);
        if ( SUCCEEDED( hr)) {
            hr = pResp->SendURL( (unsigned char * ) pszURL);
        }
        DBGPRINTF(( DBG_CONTEXT, 
                    "SendURL(%s) => %08x\n",
                    pszURL, 
                    hr));
    }
    else {
        hr = SendUsage( pResp, pReq);
    }

    return ( hr);
} // DoAction()


HRESULT
GetPathInfo( IN IIsaResponse * pResp,IN IIsaRequest * pReq,  
             OUT CHAR * pszPathInfo, IN DWORD cbs)
{
    HRESULT hr;
    unsigned long cbSize = cbs;
    
    // 1. Obtain the query string to determine what was requested
    // 2. Take action based on the query string
    
    pszPathInfo[0] = '\0';
    hr = pReq->GetServerVariable( "PATH_INFO",
                                  cbSize,
                                  (unsigned char * ) pszPathInfo,
                                  &cbSize);
    if ( !SUCCEEDED( hr)) {
        SendMessageToClient( pResp, pReq, 
                             "GetServerVariable( PATH_INFO) failed",
                             hr);
    }

    return ( hr);

} // GetPathInfo()





const char  g_pszUsage[] = 
"<head><title>ISA Test: Usage</title></head>\n"
"<body><h1>USAGE of INET Server APP Test object</h1>\n"
"<p>Usage:"
"<p>Query string contains one of the following:"
"<p>"
"<p> GET_VAR&var_to_get"
"<p> SERVER_VAR&var_to_get&name-value-pairs"
"<p> QSTR&Var=Value&Var2=Value2"
"<p> POST&pdata  - should have posted data"
"<p> REDIRECT&NewLocation"
"<p> SEND_URL  w/- PathInfo containing the URL to send"
"<p> HSE_REQ_SEND_RESPONSE_HEADER"
"<p> HSE_REQ_MAP_URL_TO_PATH"
"<p> SimulateFault"
"<p> Keep_Alive"
"<p> Open_Reg"
"<p> Open_File"
"<p>"
"<p> For example:"
"<p>"
"<p>   http://computer/scripts/isattest.dll?GET_VAR"
"<p>"
"<p> or SimulatePendingIO with one of the"
" above action strings"
"<p>"
"<p> such as:"
"<p>"
"<p> http://computer/scripts/isattest.dll/default.htm?SimulatePendingIO&SEND_URL"
"<p>"
"<p> The Path info generally contains the URL or"
" response to use"
"</body>\n"
;
                        
HRESULT
SendUsage( IN IIsaResponse * pResp, 
           IN IIsaRequest *  pReq
           )
{
    unsigned char * pszReply;
    unsigned long  cbReply;
    HRESULT hr;

    hr = pResp->SendHeader( (unsigned char *) sg_rgch200OK,
                            (unsigned char *) sg_rgchTextHtml
                            );

    if ( SUCCEEDED( hr)) {

        pszReply = (unsigned char * )g_pszUsage;
        cbReply = sizeof( g_pszUsage);
        hr = (pResp->WriteClient( cbReply, 
                                  pszReply,
                                  &cbReply)
              );
    }

    return  ( hr);
    
} // SendUsage()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = sobj
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I$(SDKINC)

CLIENT_STUB     =$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(IDL_FILE_NAME)_p.c
HEADER_FILE     =$(IDL_FILE_NAME).h
TLB_FILE        =$(IDL_FILE_NAME).tlb
DLL_DATA        =dlldata.c

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(TLB_FILE) $(DLL_DATA)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)


#
#  MIDL Compile stuff
# 
$(TARGETS):  .\$(IDL_FILE_NAME).idl
    midl -Oi -error allocation -error ref $(IDL_FLAGS) $(CPP) $(INCS) .\$(IDL_FILE_NAME).idl

#  /header $(HEADER_FILE) /tlb $(TLB_FILE) /dlldata $(DLL_DATA) /iid $(IID_STUB) /proxy $(PROXY_STUB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sobj.rc
//
#define IDS_ISAREQ_DESC  1
#define IDS_ISARESP_DESC 2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\navcol.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       navcol.cxx

   Abstract:
       This module defines the functions for handling the dictionary items.

   Author:

       Murali R. Krishnan    ( MuraliK )     4-Dec-1996 

   Environment:
       User Mode - Win32
       
   Project:

       Internet Application Server DLL

   Functions Exported:
       NAVCOL::<members>


   Revision History:

--*/

/************************************************************
 *     Include Headers
 ************************************************************/

# include "stdafx.h"

# if !(REG_DLL)

# include "navcol.hxx"


/************************************************************
 *    Functions 
 ************************************************************/


/************************************************************
 *   Member Functions of NAVCOL
 ************************************************************/

inline VOID 
UpdatePointer( IN OUT LPCSTR * ppsz, IN const CHAR * pchOld, 
               IN DWORD cchLen, IN const CHAR * pchNew)
{
    if ( (*ppsz >= pchOld) && 
         (*ppsz < (pchOld + cchLen))
         ){
      
        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT, 
                        " Updating pointer [%08x] from %08x to %08x\n",
                        ppsz, *ppsz,  ((*ppsz - pchOld) + pchNew)));
        }

        // update the pointer
        *ppsz = ((*ppsz - pchOld) + pchNew);
    }
}


NAVCOL::NAVCOL(VOID)
    : m_chNull       ('\0'),
      m_buffData     (),
      m_cchData      ( 0),
      m_cchBuffData  ( 0)
{
    InitializeListHead( &m_ActiveList);
    InitializeListHead( &m_FreeList);

    IF_DEBUG( INIT_CLEAN) { 

        DBGPRINTF(( DBG_CONTEXT, "NAVCOL() => %08x\n", this));
    }

    Reset();
    
} // NAVCOL::NAVCOL()


NAVCOL::~NAVCOL( VOID)
{
    // NOTHING SPECIAL TO BE DONE HERE 
    IF_DEBUG( INIT_CLEAN) { 

        DBGPRINTF(( DBG_CONTEXT, "deleted NAVCOL %08x\n", this));
    }
    
} // NAVCOL::~NAVCOL()


VOID
NAVCOL::Reset( VOID)
{
    m_cchData = 0;
    m_rcInlinedData[0] = '\0';

    m_cchBuffData = 0;
    m_buffData.Resize( HH_MIN);

    //
    // Move the Name-Value chunks from active list to the free-list.
    //
    while ( !IsListEmpty( &m_ActiveList)) {

        PLIST_ENTRY pl = m_ActiveList.Flink;
        RemoveEntryList( pl);
        InsertTailList( &m_FreeList, pl);
    } // while

    InitializeListHead( &m_ActiveList);

    return;
} // NAVCOL::Reset()


VOID
NAVCOL::CancelHeader( IN LPCSTR    pszName)
{
    DWORD cchName = strlen( pszName);
    CancelHeaderInChunks( pszName, cchName);

} // NAVCOL::CancelHeader()



BOOL
NAVCOL::StoreHeader(IN const CHAR * pszHeader, IN DWORD cchHeader,
                    IN const CHAR * pszValue,  IN DWORD cchValue
                    )
{
    return ( AddEntryToChunks( pszHeader, cchHeader, pszValue,  cchValue));
} // NAVCOL::StoreHeader()

BOOL
NAVCOL::StoreHeader(IN const CHAR * pszHeader, 
                    IN const CHAR * pszValue
                    )
{
    return ( StoreHeader( pszHeader, strlen( pszHeader),
                          pszValue,  strlen( pszValue)
                          )
             );
} // NAVCOL::StoreHeader()




VOID
NAVCOL::PrintToBuffer( IN CHAR * pchBuffer, IN OUT LPDWORD pcchMax) const
{
    DWORD cb;
    PLIST_ENTRY pl;

    DBG_ASSERT( pchBuffer != NULL);
    DBG_ASSERT( pcchMax != NULL);

    // 0. Print the summary of the object
    // 1. Print all the Fast Map headers
    // 2. Print the rest of the headers
    
    if( 100 < *pcchMax) {
        cb = wsprintfA( pchBuffer, 
                        "\nNAVCOL (%08x). cchData = %d (buff = %d/%d)\n"
                        ,
                        this, m_cchData, 
                        m_cchBuffData, m_buffData.QuerySize()
                        );
    } else {
        cb = 100;
    }
    
    DWORD cb1 = (cb < *pcchMax) ? *pcchMax - cb : 0;

    for ( pl =  m_ActiveList.Flink; pl != &m_ActiveList; pl = pl->Flink) {
        
        NAME_VALUE_CHUNK * pnvc = 
            CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        cb1 = (cb < *pcchMax) ? *pcchMax - cb : 0;
        cb += pnvc->PrintToBuffer ( pchBuffer + cb, &cb1);
    } // for

    pchBuffer[cb] = '\0';

    //
    // Print the Raw header from buffer ... NYI
    //
    
    if ( cb + 2 < *pcchMax ) { 
        lstrcat( pchBuffer + cb, "\n\n");
        cb += 2;
    } else {
        cb += 2;
    }

    *pcchMax = cb;

    return;
} // NAVCOL::PrintToBuffer()


BOOL 
NAVCOL::UpdatePointers( 
    IN const CHAR * pchOld, 
    IN DWORD cchLen,
    IN const CHAR * pchNew)
{
    
    DBGPRINTF(( DBG_CONTEXT, 
                "%08x::UpdatePointers( %08x, %d, %08x) a costly function\n",
                this, pchOld, cchLen, pchNew));

    DBG_ASSERT( pchOld != pchNew); // if this is true why call this function?

    if ( pchOld == pchNew) {
        return ( TRUE);
    }

    // 1. Update pointers in the name-value chunk list
    PLIST_ENTRY pl;
    for ( pl =  m_ActiveList.Flink; pl != &m_ActiveList; pl = pl->Flink) {
        
        NAME_VALUE_CHUNK * pnvc = 
            CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnvc->UpdatePointers( pchOld, cchLen, pchNew);
    } // for

    return ( TRUE);
} // NAVCOL::UpdatePointers()


BOOL 
NAVCOL::MakeRoomInBuffer( IN DWORD cchReqd)
{
    if ( cchReqd > m_buffData.QuerySize()) {

        // cache old pointer to update the other pointers properly
        LPSTR pszOld = (LPSTR ) m_buffData.QueryPtr();

        if ( !m_buffData.Resize( cchReqd, NAVCOL_GROW_BY)) {

            IF_DEBUG( ERROR) {
                DBGPRINTF(( DBG_CONTEXT, "%08x::Unable to allocate %d bytes\n",
                            this, cchReqd));
            }
            return ( FALSE);
        }
        
        DBG_ASSERT( cchReqd <= m_buffData.QuerySize());
        LPSTR pszNew = (LPSTR ) m_buffData.QueryPtr();
        if ( pszNew != pszOld) {

            // Trouble starts.
            // I have to update all the guys pointing inside the old blob
            // especially the pointers in 
            //   the range (pszOld  to pszOld + m_cchBuffHeaders)
            
            return ( UpdatePointers( pszOld, m_cchBuffData, pszNew));
        }
        
        // We are just lucky to be able to have reallocated at same place.
    }
    
    return ( TRUE);
} // NAVCOL::MakeRoomInBuffer()


VOID
NAVCOL::Print( VOID)  const
{
    CHAR  pchBuffer[ 20000];
    DWORD cchMax = sizeof( pchBuffer);

    PrintToBuffer( pchBuffer, &cchMax);
    
    DBGDUMP(( DBG_CONTEXT, pchBuffer));

} // NAVCOL::Print()


CHAR * 
NAVCOL::FindValue( IN LPCSTR pszName, OUT LPDWORD pcchValue)
{
    DWORD cchName = strlen( pszName);

    // 1. Search in the slow list - name-value-chunks
    NAME_VALUE_PAIR * pnp = FindValueInChunks( pszName, cchName);
        
    if ( pnp != NULL) {

        if ( pcchValue != NULL) {
            DBG_ASSERT( pnp->pchValue != NULL);
            *pcchValue = pnp->cchValue;
        }
        
        return ( (CHAR *) pnp->pchValue);
    } else {
        SetLastError( ERROR_INVALID_PARAMETER);
    }

    return ( NULL);
} // NAVCOL::FindValue()


NAME_VALUE_PAIR * 
NAVCOL::FindValueInChunks( IN LPCSTR  pszName, IN DWORD cchName)
{
    PLIST_ENTRY pl;
    NAME_VALUE_PAIR * pnp = NULL;
    
    // find a Name-value-pair/chunk that holds this entry. 
    for ( pl = m_ActiveList.Flink; 
          (pnp == NULL) && (pl != &m_ActiveList); 
          pl = pl->Flink) {
        
        NAME_VALUE_CHUNK * 
            pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindEntry( pszName, cchName);
    } // for

    return ( pnp);
} // NAVCOL::FindValueInChunks()


VOID
NAVCOL::CancelHeaderInChunks( IN LPCSTR pszName, IN DWORD cchName)
{
    PLIST_ENTRY pl;
    NAME_VALUE_PAIR * pnp = NULL;
    NAME_VALUE_CHUNK * pnc;

    // NYI:  This function can benefit from better implementation
    //  instead of moving memory around.
    // Since the freq. of use of this func is less, we will not optimize :(
    
    // find the Name-value-pair/chunk that holds this entry. 
    for ( pl = m_ActiveList.Flink; 
          (pnp == NULL) && (pl != &m_ActiveList); 
          pl = pl->Flink) {
        
            pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindEntry( pszName, cchName);
    } // for

    if ( pnp != NULL) {

        // pnp - current item
        // pnc - the current chunk

        // to cancel the item, just left-shift the array of 
        //  NAME_VALUE_PAIRS in the chunk and reset the m_nPairs value

        DBG_ASSERT( (pnp >= pnc->m_rgNVP) &&
                    (pnp < pnc->m_rgNVP + pnc->m_nPairs));

        DBG_ASSERT( (pnc->m_nPairs  - (pnp - pnc->m_rgNVP)) >= 1 );
        MoveMemory( pnp, (pnp + 1), 
                    ((pnc->m_nPairs - 1 - (pnp - pnc->m_rgNVP)) * 
                     sizeof( NAME_VALUE_PAIR))
                    );
        pnc->m_nPairs--;

        // NYI:  if pnc->m_nPairs == 0, 
        // we can move this away from the active list
    }

    return;
} // NAVCOL::CancelHeaderInChunks()



BOOL
NAVCOL::NextPair( IN OUT NAVCOL_ITERATOR *   pni, 
                  OUT NAME_VALUE_PAIR ** ppnp
                  )
{
    DBG_ASSERT( pni );
    DBG_ASSERT( ppnp );
    
    //
    // Find the pair in the chunk
    //

    return ( NextPairInChunks( pni, ppnp));
} // NAVCOL::NextPair()


BOOL
NAVCOL::NextPairInChunks( IN OUT NAVCOL_ITERATOR * pni, 
                          OUT NAME_VALUE_PAIR **   ppnp
                          )
{
    DBG_ASSERT( pni);
    DBG_ASSERT( ppnp);
    PLIST_ENTRY pl;

    do { 

        PLIST_ENTRY pl = (PLIST_ENTRY ) pni->dwChunk;
        if ( pl == &m_ActiveList) {
            break;
        }
        
        NAME_VALUE_CHUNK * pnc = 
            (NAME_VALUE_CHUNK *) CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, 
                                                    m_listEntry);
        if ( pni->dwPair < pnc->m_nPairs) {
            
            // extract the current pair, update pair pointer and return
            *ppnp = (NAME_VALUE_PAIR *) (pnc->m_rgNVP + pni->dwPair);
            pni->dwPair++;
            return ( TRUE);
        }

        // we could not find any in the current chunk. Move to next chunk.
        pni->dwChunk = (DWORD ) pnc->m_listEntry.Flink;
        pni->dwPair = 0;  // pair # within the chunk
    } while ( TRUE);

    SetLastError( ERROR_NO_MORE_ITEMS);
    return ( FALSE);
} // NAVCOL::NextPairInChunks()



BOOL
NAVCOL::AddEntryToChunks( 
    IN const CHAR * pszHeader, 
    IN DWORD        cchHeader,
    IN const CHAR * pszValue,  
    IN DWORD        cchValue
    )
/*++
  This function stores the <header, value> pair for headers not found
  in the fast-map. It checks to see if the header already exists
  with some value. If it does, then the new value is just concatenated
  to the old one. Else the new value is stored separately in the first
  available free chunk.

  If there is no free chunk available, this function also allocates a free
  chunk and stores the data in the new chunk.
--*/
{
    // Store the header that is not part of the Fast Map
    
    PLIST_ENTRY pl;
    NAME_VALUE_CHUNK * pnc;
    NAME_VALUE_PAIR  * pnp;
    NAME_VALUE_CHUNK * pncFirst = NULL;
    NAME_VALUE_PAIR  * pnpFirst = NULL;
    
    // find a Name-value-pair/chunk that can hold this entry. 
    for ( pl = m_ActiveList.Flink; 
          (pl != &m_ActiveList); 
          pl = pl->Flink) {

        BOOL fFound = FALSE;
        
        pnc = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);

        pnp = pnc->FindMatchingOrFreeEntry( pszHeader, cchHeader, &fFound);

        if ( fFound ) {
            
            DBG_ASSERT( pnp != NULL);
            
            // pnc points to the chunk containing the matched item
            // pnp points to the exact pair that matched up
            
            DBG_ASSERT( (pnp->cchName == cchHeader) &&
                        (!_strnicmp( pnp->pchName, pszHeader, cchHeader))
                        );
            
            IF_DEBUG( PARSING) {
                DBGPRINTF(( DBG_CONTEXT, "Match For (%s) found at PNP=%08x\n",
                            pszHeader, pnp));
            }
            
            // Concat the given value to the existing value element.
            // Nothing more needs to be done
            BOOL fRet = ConcatToHolder( &pnp->pchValue, pszValue, cchValue);

            if  ( fRet) { 
                
                // update the length of the datum.
                pnp->cchValue += (1 + cchValue);  // 1 for the ',' concat sign.
            }
            return ( fRet);
        } else if ( pncFirst == NULL) {
            
            // cache it for later use, if header is never found
            pncFirst = pnc; 
            pnpFirst = pnp;
        }
    } // for

    if ( pncFirst == NULL ) {
        
        // No match found. No free chunk is available.
        // Pull a new one from free list or create one
        if ( IsListEmpty( &m_FreeList)) {
            
            pncFirst = new NAME_VALUE_CHUNK();
            if ( NULL == pncFirst) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                return ( FALSE);
            }
        } else {
            // pull one from the free list and use it.
            pl = m_FreeList.Flink;
            RemoveEntryList( pl);
            pncFirst = CONTAINING_RECORD( pl, NAME_VALUE_CHUNK, m_listEntry);
            pncFirst->Reset();
        }
        
        InsertTailList( &m_ActiveList, &pncFirst->m_listEntry);
        DBG_ASSERT( pncFirst->m_nPairs == 0);
        pnpFirst =  ((NAME_VALUE_PAIR * ) pncFirst->m_rgNVP);
    }

    //
    // Store the new <header, value> pair in pnp and increment count of pairs.
    //

    DBG_ASSERT( NULL != pncFirst);
    DBG_ASSERT( NULL != pnpFirst);

    pnpFirst->pchName  = pszHeader;
    pnpFirst->cchName  = cchHeader;
    pnpFirst->pchValue = pszValue;
    pnpFirst->cchValue = cchValue;
    pncFirst->m_nPairs++;
    
    DBG_ASSERT( pnc->m_nPairs < MAX_HEADERS_PER_CHUNK);

    return ( TRUE);
} // NAVCOL::AddEntryToChunks()



BOOL
NAVCOL::ConcatToHolder( IN LPCSTR * ppsz, 
                        IN LPCSTR pszNew,
                        IN DWORD  cchNew
                        )
/*++
 
  Given an internal pointer ppsz of the HTTP_HEADERS object,
   this function appens the new value to the old value present
   using ',' as the concatenation character.
  
  It automatically allocates room and grows buffers, updates pointers, etc
   if need be.

--*/
{
    BOOL fRet = TRUE;
    LPCSTR pszOld = *ppsz;
    DBG_ASSERT( NULL != pszOld);
    DWORD  cchOld = strlen( pszOld);
    DWORD  cchReqd = cchOld + cchNew + 2;

    // Find if we have enough space in the inlined buffer
    if ( ( m_cchData + cchReqd < sizeof( m_rcInlinedData))
         ) {

        // Aha we are lucky. 
        // Make a copy at the end and form concatenated result
        *ppsz = m_rcInlinedData + m_cchData;
        m_cchData += cchReqd;
    } else {

        // Clearly we do not have room in the Inlined Header, 
        //  store the stuff in the aux buffer area.
        
        // Find if space is sufficient. 
        //  This will automatically alloc and update pointers
        if ( MakeRoomInBuffer( (m_cchBuffData + cchReqd))
             ){ 

            pszOld = *ppsz;  // get the new pointer (since it could have moved)
            LPSTR pszBuf = (LPSTR ) m_buffData.QueryPtr();
            
            // we have space at the end of the buffer here. Use this space.
            *ppsz = pszBuf + m_cchBuffData;
            m_cchBuffData += cchReqd;
        } else {
            
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create room for %d characters \n",
                        m_cchBuffData + cchOld + cchNew + 3));
            return ( FALSE);
        }
    }
    
    // Format the value as :=  <old> ',' <new>
    CopyMemory( (PVOID ) *ppsz, pszOld, cchOld);
    ((CHAR *) *ppsz)[cchOld] = ','; // concat character
    CopyMemory( (PVOID ) (*ppsz + cchOld + 1), pszNew, cchNew + 1);
    DBG_ASSERT( fRet == TRUE);

    return ( fRet);
} // NAVCOL::ConcatToHolder()


/**************************************************
 *  PARSER for the HTTP_HEADERS
 **************************************************/

extern int _HTTP_LINEAR_SPACE[];

BOOL 
NAVCOL::ParseInput( IN const CHAR * pchData, 
                    IN DWORD        cchData
                    )
{
    CHAR * pchScan;
    const CHAR * pchRequest;
    LPSTR        pszScan2;
    DWORD        cReq;

    IF_DEBUG( PARSING) {
        DBGPRINTF(( DBG_CONTEXT, "%08x::ParseInput( %08x:, %d) \n"
                    "Input Data:\n%s\n",
                    this, pchData, cchData, pchData));
    }

    //
    // 1. Skip all the leading spaces and ignore them all. 
    //   We do not need these fields
    //

    for ( pchScan = (CHAR * ) pchData; 
          ((pchScan < (CHAR * ) pchData + cchData) && isspace( (UCHAR)(*pchScan)));
          pchScan++) 
        ;

    cchData -= (pchScan - pchData);

    //
    // 2. Make a copy of the incoming data so that we can own the 
    //    input headers and munge it in our own fashion
    //  NYI: One can optimize this by selectively copying segments that
    //    are worth using (values), but that will be costly due to
    //    multiple small CopyMemory() operations.
    // 
    if ( cchData < sizeof( m_rcInlinedData)) {
        
        pchRequest = m_rcInlinedData;
        m_cchData = cchData;
    } else {
        
        if ( !m_buffData.Resize( cchData + 4, HH_GROW_BY)) {
            return ( FALSE);
        }
            
        pchRequest = (const CHAR * ) m_buffData.QueryPtr();
        m_cchBuffData = cchData;
    }
           
    // 2a. copy the data to the buffer
    CopyMemory( (PVOID ) pchRequest, pchScan, cchData);

    pchScan = (char * )pchRequest;

    //
    // 3. Extract all the name-value pairs which are of the form
    //    name=value and separated by an '&'
    //

    LPSTR pszHeader = pchScan;
    cReq = (PCHAR )pchRequest + cchData - pszHeader;
    LPSTR pchEnd = pszHeader + cReq;
    LPSTR pszEol, pszValue;

    for ( pszEol = pszHeader; 
          ( (pszEol < pchEnd) && 
            ( (pszEol = (LPSTR)memchr( pszHeader, '&', cReq )) ||
              (pszEol = pchEnd))
            );
          pszHeader = (pszEol + 1), cReq = (pchEnd - pszHeader)
          )
    {
        DWORD  cchValue = 0;
        int    cchName;

        // Find the value for given name 
        if ( pszValue = (LPSTR)memchr( pszHeader, '=', pszEol - pszHeader ) )
        {
            // reset the '=' sign and make pszValue point ahead, calc name len
            cchName = pszValue - pszHeader;
            *pszValue++ = '\0';

            // NYI: I need to URL unescape the Name/Value pairs 

            // Terminate the value string
            DBG_ASSERT( pszEol > pszValue);
            pszEol[0] = '\0';
            cchValue = pszEol - pszValue;
        } // if value present
        else
        {
            // No value is present. Null Value.
            pszValue = &m_chNull;
            DBG_ASSERT( cchValue == 0);

            // end the name part
            cchName = pszEol - pszHeader;
            *pszEol = '\0';
        }

        IF_DEBUG( PARSING ) {
            
            DBGPRINTF((DBG_CONTEXT,
                       "\t[%s] = %s\n", pszHeader, pszValue ));
        }
            
        // Store the name-value pair
        BOOL fRet = ( AddEntryToChunks( pszHeader, cchName,
                                        pszValue,  cchValue)
                      );
        
        if ( !fRet) {
            IF_DEBUG( ERROR) { 
                
                DBGPRINTF(( DBG_CONTEXT, 
                            "Failed to StoreHeader %s in chunks\n",
                            pszHeader));
            }
            return ( FALSE);
        }
    } // for()

    return ( TRUE);
} // NAVCOL::ParseInput()


#endif // !REG_DLL
/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\rdicto.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
   
       rdicto.cxx

   Abstract:
       This module defines the functions for CIsaServerVariables

   Author:

       Murali R. Krishnan    ( MuraliK )     22-Nov-1996 

   Environment:
    
       Win32 - User Mode

   Project:

       Internet Application Server DLL

   Functions Exported:

        Members of CIsaServerVariables
        Members of CIsaQueryString

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "stdafx.h"
#include "sobj.h"
#include "reqobj.hxx"
#include <iisext.h>

# include "dbgutil.h"



/************************************************************
 *    Variables/Values 
 ************************************************************/

// Specifies the amount of data that will be cached
# define CISA_FORM_DATA_DEFAULT_LEN (4024)  // 4 KB


/************************************************************
 *    Member Functions  of CIsaServerVariables
 ************************************************************/

CIsaServerVariables::CIsaServerVariables(
    CIsaRequestObject   * pcisaRequest,
    IUnknown *            punkOuter
    )
    : m_pcisaRequest ( pcisaRequest),
      m_punkOuter    ( punkOuter)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "Creating CIsaServerVariables( %08x, %08x) ==> %08x\n",
                    pcisaRequest, punkOuter,
                    this));
    }
    
} // CIsaServerVariables::CIsaServerVariables()


CIsaServerVariables::~CIsaServerVariables()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "deleting CIsaServerVariables() ==>%08x\n",
                    this));
    }

    // Do nothing

} // CIsaServerVariables::~CIsaServerVariables()


BOOL
CIsaServerVariables::Reset( VOID)
{
    // NYI: No private data. So there is no need to reset anything now.

    return (TRUE);
} // CIsaServerVariables::Reset()


// ------------------------------------------------------------
//  Member Functions for CIsaServerVariables::IUnknown
// ------------------------------------------------------------

STDMETHODIMP 
CIsaServerVariables::QueryInterface(REFIID iid, void ** ppvObj)
{
    *ppvObj = NULL;
    
    if ( (iid == IID_IUnknown) || 
         (iid == IID_IIsaRequestDictionary)
         // || (iid == IID_IDispatch)
         ) {
        *ppvObj = this;
    }

    
    if (*ppvObj != NULL) {

        // increment ref count before returning
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
    }

    return ( E_NOINTERFACE);
} // CIsaServerVariables::QueryInterface()


STDMETHODIMP_(ULONG) CIsaServerVariables::AddRef(void) 
{
    
    // delegate to the outer object
    return ( m_pcisaRequest->AddRef());
} // CIsaServerVariables::AddRef();


STDMETHODIMP_(ULONG) CIsaServerVariables::Release(void)
{
    // delegate to the outer object
    return (m_pcisaRequest->Release());
} // CIsaServerVariables::Release()


// ------------------------------------------------------------
//  Member Functions for CIsaServerVariables::IIsaRequestDictionary
// ------------------------------------------------------------


STDMETHODIMP
CIsaServerVariables::Item( 
    IN LPCSTR          pszName,
    IN unsigned long   cbSize,
    OUT unsigned char *pchBuf,
    OUT unsigned long *pcbReturn
    )
{
    HRESULT hr = S_OK;


    // 1. Validate the parameters
    if ( (NULL == pszName) || 
         (NULL == pchBuf)  ||
         (NULL == pcbReturn) ||
         (NULL == m_pcisaRequest) ||
         (!m_pcisaRequest->IsValid())
         ) {
        
        hr = ( E_INVALIDARG);
    } else {

        BOOL fReturn;

        DBG_ASSERT( m_pcisaRequest);
        DBG_ASSERT( m_pcisaRequest->IsValid());

#if !(REG_DLL)
        fReturn = ( m_pcisaRequest->HttpRequest()->
                      GetInfoForName( pszName, (char *) pchBuf, &cbSize));
        *pcbReturn = cbSize;
# else 
        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
# endif // REG_DLL

        if ( !fReturn ) {

            hr = HRESULT_FROM_WIN32( GetLastError());
        }
    }

    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::Item(%s, cb=%d, %08x, %08x[%d bytes])"
                    " => %08x. Val = %s\n",
                    this, pszName, cbSize, pchBuf, pcbReturn, *pcbReturn,
                    hr, ((pchBuf != NULL) ? pchBuf : ((unsigned char *)""))));
    }
    
    return ( hr);
} // CIsaServerVariables::Item()


STDMETHODIMP
CIsaServerVariables::_Enum( 
   OUT IUnknown ** ppunkEnumReturn
   )
{
    HRESULT hr = E_NOTIMPL;
    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::_Enum(%08x) => hr",
                    this, ppunkEnumReturn, hr
                    ));
        
    }

    return ( hr);

} // CIsaServerVariables::_Enum()



/************************************************************
 *    Member Functions  of CIsaQueryString
 ************************************************************/

CIsaQueryString::CIsaQueryString(
    CIsaRequestObject   * pcisaRequest,
    IUnknown *            punkOuter
    )
    : m_pcisaRequest ( pcisaRequest),
      m_punkOuter    ( punkOuter),
#if !defined(REG_DLL)
      m_navcol       (),
#endif 
      m_fLoaded      ( FALSE)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "Creating CIsaQueryString( %08x, %08x) ==> %08x\n",
                    pcisaRequest, punkOuter,
                    this));
    }
    
} // CIsaQueryString::CIsaQueryString()


CIsaQueryString::~CIsaQueryString()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "deleting CIsaQueryString() ==>%08x\n",
                    this));
    }

    // Do nothing

} // CIsaQueryString::~CIsaQueryString()


BOOL
CIsaQueryString::Reset( VOID)
{
    if ( m_fLoaded ) {
#if !defined( REG_DLL)
        m_navcol.Reset();
#endif 
        m_fLoaded = FALSE;
    }

    return (TRUE);
} // CIsaQueryString::Reset()



// ------------------------------------------------------------
//  Member Functions for CIsaQueryString::IUnknown
// ------------------------------------------------------------

STDMETHODIMP 
CIsaQueryString::QueryInterface(REFIID iid, void ** ppvObj)
{
    *ppvObj = NULL;
    
    if ( (iid == IID_IUnknown) || 
         (iid == IID_IIsaRequestDictionary)
         // || (iid == IID_IDispatch)
         ) {
        *ppvObj = this;
    }

    
    if (*ppvObj != NULL) {

        // increment ref count before returning
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
    }

    return ( E_NOINTERFACE);
} // CIsaQueryString::QueryInterface()


STDMETHODIMP_(ULONG) CIsaQueryString::AddRef(void) 
{
    
    // delegate to the outer object
    return ( m_pcisaRequest->AddRef());
} // CIsaQueryString::AddRef();


STDMETHODIMP_(ULONG) CIsaQueryString::Release(void)
{
    // delegate to the outer object
    return (m_pcisaRequest->Release());
} // CIsaQueryString::Release()


// ------------------------------------------------------------
//  Member Functions for CIsaQueryString::IIsaRequestDictionary
// ------------------------------------------------------------


STDMETHODIMP
CIsaQueryString::Item( 
    IN LPCSTR          pszName,
    IN unsigned long   cbSize,
    OUT unsigned char *pchBuf,
    OUT unsigned long *pcbReturn
    )
{
    HRESULT hr = S_OK;


    // 1. Validate the parameters
    if ( (NULL == pszName) || 
         (NULL == pchBuf)  ||
         (NULL == pcbReturn) ||
         (NULL == m_pcisaRequest) ||
         (!m_pcisaRequest->IsValid())
         ) {
        
        hr = ( E_INVALIDARG);
    } else {

        BOOL fReturn;

        DBG_ASSERT( m_pcisaRequest);
        DBG_ASSERT( m_pcisaRequest->IsValid());

#if !(REG_DLL)
        if ( !m_fLoaded ) {
            fReturn = LoadVariables();
        }

        if ( m_fLoaded) {
            
            CHAR * pchValue;
            DWORD  cchValue;
            
            pchValue = m_navcol.FindValue( pszName, &cchValue);
            
            if ( pchValue != NULL) {
                
                // value is found
                if ( cbSize > cchValue ) {
                    CopyMemory( pchBuf, pchValue, cchValue + 1);
                }
                
                *pcbReturn = (cchValue + 1);
            }
        }
# else 
        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
# endif // REG_DLL

        if ( !fReturn ) {

            hr = HRESULT_FROM_WIN32( GetLastError());
        }
    }

    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::Item(%s, cb=%d, %08x, %08x[%d bytes])"
                    " => %08x. Val = %s\n",
                    this, pszName, cbSize, pchBuf, pcbReturn, *pcbReturn,
                    hr, ((pchBuf != NULL) ? pchBuf : ((unsigned char *)""))));
    }
    
    return ( hr);
} // CIsaQueryString::Item()


STDMETHODIMP
CIsaQueryString::_Enum( 
   OUT IUnknown ** ppunkEnumReturn
   )
{
    HRESULT hr = E_NOTIMPL;
    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::_Enum(%08x) => hr",
                    this, ppunkEnumReturn, hr
                    ));
        
    }

    return ( hr);

} // CIsaQueryString::_Enum()


// ------------------------------------------------------------
//  Private Member Functions for CIsaQueryString
// ------------------------------------------------------------

BOOL 
CIsaQueryString::LoadVariables( VOID)
{
    BOOL fReturn = FALSE;

    // Loads the variables from the request object and parses it

    DBG_ASSERT( !m_fLoaded);

#if !defined( REG_DLL)     
    // NYI: Modify HTTP_REQUEST to expose the strURLParams
    LPCSTR pszQs = m_pcisaRequest->HttpRequest()->QueryURLParams();
    DWORD  cchQs = strlen( pszQs);

    // parse the query string and obtain the name-value collection
    fReturn = m_navcol.ParseInput( pszQs, cchQs);
    if ( fReturn ) { m_fLoaded = TRUE; }

# else 
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED);
# endif 

    return ( fReturn);
} // CIsaQueryString::LoadVariables()



/************************************************************
 *    Member Functions  of CIsaForm
 ************************************************************/

CIsaForm::CIsaForm(
    CIsaRequestObject   * pcisaRequest,
    IUnknown *            punkOuter
    )
    : m_pcisaRequest ( pcisaRequest),
      m_punkOuter    ( punkOuter),
#if !defined(REG_DLL)
      m_cbTotal      ( 0),
      m_navcol       (),
      m_buffData     (),
#endif 
      m_fLoaded      ( FALSE)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "Creating CIsaForm( %08x, %08x) ==> %08x\n",
                    pcisaRequest, punkOuter,
                    this));
    }
    
} // CIsaForm::CIsaForm()


CIsaForm::~CIsaForm()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "deleting CIsaForm() ==>%08x\n",
                    this));
    }

    // Do nothing

} // CIsaForm::~CIsaForm()


BOOL
CIsaForm::Reset( VOID)
{
    if ( m_fLoaded ) {
#if !defined( REG_DLL)
        m_navcol.Reset();

        if ( m_cbTotal > CISA_FORM_DATA_DEFAULT_LEN ) {
            DBG_REQUIRE( m_buffData.Resize( CISA_FORM_DATA_DEFAULT_LEN));
        }

        m_cbTotal = 0;
#endif 
        m_fLoaded = FALSE;
    }

    return (TRUE);
} // CIsaForm::Reset()



// ------------------------------------------------------------
//  Member Functions for CIsaForm::IUnknown
// ------------------------------------------------------------

STDMETHODIMP 
CIsaForm::QueryInterface(REFIID iid, void ** ppvObj)
{
    *ppvObj = NULL;
    
    if ( (iid == IID_IUnknown) || 
         (iid == IID_IIsaRequestDictionary)
         // || (iid == IID_IDispatch)
         ) {
        *ppvObj = this;
    }

    
    if (*ppvObj != NULL) {

        // increment ref count before returning
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
    }

    return ( E_NOINTERFACE);
} // CIsaForm::QueryInterface()


STDMETHODIMP_(ULONG) CIsaForm::AddRef(void) 
{
    
    // delegate to the outer object
    return ( m_pcisaRequest->AddRef());
} // CIsaForm::AddRef();


STDMETHODIMP_(ULONG) CIsaForm::Release(void)
{
    // delegate to the outer object
    return (m_pcisaRequest->Release());
} // CIsaForm::Release()


// ------------------------------------------------------------
//  Member Functions for CIsaForm::IIsaRequestDictionary
// ------------------------------------------------------------


STDMETHODIMP
CIsaForm::Item( 
    IN LPCSTR          pszName,
    IN unsigned long   cbSize,
    OUT unsigned char *pchBuf,
    OUT unsigned long *pcbReturn
    )
{
    HRESULT hr = S_OK;


    // 1. Validate the parameters
    if ( (NULL == pszName) || 
         (NULL == pchBuf)  ||
         (NULL == pcbReturn) ||
         (NULL == m_pcisaRequest) ||
         (!m_pcisaRequest->IsValid())
         ) {
        
        hr = ( E_INVALIDARG);
    } else {

        BOOL fReturn;

        DBG_ASSERT( m_pcisaRequest);
        DBG_ASSERT( m_pcisaRequest->IsValid());

#if !(REG_DLL)
        if ( !m_fLoaded ) {
            fReturn = LoadVariables();
        }

        if ( m_fLoaded) {
            
            CHAR * pchValue;
            DWORD  cchValue;
            
            pchValue = m_navcol.FindValue( pszName, &cchValue);
            
            if ( pchValue != NULL) {
                
                // value is found
                if ( cbSize > cchValue ) {
                    CopyMemory( pchBuf, pchValue, cchValue + 1);
                }
                
                *pcbReturn = (cchValue + 1);
            }
        }
# else 
        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
# endif // REG_DLL

        if ( !fReturn ) {

            hr = HRESULT_FROM_WIN32( GetLastError());
        }
    }

    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::Item(%s, cb=%d, %08x, %08x[%d bytes])"
                    " => %08x. Val = %s\n",
                    this, pszName, cbSize, pchBuf, pcbReturn, *pcbReturn,
                    hr, ((pchBuf != NULL) ? pchBuf : ((unsigned char *)""))));
    }
    
    return ( hr);
} // CIsaForm::Item()


STDMETHODIMP
CIsaForm::_Enum( 
   OUT IUnknown ** ppunkEnumReturn
   )
{
    HRESULT hr = E_NOTIMPL;
    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::_Enum(%08x) => hr",
                    this, ppunkEnumReturn, hr
                    ));
        
    }

    return ( hr);

} // CIsaForm::_Enum()


// ------------------------------------------------------------
//  Private Member Functions for CIsaForm
// ------------------------------------------------------------

BOOL 
CIsaForm::LoadVariables( VOID)
{
    BOOL fReturn = FALSE;

    // Loads the variables from the request object and parses it

    DBG_ASSERT( !m_fLoaded);

#if !defined( REG_DLL)     
    HTTP_REQUEST * phReq = m_pcisaRequest->HttpRequest();
    DBG_ASSERT( phReq != NULL);

    DWORD cbTotal = phReq->QueryClientContentLength();

    if ( cbTotal <= 0 ) {
        SetLastError( ERROR_NO_MORE_ITEMS);
        return ( FALSE);
    }
        
    DWORD cbAvailable = phReq->QueryEntityBodyCB();
    BYTE * pbData = (BYTE * ) phReq->QueryEntityBody();
    
    fReturn = m_buffData.Resize( cbTotal + 1);
    if ( !fReturn ) { 

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return ( FALSE);
    }
    
    if ( cbTotal <= cbAvailable ) {

        // all data is available. Just copy the data in now.
        CopyMemory( m_buffData.QueryPtr(), pbData, cbTotal);

    } else {
        PBYTE pb = (PBYTE ) m_buffData.QueryPtr();

        // 1. Copy the first chunk of data
        CopyMemory( pb, pbData, cbAvailable);

        // 2. Read the byte chunks incrementally till all is read
        DWORD cbToRead = cbTotal - cbAvailable;

        while ( cbToRead > 0 ) {

            DWORD cbRead = 0;

            if ( !phReq->ReadFile( pb, cbToRead, 
                                   &cbRead, 
                                   IO_FLAG_SYNC)
                 ) {

                return ( E_FAIL);
            }
            
            pb += cbRead; 
            cbToRead -= cbRead;
        } // while 
                
        pb[cbTotal] = '\0';  // terminate the buffer.
    }
   
    m_cbTotal = cbTotal;

    // NYI: Now the parser in <name value> collection will make
    //  yet another copy of the entire form. Can we avoid this?

    // parse the data and obtain the name-value collection
    fReturn = m_navcol.ParseInput( (const CHAR * ) m_buffData.QueryPtr(), 
                                   cbTotal);
    if ( fReturn ) { m_fLoaded = TRUE; }

# else 
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED);
# endif 

    return ( fReturn);
} // CIsaForm::LoadVariables()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


extern "C" {

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>

};

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR | DEBUG_IID)

# include "dbgutil.h"

#if !defined( REG_DLL)

# include <w3p.hxx>
# endif // !defined(REG_DLL)


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\sobj.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       sobj.cpp

   Abstract:
      This module defines the DLL main and additional book-keeping
      functions for ATL based COM Interface

   Author:

       Murali R. Krishnan  4-Nov-1996

   Environment:

   Project:
       Internet Application Server
--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "stdafx.h"

#include "resource.h"
#include "initguid.h"

#include "sobj.h"
#include "reqobj.hxx"
#include "respobj.hxx"
#include "dlldatax.h"

#define IID_DEFINED
#include "sobj_i.c"
# include "dbgutil.h"

/************************************************************
 *    Global Variables
 ************************************************************/

// Define the variables for ATL

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_IsaRequest, 
                     CIsaRequestObject, 
                     "CIsaRequest.RequestObject.1", 
                     "CIsaRequest.RequestObject.1", 
                     IDS_ISAREQ_DESC, 
                     THREADFLAGS_BOTH)
	OBJECT_ENTRY(CLSID_IsaResponse, 
                     CIsaResponseObject, 
                     "CIsaResponse.ResponseObject.1", 
                     "CIsaResponse.ResponseObject.1", 
                     IDS_ISARESP_DESC, 
                     THREADFLAGS_BOTH)
END_OBJECT_MAP()

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisCisaObjGuid, 
0x784d8931, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

/************************************************************
 *    Functions 
 ************************************************************/

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( "sobj");
#else
        CREATE_DEBUG_PRINT_OBJECT( "sobj", IisCisaObjGuid);
#endif
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            
            return ( FALSE);
        }
     
#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_IID);
#endif

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
        DELETE_DEBUG_PRINT_OBJECT();
    }
        
    return TRUE;    // ok

} // DllMain()



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow()


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    IF_DEBUG( IID) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "GetClassObject( " GUID_FORMAT ", " GUID_FORMAT ", %08x)\n",
                    GUID_EXPAND( &rclsid),
                    GUID_EXPAND( &riid),
                    ppv));
    }

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    hr = _Module.GetClassObject(rclsid, riid, ppv);

    IF_DEBUG( IID) {

        DBGPRINTF(( DBG_CONTEXT, "GetClassObject() returns %08x. (*ppv=%08x)\n",
                    hr, *ppv));
    }

    return ( hr);
} // DllGetClassObject()


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = S_OK;
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.UpdateRegistry(TRUE);
    return hRes;

} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = S_OK;
    _Module.RemoveRegistry();
#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllUnregisterServer();
#endif
    return hRes;
} // DllUnregisterServer()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\tisat1\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_INIT                (DEBUG_INIT_CLEAN)
# define DEBUG_CLEANUP             (DEBUG_INIT_CLEAN) 

# define DEBUG_OBJECT              0x00001000
# define DEBUG_IID                 0x00002000
# define DEBUG_MISC                0x00004000

//
// Following macros are useful for formatting and printing out GUIDs
//

# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])

    // Usage:  DBGPRINTF(( DBG_CONTEXT, " My Guid: " GUID_FORMAT " \n", 
    //                     GUID_EXPAND( pMyGuid)));

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\respobj.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
   
       respobj.cpp

   Abstract:
       This module defines the functions for CIsaResponseObject

   Author:

       Murali R. Krishnan    ( MuraliK )     4-Nov-1996 

   Environment:
    
       Win32 - User Mode

   Project:

       Internet Application Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "stdafx.h"
#include "sobj.h"
#include "respobj.hxx"
#include <iisext.h>

# include "dbgutil.h"

# define DEFAULT_URL_SIZE  (256)

/*----------------------------------------
  IMPLEMENTATION Details:
  
  4-Nov-1996:
    CIsaResponseObject does not maintain any buffered
    contents. All operations are write through. Need to revisit
    and fix this in the future.

  ----------------------------------------*/

/************************************************************
 *    Functions 
 ************************************************************/


CIsaResponseObject::CIsaResponseObject()
    : m_pHttpRequest ( NULL),
      m_fValid       ( FALSE)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "Creating CIsaResponseObject() ==> %08x\n",
                    this));
    }
    
} // CIsaResponseObject::CIsaResponseObject()


CIsaResponseObject::~CIsaResponseObject()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "deleting CIsaResponseObject() ==>%08x\n",
                    this));
    }

} // CIsaResponseObject::~CIsaResponseObject()


VOID
CIsaResponseObject::Reset(VOID)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "[%08x]CIsaResponseObject::Reset()\n",
                    this));
    }

    m_fValid = FALSE;

    return;
} // CIsaResponseObject::Reset()


STDMETHODIMP
CIsaResponseObject::SetHttpRequest(IN unsigned long dwpvHttpReq)
{
    HRESULT hr = S_OK;
    HTTP_REQUEST * pReq = (HTTP_REQUEST * ) dwpvHttpReq;

    DBG_ASSERT( pReq != NULL);
    
    if ( pReq == NULL) {
        hr = ( E_POINTER);
    } else {
        m_pHttpRequest = pReq;
        m_fValid = TRUE;
    } 

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::SetHttpRequest(%08x) returns %08x\n",
                    this, pReq, hr));
    }

    return ( hr);
} // CIsaResponseObject::SetHttpRequest()



STDMETHODIMP
CIsaResponseObject::SendHeader(
    IN unsigned char * pszStatus, 
    IN unsigned char * pszHeader 
    )
{
    HRESULT   hr = S_OK;

    if ( (!m_fValid)
         ){ 
        
        hr = E_INVALIDARG;
    } else {
        
        BOOL      fKeepConn;
        BOOL      fSt;
        
        //
        //  Build the typical server response headers for the extension DLL
        //
        
        //
        //  Temporarily turn off the KeepConn flag so the keep connection
        //  header won't be sent out.  If the client wants the connection
        //  kept alive, they should supply the header themselves (ugly)
        //  NYI:  We got to find a better way for this option :(
        //
        
#if !(REG_DLL)
        fKeepConn = m_pHttpRequest->IsKeepConnSet();
        m_pHttpRequest->SetKeepConn( FALSE );
        
        if ( (NULL != pszStatus) && 
             !strncmp( (LPCSTR )pszStatus, "401 ", sizeof("401 ")-1 ) )
        {
            m_pHttpRequest->SetDeniedFlags( SF_DENIED_APPLICATION );
            m_pHttpRequest->SetAuthenticationRequested( TRUE );
        }

        if ( NULL != pszHeader )
        {
            m_pHttpRequest->
                CheckForBasicAuthenticationHeader( (LPSTR ) pszHeader );
        }

        BOOL fReturn, fFinished;
        
        // NYI: UGLY: Why should we cast it to CHAR *. Fix the function.
        fReturn = m_pHttpRequest->SendHeader( (CHAR *) pszStatus,
                                              ((CHAR *) pszHeader) ?
                                              ((CHAR *) pszHeader) : "\r\n",
                                              IO_FLAG_SYNC,
                                              &fFinished );

        //  - not fully implemented
        DBG_ASSERT( !fFinished );

        if ( !fReturn) {
            hr = HRESULT_FROM_WIN32( GetLastError());
        }

        m_pHttpRequest->SetKeepConn( fKeepConn );
#else
        hr = E_FAIL;
#endif 
    }

    IF_DEBUG( API_EXIT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "%08x::SendHeader(%s, %s) => %08x\n",
                    this, pszStatus, pszHeader, 
                    hr));
    }

    return ( hr);
} // CIsaResponseObject::SendHeader()



STDMETHODIMP
CIsaResponseObject::Redirect(
    IN unsigned char * pszURL
    )
{
    HRESULT   hr = S_OK;

    if ( (!m_fValid)
         ){ 
        
        hr = E_INVALIDARG;
    } else {

#if !(REG_DLL)
        CHAR    tempURL[ DEFAULT_URL_SIZE];
        STR     strURL( tempURL, DEFAULT_URL_SIZE);
        DWORD   cb;

        if ( !strURL.Copy( (CHAR *) pszURL )        ||
             !m_pHttpRequest->
              BuildURLMovedResponse( m_pHttpRequest->QueryRespBuf(),
                                     &strURL )
             ) {
            hr = HRESULT_FROM_WIN32( GetLastError());
        } else {

            //
            //  Send The new header using synchronous IO
            //
            
            if ( !m_pHttpRequest->
                 WriteFile( m_pHttpRequest->QueryRespBufPtr(),
                            m_pHttpRequest->QueryRespBufCB(),
                            &cb,
                            IO_FLAG_SYNC )
                 ){
                
                hr = HRESULT_FROM_WIN32( GetLastError());
            }
        }
# else
            hr = E_FAIL;
# endif 
    }

    IF_DEBUG( API_EXIT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "%08x::Redirect(%s) => %08x\n",
                    this, pszURL, 
                    hr));
    }

    return ( hr);

} // CIsaResponseObject::Redirect()



STDMETHODIMP
CIsaResponseObject::SendURL(
    IN unsigned char * pszURL
    )
{
    HRESULT   hr = S_OK;

    if ( (!m_fValid)
         ){ 
        
        hr = E_INVALIDARG;
    } else {

        // NYI: We should migrate the send URL logic 
        //   and avoid accessing SE_INFO object .... 
#if !(REG_DLL)
        SE_INFO * psei = (SE_INFO *) m_pHttpRequest->QueryISAPIConnID();

        // Set this so that the Test ISAPI dll does not blow this connection
        //  prematurely before the Async IO completes
        psei->_dwFlags |= SE_PRIV_FLAG_SENDING_URL;
        
        if ( !m_pHttpRequest->ReprocessURL( (CHAR * ) pszURL,
                                            HTV_GET )
             ) {
            hr = HRESULT_FROM_WIN32( GetLastError());

            // we failed to process the URL. Shut off the priv sending flag.
            psei->_dwFlags &= ~SE_PRIV_FLAG_SENDING_URL;
        }
# else
        hr = E_FAIL;
# endif
    }

    IF_DEBUG( API_EXIT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "%08x::SendURL(%s) => %08x\n",
                    this, pszURL, 
                    hr));
    }

    return ( hr);

} // CIsaResponseObject::SendURL()




STDMETHODIMP 
CIsaResponseObject::WriteClient(
   IN unsigned long    cbSize,
   IN unsigned char*   pchBuf,
   OUT unsigned long * pcbReturn
   )
/*++
  This function forwards all the calls to do the proper work for 
   writing out the buffer to the client which made the HttpRequest 

  Arguments:
    cbSize  - count of bytes to send to the client
    pchBuf    - pointer to Buffer containing data
    pcbReturn - pointer to buffer containing the # of bytes successfully written
    
  Returns:
    HRESULT - indicating success/failure.

   NOTE:
    Only Synchronous IO is supported for now.
    No BUFFERING is supported.
--*/
{
    HRESULT hr = S_OK;

    if ( (NULL == pchBuf) ||
         (!m_fValid)
         ){ 
        
        hr = E_INVALIDARG;
    } else {
        
        DBG_ASSERT( NULL != m_pHttpRequest);

#if !defined( REG_DLL) 

        DBG_ASSERT( m_pHttpRequest->QueryClientConn()->CheckSignature() );
        
        if ( 0 != cbSize) {

            // NYI: Avoid casts if possible. Modify the base functions
            if ( !m_pHttpRequest->WriteFile( (LPVOID ) pchBuf,     
                                             (DWORD ) cbSize,
                                             (DWORD * ) pcbReturn,  
                                             IO_FLAG_SYNC
                                             )
                 ) {

                hr = HRESULT_FROM_WIN32( GetLastError());
            }
            
         } else {
             DBG_ASSERT( SUCCEEDED( hr));
         }
# else
        hr = E_FAIL;
#endif // !defined( REG_DLL)

    }
         
    IF_DEBUG( API_EXIT) {
        
        DBGPRINTF(( DBG_CONTEXT, 
                    "%08x::WriteClient(%08x, cb=%d, %08x [%d]) => %08x\n",
                    this, pchBuf, cbSize, 
                    pcbReturn, (NULL != pcbReturn) ? *pcbReturn : 0,
                    hr));
    }
    
    return (hr);
} // CIsaResponseObject::WriteClient()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\sobj\reqobj.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
   
       reqobj.cpp

   Abstract:
       This module defines the functions for CIsaRequestObject

   Author:

       Murali R. Krishnan    ( MuraliK )     4-Nov-1996 

   Environment:
    
       Win32 - User Mode

   Project:

       Internet Application Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "stdafx.h"
#include "sobj.h"
#include "reqobj.hxx"
#include <iisext.h>

# include "dbgutil.h"

/************************************************************
 *    Functions 
 ************************************************************/


CIsaRequestObject::CIsaRequestObject()
#pragma warning(4 : 4355)
    : m_pHttpRequest ( NULL),
      m_fValid       ( FALSE),
      m_Form         ( this, NULL),
      m_ServerVariables( this, NULL),
      m_QueryString( this, NULL)
#pragma warning(default : 4355)
{

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "Creating CIsaRequestObject() ==> %08x\n",
                    this));
    }
    
} // CIsaRequestObject::CIsaRequestObject()


CIsaRequestObject::~CIsaRequestObject()
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "deleting CIsaRequestObject() ==>%08x\n",
                    this));
    }

} // CIsaRequestObject::~CIsaRequestObject()

VOID
CIsaRequestObject::Reset(VOID)
{
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "[%08x]CIsaRequestObject::Reset()\n",
                    this));
    }

    m_fValid = FALSE;
    DBG_REQUIRE( m_ServerVariables.Reset());
    DBG_REQUIRE( m_QueryString.Reset());
    DBG_REQUIRE( m_Form.Reset());

    return;
} // CIsaRequestObject::Reset()



STDMETHODIMP
CIsaRequestObject::SetHttpRequest(IN unsigned long dwpvHttpReq)
{
    HRESULT hr = S_OK;
    HTTP_REQUEST * pReq = (HTTP_REQUEST * ) dwpvHttpReq;

    DBG_ASSERT( pReq != NULL);

    // Reset other members while doing this operation
    Reset();
    
    if ( pReq == NULL) {
        hr = ( E_POINTER);
    } else {
        m_pHttpRequest = pReq;
        m_fValid = TRUE;
    } 


    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT, "%08x::SetHttpRequest(%08x) returns %08x\n",
                    this, pReq, hr));
    }

    return ( hr);
} // CIsaRequestObject::SetHttpRequest()




STDMETHODIMP
CIsaRequestObject::GetServerVariable( 
    IN LPCSTR          pszName,
    IN unsigned long   cbSize,
    OUT unsigned char* pchBuf,
    OUT unsigned long *pcbReturn
    )
{
    HRESULT hr = m_ServerVariables.Item( pszName, cbSize, pchBuf, pcbReturn);
    
    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::GetServerVariable(%s, cb=%d, %08x, %08x[%d bytes])"
                    " => %08x. Val = %s\n",
                    this, pszName, cbSize, pchBuf, pcbReturn, *pcbReturn,
                    hr, ((pchBuf != NULL) ? pchBuf : ((unsigned char *)""))));
    }
    
    return ( hr);
} // CIsaRequestObject::GetServerVariable()


STDMETHODIMP
CIsaRequestObject::ClientCertificate(
    IN DWORD    cbCertBuffer,
    OUT unsigned char * pbCertBuffer,
    OUT LPDWORD pcbRequiredCertBuffer,
    OUT DWORD * pdwFlags
    )
{
    HRESULT hr = S_OK;

    if ( !IsValid() ||
         ( NULL == pbCertBuffer) ||
         ( NULL == pcbRequiredCertBuffer)
         ) {
        
        hr = ( E_INVALIDARG);
    } else {

#if !(REG_DLL)
        //
        //  Retrieves the SSL context, only used if
        //  using an SSPI package to provide SSL support
        //
        CtxtHandle * pCHRequest;

        //
        //  Retrieves the SSL context, only used if
        //  using an SSPI package to provide SSL support
        //
        DBG_ASSERT( m_pHttpRequest);
        DBG_ASSERT( m_pHttpRequest->QueryAuthenticationObj());
        pCHRequest = ( m_pHttpRequest->QueryAuthenticationObj()->
                       QuerySslCtxtHandle()
                       );
        
        if ( pCHRequest != NULL) {

            SECURITY_STATUS                     ss;
            SecPkgContext_RemoteCredenitalInfo  spcRCI;
            
            // get the security package context with credentials
            // NYI: Use function pointer in this case. 
            // Currently security.dll is not supported in Win95.
            ss = QueryContextAttributes( pCHRequest,
                                         SECPKG_ATTR_REMOTE_CRED,
                                         &spcRCI );
    
            if ( ss != NO_ERROR) {
                
                hr = HRESULT_FROM_WIN32( ((DWORD ) ss));
            } else if ( !spcRCI.cCertificates ) {
                
                hr = OLE_E_ENUM_NOMORE;
            } else {
                
                if ( cbCertBuffer >= spcRCI.cbCertificateChain ) {
                    
                    // copy the data from the certificate chain buffer
                    CopyMemory( pbCertBuffer, 
                                (PVOID ) spcRCI.pbCertificateChain,
                                spcRCI.cbCertificateChain
                                );
                } else {
                    
                    hr = TYPE_E_BUFFERTOOSMALL;
                }
                
                // fill in the size of data required
                if ( pcbRequiredCertBuffer ) {
                    *pcbRequiredCertBuffer = spcRCI.cbCertificateChain;
                }
                
                if ( pdwFlags != NULL) {
                    
                    *pdwFlags = spcRCI.fFlags;
                }
            }
        } else {
            
            hr = OLE_E_ENUM_NOMORE;
        }
# else 
        hr = E_INVALIDARG;
# endif // REG_DLL
    }

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::ClientCertificate(%d, %08x, %08x[%d], %08x[%08x])"
                    " => %08x\n",
                    this, cbCertBuffer, pbCertBuffer, 
                    pcbRequiredCertBuffer, 
                    ((pcbRequiredCertBuffer) ? *pcbRequiredCertBuffer : 0),
                    pdwFlags, 
                    ((pdwFlags) ? *pdwFlags : 0),
                    hr));
    }

    return ( hr);
} // CIsaRequestObject::ClientCertificate()


STDMETHODIMP
CIsaRequestObject::ServerCertificate(
    IN DWORD    cbCertBuffer,
    OUT unsigned char * pbCertBuffer,
    OUT LPDWORD pcbRequiredCertBuffer,
    OUT DWORD * pdwFlags
    )
{
    HRESULT hr = S_OK;

    if ( !IsValid() ||
         ( NULL == pbCertBuffer) ||
         ( NULL == pcbRequiredCertBuffer)
         ) {
        
        hr = ( E_INVALIDARG);
    } else {

#if !(REG_DLL)
        CtxtHandle * pCHRequest;

        //
        //  Retrieves the SSL context, only used if
        //  using an SSPI package to provide SSL support
        //
        DBG_ASSERT( m_pHttpRequest);
        DBG_ASSERT( m_pHttpRequest->QueryAuthenticationObj());
        pCHRequest = ( m_pHttpRequest->QueryAuthenticationObj()->
                       QuerySslCtxtHandle()
                       );
        
        if ( pCHRequest != NULL) {
            
            SECURITY_STATUS                     ss;
            SecPkgContext_LocalCredenitalInfo  spcLCI;
            
            // get the security package context with credentials
            // NYI: Use function pointer in this case. 
            // Currently security.dll is not supported in Win95.
            ss = QueryContextAttributes( pCHRequest,
                                         SECPKG_ATTR_LOCAL_CRED,
                                         &spcLCI );
    
            if ( ss != NO_ERROR) {
                
                hr = HRESULT_FROM_WIN32( ((DWORD ) ss));
            } else if ( !spcLCI.cCertificates ) {
                
                hr = OLE_E_ENUM_NOMORE;
            } else {
                
                if ( cbCertBuffer >= spcLCI.cbCertificateChain ) {
                    
                    // copy the data from the certificate chain buffer
                    CopyMemory( pbCertBuffer, 
                                (PVOID ) spcLCI.pbCertificateChain,
                                spcLCI.cbCertificateChain
                                );
                } else {
                    
                    hr = TYPE_E_BUFFERTOOSMALL;
                }
                
                // fill in the size of data required
                if ( pcbRequiredCertBuffer ) {
                    *pcbRequiredCertBuffer = spcLCI.cbCertificateChain;
                }
                
                if ( pdwFlags != NULL) {
                    
                    *pdwFlags = spcLCI.fFlags;
                }
            }
        } else {
            
            hr = OLE_E_ENUM_NOMORE;
        }
# else 
        hr = E_INVALIDARG;
# endif // REG_DLL
    }

    IF_DEBUG( OBJECT) {
        
        DBGPRINTF(( DBG_CONTEXT,
                    "%08x::ServerCertificate(%d, %08x, %08x[%d], %08x[%08x])"
                    " => %08x\n",
                    this, cbCertBuffer, pbCertBuffer, 
                    pcbRequiredCertBuffer, 
                    ((pcbRequiredCertBuffer) ? *pcbRequiredCertBuffer : 0),
                    pdwFlags, 
                    ((pdwFlags) ? *pdwFlags : 0),
                    hr));
    }

    return ( hr);
} // CIsaRequestObject::ServerCertificate()



STDMETHODIMP
CIsaRequestObject::Cookies(
    OUT IIsaRequestDictionary **ppDictReturn
    )
{
	return ( E_NOTIMPL);
} // CIsaRequestObject::Cookies()

STDMETHODIMP
CIsaRequestObject::Form(
    OUT IIsaRequestDictionary **ppDictReturn
    )
{
	return ( m_Form.
             QueryInterface(IID_IIsaRequestDictionary, 
                            reinterpret_cast<void **>(ppDictReturn)
                            )
             );
} // CIsaRequestObject::Form()

STDMETHODIMP
CIsaRequestObject::QueryString(
    OUT IIsaRequestDictionary **ppDictReturn
    )
{
	return ( m_QueryString.
             QueryInterface(IID_IIsaRequestDictionary, 
                            reinterpret_cast<void **>(ppDictReturn)
                            )
             );
} // CIsaRequestObject::QueryString()


STDMETHODIMP
CIsaRequestObject::ServerVariables(
    OUT IIsaRequestDictionary **ppDictReturn
    )
{
	return ( m_ServerVariables.
             QueryInterface(IID_IIsaRequestDictionary, 
                            reinterpret_cast<void **>(ppDictReturn)
                            )
             );
} // CIsaRequestObject::ServerVariables()


/************************************************************
 *  Internal Functions 
 ************************************************************/

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\tisat1\isainst.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      isainst.cpp

   Abstract:
      This module defines the functions for Internet Server Application
        Instance and Instance Pool

   Author:

       Murali R. Krishnan    ( MuraliK )     9-Sept-1996 

   Environment:
       Win32 
       
   Project:

       Internet Application Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "isainst.hxx"
# include "dbgutil.h"

# ifdef MTX_ENABLED
#include <vipapi.h>
# endif // MTX_ENABLED

#define IID_DEFINED

# ifdef MTX_ENABLED

#include <txctx.h>
#include <txctx_i.c>

# endif // MTX_ENABLED

#include "isat_i.c"
#include "sobj_i.c"


class HTTP_REQUEST;  // forward declaration

// Following defintions of HSE_PRIV* is imported from httpreq.hxx
#define HSE_PRIV_REQ_TSVCINFO          0x0000f001
#define HSE_PRIV_REQ_HTTP_REQUEST      (HSE_PRIV_REQ_TSVCINFO+1)

#define HSE_PRIV_REQ_VROOT_TABLE       (HSE_PRIV_REQ_TSVCINFO+2)

#define HSE_PRIV_REQ_TSVC_CACHE        (HSE_PRIV_REQ_TSVCINFO+3)

/************************************************************
 *    Functions 
 ************************************************************/

PISA_INSTANCE
CreateNewInstance( IN LPCLSID pclsid);



/************************************************************
 *  Member functions of ISA_INSTANCE
 ************************************************************/

ISA_INSTANCE::ISA_INSTANCE(VOID)
    : m_fInUse   ( FALSE),
      m_fInstantiated ( FALSE),
      m_pIsa     ( NULL),
      m_pRequest ( NULL),
      m_pResponse( NULL)
{

    InitializeListHead( &m_listEntry);

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Created ISA_INSTANCE %08x\n",
                    this));
    }

} // ISA_INSTANCE::ISA_INSTANCE()

ISA_INSTANCE::~ISA_INSTANCE(VOID)
{
    DBG_ASSERT( !m_fInUse);

    if ( m_pIsa != NULL) {
        m_pIsa->Release();
        m_pIsa = NULL;
    }

    if ( m_pRequest != NULL) { 
        m_pRequest->Release();
        m_pRequest = NULL;
    }

    if ( m_pResponse != NULL) { 
        m_pResponse->Release();
        m_pResponse = NULL;
    }

    m_fInUse = FALSE;
    m_fInstantiated = FALSE;

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Deleted ISA_INSTANCE %08x\n",
                    this));
    }

} // ISA_INSTANCE::~ISA_INSTANCE()



BOOL
ISA_INSTANCE::Instantiate( IN LPCLSID pclsid)
{
    HRESULT hr;
    DBG_ASSERT( !m_fInstantiated);
    DBG_ASSERT( NULL == m_pIsa);
    DBG_ASSERT( NULL == m_pRequest);
    DBG_ASSERT( NULL == m_pResponse);
    DBG_ASSERT( NULL != pclsid);

    m_clsidIsa = *pclsid;

# ifdef VIPER
    // Get a Viper transaction context object (should only do once)
    hr = CoCreateInstance(CLSID_TransactionContextEx, NULL,
                          CLSCTX_SERVER, 
                          IID_ITransactionContextEx, (void**)&m_pTxContext);
    if (!SUCCEEDED(hr)) goto Err;
# endif

    
#ifndef VIPER
    hr = CoCreateInstance(m_clsidIsa, NULL,
                          CLSCTX_SERVER, IID_IInetServerApp, 
                          (void ** ) &m_pIsa);
#else
    // Create the COMISAPI instance that wraps the ISAPI DLL
    hr = m_pTxContext->CreateInstance( m_clisidIsa, IID_IInetServerApp, 
                                       (void **) &m_pIsa);
# endif NO_VIPER
    if (!SUCCEEDED(hr)) goto Err;
        
    // NYI: Wrap the ECB in a Viper context property 
    hr = CoCreateInstance(CLSID_IsaRequest, NULL, CLSCTX_SERVER, 
                          IID_IIsaRequest, (void **) &m_pRequest);
    if (!SUCCEEDED(hr)) goto Err;

    // NYI: Wrap the ECB in a Viper context property 
    hr = CoCreateInstance(CLSID_IsaResponse, NULL, CLSCTX_SERVER, 
                          IID_IIsaResponse, (void **) &m_pResponse);
    if (!SUCCEEDED(hr)) goto Err;

    // store the context in the created ISA instance
    hr = m_pIsa->SetContext( m_pRequest, m_pResponse);
    if (!SUCCEEDED(hr)) goto Err;

Err:
    if (!SUCCEEDED(hr)) {

        Print();

        DBGPRINTF(( DBG_CONTEXT, " Error = %0x8x\n", hr));

#ifdef VIPER
        if (m_pTxContext) {
            m_pTxContext->Release();
            m_ppTxContext = NULL;
        }
#endif // VIPER

        if ( m_pIsa) {
            m_pIsa->Release();
            m_pIsa = NULL;
        }

        if ( m_pRequest != NULL) { 
            m_pRequest->Release();
            m_pRequest = NULL;
        }
        
        if ( m_pResponse != NULL) { 
            m_pResponse->Release();
            m_pResponse = NULL;
        }
    } else {
        m_fInstantiated = TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[%08x]::Instantiate( %08x " GUID_FORMAT ") returns hr=%08x \n",
                this, pclsid, GUID_EXPAND( pclsid), hr
                ));
    
    return ( (SUCCEEDED(hr)? TRUE : FALSE));

} // ISA_INSTANCE::Instantiate()



HRESULT 
ISA_INSTANCE::ProcessRequest(IN EXTENSION_CONTROL_BLOCK * pecb, 
                             OUT LPDWORD pdwStatus)
{
    HTTP_REQUEST * pReq;
    HRESULT hr = E_FAIL;

    DBG_ASSERT( m_fInstantiated);
    DBG_ASSERT( NULL != m_pIsa);
    DBG_ASSERT( NULL != m_pRequest);
    DBG_ASSERT( NULL != m_pResponse);
    DBG_ASSERT( !m_fInUse);

    m_fInUse = TRUE;

    // 1. Obtain the private HTTP_REQUEST object
    DBG_REQUIRE(( pecb->ServerSupportFunction( pecb->ConnID,
                                               HSE_PRIV_REQ_HTTP_REQUEST,
                                               &pReq,
                                               NULL,
                                               NULL )));
    
    
    
    // 2. Set the HTTP_REQUEST object in the Request object
    hr = m_pRequest->SetHttpRequest( (unsigned long ) pReq);
    if ( SUCCEEDED( hr)) {
        
        // 3. Set the HTTP_REQUEST object in the Response object
        hr = m_pResponse->SetHttpRequest( (unsigned long ) pReq);

        // By Virtue of instantiation, m_pIsa is already bound to the 
        //   Request and Response objects

        DBG_ASSERT( IsInstantiated());
        
        // 4. Process the request
        if ( SUCCEEDED( hr)) {
            hr = m_pIsa->ProcessRequest( pdwStatus);
        }
    }
    
    m_fInUse = FALSE;

    return ( hr);
} // ISA_INSTANCE::ProcessRequest()



void
ISA_INSTANCE::Print(VOID) const
{
    DBGPRINTF(( DBG_CONTEXT, 
                "ISA_INSTANCE(%08x):"
                " pIsa=%08x; pRequest=%08x; pResponse=%08x;"
                " fInUse=%d; fInstantiated=%d"
                "\n"
                ,
                this, m_pIsa, m_pRequest, m_pResponse, 
                m_fInUse, m_fInstantiated
                ));
    return;
} // ISA_INSTANCE::Print()



/************************************************************
 *  Member functions of ISA_INSTANCE
 ************************************************************/

ISA_INSTANCE_POOL::ISA_INSTANCE_POOL(VOID)
    : m_fInstantiated ( FALSE),
      m_nFreeEntries  ( 0),
      m_nActiveEntries( 0)
{

    m_rgchProgId[0] = L'\0';
    
    InitializeCriticalSection( & m_csLock);
    InitializeListHead( &m_lActiveEntries);
    InitializeListHead( &m_lFreeEntries);

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Created ISA_INSTANCE_POOL %08x\n",
                    this));
    }

} // ISA_INSTANCE_POOL::ISA_INSTANCE_POOL()


ISA_INSTANCE_POOL::~ISA_INSTANCE_POOL(VOID)
{
    PLIST_ENTRY pl;

    DBG_ASSERT( IsListEmpty( &m_lActiveEntries));
    DBG_ASSERT( 0 == m_nActiveEntries);

    // free up all the instances in the pool
    for( pl = m_lFreeEntries.Flink; 
         pl != &m_lFreeEntries; 
         m_nFreeEntries-- ) {
        
        PLIST_ENTRY plNext;

        PISA_INSTANCE pisaInstance = 
            CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);

        plNext = pl->Flink;

        DBG_ASSERT( pisaInstance);
        RemoveEntryList( pl);
        delete pisaInstance;
        pl = plNext;

    } // for

    DBG_ASSERT( IsListEmpty(&m_lFreeEntries));
    DBG_ASSERT( 0 == m_nFreeEntries);
    
    m_fInstantiated = FALSE;

    DeleteCriticalSection( & m_csLock);

    IF_DEBUG( OBJECT) {

        DBGPRINTF(( DBG_CONTEXT, "Deleted ISA_INSTANCE_POOL %08x\n",
                    this));
    }

} // ISA_INSTANCE_POOL::~ISA_INSTANCE_POOL()



VOID
ISA_INSTANCE_POOL::Print(VOID)
{
    PLIST_ENTRY pl;
    
    DBGPRINTF(( DBG_CONTEXT, 
                "ISA_INSTANCE_POOL (%08x):"
                " ProgId = %ws. Instantiated=%d\n"
                " Guid = " GUID_FORMAT " \n"
                " Instances #Free = %d; #Active = %d"
                "\n"
                ,
                this, m_rgchProgId,
                m_fInstantiated,
                GUID_EXPAND( &m_clsidIsa),
                m_nFreeEntries, m_nActiveEntries
                ));

    Lock();
    // Print all free entries
    DBGPRINTF(( DBG_CONTEXT, " Free Entries \n"));
    for( pl = m_lFreeEntries.Flink; pl != &m_lFreeEntries; 
         pl = pl->Flink) {
        
        PISA_INSTANCE pisaInstance = 
            CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);
        
        pisaInstance->Print();
    } // for

    // Print all active entries
    DBGPRINTF(( DBG_CONTEXT, " Active Entries \n"));
    for( pl = m_lActiveEntries.Flink; pl != &m_lActiveEntries; 
         pl = pl->Flink) {
        
        PISA_INSTANCE pisaInstance = 
            CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);
        
        pisaInstance->Print();
    } // for

    Unlock();

    return;
} // ISA_INSTANCE_POOL::Print()



BOOL
ISA_INSTANCE_POOL::Instantiate( IN LPCWSTR pszProgId)
/*++
  ISA_INSTANCE_POOL::Instantiate()

  o  This function instantiates the instance pool. It stores the 
     program ID supplied as well as the class ID for the given object.
     In the future new instances maybe created in this instance pool
     using these values.

  Arguments:
    pszProgId - pointer to null-terminated-string containing the ProgID
                  for instance objects

  Returns:
    TRUE on success and FALSE if there is any error.
--*/
{
    HRESULT hr;
    DBG_ASSERT( !m_fInstantiated);
    DBG_ASSERT( m_rgchProgId[0] == L'\0');

    // Get the clsid for the instance
    hr = CLSIDFromProgID( pszProgId, &m_clsidIsa);

    if (!SUCCEEDED(hr)) {

        Print();

        DBGPRINTF(( DBG_CONTEXT, 
                    "ISA_INSTANCE_POOL::Instantiate(%ws)."
                    " Could not get CLSID from ProgId. Error = %0x8x\n", 
                    pszProgId, hr));
    } else {
        // make a local copy of the ProgId
        lstrcpynW( m_rgchProgId, pszProgId,
                   (sizeof( m_rgchProgId) - 1)/sizeof(WCHAR));
        m_fInstantiated = TRUE;
    }

    return ( (SUCCEEDED(hr)? TRUE : FALSE));

} // ISA_INSTANCE_POOL::Instantiate()



PISA_INSTANCE
ISA_INSTANCE_POOL::GetInstance(void)
{
    PISA_INSTANCE pisa = NULL;

    DBG_ASSERT( m_fInstantiated);

    //
    // 1. Look for a free instance
    // 2. If a free one is found, 
    //        move it to active list and return pointer for the same
    // 3. If no free instance is found, create a new instance
    // 4. Send the new instance off to the caller after putting it in
    //     the active list.
    //

    if ( m_nFreeEntries > 0) {
        
        // Aha! there may be free entries, lock and pull one out.
        Lock();
        
        if ( m_nFreeEntries > 0) {
            // remove an item from the list
            PLIST_ENTRY pl = m_lFreeEntries.Flink;
            RemoveEntryList( pl);
            
            pisa = CONTAINING_RECORD( pl, ISA_INSTANCE, m_listEntry);
            DBG_ASSERT( pisa != NULL);
            m_nFreeEntries--;
            DBG_ASSERT( m_nFreeEntries >= 0);

            InsertTailList( &m_lActiveEntries, pl);
            m_nActiveEntries++;
            DBG_ASSERT( m_nActiveEntries > 0);
        }
        Unlock();
    }

    if ( NULL == pisa) {

        // we did not find an item. we need to create a new instance

        // create a new instance
        pisa = CreateNewInstance( &m_clsidIsa);

        if ( pisa != NULL) {
            
            // Successfully created  a new instance. Add it to the list.
            Lock();
            InsertTailList( &m_lActiveEntries, &pisa->m_listEntry);
            m_nActiveEntries++;
            DBG_ASSERT( m_nActiveEntries > 0);
            Unlock();
        } else {
            
            // there was an error in creating the instance.
        }
    }

    DBGPRINTF(( DBG_CONTEXT,
                "[%08x]::GetInstance() returns %08x\n",
                this, pisa
                ));
     

    return ( pisa);
 
} // ISA_INSTANCE_POOL::GetInstance()



BOOL
ISA_INSTANCE_POOL::ReleaseInstance( PISA_INSTANCE pisaInstance)
{
    DBG_ASSERT( NULL != pisaInstance);
    
    //
    // 1. Remove the request from the active list
    // 2. Add this new item to the free list
    // 3. Adjust the counts appropriately
    //

    Lock();

    DBG_ASSERT( m_nActiveEntries > 0);
    RemoveEntryList( &pisaInstance->m_listEntry);
    m_nActiveEntries--;
    DBG_ASSERT( m_nActiveEntries >= 0);
    
    InsertHeadList( &m_lFreeEntries, &pisaInstance->m_listEntry);
    m_nFreeEntries++;
    DBG_ASSERT( m_nFreeEntries > 0);
    
    Unlock();

    return (TRUE);
} // ISA_INSTANCE_POOL::ReleaseInstance()



PISA_INSTANCE
CreateNewInstance( IN LPCLSID pclsid)
{
    PISA_INSTANCE pisa;
    
    pisa = new ISA_INSTANCE();
    if ( NULL == pisa ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "Creating ISA_INSTANCE failed. \n"
                    ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    } else {
        if ( !pisa->Instantiate( pclsid )) {
            
            DBGPRINTF(( DBG_CONTEXT,
                        "[%08x]::Instantiate( " GUID_FORMAT ") failed. "
                        " Error=%d \n",
                        pisa, GUID_EXPAND(pclsid), GetLastError()
                        ));
     
            delete pisa;
            pisa = NULL;
        }
    }

    return ( pisa);
} // CreateNewInstance()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\spamcls.c ===
const CLSID CLSID_SPAM = { 0x2a005c11, 0xa5de, 0x11cf, { 0x9e, 0x66, 0, 0xaa, 0, 0xa3, 0xf4, 0x64 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\spam.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 18 18:13:12 1996
 */
/* Compiler settings for spam.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __spam_h__
#define __spam_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISharedProperty_FWD_DEFINED__
#define __ISharedProperty_FWD_DEFINED__
typedef interface ISharedProperty ISharedProperty;
#endif 	/* __ISharedProperty_FWD_DEFINED__ */


#ifndef __ISharedPropertyGroup_FWD_DEFINED__
#define __ISharedPropertyGroup_FWD_DEFINED__
typedef interface ISharedPropertyGroup ISharedPropertyGroup;
#endif 	/* __ISharedPropertyGroup_FWD_DEFINED__ */


#ifndef __ISharedPropertyGroupManager_FWD_DEFINED__
#define __ISharedPropertyGroupManager_FWD_DEFINED__
typedef interface ISharedPropertyGroupManager ISharedPropertyGroupManager;
#endif 	/* __ISharedPropertyGroupManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISharedProperty_INTERFACE_DEFINED__
#define __ISharedProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISharedProperty
 * at Thu Jul 18 18:13:12 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][unique][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_ISharedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISharedProperty : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISharedProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISharedProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISharedProperty __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISharedProperty __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISharedProperty __RPC_FAR * This,
            /* [in] */ VARIANT val);
        
        END_INTERFACE
    } ISharedPropertyVtbl;

    interface ISharedProperty
    {
        CONST_VTBL struct ISharedPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedProperty_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISharedProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISharedProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISharedProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISharedProperty_get_Value(This,pVal)	\
    (This)->lpVtbl -> get_Value(This,pVal)

#define ISharedProperty_put_Value(This,val)	\
    (This)->lpVtbl -> put_Value(This,val)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ISharedProperty_get_Value_Proxy( 
    ISharedProperty __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB ISharedProperty_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ISharedProperty_put_Value_Proxy( 
    ISharedProperty __RPC_FAR * This,
    /* [in] */ VARIANT val);


void __RPC_STUB ISharedProperty_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedProperty_INTERFACE_DEFINED__ */


#ifndef __ISharedPropertyGroup_INTERFACE_DEFINED__
#define __ISharedPropertyGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISharedPropertyGroup
 * at Thu Jul 18 18:13:12 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][unique][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_ISharedPropertyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISharedPropertyGroup : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreatePropertyByPosition( 
            /* [in] */ int Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PropertyByPosition( 
            /* [in] */ int Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateProperty( 
            /* [in] */ BSTR Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Property( 
            /* [in] */ BSTR Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISharedPropertyGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISharedPropertyGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyByPosition )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ int Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PropertyByPosition )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ int Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProperty )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ BSTR Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Property )( 
            ISharedPropertyGroup __RPC_FAR * This,
            /* [in] */ BSTR Index,
            /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);
        
        END_INTERFACE
    } ISharedPropertyGroupVtbl;

    interface ISharedPropertyGroup
    {
        CONST_VTBL struct ISharedPropertyGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedPropertyGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedPropertyGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedPropertyGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedPropertyGroup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISharedPropertyGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISharedPropertyGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISharedPropertyGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISharedPropertyGroup_CreatePropertyByPosition(This,Index,ppProp)	\
    (This)->lpVtbl -> CreatePropertyByPosition(This,Index,ppProp)

#define ISharedPropertyGroup_get_PropertyByPosition(This,Index,ppProperty)	\
    (This)->lpVtbl -> get_PropertyByPosition(This,Index,ppProperty)

#define ISharedPropertyGroup_CreateProperty(This,Index,ppProp)	\
    (This)->lpVtbl -> CreateProperty(This,Index,ppProp)

#define ISharedPropertyGroup_get_Property(This,Index,ppProperty)	\
    (This)->lpVtbl -> get_Property(This,Index,ppProperty)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_CreatePropertyByPosition_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ int Index,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);


void __RPC_STUB ISharedPropertyGroup_CreatePropertyByPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_get_PropertyByPosition_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ int Index,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);


void __RPC_STUB ISharedPropertyGroup_get_PropertyByPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_CreateProperty_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ BSTR Index,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProp);


void __RPC_STUB ISharedPropertyGroup_CreateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroup_get_Property_Proxy( 
    ISharedPropertyGroup __RPC_FAR * This,
    /* [in] */ BSTR Index,
    /* [retval][out] */ ISharedProperty __RPC_FAR *__RPC_FAR *ppProperty);


void __RPC_STUB ISharedPropertyGroup_get_Property_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedPropertyGroup_INTERFACE_DEFINED__ */


#ifndef __ISharedPropertyGroupManager_INTERFACE_DEFINED__
#define __ISharedPropertyGroupManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISharedPropertyGroupManager
 * at Thu Jul 18 18:13:12 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][unique][helpstring][dual][uuid] */ 



EXTERN_C const IID IID_ISharedPropertyGroupManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ISharedPropertyGroupManager : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreatePropertyGroup( 
            /* [in] */ BSTR name,
            /* [in] */ LONG dwIsoMode,
            /* [in] */ LONG dwRecMode,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [in] */ BSTR Index,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISharedPropertyGroupManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISharedPropertyGroupManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISharedPropertyGroupManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyGroup )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ LONG dwIsoMode,
            /* [in] */ LONG dwRecMode,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Group )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [in] */ BSTR Index,
            /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ISharedPropertyGroupManager __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);
        
        END_INTERFACE
    } ISharedPropertyGroupManagerVtbl;

    interface ISharedPropertyGroupManager
    {
        CONST_VTBL struct ISharedPropertyGroupManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISharedPropertyGroupManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISharedPropertyGroupManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISharedPropertyGroupManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISharedPropertyGroupManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISharedPropertyGroupManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISharedPropertyGroupManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISharedPropertyGroupManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISharedPropertyGroupManager_CreatePropertyGroup(This,name,dwIsoMode,dwRecMode,ppGroup)	\
    (This)->lpVtbl -> CreatePropertyGroup(This,name,dwIsoMode,dwRecMode,ppGroup)

#define ISharedPropertyGroupManager_get_Group(This,Index,ppGroup)	\
    (This)->lpVtbl -> get_Group(This,Index,ppGroup)

#define ISharedPropertyGroupManager_get__NewEnum(This,retval)	\
    (This)->lpVtbl -> get__NewEnum(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroupManager_CreatePropertyGroup_Proxy( 
    ISharedPropertyGroupManager __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ LONG dwIsoMode,
    /* [in] */ LONG dwRecMode,
    /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);


void __RPC_STUB ISharedPropertyGroupManager_CreatePropertyGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroupManager_get_Group_Proxy( 
    ISharedPropertyGroupManager __RPC_FAR * This,
    /* [in] */ BSTR Index,
    /* [retval][out] */ ISharedPropertyGroup __RPC_FAR *__RPC_FAR *ppGroup);


void __RPC_STUB ISharedPropertyGroupManager_get_Group_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ISharedPropertyGroupManager_get__NewEnum_Proxy( 
    ISharedPropertyGroupManager __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *retval);


void __RPC_STUB ISharedPropertyGroupManager_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISharedPropertyGroupManager_INTERFACE_DEFINED__ */



#ifndef __Spam_LIBRARY_DEFINED__
#define __Spam_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: Spam
 * at Thu Jul 18 18:13:12 1996
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public] */ 
enum __MIDL___MIDL__intf_0075_0001
    {	LockSetGet	= 0,
	LockMethod	= LockSetGet + 1
    }	LockModes;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0075_0002
    {	RecycleInstance	= 0,
	RecycleProcess	= RecycleInstance + 1
    }	RecycleModes;


EXTERN_C const IID LIBID_Spam;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SharedProperty;

class SharedProperty;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SharedPropertyGroup;

class SharedPropertyGroup;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SharedPropertyGroupManager;

class SharedPropertyGroupManager;
#endif
#endif /* __Spam_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\dispman.h ===
// Microsoft Viper96 (Microsoft Confidential)
// Copyright(c) 1995 - 1996 Microsoft Corporation.  All Rights Reserved.

// DispMan.h	public interface for Resource Dispenser implementations

#ifndef _DISPMAN_H
#define _DISPMAN_H

//To implement a Resource Dispenser:
//
//1. Build a dll which implements IDispenserDriver (and of course the API you expose to users).
//2. In the startup (dllmain or first call to API) you must call GetDispenserManager.
//   This returns a pointer to the DispMan's IDispenserManager.
//3. On this interface call RegisterDispenser passing a pointer to your implementation of
//... fix this
//   IDispenserDriver.  This will cause DispMan to create a Holder (pooling manager) for your Dispenser
//   and DispMan will call back to your RegisterHolder method to inform you of the pointer to your IHolder.
//   Your RegisterHolder method should remember this pointer in order to know how to call
//   AllocResource, FreeResource,...
//   Now RegisterDispenser returns to you and your initialization is complete.
//4. Now (in response to calls to your API) you can make AllocResource,FreeResource,.. calls.
//   AllocResource will initially respond by calling back to your CreateResource, but later
//   AllocResource calls will be serviced from the growing pool of resources.

#ifdef WIN32
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

//
// TYPES
//

#define VIPER_UNICODE					// remove this if DispMan (and rest of VIPER) is not UNICODE

#ifdef VIPER_UNICODE
typedef wchar_t VCHAR;
#else
typedef char	VCHAR;
#endif

typedef VCHAR*			RESTYPID;		// resource type ID String
typedef const VCHAR*	constRESTYPID;
#define MAX_RESTYPID	1000			// max len of a RESTYPID
typedef DWORD			TRANSID;
typedef VCHAR*			RESID;			// resource ID
typedef const VCHAR*	constRESID;
typedef	long			TIMEINSECS;	// time in seconds for Dispenser Manager resource destruction timeout

//
// GUIDS
//

// {5cb31e10-2b5f-11cf-be10-00aa00a2fa25}
DEFINE_GUID(IID_IDispenserManager,
0x5cb31e10,0x2b5f,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);

// {bf6a1850-2b45-11cf-be10-00aa00a2fa25}
DEFINE_GUID (IID_IHolder,
0xbf6a1850,0x2b45,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);

// {208b3651-2b48-11cf-be10-00aa00a2fa25}
DEFINE_GUID(IID_IDispenserDriver,
0x208b3651,0x2b48,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


//
// INTERFACES
//

interface IDispenserDriver;
interface IHolder;

DECLARE_INTERFACE_(IDispenserManager, IUnknown)
{
	// IUknown interface methods.
	STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) = 0;
	STDMETHOD_(ULONG, AddRef)(THIS) = 0;
	STDMETHOD_(ULONG, Release)(THIS) = 0;

	// IDispenserManager interface methods.
	STDMETHOD(RegisterDispenser) (THIS_ IDispenserDriver*, VCHAR* szDispenserName, IHolder**) = 0;
	STDMETHOD(GetInstance) (THIS_ IUnknown** ppUnkInstanceContext) = 0;
};

DECLARE_INTERFACE_(IHolder, IUnknown)
{
	// IUknown interface methods.
	STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) = 0;
	STDMETHOD_(ULONG, AddRef)(THIS) = 0;
	STDMETHOD_(ULONG, Release)(THIS) = 0;

	// IHolder interface methods.

	STDMETHOD(AllocResource)(THIS_ constRESTYPID, /*out*/ RESID, const size_t) = 0;

	// FreeResource reinitializes the resource and caches it for later use.
	STDMETHOD(FreeResource)(THIS_ constRESID) = 0;

	// TrackResource keeps track of an external resource allocated somewhere else.  
	STDMETHOD(TrackResource)(THIS_ constRESID) = 0;

	// UntrackResource removes the external resource from holder resource tracking table.
	STDMETHOD(UntrackResource)(THIS_ constRESID, const BOOL) = 0;

	// Shutdown tells Holder to destroy any inventory
	STDMETHOD(Close)(THIS) = 0;

};

DECLARE_INTERFACE_(IDispenserDriver, IUnknown)
{
	STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) = 0;
	STDMETHOD_(ULONG, AddRef)(THIS) = 0;
	STDMETHOD_(ULONG, Release)(THIS) = 0;

	// IDispenserDriver interface methods.

	STDMETHOD(CreateResource)(THIS_ constRESTYPID, /*out*/ RESID, const size_t, TIMEINSECS*) = 0;
	STDMETHOD(EnlistResource)(THIS_ constRESID, const TRANSID) = 0;
		// Dispenser Manager will pass TRANSID==0 to ensure non-enlisted resource
		// return S_FALSE if the resource is not enlistable
	STDMETHOD(ResetResource)(THIS_ constRESID, /*out*/RESTYPID) = 0;
	STDMETHOD(DestroyResource)(THIS_ constRESID) = 0;
};


//
// HELPERS
//

// for Resource Dispensers to get IDispenserManager
__declspec(dllimport) HRESULT GetDispenserManager(IDispenserManager**); 

#endif // ifndef _DISPMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\tisat1\tisat1.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :
       isattest.cpp

   Abstract:
       This module defines the Test ISAPI DLL for driving 
         InetServerApp
 
   Author:

       Murali R. Krishnan    ( MuraliK )     6-Sept-1996 

   Project:

       Internet Application Server DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "isainst.hxx"
#include <objbase.h>

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR | DEBUG_OBJECT)

# include "dbgutil.h"


# define PSZ_PROGID_TEST1   L"MSISA.Test1"

/************************************************************
 *     Variable Declarations
 ************************************************************/
# ifdef COINIT_NOEX
static DWORD g_dwTLSIndex = (DWORD)-1;    // COM initialization flag
# endif // COINIT_NOEX

BOOL   g_fComInit = FALSE;

ISA_INSTANCE_POOL * g_pisaPool = NULL;

DECLARE_DEBUG_PRINTS_OBJECT();                  
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisTisAtGuid, 
0x784d8932, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

HRESULT 
IsapiToISA( EXTENSION_CONTROL_BLOCK * pECB, LPDWORD pdwStatus);

const  char PSZ_FAILURE_MSG[] = "<HTML> This call failed\n</HTML>";
# define LEN_PSZ_FAILURE_MSG (sizeof(PSZ_FAILURE_MSG) - 1)


/************************************************************
 *     Functions
 ************************************************************/

extern "C"
BOOL 
WINAPI DllMain(HINSTANCE    hinstDll,
               DWORD        fdwReason,
               LPVOID       lpvContext
               )
/*++
  DllMain()

  o  This function isinvoked when this DLL is loaded/unloaded.
     Since IIS thread pools, we will not reliably get DLL_THREAD_ATTACH
     messages. Avoid problems by acquiring all resources on DLL_PROCESS_ATTACH
     and deallocating them on DLL_PROCESS_DETACH

  Arguments:
    hinstDll - Handle for this DLL instance
    fdwReason - flags indicating the Reason for call
    lpvContext - special context value for the call

  Returns:
    TRUE on success and FALSE if there is any error
--*/
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH: {

        HRESULT hr;

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( "isattest");
#else
        CREATE_DEBUG_PRINT_OBJECT( "isattest", IisTisAtGuid);
#endif
        if ( !VALID_DEBUG_PRINT_OBJECT()) { 
            return ( FALSE);
        }
#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_OBJECT );
#endif


#ifdef COINIT_NOEX
        // allocate thread local storage
        if ((g_dwTLSIndex = TlsAlloc()) == -1)
            return FALSE;

# else
        hr = CoInitializeEx( NULL, 
                             (COINIT_MULTITHREADED | 
                              COINIT_DISABLE_OLE1DDE |
                              COINIT_SPEED_OVER_MEMORY)
                             );
        g_fComInit = (hr == S_OK);

        DBGPRINTF(( DBG_CONTEXT, 
                    "\tCoInitializeEx( NULL, %08x) returns %08x\n",
                    (COINIT_MULTITHREADED | 
                     COINIT_DISABLE_OLE1DDE |
                     COINIT_SPEED_OVER_MEMORY),
                    hr
                    ));
# endif // ifndef COINIT_NOEX

        // IIS thread pools, we don't want thread notifications
        // so disable them to improve performance
        DisableThreadLibraryCalls(hinstDll);
        break;
    }
    
    case DLL_PROCESS_DETACH:

#ifdef COINIT_NOEX 
        if (g_dwTLSIndex != -1)
            TlsFree(g_dwTLSIndex);
# else
        if (g_pisaPool) {
            delete g_pisaPool;
            g_pisaPool = NULL;
        }

        if ( g_fComInit) { 
            CoUninitialize();
        }
# endif // COINIT_NOEX
        
        DELETE_DEBUG_PRINT_OBJECT();
        break;
    }
    
    return TRUE;
} // DllMain()




extern "C" 
BOOL WINAPI
GetExtensionVersion(HSE_VERSION_INFO* pVer)
/*++
  GetExtensionVerion()
  o  Standard Entry point called by IIS as the first entry.
      It is called only once. It is called in the system context.
      The ISAPI application can register its version information with IIS.
      
  Arugments:
    pVer - pointer to Internet Server Application Version Inforamtion
    
  Returns:
    TRUE on success and FALSE on failure.
--*/
{
    BOOL fRet = TRUE;

    pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    strncpy(pVer->lpszExtensionDesc, "Test InetServerApp Object", 
            HSE_MAX_EXT_DLL_NAME_LEN);

    g_pisaPool = new ISA_INSTANCE_POOL();
    if ( NULL == g_pisaPool ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "Creating ISA_INSTANCE_POOL failed. \n"
                    ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        fRet = FALSE;
    } else {
        if ( !g_pisaPool->Instantiate( PSZ_PROGID_TEST1 )) {
            
            DBGPRINTF(( DBG_CONTEXT,
                        "[%08x]::Instantiate( %ws) failed. Error=%d \n",
                        g_pisaPool, PSZ_PROGID_TEST1, GetLastError()
                        ));
     
            delete g_pisaPool;
            g_pisaPool = NULL;
            fRet = FALSE;
        }
    }

    DBGPRINTF(( DBG_CONTEXT, 
                "GetExtensionVersion(%08x) returns with value %d. App=%s\n",
                pVer, fRet, pVer->lpszExtensionDesc));


    return (fRet);
} // GetExtensionVersion()




extern "C"
BOOL WINAPI
TerminateExtension( IN DWORD dwFlags)
/*++
  TerminateExtension()
  o  Standard Entry point called by IIS as the last function.
      It is called to request the unload of the ISAPI dll.
      
  Arugments:
    dwFlags - DWORD flags indicating the state of the unload.

  Returns:
    TRUE on success -> means that the DLL can be unloaded
    and FALSE if the DLL should not be unloaded yet.
--*/
{
    DBGPRINTF(( DBG_CONTEXT, "TerminateExtension (%08x)\n", dwFlags));

    // if (# current requests > 0) then do not stop.
    if ( NULL != g_pisaPool) {
        g_pisaPool->Print();
        DBG_ASSERT( g_pisaPool->NumActive() == 0);
        // NYI: This function is not fully implemented.
    }

    return (TRUE);
} // TerminateExtension()




extern "C"
DWORD WINAPI
HttpExtensionProc( EXTENSION_CONTROL_BLOCK* pECB)
/*++
  HttpExtensionProc()
  o  The main function for processing the ISAPI application requests.
     For each request to this DLL,
      IIS formats an ECB and invokes this function.
      This funciton is responsible for executing or failing the request.
 
  Arguments:
   pECB - pointer to ECB - the extension control block containing the 
          most frequently used variables for IIS requests.

  Returns:
   DWORD containig the HSE_STATUS_* codes.
--*/
{
    DWORD dwRet = HSE_STATUS_SUCCESS;

    try {
        if (!SUCCEEDED(IsapiToISA(pECB, &dwRet))) {
            dwRet = HSE_STATUS_ERROR;               
        }
    }
    catch(...) {
        DBG_ASSERT(FALSE);
        
        DWORD cbMsg = LEN_PSZ_FAILURE_MSG;
        pECB->WriteClient( pECB->ConnID, 
                           (LPVOID )PSZ_FAILURE_MSG, 
                           &cbMsg, 0);
        dwRet = HSE_STATUS_ERROR;
    }
    
    return dwRet;
} // HttpExtensionProc()



HRESULT 
IsapiToISA(EXTENSION_CONTROL_BLOCK* pECB, DWORD* pdwStatus)
/*++
  IsapiToISA
  o  This function finds and ISA_INSTANCE and dispatches a HttpRequest
     to the ISA instance for execution. Once the execution completes,
     this function returns the status to the caller.

  Arguments:
    pECB - pointer to ISAPI Extension Control Block.
    pdwStatus - pointer to DWORD which will contain status on return.

  Returns:
    HRESULT
--*/
{ 
    HRESULT hr = E_FAIL;
    PISA_INSTANCE pisa;

    DBG_ASSERT( NULL != g_pisaPool);

    if ( g_pisaPool == NULL) {

        DBGPRINTF(( DBG_CONTEXT, "The Instance pool is not initialized\n"));
        // we should not have been here.
        DBG_ASSERT( FALSE);
        *pdwStatus = HSE_STATUS_ERROR;
    } else {
        PISA_INSTANCE pisa = g_pisaPool->GetInstance();

        if ( NULL != pisa ) {
            hr = pisa->ProcessRequest( pECB, pdwStatus);

            DBGPRINTF(( DBG_CONTEXT, 
                        "ISA_INSTANCE(%08x)::ProcessRequest( %08x, %08x)."
                        "  returns hr=%08x.  Status = %08x\n",
                        pisa, pECB, pdwStatus, hr, *pdwStatus));

            DBG_REQUIRE( g_pisaPool->ReleaseInstance( pisa));
        } else {
            hr = E_NOINTERFACE;
        }
    }

    return hr;
} // IsapiToISA()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\spam_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 18 18:13:12 1996
 */
/* Compiler settings for spam.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ISharedProperty = {0x2A005C01,0xA5DE,0x11CF,{0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64}};


const IID IID_ISharedPropertyGroup = {0x2A005C07,0xA5DE,0x11CF,{0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64}};


const IID IID_ISharedPropertyGroupManager = {0x2A005C0D,0xA5DE,0x11CF,{0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64}};


const IID LIBID_Spam = {0x2A005C00,0xA5DE,0x11CF,{0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64}};


const CLSID CLSID_SharedProperty = {0x2A005C05,0xA5DE,0x11CF,{0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64}};


const CLSID CLSID_SharedPropertyGroup = {0x2A005C0B,0xA5DE,0x11CF,{0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64}};


const CLSID CLSID_SharedPropertyGroupManager = {0x2A005C11,0xA5DE,0x11CF,{0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\txctx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 18 18:14:59 1996
 */
/* Compiler settings for txctx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __txctx_h__
#define __txctx_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITransactionContext_FWD_DEFINED__
#define __ITransactionContext_FWD_DEFINED__
typedef interface ITransactionContext ITransactionContext;
#endif 	/* __ITransactionContext_FWD_DEFINED__ */


#ifndef __ITransactionContextEx_FWD_DEFINED__
#define __ITransactionContextEx_FWD_DEFINED__
typedef interface ITransactionContextEx ITransactionContextEx;
#endif 	/* __ITransactionContextEx_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ITransactionContext_INTERFACE_DEFINED__
#define __ITransactionContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionContext
 * at Thu Jul 18 18:14:59 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ITransactionContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionContext : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ BSTR pszProgId,
            /* [retval][out] */ VARIANT __RPC_FAR *pObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITransactionContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITransactionContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITransactionContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITransactionContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            ITransactionContext __RPC_FAR * This,
            /* [in] */ BSTR pszProgId,
            /* [retval][out] */ VARIANT __RPC_FAR *pObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            ITransactionContext __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            ITransactionContext __RPC_FAR * This);
        
        END_INTERFACE
    } ITransactionContextVtbl;

    interface ITransactionContext
    {
        CONST_VTBL struct ITransactionContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITransactionContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITransactionContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITransactionContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITransactionContext_CreateInstance(This,pszProgId,pObject)	\
    (This)->lpVtbl -> CreateInstance(This,pszProgId,pObject)

#define ITransactionContext_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define ITransactionContext_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE ITransactionContext_CreateInstance_Proxy( 
    ITransactionContext __RPC_FAR * This,
    /* [in] */ BSTR pszProgId,
    /* [retval][out] */ VARIANT __RPC_FAR *pObject);


void __RPC_STUB ITransactionContext_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITransactionContext_Commit_Proxy( 
    ITransactionContext __RPC_FAR * This);


void __RPC_STUB ITransactionContext_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITransactionContext_Abort_Proxy( 
    ITransactionContext __RPC_FAR * This);


void __RPC_STUB ITransactionContext_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionContext_INTERFACE_DEFINED__ */


#ifndef __ITransactionContextEx_INTERFACE_DEFINED__
#define __ITransactionContextEx_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionContextEx
 * at Thu Jul 18 18:14:59 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ITransactionContextEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionContextEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ REFCLSID cid,
            /* [in] */ REFIID rid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionContextExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionContextEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionContextEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionContextEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            ITransactionContextEx __RPC_FAR * This,
            /* [in] */ REFCLSID cid,
            /* [in] */ REFIID rid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            ITransactionContextEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            ITransactionContextEx __RPC_FAR * This);
        
        END_INTERFACE
    } ITransactionContextExVtbl;

    interface ITransactionContextEx
    {
        CONST_VTBL struct ITransactionContextExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionContextEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionContextEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionContextEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionContextEx_CreateInstance(This,cid,rid,pObject)	\
    (This)->lpVtbl -> CreateInstance(This,cid,rid,pObject)

#define ITransactionContextEx_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#define ITransactionContextEx_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionContextEx_CreateInstance_Proxy( 
    ITransactionContextEx __RPC_FAR * This,
    /* [in] */ REFCLSID cid,
    /* [in] */ REFIID rid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pObject);


void __RPC_STUB ITransactionContextEx_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionContextEx_Commit_Proxy( 
    ITransactionContextEx __RPC_FAR * This);


void __RPC_STUB ITransactionContextEx_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionContextEx_Abort_Proxy( 
    ITransactionContextEx __RPC_FAR * This);


void __RPC_STUB ITransactionContextEx_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionContextEx_INTERFACE_DEFINED__ */



#ifndef __TXCTXLib_LIBRARY_DEFINED__
#define __TXCTXLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: TXCTXLib
 * at Thu Jul 18 18:14:59 1996
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_TXCTXLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TransactionContext;

class TransactionContext;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TransactionContextEx;

class TransactionContextEx;
#endif
#endif /* __TXCTXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\utassert.h ===
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

(c)	1995	Microsoft Corporation.	All Rights Reserved

@doc

@module UTAssert.H.h  |

	This file contains some macros for asserts.

	Following are the Assert macros with a brief definition of them
	DeclAssertFile				Should be added at the begining of each .C/.CPP
	Assert(exp)					Simple Assert with an expression
	Verify(exp)					Assert whose exp has side effects and is
								 always evaluated, even !_DEBUG.
	ExpAssert(exp)				Same as Assert, just a more convenient name.
	AssertSz(exp, sz)			The assert will dump the sz passed to it
	AssertEq(exp, exp2)			Assert that exp == exp2
	AssertGe(exp, exp2)			Assert that exp >= exp2
	AssertNe(exp, exp2)			Assert that exp <= exp2

@devnote None

@rev	1 	| 6/28/95	  | MohsenA		| Commented out Windows.h for MFC 
										  compatibility
@rev 	0 	| 24th Jan,95 | GaganC 		| Created
*******************************************************************************/

#ifndef __UTAssert_H__
#define __UTAssert_H__

#include <stdio.h>
#include <windows.h>


#ifndef	_DEBUG

	#define DeclAssertFile
	#define Assert(exp)		((void)1)
#ifndef Verify
	#define Verify(exp)		(exp)
#endif
	#define ExpAssert(exp)		((void)1)
	#define AssertSz(exp, sz)	((void)1)
	#define AssertEq(exp, exp2)	(exp)
	#define AssertGe(exp, exp2)	(exp)
	#define AssertNe(exp, exp2)	(exp)

#else	//Debug

	#define DTCAssertNone	0x0000		/* None */
	#define DTCAssertExit	0x0001		/* Exit the application */
	#define DTCAssertBreak 	0x0002		/* Break to debugger */
	#define DTCAssertMsgBox	0x0004		/* Display message box */
	#define DTCAssertStop	0x0008		/* Alert and stop */
	#define DTCAssertStack	0x0010		/* Stack trace */
	#define DTCAssertLog	0x0020		/* Log assert to file only */

	#ifdef __cplusplus
	extern "C" {
	#endif

	void AssertSzFail(const char *sz, const char *szFilename, unsigned Line);
	void AssertFail(const char FAR *szFilename, unsigned Line);

	static WORD z_wAssertAction = DTCAssertNone; // default to None

	static const char szAssertFile[] = "assert.txt";
	static const char szAssertHdr[] = "Assertion Failure: ";
	static const char szMsgHdr[] = ": ";
	static const char szLineHdr[] = ", Line ";
	static const char szAssertEnd[] = "\r\n";
	static const char szAssertCaption[] = "Assertion Failure";
	
	#ifdef __cplusplus
	}
	#endif



	#define DeclAssertFile static const char szAssertFilename[] = __FILE__


	#define AssertSz(exp, sz) { \
			static char szMsg[] = sz; \
			(exp) ? (void) 0 : AssertSzFail(szMsg, szAssertFilename, __LINE__); \
		}

	#define Assert(exp) \
		( (exp) ? (void) 0 : AssertFail(szAssertFilename, __LINE__) )

#ifndef Verify
	#define Verify(exp)		Assert(exp)
#endif
		
	#define ExpAssert(exp)		Assert(exp)

	#define AssertEq(exp, exp2)	Assert((exp) == (exp2))
	#define AssertGe(exp, exp2)	Assert((exp) >= (exp2))
	#define AssertNe(exp, exp2)	Assert((exp) != (exp2))


#endif	//!def _DEBUG


#endif //__UTAssert_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\transact.h ===
//.-------------------------------------------------------------------------
//.
//.  Microsoft Windows
//.  Copyright (C) Microsoft Corporation, 1995.
//.
//.  File: transact.idl
//.
//.  Contents: The basic transaction interfaces and types.
//.
//.--------------------------------------------------------------------------


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri May 10 01:04:33 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __transact_h__
#define __transact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif 	/* __ITransaction_FWD_DEFINED__ */


#ifndef __ITransactionDispenser_FWD_DEFINED__
#define __ITransactionDispenser_FWD_DEFINED__
typedef interface ITransactionDispenser ITransactionDispenser;
#endif 	/* __ITransactionDispenser_FWD_DEFINED__ */


#ifndef __ITransactionOptions_FWD_DEFINED__
#define __ITransactionOptions_FWD_DEFINED__
typedef interface ITransactionOptions ITransactionOptions;
#endif 	/* __ITransactionOptions_FWD_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_FWD_DEFINED__
#define __ITransactionOutcomeEvents_FWD_DEFINED__
typedef interface ITransactionOutcomeEvents ITransactionOutcomeEvents;
#endif 	/* __ITransactionOutcomeEvents_FWD_DEFINED__ */


#ifndef __ITransactionCompletionEvents_FWD_DEFINED__
#define __ITransactionCompletionEvents_FWD_DEFINED__
typedef interface ITransactionCompletionEvents ITransactionCompletionEvents;
#endif 	/* __ITransactionCompletionEvents_FWD_DEFINED__ */


/* header files for imported files */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __BasicTransactionTypes_INTERFACE_DEFINED__
#define __BasicTransactionTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: BasicTransactionTypes
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][local] */ 


			/* size is 16 */
typedef struct  BOID
    {
    BYTE rgb[ 16 ];
    }	BOID;

#define BOID_NULL (*((BOID*)(&IID_NULL)))

#define MAX_TRAN_DESC 40		// used by XACTOPT via midl - see transact.idl 
			/* size is 16 */
typedef BOID XACTUOW;

			/* size is 4 */
typedef LONG ISOLEVEL;

#if defined(_WIN32)
			/* size is 2 */
typedef 
enum ISOLATIONLEVEL
    {	ISOLATIONLEVEL_UNSPECIFIED	= 0xffffffff,
	ISOLATIONLEVEL_CHAOS	= 0x10,
	ISOLATIONLEVEL_READUNCOMMITTED	= 0x100,
	ISOLATIONLEVEL_BROWSE	= 0x100,
	ISOLATIONLEVEL_CURSORSTABILITY	= 0x1000,
	ISOLATIONLEVEL_READCOMMITTED	= 0x1000,
	ISOLATIONLEVEL_REPEATABLEREAD	= 0x10000,
	ISOLATIONLEVEL_SERIALIZABLE	= 0x100000,
	ISOLATIONLEVEL_ISOLATED	= 0x100000
    }	ISOLATIONLEVEL;

#else
#define ISOLATIONLEVEL_UNSPECIFIED      0xFFFFFFFF
#define ISOLATIONLEVEL_CHAOS            0x00000010
#define ISOLATIONLEVEL_READUNCOMMITTED  0x00000100
#define ISOLATIONLEVEL_BROWSE           0x00000100
#define ISOLATIONLEVEL_CURSORSTABILITY  0x00001000
#define ISOLATIONLEVEL_READCOMMITTED    0x00001000
#define ISOLATIONLEVEL_REPEATABLEREAD   0x00010000
#define ISOLATIONLEVEL_SERIALIZABLE     0x00100000
#define ISOLATIONLEVEL_ISOLATED         0x00100000
#endif
			/* size is 40 */
typedef struct  XACTTRANSINFO
    {
    XACTUOW uow;
    ISOLEVEL isoLevel;
    ULONG isoFlags;
    DWORD grfTCSupported;
    DWORD grfRMSupported;
    DWORD grfTCSupportedRetaining;
    DWORD grfRMSupportedRetaining;
    }	XACTTRANSINFO;

			/* size is 36 */
typedef struct  XACTSTATS
    {
    ULONG cOpen;
    ULONG cCommitting;
    ULONG cCommitted;
    ULONG cAborting;
    ULONG cAborted;
    ULONG cInDoubt;
    ULONG cHeuristicDecision;
    FILETIME timeTransactionsUp;
    }	XACTSTATS;

			/* size is 2 */
typedef 
enum ISOFLAG
    {	ISOFLAG_RETAIN_COMMIT_DC	= 1,
	ISOFLAG_RETAIN_COMMIT	= 2,
	ISOFLAG_RETAIN_COMMIT_NO	= 3,
	ISOFLAG_RETAIN_ABORT_DC	= 4,
	ISOFLAG_RETAIN_ABORT	= 8,
	ISOFLAG_RETAIN_ABORT_NO	= 12,
	ISOFLAG_RETAIN_DONTCARE	= ISOFLAG_RETAIN_COMMIT_DC | ISOFLAG_RETAIN_ABORT_DC,
	ISOFLAG_RETAIN_BOTH	= ISOFLAG_RETAIN_COMMIT | ISOFLAG_RETAIN_ABORT,
	ISOFLAG_RETAIN_NONE	= ISOFLAG_RETAIN_COMMIT_NO | ISOFLAG_RETAIN_ABORT_NO,
	ISOFLAG_OPTIMISTIC	= 16,
	ISOFLAG_READONLY	= 32
    }	ISOFLAG;

			/* size is 2 */
typedef 
enum XACTTC
    {	XACTTC_SYNC_PHASEONE	= 1,
	XACTTC_SYNC_PHASETWO	= 2,
	XACTTC_SYNC	= 2,
	XACTTC_ASYNC_PHASEONE	= 4,
	XACTTC_ASYNC	= 4
    }	XACTTC;

			/* size is 2 */
typedef 
enum XACTRM
    {	XACTRM_OPTIMISTICLASTWINS	= 1,
	XACTRM_NOREADONLYPREPARES	= 2
    }	XACTRM;

			/* size is 2 */
typedef 
enum XACTCONST
    {	XACTCONST_TIMEOUTINFINITE	= 0
    }	XACTCONST;

			/* size is 2 */
typedef 
enum XACTHEURISTIC
    {	XACTHEURISTIC_ABORT	= 1,
	XACTHEURISTIC_COMMIT	= 2,
	XACTHEURISTIC_DAMAGE	= 3,
	XACTHEURISTIC_DANGER	= 4
    }	XACTHEURISTIC;

#if defined(_WIN32)
			/* size is 2 */
typedef 
enum XACTSTAT
    {	XACTSTAT_NONE	= 0,
	XACTSTAT_OPENNORMAL	= 0x1,
	XACTSTAT_OPENREFUSED	= 0x2,
	XACTSTAT_PREPARING	= 0x4,
	XACTSTAT_PREPARED	= 0x8,
	XACTSTAT_PREPARERETAINING	= 0x10,
	XACTSTAT_PREPARERETAINED	= 0x20,
	XACTSTAT_COMMITTING	= 0x40,
	XACTSTAT_COMMITRETAINING	= 0x80,
	XACTSTAT_ABORTING	= 0x100,
	XACTSTAT_ABORTED	= 0x200,
	XACTSTAT_COMMITTED	= 0x400,
	XACTSTAT_HEURISTIC_ABORT	= 0x800,
	XACTSTAT_HEURISTIC_COMMIT	= 0x1000,
	XACTSTAT_HEURISTIC_DAMAGE	= 0x2000,
	XACTSTAT_HEURISTIC_DANGER	= 0x4000,
	XACTSTAT_FORCED_ABORT	= 0x8000,
	XACTSTAT_FORCED_COMMIT	= 0x10000,
	XACTSTAT_INDOUBT	= 0x20000,
	XACTSTAT_CLOSED	= 0x40000,
	XACTSTAT_OPEN	= 0x3,
	XACTSTAT_NOTPREPARED	= 0x7ffc3,
	XACTSTAT_ALL	= 0x7ffff
    }	XACTSTAT;

#else
#define XACTSTAT_NONE               0x00000000
#define XACTSTAT_OPENNORMAL         0x00000001
#define XACTSTAT_OPENREFUSED        0x00000002
#define XACTSTAT_PREPARING          0x00000004
#define XACTSTAT_PREPARED           0x00000008
#define XACTSTAT_PREPARERETAINING   0x00000010
#define XACTSTAT_PREPARERETAINED    0x00000020
#define XACTSTAT_COMMITTING         0x00000040
#define XACTSTAT_COMMITRETAINING    0x00000080
#define XACTSTAT_ABORTING           0x00000100
#define XACTSTAT_ABORTED            0x00000200
#define XACTSTAT_COMMITTED          0x00000400
#define XACTSTAT_HEURISTIC_ABORT    0x00000800
#define XACTSTAT_HEURISTIC_COMMIT   0x00001000
#define XACTSTAT_HEURISTIC_DAMAGE   0x00002000
#define XACTSTAT_HEURISTIC_DANGER   0x00004000
#define XACTSTAT_FORCED_ABORT       0x00008000
#define XACTSTAT_FORCED_COMMIT      0x00010000
#define XACTSTAT_INDOUBT            0x00020000
#define XACTSTAT_CLOSED             0x00040000
#define XACTSTAT_OPEN               0x00000003
#define XACTSTAT_NOTPREPARED        0x0007FFC3
#define XACTSTAT_ALL                0x0007FFFF
#endif
			/* size is 44 */
typedef struct  XACTOPT
    {
    ULONG ulTimeout;
    unsigned char szDescription[ 40 ];
    }	XACTOPT;



extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_s_ifspec;
#endif /* __BasicTransactionTypes_INTERFACE_DEFINED__ */

#ifndef __ITransaction_INTERFACE_DEFINED__
#define __ITransaction_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransaction
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransaction : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT __stdcall Abort( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT __stdcall GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransaction __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransaction __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Commit )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( __stdcall __RPC_FAR *Abort )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( __stdcall __RPC_FAR *GetTransactionInfo )( 
            ITransaction __RPC_FAR * This,
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);
        
    } ITransactionVtbl;

    interface ITransaction
    {
        CONST_VTBL struct ITransactionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransaction_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define ITransaction_Abort(This,pboidReason,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,pboidReason,fRetaining,fAsync)

#define ITransaction_GetTransactionInfo(This,pinfo)	\
    (This)->lpVtbl -> GetTransactionInfo(This,pinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransaction_Commit_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfTC,
    /* [in] */ DWORD grfRM);


void __RPC_STUB ITransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransaction_Abort_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ BOOL fAsync);


void __RPC_STUB ITransaction_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransaction_GetTransactionInfo_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);


void __RPC_STUB ITransaction_GetTransactionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransaction_INTERFACE_DEFINED__ */


#ifndef __ITransactionDispenser_INTERFACE_DEFINED__
#define __ITransactionDispenser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionDispenser
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionDispenser : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetOptionsObject( 
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions) = 0;
        
        virtual HRESULT __stdcall BeginTransaction( 
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionDispenserVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionDispenser __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionDispenser __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetOptionsObject )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);
        
        HRESULT ( __stdcall __RPC_FAR *BeginTransaction )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);
        
    } ITransactionDispenserVtbl;

    interface ITransactionDispenser
    {
        CONST_VTBL struct ITransactionDispenserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionDispenser_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionDispenser_BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionDispenser_GetOptionsObject_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);


void __RPC_STUB ITransactionDispenser_GetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionDispenser_BeginTransaction_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
    /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);


void __RPC_STUB ITransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __ITransactionOptions_INTERFACE_DEFINED__
#define __ITransactionOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOptions
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionOptions : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetOptions( 
            /* [in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
        virtual HRESULT __stdcall GetOptions( 
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOptionsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionOptions __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionOptions __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ XACTOPT __RPC_FAR *pOptions);
        
        HRESULT ( __stdcall __RPC_FAR *GetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions);
        
    } ITransactionOptionsVtbl;

    interface ITransactionOptions
    {
        CONST_VTBL struct ITransactionOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOptions_SetOptions(This,pOptions)	\
    (This)->lpVtbl -> SetOptions(This,pOptions)

#define ITransactionOptions_GetOptions(This,pOptions)	\
    (This)->lpVtbl -> GetOptions(This,pOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionOptions_SetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOptions_GetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [out][in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOptions_INTERFACE_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_INTERFACE_DEFINED__
#define __ITransactionOutcomeEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOutcomeEvents
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOutcomeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionOutcomeEvents : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOutcomeEventsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Committed )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Aborted )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *HeuristicDecision )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Indoubt )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
    } ITransactionOutcomeEventsVtbl;

    interface ITransactionOutcomeEvents
    {
        CONST_VTBL struct ITransactionOutcomeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOutcomeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOutcomeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOutcomeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOutcomeEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionOutcomeEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionOutcomeEvents_Committed_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_Aborted_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_HeuristicDecision_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_Indoubt_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This);


void __RPC_STUB ITransactionOutcomeEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOutcomeEvents_INTERFACE_DEFINED__ */


#ifndef __ITransactionCompletionEvents_INTERFACE_DEFINED__
#define __ITransactionCompletionEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionCompletionEvents
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionCompletionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionCompletionEvents : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionCompletionEventsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Committed )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Aborted )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *HeuristicDecision )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Indoubt )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
    } ITransactionCompletionEventsVtbl;

    interface ITransactionCompletionEvents
    {
        CONST_VTBL struct ITransactionCompletionEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionCompletionEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionCompletionEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionCompletionEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionCompletionEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionCompletionEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionCompletionEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionCompletionEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionCompletionEvents_Committed_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_Aborted_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_HeuristicDecision_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_Indoubt_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This);


void __RPC_STUB ITransactionCompletionEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionCompletionEvents_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0011
 * at Fri May 10 01:04:33 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#define XACT_E_FIRST						0x8004D000
#define XACT_E_LAST						0x8004D01E
#define XACT_S_FIRST						0x0004D000
#define XACT_S_LAST						0x0004D009

#define XACT_E_ALREADYOTHERSINGLEPHASE	0x8004D000
#define XACT_E_CANTRETAIN				0x8004D001
#define XACT_E_COMMITFAILED				0x8004D002
#define XACT_E_COMMITPREVENTED			0x8004D003
#define XACT_E_HEURISTICABORT			0x8004D004
#define XACT_E_HEURISTICCOMMIT			0x8004D005
#define XACT_E_HEURISTICDAMAGE			0x8004D006
#define XACT_E_HEURISTICDANGER			0x8004D007
#define XACT_E_ISOLATIONLEVEL			0x8004D008
#define XACT_E_NOASYNC					0x8004D009
#define XACT_E_NOENLIST					0x8004D00A
#define XACT_E_NOISORETAIN				0x8004D00B
#define XACT_E_NORESOURCE				0x8004D00C
#define XACT_E_NOTCURRENT				0x8004D00D
#define XACT_E_NOTRANSACTION				0x8004D00E
#define XACT_E_NOTSUPPORTED				0x8004D00F
#define XACT_E_UNKNOWNRMGRID				0x8004D010
#define XACT_E_WRONGSTATE				0x8004D011
#define XACT_E_WRONGUOW					0x8004D012
#define XACT_E_XTIONEXISTS				0x8004D013
#define XACT_E_NOIMPORTOBJECT			0x8004D014
#define XACT_E_INVALIDCOOKIE				0x8004D015
#define XACT_E_INDOUBT					0x8004D016
#define XACT_E_NOTIMEOUT					0x8004D017
#define XACT_E_ALREADYINPROGRESS			0x8004D018
#define XACT_E_ABORTED					0x8004D019
#define XACT_E_LOGFULL					0x8004D01A
#define XACT_E_TMNOTAVAILABLE			0x8004D01B
#define XACT_E_CONNECTION_DOWN			0x8004D01C
#define XACT_E_CONNECTION_DENIED			0x8004D01D
#define XACT_E_REENLISTTIMEOUT			0x8004D01E

#define XACT_S_ASYNC                    0x0004D000
#define XACT_S_DEFECT                   0x0004D001
#define XACT_S_READONLY                 0x0004D002
#define XACT_S_SOMENORETAIN             0x0004D003
#define XACT_S_OKINFORM                 0x0004D004
#define XACT_S_MADECHANGESCONTENT       0x0004D005
#define XACT_S_MADECHANGESINFORM        0x0004D006
#define XACT_S_ALLNORETAIN              0x0004D007
#define XACT_S_ABORTING                 0x0004D008
#define XACT_S_SINGLEPHASE              0x0004D009


extern RPC_IF_HANDLE __MIDL__intf_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

///////////////////////////////////////////////////////////////////////
//
// IID definitions for interfaces defined in this header file
//

#if !defined(_transact_iid_) && defined(INITGUID)
#define      _transact_iid_
const IID IID_ITransaction = {0x0fb15084,0xaf41,0x11ce,{0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20}};
const IID IID_ITransactionDispenser = {0x3A6AD9E1,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionOptions = {0x3A6AD9E0,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionOutcomeEvents = {0x3A6AD9E2,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionCompletionEvents = {0xB38D5220,0x23CE,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
#endif

///////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\vipapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 18 17:58:34 1996
 */
/* Compiler settings for .\viper.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, app_config, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vipapi_h__
#define __vipapi_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IObjectContext_FWD_DEFINED__
#define __IObjectContext_FWD_DEFINED__
typedef interface IObjectContext IObjectContext;
#endif 	/* __IObjectContext_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Jul 18 17:58:34 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#include <objbase.h>
#define VIPER_E_STACK_OVERFLOW			0x8004E001
#define VIPER_E_ABORTED					0x8004E002
#define VIPER_E_ABORTING					0x8004E003
#define VIPER_E_NOCONTEXT				0x8004E004
#define VIPER_E_NOTREGISTERED			0x8004E005
#define VIPER_E_EXCEPTION				0x8004E006
#define VIPER_E_OLDREF					0x8004E007
#define VIPER_E_MARSHAL					0x8004E008
#define VIPER_E_IMPROPER_USE				0x8004E009
#define VIPER_E_INTERFACE_TOO_LARGE		0x8004E00A
#define VIPER_E_LICENSE_EXPIRED			0x8004E00B


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IObjectContext_INTERFACE_DEFINED__
#define __IObjectContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectContext
 * at Thu Jul 18 17:58:34 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IObjectContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IObjectContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            REFCLSID rclsid,
            REFIID riid,
            LPVOID __RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableCommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableCommit( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsInTransaction( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            IObjectContext __RPC_FAR * This,
            REFCLSID rclsid,
            REFIID riid,
            LPVOID __RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComplete )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAbort )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableCommit )( 
            IObjectContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableCommit )( 
            IObjectContext __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsInTransaction )( 
            IObjectContext __RPC_FAR * This);
        
        END_INTERFACE
    } IObjectContextVtbl;

    interface IObjectContext
    {
        CONST_VTBL struct IObjectContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectContext_CreateInstance(This,rclsid,riid,ppv)	\
    (This)->lpVtbl -> CreateInstance(This,rclsid,riid,ppv)

#define IObjectContext_SetComplete(This)	\
    (This)->lpVtbl -> SetComplete(This)

#define IObjectContext_SetAbort(This)	\
    (This)->lpVtbl -> SetAbort(This)

#define IObjectContext_EnableCommit(This)	\
    (This)->lpVtbl -> EnableCommit(This)

#define IObjectContext_DisableCommit(This)	\
    (This)->lpVtbl -> DisableCommit(This)

#define IObjectContext_IsInTransaction(This)	\
    (This)->lpVtbl -> IsInTransaction(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectContext_CreateInstance_Proxy( 
    IObjectContext __RPC_FAR * This,
    REFCLSID rclsid,
    REFIID riid,
    LPVOID __RPC_FAR *ppv);


void __RPC_STUB IObjectContext_CreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_SetComplete_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_SetComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_SetAbort_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_SetAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_EnableCommit_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_EnableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContext_DisableCommit_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_DisableCommit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IObjectContext_IsInTransaction_Proxy( 
    IObjectContext __RPC_FAR * This);


void __RPC_STUB IObjectContext_IsInTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectContext_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Thu Jul 18 17:58:34 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


extern "C" {
extern HRESULT GetObjectContext (IObjectContext** ppInstanceContext);
};


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\txctx_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 18 18:14:59 1996
 */
/* Compiler settings for txctx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ITransactionContext = {0x7999FC21,0xD3C6,0x11CF,{0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF}};


const IID IID_ITransactionContextEx = {0x7999FC22,0xD3C6,0x11CF,{0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF}};


const IID LIBID_TXCTXLib = {0x7999FC20,0xD3C6,0x11CF,{0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF}};


const CLSID CLSID_TransactionContext = {0x7999FC25,0xD3C6,0x11CF,{0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF}};


const CLSID CLSID_TransactionContextEx = {0x5cb66670,0xd3d4,0x11cf,{0xac,0xab,0x00,0xa0,0x24,0xa5,0x5a,0xef}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\client\w3svci_c_stub.c ===
#include "w3svci_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\client\w3bind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    w3bind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the W3 Daemon
    service.

Author:

    Dan Hinsley (DanHi) 23-Mar-1993

Environment:

    User Mode -Win32

Revision History:
    MuraliK  15-Nov-1995   converted to get rid of net lib functions.
    MuraliK  21-Dec-1995   Support for TCP/IP binding.

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <w3svci_c.h>
#include "apiutil.h"


handle_t
W3_IMPERSONATE_HANDLE_bind(
    W3_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the W3 Daemon client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;


    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       W3_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindHandle;
}



handle_t
W3_IDENTIFY_HANDLE_bind(
    W3_IDENTIFY_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the W3 Daemon client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       W3_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindHandle;
}



void
W3_IMPERSONATE_HANDLE_unbind(
    W3_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the W3 Daemon client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID) RpcBindHandleFree(&BindHandle);

    return;
}



void
W3_IDENTIFY_HANDLE_unbind(
    W3_IDENTIFY_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the W3 Daemon client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID) RpcBindHandleFree(BindHandle);

    return;
}


/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\cisa\vipinc\vipattr.h ===
#ifndef _VIPATTR_H_
#define _VIPATTR_H_

//****************************************************************************************
// IDL Include for Viper custom attributes 
// See VipAttrG.h for corresponding DEFINE_GUID's
//****************************************************************************************

//======================================================================================
// Component attributes
//======================================================================================
#define		TLBATTR_COMPCLSID		17093CC1-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_PROGID			17093CC2-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_DEFCREATE		17093CC3-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_INSTSTREAM		17093CC4-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_TRANS_REQUIRED	17093CC5-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_TRANS_NOTSUPP	17093CC6-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_TRANS_REQNEW	17093CC7-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_TRANS_SUPPORTED	17093CC8-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_DESC			17093CC9-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_THREAD_NONE		17093CCC-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_THREAD_APT		17093CCD-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_THREAD_BOTH		17093CCE-9BD2-11cf-AA4F-304BF89C0001
#define		TLBATTR_THREAD_FREE		17093CCF-9BD2-11cf-AA4F-304BF89C0001

//======================================================================================
// Component attribute MACROS
//======================================================================================

#define TRANSACTION_REQUIRED		custom(TLBATTR_TRANS_REQUIRED,0)
#define TRANSACTION_SUPPORTED		custom(TLBATTR_TRANS_SUPPORTED,0)
#define TRANSACTION_NOT_SUPPORTED	custom(TLBATTR_TRANS_NOTSUPP,0)
#define TRANSACTION_REQUIRES_NEW	custom(TLBATTR_TRANS_REQNEW,0)

//======================================================================================
// Interface attributes
//======================================================================================
#define		TLBATTR_STATICQI		17093CCA-9BD2-11cf-AA4F-304BF89C0001

//======================================================================================
// Interface attribute MACROS
//======================================================================================
#define STATIC_QUERY_INTERFACE		custom(TLBATTR_STATICQI,0)

//======================================================================================
// Method attributes
//======================================================================================
#define		TLBATTR_LAZY			17093CCB-9BD2-11cf-AA4F-304BF89C0001

//======================================================================================
// Method attribute MACROS
//======================================================================================
#define LAZY						custom(TLBATTR_LAZY,0)


#endif _VIPATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\debug\help.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    help.c
    This module implements the "help" command of the W3 Server debugger
    extension DLL.


    FILE HISTORY:
        KeithMo     18-May-1993 Created.

*/

#include "w3dbg.h"


/*******************************************************************

    NAME:       help

    SYNOPSIS:   Implements the "help" command.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    HISTORY:
        KeithMo     18-May-1993 Created.

********************************************************************/
VOID help( HANDLE hCurrentProcess,
           HANDLE hCurrentThread,
           DWORD  dwCurrentPc,
           LPVOID lpExtensionApis,
           LPSTR  lpArgumentString )
{
    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Show the help.
    //

    DebugPrint( "W3 Server Debugger Extensions:\n" );
    DebugPrint( "  help           - Show this help\n" );
    DebugPrint( "  user           - Dump user info\n" );
    DebugPrint( "  stats          - Dump statistics\n" );

    return;

}   // help
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\client\w3stub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    w3stub.c

Abstract:

    Client stubs of the W3 Daemon APIs.

Author:

    Dan Hinsley (DanHi) 23-Mar-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "w3svci_c.h" // W3_USER_ENUM_STRUCT

#include "w3svc.h"
#include <winsock2.h>

#include <ntsam.h>
#include <ntlsa.h>

DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    );

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    );

NET_API_STATUS
NET_API_FUNCTION
W3GetAdminInformation(
    IN  LPWSTR             Server OPTIONAL,
    OUT LPW3_CONFIG_INFO * ppConfig
    )
{
    NET_API_STATUS status;
    LPWSTR         pSecret;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = W3rGetAdminInformation(
                     Server,
                     ppConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status )
        return status;

    memset( (*ppConfig)->szCatapultUserPwd,
            0,
            sizeof( (*ppConfig)->szCatapultUserPwd ));

    return (status);
}

NET_API_STATUS
NET_API_FUNCTION
W3SetAdminInformation(
    IN  LPWSTR             Server OPTIONAL,
    IN  LPW3_CONFIG_INFO   pConfig
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = W3rSetAdminInformation(
                     Server,
                     pConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status )
        return status;

    return (status);
}



NET_API_STATUS
NET_API_FUNCTION
W3EnumerateUsers(
    IN LPWSTR   Server OPTIONAL,
    OUT LPDWORD  EntriesRead,
    OUT LPW3_USER_INFO * Buffer
    )
{
    NET_API_STATUS status;
    W3_USER_ENUM_STRUCT EnumStruct;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = W3rEnumerateUsers(
                     Server,
                     &EnumStruct
                     );
        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = EnumStruct.Buffer;

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
NET_API_FUNCTION
W3DisconnectUser(
    IN LPWSTR  Server OPTIONAL,
    IN DWORD   User
    )

{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = W3rDisconnectUser(
                     Server,
                     User
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics(
    IN LPWSTR Server OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    )
{
    NET_API_STATUS status;

    *Buffer = NULL;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = W3rQueryStatistics(
                     Server,
                     Level,
                     (LPSTATISTICS_INFO)Buffer
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics(
    IN LPWSTR Server OPTIONAL
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = W3rClearStatistics(
                     Server
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}

DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    )
/*++

   Description

     Gets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     ppSecret - Receives an allocated block of memory containing the secret.
        Must be freed with LocalFree.

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING *  punicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE        hSecret;
    UNICODE_STRING    unicodeSecret;


    RtlInitUnicodeString( &unicodeServer,
                          Server );

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return RtlNtStatusToDosError( ntStatus );

    //
    //  Open the LSA secret
    //

    RtlInitUnicodeString( &unicodeSecret,
                          SecretName );

    ntStatus = LsaOpenSecret( hPolicy,
                              &unicodeSecret,
                              SECRET_ALL_ACCESS,
                              &hSecret );

    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
        return RtlNtStatusToDosError( ntStatus );

    //
    //  Query the secret value
    //

    ntStatus = LsaQuerySecret( hSecret,
                               &punicodePassword,
                               NULL,
                               NULL,
                               NULL );

    LsaClose( hSecret );

    if ( !NT_SUCCESS( ntStatus ))
        return RtlNtStatusToDosError( ntStatus );

    *ppSecret = LocalAlloc( LPTR, punicodePassword->Length + sizeof(WCHAR) );

    if ( !*ppSecret )
    {
        RtlZeroMemory( punicodePassword->Buffer,
                       punicodePassword->MaximumLength );

        LsaFreeMemory( (PVOID) punicodePassword );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Copy it into the buffer, Length is count of bytes
    //

    memcpy( *ppSecret,
            punicodePassword->Buffer,
            punicodePassword->Length );

    (*ppSecret)[punicodePassword->Length/sizeof(WCHAR)] = L'\0';

    RtlZeroMemory( punicodePassword->Buffer,
                   punicodePassword->MaximumLength );
    LsaFreeMemory( (PVOID) punicodePassword );

    return NO_ERROR;
}

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
/*++

   Description

     Sets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING    unicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE        hSecret;
    UNICODE_STRING    unicodeSecret;


    RtlInitUnicodeString( &unicodeServer,
                          Server );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    unicodePassword.Buffer        = pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return RtlNtStatusToDosError( ntStatus );

    //
    //  Create or open the LSA secret
    //

    RtlInitUnicodeString( &unicodeSecret,
                          SecretName );

    ntStatus = LsaCreateSecret( hPolicy,
                                &unicodeSecret,
                                SECRET_ALL_ACCESS,
                                &hSecret );

    if ( !NT_SUCCESS( ntStatus ))
    {

        //
        //  If the secret already exists, then we just need to open it
        //

        if ( ntStatus == STATUS_OBJECT_NAME_COLLISION )
        {
            ntStatus = LsaOpenSecret( hPolicy,
                                      &unicodeSecret,
                                      SECRET_ALL_ACCESS,
                                      &hSecret );
        }

        if ( !NT_SUCCESS( ntStatus ))
        {
            LsaClose( hPolicy );
            return RtlNtStatusToDosError( ntStatus );
        }
    }

    //
    //  Set the secret value
    //

    ntStatus = LsaSetSecret( hSecret,
                             &unicodePassword,
                             &unicodePassword );

    LsaClose( hSecret );
    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
    {
        return RtlNtStatusToDosError( ntStatus );
    }

    return NO_ERROR;
}





































=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\debug\stats.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stats.c
    This module implements the "stats" command of the W3 Server
    debugger extension DLL.


    FILE HISTORY:
        KeithMo     13-Jun-1993 Created.

*/


#include "w3dbg.h"
#include <time.h>


/*******************************************************************

    NAME:       stats

    SYNOPSIS:   Displays the server statistics.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    HISTORY:
        KeithMo     13-Jun-1993 Created.

********************************************************************/
VOID stats( HANDLE hCurrentProcess,
            HANDLE hCurrentThread,
            DWORD  dwCurrentPc,
            LPVOID lpExtensionApis,
            LPSTR  lpArgumentString )
{
    W3_STATISTICS_0 W3Stats;
    CHAR             szLargeInt[64];
    LPVOID           pstats;

    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Capture the statistics.
    //

    pstats = (LPVOID)DebugEval( "W3Stats" );

    if( pstats == NULL )
    {
        DebugPrint( "cannot locate W3Stats\n" );
        return;
    }

    ReadProcessMemory( hCurrentProcess,
                       pstats,
                       (LPVOID)&W3Stats,
                       sizeof(W3Stats),
                       (LPDWORD)NULL );

    //
    //  Dump the statistics.
    //

    RtlLargeIntegerToChar( &W3Stats.TotalBytesSent,
                           10,
                           sizeof(szLargeInt),
                           szLargeInt );

    DebugPrint( "TotalBytesSent           = %s\n",
                szLargeInt                       );

    RtlLargeIntegerToChar( &W3Stats.TotalBytesReceived,
                           10,
                           sizeof(szLargeInt),
                           szLargeInt );

    DebugPrint( "TotalBytesReceived       = %s\n",
                szLargeInt                       );

    DebugPrint( "TotalFilesSent           = %lu\n",
                W3Stats.TotalFilesSent           );

    DebugPrint( "TotalFilesReceived       = %lu\n",
                W3Stats.TotalFilesReceived       );

    DebugPrint( "CurrentAnonymousUsers    = %lu\n",
                W3Stats.CurrentAnonymousUsers    );

    DebugPrint( "CurrentNonAnonymousUsers = %lu\n",
                W3Stats.CurrentNonAnonymousUsers );

    DebugPrint( "TotalAnonymousUsers      = %lu\n",
                W3Stats.TotalAnonymousUsers      );

    DebugPrint( "TotalNonAnonymousUsers   = %lu\n",
                W3Stats.TotalNonAnonymousUsers   );

    DebugPrint( "MaxAnonymousUsers        = %lu\n",
                W3Stats.MaxAnonymousUsers        );

    DebugPrint( "MaxNonAnonymousUsers     = %lu\n",
                W3Stats.MaxNonAnonymousUsers     );

    DebugPrint( "CurrentConnections       = %lu\n",
                W3Stats.CurrentConnections       );

    DebugPrint( "MaxConnections           = %lu\n",
                W3Stats.MaxConnections           );

    DebugPrint( "ConnectionAttempts       = %lu\n",
                W3Stats.ConnectionAttempts       );

    DebugPrint( "LogonAttempts            = %lu\n",
                W3Stats.LogonAttempts            );

    DebugPrint( "TimeOfLastClear          = %s\n",
                asctime( localtime( (time_t *)&W3Stats.TimeOfLastClear ) ) );

}   // stats
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\debug\user.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    user.c
    This module implements the "user" command of the W3 Server
    debugger extension DLL.

    The "user" command dumps the info pertaining to a specific user.
    There is one parameter to this command.  If this parameter is
    positive, it is assumed to be the address of a USER_DATA structure
    for a specific user.  If the parameter is negative, its absolute
    value is assumed to be a user ID.  If no parameter is given, info
    for all connected users is dumped.


    FILE HISTORY:
        KeithMo     13-Aug-1992 Created.

*/


#include "w3dbg.h"


//
//  Private prototypes.
//

VOID DumpUserInfo( HANDLE      hCurrentProcess,
                   USER_DATA * puser );

CHAR * InterpretState( USER_STATE state );

CHAR * InterpretXferType( XFER_TYPE xferType );

CHAR * InterpretXferMode( XFER_MODE xferMode );

VOID InterpretFlags( DWORD dwFlags );



/*******************************************************************

    NAME:       user

    SYNOPSIS:   Displays the info for a specific user.

    ENTRY:      hCurrentProcess         - Handle to the current process.

                hCurrentThread          - Handle to the current thread.

                dwCurrentPc             - The current program counter
                                          (EIP for x86, FIR for MIPS).

                lpExtensionApis         - Points to a structure containing
                                          pointers to the debugger functions
                                          that the command may invoke.

                lpArgumentString        - Points to any arguments passed
                                          to the command.

    NOTES:      The argument string must contain either the address of
                a USER_DATA structure (if positive) or a user ID (if
                negative).

    HISTORY:
        KeithMo     13-Aug-1992 Created.

********************************************************************/
VOID user( HANDLE hCurrentProcess,
           HANDLE hCurrentThread,
           DWORD  dwCurrentPc,
           LPVOID lpExtensionApis,
           LPSTR  lpArgumentString )
{
    LONG         lParam;
    USER_DATA    user;

    //
    //  Grab the debugger entrypoints.
    //

    GrabDebugApis( lpExtensionApis );

    //
    //  Evaluate the parameter (if present).
    //

    if( ( lpArgumentString == NULL ) || ( *lpArgumentString == '\0' ) )
    {
        lParam = 0;
    }
    else
    {
        lParam = (LONG)DebugEval( lpArgumentString );
    }

    //
    //  Interpret the parameter.
    //

    if( lParam > 0 )
    {
        //
        //  User specified an address.  Dump the user info
        //  at that address.
        //

        ReadProcessMemory( hCurrentProcess,
                           (LPVOID)lParam,
                           (LPVOID)&user,
                           sizeof(user),
                           (LPDWORD)NULL );

        DumpUserInfo( hCurrentProcess, &user );
    }
    else
    {
        //
        //  User specified either nothing (0) or a user ID (< 0).
        //

        LIST_ENTRY   list;
        LIST_ENTRY * plist;
        LIST_ENTRY * plistHead;

        lParam = -lParam;

        plistHead = (LIST_ENTRY *)DebugEval( "listUserData" );

        ReadProcessMemory( hCurrentProcess,
                           (LPVOID)plistHead,
                           (LPVOID)&list,
                           sizeof(list),
                           (LPDWORD)NULL );

        plist = list.Flink;

        while( plist != plistHead )
        {
            ReadProcessMemory( hCurrentProcess,
                               (LPVOID)CONTAINING_RECORD( plist,
                                                          USER_DATA,
                                                          link ),
                               (LPVOID)&user,
                               sizeof(user),
                               (LPDWORD)NULL );

            if( ( lParam == 0 ) || ( user.idUser == (DWORD)lParam ) )
            {
                DumpUserInfo( hCurrentProcess, &user );

                if( lParam != 0 )
                {
                    break;
                }
            }

            plist = user.link.Flink;

            //
            //  Check for CTRL-C, to let the user bag-out early.
            //

            if( DebugCheckCtrlC() )
            {
                break;
            }
        }

        if( ( lParam != 0 ) && ( plist == plistHead ) )
        {
            DebugPrint( "user ID %ld not found\n", lParam );
        }
    }

}   // user


VOID DumpUserInfo( HANDLE      hCurrentProcess,
                   USER_DATA * puser )
{
    char szDir[MAX_PATH];
    int  i;

    DebugPrint( "user @ %08lX:\n", puser );
    DebugPrint( "    link.Flink = %08lX\n", puser->link.Flink );
    DebugPrint( "    link.Blink = %08lX\n", puser->link.Blink );
    DebugPrint( "    dwFlags    = %08lX\n", puser->dwFlags );
    InterpretFlags( puser->dwFlags );
    DebugPrint( "    sControl   = %d\n",    puser->sControl );
    DebugPrint( "    sData      = %d\n",    puser->sData );
    DebugPrint( "    hToken     = %08lX\n", puser->hToken );
    DebugPrint( "    state      = %s\n",    InterpretState( puser->state ) );
    DebugPrint( "    idUser     = %lu\n",   puser->idUser );
    DebugPrint( "    tConnect   = %08lX\n", puser->tConnect );
    DebugPrint( "    tAccess    = %08lX\n", puser->tAccess );
    DebugPrint( "    xferType   = %s\n",    InterpretXferType( puser->xferType ) );
    DebugPrint( "    xferMode   = %s\n",    InterpretXferMode( puser->xferMode ) );
    DebugPrint( "    inetLocal  = %s\n",    inet_ntoa( puser->inetLocal ) );
    DebugPrint( "    inetHost   = %s\n",    inet_ntoa( puser->inetHost ) );
    DebugPrint( "    inetData   = %s\n",    inet_ntoa( puser->inetData ) );
    DebugPrint( "    portData   = %u\n",    puser->portData );
    DebugPrint( "    hDir       = %08lX\n", puser->hDir );
    DebugPrint( "    pIoBuffer  = %08lX\n", puser->pIoBuffer );
    DebugPrint( "    pszRename  = %s\n",    puser->pszRename );
    for( i = 0 ; i < 26 ; i++ )
    {
        if( puser->apszDirs[i] != NULL )
        {
            ReadProcessMemory( hCurrentProcess,
                               puser->apszDirs[i],
                               szDir,
                               sizeof(szDir),
                               (LPDWORD)NULL );

            DebugPrint( "    dir %c:     = %s\n", 'A'+i, szDir );
        }
    }
    DebugPrint( "    szDir      = %s\n",    puser->szDir );
    DebugPrint( "    szUser     = %s\n",    puser->szUser );
    DebugPrint( "    idThread   = %lu\n",   puser->idThread );

    DebugPrint( "\n" );

}   // DumpUserInfo


CHAR * InterpretState( USER_STATE state )
{
    CHAR * pszResult = "unknown";

    switch( state )
    {
    case Embryonic :
        pszResult = "Embryonic";
        break;

    case WaitingForUser :
        pszResult = "WaitingForUser";
        break;

    case WaitingForPass :
        pszResult = "WaitingForPass";
        break;

    case LoggedOn :
        pszResult = "LoggedOn";
        break;

    case Disconnected :
        pszResult = "Disconnected";
        break;

    default :
        break;
    }

    return pszResult;

}   // InterpretState


CHAR * InterpretXferType( XFER_TYPE xferType )
{
    CHAR * pszResult = "unknown";

    switch( xferType )
    {
    case AsciiType :
        pszResult = "ASCII";
        break;

    case BinaryType :
        pszResult = "BINARY";
        break;

    default :
        break;
    }

    return pszResult;

}   // InterpretXferType


CHAR * InterpretXferMode( XFER_MODE xferMode )
{
    CHAR * pszResult = "unknown";

    switch( xferMode )
    {
    case StreamMode :
        pszResult = "STREAM";
        break;

    case BlockMode :
        pszResult = "BLOCK";
        break;

    default :
        break;
    }

    return pszResult;

}   // InterpretXferMode


typedef struct FLAG_MAP
{
    DWORD   flag;
    CHAR  * pszName;

} FLAG_MAP;

FLAG_MAP flag_map[] =
    {
        { UF_MSDOS_DIR_OUTPUT, "UF_MSDOS_DIR_OUTPUT" },
        { UF_ANNOTATE_DIRS,    "UF_ANNOTATE_DIRS"    },
        { UF_READ_ACCESS,      "UF_READ_ACCESS"      },
        { UF_WRITE_ACCESS,     "UF_WRITE_ACCESS"     },
        { UF_OOB_ABORT,        "UF_OOB_ABORT"        },
        { UF_RENAME,           "UF_RENAME"           },
        { UF_PASSIVE,          "UF_PASSIVE"          },
        { UF_ANONYMOUS,        "UF_ANONYMOUS"        },
        { UF_TRANSFER,         "UF_TRANSFER"         },
        { UF_OOB_DATA,         "UF_OOB_DATA"         }
    };
#define NUM_FLAG_MAP (sizeof(flag_map) / sizeof(flag_map[0]))


VOID InterpretFlags( DWORD dwFlags )
{
    INT        i;
    FLAG_MAP * pmap = flag_map;

    for( i = 0 ; i < NUM_FLAG_MAP ; i++ )
    {
        if( dwFlags & pmap->flag )
        {
            DebugPrint( "                 %s\n", pmap->pszName );
            dwFlags &= ~pmap->flag;
        }

        pmap++;
    }

    if( dwFlags != 0 )
    {
        DebugPrint( "                 Remaining flags = %08lX\n", dwFlags );
    }

}   // InterpretFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\client\w3admin.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        w3admin.cxx

   Abstract:
        main program to test the working of RPC APIs of W3 server

   Author:

           Murali R. Krishnan    ( MuraliK )     3-July1-995

   Project:

          W3 server Admin Test Program

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <time.h>
# include <winsock2.h>
# include "inetinfo.h"
# include "apiutil.h"

//
//  size of half dword in bits
//
# define HALF_DWORD_SIZE    ( sizeof(DWORD) * 8 / 2)

//
//  To Avoid overflows I multiply using two parts
//
# define LargeIntegerToDouble( li)      \
        ( ( 1 << HALF_DWORD_SIZE) * \
           (( double) (li).HighPart) * ( 1 << HALF_DWORD_SIZE) + \
          ((li).LowPart) \
        )


static LPWSTR g_lpszServerAddress = NULL;

//
// Prototypes of Functions
//

BOOL GenUsageMessage( int argc, char * argv[]);

BOOL TestGetStatistics( int argc, char * argv[]);

BOOL TestClearStatistics( int argc, char * argv[]);

BOOL TestGetAdminInfo( int argc, char * argv[]);

BOOL TestSetAdminInfo( int argc, char * argv[]);

BOOL TestInetGetAdminInfo( int argc, char * argv[]);

BOOL TestInetSetAdminInfo( int argc, char * argv[]);

BOOL TestEnumUserInfo( int argc, char * argv[]);


//
//  The following DefineAllCommands() defines a template for all commands.
//  Format: CmdCodeName     CommandName         Function Pointer   Comments
//
//  To add addditional test commands, add just another line to the list
//  Dont touch any macros below, they are all automatically generated.
//  Always the first entry should be usage function.
//

#define  DefineAllCommands()    \
 Cmd( CmdUsage,             "usage",                GenUsageMessage,    \
        " Commands Available" )                                         \
 Cmd( CmdGetStatistics,     "getstatistics",        TestGetStatistics,  \
        " Get Server Statistics " )                          \
 Cmd( CmdGetStats,          "stats",                TestGetStatistics,  \
        " Get Server Statistics " )                          \
 Cmd( CmdClearStatistics,   "clearstatistics",      TestClearStatistics,\
        " Clear Server Statistics" )                             \
 Cmd( CmdGetAdminInfo,      "getadmininfo",         TestGetAdminInfo,   \
        " Get Administrative Information" )                             \
 Cmd( CmdSetAdminInfo,      "setadmininfo",         TestSetAdminInfo,   \
        " Set Administrative Information" )           \
 Cmd( CmdEnumUserInfo,      "enumusers",            TestEnumUserInfo,   \
        " Enumerate connected users" )           \
 Cmd( CmdInetGetAdminInfo,  "igetadmininfo",        TestInetGetAdminInfo, \
        " Get common Internet Administrative Information" )    \
 Cmd( CmdInetSetAdminInfo,  "isetadmininfo",        TestInetSetAdminInfo, \
        " Set common Internet Administrative Information" )    \
 Cmd( CmdDebugFlags,        "debug",                NULL,               \
        " isetadmininfo: Set Debugging flags for the server" )          \
 Cmd( CmdPortNumber,        "port",                 NULL,               \
        " isetadmininfo: Set the port number for server")               \
 Cmd( CmdMaxConnections,    "maxconn",              NULL,               \
        " isetadmininfo: Set the max connections allowed in server")    \
 Cmd( CmdConnectionTimeout, "timeout",              NULL,               \
        " isetadmininfo: Set the Connection Timeout interval( in seconds)") \
 Cmd( CmdLogAnonymous,      "loganon",              NULL,               \
        " isetadmininfo: Set the LogAnonymous Flag")                    \
 Cmd( CmdLogNonAnonymous,   "lognonanon",           NULL,               \
        " isetadmininfo: Set the LogNonAnonymous Flag")                 \
 Cmd( CmdAnonUserName,      "anonuser",             NULL,               \
        " isetadmininfo: Set the Anonymous User Name ")                 \
 Cmd( CmdAdminName,         "adminname",            NULL,               \
        " isetadmininfo: Set the Administrator name ")                  \
 Cmd( CmdAdminEmail,        "adminemail",           NULL,               \
        " isetadmininfo: Set the Administrator Email ")                 \
 Cmd( CmdServerComment,     "servercomment",        NULL,               \
        " isetadmininfo: Set the Server Comments for server ")          \
  /* following are string data */   \
                                    \
 Cmd( CmdCatapultPwd,       "catapultpwd",          NULL,               \
        " setadmininfo: Sets the catapult user password ")              \

/*++
  Unimplemented Options:

 (from old w3t.exe)

  Query: Query Volume Security masks.
  Set: Catapult user password.
  nuke:  Disconnect a connected user.

--*/

// Define command codes

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)       CmdCode,

typedef enum  _CmdCodes {
    DefineAllCommands()
    maxCmdCode
} CmdCodes;

#undef Cmd

// Define the functions and array of mappings

// General command function type
typedef BOOL ( * CMDFUNC)( int argc, char * argv[]);

typedef  struct _CmdStruct {
    CmdCodes    cmdCode;
    char *      pszCmdName;
    CMDFUNC     cmdFunc;
    char *      pszCmdComments;
} CmdStruct;


// Define Prototypes of command functions
# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)    \
    BOOL CmdFunc(int argc, char * argv[]);

// Cause an expansion to generate prototypes
// DefineAllCommands()
// Automatic generation causes a problem when we have NULL in Function ptrs :(
// Let the user explicitly define the prototypes

#undef Cmd

//
// Define the global array of commands
//

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)        \
    { CmdCode, CmdName, CmdFunc, CmdComments},

static CmdStruct   g_cmds[] = {

    DefineAllCommands()
    { maxCmdCode, NULL, NULL}       // sentinel command
};

#undef Cmd



/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenUsageMessage( int argc, char * argv[])
{
    CmdStruct * pCmd;

    printf( " Usage:\n %s <server-name/address> <cmd name> <cmd arguments>\n",
            argv[0]);
    for( pCmd = g_cmds; pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {
        printf( "\t%s\t%s\n", pCmd->pszCmdName, pCmd->pszCmdComments);
    }

    return ( TRUE);
} // GenUsageMessage()



static
CmdStruct * DecodeCommand( char * pszCmd)
{
    CmdStruct * pCmd;
    if ( pszCmd != NULL) {

        for( pCmd = g_cmds;
             pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {

            if ( _stricmp( pszCmd, pCmd->pszCmdName) == 0) {
                 return ( pCmd);
            }
        } // for
    }

    return ( &g_cmds[0]);      // No match found, return usage message
} // DecodeCommand()



static
LPWSTR
ConvertToUnicode( char * psz)
/*++
    Converts a given string into unicode string (after allocating buffer space)
    Returns NULL on failure. Use GetLastError() for details.
--*/
{
    LPWSTR  pszUnicode;
    int     cch;

    cch = strlen( psz) + 1;
    pszUnicode = ( LPWSTR ) malloc( cch * sizeof( WCHAR));

    if ( pszUnicode != NULL) {

       // Success. Copy the string now
       int iRet;

       iRet = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                                   psz,    cch,
                                   pszUnicode,  cch);

       if ( iRet == 0 || iRet != cch) {

            free( pszUnicode);      // failure so free the block
            pszUnicode = NULL;
       }
    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( pszUnicode);
} // ConvertToUnicode()


static
VOID
PrintStatisticsInfo( IN W3_STATISTICS_0 * pStat)
{
    DWORD i;

    if ( pStat == NULL) {

        return ;
    }

    printf( " Printing Statistics Information: \n");

    printf( "%20s = %10.3g\n", "BytesSent",
           LargeIntegerToDouble( pStat->TotalBytesSent));
    printf( "%20s = %4.3g\n", "BytesReceived",
           LargeIntegerToDouble(pStat->TotalBytesReceived));
    printf( "%20s = %ld\n", "Files Sent ", pStat->TotalFilesSent);

    printf( "%20s = %ld\n", "Current Anon Users",pStat->CurrentAnonymousUsers);
    printf( "%20s = %ld\n", "Current NonAnon Users",
           pStat->CurrentNonAnonymousUsers);
    printf( "%20s = %ld\n", "Total Anon Users", pStat->TotalAnonymousUsers);
    printf( "%20s = %ld\n", "Total NonAnon Users",
           pStat->TotalNonAnonymousUsers);
    printf( "%20s = %ld\n", "Max Anon Users", pStat->MaxAnonymousUsers);
    printf( "%20s = %ld\n", "Max NonAnon Users", pStat->MaxNonAnonymousUsers);

    printf( "%20s = %ld\n", "Current Connections", pStat->CurrentConnections);
    printf( "%20s = %ld\n", "Max Connections", pStat->MaxConnections);
    printf( "%20s = %ld\n", "Connection Attempts", pStat->ConnectionAttempts);
    printf( "%20s = %ld\n", "Logon Attempts", pStat->LogonAttempts);

    printf( "%20s = %ld\n", "Total Gets", pStat->TotalGets);
    printf( "%20s = %ld\n", "Total Heads", pStat->TotalHeads);
    printf( "%20s = %ld\n", "Total Posts", pStat->TotalPosts);

    printf( "%20s = %ld\n", "Total CGI Reqs", pStat->TotalCGIRequests);
    printf( "%20s = %ld\n", "Total BGI Reqs", pStat->TotalBGIRequests);
    printf( "%20s = %ld\n", "Current CGI Reqs", pStat->CurrentCGIRequests);
    printf( "%20s = %ld\n", "Current BGI Reqs", pStat->CurrentBGIRequests);
    printf( "%20s = %ld\n", "Max CGI Reqs", pStat->MaxCGIRequests);
    printf( "%20s = %ld\n", "Max BGI Reqs", pStat->MaxBGIRequests);

    printf( "%20s = %ld\n", "Total Not Found Errors",
           pStat->TotalNotFoundErrors);
    printf( "%20s = %s\n", "Time of Last Clear",
           asctime( localtime( (time_t *)&pStat->TimeOfLastClear ) ) );


#ifndef NO_AUX_PERF

    printf( " Auxiliary Counters # = %u\n",
           pStat->nAuxCounters);

    for ( i = 0; i < pStat->nAuxCounters; i++) {

        printf( "Aux Counter[%u] = %u\n", i, pStat->rgCounters[i]);

    } //for

#endif // NO_AUX_PERF

    return;

} // PrintStatisticsInfo()



static
VOID
PrintStatsForTime( IN W3_STATISTICS_0 *    pStatStart,
                   IN W3_STATISTICS_0 *    pStatEnd,
                   IN DWORD sInterval)
/*++
  Print the statistics information over a time interval sInterval seconds.
  Arguments:
    pStatStart  pointer to statistics information for starting sample
    pStatEnd    pointer to statistics information for ending sample
    sInterval   Time interval in seconds for the sample

  Returns:
     None

--*/
{
    LARGE_INTEGER  liDiff;
    double dDiff;

    if ( pStatStart == NULL || pStatEnd == NULL || sInterval == 0 ) {

        return ;
    }

    printf( "Statistics  for Interval = %u seconds\n", sInterval);
    printf( "%20s\t %10s\t%10s\t%10s\t%6s\n\n",
           "Item   ", "Start Sample", "End Sample", "Difference", "Rate/s");

    liDiff.QuadPart = ( pStatEnd->TotalBytesSent.QuadPart -
                        pStatStart->TotalBytesSent.QuadPart);
    dDiff = LargeIntegerToDouble( liDiff);
    printf( "%20s\t %10.3g\t %10.3g\t %10.3g\t%6.3g\n",
           "Bytes Sent",
           LargeIntegerToDouble( pStatStart->TotalBytesSent),
           LargeIntegerToDouble( pStatEnd->TotalBytesSent),
           dDiff,
           dDiff/sInterval
           );

    liDiff.QuadPart = ( pStatEnd->TotalBytesReceived.QuadPart -
                        pStatStart->TotalBytesReceived.QuadPart);
    dDiff = LargeIntegerToDouble( liDiff);
    printf( "%20s\t %10.3g\t %10.3g\t %10.3g\t%6.3g\n",
           "Bytes Received",
           LargeIntegerToDouble(pStatStart->TotalBytesReceived),
           LargeIntegerToDouble(pStatEnd->TotalBytesReceived),
           dDiff,
           dDiff/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Files Sent ",
           pStatStart->TotalFilesSent,
           pStatEnd->TotalFilesSent,
           pStatEnd->TotalFilesSent - pStatStart->TotalFilesSent,
           (pStatEnd->TotalFilesSent - pStatStart->TotalFilesSent)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Anon Users",
           pStatStart->CurrentAnonymousUsers,
           pStatEnd->CurrentAnonymousUsers,
           pStatEnd->CurrentAnonymousUsers - pStatStart->CurrentAnonymousUsers,
           (int ) (pStatEnd->CurrentAnonymousUsers -
                   pStatStart->CurrentAnonymousUsers)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current NonAnon Users",
           pStatStart->CurrentNonAnonymousUsers,
           pStatEnd->CurrentNonAnonymousUsers,
           (pStatStart->CurrentNonAnonymousUsers -
            pStatEnd->CurrentNonAnonymousUsers),
           (int ) (pStatStart->CurrentNonAnonymousUsers -
                   pStatEnd->CurrentNonAnonymousUsers)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Anon Users",
           pStatStart->TotalAnonymousUsers,
           pStatEnd->TotalAnonymousUsers,
           pStatEnd->TotalAnonymousUsers - pStatStart->TotalAnonymousUsers,
           (pStatEnd->TotalAnonymousUsers - pStatStart->TotalAnonymousUsers)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total NonAnon Users",
           pStatStart->TotalNonAnonymousUsers,
           pStatEnd->TotalNonAnonymousUsers,
           (pStatEnd->TotalNonAnonymousUsers -
            pStatStart->TotalNonAnonymousUsers),
           (pStatEnd->TotalNonAnonymousUsers -
            pStatStart->TotalNonAnonymousUsers)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max Anon Users",
           pStatStart->MaxAnonymousUsers,
           pStatEnd->MaxAnonymousUsers,
           pStatEnd->MaxAnonymousUsers - pStatStart->MaxAnonymousUsers,
           (pStatEnd->MaxAnonymousUsers - pStatStart->MaxAnonymousUsers)
           /sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max NonAnon Users",
           pStatStart->MaxNonAnonymousUsers,
           pStatEnd->MaxNonAnonymousUsers,
           pStatEnd->MaxNonAnonymousUsers - pStatStart->MaxNonAnonymousUsers,
           (pStatEnd->MaxNonAnonymousUsers - pStatStart->MaxNonAnonymousUsers)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Connections",
           pStatStart->CurrentConnections,
           pStatEnd->CurrentConnections,
           pStatEnd->CurrentConnections - pStatStart->CurrentConnections,
           (int )
           (pStatEnd->CurrentConnections - pStatStart->CurrentConnections)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max Connections",
           pStatStart->MaxConnections,
           pStatEnd->MaxConnections,
           pStatEnd->MaxConnections - pStatStart->MaxConnections,
           (pStatEnd->MaxConnections - pStatStart->MaxConnections)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Connection Attempts",
           pStatStart->ConnectionAttempts,
           pStatEnd->ConnectionAttempts,
           pStatEnd->ConnectionAttempts - pStatStart->ConnectionAttempts,
           (pStatEnd->ConnectionAttempts - pStatStart->ConnectionAttempts)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Logon Attempts",
           pStatStart->LogonAttempts,
           pStatEnd->LogonAttempts,
           pStatEnd->LogonAttempts - pStatStart->LogonAttempts,
           (pStatEnd->LogonAttempts - pStatStart->LogonAttempts)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Gets",
           pStatStart->TotalGets,
           pStatEnd->TotalGets,
           pStatEnd->TotalGets - pStatStart->TotalGets,
           (pStatEnd->TotalGets - pStatStart->TotalGets)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Heads",
           pStatStart->TotalHeads,
           pStatEnd->TotalHeads,
           pStatEnd->TotalHeads - pStatStart->TotalHeads,
           (pStatEnd->TotalHeads - pStatStart->TotalHeads)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Posts",
           pStatStart->TotalPosts,
           pStatEnd->TotalPosts,
           pStatEnd->TotalPosts - pStatStart->TotalPosts,
           (pStatEnd->TotalPosts - pStatStart->TotalPosts)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Others",
           pStatStart->TotalOthers,
           pStatEnd->TotalOthers,
           pStatEnd->TotalOthers - pStatStart->TotalOthers,
           (pStatEnd->TotalOthers - pStatStart->TotalOthers)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current CGI Requests",
           pStatStart->CurrentCGIRequests,
           pStatEnd->CurrentCGIRequests,
           pStatEnd->CurrentCGIRequests - pStatStart->CurrentCGIRequests,
           (pStatEnd->CurrentCGIRequests - pStatStart->CurrentCGIRequests)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total CGI Requests",
           pStatStart->TotalCGIRequests,
           pStatEnd->TotalCGIRequests,
           pStatEnd->TotalCGIRequests - pStatStart->TotalCGIRequests,
           (pStatEnd->TotalCGIRequests - pStatStart->TotalCGIRequests)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max CGIRequests",
           pStatStart->MaxCGIRequests,
           pStatEnd->MaxCGIRequests,
           pStatEnd->MaxCGIRequests - pStatStart->MaxCGIRequests,
           (pStatEnd->MaxCGIRequests - pStatStart->MaxCGIRequests)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current BGI Requests",
           pStatStart->CurrentBGIRequests,
           pStatEnd->CurrentBGIRequests,
           pStatEnd->CurrentBGIRequests - pStatStart->CurrentBGIRequests,
           (pStatEnd->CurrentBGIRequests - pStatStart->CurrentBGIRequests)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total BGI Requests",
           pStatStart->TotalBGIRequests,
           pStatEnd->TotalBGIRequests,
           pStatEnd->TotalBGIRequests - pStatStart->TotalBGIRequests,
           (pStatEnd->TotalBGIRequests - pStatStart->TotalBGIRequests)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max BGIRequests",
           pStatStart->MaxBGIRequests,
           pStatEnd->MaxBGIRequests,
           pStatEnd->MaxBGIRequests - pStatStart->MaxBGIRequests,
           (pStatEnd->MaxBGIRequests - pStatStart->MaxBGIRequests)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Not Found Errors",
           pStatStart->TotalNotFoundErrors,
           pStatEnd->TotalNotFoundErrors,
           pStatEnd->TotalNotFoundErrors - pStatStart->TotalNotFoundErrors,
           (pStatEnd->TotalNotFoundErrors - pStatStart->TotalNotFoundErrors)/
           sInterval
           );

    return;

} // PrintStatisticsInfo()




BOOL
TestGetStatistics( int argc, char * argv[] )
/*++
   Gets Statistics from server and prints it.
   If the optional time information is given, then this function
   obtains the statistics, sleeps for specified time interval and then
    again obtains new statistics and prints the difference, neatly formatted.

   Arguments:
      argc = count of arguments
      argv  array of strings for command
            argv[0] = stats or getstatistics
            argv[1] = time interval if specified in seconds
              if argv[1] = -t10 => loop getting stats every 10 seconds.
--*/
{
    DWORD   err;
    DWORD   timeToSleep = 0;
    W3_STATISTICS_0 *  pStat1 = NULL;  // this should be freed ? NYI
    BOOL    fLoop = FALSE;

    if ( argc > 1 && argv[1] != NULL) {

        if ( argv[1][0] == '-' && argv[1][1] == 't') {
            fLoop = TRUE;
            timeToSleep = atoi(argv[1] + 2);
        } else {
            timeToSleep = atoi( argv[1]);
        }
    }

    err = W3QueryStatistics(g_lpszServerAddress,
                            0,
                            (LPBYTE *) &pStat1);

    if ( err == NO_ERROR) {

        if ( timeToSleep <= 0) {

            PrintStatisticsInfo( pStat1);
        } else {

            W3_STATISTICS_0  *  pStat2 = NULL;

            do {
                printf( "\n\nStatistics For Time Interval %u seconds\n\n",
                       timeToSleep);

                Sleep( timeToSleep * 1000);   // sleep for the interval
                err = W3QueryStatistics(g_lpszServerAddress,
                                        0,
                                        (LPBYTE *) &pStat2);

                if ( err == NO_ERROR) {

                    PrintStatsForTime( pStat1, pStat2, timeToSleep);
                } else {

                    break;
                }

                if ( pStat1 != NULL) {

                    MIDL_user_free( pStat1);
                    pStat1 = NULL;
                }

                pStat1 = pStat2;

            } while ( fLoop);
        }
    }

    if ( pStat1 != NULL) {

        MIDL_user_free( pStat1);
    }

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetStatistics()



BOOL
TestClearStatistics( int argc, char * argv[])
{
    DWORD   err;

    err = W3ClearStatistics(  g_lpszServerAddress);

    printf( "Cleared the statistics Err = %d\n", err);

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestClearStatistics()



static VOID
PrintAdminInformation( IN W3_CONFIG_INFO * pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %S\n", "DirBrowseControl", pConfigInfo->dwDirBrowseControl);
    printf( "%20s= %S\n", "fCheckForWAISDB", pConfigInfo->fCheckForWAISDB);
    printf( "%20s= %S\n", "DefaultLoadFiles",pConfigInfo->lpszDefaultLoadFile);
    printf( "%20s= %S\n", "DirectoryImage",  pConfigInfo->lpszDirectoryImage);
    printf( "%20s= %S\n", "Catapult User",   pConfigInfo->lpszCatapultUser);
    printf( "%20s= %x\n",  "CatapultUserPwd",  pConfigInfo->szCatapultUserPwd);

    return;
} // PrintAdminInformation()




static BOOL
TestGetAdminInfo( int argc, char * argv[] )
{
    DWORD err;
    W3_CONFIG_INFO * pConfig = NULL;

    err = W3GetAdminInformation( g_lpszServerAddress, &pConfig);

    printf( "W3GetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintAdminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetAdminInfo()


DWORD
SetAdminField(
    IN W3_CONFIG_INFO  * pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

      case CmdCatapultPwd:
        {
            if ( pszValue) {

                WCHAR achPassword[ PWLEN + 1];

                wsprintfW( achPassword, L"%S", pszValue);
                wcscpy( pConfigIn->szCatapultUserPwd, achPassword);
            }
            break;
        }

      default:
        printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
               pszSubCmd);
        err = ERROR_INVALID_PARAMETER;
        break;

    }  // switch


    return ( err);
} // SetAdminField()




BOOL
TestSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = setadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    W3_CONFIG_INFO * pConfigOut = NULL;  // config value obtained from server

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    // Get the config from server to start with
    err = W3GetAdminInformation( g_lpszServerAddress, &pConfigOut);
    if ( err != NO_ERROR) {

        printf( " W3GetAdminInformation()  failed with error = %u\n",
               err);
        SetLastError( err);
        return (FALSE);
    }

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( SetAdminField( pConfigOut, argv[argc - 1], argv[argc])
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err != NO_ERROR) {
        // Now make RPC call to set the fields
        err = W3SetAdminInformation( g_lpszServerAddress,
                                     pConfigOut);
    }

    MIDL_user_free( pConfigOut);
    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetAdminInfo()




static VOID
PrintInetInfodminInformation( IN LPINET_INFO_CONFIG_INFO  pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing InetInfo Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %d\n", "LogAnonymous",   pConfigInfo->fLogAnonymous);
    printf( "%20s= %d\n", "LogNonAnonymous",pConfigInfo->fLogNonAnonymous);
    printf( "%20s= %08x\n", "Authentication Flags",
           pConfigInfo->dwAuthentication);

    printf( "%20s= %d\n", "Port",           pConfigInfo->sPort);
    printf( "%20s= %d\n", "Connection Timeout",
           pConfigInfo->dwConnectionTimeout);
    printf( "%20s= %d\n",  "Max Connections",
           pConfigInfo->dwMaxConnections);

    printf( "%20s= %S\n", "AnonUserName",   pConfigInfo->lpszAnonUserName);
    printf( "%20s= %S\n", "AnonPassword",   pConfigInfo->szAnonPassword);

    printf( "%20s= %S\n", "Admin Name",
           pConfigInfo->lpszAdminName);
    printf( "%20s= %S\n", "Admin Email",
           pConfigInfo->lpszAdminEmail);
    printf( "%20s= %S\n", "Server Comments",
           pConfigInfo->lpszServerComment);

    //
    // IP lists and Grant lists, Virtual Roots are not included now. Later.
    //

    return;
} // PrintInetInfodminInformation()


static DWORD
GetServiceIdFromString( IN LPCSTR pszService)
{
    if ( pszService != NULL) {

        if ( !_stricmp(pszService, "HTTP")) {

            return ( INET_HTTP);
        } else if (!_stricmp( pszService, "GOPHER")) {

            return (INET_GOPHER);
        } else if ( !_stricmp( pszService, "FTP")) {

            return (INET_FTP);
        } else if ( !_stricmp( pszService, "DNS")) {

            return (INET_DNS);
        }
    }

    return ( INET_HTTP);
} // GetServiceIdFromString()



static BOOL
TestInetGetAdminInfo( int argc, char * argv[] )
/*++
   Gets the configuration information using InetInfoGetAdminInformation()
   argv[0] = igetadmininfo
   argv[1] = service name  ( gopher, http, ftp, catapult)

--*/
{
    DWORD err;
    LPINET_INFO_CONFIG_INFO  pConfig = NULL;
    DWORD dwServiceId;

    printf( " InetInfoGetAdminInformation() called at: Time = %d\n",
            GetTickCount());

    dwServiceId = (argc > 1) ? GetServiceIdFromString( argv[1]) : INET_HTTP;

    err = InetInfoGetAdminInformation( g_lpszServerAddress,
                                    dwServiceId,
                                   &pConfig);

    printf( "Finished at Time = %d\n", GetTickCount());
    printf( "InetInfoGetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintInetInfodminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestInetGetAdminInfo()


DWORD
SetInetInfoAdminField(
    IN LPINET_INFO_CONFIG_INFO  pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

        case CmdPortNumber:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_PORT_NUMBER);
            pConfigIn->sPort = atoi( pszValue);
            break;

        case CmdConnectionTimeout:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_CONNECTION_TIMEOUT);
            pConfigIn->dwConnectionTimeout = atoi( pszValue);
            break;

        case CmdMaxConnections:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_MAX_CONNECTIONS);
            pConfigIn->dwMaxConnections = atoi( pszValue);
            break;

          case CmdLogAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_ANONYMOUS);
            pConfigIn->fLogAnonymous = atoi( pszValue);
            break;

          case CmdLogNonAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_NONANONYMOUS);
            pConfigIn->fLogNonAnonymous = atoi( pszValue);
            break;

          case CmdAnonUserName:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ANON_USER_NAME);
            pConfigIn->lpszAnonUserName = ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAnonUserName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminName:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ADMIN_NAME);
            pConfigIn->lpszAdminName =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAdminName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminEmail:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ADMIN_EMAIL);
            pConfigIn->lpszAdminEmail =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAdminEmail == NULL) {
                err = GetLastError();
            }
            break;

          case CmdServerComment:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_SERVER_COMMENT);
            pConfigIn->lpszServerComment =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszServerComment == NULL) {
                err = GetLastError();
            }
            break;


        default:
            printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
                    pszSubCmd);
            err = ERROR_INVALID_PARAMETER;
            break;

    }  // switch


    return ( err);
} // SetAdminField()


static VOID
FreeBuffer( IN PVOID * ppBuffer)
{
    if ( *ppBuffer != NULL) {
        free( * ppBuffer);
        *ppBuffer = NULL;       // reset the old value
    }
    return;
} // FreeBuffer()

VOID
FreeStringsInInetConfigInfo( IN OUT LPINET_INFO_CONFIG_INFO pConfigInfo)
{
    FreeBuffer( (PVOID *) & pConfigInfo->lpszAnonUserName);

} // FreeStringsInInetConfigInfo()


BOOL
TestInetSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = isetadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    LPINET_INFO_CONFIG_INFO  * ppConfigOut = NULL;
    INET_INFO_CONFIG_INFO  configIn;   // config values that are set

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // form the admin info block to set the information
    //
    memset( ( LPVOID) &configIn, 0, sizeof( configIn)); // init to Zeros

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( SetInetInfoAdminField( &configIn, argv[argc - 1], argv[argc])
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err != NO_ERROR) {
        // Now make RPC call to set the fields
        err = InetInfoSetAdminInformation( g_lpszServerAddress,
                                        INET_HTTP,
                                       &configIn);
    }

    // Need to free all the buffers allocated for the strings
    FreeStringsInInetConfigInfo( &configIn);

    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetInetAdminInfo()



BOOL TestEnumUserInfo( int argc, char * argv[])
{

    DWORD   err;
    W3_USER_INFO  * pUserInfo;
    DWORD           cEntries;

    printf( "Invoking W3EnumerateUsers..." );

    err = W3EnumerateUsers( g_lpszServerAddress,
                           &cEntries,
                           &pUserInfo );

    if( err == NO_ERROR )
    {
        printf( " %lu connected users\n", cEntries );

        while( cEntries-- )
        {
            IN_ADDR addr;

            addr.s_addr = (u_long)pUserInfo->inetHost;

            printf( "idUser     = %lu\n"
                   "pszUser    = %S\n"
                   "fAnonymous = %lu\n"
                   "inetHost   = %s\n"
                   "tConnect   = %lu\n\n",
                   pUserInfo->idUser,
                   pUserInfo->pszUser,
                   pUserInfo->fAnonymous,
                   inet_ntoa( addr ),
                   pUserInfo->tConnect   );

            pUserInfo++;
        }
    }

    SetLastError( err);
    return ( err == NO_ERROR);

} // TestEnumUserInfo()





int __cdecl
main( int argc, char * argv[])
{
    DWORD err = NO_ERROR;
    char ** ppszArgv;       // arguments for command functions
    int     cArgs;           // arg count for command functions
    char * pszCmdName;
    CmdStruct  * pCmd;
    CMDFUNC pCmdFunc = NULL;

    if ( argc < 3 || argv[1] == NULL ) {

      // Insufficient arguments
       GenUsageMessage( argc, argv);
       return ( 1);
    }

    pszCmdName = argv[2];
    if (( pCmd = DecodeCommand( pszCmdName)) == NULL || pCmd->cmdFunc == NULL) {
        printf( "Internal Error: Invalid Command %s\n", pszCmdName);
        GenUsageMessage( argc, argv);
        return ( 1);
    }

    g_lpszServerAddress = ConvertToUnicode( argv[1]);   // get server address

    cArgs = argc - 2;
    ppszArgv = argv + 2;     // position at the start of the command name

    if ( !(*pCmd->cmdFunc)( cArgs, ppszArgv)) {     // call the test function

        // Test function failed.
        printf( "Command %s failed. Error = %d\n", pszCmdName, GetLastError());
        return ( 1);
    }

    printf( " Command %s succeeded\n", pszCmdName);
    return ( 0);        // success

} // main()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\cacheflt\debug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Defines simple debug output mechanisms.

Author:

    Seth Pollack (SethP)    5-September-1997

Revision History:

--*/


#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <windows.h>

#ifdef DBG

//
//  Simple debug output
//

#define DEST                __buff

#define DBGPRINT( x )       {                                   \
                                char __buff[1024];              \
                                wsprintf x;                     \
                                OutputDebugString( __buff );    \
                            }


#else // !def DBG

#define DEST
#define DBGPRINT( x )       ((void)0)


#endif // def/!def DBG


#endif // ndef __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\debug\w3dbg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    w3dbg.h
    This include file contains the prototypes & manifest constants
    used by the W3 Server debugger extension DLL.


    FILE HISTORY:
        KeithMo     18-May-1993 Created.

*/


#ifndef _W3DBG_H_
#define _W3DBG_H_


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <wdbgexts.h>

#include <w3p.h>


//
//  Globals shared by all extension commands.
//

extern PNTSD_OUTPUT_ROUTINE  DebugPrint;
extern PNTSD_GET_EXPRESSION  DebugEval;
extern PNTSD_GET_SYMBOL      DebugGetSymbol;
extern PNTSD_DISASM          DebugDisassem;
extern PNTSD_CHECK_CONTROL_C DebugCheckCtrlC;


//
//  Utility functions.
//

VOID GrabDebugApis( LPVOID lpExtensionApis );


//
//  DLL entrypoint.
//
//

BOOLEAN W3DbgDllInitialize( HANDLE hDll,
                             DWORD  nReason,
                             LPVOID pReserved );


#ifdef __cplusplus
}       // extern "C"
#endif  // __cplusplus


#endif  // _W3DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\cacheflt\cacheflt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cacheflt.h

Abstract:

    Main header file for ISAPI filter that allows cached forms of dynamic 
    output (e.g. .asp) to be served, greatly improving efficiency.

Author:

    Seth Pollack (SethP)    5-September-1997

Revision History:

--*/


#ifndef __CACHEFLT__
#define __CACHEFLT__


//
// Includes
//

#include <windows.h>
#include <iisfilt.h>


//
// Contants
//

#define MAJOR_VERSION 1
#define MINOR_VERSION 0

// The file extension used for the cached pages
#define CACHED_FILE_EXT "csp"
#define CACHED_FILE_EXT_LEN 3


//
//  Prototypes
//

DWORD
OnUrlMap(
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_URL_MAP pvData
    );

DWORD
OnLog(
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_LOG     pLog
    );


#endif // ndef __CACHEFLT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\debug\w3dbg.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    w3dbg.c
    This is the main module for the W3 Server debugger extension DLL.
    This module contains the DLL initialization/termination code and a
    few utility functions.


    FILE HISTORY:
        KeithMo     18-May-1993 Created.

*/

#include "w3dbg.h"


//
//  Globals shared by all extension commands.
//

PNTSD_OUTPUT_ROUTINE  DebugPrint;
PNTSD_GET_EXPRESSION  DebugEval;
PNTSD_GET_SYMBOL      DebugGetSymbol;
PNTSD_DISASM          DebugDisassem;
PNTSD_CHECK_CONTROL_C DebugCheckCtrlC;


/*******************************************************************

    NAME:       W3DbgDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hDll                    - A handle to the DLL.

                nReason                 - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

    RETURNS:    BOOLEAN                 - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        KeithMo     18-May-1993 Created.

********************************************************************/
BOOLEAN W3DbgDllInitialize( HANDLE hDll,
                             DWORD  nReason,
                             LPVOID pReserved )
{
    BOOLEAN fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;

}   // W3DbgDllInitialize


/*******************************************************************

    NAME:       GrabDebugApis

    SYNOPSIS:   Initializes the global variables that hold pointers
                to the debugger API functions.

    ENTRY:      lpExtensionApis         - Points to a structure that
                                          contains pointers to the
                                          various debugger APIs.

    HISTORY:
        KeithMo     18-May-1993 Created.

********************************************************************/
VOID GrabDebugApis( LPVOID lpExtensionApis )
{
    PNTSD_EXTENSION_APIS lpNtsdApis = (PNTSD_EXTENSION_APIS)lpExtensionApis;

    DebugPrint      = lpNtsdApis->lpOutputRoutine;
    DebugEval       = lpNtsdApis->lpGetExpressionRoutine;
    DebugGetSymbol  = lpNtsdApis->lpGetSymbolRoutine;
    DebugDisassem   = lpNtsdApis->lpDisasmRoutine;
    DebugCheckCtrlC = lpNtsdApis->lpCheckControlCRoutine;

}   // GrabDebugApis
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\cacheflt\cacheflt.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cacheflt.cxx

Abstract:

    Main source file for ISAPI filter that allows cached forms of dynamic 
    output (e.g. .asp) to be served, greatly improving efficiency.

Author:

    Seth Pollack (SethP)    5-September-1997

Revision History:

--*/


#include "cacheflt.h"
#include "debug.h"


//
// Optional entry/exit point for DLLs
//

extern "C"
BOOL
WINAPI
DllMain(
    IN HINSTANCE    hInstance,
    IN DWORD        dwReason,
    IN LPVOID       lpReserved
    )
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DBGPRINT((DEST, "CACHEFLT: Starting up\n"));
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DBGPRINT((DEST, "CACHEFLT: Shutting down\n"));
    }
    
    return TRUE;
}


//
// Required initialization entrypoint for all ISAPI filters
//

BOOL
WINAPI
GetFilterVersion(
    IN HTTP_FILTER_VERSION* pVer
    )
{

    DBGPRINT((DEST, "CACHEFLT: Server filter version is %d.%d\n",
              HIWORD(pVer->dwServerFilterVersion),
              LOWORD(pVer->dwServerFilterVersion)));


    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    // Specify the types and order of notification
    pVer->dwFlags = ((SF_NOTIFY_SECURE_PORT  | SF_NOTIFY_NONSECURE_PORT)
                     | SF_NOTIFY_ORDER_HIGH
                     | SF_NOTIFY_URL_MAP
                     | SF_NOTIFY_LOG
                     );

    // Set the filter description
    wsprintf(pVer->lpszFilterDesc,
             "Cached dynamic content filter, version v%d.%02d",
             MAJOR_VERSION, MINOR_VERSION);
             
    DBGPRINT((DEST, "CACHEFLT: %s\n", pVer->lpszFilterDesc));

    return TRUE;
}


//
// Shutdown entry point for filters
//

BOOL
WINAPI
TerminateFilter(
    IN DWORD dwFlags
    )
{
    // Do any cleanup here

    return TRUE;
}


//
// Required dispatch entrypoint for all ISAPI filters
//

DWORD
WINAPI
HttpFilterProc(
    IN HTTP_FILTER_CONTEXT*  pfc,
    IN DWORD                 dwNotificationType,
    IN VOID*                 pvData
    )
{
    switch (dwNotificationType)
    {
    case SF_NOTIFY_URL_MAP:
        return OnUrlMap(pfc, (PHTTP_FILTER_URL_MAP) pvData);
        
    case SF_NOTIFY_LOG:
        return OnLog(pfc, (PHTTP_FILTER_LOG) pvData);

    default:
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }
}


//
// Handler for URL Map filter notifications.
//

DWORD
OnUrlMap(
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_URL_MAP pvData
    )
{

    DWORD cchPhysicalPath;
    DWORD cchPhysicalPathWithoutExt;
    DWORD cchOrigExt;
    char * pszTemp = NULL;
    char * pszOrigExt = NULL;
    char szCachedFilePath[MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA FileAttribData;
    DWORD i;
    BOOL bSuccess;
    DWORD cchOrigURL;
    char * pszSavedURL = NULL;


    DBGPRINT((DEST, 
              "CACHEFLT: Original URL: %s\n", 
              pvData->pszURL));
    DBGPRINT((DEST, 
              "CACHEFLT: Original Physical Path: %s\n", 
              pvData->pszPhysicalPath));


    //
    // Isolate the extension of the request. 
    // Note that we use the physical path for this, so that we have our 
    // pointer all set to go if we do indeed want to modify the mapping 
    // in place.
    // We start at the end and back up to the period, being careful not to 
    // overshoot. 
    // Note that the URL at this point has already been normalized, so we
    // don't have to worry about possibly having a query string at the 
    // end, or the period encoded as %2E, etc.
    //

    cchPhysicalPath = strlen(pvData->pszPhysicalPath);

    pszTemp = pvData->pszPhysicalPath + cchPhysicalPath; 
    
    while (*pszTemp != '.' && pszTemp > pvData->pszPhysicalPath)
    {
        pszTemp--;
    }

    //
    // If we didn't find any extension, then bail. This can happen for
    // example if a default document is being used; we will get called
    // here first with the original URL without a filename, and then
    // again with the modified URL that has the default docuement name
    // attached.
    //
    if (pszTemp == pvData->pszPhysicalPath)
    {
        goto Exit;
    }

    // The extension starts after the period
    pszOrigExt = pszTemp + 1;


    // 
    // See if it is an extension that we care about.
    // For now, that's .asp only, although we can broaden that later.
    //

    if (_stricmp(pszOrigExt, "asp") != 0)
    {
        // Not a match
        goto Exit;
    }


    //
    // Copy the filename (without the extension but with the period),  
    // append the extension used for cached files onto it, and null
    // terminate.
    //

    cchOrigExt = strlen(pszOrigExt);

    cchPhysicalPathWithoutExt = cchPhysicalPath - cchOrigExt;

    if ((cchPhysicalPathWithoutExt + CACHED_FILE_EXT_LEN) >= sizeof(szCachedFilePath))
    {
        // Our buffer is too small
        goto Exit;
    }
    
    strncpy(szCachedFilePath, 
            pvData->pszPhysicalPath, 
            cchPhysicalPathWithoutExt);
    
    strncpy(szCachedFilePath + cchPhysicalPathWithoutExt,
            CACHED_FILE_EXT, 
            CACHED_FILE_EXT_LEN);

    szCachedFilePath[cchPhysicalPathWithoutExt + CACHED_FILE_EXT_LEN] = '\0';


    //
    // Now see if we have a cached copy for the file in question.
    //

    //
    // Consider: We could keep track of what is cached and not to avoid
    // this call every time. In that case, we would need to think about
    // change notify and other look-aside flushing issues.
    //

    bSuccess = GetFileAttributesEx(szCachedFilePath,
                                   GetFileExInfoStandard,
                                   &FileAttribData);

    if (!bSuccess) 
    {
        // No cached file is available
        goto Exit;
    }

    //
    // Consider: we could check here is the cached file is older that the
    // original target file. This still doesn't guarantee that the cached
    // file isn't stale though, as it also may depend on external data
    // (e.g. from a database) that has changed.
    //


    //
    // Serve up the cached file. Change the physical path to point to
    // the cached file instead of the originally requested file.
    // 

    // Make sure we aren't going to overwrite the server's buffer
    if (cchPhysicalPathWithoutExt + CACHED_FILE_EXT_LEN > pvData->cbPathBuff)
    {
        //
        // We don't have room to add our extension.
        // Note: this should never happen as long as we are only
        // using this filter with .asp, as the length of the
        // original and cached file extensions are the same.
        //
        
        goto Exit;
    }

    //
    // Note: if in the future we support caching for things besides .asp, there
    // will be a null termination issue if the extension lengths don't match
    //
    
    strncpy(pszOrigExt, CACHED_FILE_EXT, CACHED_FILE_EXT_LEN);
    
    // 
    // HACK ALERT
    //
    // We are modifying the pvData->pszURL string here, which
    // is supposed to be const and not modified by a filter.
    // However, it happens to work. 
    //
    // Figure out a cleaner solution long term. Some ideas (best first):
    // * (post-K2) add a new filter notification that allows the URL to be 
    // changed legally
    // * (post-K2) add a new filter SF that allows URL->physical mapping to 
    // be looked up during pre-proc headers
    // * copy vroot metabase lookup code into the filter
    // * wire to configurable list of URLs to cache
    //

    // Make a copy of the original URL so that we can log it correctly

    cchOrigURL = strlen(pvData->pszURL);
    
    pszSavedURL = (char *)(pfc->AllocMem(pfc, cchOrigURL + 1, 0));
    
    pfc->pFilterContext = (void *)(pszSavedURL);
    
    strcpy(pszSavedURL, pvData->pszURL);


    //
    // Note: if in the future we support caching for things besides .asp, we
    // will blow the buffer if the original extension length is less than
    // the new one.
    //
    
    strncpy((char *)(pvData->pszURL) + cchOrigURL - cchOrigExt,
            CACHED_FILE_EXT, 
            CACHED_FILE_EXT_LEN);

    
Exit:

    DBGPRINT((DEST, 
              "CACHEFLT: Final URL: %s\n", 
              pvData->pszURL));
    DBGPRINT((DEST, 
              "CACHEFLT: Final Physical Path: %s\n", 
              pvData->pszPhysicalPath));
    

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


//
// Correct the log if the URL was changed in OnPreprocHeaders
//

DWORD
OnLog(
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_LOG     pLog
    )
{
    LPCSTR pszSavedURL;
    

    pszSavedURL= (LPCSTR)(pfc->pFilterContext);

    if (pszSavedURL != NULL)
    {
        DBGPRINT((DEST, 
                  "CACHEFLT: changing log from %s to %s\n", 
                  pLog->pszTarget, 
                  pszSavedURL));
                  
        pLog->pszTarget = pszSavedURL;


        //
        // Clear the filter context, so that future requests on the same
        // keep-alive connection won't get a stale value
        //

        pfc->pFilterContext = NULL;
    }
    else
    {
        DBGPRINT((DEST, 
                  "CACHEFLT: Not changing log for %s\n", 
                  pLog->pszTarget));
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\authfilt\authfilt.cxx ===
/*++

Copyright (c) 1996,97  Microsoft Corporation


Module Name:

    authfilt.cxx

Abstract:

    This module is an ISAPI Authentication Filter.

    This is based on iismap flat-file format.

--*/

#ifdef __cplusplus
extern "C" {
#endif

# include <windows.h>
#if 1 // DBCS
# include <mbstring.h>
#endif

#ifdef __cplusplus
};
#endif

# include <iis64.h>
# include <inetcom.h>
# include <inetinfo.h>

extern "C" {

//
//  Project include files.
//

#include <iisfiltp.h>

} // extern "C"

#include <stdio.h>
#include <refb.hxx>
#include <iismap.hxx>

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
/*++

Routine Description:

    Filter Init entry point

Arguments:

    pVer - filter version structure

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL fFirst;

    pVer->dwFilterVersion = MAKELONG( 0, 1 );   // Version 1.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
                     SF_NOTIFY_NONSECURE_PORT     |

                     SF_NOTIFY_AUTHENTICATIONEX   |
                     SF_NOTIFY_LOG                |

                     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "Basic authentication Filter, v1.0" );

    return TRUE;
}


DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData
    )
/*++

Routine Description:

    Filter notification entry point

Arguments:

    pfc -              Filter context
    NotificationType - Type of notification
    pvData -           Notification specific data

Return Value:

    One of the SF_STATUS response codes

--*/
{
    DWORD                 dwRet;
    BOOL                  fAllowed;
    CHAR                  achUser[SF_MAX_USERNAME];
    HTTP_FILTER_AUTHENTEX*pAuth;
    HTTP_FILTER_LOG *     pLog;
    CHAR *                pch;
    CIisMapping *         pQuery;
    CIisMapping *         pResult = NULL;
    CIisMd5Mapper *       pItaMapper = NULL;
    RefBlob*              pBlob = NULL;
    BOOL                  fFirst;
    LPSTR                 pQPwd;
    LPSTR                 pRPwd;
    LPSTR                 pPwd;

    //
    //  Handle this notification
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_AUTHENTICATIONEX:

        pAuth = (HTTP_FILTER_AUTHENTEX *) pvData;

        //
        //  Ignore the anonymous user ( mapped by IIS )
        //  Ignore non-basic authentication types
        //

        if ( !*pAuth->pszUser ||
             (_stricmp(pAuth->pszAuthType, "Basic" ) &&
              _stricmp(pAuth->pszAuthType, "User" )) )
        {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        //
        // Retrieve mapper object from IIS server
        //

        if ( !pfc->ServerSupportFunction( pfc,
                                    SF_REQ_GET_PROPERTY,
                                    (LPVOID)&pBlob,
                                    (UINT)SF_PROPERTY_GET_MD5_MAPPER,
                                    NULL ) )
        {
            return SF_STATUS_REQ_ERROR;
        }

        if ( pBlob == NULL )
        {
            // no mapper for this instance

            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        pItaMapper = (CIisMd5Mapper*)pBlob->QueryPtr();

        //
        //  Save the unmapped username so we can log it later
        //

        strcpy( achUser, pAuth->pszUser );

        //
        //  Make sure this user is a valid user and map to the appropriate
        //  Windows NT user
        //

        BOOL fSt;
        LPSTR pAcct;
        int x;

        if ( !(pQuery = pItaMapper->CreateNewMapping( pAuth->pszRealm, pAuth->pszUser )) )
        {
            pBlob->Release();
            return SF_STATUS_REQ_ERROR;
        }
        pQuery->MappingSetField(IISMMDB_INDEX_IT_MD5PWD, pAuth->pszPassword );

        //
        // Query mapping object for mapped NT account & password
        //

        pItaMapper->Lock();

        if ( ! pItaMapper->FindMatch( pQuery, &pResult )
                || !pResult->MappingGetField( IISMMDB_INDEX_NT_ACCT, &pAcct )
                || !pQuery->MappingGetField( IISMMDB_INDEX_IT_MD5PWD, &pQPwd )
                || !pResult->MappingGetField( IISMMDB_INDEX_IT_MD5PWD, &pRPwd )
                || !pResult->MappingGetField( IISMMDB_INDEX_NT_PWD, &pPwd )
                || strcmp( pQPwd, pRPwd ) )
        {
            pItaMapper->Unlock();

            SetLastError( ERROR_ACCESS_DENIED );

            delete pQuery;

            pBlob->Release();

            return SF_STATUS_REQ_ERROR;
        }

        delete pQuery;

        //
        // break in domain & user name
        // copy to local storage so we can unlock mapper object
        //

        CHAR    achDomain[64];
        CHAR    achUser[64];
        CHAR    achCookie[64];
        CHAR    achPwd[64];
        LPSTR   pSep;
        LPSTR   pUser;

#if 1 // DBCS enabling for user name
        if ( (pSep = (PCHAR)_mbschr( (PUCHAR)pAcct, '\\' )) )
#else
        if ( (pSep = strchr( pAcct, '\\' )) )
#endif
        {
            if ( (pSep - pAcct) < sizeof(achDomain) )
            {
                memcpy( achDomain, pAcct, DIFF(pSep - pAcct) );
                achDomain[pSep - pAcct] = '\0';
            }
            else
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                pItaMapper->Unlock();
                pBlob->Release();
                return SF_STATUS_REQ_ERROR;
            }
            pUser = pSep + 1;
        }
        else
        {
            achDomain[0] = '\0';
            pUser = pAcct;
        }
        if ( strlen( pUser ) >= sizeof(achUser) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            pItaMapper->Unlock();
            pBlob->Release();
            return SF_STATUS_REQ_ERROR;
        }
        strcpy( achUser, pUser );
        strcpy( achPwd, pPwd );

        pItaMapper->Unlock();
        pBlob->Release();

        //
        // Logon user
        //

        fSt = LogonUserA( achUser,
                          achDomain,
                          achPwd,
                          LOGON32_LOGON_INTERACTIVE,
                          LOGON32_PROVIDER_DEFAULT,
                          &pAuth->hAccessTokenPrimary );

        if ( !fSt )
        {
            pAuth->hAccessTokenImpersonation = NULL;

            return SF_STATUS_REQ_ERROR;
        }

        //
        //  Save the unmapped user name so we can log it later on.  We allocate
        //  enough space for two usernames so we can use this memory block
        //  for logging.  Note we may have already allocated it from a previous
        //  request on this TCP session
        //

        if ( !pfc->pFilterContext )
        {
            pfc->pFilterContext = pfc->AllocMem( pfc, 2 * SF_MAX_USERNAME + sizeof(" ()"), 0 );

            if ( !pfc->pFilterContext )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return SF_STATUS_REQ_ERROR;
            }
        }

        strcpy( (CHAR *) pfc->pFilterContext, achUser );

        return SF_STATUS_REQ_HANDLED_NOTIFICATION;

    case SF_NOTIFY_LOG:

        //
        //  The unmapped username is in pFilterContext if this filter
        //  authenticated this user
        //

        if ( pfc->pFilterContext )
        {
            pch  = (CHAR*)pfc->pFilterContext;
            pLog = (HTTP_FILTER_LOG *) pvData;

            //
            //  Put both the original username and the NT mapped username
            //  into the log in the form "Original User (NT User)"
            //

            if ( strchr( pch, '(' ) == NULL )
            {
                strcat( pch, " (" );
                strcat( pch, pLog->pszClientUserName );
                strcat( pch, ")" );
            }

            pLog->pszClientUserName = pch;
        }

        return SF_STATUS_REQ_NEXT_NOTIFICATION;

    default:

        break;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\compfile.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    compfile.c

Abstract:

    Contains routines to compress specific files for the ISAPI
    compression filter.

Author:

    David Treadwell (davidtr)   15-Oct-1997

Revision History:

--*/

#include "compfilt.h"


VOID
CompressFile (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine does the real work of compressing a static file and
    storing it to the compression directory with a unique name.

Arguments:

    Context - a pointer to context information for the request,
        including the compression scheme to use for compression and the
        physical path to the file that we need to compress.

Return Value:

    None.  If the compression fails, we just press on and attempt to
    compress the file the next time it is requested.

--*/

{
    PCOMPRESS_FILE_INFO info = (PCOMPRESS_FILE_INFO)Context;
    HANDLE hOriginalFile;
    HANDLE hCompressedFile;
    CHAR compressedFileName[MAX_PATH*2 + 100];
    CHAR realCompressedFileName[MAX_PATH*2 + 100];
    DWORD realCompressedFileNameLength;
    BOOL success;
    DWORD cbIo;
    PSUPPORTED_COMPRESSION_SCHEME scheme;
    DWORD bytesCompressed;
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;
    DWORD securityDescriptorLength;
    SECURITY_ATTRIBUTES securityAttributes;
    DWORD totalBytesWritten;
    BOOL usedScheme;
    PLARGE_INTEGER pli;
    LPTS_OPEN_FILE_INFO     pofiOriginalFile = NULL;
    TSVC_CACHE              tsvcGarbage;
    FILETIME                originalFileTime;
    PSECURITY_DESCRIPTOR    originalFileAcls = NULL;
    DWORD                   originalFileAclsLen;
    OVERLAPPED              ovlForRead;
    DWORD                   readStatus;
    ULARGE_INTEGER          readOffsset;
    SYSTEMTIME              systemTime;
    FILETIME                fileTime;

    Write(( DEST,
            "About to compress file %s with scheme %s\n",
            info->pszPhysicalPath,
            info->CompressionScheme->pszCompressionSchemeName ));

    //
    // Initialize locals so that we know how to clean up on exit.
    //

    hOriginalFile = NULL;
    hCompressedFile = NULL;
    success = FALSE;
    totalBytesWritten = 0;
    usedScheme = FALSE;

    scheme = info->CompressionScheme;

    //
    // If the scheme couldn't be initialized, bail.
    //

    if ( scheme->hDllHandle == NULL ) {
        goto exit;
    }

    //
    // Determine the name of the file to which we will write compression
    // file data.  Note that we use a bogus file name initially: this
    // allows us to rename it later and ensure an atomic update to the
    // file system, thereby preventing other threads from returning the
    // compressed file when it has only been partially written.
    //
    // If the caller specified a specific output file name, then use that
    // instead of the calculated name.
    //

    if ( info->OutputFileName == NULL ) {

        ConvertPhysicalPathToCompressedPath(
            scheme,
            info->pszPhysicalPath,
            realCompressedFileName,
            &realCompressedFileNameLength
            );

    } else {

        strcpy( realCompressedFileName, info->OutputFileName );
    }

    strcpy( compressedFileName, realCompressedFileName );
    strcat( compressedFileName, "~TMP~" );


    pofiOriginalFile = TsCreateFile( tsvcGarbage, info->pszPhysicalPath, 
                                    INVALID_HANDLE_VALUE,
                                    TS_CACHING_DESIRED | TS_NO_ACCESS_CHECK);
    if ( pofiOriginalFile != NULL)
    {
        success = CheckForExistenceOfCompressedFile ( realCompressedFileName, pofiOriginalFile, FALSE);
    }


    if ( !success &&  pofiOriginalFile != NULL) 
    {
        originalFileAcls = pofiOriginalFile->QuerySecDesc ();

        if (originalFileAcls == NULL )
        {
            goto exit;
        }

        originalFileAclsLen = GetSecurityDescriptorLength(originalFileAcls);

        if ( !pofiOriginalFile->QueryLastWriteTime (&originalFileTime) )
        {
            goto exit;
        }

        hOriginalFile = pofiOriginalFile->QueryFileHandle();

        if ( hOriginalFile == INVALID_HANDLE_VALUE ) {
            hOriginalFile = NULL;
            goto exit;
        }

        securityAttributes.nLength = originalFileAclsLen;
        securityAttributes.lpSecurityDescriptor = originalFileAcls;
        securityAttributes.bInheritHandle = FALSE;

        //
        // Do the actual file open.  We open the file for exclusive access,
        // and we assume that the file will not already exist.
        //

        hCompressedFile = CreateFile(
                              compressedFileName,
                              GENERIC_WRITE,
                              0,
                              &securityAttributes,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL
                              );
        if ( hCompressedFile == INVALID_HANDLE_VALUE ) {
            goto exit;
        }

        //
        // Loop through the file data, reading it, then compressing it, then
        // writing out the compressed data.
        //

        ovlForRead.Offset = 0;
        ovlForRead.OffsetHigh = 0;
        ovlForRead.hEvent     = NULL; 
        readOffsset.QuadPart = 0;


        while ( TRUE ) {

            success = ReadFile( hOriginalFile, IoBuffer, IoBufferSize, &cbIo, &ovlForRead);

            if (!success) 
            {  
                switch (readStatus = GetLastError())     
                {         
                case ERROR_HANDLE_EOF:
                    {
                        cbIo = 0;
                        success = TRUE;
                    }
                    break;

                case ERROR_IO_PENDING:  
                    {                                   
                        success = GetOverlappedResult(hOriginalFile, &ovlForRead, &cbIo, TRUE);  
                        if (!success) 
                        { 
                            switch (readStatus = GetLastError())     
                            { 
                                case ERROR_HANDLE_EOF:   
                                    {
                                        cbIo = 0;
                                        success = TRUE;
                                    }
                                    break;

                                default:
                                    break;
                            }
                        }
                    }
                    break;
                default:
                    break;
                }
            }

            if ( !success ) {
                goto exit;
            }

            if ( cbIo )
            {
                readOffsset.QuadPart += cbIo;
                ovlForRead.Offset = readOffsset.LowPart;
                ovlForRead.OffsetHigh = readOffsset.HighPart;
            }

            //
            // ReadFile returns zero bytes read at the end of the file.  If
            // we hit that, then break out of this loop.
            //

            if ( cbIo == 0 ) {
                break;
            }

            //
            // Remember that we used this compression scheme and that we
            // will need to reset it on exit.
            //

            usedScheme = TRUE;

            //
            // Write the compressed data to the output file.
            //

            success = CompressAndWriteData(
                          scheme,
                          IoBuffer,
                          cbIo,
                          &totalBytesWritten,
                          hCompressedFile
                          );
            if ( !success ) {
                goto exit;
            }
        }

        if ( !success ) {
            goto exit;
        }

        //
        // Tell the compression DLL that we're done with this file.  It may
        // return a last little bit of data for us to write to the the file.
        // This is because most compression schemes store an end-of-file
        // code in the compressed data stream.  Using "0" as the number of
        // bytes to compress handles this case.
        //

        success = CompressAndWriteData(
                      scheme,
                      IoBuffer,
                      0,
                      &totalBytesWritten,
                      hCompressedFile
                      );
        if ( !success ) {
            goto exit;
        }

        //
        // Set the compressed file's creation time to be identical to the
        // original file.  This allows a more granular test for things being
        // out of date.  If we just did a greater-than-or-equal time
        // comparison, then copied or renamed files might not get registered
        // as changed.
        //

        //
        // Subtract two seconds from the file time to get the file time that
        // we actually want to put on the file.  We do this to make sure
        // that the server will send a different Etag: header for the
        // compressed file than for the uncompressed file, and the server
        // uses the file time to calculate the Etag: it uses.
        //
        // We set it in the past so that if the original file changes, it
        // should never happen to get the same value as the compressed file.
        // We pick two seconds instead of one second because the FAT file
        // system stores file times at a granularity of two seconds.
        //

        pli = (PLARGE_INTEGER)(&originalFileTime);
        pli->QuadPart -= 2*10*1000*1000;

        success = SetFileTime(
                      hCompressedFile,
                      NULL,
                      NULL,
                      &originalFileTime
                      );
        if ( !success ) {
            goto exit;
        }


        CloseHandle( hCompressedFile );
        hCompressedFile = NULL;
        //
        // Turn on the system bit for this file.  We do this to help
        // distinguish files we create in the compression directory from
        // what may be user files, so that when we delete files from the
        // compression directory we only delete our own files.
        //


        success = SetFileAttributes( compressedFileName, FILE_ATTRIBUTE_SYSTEM );
        if ( !success ) {
            goto exit;
        }

        //
        // Almost done now.  Just rename the file to the proper name.
        //

        success = MoveFileEx(
                      compressedFileName,
                      realCompressedFileName,
                      MOVEFILE_REPLACE_EXISTING
                      );
        if ( !success ) {
            goto exit;
        }

        //
        // If we are configured to limit the amount of disk space we use for
        // compressed files, then update the tally of disk space used by
        // compression.  If the value is too high, then free up some space.
        //
        // Use InterlockedExchangeAdd to update this value because other
        // threads may be deleting files from the compression directory
        // because they have gone out of date.
        //

        if ( DoDiskSpaceLimiting ) {

            InterlockedExchangeAdd( (PLONG)&CurrentDiskSpaceUsage, totalBytesWritten );

            EnterCriticalSection( &CompressionDirectoryLock );

            if ( CurrentDiskSpaceUsage > MaxDiskSpaceUsage ) {
                LeaveCriticalSection( &CompressionDirectoryLock );
                FreeDiskSpace( );
            } else {
                LeaveCriticalSection( &CompressionDirectoryLock );
            }
        }
    }

    //
    // Free the context structure and return.
    //

exit:
    if ( pofiOriginalFile != NULL) 
    {
        TsCloseHandle( tsvcGarbage, pofiOriginalFile);
        hOriginalFile = NULL;
        pofiOriginalFile = NULL;
    }

#if 0
    if (!success) {
        DWORD dwError = GetLastError();
        DBGPRINTF(( DBG_CONTEXT,
            "CompressFile returned error %X\n",
            dwError ));
    }
#endif


    //
    // Reset the compression context for reuse the next time through.
    // This is more optimal than recreating the compression context for
    // every file--it avoids allocations, etc.
    //

    if ( usedScheme ) {
        scheme->ResetCompressionRoutine( scheme->CompressionContext );
    }

    if ( hCompressedFile != NULL ) {
        CloseHandle( hCompressedFile );
    }

    if ( !success ) {
        DeleteFile( compressedFileName );
    }

    if ( securityDescriptor != NULL ) {
        LocalFree( securityDescriptor );
    }

    return;

} // CompressFile


VOID
FreeDiskSpace (
    VOID
    )

/*++

Routine Description:

    If disk space limiting is in effect, this routine frees up the
    oldest compressed files to make room for new files.

Arguments:

    None.

Return Value:

    None.  This routine makes a best-effort attempt to free space, but
    if it doesn't work, oh well.

--*/

{
    WIN32_FIND_DATA **filesToDelete;
    WIN32_FIND_DATA *currentFindData;
    WIN32_FIND_DATA *findDataHolder;
    BOOL success;
    DWORD i;
    HANDLE hDirectory;
    CHAR file[MAX_PATH];

    //
    // Allocate space to hold the array of files to delete and the
    // WIN32_FIND_DATA structures that we will need.  We will find the
    // least-recently-used files in the compression directory to delete.
    // The reason we delete multpiple files is to reduce the number of
    // times that we have to go through the process of freeing up disk
    // space, since this is a fairly expensive operation.
    //

    filesToDelete = (WIN32_FIND_DATA **)LocalAlloc(
                        LMEM_FIXED,
                        sizeof(filesToDelete)*FilesDeletedPerDiskFree +
                            sizeof(WIN32_FIND_DATA)*(FilesDeletedPerDiskFree + 1)
                        );
    if ( filesToDelete == NULL ) {
        return;
    }

    //
    // Parcel out the allocation to the various uses.  The initial
    // currentFindData will follow the array, and then the
    // WIN32_FIND_DATA structures that start off in the sorted array.
    // Initialize the last access times of the entries in the array to
    // 0xFFFFFFFF so that they are considered recently used and quickly
    // get tossed from the array with real files.
    //

    currentFindData = (PWIN32_FIND_DATA)( (PCHAR)filesToDelete +
                          sizeof(filesToDelete)*FilesDeletedPerDiskFree );

    for ( i = 0; i < FilesDeletedPerDiskFree; i++ ) {
        filesToDelete[i] = currentFindData + 1 + i;
        filesToDelete[i]->ftLastAccessTime.dwLowDateTime = 0xFFFFFFFF;
        filesToDelete[i]->ftLastAccessTime.dwHighDateTime = 0x7FFFFFFF;
    }

    //
    // Start enumerating the files in the compression directory.  Do
    // this while holding the lock that protects the
    // CompressionDirectoryWildcard variable, since it is possible for
    // that string pointer to get freed if there is a metabase
    // configuration change.  Note that holding the critical section for
    // a long time is not a perf issue because, in general, only this
    // thread ever acquires this lock, except for the rare configuration
    // change.
    //

    EnterCriticalSection( &CompressionDirectoryLock );

    hDirectory = FindFirstFile( CompressionDirectoryWildcard, currentFindData );

    LeaveCriticalSection( &CompressionDirectoryLock );

    if ( hDirectory == INVALID_HANDLE_VALUE ) {
        goto exit;
    }

    while ( TRUE ) {

        //
        // Ignore this entry if it is a directory.
        //

        if ( (currentFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {

            //
            // Walk down the sorted array of files, comparing the time
            // of this file against the times of the files currently in
            // the array.  We need to find whether this file belongs in
            // the array at all, and, if so, where in the array it
            // belongs.
            //

            for ( i = 0;
                  i < FilesDeletedPerDiskFree &&
                      CompareFileTime(
                          &currentFindData->ftLastAccessTime,
                          &filesToDelete[i]->ftLastAccessTime
                          ) < 0;
                  i++ );

            //
            // If this file needs to get inserted in the array, put it
            // in and move the other entries forward.
            //

            {
                SYSTEMTIME time;

                FileTimeToSystemTime(
                    &currentFindData->ftLastAccessTime,
                    &time
                    );

                Write(( DEST,
                        "Inserting file %s position %d date %d/%d/%d "
                        "time %d:%d:%d\n",
                        currentFindData->cFileName,
                        i,
                        time.wMonth, time.wDay, time.wYear,
                        time.wHour, time.wMinute, time.wSecond ));
            }

            while ( i-- > 0 ) {
                findDataHolder = currentFindData;
                currentFindData = filesToDelete[i];
                filesToDelete[i] = findDataHolder;
            }
        }

        //
        // Get the next file in the directory.
        //

        success = FindNextFile( hDirectory, currentFindData );
        if ( !success ) {
            break;
        }
    }

    //
    // Now walk through the array of files to delete and get rid of
    // them.
    //

    for ( i = 0; i < FilesDeletedPerDiskFree; i++ ) {
        if ( filesToDelete[i]->ftLastAccessTime.dwHighDateTime != 0x7FFFFFFF ) {

            strcpy( file, CompressionDirectory );
            strcat( file, "\\" );
            strcat( file, filesToDelete[i]->cFileName );

            Write((
                DEST,
                "Deleting file %s, last access time %lx:%lx\n",
                file,
                filesToDelete[i]->ftLastAccessTime.dwHighDateTime,
                filesToDelete[i]->ftLastAccessTime.dwLowDateTime ));

            if (DeleteFile( file ))
            {
                InterlockedExchangeAdd((LPLONG)&CurrentDiskSpaceUsage,
                                       -(LONG)filesToDelete[i]->nFileSizeLow);
            }
        }
    }

exit:

    LocalFree( filesToDelete );
    FindClose( hDirectory );

    return;

} // FreeDiskSpace


BOOL
CompressAndWriteData (
    PSUPPORTED_COMPRESSION_SCHEME Scheme,
    PBYTE InputBuffer,
    DWORD BytesToCompress,
    PDWORD BytesWritten,
    HANDLE hCompressedFile
    )

/*++

Routine Description:

    Takes uncompressed data, compresses it with the specified compression
    scheme, and writes the result to the specified file.

Arguments:

    Scheme - the compression scheme to use.

    InputBuffer - the data we need to compress.

    BytesToCompress - the size of the input buffer, or 0 if we should
        flush the compression buffers to the file at the end of the
        input file.  Note that this routine DOES NOT handle compressing
        a zero-byte file; we assume that the input file has some data.

    BytesWritten - the number of bytes written to the output file.

    hCompressedFile - a handle to the file to which we should write the
        compressed results.

Return Value:

    None.  This routine makes a best-effort attempt to free space, but
    if it doesn't work, oh well.

--*/

{
    DWORD inputBytesUsed;
    DWORD bytesCompressed;
    HRESULT hResult;
    BOOL keepGoing;
    BOOL success;
    DWORD cbIo;

    if (IsTerminating) {
        return FALSE;
    }

    //
    // Perform compression on the actual file data.  Note that it is
    // possible that the compressed data is actually larger than the
    // input data, so we might need to call the compression routine
    // multiple times.
    //

    do {

        bytesCompressed = CompressionBufferSize;

        hResult = Scheme->CompressRoutine(
                      Scheme->CompressionContext,
                      InputBuffer,
                      BytesToCompress,
                      CompressionBuffer,
                      CompressionBufferSize,
                      (PLONG)&inputBytesUsed,
                      (PLONG)&bytesCompressed,
                      Scheme->OnDemandCompressionLevel
                      );
        if ( FAILED( hResult ) ) {
            return FALSE;
        }

        if ( hResult == S_OK && BytesToCompress == 0 ) {
            keepGoing = TRUE;
        } else {
            keepGoing = FALSE;
        }

        //
        // If the compressor gave us any data, then write the result to
        // disk.  Some compression schemes buffer up data in order to
        // perform better compression, so not every compression call
        // will result in output data.
        //

        if ( bytesCompressed > 0 ) {

            success = WriteFile(
                          hCompressedFile,
                          CompressionBuffer,
                          bytesCompressed,
                          &cbIo,
                          NULL
                          );
            if ( !success ) {
                return FALSE;
            }

            *BytesWritten += cbIo;
        }

        //
        // Update the number of input bytes that we have compressed
        // so far, and adjust the input buffer pointer accordingly.
        //

        BytesToCompress -= inputBytesUsed;
        InputBuffer += inputBytesUsed;

    } while ( BytesToCompress > 0 || keepGoing );

    return TRUE;

} // CompressAndWriteData


VOID
ConvertPhysicalPathToCompressedPath (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme,
    IN PSTR pszPhysicalPath,
    OUT PSTR pszCompressedPath,
    OUT PDWORD cbCompressedPath
    )

/*++

Routine Description:

    Builds a string that has the directory for the specified compression
    scheme, followed by the file name with all slashes and colons
    converted to underscores.  This allows for a flat file which
    contains all the compressed files.

Arguments:

    Scheme - the compression scheme to use.

    pszPhysicalPath - the physical file name that we want to convert.

    pszCompressedPath - the resultant string.

    cbCompressedPath - the length of the compressed path.

Return Value:

    A index to a compression scheme supported by both client and server,
    or 0xFFFFFFFF if none was found.

--*/

{
    PCHAR s;
    DWORD i;

    *cbCompressedPath = 0;

    //
    // Copy over the compression scheme name.  Don't use strcpy() so
    // that we can get the length of the output easily (strcpy returns a
    // pointer to the first input string).
    //

    EnterCriticalSection( &CompressionDirectoryLock );

    for ( i = 0; *(Scheme->pszCompressionSchemeNamePrefix + i) != '\0'; i++ ) {
        pszCompressedPath[i] = *(Scheme->pszCompressionSchemeNamePrefix + i);
    }

    LeaveCriticalSection( &CompressionDirectoryLock );

    //
    // Copy over the actual file name, converting slashes and colons
    // to underscores.
    //

    for ( s = pszPhysicalPath; *s != '\0'; s++, i++ ) {

        if (!IsDBCSLeadByte(*s)) {
            if ( *s == '\\' || *s == ':' ) {
                pszCompressedPath[i] = '_';
            } else {
                pszCompressedPath[i] = *s;
            }
        }
        else {
            pszCompressedPath[i] = *s;
            pszCompressedPath[++i] = *(++s);
        }
    }

    pszCompressedPath[i] = '\0';
    *cbCompressedPath = i + 1;

    return;

} // ConvertPhysicalPathToCompressedPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\cmdline\compress.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    compress.c

Abstract:

    A command-line application for compressing files.  Works in conjunction
    with the ISAPI compression filter.

Author:

    David Treadwell (davidtr)    15-Oct-1997

Revision History:

--*/

#include "compfilt.h"
#include <stdio.h>

void __cdecl
main (
    int argc,
    char *argv[]
    )
{
    INT err;
    DWORD i;
    BOOL result;
    COMPRESS_FILE_INFO info;
    LPTSTR lpFilePart;
    LPSTR schemeName = NULL;
    LPSTR outputName = NULL;
    PSUPPORTED_COMPRESSION_SCHEME scheme = NULL;
    DWORD compressionLevel = -1;
    CHAR test[100000];
    WIN32_FILE_ATTRIBUTE_DATA origData;
    WIN32_FILE_ATTRIBUTE_DATA newData;
    CHAR newFileName[MAX_PATH * 2 ];
    BOOL success;
    CHAR *s;

    test[0] = 1;
    test[99999] = 2;

    result = Initialize( );
    if ( !result ) {
        printf( "Initialize() failed.\n" );
        exit( 0 );
    }

    printf( "nothing", test );

    if ( argc == 1 ) {
        printf( "\n" );
        printf( "Usage: compress [options] original_file\n" );
        printf( "    Options:\n" );
        printf( "        /scheme:<scheme name> - the compression scheme to use, e.g. \"gzip\".\n" );
        printf( "        /level:<a number from 1 to 10> - the compression level to use.\n" );
        printf( "        /output:<file name> - store the output in the named file.\n" );
        printf( "\n" );
        printf( "    Examples of usage:\n" );
        printf( "        compress myfile\n" );
        printf( "            Compresses \"myfile\" with the default compfilt compression options.\n" );
        printf( "\n" );
        printf( "        compress /level:3 /scheme:deflate myfile\n" );
        printf( "            Compresses \"myfile\" with scheme deflate at level 3.\n" );
        printf( "\n" );
        printf( "        compress /output:myfile.out myfile\n" );
        printf( "            Compresses \"myfile\" with the default compfilt compression options,\n" );
        printf( "            and stores the result in myfile.out.\n" );
        printf( "\n" );
        exit(0);
    }

    for ( i = 1; i < (ULONG)argc - 1; i++ ) {

        if ( _strnicmp( argv[i], "/level:", 7 ) == 0 ) {

            compressionLevel = atoi( argv[i] + 7 );

        } else if ( _strnicmp( argv[i], "/scheme:", 8 ) == 0 ) {

            schemeName = argv[i] + 8;

        } else if ( _strnicmp( argv[i], "/output:", 8 ) == 0 ) {

            outputName = argv[i] + 8;

        } else {
            printf( "Ignoring unknown parameter \"%s\"\n", argv[i] );
        }
    }

    //
    // If the user didn't specify a compression scheme, find the first 
    // scheme that supports compression of static files and use it.  
    //

    if ( schemeName == NULL ) {

        for ( i = 0; SupportedCompressionSchemes[i] != NULL; i++ ) {
            if ( SupportedCompressionSchemes[i]->DoStaticCompression ) {
                scheme = SupportedCompressionSchemes[i];
                break;
            }
        }

    } else {

        //
        // The user did specify a scheme name.  Try to find a match with
        // our configured schemes.
        //


        for ( i = 0; SupportedCompressionSchemes[i] != NULL; i++ ) {
            if ( _stricmp(
                     SupportedCompressionSchemes[i]->pszCompressionSchemeName,
                     schemeName ) == 0 ) {
                scheme = SupportedCompressionSchemes[i];
                break;
            }
        }

        if ( scheme == NULL ) {
            printf( "compress: No scheme matches \"%s\"\n", schemeName );
            exit( 1 );
        }
    }

    if ( scheme == NULL ) {
        printf( "compress: no valid compression schemes installed.\n" );
        exit( 1 );
    }

    //
    // If the user modified the compression level from the default, use
    // that level.
    //

    if ( compressionLevel != -1 ) {
        scheme->OnDemandCompressionLevel = compressionLevel;
    }

    info.CompressionScheme = scheme;
    info.OutputFileName = outputName;
    i = GetFullPathName(
            argv[argc-1],
            sizeof(info.pszPhysicalPath),
            info.pszPhysicalPath,
            &lpFilePart
            );

    printf( "    File: \"%s\"\n    Scheme: \"%s\"\n    Level: %d\n",
                info.pszPhysicalPath,
                scheme->pszCompressionSchemeName,
                scheme->OnDemandCompressionLevel );

    CompressFile( &info );

    //
    // Get the file attributes for the original and compressed versions 
    // of the file so that we can compare the results.  
    //

    success = GetFileAttributesEx(
                  info.pszPhysicalPath,
                  GetFileExInfoStandard,
                  &origData
                  );
    if ( !success ) {
        printf( "Failed to get file data for original file: %ld\n",
                    GetLastError( ) );
        exit( 1 );
    }

    strcpy( newFileName, scheme->pszCompressionSchemeNamePrefix );

    for ( s = info.pszPhysicalPath; *s != '\0'; s++ ) {
        if ( *s == '\\' || *s == ':' ) {
            *s = '_';
        }
    }

    strcat( newFileName, info.pszPhysicalPath );

    success = GetFileAttributesEx(
                  newFileName,
                  GetFileExInfoStandard,
                  &newData
                  );
    if ( !success ) {
        printf( "Failed to get file data for new file: %ld\n",
                    GetLastError( ) );
        exit( 1 );
    }

    printf( "Original size: %ld; compressed size: %ld; compressed is %ld%% of original.\n",
                origData.nFileSizeLow, newData.nFileSizeLow,
                (newData.nFileSizeLow * 100) / origData.nFileSizeLow );


    exit( 0 );

} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\filter\endreq.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    endreq.c

Abstract:

    This module handles the SF_NOTIFY_END_OF_REQUEST notification for the
    ISAPI compression filter.

Author:

    David Treadwell (davidtr)   19-July-1997

Revision History:

--*/

#include "compfilt.h"


DWORD
OnEndOfRequest(
    IN PHTTP_FILTER_CONTEXT pfc
    )
{
    HTTP_FILTER_RAW_DATA data;
    PCOMPFILT_FILTER_CONTEXT filterContext;
    DWORD dwRet;

    Write(( DEST,
            "%d [OnEndOfRequest] Notification\n",
            pfc->pFilterContext ));

    //
    // If no context structure has been allocated, then bail.  A previous
    // allocation attempt must have failed, or it was a static request.
    //

    filterContext = (PCOMPFILT_FILTER_CONTEXT)GET_COMPFILT_CONTEXT( pfc );

    if ( filterContext == NULL ) {
        SET_REQUEST_DONE( pfc );
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    //
    // Remember that we're inside the end of request notification.  We
    // need to do this so that if and when we call WriteClient, the server
    // will call us back with another SEND_RAW notification which we
    // need to ignore.
    //

    filterContext->InEndOfRequest = TRUE;

    //
    // If this is a static file request which has already been handled,
    // then we don't need to do anything here.  Also bail if we're
    // getting the end of request before we believe that the full header
    // has passed, or if there was no matching scheme.
    //

    if ( filterContext->RequestHandled || !filterContext->HeaderPassed ||
             filterContext->Scheme == NULL ) {
        SET_REQUEST_DONE( pfc );
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    //
    // Just fake up an HTTP_FILTER_RAW_DATA request that has no data
    // and let it handle any compression, etc.  The zero-data
    // aspect will cause the compression code to finish up with anything
    // it might give us.
    //

    data.pvInData = NULL;
    data.cbInData = 0;
    data.cbInBuffer = 0;
    data.dwReserved = 0;

    dwRet = OnSendRawData( pfc, &data, TRUE );

    //
    // Clean up the compression context that we were using.
    //

    if ( filterContext->CompressionContext != NULL ) {
        filterContext->Scheme->DestroyCompressionRoutine(
            filterContext->CompressionContext
            );
        filterContext->CompressionContext = NULL;
    }

    //
    // Since we used AllocMem, the server will automatically clean up the
    // COMPFILT_FILTER_CONTEXT structure for us.
    //

    SET_REQUEST_DONE( pfc );
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\filter\compfilt.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    compfilt.c

Abstract:

    Implements an ISAPI filter which does compression, including support
    for the HTTP 1.1 Content-Encoding and Accept-Encoding headers.

Author:

    David Treadwell (davidtr)   7-April-1997

Revision History:

--*/

#include "compfilt.h"
#include "resource.hxx"


BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    )
{
    Write(( DEST,
            "Compression Filter TerminateExtension() called\n" ));

    //
    // Do termination, including freeing up resources, killing the
    // compression thread, etc.
    //

    Terminate( );

    return TRUE;
}

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
    BOOL success;

    Write(( DEST,
            "[GetFilterVersion] Server filter version is %d.%d\n",
            HIWORD( pVer->dwServerFilterVersion ),
            LOWORD( pVer->dwServerFilterVersion ) ));

    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    //
    // Initialize internal data structures.
    //

    success = Initialize( );
    if ( !success ) {
        return FALSE;
    }

    //
    // Initialize the compression thread.
    //

    success = InitializeCompressionThread( );
    if ( !success ) {
        return FALSE;
    }

    //
    // Specify the types and order of notification.  Always listen for
    // URL_MAP, and for SEND_RAW_DATA and END_OF_REQUEST if there is at
    // least one dynamic compression scheme configured.
    //

    NotificationFlags = SF_NOTIFY_ORDER_HIGH;

    if ( DoStaticCompression || DoDynamicCompression ) {
        NotificationFlags = SF_NOTIFY_URL_MAP |
                            SF_NOTIFY_SEND_RESPONSE ;
    }

    if ( DoDynamicCompression ) {
        NotificationFlags |= SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_END_OF_REQUEST;
    }


    pVer->dwFlags = NotificationFlags;
    LoadString(GetModuleHandle("compfilt.dll"),
               IDS_FILTER_NAME,
               pVer->lpszFilterDesc,
               SF_MAX_FILTER_DESC_LEN);

    //
    // All is go!
    //

    return TRUE;

} // GetFilterVersion


DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
{
    DWORD dwRet;

    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
    {

    case SF_NOTIFY_URL_MAP:

        dwRet = OnUrlMap( pfc, (PHTTP_FILTER_URL_MAP)pvData );
        break;

    case SF_NOTIFY_SEND_RAW_DATA:

        dwRet = OnSendRawData( pfc, (PHTTP_FILTER_RAW_DATA)pvData, FALSE );
        break;


    case SF_NOTIFY_END_OF_REQUEST:

        dwRet = OnEndOfRequest( pfc );
        break;

    case SF_NOTIFY_SEND_RESPONSE:

        dwRet = OnSendResponse( pfc, (PHTTP_FILTER_SEND_RESPONSE)pvData );
        break;

    default:
        Write(( DEST,
                "[HttpFilterProc] Unknown notification type, %d\n",
                NotificationType ));

        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwRet;

} // HttpFilterProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\filter\compthrd.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    compthrd.c

Abstract:

    Contains the code for the on-demand compression thread.  This
    thread compresses static files and stores them to a temporary directory
    for later usage by the web server.

Author:

    David Treadwell (davidtr)   11-April-1997

Revision History:

--*/

#include "compfilt.h"
#include <pudebug.h>


BOOL
InitializeCompressionThread (
    VOID
    )

/*++

Routine Description:

    This routine initializes the compression thread.  The purpose of the
    compression thread is to do on-demand compression of static files.
    It is a low-priority thread that compresses one file at a time,
    thereby reducing the load on the system devoted to compression.

Arguments:

    None.

Return Value:

    TRUE if the compression thread was successfully initialized, else
    FALSE.

--*/

{
    DWORD threadId;

    //
    // Initialize the work queue list.
    //

    InitializeListHead( &CompressionThreadWorkQueue );

    //
    // Initialize the critical section that protects the compression
    // work queue list.
    //

    INITIALIZE_CRITICAL_SECTION( &CompressionThreadLock );

    //
    // Create the event that we'll use for the on-demand compression
    // event.
    //

    hThreadEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( hThreadEvent == NULL ) {
        return FALSE;
    }

    //
    // Initialize the on-demand compression thread.  This thread
    // handles compression of static files, putting the compressed
    // versions in the above directories.
    //


    CompressionThreadHandle = CreateThread(
                                  NULL,
                                  0,
                                  CompressionThread,
                                  NULL,
                                  0,
                                  &threadId
                                  );

    if ( CompressionThreadHandle == NULL ) {
        return FALSE;
    }

    //
    // This will be a low-priority thread.  We do not want it to
    // interfere with the normal operation of the Web server.  Note that
    // there is really nothing interesting we can do if this call fails,
    // so we ignore the return code on SetThreadPriority.
    //

    SetThreadPriority( CompressionThreadHandle, THREAD_PRIORITY_LOWEST );

    return TRUE;

} // InitializeCompressionThread


DWORD
CompressionThread (
    IN PVOID Dummy
    )

/*++

Routine Description:

    This is the routine that drives the compression thread.  It is the
    first thing called by the system for the compression thread, and it
    handles looping and initial request processing.

Arguments:

    Not used.

Return Value:

    Not relevent.

--*/

{
    DWORD result;
    PLIST_ENTRY listEntry;
    PCOMPRESSION_WORK_ITEM workItem;
    BOOL terminate = FALSE;
    BOOL success;
    PCOMPRESS_FILE_INFO info;

    //
    // Loop forever dispatching requests.
    //

    while ( !terminate ) {

        //
        // Wait for the event that tells us there is work in our queue.
        // If the wait fails, there isn't much we can do about it, so
        // just wait a second and retry the wait.
        //

        result = WaitForSingleObject( hThreadEvent, INFINITE );
        if ( result == WAIT_FAILED ) {
            Sleep( 1000 );
            continue;
        }

        //
        // Acquire the lock that protects the list of work items.
        //

        EnterCriticalSection( &CompressionThreadLock );

        //
        // Loop pulling off work items as long as the list is not empty.
        //

        while ( !IsListEmpty( &CompressionThreadWorkQueue ) ) {

            //
            // Remove the first entry from the list.
            //

            listEntry = RemoveHeadList( &CompressionThreadWorkQueue );

            workItem = CONTAINING_RECORD(
                           listEntry,
                           COMPRESSION_WORK_ITEM,
                           ListEntry
                           );

            //
            // Decrement the count of entries in the queue.
            //

            CurrentQueueLength--;

            //
            // Release the lock, since we do not want to be holding it
            // around potentially long calls to do work like compressing a
            // large file.
            //

            LeaveCriticalSection( &CompressionThreadLock );

            //
            // If the work routine is NULL, then we're being asked to
            // terminate this thread.  Returning from this function will
            // accomplish that.
            //

            if ( workItem->WorkRoutine == NULL ) {

                //
                // Remember that we're terminating.  This will cause us
                // not to process any more work items, but we'll keep
                // going so that we free them all correctly.
                //

                terminate = TRUE;

            } else if ( !terminate ) {

                info = (PCOMPRESS_FILE_INFO)(workItem->Context);

                if (info->CompressionScheme == ID_FOR_FILE_DELETION_ROUTINE)
                {
                    success = DeleteFile (info->pszPhysicalPath);

                    // no need for this assert we can fail is somebody deleted file.
                    //DBG_ASSERT( success );

                }
                else
                {

                    //
                    // Call the routine specified in the work item.
                    //

                    workItem->WorkRoutine( workItem->Context );
                }
            }

            //
            // Free the work item structure and continue looping and
            // processing work items.  Note that we cannot free the work
            // item until after calling the work routine, since the work
            // routine is allowed to use the memory.
            //

            LocalFree( workItem );

            //
            // Reacquire the lock for the next pass through the loop.
            //

            EnterCriticalSection( &CompressionThreadLock );
        }

        LeaveCriticalSection( &CompressionThreadLock );
    }

    CloseHandle(hThreadEvent);
    hThreadEvent = NULL;
    return 0;

} // CompressionThread


BOOL
QueueWorkItem (
    IN PWORKER_THREAD_ROUTINE WorkRoutine,
    IN PVOID Context,
    IN PCOMPRESSION_WORK_ITEM WorkItem OPTIONAL,
    IN BOOLEAN MustSucceed,
    IN BOOLEAN QueueAtHead
    )

/*++

Routine Description:

    This is the low-level routine that handles queuing work items to the
    compression thread.

Arguments:

    WorkRoutine - the routine that the compression thread should call
        to do work.  If NULL, then the call is an indication to the
        compression thread that it should terminate.

    Context - a context pointer which is passed to WorkRoutine.

    WorkItem - if not NULL, this is a pointer to the work item to use
        for this request.  If NULL, then this routine will allocate a
        work item to use.  Note that by passing in a work item, the
        caller agrees to give up control of the memory: we will free it
        as necessary, either here or in the compression thread.

    MustSucceed - if TRUE, then this request is not subject to the
        limits on the number of work items that can be queued at any one
        time.

    QueueAtHead - if TRUE, then this work item is placed at the head
        of the queue to be serviced immediately.

Return Value:

    TRUE if the queuing succeeded.

--*/

{
    //
    // First allocate a work item structure to use to queue in the list.
    //

    if ( WorkItem == NULL ) {
        WorkItem = (PCOMPRESSION_WORK_ITEM)
                       LocalAlloc( LMEM_FIXED, sizeof(*WorkItem) );
    }

    if ( WorkItem == NULL ) {
        return FALSE;
    }

    //
    // Initialize this structure with the necessary information.
    //

    WorkItem->WorkRoutine = WorkRoutine;
    WorkItem->Context = Context;

    //
    // Acquire the lock that protects the work queue list test to see
    // how many items we have on the queue.  If this is not a "must
    // succeed" request and if we have reached the configured queue size
    // limit, then fail this request.  "Must succeed" requests are used
    // for thread shutdown and other things which we really want to
    // work.
    //

    EnterCriticalSection( &CompressionThreadLock );

    if ( !MustSucceed && CurrentQueueLength >= MaxQueueLength ) {
        LeaveCriticalSection( &CompressionThreadLock );
        LocalFree( WorkItem );
        return FALSE;
    }

    //
    // All looks good, so increment the count of items on the queue and
    // add this item to the queue.
    //

    CurrentQueueLength++;

    if ( QueueAtHead ) {
        InsertHeadList( &CompressionThreadWorkQueue, &WorkItem->ListEntry );
    } else {
        InsertTailList( &CompressionThreadWorkQueue, &WorkItem->ListEntry );
    }

    LeaveCriticalSection( &CompressionThreadLock );

    //
    // Signal the event that will cause the compression thread to wake
    // up and process this work item.
    //

    SetEvent( hThreadEvent );

    return TRUE;

} // QueueWorkItem


BOOL
QueueCompressFile (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme,
    IN PSTR pszPhysicalPath,
    IN FILETIME *pftOriginalLastWriteTime
    )

/*++

Routine Description:

    Queues a compress file request to the compression thread.

Arguments:

    Scheme - a pointer to the compression scheme to use in compressing
        the file.

    pszPhysicalPath - the current physical path to the file.

Return Value:

    TRUE if the queuing succeeded.

--*/

{
    PCOMPRESS_FILE_INFO compressFileInfo;

    //
    // Allocate space to hold the necessary information for file
    // compression.
    //

    compressFileInfo = (PCOMPRESS_FILE_INFO)
                           LocalAlloc( LMEM_FIXED, sizeof(*compressFileInfo) );
    if ( compressFileInfo == NULL ) {
        return FALSE;
    }

    //
    // Initialize this structure with the necessary information.
    //

    compressFileInfo->CompressionScheme = Scheme;
    compressFileInfo->OutputFileName = NULL;
    compressFileInfo->ftOriginalLastWriteTime = *pftOriginalLastWriteTime;
    strcpy( compressFileInfo->pszPhysicalPath, pszPhysicalPath );

    //
    // Queue a work item and we're done.
    //

    return QueueWorkItem(
               CompressFile,
               compressFileInfo,
               &compressFileInfo->WorkItem,
               FALSE,
               FALSE
               );

} // QueueCompressFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\init.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Contains initialization routines and global data for the ISAPI
    compression filter.

Author:

    David Treadwell (davidtr)   8-April-1997

Revision History:

--*/

#define INITGUID
#include "compfilt.h"
#include <pudebug.h>

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

#define INVALID_BOOLEAN 0xFFFFFFFF
#define INVALID_DWORD   0xBADF000D
#define COMP_FILE_PREFIX "$^~_"
#define METABASE_KEY_NAME L"/lm/w3svc/Filters/Compression"
#define METABASE_PARAMS_SUBKEY_NAME L"Parameters"
#define METABASE_DEFAULT_TIMEOUT       5000

//
// The class for the metabase change notify sink.
//

class CImpIADMCOMSINKW : public IMSAdminBaseSinkW {

public:

    CImpIADMCOMSINKW();
    ~CImpIADMCOMSINKW();


    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT STDMETHODCALLTYPE SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]);

    HRESULT STDMETHODCALLTYPE ShutdownNotify( void);

    VOID
    CImpIADMCOMSINKW::SetMDPointer(IMSAdminBaseW *pcCom)
    {
        m_pcCom = pcCom;
    }

private:

    ULONG m_dwRefCount;
    IMSAdminBaseW *m_pcCom;
};


//
// Global data structures.
//

PSUPPORTED_COMPRESSION_SCHEME SupportedCompressionSchemes[100];

LPSTR CompressionDirectory;
LPSTR CacheControlHeader;
LPSTR ExpiresHeader;
BOOL DoDynamicCompression;
BOOL DoStaticCompression;
BOOL DoOnDemandCompression;
BOOL DoDiskSpaceLimiting;
BOOL NoCompressionForHttp10;
BOOL NoCompressionForProxies;
BOOL NoCompressionForRangeRequests;
BOOL SendCacheHeaders;
DWORD MaxDiskSpaceUsage;
DWORD IoBufferSize;
PBYTE IoBuffer;
DWORD CompressionBufferSize;
PBYTE CompressionBuffer;
DWORD MaxQueueLength;
DWORD FilesDeletedPerDiskFree;
DWORD MinFileSizeForCompression;

CHAR CompressionDirectoryWildcard[MAX_PATH];
CRITICAL_SECTION CompressionDirectoryLock;
HANDLE hThreadEvent;
LIST_ENTRY CompressionThreadWorkQueue;
CRITICAL_SECTION CompressionThreadLock;
DWORD CurrentQueueLength = 0;
DWORD CurrentDiskSpaceUsage = 0;
HANDLE CompressionThreadHandle = NULL;
BOOL CompressionVolumeIsFat;
DWORD NotificationFlags = 0;

IMSAdminBase *pcAdmCom = NULL;
IConnectionPoint *pConnPoint = NULL;
IConnectionPointContainer *pConnPointContainer = NULL;
CImpIADMCOMSINKW *pEventSink = NULL;
DWORD dwSinkNotifyCookie;
BOOL InitializedSink = FALSE;
BOOL IsTerminating = FALSE;


//
// Defines used to optimize the notification handler.
// Update if the metabase values in GlobalMetabaseData change.
//

#define MIN_MD_COMPRESSION_GLOBAL_ID  MD_HC_COMPRESSION_DIRECTORY
#define MAX_MD_COMPRESSION_GLOBAL_ID  MD_HC_MIN_FILE_SIZE_FOR_COMP

METABASE_DATA GlobalMetabaseData[] = {
    { MD_HC_COMPRESSION_DIRECTORY,        // dwIdentifier
          EXPANDSZ_METADATA,              // dwValueType
          &CompressionDirectory,          // pvResult
          0,                              // dwOffset
          L"%windir%\\IIS Temporary Compressed Files",
          0,                              // dwMinimum
          0,                              // dwMaximum
          CompressionDirectoryChangeHandler // pChangeHandler
          },

    { MD_HC_CACHE_CONTROL_HEADER,         // dwIdentifier
          STRING_METADATA,                // dwValueType
          &CacheControlHeader,            // pvResult
          0,                              // dwOffset
          L"max-age=86400",               // DefaultValue
          0,                              // dwMinimum
          0,                              // dwMaximum
          NULL,                           // pChangeHandler
          },

    { MD_HC_EXPIRES_HEADER,               // dwIdentifier
          STRING_METADATA,                // dwValueType
          &ExpiresHeader,                 // pvResult
          0,                              // dwOffset
          L"Wed, 01 Jan 1997 12:00:00 GMT",// DefaultValue
          0,                              // dwMinimum
          0,                              // dwMaximum
          NULL                            // pChangeHandler
          },

    { MD_HC_DO_DYNAMIC_COMPRESSION,       // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &DoDynamicCompression,          // pvResult
          0,                              // dwOffset
          (PVOID)FALSE,                   // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          DoDynamicChangeHandler          // pChangeHandler
          },

    { MD_HC_DO_STATIC_COMPRESSION,        // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &DoStaticCompression,           // pvResult
          0,                              // dwOffset
          (PVOID)FALSE,                    // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          DoStaticChangeHandler           // pChangeHandler
          },

    { MD_HC_DO_ON_DEMAND_COMPRESSION,     // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &DoOnDemandCompression,         // pvResult
          0,                              // dwOffset
          (PVOID)TRUE,                    // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_DO_DISK_SPACE_LIMITING,       // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &DoDiskSpaceLimiting,           // pvResult
          0,                              // dwOffset
          (PVOID)FALSE,                   // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          DoDiskSpaceChangeHandler        // pChangeHandler
          },

    { MD_HC_NO_COMPRESSION_FOR_HTTP_10,   // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &NoCompressionForHttp10,        // pvResult
          0,                              // dwOffset
          (PVOID)TRUE,                    // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_NO_COMPRESSION_FOR_PROXIES,   // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &NoCompressionForProxies,       // pvResult
          0,                              // dwOffset
          (PVOID)FALSE,                   // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_NO_COMPRESSION_FOR_RANGE,     // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &NoCompressionForRangeRequests, // pvResult
          0,                              // dwOffset
          (PVOID)TRUE,                    // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_SEND_CACHE_HEADERS,           // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &SendCacheHeaders,              // pvResult
          0,                              // dwOffset
          (PVOID)TRUE,                    // DefaultValue
          0,                              // dwMinimum
          1,                              // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_MAX_DISK_SPACE_USAGE,         // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &MaxDiskSpaceUsage,             // pvResult
          0,                              // dwOffset
          (PVOID)1000000,                 // DefaultValue
          0,                              // dwMinimum
          0xFFFFFFFF,                     // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_IO_BUFFER_SIZE,               // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &IoBufferSize,                  // pvResult
          0,                              // dwOffset
          (PVOID)8192,                    // DefaultValue
          256,                            // dwMinimum
          0x100000,                       // dwMaximum
          NULL                            // pChangeHandler
          },

    { MD_HC_COMPRESSION_BUFFER_SIZE,      // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &CompressionBufferSize,         // pvResult
          0,                              // dwOffset
          (PVOID)8192,                    // DefaultValue
          1024,                           // dwMinimum
          0x100000,                       // dwMaximum
          NULL                            // pChangeHandler
          },

    { MD_HC_MAX_QUEUE_LENGTH,             // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &MaxQueueLength,                // pvResult
          0,                              // dwOffset
          (PVOID)1000,                    // DefaultValue
          0,                              // dwMinimum
          10000,                          // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_FILES_DELETED_PER_DISK_FREE,  // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &FilesDeletedPerDiskFree,       // pvResult
          0,                              // dwOffset
          (PVOID)256,                     // DefaultValue
          1,                              // dwMinimum
          1024,                           // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { MD_HC_MIN_FILE_SIZE_FOR_COMP,       // dwIdentifier
          DWORD_METADATA,                 // dwValueType
          &MinFileSizeForCompression,     // pvResult
          0,                              // dwOffset
          (PVOID)1,                       // DefaultValue
          0,                              // dwMinimum
          0xFFFFFFFF,                     // dwMaximum
          GlobalMetabaseChangeHandler     // pChangeHandler
          },

    { 0, 0, NULL, 0, NULL, 0, NULL, 0 }
};

METABASE_DATA SchemeMetabaseData[] = {
    { MD_HC_COMPRESSION_DLL,
          EXPANDSZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, pszCompressionDll ),
          NULL,
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_DYNAMIC_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoDynamicCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_STATIC_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoStaticCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_ON_DEMAND_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoOnDemandCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_FILE_EXTENSIONS,
          MULTISZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ppszFileExtensions ),
          NULL,
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_SCRIPT_FILE_EXTENSIONS,
          MULTISZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ppszScriptFileExtensions ),
          NULL,
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_MIME_TYPE,
          STRING_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, pszMimeType ),
          NULL,
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_PRIORITY,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, dwPriority ),
          (PVOID)1,
          0,
          1000,
          NULL                            // pChangeHandler
          },
    { MD_HC_DYNAMIC_COMPRESSION_LEVEL,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DynamicCompressionLevel ),
          (PVOID)0,
          0,
          10,
          NULL                            // pChangeHandler
          },
    { MD_HC_ON_DEMAND_COMP_LEVEL,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, OnDemandCompressionLevel ),
          (PVOID)10,
          0,
          10,
          NULL                            // pChangeHandler
          },
    { MD_HC_CREATE_FLAGS,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, CreateFlags ),
          (PVOID)0,
          0,
          0xFFFFFFFF,
          NULL                            // pChangeHandler
          },
    { 0, 0, NULL, 0, NULL, 0, NULL, 0 }
};

METABASE_DATA GzipData[] = {
    { MD_KEY_TYPE,
          STRING_METADATA,
          NULL,
          0,
          L"IIsCompressionScheme",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_COMPRESSION_DLL,
          EXPANDSZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, pszCompressionDll ),
          L"%windir%\\system32\\inetsrv\\gzip.dll",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_DYNAMIC_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoDynamicCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_STATIC_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoStaticCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_ON_DEMAND_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoOnDemandCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_FILE_EXTENSIONS,
          MULTISZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ppszFileExtensions ),
          L"htm\0html\0txt\0\0",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_SCRIPT_FILE_EXTENSIONS,
          MULTISZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ppszScriptFileExtensions ),
          L"asp\0dll\0exe\0\0",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_MIME_TYPE,
          STRING_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, pszMimeType ),
          L"",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_PRIORITY,
          DWORD_METADATA,
          (PVOID)5,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, dwPriority ),
          (PVOID)1,
          0,
          1000,
          NULL                            // pChangeHandler
          },
    { MD_HC_DYNAMIC_COMPRESSION_LEVEL,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DynamicCompressionLevel ),
          (PVOID)0,
          0,
          10,
          NULL                            // pChangeHandler
          },
    { MD_HC_ON_DEMAND_COMP_LEVEL,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, OnDemandCompressionLevel ),
          (PVOID)10,
          0,
          10,
          NULL                            // pChangeHandler
          },
    { MD_HC_CREATE_FLAGS,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, CreateFlags ),
          (PVOID)1,
          0,
          0xFFFFFFFF,
          NULL                            // pChangeHandler
          },
    { 0, 0, NULL, 0, NULL, 0, NULL, 0 }
};

METABASE_DATA DeflateData[] = {
    { MD_KEY_TYPE,
          STRING_METADATA,
          NULL,
          0,
          L"IIsCompressionScheme",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_COMPRESSION_DLL,
          EXPANDSZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, pszCompressionDll ),
          L"%windir%\\system32\\inetsrv\\gzip.dll",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_DYNAMIC_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoDynamicCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_STATIC_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoStaticCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_DO_ON_DEMAND_COMPRESSION,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DoOnDemandCompression ),
          (PVOID)TRUE,
          0,
          1,
          NULL                            // pChangeHandler
          },
    { MD_HC_FILE_EXTENSIONS,
          MULTISZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ppszFileExtensions ),
          L"htm\0html\0txt\0\0",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_SCRIPT_FILE_EXTENSIONS,
          MULTISZ_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ppszScriptFileExtensions ),
          L"asp\0dll\0exe\0\0",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_MIME_TYPE,
          STRING_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, pszMimeType ),
          L"",
          0,
          0,
          NULL                            // pChangeHandler
          },
    { MD_HC_PRIORITY,
          DWORD_METADATA,
          (PVOID)5,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, dwPriority ),
          (PVOID)1,
          0,
          1000,
          NULL                            // pChangeHandler
          },
    { MD_HC_DYNAMIC_COMPRESSION_LEVEL,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DynamicCompressionLevel ),
          (PVOID)0,
          0,
          10,
          NULL                            // pChangeHandler
          },
    { MD_HC_ON_DEMAND_COMP_LEVEL,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, OnDemandCompressionLevel ),
          (PVOID)10,
          0,
          10,
          NULL                            // pChangeHandler
          },
    { MD_HC_CREATE_FLAGS,
          DWORD_METADATA,
          NULL,
          FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, CreateFlags ),
          (PVOID)0,
          0,
          0xFFFFFFFF,
          NULL                            // pChangeHandler
          },
    { 0, 0, NULL, 0, NULL, 0, NULL, 0 }
};

struct {
    PSTR RoutineName;
    DWORD RoutineOffset;
} CompressionRoutines[] = {
    { "InitCompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, InitCompressionRoutine ) },
    { "InitDecompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, InitDecompressionRoutine ) },
    { "DeInitCompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DeinitCompressionRoutine ) },
    { "DeInitDecompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DeinitDecompressionRoutine ) },
    { "CreateCompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, CreateCompressionRoutine ) },
    { "CreateDecompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, CreateDecompressionRoutine ) },
    { "Compress", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, CompressRoutine ) },
    { "Decompress", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DecompressRoutine ) },
    { "DestroyCompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DestroyCompressionRoutine ) },
    { "DestroyDecompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, DestroyDecompressionRoutine ) },
    { "ResetCompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ResetCompressionRoutine ) },
    { "ResetDecompression", FIELD_OFFSET( SUPPORTED_COMPRESSION_SCHEME, ResetDecompressionRoutine ) },
    { NULL, 0 }
};

#if DBG
BOOL EnableDbgPrints = FALSE;
#endif



BOOL
Initialize (
    VOID
    )

/*++

Routine Description:

    Performs initialization of all data structures used by the compression
    filter.

Arguments:

    None.

Return Value:

    TRUE if all initialization succeeded, else FALSE if there was any
    failure.  In the event of failure, the filter will not function
    successfully.

--*/

{
    BOOL success;
    PSUPPORTED_COMPRESSION_SCHEME scheme;
    DWORD result;
    DWORD disposition;
    DWORD i;

    HRESULT hRes;
    IClassFactory *pcsfFactory = NULL;
    COSERVERINFO *pcsiParam = NULL;
    METADATA_RECORD mdrMDData;
    DWORD bytesRequired;
    BOOL initializedCom = FALSE;
    METADATA_HANDLE hmdParentHandle;

    //
    // Do initialization.  Perform the necessary steps to get the metabase
    // COM interface pointer, and then open the key that contains compression
    // configuration data.
    //
    // First, initialize COM.
    //

    hRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( hRes == RPC_E_CHANGED_MODE ) {
        hRes = CoInitialize( NULL );
    }

    if ( FAILED(hRes) ) {
        goto error_exit;
    }

    initializedCom = TRUE;

    hRes = CoGetClassObject(
               GETAdminBaseCLSID( TRUE ),
               CLSCTX_SERVER,
               pcsiParam,
               IID_IClassFactory,
               (void**)&pcsfFactory
               );

    if ( FAILED(hRes) ) {

        goto error_exit;

    } else {

        hRes = pcsfFactory->CreateInstance(
                   NULL,
                   IID_IMSAdminBase,
                   (PVOID *)&pcAdmCom
                   );

        if (FAILED(hRes)) {
            pcsfFactory->Release();
            goto error_exit;
        }

        pcsfFactory->Release();
    }

    //
    // Open the path to the key that contains all compression metabase
    // information.
    //

    hRes = pcAdmCom->OpenKey(
               METADATA_MASTER_ROOT_HANDLE,
               METABASE_KEY_NAME,
               METADATA_PERMISSION_READ,
               METABASE_DEFAULT_TIMEOUT,
               &hmdParentHandle
               );

    if ( FAILED(hRes) ) {
        pcAdmCom->Release();
        goto error_exit;
    }

    //
    // Walk through the list of global values that we need.
    //

    for ( i = 0; GlobalMetabaseData[i].dwIdentifier != 0; i++ ) {
        ReadMetabaseValue(
            hmdParentHandle,
            METABASE_PARAMS_SUBKEY_NAME,
            GlobalMetabaseData[i].dwIdentifier,
            GlobalMetabaseData[i].dwValueType,
            GlobalMetabaseData[i].pvResult,
            GlobalMetabaseData[i].DefaultValue,
            GlobalMetabaseData[i].dwMinimum,
            GlobalMetabaseData[i].dwMaximum
            );
    }

    //
    // Read all the compression schemes supported on this machine.
    //

    success = ReadCompressionSchemes( hmdParentHandle );
    if ( !success ) {
        goto error_exit;
    }

    //
    // Initialize the metabase change notification mechanism so that we
    // can immediately respond to config changes.  If this fails for
    // whatever reason, then just ignore the failure.
    //
    // !!! Should we eventlog failures?
    //

    pEventSink = new CImpIADMCOMSINKW();

    DBG_ASSERT(pEventSink != NULL);

    if ( pEventSink == NULL )
        goto error_exit;

    hRes = pcAdmCom->QueryInterface(
               IID_IConnectionPointContainer,
               (PVOID *)&pConnPointContainer
               );

    if ( SUCCEEDED( hRes ) ) {

        //
        // Find the requested Connection Point. This AddRef's the
        // returned pointer.
        //

        hRes = pConnPointContainer->FindConnectionPoint(
                   IID_IMSAdminBaseSink_W,
                   &pConnPoint
                   );

        if ( SUCCEEDED(hRes) ) {

            hRes = pConnPoint->Advise(
                       (IMSAdminBaseW *)pEventSink,
                       &dwSinkNotifyCookie
                       );
            if ( SUCCEEDED(hRes) ) {
                InitializedSink = TRUE;
            }
        } else {

            DBG_ASSERT( FALSE );

            pConnPoint->Release();
            pConnPointContainer->Release( );
            delete pEventSink;
            pEventSink = NULL;
        }

    } else {

        delete pEventSink;
        pEventSink = NULL;
    }

    //
    // Allocate the buffers that we'll use for I/O and compression.
    //

    IoBuffer = (PBYTE)LocalAlloc( LMEM_FIXED, IoBufferSize );
    if ( IoBuffer == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    CompressionBuffer = (PBYTE)LocalAlloc( LMEM_FIXED, CompressionBufferSize );
    if ( CompressionBuffer == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    //
    // Initialize the lock that protects strings having to do with the
    // compression directory.  These are the things that can change when
    // the compression configured directory changes.  This includes the
    // following:
    //
    //     CompressionDirectory
    //     CompressionDirectoryWildcard
    //     scheme->pszCompressionSchemeNamePrefix
    //

    INITIALIZE_CRITICAL_SECTION( &CompressionDirectoryLock );

    success = InitializeCompressionDirectory( );
    if ( !success ) {
        goto error_exit;
    }

    //
    // Close the metabase key handle we used above.
    //

    hRes = pcAdmCom->CloseKey( hmdParentHandle );
    if (FAILED(hRes))
    {
        pcAdmCom->Release();
        goto error_exit;
    }

    return TRUE;

error_exit:

    if ( initializedCom ) {
        CoUninitialize( );
    }

    return FALSE;

} // Initialize


BOOL
InitializeCompressionDirectory (
    VOID
    )

/*++

Routine Description:

    Initializes data structures associated with the compression directory
    string.  This is a separate routine to allow for the compression
    directory to change dynamically after the server/filter have already
    started.

Arguments:

    None -- operates off global variables.

Return Value:

    TRUE if the initialization was successful.  If there was an error,
    the previous compression directory information remains unchanged.

--*/

{
    WIN32_FILE_ATTRIBUTE_DATA fileInformation;
    BOOL success;
    CHAR volumeRoot[10];
    DWORD fileSystemFlags;
    CHAR fileSystemName[256];
    DWORD maximumComponentLength;
    DWORD i;

    //
    // Make sure that all the root compression directory exists.
    //

    success = GetFileAttributesEx(
                  CompressionDirectory,
                  GetFileExInfoStandard,
                  &fileInformation
                  );

    if ( !success ) {

        success = CreateDirectory( CompressionDirectory, NULL );
        if ( !success ) {
            return FALSE;
        }

    } else {

        //
        // Check if the compression directory is a file, and fail if so.
        //

        if ( (fileInformation.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ==
                 0 ) {
            SetLastError( ERROR_PATH_NOT_FOUND );
            return FALSE;
        }
    }

    //
    // Determine how much disk space is already in use for the
    // compression directory.  Do this by enumerating all the files in
    // the compression directory and simply adding up the sizes.
    //

    strcpy( CompressionDirectoryWildcard, CompressionDirectory );
    strcat( CompressionDirectoryWildcard, "\\" );
    strcat( CompressionDirectoryWildcard, COMP_FILE_PREFIX );
    strcat( CompressionDirectoryWildcard, "*" );

    if ( DoDiskSpaceLimiting ) {
        success = CalculateDiskSpaceUsage( );
        if ( !success ) {
            return FALSE;
        }
    }

    //
    // Determine whether the volume that holds the compression directory
    // is FAT or NTFS.  If it is FAT, then we'll use more lenient tests for
    // determining whether files have changed, since FAT stores file times
    // with less granulatiry then NTFS.
    //

    volumeRoot[0] = CompressionDirectory[0];
    volumeRoot[1] = ':';
    volumeRoot[2] = '\\';
    volumeRoot[3] = '\0';

    success = GetVolumeInformation(
                  volumeRoot,
                  NULL,
                  0,
                  NULL,
                  &maximumComponentLength,
                  &fileSystemFlags,
                  fileSystemName,
                  sizeof(fileSystemName)
                  );

    if ( !success || strcmp( "FAT", fileSystemName ) == 0 ) {
        CompressionVolumeIsFat = TRUE;
    } else {
        CompressionVolumeIsFat = FALSE;
    }

    //
    // For each compression scheme, initialize the path prefix we'll use
    // when compressing static files.
    //

    for ( i = 0; SupportedCompressionSchemes[i] != NULL; i++ ) {
        strcpy( SupportedCompressionSchemes[i]->pszCompressionSchemeNamePrefix,
                    CompressionDirectory );
        strcat( SupportedCompressionSchemes[i]->pszCompressionSchemeNamePrefix,
                    "\\" );
        strcat( SupportedCompressionSchemes[i]->pszCompressionSchemeNamePrefix,
                   COMP_FILE_PREFIX );
        strcat( SupportedCompressionSchemes[i]->pszCompressionSchemeNamePrefix,
                    SupportedCompressionSchemes[i]->pszCompressionSchemeName );
        strcat( SupportedCompressionSchemes[i]->pszCompressionSchemeNamePrefix,
                    "_" );
    }

    //
    // Everything worked!
    //

    return TRUE;

} // InitializeCompressionDirectory

#ifndef CMDLINE


VOID
Terminate (
    VOID
    )

/*++

Routine Description:

    Frees all compression filter data structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD i;
    HRESULT hRes;

    //
    // Stop the metabase change notify sink if necessary, and release
    // the associated COM objects.
    //

    IsTerminating = TRUE;

    if ( InitializedSink ) {

        DBG_ASSERT(pEventSink != NULL);

        hRes = pConnPoint->Unadvise( dwSinkNotifyCookie );

        pConnPoint->Release();
        pConnPointContainer->Release( );

    }

    if ( pcAdmCom != NULL ) {
        pcAdmCom->Release( );
    }

    //
    // If the compression thread exists, tell it to terminate itself,
    // and wait for it to do so.  Setting the work routine to NULL
    // indicates that the compression should kill itself.
    //
    // Note that we assume here that the compression thread itself will
    // handle freeing any queued work items.
    //

    if ( CompressionThreadHandle != NULL ) {

        QueueWorkItem( NULL, NULL, NULL, TRUE, TRUE );

        WaitForSingleObject( CompressionThreadHandle, INFINITE );

        CloseHandle( CompressionThreadHandle );
    }

    //
    // Free static objects.
    //

    if ( IoBuffer != NULL ) {
        LocalFree( IoBuffer );
    }

    if ( CompressionBuffer != NULL ) {
        LocalFree( CompressionBuffer );
    }

    if ( CompressionDirectory != NULL ) {
        LocalFree( CompressionDirectory );
    }

    DeleteCriticalSection( &CompressionDirectoryLock );

    DeleteCriticalSection( &CompressionThreadLock );

    //
    // For each compression scheme, unload the compression DLL and free
    // the space that holds info about the scheme itself.
    //

    for ( i = 0; SupportedCompressionSchemes[i] != NULL; i++ ) {

        if ( SupportedCompressionSchemes[i]->DestroyCompressionRoutine && 
             SupportedCompressionSchemes[i]->CompressionContext ) {
            SupportedCompressionSchemes[i]->DestroyCompressionRoutine ( 
                SupportedCompressionSchemes[i]->CompressionContext );
        }

        if ( SupportedCompressionSchemes[i]->hDllHandle ) {
            FreeLibrary( SupportedCompressionSchemes[i]->hDllHandle );
        }

        if ( SupportedCompressionSchemes[i]->pszCompressionDll != NULL ) {
            LocalFree( SupportedCompressionSchemes[i]->pszCompressionDll );
        }

        if ( SupportedCompressionSchemes[i]->ppszFileExtensions != NULL ) {
            LocalFree( SupportedCompressionSchemes[i]->ppszFileExtensions );
        }

        if ( SupportedCompressionSchemes[i]->ppszScriptFileExtensions != NULL ) {
            LocalFree( SupportedCompressionSchemes[i]->ppszScriptFileExtensions );
        }

        if ( SupportedCompressionSchemes[i]->pszMimeType != NULL ) {
            LocalFree( SupportedCompressionSchemes[i]->pszMimeType );
        }

        LocalFree( SupportedCompressionSchemes[i] );
    }


	// balancing CoInitialize
	CoUninitialize ();


} // Terminate

#endif


VOID
ReadMetabaseValue (
    IN METADATA_HANDLE hMd,
    IN LPWSTR pszParentPath OPTIONAL,
    IN DWORD dwIdentifier,
    IN DWORD dwValueType,
    IN PVOID pvResult,
    IN PVOID DefaultValue,
    IN DWORD Minimum,
    IN DWORD Maximum
    )

/*++

Routine Description:

    Reads a single value out of the metabase.  This routine assumes that
    the global variable pcAdmCom is valid on entry.

Arguments:

    hMd - A metabase handle to the root key where the metabase
        identifier is to be read.

    pszParentPath - An optional pointer to a Unicode string that contains
        the relative path for this specific value.

    dwIdentifier - The identifier to read.

    dwValueType - the value type of the identifier.  This routine
        supports STRING_METADATA, EXPANDSZ_METADATA, MULTISZ_METADATA,
        and DWORD_METADATA value types.

    pvResult - Points to the location where the result should be stored.

    DefaultValue - If there is any failure in reading the identifier from
        the metabase, pvResult is set to this value.

    Minimum - For DWORD_METADATA identifiers, the smallest possible
        legitimate value of the parameter.  If the metabase holds a
        smaller value, then pvResult is set to Minimum.

    Maximum - As with Minimum, except on the other end.

Return Value:

    None.  Callers interested in success/failure can use an invalid
    DefaultValue and test against that to see if the routine succeeded.

--*/

{
    HRESULT hresError;
    DWORD type;
    DWORD bytesRequired;
    BOOL stringType = FALSE; 
    PCHAR s;
    PWCHAR ws;
    DWORD i;
    DWORD arrayCount;
    LPSTR *stringArray;
    METADATA_RECORD mdrMDData;
    LPSTR string;
    BYTE buffer[4096];
    INT result;

    //
    // If this is a string data type, determine the amount of space we need
    // to allocate to hold it, then allocate this space and save it.
    //

    if ( dwValueType == STRING_METADATA ||
             dwValueType == EXPANDSZ_METADATA ||
             dwValueType == MULTISZ_METADATA ) {

        stringType = TRUE;

        //
        // Retrieve the string data from the metabase.
        //

        mdrMDData.dwMDIdentifier = dwIdentifier;
        mdrMDData.dwMDAttributes = 0;
        mdrMDData.dwMDUserType = ALL_METADATA;
        mdrMDData.dwMDDataType = ALL_METADATA;
        mdrMDData.dwMDDataLen = sizeof(buffer);
        buffer[0] = '\0';
        mdrMDData.pbMDData = (unsigned char *)buffer;

        hresError = pcAdmCom->GetData(
                        hMd,
                        pszParentPath,
                        &mdrMDData,
                        &bytesRequired
                        );

        if ( FAILED(hresError) ) {
            goto fail;
        }

        if ( (mdrMDData.dwMDDataType != dwValueType) &&
             !( (mdrMDData.dwMDDataType == STRING_METADATA) &&
                (dwValueType == EXPANDSZ_METADATA) ) &&
             !( (mdrMDData.dwMDDataType == EXPANDSZ_METADATA) &&
               (dwValueType == STRING_METADATA) ) ) {
            goto fail;
        }

        //
        // If the returned string has size zero, then free the storage
        // space and return the result value as NULL.
        //

        if ( *(PWCHAR)buffer == L'\0' ) {
            *((PVOID *)pvResult) = NULL;
            return;
        }

        //
        // If this is a MULTISZ_METADATA, then parse out the actual data
        // into the array.
        //

        if ( dwValueType == MULTISZ_METADATA ) {

            arrayCount = 0;

            for ( ws = (PWCHAR)buffer; TRUE; ws++ ) {
                if ( *ws == L'\0' ) {
                    arrayCount += 1;
                    if ( *(ws+1) == L'\0' ) {
                        break;
                    }
                }
            }

            //
            // Allocate space to hold the actual array.  Include space
            // for the NULL terminator at the end of the array.
            //

            stringArray = (LPSTR *)LocalAlloc(
                                       LMEM_FIXED,
                                       (arrayCount + 1) * sizeof(LPSTR)
                                       );
            if ( stringArray == NULL ) {
                goto fail;
            }

            //
            // Allocate a buffer to hold the ANSI version of the
            // strings.  Note that we allocate a buffer just as large as
            // the Unicode buffer in order to ensure that we will always
            // have enough space for the ANSI strings.
            //

            string = (LPSTR)LocalAlloc(
                                LMEM_FIXED,
                                (LONG)((PBYTE)ws - (PBYTE)buffer) + 2
                                );
            if ( string == NULL ) {
                LocalFree( stringArray );
                goto fail;
            }

            //
            // Set up the array pointers by walking the string again and
            // pointing each array entry just after each zero
            // terminator.  Convert the individual strings to ANSI as we
            // go.
            //

            s = string;
            ws = (PWCHAR)buffer;

            for ( i = 0; i < arrayCount; i++ ) {

                stringArray[i] = s;

                result = WideCharToMultiByte(
                             CP_ACP,
                             0,
                             ws,
                             wcslen( ws ) * sizeof(WCHAR),
                             s,
                             MAX_PATH,
                             NULL,
                             NULL
                             );
                if ( result == 0 ) {
                    LocalFree( stringArray );
                    LocalFree( string );
                    goto fail;
                }

                s += strlen( s ) + 1;
                ws += wcslen( ws ) + 1;
            }

            //
            // Terminate the array.
            //

            stringArray[i] = NULL;

            //
            // Save the array pointer in the appropriate data location.
            //

            *((LPSTR **)pvResult) = stringArray;

        } else {

            //
            // It is a normal string value or an EXPANDSZ value.  If it is
            // an EXPANDSZ string type, do variable expansion.
            //

            if ( ( mdrMDData.dwMDDataType == EXPANDSZ_METADATA ) ||
                 ( dwValueType == EXPANDSZ_METADATA ) ) {

                BYTE buffer2[4096];

                //
                // Use a second buffer to expand the strings into.  The
                // ExpandEnvironmentStrings API does not do in-place
                // expansion, so we have to use a second buffer.
                //

                result = ExpandEnvironmentStringsW(
                             (LPCWSTR)buffer,
                             (LPWSTR)buffer2,
                             sizeof(buffer2) / sizeof(WCHAR)
                             );
                if ( result >= sizeof(buffer) || result == 0 ) {
                    goto fail;
                }

                //
                // Reset the new size of the string and copy the string
                // into the correct location.
                //

                mdrMDData.dwMDDataLen = result + sizeof(WCHAR);
                wcscpy( (LPWSTR)buffer, (LPWSTR)buffer2 );
            }

            //
            // Allocate a buffer into which we'll convert the Unicode
            // string to ANSI.
            //

            string = (LPSTR)LocalAlloc( LMEM_FIXED, mdrMDData.dwMDDataLen );
            if ( string == NULL ) {
                goto fail;
            }

            result = WideCharToMultiByte(
                         CP_ACP,
                         0,
                         (LPCWSTR)buffer,
                         mdrMDData.dwMDDataLen - sizeof(WCHAR),
                         string,
                         mdrMDData.dwMDDataLen,
                         NULL,
                         NULL
                         );

            if ( result == 0 ) {
                LocalFree( string );
                goto fail;
            }

            //
            // Save it in the appropriate data location.
            //

            *((LPSTR *)pvResult) = string;
        }

        return;
    }

    //
    // Just read the DWORD and store it directly in the appropriate
    // location.
    //

    bytesRequired = sizeof(DWORD);

    mdrMDData.dwMDIdentifier = dwIdentifier;
    mdrMDData.dwMDAttributes = 0;
    mdrMDData.dwMDUserType = ALL_METADATA;
    mdrMDData.dwMDDataType = dwValueType;
    mdrMDData.dwMDDataLen = sizeof(DWORD);
    mdrMDData.pbMDData = (unsigned char *)pvResult;

    hresError = pcAdmCom->GetData(
                    hMd,
                    pszParentPath,
                    &mdrMDData,
                    &bytesRequired
                    );

    if ( FAILED(hresError) ) {
        goto fail;
    }

    //
    // Make sure that the value is within the allowable range of values.
    // If it isn't, jam it to the default.
    //

    if ( *(PDWORD)pvResult < Minimum || *(PDWORD)pvResult > Maximum ) {
        *((PVOID *)pvResult) = DefaultValue;
    }

    return;

fail:

    //
    // The operation failed.  Use the default setting for this entry.
    // Note that if the entry is a string, we'll just point it to the
    // same string that was passed in to this routine, assuming that the
    // default value is stable memory.
    //

    *((PVOID *)pvResult) = DefaultValue;

} // ReadMetabaseValue


BOOL
ReadCompressionSchemes (
    IN METADATA_HANDLE hMd
    )

/*++

Routine Description:

    Reads all the compression schemes stored on the machine and
    initializes the data structures for them.

Arguments:

    hMd - A handle to the metabase key that holds all compression
        information.  This routines assumes that each scheme will be
        stored as a subkey off the key that is represented by this
        handle.

Return Value:

    TRUE if initialization of all schemes succeeded.

--*/

{
    LONG result;
    DWORD i, j;
    DWORD EnumIndex, SchemeIndex;
    PSUPPORTED_COMPRESSION_SCHEME scheme;
    FILETIME fileTime;
    DWORD disposition;
    BOOL anyDynamicSchemes = FALSE;
    BOOL anyStaticSchemes = FALSE;
    BOOL anyOnDemandSchemes = FALSE;
    WCHAR unicodeSchemeName[METADATA_MAX_NAME_LEN];
    HRESULT hresError;
    PCHAR s;
    BOOL success;

    //
    // Enumerate the keys under the main compression metabase key.  Each
    // subkey corresponds to a compression scheme.
    //

    EnumIndex = 0;
    SchemeIndex = 0;

    do {

        //
        // Allocate space for both the compression info structure and
        // the string fields that belong with the structure.  We'll put
        // the string fields just after the actual structure.
        //

        scheme = (PSUPPORTED_COMPRESSION_SCHEME)
                     LocalAlloc(
                         LMEM_FIXED | LMEM_ZEROINIT,
                         sizeof(*scheme) + MAX_PATH*6
                         );
        if ( scheme == NULL ) {
            return FALSE;
        }

        scheme->pszCompressionSchemeName = (LPSTR)(scheme + 1);
        scheme->pszCompressionSchemeNamePrefix =
            scheme->pszCompressionSchemeName + MAX_PATH;
        scheme->pszResponseHeaders =
            scheme->pszCompressionSchemeNamePrefix + MAX_PATH;

        //
        // Enumerate the next subkey.
        //

        hresError = pcAdmCom->EnumKeys(
                        hMd,
                        L"",
                        unicodeSchemeName,
                        EnumIndex++
                        );

        if ( (SUCCEEDED( hresError)) &&
             (_wcsicmp(unicodeSchemeName, METABASE_PARAMS_SUBKEY_NAME) != 0) ) {

            //
            // Save the ANSI version of the compression scheme name.
            //

            result = WideCharToMultiByte(
                         CP_ACP,
                         0,
                         unicodeSchemeName,
                         wcslen( unicodeSchemeName ) * sizeof(WCHAR),
                         scheme->pszCompressionSchemeName,
                         MAX_PATH,
                         NULL,
                         NULL
                         );
            if ( result == 0 ) {
                LocalFree( scheme );
                continue;
            }

            //
            // Convert the scheme name to lowercase so that later
            // comparisons are fast and case-insensitive.  This is a pure
            // ASCII name, so NLS issues are not relevent and the old
            // "bitwise OR with 0x20" trick works well.
            //

            for ( s = scheme->pszCompressionSchemeName; *s != '\0'; s++ ) {
                *s |= 0x20;
            }

            //
            // Read all the values for this key.
            //

            for ( j = 0; SchemeMetabaseData[j].dwIdentifier != 0; j++ ) {
                ReadMetabaseValue(
                    hMd,
                    unicodeSchemeName,
                    SchemeMetabaseData[j].dwIdentifier,
                    SchemeMetabaseData[j].dwValueType,
                    (PVOID)( (PCHAR)scheme + SchemeMetabaseData[j].dwOffset),
                    SchemeMetabaseData[j].DefaultValue,
                    SchemeMetabaseData[j].dwMinimum,
                    SchemeMetabaseData[j].dwMaximum
                    );
            }

            //
            // Catch whether any schemes support dynamic compression,
            // static compression, and on-demand compression.
            //

            if ( scheme->DoDynamicCompression ) {
                anyDynamicSchemes = TRUE;
            }

            if ( scheme->DoStaticCompression ) {
                anyStaticSchemes = TRUE;
            }

            if ( scheme->DoOnDemandCompression ) {
                anyOnDemandSchemes = TRUE;
            }

            //
            // Fill in other appropriate fields in the compression scheme
            // scructure.
            //

            strcpy( scheme->pszResponseHeaders, "Content-Encoding: " );
            strcat( scheme->pszResponseHeaders, scheme->pszCompressionSchemeName );
            strcat( scheme->pszResponseHeaders, "\r\n" );

            SupportedCompressionSchemes[SchemeIndex++] = scheme;

            //
            // Initialize the compression scheme for use.  Note that we
            // ignore initialization failures and assume that later code
            // will ignore schemes in this state.
            //

            (VOID)InitializeCompressionScheme( scheme );

        } else {

            //
            // We're done enumerating the subkeys.  Free this entry.
            //
            //

            LocalFree( scheme );
        }

    } while ( SUCCEEDED( hresError ) );

    //
    // Do a simple insertion sort on the compression schemes based on
    // their priority values.  Higher priority schemes go at the
    // beginning of the array.
    //

    for ( i = 0; i < SchemeIndex; i++ ) {

        for ( j = i + 1; j < SchemeIndex; j++ ) {

            if ( SupportedCompressionSchemes[j]->dwPriority >
                     SupportedCompressionSchemes[i]->dwPriority ) {

                //
                // Found entries out of order.  Swap them.
                //

                scheme = SupportedCompressionSchemes[j];
                SupportedCompressionSchemes[j] = SupportedCompressionSchemes[i];
                SupportedCompressionSchemes[i] = scheme;
            }
        }
    }

    //
    // If there are no compression schemes of specific types, then
    // disable those compression types globally.
    //

    if ( !anyDynamicSchemes ) {
        DoDynamicCompression = FALSE;
    }

    if ( !anyStaticSchemes ) {
        DoStaticCompression = FALSE;
    }

    if ( !anyOnDemandSchemes ) {
        DoOnDemandCompression = FALSE;
    }

    return TRUE;

} // ReadCompressionSchemes


BOOL
InitializeCompressionScheme (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme
    )

/*++

Routine Description:

    Initializes the DLL information for a specific compression scheme.
    We do this "lazily" so that we never load compression schemes
    that we will not actually need to use.

Arguments:

    Scheme - a pointer to the compression scheme to initalize.

Return Value:

    TRUE if the initialization succeeded.  A side effect of this routine
    is to set Scheme->hDllHandle if successful.

--*/

{
    HINSTANCE compressionDll = NULL;
    DWORD i;
    PVOID routine;
    BOOL success;
    HRESULT hResult;

    //
    // Load the compression DLL.
    //

    compressionDll = LoadLibrary( Scheme->pszCompressionDll );
    if ( compressionDll == NULL ) {
        return FALSE;
    }

    //
    // Get the addresses of the relevent compression routines.
    //

    for ( i = 0; CompressionRoutines[i].RoutineName != NULL; i++ ) {

        routine = GetProcAddress(
                      compressionDll,
                      CompressionRoutines[i].RoutineName
                      );
        if ( routine == NULL ) {
            FreeLibrary( compressionDll );
            return FALSE;
        }

        *((PVOID *)((PCHAR)Scheme + CompressionRoutines[i].RoutineOffset)) = routine;
    }

    //
    // Call the compression DLL's initialization routine.
    //

    hResult = Scheme->InitCompressionRoutine( );
    if ( FAILED( hResult ) ) {
        FreeLibrary( compressionDll );
        return FALSE;
    }

    //
    // Initialize the compression context that we need.
    //

    hResult = Scheme->CreateCompressionRoutine(
                          &Scheme->CompressionContext,
                          Scheme->CreateFlags
                          );
    if ( FAILED( hResult) ) {
        FreeLibrary( compressionDll );
        return FALSE;
    }

    //
    // It all worked!  Store a pointer to the compression DLL handle.
    // If this remains NULL, then the DLL is considered uninitialized
    // and we will attempt to load it again the next time it is needed,
    // if anything above fails.
    //

    Scheme->hDllHandle = compressionDll;

    return TRUE;

} // InitializeCompressionScheme

CImpIADMCOMSINKW::CImpIADMCOMSINKW()
{
    m_dwRefCount=0;
    m_pcCom = NULL;
}

CImpIADMCOMSINKW::~CImpIADMCOMSINKW()
{
}

HRESULT
CImpIADMCOMSINKW::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IMSAdminBaseSink) {
        *ppObject = (IMSAdminBaseSink *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIADMCOMSINKW::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIADMCOMSINKW::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIADMCOMSINKW::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ])

/*++

Routine Description:

    This is the change notification routine for the compression filter.
    It is called by the metabase whenever there is a change in the
    metabase.

    This routine walks the list of changed metabase values to determine
    whether any are compression parameters that can be dynamically changed.
    For any parameters that can be dynamically changed, we call the
    routine that will do the actual dynamic update of the parameter.

Arguments:

    dwMDNumElements - The number of MD_CHANGE_OBJECT structures passed
        to this routine.

    pcoChangeList - An array of all the metabase values that have changed.

Return Value:

    Not used.

--*/

{
    DWORD i, j, k;
    HRESULT hRes;
    METADATA_HANDLE hmdParentHandle = NULL;

    //
    // Walk through the list of changed items and determine whether any
    // are related to compression.  Take action based on whether we
    // support dynamic reconfiguration of the property at issue.
    //

    for ( i = 0; i < dwMDNumElements; i++ ) {

        for ( j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++ ) {

            //
            // Walk the lists of configuration parameters to see if there
            // is a match.  If there is a match, call the metabase
            // change handler for the ID at issue, if one exists.
            //
            // Note that at this time we don't support changing any
            // per-scheme values on a dynamic basis.
            //

            if ( (pcoChangeList[i].pdwMDDataIDs[j] >= MIN_MD_COMPRESSION_GLOBAL_ID) &&
                 ( pcoChangeList[i].pdwMDDataIDs[j] <= MAX_MD_COMPRESSION_GLOBAL_ID ) ) {

                for ( k = 0; GlobalMetabaseData[k].dwIdentifier != 0; k++ ) {

                    if ( GlobalMetabaseData[k].dwIdentifier ==
                             pcoChangeList[i].pdwMDDataIDs[j] &&
                         GlobalMetabaseData[k].pChangeHandler != NULL ) {

                        //
                        // If necessary, open the metabase key that holds
                        // HTTP compression information.
                        //

                        if ( hmdParentHandle == NULL ) {

                            hRes = pcAdmCom->OpenKey(
                                       METADATA_MASTER_ROOT_HANDLE,
                                       METABASE_KEY_NAME,
                                       METADATA_PERMISSION_READ,
                                       METABASE_DEFAULT_TIMEOUT,
                                       &hmdParentHandle
                                       );
                            if ( FAILED(hRes) ) {
                                return 0;
                            }
                        }

                        //
                        // Now call the routine that will actually handle
                        // reading the new information and reconfiguring the
                        // filter as appropriate.
                        //

                        GlobalMetabaseData[k].pChangeHandler(
                            pcoChangeList[i].pdwMDDataIDs[j],
                            hmdParentHandle
                            );
                    }
                }
            }
        }
    }

    //
    // Close the metabase key handle, if we opened it.  Note that there's
    // nothing we can do about failures here.
    //

    if ( hmdParentHandle != NULL ) {
        hRes = pcAdmCom->CloseKey( hmdParentHandle );
    }

    return 0;
}

HRESULT STDMETHODCALLTYPE
CImpIADMCOMSINKW::ShutdownNotify( void)
{
    return (0);
}


VOID
CompressionDirectoryChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    )

/*++

Routine Description:

    Perform reinitialization of the CompressionDirectory and related
    parameters.

Arguments:

    dwIdentifier - always MD_HC_COMPRESSION_DIRECTORY.

    hmdParentHandle - a metabase handle to the key that contains all
        compression configuration information.

Return Value:

    None.

--*/

{
    LPSTR newCompressionDirectory;
    BOOL success;
    HANDLE hDirectory;
    WIN32_FIND_DATA win32FindData;
    DWORD prefixLength;
    CHAR fileName[MAX_PATH * 2];

    DBG_ASSERT( dwIdentifier == MD_HC_COMPRESSION_DIRECTORY );

    //
    // Read the new setting for the compression directory.
    //

    ReadMetabaseValue(
        hmdParentHandle,
        METABASE_PARAMS_SUBKEY_NAME,
        MD_HC_COMPRESSION_DIRECTORY,
        EXPANDSZ_METADATA,
        &newCompressionDirectory,
        NULL,
        FALSE,
        TRUE
        );

    //
    // If there was a failure, or if the setting did not change, bail now.
    //

    if ( newCompressionDirectory == NULL ) {
        return;
    }

    if ( strcmp( newCompressionDirectory, CompressionDirectory ) == 0 ) {
        LocalFree( newCompressionDirectory );
        return;
    }

    //
    // Acquire the lock that protects compression directory data
    // structures.  We hold this throughout the following operations
    // in order to prevent changes from occurring in the compression
    // thread.
    //

    EnterCriticalSection( &CompressionDirectoryLock );

    //
    // Delete the files from the old compression directory.  We assume
    // that any file name starting with COMP_FILE_PREFIX and which has
    // the SYSTEM attribute turned on will be a compression file.
    // Ignore any failures we get in doing all of this.
    //

    prefixLength = strlen( COMP_FILE_PREFIX );

    hDirectory = FindFirstFile( CompressionDirectoryWildcard, &win32FindData );

    if ( hDirectory != INVALID_HANDLE_VALUE ) {

        success = TRUE;

        while ( success ) {

            if ( strncmp( win32FindData.cFileName,
                          COMP_FILE_PREFIX,
                          prefixLength ) == 0 &&
                 (win32FindData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) != 0 ) {

                strcpy( fileName, CompressionDirectory );
                strcat( fileName, "\\" );
                strcat( fileName, win32FindData.cFileName );

                DeleteFile( fileName );
            }

            success = FindNextFile( hDirectory, &win32FindData );
        }

        FindClose( hDirectory );
    }

    //
    // Attempt to delete the old compression directory.  If there
    // are any files in the directory, this delete will fail, but that
    // is OK because the files are not compression files.
    //

    RemoveDirectory( CompressionDirectory );

    //
    // Free the old compression directory string, and remember the new
    // compression directory pointer in the "official" place.
    //

    LocalFree( CompressionDirectory );

    CompressionDirectory = newCompressionDirectory;

    //
    // While still holding the lock, reinitialize the various data
    // structures and settings pertaining to the compression directory.
    //

    InitializeCompressionDirectory( );

    //
    // Release the lock and continue.
    //

    LeaveCriticalSection( &CompressionDirectoryLock );

    return;

} // CompressionDirectoryChangeHandler


VOID
DoDiskSpaceChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    )

/*++

Routine Description:

    Perform reinitialization of the DoDiskSpaceLimiting parameter.

Arguments:

    dwIdentifier - always MD_HC_DO_DISK_SPACE_LIMITING.

    hmdParentHandle - a metabase handle to the key that contains all
        compression configuration information.

Return Value:

    None.

--*/

{
    DWORD newValue;

    DBG_ASSERT( dwIdentifier == MD_HC_DO_DISK_SPACE_LIMITING );

    //
    // First, read the new value for DoStaticCompression.
    //

    ReadMetabaseValue(
        hmdParentHandle,
        METABASE_PARAMS_SUBKEY_NAME,
        MD_HC_DO_DISK_SPACE_LIMITING,
        DWORD_METADATA,
        &newValue,
        (PVOID)UIntToPtr(INVALID_BOOLEAN),
        FALSE,
        TRUE
        );

    //
    // If that fails for some reason, just bail--there's nothing we can
    // do about it here.
    //

    if ( newValue == INVALID_BOOLEAN ) {
        return;
    }

    //
    // If we are enabling disk space limiting, lock out the compression
    // thread and figure out how much space the new directory is using.
    //

    if ( newValue ) {

        EnterCriticalSection( &CompressionDirectoryLock );

        CalculateDiskSpaceUsage( );
        DoDiskSpaceLimiting = newValue;

        LeaveCriticalSection( &CompressionDirectoryLock );

    } else {

        DoDiskSpaceLimiting = newValue;
    }

    return;

} // DoDiskSpaceChangeHandler


VOID
DoDynamicChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    )


/*++

Routine Description:

    Perform reinitialization of the DoDynamicCompression parameter.

Arguments:

    dwIdentifier - always MD_HC_DO_DYNAMIC_COMPRESSION.

    hmdParentHandle - a metabase handle to the key that contains all
        compression configuration information.

Return Value:

    None.

--*/

{
    DWORD newValue;
    DWORD i;
    BOOL anyDynamicSchemes;

    DBG_ASSERT( dwIdentifier == MD_HC_DO_DYNAMIC_COMPRESSION );

    //
    // First, read the new value for DoDynamicCompression.
    //

    ReadMetabaseValue(
        hmdParentHandle,
        METABASE_PARAMS_SUBKEY_NAME,
        MD_HC_DO_DYNAMIC_COMPRESSION,
        DWORD_METADATA,
        &newValue,
        (PVOID)UIntToPtr(INVALID_BOOLEAN),
        FALSE,
        TRUE
        );

    //
    // If that fails for some reason, just bail--there's nothing we can
    // do about it here.
    //

    if ( newValue == INVALID_BOOLEAN ) {
        return;
    }

    //
    // Treat any nonzero value as TRUE.
    //

    if ( newValue != 0 ) {
        newValue = TRUE;
    }

    //
    // If the setting didn't change, also take no action.
    //

    if ( (BOOLEAN)newValue == DoDynamicCompression ) {
        return;
    }

    //
    // If we're now enabling dynamic compression, make sure that at least
    // one installed scheme can support dynamic compression.
    //

    if ( newValue != 0 ) {

        anyDynamicSchemes = FALSE;

        for ( i = 0; SupportedCompressionSchemes[i] != NULL; i++ ) {

            if ( SupportedCompressionSchemes[i]->DoDynamicCompression ) {
                anyDynamicSchemes = TRUE;
            }
        }

        if ( !anyDynamicSchemes ) {
            return;
        }
    }

    //
    // Adjust our notification flags with the web server.  If we're
    // enabling dynamic compression, add the flags to get raw send and
    // end of request notifications.  If we're disabling dynamic
    // compression, remove these flags.
    //

    NotificationFlags = 0;

    if ( DoStaticCompression || newValue ) {
        NotificationFlags = SF_NOTIFY_URL_MAP |
                            SF_NOTIFY_SEND_RESPONSE ;
    }

    if ( newValue ) {
        NotificationFlags |= SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_END_OF_REQUEST;
    }

    //
    // Note that there's nothing we can do about failures in
    // AdjustFilterFlags, so ignore the return code.
    //

#ifndef CMDLINE
    AdjustFilterFlags( HttpFilterProc, NotificationFlags );
#endif

    //
    // Remember the new setting.
    //

    DoDynamicCompression = (BOOLEAN)newValue;

    return;

} // DoDynamicChangeHandler


VOID
DoStaticChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    )

/*++

Routine Description:

    Perform reinitialization of the DoStaticCompression parameter.

Arguments:

    dwIdentifier - always MD_HC_DO_STATIC_COMPRESSION.

    hmdParentHandle - a metabase handle to the key that contains all
        compression configuration information.

Return Value:

    None.

--*/

{
    DWORD newValue;
    DWORD i;
    BOOL anyStaticSchemes;

    DBG_ASSERT( dwIdentifier == MD_HC_DO_STATIC_COMPRESSION );

    //
    // First, read the new value for DoStaticCompression.
    //

    ReadMetabaseValue(
        hmdParentHandle,
        METABASE_PARAMS_SUBKEY_NAME,
        MD_HC_DO_STATIC_COMPRESSION,
        DWORD_METADATA,
        &newValue,
        (PVOID)UIntToPtr(INVALID_BOOLEAN),
        FALSE,
        TRUE
        );

    //
    // If that fails for some reason, just bail--there's nothing we can
    // do about it here.
    //

    if ( newValue == INVALID_BOOLEAN ) {
        return;
    }

    //
    // If the setting didn't change, also take no action.
    // also if dynamic is on , dynamic need all notifications, so even if static has changed
    // we don't need to change flags

    if ( (BOOLEAN)newValue == DoStaticCompression || DoDynamicCompression) {

        // change global variable in case if it was not equal (case of DoDynamicCompression== TRUE)
        DoStaticCompression = (BOOLEAN)newValue;
        return;
    }

    //
    // If we're now enabling static compression, make sure that at least
    // one installed scheme can support static compression.
    //

    if ( newValue != 0 ) {

        anyStaticSchemes = FALSE;

        for ( i = 0; SupportedCompressionSchemes[i] != NULL; i++ ) {

            if ( SupportedCompressionSchemes[i]->DoStaticCompression ) {
                anyStaticSchemes = TRUE;
            }
        }

        if ( !anyStaticSchemes ) {
            return;
        }
    }

    //
    // Adjust our notification flags with the web server.  If we're
    // enabling static compression, add the flags to get URL map
    // and send resopnse notifications.  If we're disabling static
    // compression, leave the notifications as before so that dynamic
    // compression works.
    // change: recalculate notifications. prev verion will not work corretly
    // if just static compression is on and we are disabling static.


    //
    // we don't check for dynamic as a check for dynamic beeing on was few lines above
    //

    if ( newValue != 0 ) {

        NotificationFlags |= SF_NOTIFY_URL_MAP |
                             SF_NOTIFY_SEND_RESPONSE |
                             SF_NOTIFY_END_OF_REQUEST;
    }
    else
    {
        NotificationFlags = 0;
    }

        //
        // Note that there's nothing we can do about failures in
        // AdjustFilterFlags, so ignore the return code.
        //

#ifndef CMDLINE
        AdjustFilterFlags( HttpFilterProc, NotificationFlags );
#endif
    

    //
    // Remember the new setting.
    //

    DoStaticCompression = (BOOLEAN)newValue;

    return;

} // DoStaticChangeHandler


VOID
GlobalMetabaseChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    )

/*++

Routine Description:

    This generic routine handles reinitialization of any compression
    parameter that can change without requiring special handling.  It
    rereads the new setting and jams it in, ignoring any failures.

    For any parameter that requires special locking/synchronization or
    reinitialization other than a value reset, this routine is not
    approprioate.  It cannot handle any STRING_METADATA or
    MULTISZ_METADATA values.

Arguments:

    dwIdentifier - the parameter that changed.

    hmdParentHandle - a metabase handle to the key that contains all
        compression configuration information.

Return Value:

    None.

--*/

{
    DWORD i;

    //
    // Walk through the list of global values to find a match.  Once
    // we've found a match, read that specific parameter from the
    // metabase.
    //

    for ( i = 0; GlobalMetabaseData[i].dwIdentifier != 0; i++ ) {

        if ( dwIdentifier == GlobalMetabaseData[i].dwIdentifier ) {

            DBG_ASSERT( GlobalMetabaseData[i].dwValueType == DWORD_METADATA );

            ReadMetabaseValue(
                hmdParentHandle,
                METABASE_PARAMS_SUBKEY_NAME,
                GlobalMetabaseData[i].dwIdentifier,
                GlobalMetabaseData[i].dwValueType,
                GlobalMetabaseData[i].pvResult,
                GlobalMetabaseData[i].DefaultValue,
                GlobalMetabaseData[i].dwMinimum,
                GlobalMetabaseData[i].dwMaximum
                );

            //
            // There's no need to continue searching for a match.
            //

            break;
        }
    }

    return;

} // GlobalMetabaseChangeHandler


BOOL
CalculateDiskSpaceUsage (
    VOID
    )

/*++

Routine Description:

    Determines how much disk space is in use in the compression directory
    by compressed files.

Arguments:

    None -- uses global variables.

Return Value:

    TRUE if the calculation was successful.

--*/

{
    BOOL success;
    HANDLE hDirectory;
    WIN32_FIND_DATA win32FindData;

    CurrentDiskSpaceUsage = 0;

    //
    // If the FindFirstFile fails, assume that it was because there were no
    // compressed files in the directory.
    //

    hDirectory = FindFirstFile( CompressionDirectoryWildcard, &win32FindData );
    if ( hDirectory == INVALID_HANDLE_VALUE ) {
        return TRUE;
    }

    success = TRUE;

    while ( success ) {

        InterlockedExchangeAdd(
            (PLONG)&CurrentDiskSpaceUsage,
            win32FindData.nFileSizeLow
            );

        success = FindNextFile( hDirectory, &win32FindData );
    }

    FindClose( hDirectory );

    return TRUE;

} // CalculateDiskSpaceUsage


STDAPI
DllRegisterServer (
    VOID
    )

/*++

Routine Description:

    Sets up the compression filter DLL metabase information.  Only used
    during setup--no runtime use.

Arguments:

    None.

Return Value:

    HRESULT - indicates whether the metabase setup was successful.

--*/

{
    DWORD i;
    HRESULT hRes;
    IClassFactory *pcsfFactory = NULL;
    COSERVERINFO *pcsiParam = NULL;
    METADATA_HANDLE hmdParentHandle;
    INT iAlreadyExist = FALSE;

    //
    // Get the appropriate handles so we can add information to the
    // metabase.
    //

    hRes = CoGetClassObject(
               GETAdminBaseCLSID( TRUE ),
               CLSCTX_SERVER,
               pcsiParam,
               IID_IClassFactory,
               (void**)&pcsfFactory
               );

    if ( FAILED(hRes) ) {

        return hRes;

    } else {

        hRes = pcsfFactory->CreateInstance(
                   NULL,
                   IID_IMSAdminBase,
                   (PVOID *)&pcAdmCom
                   );

        pcsfFactory->Release();

        if (FAILED(hRes)) {
            return hRes;
        }
        }

    //
    // Open the path to the key that contains all compression metabase
    // information.  This code assumes that compfilt.dll has already been
    // set up as an ISAPI filter on the machine.
    //

    hRes = pcAdmCom->OpenKey(
               METADATA_MASTER_ROOT_HANDLE,
               METABASE_KEY_NAME,
               METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
               METABASE_DEFAULT_TIMEOUT,
               &hmdParentHandle
               );

    if ( FAILED(hRes) ) {
        pcAdmCom->Release();
        return hRes;
    }


    //
    // Walk through the list of global values that we need to set.
    //
    for ( i = 0; GlobalMetabaseData[i].dwIdentifier != 0; i++ ) {
        iAlreadyExist = FALSE;
        // in case this is an upgrade case don't overwrite any entries if already there
        iAlreadyExist = CheckMetabaseValue(
                   hmdParentHandle,
                   &GlobalMetabaseData[i],
                   METABASE_PARAMS_SUBKEY_NAME
                   );
        if (FALSE == iAlreadyExist) {
            hRes = WriteMetabaseValue(
                       hmdParentHandle,
                       &GlobalMetabaseData[i],
                       METABASE_PARAMS_SUBKEY_NAME
                       );
            if ( FAILED(hRes) ) {
                pcAdmCom->CloseKey( hmdParentHandle );
                pcAdmCom->Release();
                return hRes;
            }
        }
    }

    METABASE_DATA mbdKeyType = { MD_KEY_TYPE,
                                 STRING_METADATA,
                                 NULL,
                                 0,
                                 L"IIsCompressionSchemes",
                                 0,
                                 0,
                                 NULL
                                 };

    hRes = WriteMetabaseValue(
               hmdParentHandle,
               &mbdKeyType,
               METABASE_PARAMS_SUBKEY_NAME
               );

    //
    // Set up the configuration for GZIP and Deflate.
    //

    for ( i = 0; GzipData[i].dwIdentifier != 0; i++ ) {
        // in case this is an upgrade case don't overwrite any entries if already there
        iAlreadyExist = FALSE;
        iAlreadyExist = CheckMetabaseValue(
                   hmdParentHandle,
                   &GzipData[i],
                   L"Gzip"
                   );
        if (FALSE == iAlreadyExist) {
            hRes = WriteMetabaseValue(
                       hmdParentHandle,
                       &GzipData[i],
                       L"Gzip"
                       );
            if ( FAILED(hRes) ) {
                pcAdmCom->CloseKey( hmdParentHandle );
                pcAdmCom->Release();
                return hRes;
            }
        }
    }

    for ( i = 0; DeflateData[i].dwIdentifier != 0; i++ ) {
        // in case this is an upgrade case don't overwrite any entries if already there
        iAlreadyExist = FALSE;
        iAlreadyExist = CheckMetabaseValue(
                   hmdParentHandle,
                   &DeflateData[i],
                   L"Deflate"
                   );
        if (FALSE == iAlreadyExist) {
            hRes = WriteMetabaseValue(
                       hmdParentHandle,
                       &DeflateData[i],
                       L"Deflate"
                       );
            if ( FAILED(hRes) ) {
                pcAdmCom->CloseKey( hmdParentHandle );
                pcAdmCom->Release();
                return hRes;
            }
        }
    }

    //
    // Clean up and return.
    //

    pcAdmCom->CloseKey( hmdParentHandle );
    pcAdmCom->Release();

    return NOERROR;

} // DllRegisterServer


INT CheckMetabaseValue(
    IN METADATA_HANDLE hmdParentHandle,
    IN PMETABASE_DATA Data,
    IN LPWSTR pszMDPath
    )
{
    INT iTheEntryExists = FALSE;
    METABASE_DATA mdrMDData_Temp;

    mdrMDData_Temp.dwIdentifier = Data->dwIdentifier;
    mdrMDData_Temp.dwValueType = Data->dwValueType;
    mdrMDData_Temp.pvResult = Data->pvResult;
    mdrMDData_Temp.dwOffset = Data->dwOffset;
    mdrMDData_Temp.DefaultValue = Data->DefaultValue;
    mdrMDData_Temp.dwMinimum = Data->dwMinimum;
    mdrMDData_Temp.dwMaximum = Data->dwMaximum;
    mdrMDData_Temp.DefaultValue = NULL;


    LPSTR szString = NULL;
    DWORD dwDword = 0;
    DWORD dwDword2;
    dwDword2 = mdrMDData_Temp.dwMinimum;

    if (mdrMDData_Temp.dwValueType == DWORD_METADATA) {
        ReadMetabaseValue(
            hmdParentHandle,
            pszMDPath,
            mdrMDData_Temp.dwIdentifier,
            mdrMDData_Temp.dwValueType,
            &dwDword,
            (PVOID) UIntToPtr(INVALID_DWORD),
            mdrMDData_Temp.dwMinimum,
            mdrMDData_Temp.dwMaximum
            );
        if (dwDword != INVALID_DWORD) {
           iTheEntryExists = TRUE;
        }
    }
    else
    {
        ReadMetabaseValue(
            hmdParentHandle,
            pszMDPath,
            mdrMDData_Temp.dwIdentifier,
            mdrMDData_Temp.dwValueType,
            &szString,
            NULL,
            mdrMDData_Temp.dwMinimum,
            mdrMDData_Temp.dwMaximum
            );
        if (szString != NULL) {
            iTheEntryExists = TRUE;
        }
        if (szString != NULL) {
            LocalFree(szString);
        }
    }

    return iTheEntryExists;
}



HRESULT
WriteMetabaseValue (
    IN METADATA_HANDLE hmdParentHandle,
    IN PMETABASE_DATA Data,
    IN LPWSTR pszMDPath
    )

/*++

Routine Description:

    Writes a metabase entry from a record.

Arguments:

    hmdParentHandle - a handle to the compression key of the metabase that
        allows write access.

    Data - the data to use to write to the metabase.

Return Value:

    HRESULT - the result of the operation.

--*/

{
    DWORD length;
    PWCHAR w;
    METADATA_RECORD mdrMDData;
    HRESULT hRes;
    BYTE buffer[4096];
    DWORD result;

    //
    // Build the structure of information that we're going to set.
    //

    mdrMDData.dwMDIdentifier = Data->dwIdentifier;
    mdrMDData.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrMDData.dwMDUserType = IIS_MD_UT_SERVER;
    mdrMDData.dwMDDataType = Data->dwValueType;

    //
    // What we put in the dwMDDataLen and pbMDData fields depends on the
    // type of value we're setting.
    //

    if ( Data->dwValueType == DWORD_METADATA ) {

        mdrMDData.dwMDDataLen = sizeof(DWORD);
        mdrMDData.pbMDData = (PUCHAR)&Data->DefaultValue;

    } else if ( Data->dwValueType == STRING_METADATA ) {

        mdrMDData.dwMDDataLen =
            (wcslen( (PWCHAR)Data->DefaultValue ) + 1) * sizeof(WCHAR);
        mdrMDData.pbMDData = (PUCHAR)Data->DefaultValue;

    } else if ( Data->dwValueType == EXPANDSZ_METADATA ) {

        //
        // For EXPANDSZ types, we need to do expansion before we write
        // to the metabase.  This is because the admin UI does not
        // know how to display and interpret environment variables
        // correctly.
        //
        // if the admin UI changes to allow EXPANDSZ types to be
        // stored in the metabase, kill this expansion here and have it
        // be done only when the data is read.
        //

        result = ExpandEnvironmentStringsW(
                     (LPCWSTR)Data->DefaultValue,
                     (LPWSTR)buffer,
                     sizeof(buffer) / sizeof(WCHAR)
                     );
        if ( result >= sizeof(buffer) || result == 0 ) {
            DBG_ASSERT( FALSE );
            return E_INVALIDARG;
        }

        mdrMDData.dwMDDataLen = result * sizeof(WCHAR);
        mdrMDData.pbMDData = (PUCHAR)buffer;

    } else if ( Data->dwValueType == MULTISZ_METADATA ) {

        for ( w = (PWCHAR)Data->DefaultValue;
              *w != L'\0';
              w += wcslen( w ) + 1 );

        mdrMDData.dwMDDataLen = DIFF((PCHAR)w - (PCHAR)Data->DefaultValue) + sizeof(WCHAR);
        mdrMDData.pbMDData = (PUCHAR)Data->DefaultValue;
    }

    //
    // Do the actual set to the metabase and return the result.
    //

    hRes = pcAdmCom->SetData(
               hmdParentHandle,
               pszMDPath,
               &mdrMDData
               );

    return hRes;

} // WriteMetabaseValue

typedef
BOOL
(*PADJUST_FILTER_FLAGS)(
    PVOID   pfnSFProc,
    DWORD   dwNewFlags
    );


BOOL
AdjustFilterFlags (
    PVOID   pfnSFProc,
    DWORD   dwNewFlags
    )

/*++

Routine Description:

    A wrapper routine for w3svc!AdjustFilterFlags.  The wrapper is used
    so that the filter will continue to load and run on IIS 4, but
    without the dynamic filter flags change feature.  Instead, a w3svc
    restart is required on IIS 4 for these configuration changes.

Arguments:

    pfnSFProc - the HttpExtensionProc for this filter.

    dwNewFlags - the new SF_NOTIFY flags for the filter.

Return Value:

    TRUE for success, FALSE for failure.

--*/

{
    HINSTANCE w3svcDll;
    PADJUST_FILTER_FLAGS routine;
    BOOL result;

    //
    // Load the web server DLL that exports this function.
    //

    w3svcDll = LoadLibrary( "w3svc.dll" );
    if ( w3svcDll == NULL ) {
        return FALSE;
    }

    //
    // Get the entry point for AdjustFilterFlags.
    //

    routine = (PADJUST_FILTER_FLAGS)
                  GetProcAddress( w3svcDll, "AdjustFilterFlags" );
    if ( routine == NULL ) {
        return FALSE;
    }

    //
    // Do the actual call.
    //

    result = routine( pfnSFProc, dwNewFlags );

    //
    // Unload the web server DLL and return.
    //

    FreeLibrary( w3svcDll );

    return result;

} // AdjustFilterFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\filter\sendraw.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sendraw.c

Abstract:

    This module handles dynamic compression for the ISAPI compression
    filter.

Author:

    David Treadwell (davidtr)   18-April-1997

Revision History:

--*/

#include "compfilt.h"

#define HEX_TO_ASCII(_c) ( (CHAR)( (_c) < 0xA ? ((_c) + '0') : ((_c) + 'a' - 0xA)) )


DWORD
OnSendRawData (
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_RAW_DATA phfrdData,
    IN BOOL InEndOfRequest
    )
{
    PCOMPFILT_FILTER_CONTEXT filterContext;
    DWORD i;
    PCHAR s;
    PBYTE startCompressionLocation, pByteInResponse, pLastByteInResponse;
    DWORD bytesToCompress;
    PSUPPORTED_COMPRESSION_SCHEME scheme;
    DWORD schemeIndex;
    HRESULT hResult;
    BOOL success;

    //
    // !!! Should we attempt to retrieve the HTTP status code (401
    //     Access Denied, etc.) and ignore dynamic compression if there
    //     was a problem?
    //

    //
    // If no context structure has been allocated, then bail.  A previous
    // allocation attempt must have failed.
    //

    filterContext = (PCOMPFILT_FILTER_CONTEXT)GET_COMPFILT_CONTEXT( pfc );

    if ( filterContext == NULL ) {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    //
    // If this is a static file request which has already been handled,
    // then we don't need to do anything here.
    //

    if ( filterContext->RequestHandled ) {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    //
    // Break the recursive call when we do a WriteClient from within
    // the END_OF_REQUEST notification.
    //

    if ( !InEndOfRequest && filterContext->InEndOfRequest ) {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    DBG_ASSERT( filterContext->Scheme != NULL );
    DBG_ASSERT( filterContext->DynamicRequest );


    //
    // Initialize the local variables that determine what data to compress.
    //

    startCompressionLocation = (PBYTE)(phfrdData->pvInData);
    bytesToCompress = phfrdData->cbInData;


    //
    // !!! We should really look at the Mime type on the response and only
    //     do compression if the types match.

    //
    // The OnSendResponseCalled field will be set to TRUE when
    // SF_NOTIFY_SEND_RESPONSE is called.  We assume that it will be
    // called just after all the headers have been sent to the client.
    // So, ignore all send raw notifications that happen before
    // SF_NOTIFY_SEND_RESPONSE, since we should not attempt to compress
    // the HTTP headers on the resopnse.  The first call to
    // SF_NOTIFY_SEND_RAW_DATA after SF_NOTIFY_SEND_RESPONSE is to tell
    // the SF_NOTIFY_SEND_RAW_DATA about the HTTP headers getting sent,
    // and we need to ignore those.
    //

    scheme = filterContext->Scheme;

    if ( !filterContext->HeaderPassed ) {

        if ( filterContext->OnSendResponseCalled )
        {
            pLastByteInResponse = startCompressionLocation + bytesToCompress;
            for (pByteInResponse = startCompressionLocation; pByteInResponse < pLastByteInResponse; pByteInResponse++)
            {
                if ( *pByteInResponse == 0x0a)
                {
                    filterContext->HeadersNewLineStatus += HEADERS_NEW_LINE_STATUS_0A;
                }
                else
                {
                    if ( *pByteInResponse == 0x0d)
                    {
                        filterContext->HeadersNewLineStatus += HEADERS_NEW_LINE_STATUS_0D;
                    }
                    else
                    {
                        filterContext->HeadersNewLineStatus = 0;
                    }
                }
                if (filterContext->HeadersNewLineStatus == HEADERS_NEW_LINE_STATUS_COMPLETE)
                {
                    pByteInResponse++;
                    break;
                }
            }


            if (filterContext->HeadersNewLineStatus == HEADERS_NEW_LINE_STATUS_COMPLETE)
            {
                filterContext->HeaderPassed = TRUE;
                if (pByteInResponse == pLastByteInResponse)
                {
                    return SF_STATUS_REQ_NEXT_NOTIFICATION;
                }
                else
                {
                    i = DIFF(pByteInResponse - startCompressionLocation);
                    success = pfc->WriteClient(pfc,startCompressionLocation,&i,0);
                    if ( !success )
                    {
                        DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                        return SF_STATUS_REQ_ERROR;
                    }
                    startCompressionLocation = pByteInResponse;
                    bytesToCompress = DIFF(pLastByteInResponse - startCompressionLocation);
                }
            }
            else
            {
                return SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
        }
        else
        {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }
    }

    //
    // Check that the compression scheme is valid.
    //

    if ( scheme->hDllHandle == NULL ) {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    //
    // If we don't yet have an initialized compression context, get one.
    //

    if ( filterContext->CompressionContext == NULL ) {

        hResult = scheme->CreateCompressionRoutine(
                      &filterContext->CompressionContext,
                      scheme->CreateFlags
                      );

        if ( FAILED( hResult) )
        {
            DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
            return SF_STATUS_REQ_ERROR;
        }
    }


    //
    // If the input data is chunked, we need a fairly complex path to
    // handle all the possible situations of chunk sizes and input
    // buffer sizes.
    //

    if ( filterContext->TransferChunkEncoded && bytesToCompress > 0 ) {

        do {

            //
            // Initially, we'll be looking at the chunk header.  This is
            // a hex represenatation of the number of bytes in this chunk.
            // Translate this number from ASCII to a DWORD.
            //

            ProcessChunkHeader(
                &startCompressionLocation,
                &bytesToCompress,
                &(filterContext->ChunkedBytesRemaining),
                &(filterContext->pcsState));

            DBG_ASSERT(startCompressionLocation <= (PBYTE)(phfrdData->pvInData) + phfrdData->cbInData);

            if (filterContext->pcsState == IN_CHUNK_DATA) {

                if (filterContext->ChunkedBytesRemaining == 0) {
                    break;
                }

                //
                // If there are more bytes in this chunk than the size of
                // this buffer, or if they're the same, then just compress
                // and send what we have.
                //

                if ( filterContext->ChunkedBytesRemaining > bytesToCompress ) {

                    if ( bytesToCompress > 0 ) {

                        success = CompressAndSendDataToClient(
                                      scheme,
                                      filterContext->CompressionContext,
                                      startCompressionLocation,
                                      bytesToCompress,
                                      pfc
                                      );
                        if ( !success )
                        {
                            DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                            return SF_STATUS_REQ_ERROR;
                        }

                        filterContext->ChunkedBytesRemaining -= bytesToCompress;
                        bytesToCompress = 0;
                    }

                } else {

                    //
                    // In this case, the buffer is larger than the chunk.
                    // Send what exists in this chunk, then prepare to loop
                    // around to look at the next chunk.
                    //

                    if ( filterContext->ChunkedBytesRemaining > 0 ) {

                        success = CompressAndSendDataToClient(
                                      scheme,
                                      filterContext->CompressionContext,
                                      startCompressionLocation,
                                      filterContext->ChunkedBytesRemaining,
                                      pfc
                                      );
                        if ( !success )
                        {
                            DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                            return SF_STATUS_REQ_ERROR;
                        }
                    }

                    //
                    // Update the number of bytes we've seen and the next
                    // location for getting input data.  Note that the end
                    // of a chunk has a CR-LF sequence, so go two bytes
                    // beyond the actual amount that we processed.
                    //

                    bytesToCompress -= filterContext->ChunkedBytesRemaining;
                    startCompressionLocation += filterContext->ChunkedBytesRemaining;
                    filterContext->ChunkedBytesRemaining = 0;
                    if (bytesToCompress == 0) {
                        filterContext->pcsState = AT_CHUNK_DATA_NEW_LINE;
                    }
                    else if (bytesToCompress == 1){
                        bytesToCompress--;
                        startCompressionLocation++;
                        filterContext->pcsState = IN_CHUNK_DATA_NEW_LINE;
                    }
                    else {
                        bytesToCompress -= 2;
                        startCompressionLocation += 2;
                        filterContext->pcsState = CHUNK_DATA_DONE;
                    }
                }
            }
            else {
                DBG_ASSERT(bytesToCompress == 0);
            }

        } while ( bytesToCompress > 0 );

    } else {

        //
        // This is the simplier, non-chunking path.  Just get the
        // compressed data to the client.
        //

        success = CompressAndSendDataToClient(
                      scheme,
                      filterContext->CompressionContext,
                      startCompressionLocation,
                      bytesToCompress,
                      pfc
                      );
        if ( !success )
        {
            DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
            return SF_STATUS_REQ_ERROR;
        }
    }

    //
    // Tell the server not to send any additional data; we've handled it
    // all here.
    //

    phfrdData->cbInData = 0;

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

} // OnSendRawData

#define DYNAMIC_COMPRESSION_BUFFER_SIZE 4096


BOOL
CompressAndSendDataToClient (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme,
    IN PVOID CompressionContext,
    IN PBYTE InputBuffer,
    IN DWORD BytesToCompress,
    IN PHTTP_FILTER_CONTEXT pfc
    )
{
    DWORD inputBytesUsed;
    DWORD bytesCompressed;
    HRESULT hResult;
    BOOL keepGoing;
    BOOL success;
    DWORD cbIo;
    CHAR compressionBuffer[8 + DYNAMIC_COMPRESSION_BUFFER_SIZE + 7];
    PCHAR startSendLocation;
    DWORD bytesToSend;
    BOOL finalChunkForEntity;

    //
    // Remember if this is the final call for this entity response.
    //

    if ( BytesToCompress == 0 ) {
        finalChunkForEntity = TRUE;
    } else {
        finalChunkForEntity = FALSE;
    }

    //
    // Perform compression on the actual file data.  Note that it is
    // possible that the compressed data is actually larger than the
    // input data, so we might need to call the compression routine
    // multiple times.
    //
    // Note that, in order to make it easy to do transfer chunk encoding
    // in a single buffer, we put the compressed data several bytes into
    // the dynamic compression buffer to leave space for the chunk size,
    // and we leave five bytes at the end for the trailing chunk info.
    //

    do {

        hResult = Scheme->CompressRoutine(
                      CompressionContext,
                      InputBuffer,
                      (LONG)BytesToCompress,
                      (PBYTE)(compressionBuffer + 6),
                      DYNAMIC_COMPRESSION_BUFFER_SIZE,
                      (PLONG)&inputBytesUsed,
                      (PLONG)&bytesCompressed,
                      (INT)Scheme->DynamicCompressionLevel
                      );
        if ( FAILED( hResult ) ) {
            return FALSE;
        }

        if ( hResult == S_OK && BytesToCompress == 0 ) {
            keepGoing = TRUE;
        } else {
            keepGoing = FALSE;
        }

        //
        // If the compressor gave us any data, then send the result to
        // the client.  Some compression schemes buffer up data in order
        // to perform better compression, so not every compression call
        // will result in output data.
        //

        if ( bytesCompressed > 0 ) {

            //
            // Add the CRLF that goes just before the chunk data, and
            // also the CRLF at the end of the chunk.
            //

            *(compressionBuffer + 4) = '\r';
            *(compressionBuffer + 5) = '\n';

            *(compressionBuffer + 6 + bytesCompressed) = '\r';
            *(compressionBuffer + 6 + bytesCompressed + 1) = '\n';

            //
            // Based on the order of magnitude of the size of this
            // chunk, write the chunk size.  Also note where we'll start
            // sending from the buffer and the total number of bytes
            // that we'll send.  This inline, loop-unrolled itoa() should
            // be somewhat more efficient than the C runtime version.
            //

            if ( bytesCompressed < 0x10 ) {

                startSendLocation = compressionBuffer + 3;
                bytesToSend = 3 + bytesCompressed + 2;
                *(compressionBuffer + 3) = HEX_TO_ASCII( bytesCompressed & 0xF );

            } else if ( bytesCompressed < 0x100 ) {

                startSendLocation = compressionBuffer + 2;
                bytesToSend = 4 + bytesCompressed + 2;

                *(compressionBuffer + 2) = HEX_TO_ASCII( (bytesCompressed >> 4) & 0xF );
                *(compressionBuffer + 3) = HEX_TO_ASCII( bytesCompressed & 0xF);

            } else if ( bytesCompressed < 0x1000 ) {

                startSendLocation = compressionBuffer + 1;
                bytesToSend = 5 + bytesCompressed + 2;
                *(compressionBuffer + 1) = HEX_TO_ASCII( (bytesCompressed >> 8) & 0xF );
                *(compressionBuffer + 2) = HEX_TO_ASCII( (bytesCompressed >> 4) & 0xF );
                *(compressionBuffer + 3) = HEX_TO_ASCII( bytesCompressed & 0xF);

            } else {

                DBG_ASSERT( bytesCompressed < 0x10000 );

                startSendLocation = compressionBuffer + 0;
                bytesToSend = 6 + bytesCompressed + 2;
                *(compressionBuffer + 0) = HEX_TO_ASCII( (bytesCompressed >> 12) & 0xF );
                *(compressionBuffer + 1) = HEX_TO_ASCII( (bytesCompressed >> 8) & 0xF );
                *(compressionBuffer + 2) = HEX_TO_ASCII( (bytesCompressed >> 4) & 0xF );
                *(compressionBuffer + 3) = HEX_TO_ASCII( bytesCompressed & 0xF);
            }

            success = pfc->WriteClient(
                          pfc,
                          startSendLocation,
                          &bytesToSend,
                          0
                          );
            if ( !success ) {
                return FALSE;
            }
        }

        //
        // Update the number of input bytes that we have compressed
        // so far, and adjust the input buffer pointer accordingly.
        //

        BytesToCompress -= inputBytesUsed;
        InputBuffer += inputBytesUsed;

    } while ( BytesToCompress > 0 || keepGoing );

    //
    // If this was the final bit of data for the entity, then send the
    // final bit of chunking so that the client knows that the response
    // is done.  This is a chunk of size zero followed by a CRLF pair.
    //
    // !!! It would be nice to combine this with the final call to
    //     WriteClient() in order to avoid an extra WriteClient()
    //     call: they are expensive.
    //

    if ( finalChunkForEntity ) {

        bytesToSend = 5;

        success = pfc->WriteClient( pfc, "0\r\n\r\n", &bytesToSend, 0 );
        if ( !success ) {
            return FALSE;
        }
    }

    return TRUE;

} // CompressAndSendDataToClient

VOID
DeleteChunkExtension (
    IN OUT PBYTE *Start,
    IN OUT PDWORD Bytes,
    IN OUT PCOMPRESS_CHUNK_STATE pcsState
    )
{
    PBYTE pbBlock;
    PBYTE pbPastBlock = *Start + *Bytes;

    DBG_ASSERT(*pcsState == IN_CHUNK_EXTENSION);

    //
    // Get rid of chunk extension
    //

    for ( pbBlock = *Start;
          (pbBlock < pbPastBlock) && (*pbBlock != 0xD);
          pbBlock++) {
    }

    *Bytes -= DIFF(pbBlock - *Start);
    *Start = pbBlock;

    if (pbBlock == pbPastBlock) {
        DBG_ASSERT(*Bytes == 0);

        //
        // Still in chunk extenstion, no state change
        //
    }
    else {
        DBG_ASSERT(*pbBlock == 0xD);
        if (*Bytes >= 2) {
            *Bytes -= 2;
            *Start += 2;
            *pcsState = IN_CHUNK_DATA;
        }
        else {
            DBG_ASSERT(*Bytes == 1);
            (*Bytes)--;
            (*Start)++;
            *pcsState = IN_CHUNK_HEADER_NEW_LINE;
        }
    }

}


VOID
GetChunkedByteCount (
    IN OUT PBYTE *Start,
    IN OUT PDWORD Bytes,
    IN OUT PDWORD pdwChunkDataLen,
    IN OUT PCOMPRESS_CHUNK_STATE pcsState
    )
{
    PBYTE pbBlock;
    DWORD dwChunkDataLen = *pdwChunkDataLen;
    PBYTE pbPastBlock = *Start + *Bytes;

    DBG_ASSERT((*pcsState == CHUNK_DATA_DONE) ||
               (*pcsState == IN_CHUNK_LENGTH));

    //
    // Walk to the first 0xD or ';', which signifies the end of the chunk byte
    // count.  As we're doing that, keep calculating the result size.
    //

    for ( pbBlock = *Start;
          (pbBlock < pbPastBlock) && (*pbBlock != 0xD) && (*pbBlock != ';');
          pbBlock++ ) {

        dwChunkDataLen <<= 4;

        if ( *pbBlock >= '0' && *pbBlock <= '9' ) {
            dwChunkDataLen += *pbBlock - '0';
        } else {
            DBG_ASSERT(((*pbBlock | 0x20) >= 'a') && ((*pbBlock | 0x20) <= 'f'));
            dwChunkDataLen += (*pbBlock | 0x20) - 'a' + 10;
        }
    }

    *Bytes -= DIFF(pbBlock - *Start );
    *Start = pbBlock;

    if (pbBlock == pbPastBlock) {
        DBG_ASSERT(*Bytes == 0);
        *pcsState = IN_CHUNK_LENGTH;
    }
    else if (*pbBlock == ';') {
        *pcsState = IN_CHUNK_EXTENSION;
    }
    else {
        DBG_ASSERT(*pbBlock == 0xD);
        if (*Bytes >= 2) {
            *Bytes -= 2;
            *Start += 2;
            *pcsState = IN_CHUNK_DATA;
        }
        else {
            DBG_ASSERT(*Bytes == 1);
            (*Bytes)--;
            (*Start)++;
            *pcsState = IN_CHUNK_HEADER_NEW_LINE;
        }
    }

    *pdwChunkDataLen = dwChunkDataLen;
}

VOID
ProcessChunkHeader (
    IN OUT PBYTE *Start,
    IN OUT PDWORD Bytes,
    IN OUT PDWORD pdwChunkDataLen,
    IN OUT PCOMPRESS_CHUNK_STATE pcsState
    )
{

    switch (*pcsState) {
    case IN_CHUNK_LENGTH:
    case CHUNK_DATA_DONE:
        GetChunkedByteCount(Start,
                            Bytes,
                            pdwChunkDataLen,
                            pcsState);
        if (*pcsState == IN_CHUNK_EXTENSION) {
            DeleteChunkExtension(Start,
                                Bytes,
                                pcsState);
        }
        break;

    case IN_CHUNK_EXTENSION:
        DeleteChunkExtension(Start,
                            Bytes,
                            pcsState);
        break;
    case IN_CHUNK_HEADER_NEW_LINE:
        if (*Bytes >= 1) {
            (*Start)++;
            (*Bytes)--;
            *pcsState = IN_CHUNK_DATA;
        }
        break;
    case AT_CHUNK_DATA_NEW_LINE:
        if (*Bytes >= 1) {
            (*Start)++;
            (*Bytes)--;
            *pcsState = IN_CHUNK_DATA_NEW_LINE;
        }

        //
        // Flow through into the in new line case
        //

    case IN_CHUNK_DATA_NEW_LINE:
        if (*Bytes >= 1) {
            (*Start)++;
            (*Bytes)--;
            *pcsState = CHUNK_DATA_DONE;
            ProcessChunkHeader (Start,
                                Bytes,
                                pdwChunkDataLen,
                                pcsState);
        }
        break;
    case IN_CHUNK_DATA:
        break;
    default: DBG_ASSERT(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\filter\sendresp.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sendresp.c

Abstract:

    Contains the source code for the SF_NOTIFY_SEND_RESPONSE notification
    for the ISAPI compression filter.

Author:

    David Treadwell (davidtr)   16-July-1997

Revision History:

--*/

#include "compfilt.h"



DWORD
OnSendResponse (
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_SEND_RESPONSE phfsrData
    )

/*++

Routine Description:

    We use this notification to determine whether the outgoing response
    has "Expires:" and "Cache-Control: max-age=" headers, and add them
    if necessary.  The motivation for adding both of these headers is
    that HTTP 1.0 caches, which do not understand Cache-Control but do
    understand Expires, will not cache our compressed responses as a
    result of an Expires header in the past (the item is considered
    already expired).  If 1.0 proxies did attempt to cache compressed
    data, they might return it to 1.0 clients which cannot parse the
    compressed data.

    With HTTP 1.1 proxies, the max-age directive of the Cache-Control
    header is defined in the RFC 2068 always to override Expires, so we
    set this with a max-age field so that HTTP 1.1 proxies, which are
    supposed to understand the Vary: Accept-Encoding header we also
    send, will be able to cache both compressed and uncompressed
    responses.

Arguments:

    pfc - The filter context from the web server.

    phfsrData - the HTTP_FILTER_SEND_RESPONSE that gives us pointers to
        add and delete HTTP headers.

Return Value:

    SF_STATUS_REQ_NEXT_NOTIFICATION if everything worked, or
    SF_STATUS_REQ_ERROR if we had a problem with this request.

--*/

{
    BOOL success;
    CHAR buffer[512];
    DWORD bufferSize;
    PCOMPFILT_FILTER_CONTEXT filterContext;

    //
    // If we're not configured for any sort of compression, do nothing
    // here.
    //
    // There is a tiny risk that the compression config changes after
    // the URL_MAP notification but before this notification.  In that
    // circumstance, pending requests may get incorrect behavior.
    // However, it would be extremely difficult to synchronize around
    // that effect, and the downside is small, so we ignore it.
    //

    if ( !DoStaticCompression && !DoDynamicCompression ) {
        DisableNotifications (pfc,0xffffffff,NULL);
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }


    //
    // If there is a filter context for this request, then we're doing
    // dynamic compression.  We'll use this notification to know that
    // all of the HTTP headers have been passed, and we can start to
    // compress the entity body.  Note that using this mechanism means
    // that an ISAPI extension that uses WriteClient() to send headers
    // itself will not ever get anything compressed.  This is a
    // reasonable tradeoff, since this sort of ISAPI extension is
    // discouraged.
    //

    filterContext = (PCOMPFILT_FILTER_CONTEXT)GET_COMPFILT_CONTEXT( pfc ) ;


    //
    // If we're returning a status code not in the 200 range, do nothing
    // here.  Note that the failure to set OnSendResponseCalled below
    // will avoid all dynamic compression for this request, which is
    // reasonable behavior for failed requests.
    //

    if ( phfsrData->HttpStatus < 200 || phfsrData->HttpStatus > 299 ) 
    {

        // in case it was rwquest for static file, we had already added content-encoding header
        // so we will remove it.

        if ( IS_SUCCESSFUL_STATIC( pfc ) ) 
        {
            SET_REQUEST_DONE( pfc );
            success = phfsrData->SetHeader( pfc, "Content-Encoding:", NULL );

        }
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }


    if ( filterContext != NULL ) {

        filterContext->OnSendResponseCalled = TRUE;

        //
        // If we don't have a matching scheme, bail here.
        //

        if ( filterContext->Scheme == NULL ) {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        //
        // If this is a dynamic request, determine whether the request
        // is already chunked and add the appropriate response headers.
        // For static requests, these headers will already have been
        // added.
        //

        if ( filterContext->DynamicRequest ) {

            //
            // If the ISAPI/CGI has already chunked the request, then we
            // need to remove the chunking before compression.
            // Determine if "Transfer-Encoding: chunked" is already in
            // the response headers.
            //

            bufferSize = sizeof(buffer);

            success = phfsrData->GetHeader(
                                  pfc,
                                  "Transfer-Encoding:",
                                  buffer,
                                  &bufferSize
                                  );

            //
            // Note: 377 in octal is equal to 255 decimal and 0xFF hex.
            // The comparisons are done in this fashion for maximum
            // efficiency.
            //

            if ( success &&
                     ((*(UNALIGNED64 DWORD *)buffer) | 0x20202020) == 'nuhc' &&
                     ((*(UNALIGNED64 DWORD *)(buffer+4)) | 0xFF202020) == '\377dek' ) {

                filterContext->TransferChunkEncoded = TRUE;
            }

            //
            // All compressed responses need to include the
            // Content-Encoding header.  This is what tells the user
            // agent how the file/content was compressed.
            //

            success = phfsrData->SetHeader(
                                  pfc,
                                  "Content-Encoding:",
                                  filterContext->Scheme->pszCompressionSchemeName
                                  );
            if ( !success ) 
            {
                DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                return SF_STATUS_REQ_ERROR;
            }

            //
            // Kill the Content-Length header if it is present.  Since
            // we're going to compress the response, the Content-Length
            // value will necessarily change.
            //

            success = phfsrData->SetHeader( pfc, "Content-Length:", NULL );
            if ( !success ) 
            {
                DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                return SF_STATUS_REQ_ERROR;
            }

            //
            // Now, add the "Transfer-Encoding: chunked" header to
            // indicate that this response will be sent in chunks.
            //

            success = phfsrData->SetHeader( pfc, "Transfer-Encoding:", "chunked" );
            if ( !success ) 
            {
                DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                return SF_STATUS_REQ_ERROR;
            }
        }

    } 
    else 
    {
        if ( !IS_SUCCESSFUL_STATIC( pfc ) ) 
        {

        //
        // There is no filter context and this is not a successful
        // static compression request.  Therefore, this was an
        // unsuccessful request and we should just ignore this
        // notification.
        //

        return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }
        else
        {
            SET_REQUEST_DONE( pfc );
        }
    }

    //
    // A user can disable the Cache-Control and Expires we add if they
    // want.  However, this is a little risky when interoperating with
    // HTTP 1.0 proxies.  Thus, in general this should only be done if
    // also setting NoCompressionForProxies == TRUE and
    // NoCompressionForHttp10 == TRUE.
    //
    //

    if ( SendCacheHeaders ) {

        //
        // Always set the Expires: header, reardless of whether it has
        // already been set.  We assume that anything that sets Expires:
        // will also set a Cache-Control: max-age, so resetting Expires:
        // will not damage any HTTP 1.1 clients and proxies.
        //

        success = phfsrData->SetHeader( pfc, "Expires:", ExpiresHeader );
        if ( !success ) 
        {
            DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
            return SF_STATUS_REQ_ERROR;
        }

        //
        // With Cache-Control, only add the max-age directive if the
        // response does not already have this directive.  If the
        // response already has max-age, then use that for our response.
        // The most important thing with max-age is that it get sent,
        // but the specific setting isn't critical for us, so we should
        // definitely respect anything other software sets for this.
        //

        bufferSize = sizeof(buffer);

        success =  phfsrData->GetHeader( pfc, "Cache-Control:", buffer, &bufferSize );

        if ( !success ) {

            //
            // The attempt to retrieve the Cache-Control header failed, so
            // assume that there was none and add one.
            //

            success = phfsrData->SetHeader( pfc, "Cache-Control:", CacheControlHeader );
            if ( !success ) 
            {
                DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                return SF_STATUS_REQ_ERROR;
            }

        } else {

            //
            // There is a Cache-Control header already in this response.
            // Scan it to see if there is a max-age directive or another
            // directive such as no-cache that obviates the need for
            // max-age.  If not, build a new Cache-Control header by
            // concatenating the old information with the max-age
            // directive we have configured.
            //

            if ( DoesCacheControlNeedMaxAge( buffer ) ) {

                //
                // There is no max-age directive on the Cache-Control
                // header for this response.  First test to make sure
                // that we have enough space to write the full new
                // Cache-Control header.  Note the rather silly
                // assumption that we'll have 100 bytes to write.  In
                // general, it is pretty impossible to believe that
                // max-age will take anywhere near this number of bytes,
                // so this assumption should be safe.
                //

                if ( bufferSize + 100 > sizeof(buffer) ) 
                {
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                    return SF_STATUS_REQ_ERROR;
                }

                //
                // Now concatenate a comma, a space and our default max-age
                // setting to the Cache-Control header that does exist in
                // this response.
                //

                *(buffer + bufferSize - 1) = ',';
                *(buffer + bufferSize) = ' ';
                strcpy( buffer + bufferSize + 1, CacheControlHeader );

                success = phfsrData->SetHeader( pfc, "Cache-Control:", buffer );
                if ( !success ) 
                {
                    DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                    return SF_STATUS_REQ_ERROR;
                }
            }
        }
    }

    //
    // If necessary, add the Vary header so that proxies know how to
    // return compress cached information.  Note that some HTTP 1.1
    // proxies (e.g.  Microsoft Catapult) will treat Vary as a sign not
    // to cache the entity.  This is an unfortunate but necessary side
    // effect.  We first attempt to retrieve the Vary header in case
    // it has already been added to the response.
    //

    bufferSize = sizeof(buffer);

    success =  phfsrData->GetHeader( pfc, "Vary:", buffer, &bufferSize );

    if ( !success ) {

        //
        // The attempt to retrieve the Vary header failed, so assume
        // that there was none and add one.
        //

        success = phfsrData->SetHeader( pfc, "Vary:", "Accept-Encoding" );
        if ( !success ) 
        {
            DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
            return SF_STATUS_REQ_ERROR;
        }

    } else {

        //
        // There is a Vary header already in this response.  Scan it to
        // see if there is a "*" in the header value, indicating that
        // all the incoming header values (including Accept-Encoding)
        // cause the response to change.  Thus, with a "*" we should not
        // add anything.  If not, build a new Vary header by
        // concatenating the old information with Accept-Encoding.
        //

        if ( strchr( buffer, '*' ) == NULL ) {

            //
            // There is no "*" in the Vary header for this response.
            // First test to make sure that we have enough space to
            // write the full new Vary header.  Note the rather silly
            // assumption that we'll have 100 bytes to write.  In
            // general, it is pretty impossible to believe that max-age
            // will take anywhere near this number of bytes, so this
            // assumption should be safe.
            //

            if ( bufferSize + 100 > sizeof(buffer) ) 
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                return SF_STATUS_REQ_ERROR;
            }

            //
            // Now concatenate a comma, a space and "Accept-Encoding"
            // to the Vary header that does exist in this response.
            //

            *(buffer + bufferSize - 1) = ',';
            *(buffer + bufferSize) = ' ';
            strcpy( buffer + bufferSize + 1, "Accept-Encoding" );

            success = phfsrData->SetHeader( pfc, "Vary:", buffer );
            if ( !success ) 
            {
                DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                return SF_STATUS_REQ_ERROR;
            }
        }
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

} // OnSendResponse


BOOL
DoesCacheControlNeedMaxAge (
    IN PCHAR CacheControlHeaderValue
    )

/*++

Routine Description:

    This function performs a high-performance scan to determine whether
    the Cache-Control header on a compressed response needs to have the
    max-age directive added.  If there is already a max-age, or if there
    is a no-cache directive, then we should not add max-age.

Arguments:

    CacheControlHeaderValue - the value of the cache control header to
        scan.  The string should be zero-terminated.

Return Value:

    TRUE if we need to add max-age; FALSE if we should not add max-age.

--*/

{
    PCHAR s;

    //
    // If the string length is less than four bytes, we know that this
    // header needs max-age.  We do this test up front so that we can
    // do fast DWORD compares for the directives we're looking for.
    //

    s = CacheControlHeaderValue;

    if ( *s == '\0' || *(s+1) == '\0' || *(s+2) == '\0' ) {
        return TRUE;
    }

    //
    // Walk the string doing fast DWORD compares for the start of the
    // directives that are relevent.  This should be a lot faster than
    // two strstr() calls: it walks the string only once, and it avoids
    // making many tests that will fail since it tests four bytes at
    // once instead of just one byte.
    //

    for ( ; *(s+3) != '\0'; s++ ) {

        //
        // First look for a preexisting max-age header.  We compare
        // against the beginning of the string but backwards because
        // NT is little endian.
        //
        // The reason for the bitwise-OR operation here is to convert
        // the relevent character portions of the comparison DWORD to
        // lowercase.  HTTP doesn't define any case sensitivity for
        // Cache-Control directives.  This OR trick depends on the
        // fact that the only difference between uppercase characters
        // and lowercase characters is that lowercase characters have
        // bit position 0x20 turned on.
        //

        if ( (*(UNALIGNED64 DWORD *)s | 0x00202020) == '-xam' ) {

            //
            // Looks like we have a max-age header.  Make sure that the
            // next few bytes finish it off correctly.  It would be nice
            // to do another DWORD comparison here, but we can't know
            // for that we wouldn't walk off the end of the string if we
            // tried that, so look at it one byte at a time.
            //
            // In order to prevent walking off the end of the string, we
            // depend on the fact that all the comparisons will fail as
            // soon as one of them fails.  Thus, when we compare against
            // '\0', it will fail and we won't look at any more
            // characters.
            //

            if ( (*(s+4) | 0x20) == 'a' &&
                 (*(s+5) | 0x20) == 'g' &&
                 (*(s+6) | 0x20) == 'e' ) {

                return FALSE;
            }
        }

        //
        // Repeat the same stuff for no-cache.  The one difference here
        // is that if the no-cache directive is followed by an equals
        // sign ("="), then no-cache is referring only to one of the
        // response header fields and not to the entire response.
        // Therefore, don't bag the response if it is "no-cache=foo".
        //

        if ( (*(UNALIGNED64 DWORD *)s | 0x20002020) == 'c-on' ) {

            if ( (*(s+4) | 0x20) == 'a' &&
                 (*(s+5) | 0x20) == 'c' &&
                 (*(s+6) | 0x20) == 'h' &&
                 (*(s+7) | 0x20) == 'e' &&
                 *(s+8) != '=' ) {

                return FALSE;
            }
        }
    }

    //
    // We didn't find any directives that would prevent us from adding
    // max-age.
    //

    return TRUE;

} // DoesCacheControlNeedMaxAge
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\comninit.c ===
//
// comninit.c
//
// Initialisation code common to inflate and deflate
//
#include <crtdbg.h>
#include "inflate.h"
#include "deflate.h"


// Called by InitCompression() and InitDecompression() (functions to init global DLL data)
//
// Initialises the tree lengths of static type blocks
//
void InitStaticBlock(void)
{
    int i;

    // No real thread synchronisation problems with doing this
    if (g_InitialisedStaticBlock == FALSE)
    {
        g_InitialisedStaticBlock = TRUE;

        for (i = 0; i <= 143; i++)
        	g_StaticLiteralTreeLength[i] = 8;

        for (i = 144; i <= 255; i++)
	        g_StaticLiteralTreeLength[i] = 9;

        for (i = 256; i <= 279; i++)
	        g_StaticLiteralTreeLength[i] = 7;

        for (i = 280; i <= 287; i++)
	        g_StaticLiteralTreeLength[i] = 8;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\api_int.h ===
/*
 * api_int.h
 *
 * Internal API function prototypes and flags
 *
 * The api.h which is given to decompression clients is hand-created from this file.
 */

// flags for CreateCompression() and CreateDeCompression()
#define COMPRESSION_FLAG_DEFLATE    0 
#define COMPRESSION_FLAG_GZIP       1 

#define COMPRESSION_FLAG_DO_GZIP      COMPRESSION_FLAG_GZIP
#define DECOMPRESSION_FLAG_DO_GZIP    COMPRESSION_FLAG_GZIP

// Initialise global DLL compression data
HRESULT	WINAPI InitCompression(VOID);

// Initialise global DLL decompression data
HRESULT	WINAPI InitDecompression(VOID);

// Free global compression data
VOID    WINAPI DeInitCompression(VOID);

// Free global decompression data
VOID    WINAPI DeInitDecompression(VOID);

// Create a new compression context
HRESULT	WINAPI CreateCompression(PVOID *context, ULONG flags);

// Compress data
HRESULT WINAPI Compress(
	PVOID				context,            // compression context
	CONST BYTE *		input_buffer,       // input buffer
	LONG				input_buffer_size,  // size of input buffer
	PBYTE				output_buffer,      // output buffer
	LONG				output_buffer_size, // size of output buffer
	PLONG				input_used,         // amount of input buffer used
	PLONG				output_used,        // amount of output buffer used
	INT					compression_level   // compression level (1...10)
);

// Reset compression state (for compressing new file)
HRESULT	WINAPI ResetCompression(PVOID context);

// Destroy compression context
VOID	WINAPI DestroyCompression(PVOID context);

// Create a decompression context
HRESULT WINAPI CreateDecompression(PVOID *context, ULONG flags);

// Decompress data
HRESULT WINAPI Decompress(
	PVOID				void_context,
	CONST BYTE *		input, 
	LONG				input_size,
	BYTE *				output, 
	LONG				output_size,
	PLONG				input_used,
	PLONG				output_used
);

HRESULT	WINAPI ResetDecompression(PVOID void_context);

VOID	WINAPI DestroyDecompression(PVOID void_context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\crc32.h ===
//
// crc32.h
//
// CRC32 table
//
#ifdef DECLARE_DATA
const ULONG g_CrcTable[256] = {
  0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
  0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
  0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
  0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
  0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
  0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
  0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
  0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
  0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
  0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
  0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
  0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
  0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
  0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
  0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
  0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
  0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
  0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
  0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
  0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
  0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
  0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
  0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
  0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
  0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
  0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
  0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
  0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
  0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
  0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
  0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
  0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
  0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
  0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
  0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
  0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
  0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
  0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
  0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
  0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
  0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
  0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
  0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
  0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
  0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
  0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
  0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
  0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
  0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
  0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
  0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
  0x2d02ef8dL
};
#else /* !DECLARE_DATA */
extern const ULONG g_CrcTable[256];
#endif /* DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\common.h ===
/*
 * common.h
 *
 * Definitions common to inflate and deflate
 */
#include "types.h"

#define NUM_CHARS				256
#define MIN_MATCH				3
#define MAX_MATCH				258

// window size
#define WINDOW_SIZE				32768
#define WINDOW_MASK				32767

// ZIP block types
#define BLOCKTYPE_UNCOMPRESSED	0
#define BLOCKTYPE_FIXED			1
#define BLOCKTYPE_DYNAMIC		2

// it's 288 and not 286 because we of the two extra codes which can appear
// in a static block; same for 32 vs 30 for distances
#define MAX_LITERAL_TREE_ELEMENTS	288
#define MAX_DIST_TREE_ELEMENTS		32
	
#define END_OF_BLOCK_CODE		256
#define	NUM_PRETREE_ELEMENTS	19
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\api.c ===
/*
 * api.c
 *
 * Externally declared APIs
 */
#include <crtdbg.h>

#define DECLARE_DATA
#include "inflate.h"
#include "deflate.h"
#include "api_int.h"
#include "infgzip.h"
#include "fasttbl.h"
#include "crc32.h"


//
// Initialise global compression 
//
HRESULT WINAPI InitCompression(VOID)
{
	deflateInit();
	return S_OK;
}


//
// Initialise global decompression 
//
HRESULT WINAPI InitDecompression(VOID)
{
	inflateInit();
	return S_OK;
}


//
// De-init global compression
//
VOID WINAPI DeInitCompression(VOID)
{
}


//
// De-init global decompression
//
VOID WINAPI DeInitDecompression(VOID)
{
}


//
// Create a compression context
//
HRESULT WINAPI CreateCompression(PVOID *context, ULONG flags)
{
	t_encoder_context *ec;

    *context = (PVOID) LocalAlloc(LMEM_FIXED, sizeof(t_encoder_context));

    if (*context == NULL)
        return E_OUTOFMEMORY;

    ec = (t_encoder_context *) (*context);

    // no encoders initialised yet
	ec->std_encoder     = NULL;
    ec->optimal_encoder = NULL;
    ec->fast_encoder    = NULL;

    if (flags & COMPRESSION_FLAG_DO_GZIP)
        ec->using_gzip      = TRUE;
    else
        ec->using_gzip      = FALSE;

    InternalResetCompression(ec);

	return S_OK;
}


//
// Destroy a compression context
//
VOID WINAPI DestroyCompression(PVOID void_context)
{
    t_encoder_context *context = (t_encoder_context *) void_context;

    _ASSERT(void_context != NULL);

    if (context->std_encoder != NULL)
        LocalFree((PVOID) context->std_encoder);

    if (context->optimal_encoder != NULL)
        LocalFree((PVOID) context->optimal_encoder);

    if (context->fast_encoder != NULL)
        LocalFree((PVOID) context->fast_encoder);

	LocalFree(void_context);
}


//
// Create a decompression context
//
HRESULT WINAPI CreateDecompression(PVOID *context, ULONG flags)
{
	*context = (PVOID) LocalAlloc(LMEM_FIXED, sizeof(t_decoder_context));

    if (*context == NULL)
        return E_OUTOFMEMORY;

    if (flags & DECOMPRESSION_FLAG_DO_GZIP)
        ((t_decoder_context *) (*context))->using_gzip = TRUE;
    else
        ((t_decoder_context *) (*context))->using_gzip = FALSE;

	return ResetDecompression(*context);
}


//
// Destroy decompression context
//
VOID WINAPI DestroyDecompression(PVOID void_context)
{
    LocalFree(void_context);
}


//
// Reset compression context
//
HRESULT WINAPI ResetCompression(PVOID void_context)
{
	t_encoder_context *context = (t_encoder_context *) void_context;

    InternalResetCompression(context);

    // This forces a realloc of the particular compressor we are using
    // each time we reset, but if we don't do this then we are stuck with one
    // compressor (fast,std,optimal) forever until we destroy the context.
    // Should create a workaround for this problem.  Luckily, IIS creates a
    // new context all the time, and doesn't call reset (so says davidtr).
    DestroyIndividualCompressors(context);

	return S_OK;
}


//
// Reset decompression context
//
HRESULT WINAPI ResetDecompression(PVOID void_context)
{
	t_decoder_context *context = (t_decoder_context *) void_context;

    if (context->using_gzip)
    {
    	context->state	= STATE_READING_GZIP_HEADER;
        context->gzip_header_substate = 0;
        DecoderInitGzipVariables(context);
    }
    else
    {
	    context->state	= STATE_READING_BFINAL_NEED_TO_INIT_BITBUF;
    }

    context->bufpos = 0;
	context->bitcount = -16;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\deflate.h ===
//
// deflate.h
//

// common to inflate and deflate
#include "common.h"


// ZIP constants
#define NUM_LENGTH_BASE_CODES		29
#define NUM_DIST_BASE_CODES			30

#define NUM_PRETREE_ELEMENTS		19


//
// For std and optimal encoders, recording buffer encoding max bit lengths and
// decoding table sizes
//
#define REC_LITERALS_DECODING_TABLE_BITS 12
#define REC_DISTANCES_DECODING_TABLE_BITS 8

#define REC_LITERALS_DECODING_TABLE_SIZE (1 << REC_LITERALS_DECODING_TABLE_BITS)
#define REC_LITERALS_DECODING_TABLE_MASK (REC_LITERALS_DECODING_TABLE_SIZE-1)

#define REC_DISTANCES_DECODING_TABLE_SIZE (1 << REC_DISTANCES_DECODING_TABLE_BITS)
#define REC_DISTANCES_DECODING_TABLE_MASK (REC_DISTANCES_DECODING_TABLE_SIZE-1)

//
// The maximum code lengths to allow for recording (we don't want really large
// 15 bit codes, just in case uncommon chars suddenly become common due to a change
// in the data).
//
#define RECORDING_DIST_MAX_CODE_LEN	9
#define RECORDING_LIT_MAX_CODE_LEN	13


//
// Max size of tree output (in bytes)
//
// We require that the output buffer have at least this much data available, so that we can
// output the tree in one chunk
//
#define MAX_TREE_DATA_SIZE			512


//
// Return the position slot (0...29) of a match offset (0...32767)
//
#define POS_SLOT(pos) g_DistLookup[((pos) < 256) ? (pos) : (256 + ((pos) >> 7))]


// context structure
#include "defctxt.h"

// encoders
#include "stdenc.h"
#include "optenc.h"
#include "fastenc.h"

// prototypes
#include "defproto.h"

// variables
#include "defdata.h"
#include "comndata.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\comndata.h ===
//
// comndata.h
//
// Common to inflate and deflate
//
#ifndef _COMNDATA_H
#define _COMNDATA_H

#ifdef DECLARE_DATA

const BYTE g_CodeOrder[] = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
const BYTE g_ExtraLengthBits[] = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
const BYTE g_ExtraDistanceBits[] = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0};
const ULONG g_LengthBase[] = {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};
const ULONG g_DistanceBasePosition[] = {1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
const ULONG g_BitMask[] = {0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767};

BYTE    g_LengthLookup[256];
BYTE    g_DistLookup[512];

BYTE    g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
USHORT  g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];

// note: g_StaticDistanceTreeLength == 5 for all distances, which is why we don't have a
// table for that
USHORT  g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

BOOL    g_InitialisedStaticBlock = FALSE;

#else /* !DECLARE_DATA */

extern const BYTE g_CodeOrder[19];
extern const BYTE g_ExtraLengthBits[];
extern const BYTE g_ExtraDistanceBits[];
extern const ULONG g_LengthBase[];
extern const ULONG g_DistanceBasePosition[];
extern const ULONG g_BitMask[];

extern BYTE     g_LengthLookup[256];
extern BYTE     g_DistLookup[512];

extern BYTE     g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

extern BOOL     g_InitialisedStaticBlock;

#endif /* !DECLARE_DATA */

#endif /* _COMNDATA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\filter\urlmap.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    urlmap.c

Abstract:

    Contains the source code for the SF_NOTIFY_URL_MAP notification of
    the ISAPI compression filter.

Author:

    David Treadwell (davidtr)   16-July-1997

Revision History:

--*/

#include "compfilt.h"





DWORD
OnUrlMap (
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_URL_MAP phfumData
    )
{
    DWORD dwClientCompressionCount;
    LPSTR clientCompressionArray[MAX_CLIENT_COMPRESSION_SCHEMES];
    PCHAR s;
    LPSTR fileExtension;
    DWORD i;
    PSUPPORTED_COMPRESSION_SCHEME scheme;
    CHAR compressedFileName[512];
    DWORD compressedFileNameLength;
    DWORD originalFileNameLength;
    BOOL success;
    BOOL fVerbIsGET = FALSE;
    DWORD schemeIndex;
    PSUPPORTED_COMPRESSION_SCHEME firstOnDemandScheme = NULL;
    CHAR acceptEncoding[512];
    CHAR buffer[512];
    DWORD cb;
    HANDLE hFile;
    PCOMPFILT_FILTER_CONTEXT filterContext;
    DWORD   retValue = SF_STATUS_REQ_NEXT_NOTIFICATION;
    LARGE_INTEGER           originalFileSize;
    LPTS_OPEN_FILE_INFO     pofiOriginalFile = NULL; 
    FILETIME                originalFileTime;
    TSVC_CACHE              tsvcGarbage;


    Write(( DEST,
            "%d [OnUrlMap] Server is mapping url %s to path %s\n",
            pfc->pFilterContext,
            phfumData->pszURL,
            phfumData->pszPhysicalPath ));

    //
    // If we're not configured for any sort of compression, do nothing
    // here.  We really shouldn't get here if we properly disabled this
    // notification when compression got disabled, but this is just being
    // extra safe at minimal cost.
    //

    if ( !DoStaticCompression && !DoDynamicCompression ) {
        DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
        goto exit_part;
    }

    if (IS_URLMAP_DONE(pfc)) {
        DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
        goto exit_part;
    }

    filterContext = (PCOMPFILT_FILTER_CONTEXT)GET_COMPFILT_CONTEXT( pfc ) ;

    if (filterContext == NULL)
    {
        SET_URLMAP_DONE(pfc);
    }
    else
    {
        goto exit_part;
    }


    //
    // call the special server support fuction to get the Accept-Encoding
    // header and the verb
    //
    success = pfc->ServerSupportFunction(
                      pfc,
                      (SF_REQ_TYPE)SF_REQ_COMPRESSION_FILTER_CHECK,
                      acceptEncoding,
                      (ULONG_PTR)buffer,
                      sizeof(acceptEncoding)
                      );

    if ( !success ) {

        //
        // Disable all further notifications to this filter for this
        // particular request.  This will keep things reasonably fast
        // when talking with clients that cannot do compression.
        //

        DisableNotifications (pfc,ALL_NOTIFICATIONS,COMPFILT_NO_COMPRESSION);
        goto exit_part;
    }

    if (*(UNALIGNED64 DWORD *)buffer == '\0TEG')
    {
        fVerbIsGET = TRUE;
    }


    //
    // If we're configured to reject clients with an HTTP version less
    // than 1.1, then grab the HTTP version in the request.  Note that
    // proxies are *supposed* to downgrade the version if it is lower
    // than their version, but some broken 1.0 proxies fail to do this.
    //

    if ( NoCompressionForHttp10 ) {

        cb = sizeof(buffer);

        success = pfc->GetServerVariable( pfc, "HTTP_VERSION", buffer, &cb );
        if ( !success ) {
            DisableNotifications(pfc, ALL_NOTIFICATIONS,
                                 COMPFILT_NO_COMPRESSION);
            goto exit_part;
        }

        //
        // The version is returned as a string like "HTTP/1.1".  Test
        // against the bytes far enough into this string.
        //

        if ( *(UNALIGNED64 DWORD *)buffer != 'PTTH' ||
            *(buffer+5) == '0' || (*(buffer+5) == '1' && *(buffer+7) == '0') ) 
        {

            //
            // The request version is 1.0 or below.  For purposes of
            // compression, ignore this request.
            //

            DisableNotifications(pfc, ALL_NOTIFICATIONS,
                                 COMPFILT_NO_COMPRESSION);
            goto exit_part;
        }
    }

    //
    // If we're configured not to do compression for requests that come
    // through proxy servers, then grab the Via: header to see if this
    // is a proxied request.  Note that older proxies don't add this
    // header, so this is an imperfect test.  If someone really wants to
    // prevent compression through proxies, they should also set
    // NoCompressionForHttp10 so that older proxies fail.
    //

    if ( NoCompressionForProxies ) {

        cb = sizeof(buffer);

        success = pfc->GetServerVariable( pfc, "HTTP_VIA", buffer, &cb );

        //
        // In this case, we want to fail if the call succeeded.  If
        // there was no Via: header, then the call will fail.
        //

        //
        // kestutip: disabled all requests as if this connection was
        // through proxy even if it is keep alive all requests will come
        // from proxy too.
        //
        if ( success ) {
            DisableNotifications (pfc,0xffffffff,COMPFILT_NO_COMPRESSION);
            goto exit_part;
        }
    }

    //
    // If we're configured not to do compression for Range requests,
    // then bail.  There is some confusion as to the correct behavior
    // when there are both Range: and Accept-Encoding: headers: should
    // the Range: apply to the compressed version of the object or the
    // uncompressed version?  As of 11/24/97, it looks like the HTTP
    // working group is leaning toward having the Range: apply to the
    // compressed version, which is what we support without any
    // additional effort.  However, this switch allows for the more
    // conservative behavior of never returning compressed data in the
    // face of a Range: request.
    //

    if ( NoCompressionForRangeRequests ) {

        cb = sizeof(buffer);

        success = pfc->GetServerVariable( pfc, "HTTP_RANGE", buffer, &cb );

        //
        // In this case, we want to fail if the call succeeded.  If
        // there was no Range: header, then the call will fail.
        //

        if ( success ) {
            DisableNotifications(pfc, ALL_NOTIFICATIONS,
                                 COMPFILT_NO_COMPRESSION);
            goto exit_part;
        }
    }

    //
    // Grab the mapped file extension for comparison purposes.  Make
    // sure not to walk off the beginning of the name buffer.
    //

    originalFileNameLength = strlen( phfumData->pszPhysicalPath );

    for ( s = phfumData->pszPhysicalPath + originalFileNameLength;
          *s != '.' && s > phfumData->pszPhysicalPath;
          s = CharPrevExA(
                  CP_ACP,
                  phfumData->pszPhysicalPath,
                  s,
                  0 ) );

    if ( s == phfumData->pszPhysicalPath )
    {
        fileExtension = NULL;
    }
    else
    {
        fileExtension = s + 1;
    }

    //
    // Parse out the compression schemes that the client understands.
    //

    dwClientCompressionCount = 1;
    clientCompressionArray[0] = acceptEncoding;

#if COMPRESSION_DBCS

    //
    // Technically we should provide DBCS support but we
    // the only schemes currently defined or supported by
    // this filter are gzip and deflate, so we don't need
    // it now, and this is on the perf path, so ifdef it out.
    //

    //
    // Lowercase the scheme from the client to facilitate
    // case-insensitive comparisons.
    //

    CharLowerBuff(acceptEncoding,
                  strlen(acceptEncoding));
#endif

    for ( s = acceptEncoding;
          *s != '\0' &&
              dwClientCompressionCount < MAX_CLIENT_COMPRESSION_SCHEMES;
#if COMPRESSION_DBCS
          s = CharNextExA(
              CP_ACP,
              s,
              0 ) ) {
#else
          s++ ) {
#endif

        //
        // If the current character is a comma or white space, then it
        // delimits compression schemes supported by the client.
        //

        if ( *s == ',' || *s == ' ' ) {

            //
            // Put a terminator on this compression scheme name.
            //

            *s++ = '\0';

            //
            // Skip over white space.
            //

            while ( *s == ' ' ) {
                s++;
            }

            //
            // If we're pointing at the end of the string now, then just
            // quit searching.
            //

            if ( *s == '\0' ) {
                break;
            }

            //
            // Point the next array entry at the next client compression
            // scheme.
            //

            clientCompressionArray[dwClientCompressionCount++] = s;

        } else {

#if COMPRESSION_DBCS
            //
            // Just let the for loop skip this character
            //
#else
            //
            // Lowercase the scheme from the client to facilitate
            // case-insensitive comparisons.
            //

            *s |= 0x20;
#endif
        }
    }

    //
    // Take care of case like GET to '/' which would result in another
    // notification for the default document
    //
    if ( fVerbIsGET && fileExtension == NULL )
    {
        pfc->pFilterContext = NULL;
        goto exit_part;
    }

    if ( DoStaticCompression && fVerbIsGET && fileExtension != NULL )
    {
        //
        // Try static compression
        //

        schemeIndex = FindMatchingScheme(0,
                                         clientCompressionArray,
                                         dwClientCompressionCount,
                                         fileExtension,
                                         DO_STATIC_COMPRESSION);

        if ( schemeIndex == 0xFFFFFFFF ) 
        {
            // no matching static compression schemes, try dynamic compression
            goto dynamic_compression;
        }

        //
        // Determine whether the original file is sufficiently large to
        // warrant even attempting to look for a compressed version of the
        // file.  Very small files compress poorly, so it doesn't make sense
        // to attempt to compress them.  Also, it makes no sense to attempt
        // to compress zero-length files, so bail immediately on those.
        //


        pofiOriginalFile = TsCreateFile(
                               tsvcGarbage,
                               phfumData->pszPhysicalPath,
                               INVALID_HANDLE_VALUE,
                               TS_CACHING_DESIRED | TS_NO_ACCESS_CHECK);

        if ( pofiOriginalFile != NULL)
        {
            success = pofiOriginalFile->QuerySize (originalFileSize);
        }
        if ( pofiOriginalFile == NULL || !success ||
             originalFileSize.QuadPart < MinFileSizeForCompression)
        {
            DisableNotifications (pfc, ALL_NOTIFICATIONS, 
                                  COMPFILT_NO_COMPRESSION);
            goto exit_part;
        }

        //
        // now we already know that at least one scheme matches the
        // extension of this file, so just find such a scheme which
        // already has the file compressed in compression caching directory
        //

        for ( schemeIndex = 0;
              schemeIndex != 0xFFFFFFFF;
              schemeIndex++ ) {

            schemeIndex = FindMatchingScheme(
                              schemeIndex,
                              clientCompressionArray,
                              dwClientCompressionCount,
                              fileExtension,
                              DO_STATIC_COMPRESSION
                              );

            //
            // If we didn't find a matching scheme, bail.
            //

            if ( schemeIndex == 0xFFFFFFFF ) 
            {
                // means there are no more matching schemes in array
                break;
            }

            scheme = SupportedCompressionSchemes[schemeIndex];

            //
            // Now that we have found a matching compression scheme, see if
            // there exists a version of the requested file that has been
            // compressed with that scheme.  First, calculate the name the
            // file would have.  The compressed file will live in the
            // special compression directory with a special converted name.
            // The file name starts with the compression scheme used, then
            // the fully qualified file name where slashes and underscores
            // have been converted to underscores.  For example, the gzip
            // version of "c:\inetpub\wwwroot\file.htm" would be
            // "c:\compdir\gzip_c_inetpub_wwwroot_file.htm".
            //
            // First, copy in the name of the directory where compressed
            // files of this scheme are stored, including the trailing
            // file name.
            //

            ConvertPhysicalPathToCompressedPath(
                scheme,
                phfumData->pszPhysicalPath,
                compressedFileName,
                &compressedFileNameLength
                );

            //
            // If the compressed name is longer than the server can accept,
            // then don't even bother attempting to do anything with this file,
            // since we cannot write it back to the server.
            //

            if ( compressedFileNameLength > phfumData->cbPathBuff ) {
                continue;
            }


            success = CheckForExistenceOfCompressedFile(compressedFileName,
                                                        pofiOriginalFile);

            if ( success ) {

                Write(( DEST,
                        "Found matching scheme \"%s\" for file %s, converting to %s\n",
                        scheme->pszCompressionSchemeName,
                        phfumData->pszPhysicalPath,
                        compressedFileName ));

                //
                // Bingo--we have a compressed version of the file in a
                // format that the client understands.  Add the appropriate
                // Content-Encoding header so that the client knows it is
                // getting compressed data and change the server's mapping
                // to the compressed version of the file.
                //
                // Note that pszResponseHeaders will likely contain several
                // CRLF-separated headers.  The other headers will prevent
                // HTTP 1.0 proxies from caching a compressed response so
                // that old clients don't get compressed data.
                //

                success = pfc->AddResponseHeaders(
                                   pfc,
                                   scheme->pszResponseHeaders,
                                   0
                                   );
                if ( !success ) 
                {
                    DisableNotifications (pfc,ALL_NOTIFICATIONS,NULL);
                    retValue = SF_STATUS_REQ_ERROR;
                    goto exit_part;
                }

                //
                // Remember that we successfully did a static compression on
                // this file.  We'll use this info in the
                // SF_NOTIFY_SEND_RESPONSE notification to determine whether
                // we should add other compression headers to the response.
                //

                SET_SUCCESSFUL_STATIC( pfc );

                //
                // Change the server to point to the new file.
                //

                strcpy( phfumData->pszPhysicalPath, compressedFileName );
                phfumData->cbPathBuff = compressedFileNameLength;


                //
                // completed handling static file case

                DisableNotifications(pfc, RAW_DATA_AND_END_OF_REQ,
                                     COMPFILT_SUCCESSFUL_STATIC);
                goto exit_part;
            }

            //
            // We found a scheme, but we don't have a matching file for it.
            // Remember whether this was the first matching scheme that
            // supports on-demand compression.  In the event that we do not
            // find any acceptable files, we'll attempt to do an on-demand
            // compression for this file so that future requests get a
            // compressed version.
            //

            if ( firstOnDemandScheme == NULL && scheme->DoOnDemandCompression )
            {
                firstOnDemandScheme = scheme;
            }

            //
            // Loop to see if there is another scheme that is supported
            // by both client and server.
            //
        }

        //
        // if we are here means scheme was found but no compressed 
        // file matching any scheme. so schedule file to compress
        //

        //
        // We were not able to find a precompressed version of this file.
        // If we have any matching compression schemes that are configured
        // for on-demand compression, queue off a request to compress it so
        // that the next time someone needs this file, it will exist.  This
        // particular connection is going to have to live with the
        // uncompressed version of the file.
        //

        if ( DoOnDemandCompression && firstOnDemandScheme != NULL ) {

            if ( pofiOriginalFile->QueryLastWriteTime (&originalFileTime) )
                QueueCompressFile( firstOnDemandScheme,
                                   phfumData->pszPhysicalPath,
                                   &originalFileTime);

        }

        // completed handling static file case

        DisableNotifications(pfc, ALL_NOTIFICATIONS, COMPFILT_NO_COMPRESSION);
        goto exit_part;
    }

 dynamic_compression:
    //
    // case of dynamic compression after matching file extension
    //

    if ( DoDynamicCompression ) {

        schemeIndex = FindMatchingScheme(
                          0,
                          clientCompressionArray,
                          dwClientCompressionCount,
                          fileExtension,
                          DO_DYNAMIC_COMPRESSION
                          );
        if ( schemeIndex == 0xFFFFFFFF )
        {
            DisableNotifications(pfc, ALL_NOTIFICATIONS,
                                 COMPFILT_NO_COMPRESSION);
            goto exit_part;
        }

        pfc->pFilterContext = pfc->AllocMem(
                                       pfc,
                                       sizeof(COMPFILT_FILTER_CONTEXT),
                                       0
                                       );
        if ( pfc->pFilterContext == NULL ) {
            goto exit_part;
        }

        //
        // Initialize the context structure.
        //

        filterContext = (PCOMPFILT_FILTER_CONTEXT)pfc->pFilterContext;
        filterContext->RequestHandled = FALSE;
        filterContext->HeaderPassed = FALSE;
        filterContext->InEndOfRequest = FALSE;
        filterContext->OnSendResponseCalled = FALSE;
        filterContext->DynamicRequest = TRUE;
        filterContext->CompressionContext = NULL;
        filterContext->TransferChunkEncoded = FALSE;
        filterContext->ChunkedBytesRemaining = 0;
        filterContext->pcsState = CHUNK_DATA_DONE;
        filterContext->Scheme = SupportedCompressionSchemes[schemeIndex];
        filterContext->HeadersNewLineStatus = 0;

        goto exit_part;

    }

    DisableNotifications(pfc,ALL_NOTIFICATIONS,COMPFILT_NO_COMPRESSION);
exit_part:
    
    if (pofiOriginalFile != NULL )
    {
        TsCloseHandle( tsvcGarbage, pofiOriginalFile);
        pofiOriginalFile = NULL;
    }

    return retValue;
} // OnUrlMap


DWORD
FindMatchingScheme (
    IN DWORD dwSchemeIndex,
    IN LPSTR ClientCompressionArray[],
    IN DWORD dwClientCompressionCount,
    IN LPSTR FileExtension,
    IN COMPRESSION_TO_PERFORM performCompr
    )

/*++

Routine Description:

    Attempts to find a compression scheme that is supported by both client
    and server.

Arguments:

    SchemeIndex - an index into the SupportedCompressionSchemes array
        that indicates the compression schemes supported by the server.
        The array is sorted in order of server preference.

    ClientCompressionArray - the compression schemes that the client passed
        in the Accept-Encoding HTTP header.

    dwClientCompressionCount - the number of entries in
        ClientCompressionArray.

    FileExtension - the file extension for which we're looking for a
        compressed version. If NULL, then we do no comparison on the
        file extension, and we assume that all extensions are supported.

    performCompr - DO_STATIC_COMPRESSION if we need to find a scheme that
        supports static compression.  DO_DYNAMIC_COMPRESSION if we need to
        find a scheme that supports dynamic compression.

Return Value:

    A index to a compression scheme supported by both client and server,
    or 0xFFFFFFFF if none was found.

--*/

{
    DWORD j, k;
    PSUPPORTED_COMPRESSION_SCHEME scheme;


    //
    // Walk the list of schemes supproted by the server.
    //

    for ( scheme = SupportedCompressionSchemes[dwSchemeIndex];
          scheme != NULL;
          dwSchemeIndex++,
              scheme = SupportedCompressionSchemes[dwSchemeIndex] ) {

        //
        // Check whether the client lists support for this specific scheme.
        //

        for ( j = 0; j < dwClientCompressionCount; j++ ) {

            //
            // This is required to be a case-insensitive compare
            // according to the HTTP 1.1 protocol.  stricmp is a very
            // expensive routine because it does NLS handling which is
            // not relevent here.  Thus, we use the strcmp() intrinsic
            // here and assume that all the strings have already been
            // lowercased.
            //

            if ( strcmp(
                     scheme->pszCompressionSchemeName,
                     ClientCompressionArray[j] ) == 0 ) {

                //
                // Both client and server support this compression scheme.
                // Make sure that the scheme supports static or dynamic
                // compression, as appropriate.
                //


                //
                // Test to see if the file is of a relevent type for this
                // scheme.  A NULL in the file extension field indicates
                // that this compression scheme supports any file type.
                //


                // first check for static compreesion schemes

                if (performCompr == DO_STATIC_COMPRESSION &&
                    scheme->DoStaticCompression &&
                    scheme->ppszFileExtensions != NULL)
                {
                    for ( k = 0; scheme->ppszFileExtensions[k] != NULL; k++ ) 
                    {

                        if ( strcmp( scheme->ppszFileExtensions[k],
                                     FileExtension ) == 0 ) {
                            return dwSchemeIndex;
                        }
                    }
                }

                // second check for dynamic compression schemes

                if (performCompr == DO_DYNAMIC_COMPRESSION &&
                    scheme->DoDynamicCompression)
                {
                    if (scheme->ppszScriptFileExtensions == NULL ||
                        scheme->ppszScriptFileExtensions[0] == NULL)
                    {
                        return dwSchemeIndex;
                    }
                    if (FileExtension == NULL)
                    {
                        break;
                    }
                    for ( k = 0; scheme->ppszScriptFileExtensions[k] != NULL; k++ ) 
                    {

                        if ( strcmp( scheme->ppszScriptFileExtensions[k],
                                     FileExtension ) == 0 ) {
                            return dwSchemeIndex;
                        }
                    }
                }

            }
        }
    }

    //
    // Didn't find a match.
    //

    return 0xFFFFFFFF;

} // FindMatchingScheme



BOOL
CheckForExistenceOfCompressedFile (
    IN  LPSTR fileName,
    IN  LPTS_OPEN_FILE_INFO pofiOriginalFile,
    IN  BOOL  dDeleteAllowed
    )
{
    BOOL success = FALSE;
    LONG timeResult;
    PLARGE_INTEGER pli;
    TSVC_CACHE              tsvcGarbage;
    LPTS_OPEN_FILE_INFO     pofiCompressedFile = NULL;
    FILETIME                compressedFileTime, originalFileTime;
    PSECURITY_DESCRIPTOR    compressedFileAcls = NULL, originalFileAcls = NULL;
    DWORD                   compressedFileAclsLen, originalFileAclsLen ;
    SECURITY_DESCRIPTOR_CONTROL  compressedFileCtl,originalFileCtl;
    LARGE_INTEGER           compressedFileSize;
 

    pofiCompressedFile = TsCreateFile( tsvcGarbage, fileName, INVALID_HANDLE_VALUE,
                                        TS_CACHING_DESIRED | TS_NO_ACCESS_CHECK);


    if ( pofiCompressedFile ) 
    {

        //
        // So far so good.  Determine whether the compressed version
        // of the file is out of date.  If the compressed file is
        // out of date, delete it and remember that we did not get a
        // good match.  Note that there's really nothing we can do
        // if the delete fails, so ignore any failures from it.
        //
        // The last write times must differ by exactly two seconds
        // to constitute a match.  The two-second difference results
        // from the fact that we set the time on the compressed file
        // to be two seconds behind the uncompressed version in
        // order to ensure unique Etag: header values.
        //


        if ( pofiCompressedFile->QuerySize (compressedFileSize) &&
             pofiCompressedFile->QueryLastWriteTime (&compressedFileTime) && 
             pofiOriginalFile->QueryLastWriteTime (&originalFileTime) )
        {

            pli = (PLARGE_INTEGER)(&compressedFileTime);
            pli->QuadPart += 2*10*1000*1000;

            timeResult = CompareFileTime(&compressedFileTime, &originalFileTime);

            if ( timeResult != 0 ) 
            {

            //
            // That check failed.  If the compression directory is
            // on a FAT volume, then see if they are within two
            // seconds of one another.  If they are, then consider
            // things valid.  We have to do this because FAT file
            // times get truncated in weird ways sometimes: despite
            // the fact that we request setting the file time
            // different by an exact amount, it gets rounded
            // sometimes.
            //

                if ( CompressionVolumeIsFat ) 
                {
                    pli->QuadPart -= 2*10*1000*1000 + 1;
                    timeResult += CompareFileTime( &compressedFileTime, &originalFileTime);
                }
            }

            if (timeResult == 0) 
            {
                compressedFileAcls = pofiCompressedFile->QuerySecDesc ();
                originalFileAcls = pofiOriginalFile->QuerySecDesc ();

                if (compressedFileAcls != NULL && originalFileAcls != NULL )
                {
                    compressedFileAclsLen = GetSecurityDescriptorLength(compressedFileAcls);
                    originalFileAclsLen = GetSecurityDescriptorLength(originalFileAcls);

                    if ( originalFileAclsLen == compressedFileAclsLen )
                    {
                        compressedFileCtl = ((PISECURITY_DESCRIPTOR)compressedFileAcls)->Control;
                        originalFileCtl = ((PISECURITY_DESCRIPTOR)originalFileAcls)->Control;

                        ((PISECURITY_DESCRIPTOR)compressedFileAcls)->Control &= ACL_CLEAR_BIT_MASK;
                        ((PISECURITY_DESCRIPTOR)originalFileAcls)->Control &= ACL_CLEAR_BIT_MASK;

                        success = (memcmp((PVOID)originalFileAcls,(PVOID)compressedFileAcls,originalFileAclsLen) == 0);

                        ((PISECURITY_DESCRIPTOR)compressedFileAcls)->Control = compressedFileCtl;
                        ((PISECURITY_DESCRIPTOR)originalFileAcls)->Control = originalFileCtl;
                    }
                }
            }
        }
    }


    if ( pofiCompressedFile != NULL) 
    {
        TsCloseHandle( tsvcGarbage, pofiCompressedFile);
    }

    
    if ( pofiCompressedFile!=NULL &&  !success ) 
    {
        
        //DeleteFile( fileName );
        
        // don't delte if call came from compression thread because then
        // delete request will be in a queue after compression request and will 
        // delete a file which was just moment ago compressed

        if (dDeleteAllowed)
        {

        QueueCompressFile(  ID_FOR_FILE_DELETION_ROUTINE,
                            fileName,
                            &compressedFileTime );



        //
        // If we are configured to limit the amount of disk
        // space we use for compressed files, then, in a
        // thread-safe manner, update the tally of disk
        // space used by compression.
        //

        if ( DoDiskSpaceLimiting ) 
        {
            InterlockedExchangeAdd((PLONG)&CurrentDiskSpaceUsage,
                        -1 * compressedFileSize.LowPart
                        );
        }
        }
    }



    return success;
}


void DisableNotifications (
    PHTTP_FILTER_CONTEXT pfc,
    DWORD   flags,
    PVOID   pfcStatus
    )
{
    BOOL success;

        if (flags != NULL)
        {
        success = pfc->ServerSupportFunction(
                      pfc,
                      SF_REQ_DISABLE_NOTIFICATIONS,
                      NULL,
                      flags,
                      0
                      );
        DBG_ASSERT( success );
        }

        if (NULL != pfcStatus )
        {
            (pfc)->pFilterContext = pfcStatus;
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defmisc.c ===
//
// defmisc.c
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// Fix the frequency data of the provided literal and distance trees such that no
// element has a zero frequency.  We must never allow the cumulative frequency of
// either tree to be >= 65536, so we divide all of the frequencies by two to make
// sure.
//
void NormaliseFrequencies(USHORT *literal_tree_freq, USHORT *dist_tree_freq)
{
	int i;

	// don't allow any zero frequency items to exist
	// also make sure we don't overflow 65535 cumulative frequency
	for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
	{
		// avoid overflow
		dist_tree_freq[i] >>= 1;

		if (dist_tree_freq[i] == 0)
			dist_tree_freq[i] = 1;
	}

	for (i = 0; i < MAX_LITERAL_TREE_ELEMENTS; i++)
	{
		// avoid overflow
		literal_tree_freq[i] >>= 1;

		if (literal_tree_freq[i] == 0)
			literal_tree_freq[i] = 1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defproto.h ===
//
// defproto.h
//
// Function prototypes

// comninit.c
void InitStaticBlock(void);

// definit.c
VOID deflateInit(VOID);

VOID DeflateInitRecordingTables(
    BYTE *  recording_literal_len,
    USHORT *recording_literal_code,
    BYTE *  recording_dist_len,
    USHORT *recording_dist_code
);

// output.c
void outputBits(t_encoder_context *context, int n, int x);
void flushOutputBitBuffer(t_encoder_context *context);
void InitBitBuffer(t_encoder_context *context);
void FlushRecordingBuffer(t_encoder_context *context);
void outputTreeStructure(t_encoder_context *context, const BYTE *literal_tree_len, const BYTE *dist_tree_len);
void OutputBlock(t_encoder_context *context);

// deftree.c
void makeTree(
	int					num_elements,
	int					max_code_length,
	unsigned short *	freq,
	unsigned short *	code,
	byte *				len
);

void makeCode(int num_elements, const int *len_cnt, const BYTE *len, USHORT *code);

// optfmtch.c
int optimal_find_match(t_encoder_context *context, long BufPos);
void optimal_insert(t_encoder_context *context, long BufPos, long end_pos);
void optimal_remove_node(t_encoder_context *context, long BufPos, ULONG end_pos);
void removeNodes(t_encoder_context *context);
void reinsertRemovedNodes(t_encoder_context *context);

// optenc.c
void OptimalEncoderDeflate(t_encoder_context *context);
void OptimalEncoderReset(t_encoder_context *context);
BOOL OptimalEncoderInit(t_encoder_context *context);
void OptimalEncoderZeroFrequencyCounts(t_optimal_encoder *encoder);

// stdenc.c
void StdEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
);

void StdEncoderReset(t_encoder_context *context);
BOOL StdEncoderInit(t_encoder_context *context);
void StdEncoderZeroFrequencyCounts(t_std_encoder *encoder);

// stdblock.c
BOOL StdEncoderOutputBlock(t_encoder_context *context);

// fastenc.c
BOOL FastEncoderInit(t_encoder_context *context);

void FastEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
);

VOID FastEncoderCreateStaticTrees(VOID);
void FastEncoderGenerateDynamicTreeEncoding(void);
void FastEncoderOutputPreamble(t_encoder_context *context);

// deflate.c
VOID DestroyIndividualCompressors(PVOID void_context);
void InternalResetCompression(t_encoder_context *context);

HRESULT WINAPI Compress(
	PVOID				void_context,
	CONST BYTE *		input_buffer,
	LONG				input_buffer_size,
	PBYTE				output_buffer,
	LONG				output_buffer_size,
	PLONG				input_used,
	PLONG				output_used,
	INT					compression_level
);

// defmisc.c
void NormaliseFrequencies(USHORT *literal_tree_freq, USHORT *dist_tree_freq);

// optblock.c
BOOL OptimalEncoderOutputBlock(t_encoder_context *context);

// stddebug.c
#ifdef _DEBUG
void StdEncoderVerifyHashes(t_encoder_context *context, long bufpos);
void StdEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number);
#endif

// optdebug.c
#ifdef _DEBUG
void OptimalEncoderVerifyHashes(t_encoder_context *context, long bufpos);
#endif

// fstdebug.c
#ifdef _DEBUG
void FastEncoderVerifyHashes(t_encoder_context *context, long bufpos);
void FastEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defctxt.h ===
/*
 * defctxt.h
 *
 * Deflate context
 */
typedef unsigned short	t_search_node;
typedef unsigned int	t_match_pos;


typedef enum
{
	STATE_NORMAL,
	STATE_OUTPUTTING_TREE_STRUCTURE,
	STATE_OUTPUTTING_BLOCK
} t_encoder_state;



struct fast_encoder;
struct optimal_encoder;
struct std_encoder;


//
// Context info common to all encoders
//
typedef struct
{
	t_encoder_state			state;

	unsigned long			outputting_block_bitbuf;
	int						outputting_block_bitcount;
	byte *					outputting_block_bufptr;
	unsigned int			outputting_block_current_literal;
	unsigned int			outputting_block_num_literals;

	long					bufpos;
	long					bufpos_end;

    // output buffer
	BYTE *					output_curpos;
	BYTE *					output_endpos;
	BYTE *					output_near_end_threshold;

	// bit buffer variables for outputting data
	unsigned long			bitbuf;
	int						bitcount;

    // varies; std/optimal encoders use the normal 32K window, while the fast
    // encoder uses a smaller window
    long                    window_size;

	struct std_encoder *	std_encoder;
	struct optimal_encoder *optimal_encoder;
    struct fast_encoder *   fast_encoder;

	BOOL					no_more_input;
	
	// have we output "bfinal=1"?
	BOOL					marked_final_block;

    // do we need to call ResetCompression() before we start compressing?
    BOOL                    fNeedToResetCompression;

    // if GZIP, have we output the GZIP header?
    BOOL                    using_gzip;
    BOOL                    gzip_fOutputGzipHeader;
    ULONG                   gzip_crc32;
    ULONG                   gzip_input_stream_size;
} t_encoder_context;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defdata.h ===
//
// defdata.h
//
// Data specific to deflate
//
// NOTE   Some of these USHORTs could be made into ULONGs for speed-of-access.  The disadvantage would
//        be greater memory/cache usage.  g_StaticDistanceTreeCode[] could be made into a BYTE array,
//        since the codes are 5 bits.  Changes of this nature will require various code changes elsewhere.
//
#ifdef DECLARE_DATA

// lookup tables for finding the slot number of a match length or distance
BYTE    g_LengthLookup[256];
BYTE    g_DistLookup[512];

// literal codes for static blocks
BYTE    g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
USHORT  g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];

// distance codes for static blocks
// note: g_StaticDistanceTreeLength == 5 for all distances, which is why we don't have a table for that
USHORT  g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

// cached tree structure output for fast encoder
BYTE    g_FastEncoderTreeStructureData[MAX_TREE_DATA_SIZE];
int     g_FastEncoderTreeLength; // # bytes in g_FastEncoderTreeStructureData
ULONG   g_FastEncoderPostTreeBitbuf; // final value of bitbuf
int     g_FastEncoderPostTreeBitcount; // final value of bitcount

#else /* !DECLARE_DATA */

extern BYTE     g_LengthLookup[256];
extern BYTE     g_DistLookup[512];

extern BYTE     g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

extern BYTE     g_FastEncoderTreeStructureData[MAX_TREE_DATA_SIZE];
extern int      g_FastEncoderTreeLength;
extern ULONG    g_FastEncoderPostTreeBitbuf;
extern int      g_FastEncoderPostTreeBitcount;

#endif /* !DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\defgzip.h ===
//
// defgzip.h
//
// Gzip additions to deflate
//

// compressing
void WriteGzipHeader(t_encoder_context *context, int compression_level);
void WriteGzipFooter(t_encoder_context *context);
void GzipCRCmemcpy(t_encoder_context *context, BYTE *dest, const BYTE *src, ULONG count);
void EncoderInitGzipVariables(t_encoder_context *context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\deflate.c ===
/*
 * deflate.c
 *
 * Main compression entrypoint for all three encoders
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "fasttbl.h"
#include "defgzip.h"


typedef struct config_s
{
   int good_length; /* reduce lazy search above this match length */
   int max_lazy;    /* do not perform lazy search above this match length */
   int nice_length; /* quit search above this match length */
   int max_chain;
} compression_config;


static const compression_config configuration_table[11] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0 },  /* store only */
/* 1 */ {4,    4,  8,    4 }, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8 },
/* 3 */ {4,    6, 32,   32 },

/* 4 */ {4,    4, 16,   16 },  /* lazy matches */
/* 5 */ {8,   16, 32,   32 },
/* 6 */ {8,   16, 128, 128 },
/* 7 */ {8,   32, 128, 256 },
/* 8 */ {32, 128, 258, 1024 },
/* 9 */ {32, 258, 258, 4096 },
/* 10 */ {32, 258, 258, 4096 } /* maximum compression */
};


//
// Destroy the std encoder, optimal encoder, and fast encoder, but leave the
// compressor context around
//
VOID DestroyIndividualCompressors(PVOID void_context)
{
    t_encoder_context *context = (t_encoder_context *) void_context;

    if (context->std_encoder != NULL)
    {
        LocalFree((PVOID) context->std_encoder);
        context->std_encoder = NULL;
    }

    if (context->optimal_encoder != NULL)
    {
        LocalFree((PVOID) context->optimal_encoder);
        context->optimal_encoder = NULL;
    }

    if (context->fast_encoder != NULL)
    {
        LocalFree((PVOID) context->fast_encoder);
        context->fast_encoder = NULL;
    }
}


//
// Mark the final block in the compressed data
//
// There must be one final block with bfinal=1 indicating that it is the last one.  In the case of
// the fast encoder we just need to output the end of block code, since the fast encoder just outputs
// one very long block.
//
// In the case of the standard and optimal encoders we have already finished outputting blocks,
// so we output a new block (a static/fixed block) with bfinal=1, consisting merely of the
// end of block code.
//
static void markFinalBlock(t_encoder_context *context)
{
    if (context->fast_encoder != NULL)
    {
        // The fast encoder outputs one long block, so it just needs to terminate this block
        outputBits(
            context,
            g_FastEncoderLiteralTreeLength[END_OF_BLOCK_CODE],
            g_FastEncoderLiteralTreeCode[END_OF_BLOCK_CODE]
        );
    }
    else
    {
        // To finish, output a static block consisting of a single end of block code

        // Combined these three outputBits() calls (commented out) into one call
        // The total number of bits output in one shot must be <= 16, but we're ok
        // since the the length of END_OF_BLOCK_CODE is 7 for a static (fixed) block
#if 0
    	outputBits(context, 1, 1); // bfinal = 1
        outputBits(context, 2, BLOCKTYPE_FIXED);
        outputBits(context, g_StaticLiteralTreeLength[END_OF_BLOCK_CODE], g_StaticLiteralTreeCode[END_OF_BLOCK_CODE]);
#endif

        // note: g_StaticLiteralTreeCode[END_OF_BLOCK_CODE] == 0x0000
        outputBits(
            context,
            (7 + 3), // StaticLiteralTreeLength[END_OF_BLOCK_CODE]=7, + 1 bfinal bit + 2 blocktype bits
            ((0x0000) << 3) | (BLOCKTYPE_FIXED << 1) | 1
        );
    }

    // flush bits from bit buffer to output buffer
    flushOutputBitBuffer(context);

    if (context->using_gzip)
        WriteGzipFooter(context);
}


//
// Returns a pointer to the start of the window of the currently active compressor
//
// Used for memcpy'ing window data when we reach the end of the window
//
static BYTE *GetEncoderWindow(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL || context->fast_encoder != NULL);

    if (context->std_encoder != NULL)
        return context->std_encoder->window;
    else if (context->optimal_encoder != NULL)
        return context->optimal_encoder->window;
    else
        return context->fast_encoder->window;
}


//
// This function does the actual work of resetting the compression state.
// However, it does not free the std/fast/optimal encoder memory (something
// that the external ResetCompression() API currently does).
//
void InternalResetCompression(t_encoder_context *context)
{
	context->no_more_input      = FALSE;
	context->marked_final_block = FALSE;
	context->state              = STATE_NORMAL;
	context->outputting_block_num_literals = 0;

    if (context->using_gzip)
        EncoderInitGzipVariables(context);

	InitBitBuffer(context);
}


//
// The compress API
//
HRESULT WINAPI Compress(
	PVOID				void_context,
	CONST BYTE *		input_buffer,
	LONG				input_buffer_size,
	PBYTE				output_buffer,
	LONG				output_buffer_size,
	PLONG				input_used,
	PLONG				output_used,
	INT					compression_level
)
{
	int				    lazy_match_threshold;
    int                 search_depth;
    int                 good_length;
    int                 nice_length;
	t_encoder_context * context = (t_encoder_context *) void_context;
    t_std_encoder *     std_encoder;
    t_optimal_encoder * optimal_encoder;
    t_fast_encoder *    fast_encoder;
    HRESULT             result = S_OK; // default to success

    *input_used = 0;
    *output_used = 0;

    // validate compression level
	if (compression_level < 0 || compression_level > 10)
    {
        result = E_INVALIDARG;
        goto exit;
    }

	context->output_curpos				= output_buffer;
	context->output_endpos				= output_buffer + output_buffer_size;
	context->output_near_end_threshold	= output_buffer + output_buffer_size - 16;

    //
    // Have we allocated the particular compressor we want yet?
    //
    if (context->std_encoder == NULL && context->optimal_encoder == NULL && context->fast_encoder == NULL)
    {
        // No
        if (compression_level <= 3) // fast encoder
        {
    		if (FastEncoderInit(context) == FALSE)
            {
	    		result = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else if (compression_level == 10) // optimal encoder
        {
    		if (OptimalEncoderInit(context) == FALSE)
            {
	    		result = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else
        {
	    	if (StdEncoderInit(context) == FALSE)
            {
	    		result = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

    std_encoder     = context->std_encoder;
    optimal_encoder = context->optimal_encoder;
    fast_encoder    = context->fast_encoder;

	_ASSERT(std_encoder != NULL || optimal_encoder != NULL || fast_encoder != NULL);

	// set search depth
    if (fast_encoder != NULL)
    {
    	search_depth = configuration_table[compression_level].max_chain;
    	good_length = configuration_table[compression_level].good_length;
    	nice_length = configuration_table[compression_level].nice_length;
    	lazy_match_threshold = configuration_table[compression_level].max_lazy;
    }
    else if (std_encoder != NULL)
    {
    	search_depth = configuration_table[compression_level].max_chain;
    	good_length = configuration_table[compression_level].good_length;
    	nice_length = configuration_table[compression_level].nice_length;
    	lazy_match_threshold = configuration_table[compression_level].max_lazy;
    }

	// the output buffer must be large enough to contain an entire tree
	if (output_buffer_size < MAX_TREE_DATA_SIZE)
	{
        result = E_INVALIDARG;
        goto exit;
	}

    if (context->using_gzip && context->gzip_fOutputGzipHeader == FALSE)
    {
        // Write the GZIP header
        WriteGzipHeader(context, compression_level);
        context->gzip_fOutputGzipHeader = TRUE;
    }

	//
	// Check if previously we were in the middle of outputting a block
	//
	if (context->state != STATE_NORMAL)
	{
        // The fast encoder is a special case; it doesn't use OutputBlock()
        if (fast_encoder != NULL)
            goto start_encoding;

        // yes we were, so continue outputting it
        OutputBlock(context);

		//
		// Check if we're still outputting a block (it may be a long block that
		// has filled up the output buffer again)
		//
        // If we're coming close to the end of the buffer, and may not have enough space to
        // output a full tree structure, stop now.
        //
		if (context->state != STATE_NORMAL ||
            context->output_endpos - context->output_curpos < MAX_TREE_DATA_SIZE)
		{
			*output_used = (LONG)(context->output_curpos - output_buffer);
            goto set_output_used_then_exit; // success
		}

		//
		// We finished outputting the previous block, so time to compress some more input
		//
	}

#ifdef _DEBUG
    // Fast encoder doesn't use outputBlock, so it doesn't have the tree limitation
    if (fast_encoder == NULL)
        _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);
#endif

	//
	// input_buffer_size == 0 means "this is the final block"
	//
	// Of course, the client may still need to call Compress() many more times if the output
	// buffer is small and there is a big block waiting to be sent.
	//
	// We may even have some pending input data in our buffer waiting to be compressed.
	//
	if ((input_buffer_size == 0 || context->no_more_input) && context->bufpos >= context->bufpos_end)
	{
		// if we're ever passed zero bytes of input, it means that there will never be any
		// more input
		context->no_more_input = TRUE;

		// output existing block
        // this never happens for the fast encoder, since we don't record blocks
   		if (context->outputting_block_num_literals != 0)
        {
            FlushRecordingBuffer(context);
            OutputBlock(context);

	    	//
    		// Still outputting a block?
   			//
	    	if (context->state != STATE_NORMAL)
                goto set_output_used_then_exit; // success
        }

        // for the fast encoder only, we won't have output our fast encoder preamble if the
        // file size == 0, so output it now if we haven't already.
        if (fast_encoder != NULL)
        {
            if (fast_encoder->fOutputBlockHeader == FALSE)
            {
                fast_encoder->fOutputBlockHeader = TRUE;
                FastEncoderOutputPreamble(context);
            }
        }

		// if we've already marked the final block, don't do it again
		if (context->marked_final_block)
		{
            result = S_FALSE;
            goto set_output_used_then_exit; // should be zero output used
		}

		// ensure there is enough space to output the final block (max 8 bytes)
		if (context->output_curpos + 8 >= context->output_endpos)
            goto set_output_used_then_exit; // not enough space - do it next time

		// output the final block (of length zero - we just want the bfinal=1 marker)
		markFinalBlock(context);
		context->marked_final_block = TRUE;

        result = S_FALSE;
        goto set_output_used_then_exit;
	}

	// while there is more input data (passed in as parameters) or existing data in
	// the window to compress
start_encoding:
	while ((input_buffer_size > 0) || (context->bufpos < context->bufpos_end))
	{
		long amount_to_compress;
		long window_space_available;

		_ASSERT(context->bufpos >= context->window_size && context->bufpos < (2*context->window_size));

#ifdef _DEBUG
        // Fast encoder doesn't use outputBlock, so it doesn't have the tree limitation
        if (fast_encoder == NULL)
            _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);
#endif

		// read more input data into the window if there is space available
		window_space_available = (2*context->window_size) - context->bufpos_end;

		amount_to_compress = (input_buffer_size < window_space_available) ? input_buffer_size : window_space_available;

		if (amount_to_compress > 0)
		{
			*input_used += amount_to_compress;

			// copy data into history window
            if (context->using_gzip)
            {
                // In addition to copying data into the history window, GZIP wants a crc32 of the input data.
                // We will do both of these things at the same time for the purposes of data locality,
                // performance etc.
                GzipCRCmemcpy(context, GetEncoderWindow(context) + context->bufpos_end, input_buffer, amount_to_compress);
            }
            else
            {
                // Copy data into history window
    		    memcpy(GetEncoderWindow(context) + context->bufpos_end, input_buffer, amount_to_compress);
            }

			input_buffer		+= amount_to_compress;
			input_buffer_size	-= amount_to_compress;

			// last input location
			context->bufpos_end += amount_to_compress;
		}

		if (optimal_encoder != NULL)
			OptimalEncoderDeflate(context);
		else if (std_encoder != NULL)
			StdEncoderDeflate(context, search_depth, lazy_match_threshold, good_length, nice_length);
        else if (fast_encoder != NULL)
			FastEncoderDeflate(context, search_depth, lazy_match_threshold, good_length, nice_length);

		// either we reached the end of the buffer, or we had to output a block and ran out
		// of output space midway
		_ASSERT(context->bufpos == context->bufpos_end || context->state != STATE_NORMAL);

		// if we ran out of output space, break now
		if (context->state != STATE_NORMAL)
			break;

        // another check for running out of output space
        if (fast_encoder == NULL && context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE)
            break;

	} /* end ... while (input_buffer_size > 0) */

set_output_used_then_exit:
	*output_used = (LONG)(context->output_curpos - output_buffer);

exit:
    _ASSERT(*output_used < output_buffer_size); // make sure we didn't overflow the output buffer
	_ASSERT(context->bufpos >= context->window_size && context->bufpos <= 2*context->window_size); // make sure bufpos is sane

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\definit.c ===
//
// definit.c
//
// Initialisation code for deflate (compression stage)
//
// Includes both some one-time init routines, as well as a per context/reset init routine
//
#include "types.h"
#include "deflate.h"
#include "inflate.h"
#include "defproto.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// This function is called by the standard and optimal encoders, and creates the initial tree
// used to record literals for the first block.  After the first block we use the last block's
// trees to record data.
//
// This function does not change global data, and is called one a per context creation/reset.
//
VOID DeflateInitRecordingTables(
    BYTE *  recording_literal_len,
    USHORT *recording_literal_code,
    BYTE *  recording_dist_len,
    USHORT *recording_dist_code
)
{
    // These frequencies were taken from running on some text file, better stats could
    // be obtained from using an html page.  This barely affects compression though; bad estimates
    // will just make the recording buffer fill up a little bit sooner, making us output a block
    // a little sooner, which isn't always a bad thing anyway.
	USHORT	recording_dist_tree_freq[MAX_DIST_TREE_ELEMENTS*2] = 
	{
		2,2,3,4,3,7,16,22,42,60,100,80,149,158,223,200,380,324,537,
		477,831,752,1231,999,1369,1100,2034,1667,2599,2216,0,0
	};

	USHORT	recording_literal_tree_freq[MAX_LITERAL_TREE_ELEMENTS*2];

    int i;

	makeTree(
		MAX_DIST_TREE_ELEMENTS, 
		RECORDING_DIST_MAX_CODE_LEN, 
		recording_dist_tree_freq, 
		recording_dist_code, 
		recording_dist_len
	);

    // NOTE - Put a better estimation in here!  This assumes all literals (chars and matches)
    // are equally likely, which they aren't (although all chars might be fairly equal for a
    // binary file).
	for (i = 0; i < MAX_LITERAL_TREE_ELEMENTS; i++)
		recording_literal_tree_freq[i] = 1;

	makeTree(
		MAX_LITERAL_TREE_ELEMENTS, 
		RECORDING_LIT_MAX_CODE_LEN, 
		recording_literal_tree_freq, 
		recording_literal_code, 
		recording_literal_len
	);
}


//
// One-time init
//
// Generate the global slot tables which allow us to convert a distance
// (0..32K) to a distance slot (0..29), and a length (3..258) to
// a length slot (0...28)
//
static void GenerateSlotTables(void)
{
	int code, length, dist, n;

        /* Initialize the mapping length (0..255) -> length code (0..28) */
	length = 0;
	
	for (code = 0; code < NUM_LENGTH_BASE_CODES-1; code++)
	{
		for (n = 0; n < (1 << g_ExtraLengthBits[code]); n++) 
			g_LengthLookup[length++] = (byte) code;
	}

	g_LengthLookup[length-1] = (byte) code;
    _ASSERT((length-1) < sizeof(g_LengthLookup)/sizeof(g_LengthLookup[0]));

        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	dist = 0;
    
	for (code = 0 ; code < 16; code++)
	{
		for (n = 0; n < (1 << g_ExtraDistanceBits[code]); n++)
			g_DistLookup[dist++] = (byte) code;
	}

	dist >>= 7; /* from now on, all distances are divided by 128 */
    
	for ( ; code < NUM_DIST_BASE_CODES; code++) 
	{
		for (n = 0; n < (1 << (g_ExtraDistanceBits[code]-7)); n++) 
			g_DistLookup[256 + dist++] = (byte) code;
	}

    // ensure we didn't overflow the array
    _ASSERT(256 + dist <= sizeof(g_DistLookup)/sizeof(g_DistLookup[0]));
}


//
// One-time init
//
// Generate tables for encoding static blocks
//
static void GenerateStaticEncodingTables(void)
{
    int     i;
    int     len_cnt[17];
    BYTE    StaticDistanceTreeLength[MAX_DIST_TREE_ELEMENTS];

    // ensure we have already created the StaticLiteralTreeLength array
    // if we haven't, then this value would be zero
    _ASSERT(g_StaticLiteralTreeLength[0] != 0);

    //
    // Make literal tree
    //
    for (i = 0; i < 17; i++)
        len_cnt[i] = 0;

    // length count (how many length 8's, 9's, etc. there are) - needed to call makeCode()
    len_cnt[8] = 144;
    len_cnt[9] = 255-144+1;
    len_cnt[7] = 279-256+1;
    len_cnt[8] += (287-280)+1;

    makeCode(
        MAX_LITERAL_TREE_ELEMENTS, 
        len_cnt, 
        g_StaticLiteralTreeLength,
        g_StaticLiteralTreeCode
    );

    //
    // Make distance tree; there are 32 5-bit codes
    //
    for (i = 0; i < 17; i++)
        len_cnt[i] = 0;

    len_cnt[5] = 32;

    // We don't store StaticDistanceTreeLength[] globally, since it's 5 for everything,
    // but we need it to call makeCode()
    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
        StaticDistanceTreeLength[i] = 5;

    makeCode(
        MAX_DIST_TREE_ELEMENTS, 
        len_cnt, 
        StaticDistanceTreeLength,
        g_StaticDistanceTreeCode
    );
}


//
// Initialise global deflate data in the DLL
//
VOID deflateInit(VOID)
{
    GenerateSlotTables();
    InitStaticBlock();
    GenerateStaticEncodingTables();

    // For the fast encoder, take the hard-coded global tree we're using (which is NOT the same as
    // a static block's tree), generate the bitwise output for outputting the structure of that
    // tree, and record that globally, so that we can do a simple memcpy() to output the tree for
    // the fast encoder, instead of calling the tree output routine all the time.  This is a nifty
    // performance optimisation.
    FastEncoderGenerateDynamicTreeEncoding();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fastenc.h ===
/*
 * fastenc.h
 *
 * Defines for the fast encoder
 */

//
// Size of hash table for std encoder
//
#define FAST_ENCODER_HASH_TABLE_SIZE			2048
#define FAST_ENCODER_HASH_MASK					(FAST_ENCODER_HASH_TABLE_SIZE-1)
#define FAST_ENCODER_HASH_SHIFT					4

#define FAST_ENCODER_RECALCULATE_HASH(loc) \
	(((window[loc] << (2*FAST_ENCODER_HASH_SHIFT)) ^ \
	(window[loc+1] << FAST_ENCODER_HASH_SHIFT) ^ \
	(window[loc+2])) & FAST_ENCODER_HASH_MASK)


// 
// Be very careful about increasing the window size; the code tables will have to
// be updated, since they assume that extra_distance_bits is never larger than a
// certain size.
//
#define FAST_ENCODER_WINDOW_SIZE            8192
#define FAST_ENCODER_WINDOW_MASK            (FAST_ENCODER_WINDOW_SIZE - 1)


//
// Don't take a match 3 further away than this
//
#define FAST_ENCODER_MATCH3_DIST_THRESHOLD 16384


typedef struct fast_encoder
{
	// history window
	BYTE 					window[2*FAST_ENCODER_WINDOW_SIZE + MAX_MATCH + 4];

	// next most recent occurance of chars with same hash value
    t_search_node			prev[FAST_ENCODER_WINDOW_SIZE + MAX_MATCH];

	// hash table to find most recent occurance of chars with same hash value
	t_search_node			lookup[FAST_ENCODER_HASH_TABLE_SIZE];

    // have we output our block header (the whole data file will be one big dynamic block)?
    BOOL                    fOutputBlockHeader;

} t_fast_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\deftree.c ===
//
// deftree.c
//
// Tree creation for the compressor
//
#include "deflate.h"
#include <string.h>
#include <crtdbg.h>


//
// MAX_LITERAL_TREE elements is the largest number of elements that will ever be passed
// in to this routine
//
typedef struct 
{
    // Made left_right a single long array for performance reasons.  We always access them
    // one after the other, so there is no disadvantage.
    // left[] in lower 16 bits, right[] in upper 16 bits
//	short           left[2*MAX_LITERAL_TREE_ELEMENTS];
//	short           right[2*MAX_LITERAL_TREE_ELEMENTS];
    unsigned long   left_right[2*MAX_LITERAL_TREE_ELEMENTS];

	int             heap[MAX_LITERAL_TREE_ELEMENTS+1];

	int				num_elements;

	// Maximum allowable code length (7 for pre-tree, 15 for other trees)
	int				max_code_length;

	unsigned short *freq; // passed in as parameter
	unsigned short *code; // passed in as parameter
	
	short *			sortptr;
	int				depth;
	int				heapsize;
	int             len_cnt[17];
} t_tree_context;



static void countLen(t_tree_context *context, int i)  /* call with i = root */
{
	if (i < context->num_elements)
	{
		// check for max code length allowed
		context->len_cnt[(context->depth < context->max_code_length) ? context->depth : context->max_code_length]++;
	}
	else
	{
        unsigned long lr_value;
        
        _ASSERT(i >= 0 && i < 2*context->num_elements);

        lr_value = context->left_right[i];

		context->depth++;
		countLen(context, lr_value & 65535); // formerly left[i]
		countLen(context, lr_value >> 16); // formerly right[i]
		context->depth--;
	}
}


static void makeLen(t_tree_context *context, int root, BYTE *len)
{
	int		k;
	int		cum;
	int		i;

	for (i = 0; i <= 16; i++)
		context->len_cnt[i] = 0;

	countLen(context, root);

	cum = 0;

	for (i = context->max_code_length; i > 0; i--)
		cum += (context->len_cnt[i] << (context->max_code_length - i));

	while (cum != (1 << context->max_code_length))
	{
		context->len_cnt[context->max_code_length]--;

		for (i = context->max_code_length-1; i > 0; i--)
		{
			if (context->len_cnt[i] != 0)
			{
				context->len_cnt[i]--;
				context->len_cnt[i+1] += 2;
				break;
			}
		}

		cum--;
	}

	for (i = 16; i > 0; i--)
	{
		k = context->len_cnt[i];

		while (--k >= 0)
			len[ *context->sortptr++ ] = (byte) i;
	}
}


/* priority queue; send i-th entry down heap */
static void downHeap(t_tree_context *context, int i)
{
	int j, k;

    _ASSERT(i >= 0 && i <= context->num_elements);
	k = context->heap[i];

	while ((j = (i<<1)) <= context->heapsize)
	{
		if (j < context->heapsize && 
			context->freq[context->heap[j]] > context->freq[context->heap[j + 1]])
	 		j++;

		if (context->freq[k] <= context->freq[context->heap[j]])
			break;

		context->heap[i] = context->heap[j];
		i = j;
	}

    _ASSERT(i >= 0 && i <= context->num_elements);
	context->heap[i] = k;
}


//
// Reverse the bits, len > 0
//
static unsigned int bitReverse(unsigned int code, int len)
{
	unsigned int new_code = 0;

	do
	{
		new_code |= (code & 1);
		new_code <<= 1;
		code >>= 1;

	} while (--len > 0);

	return new_code >> 1;
}


void makeCode(int num_elements, const int *len_cnt, const BYTE *len, USHORT *code)
{
	int start[18];
	int i;
	
	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = (start[i] + len_cnt[i]) << 1;

	for (i = 0; i < num_elements; i++)
	{
		unsigned int unreversed_code;
		
		unreversed_code = start[len[i]]++;
		code[i] = (USHORT) bitReverse(unreversed_code, len[i]);
	}
}


void makeTree(
	int					num_elements,
	int					max_code_length,
	unsigned short *	freq,
	unsigned short *	code,
	byte *				len
)
{
	t_tree_context	tree;
	int				k;
	int				avail;
	int				i;

    _ASSERT(num_elements > 0 && num_elements <= MAX_LITERAL_TREE_ELEMENTS);

	// init tree context
	tree.depth	= 0;
	tree.freq	= freq;
	tree.code	= code;
	tree.num_elements = num_elements;
	tree.max_code_length = max_code_length;

	avail				= num_elements;
	tree.heapsize		= 0;
	tree.heap[1]		= 0;

	for (i = 0; i < tree.num_elements; i++)
	{
		len[i] = 0;

		if (tree.freq[i] != 0)
			tree.heap[++tree.heapsize] = i;
	}

	//
	// Less than 2 elements in the tree?
	//
	if (tree.heapsize < 2)
	{
		if (tree.heapsize == 0)
		{
			//
			// No elements in the tree?
			//
			// Then insert two fake elements and retry.
			//
			tree.freq[0] = 1;
			tree.freq[1] = 1;
		}	
		else
		{
			//
			// One element in the tree, so add a fake code
			//
			// If our only element is element #0 (heap[1] == 0), then
			// make element #1 have a frequency of 1.
			//
			// Else make element #0 have a frequency of 1.
			//
			if (tree.heap[1] == 0)
				tree.freq[1] = 1;
			else
				tree.freq[0] = 1;
		}

		//
		// Retry with these new frequencies
		//
		makeTree(num_elements, max_code_length, freq, code, len);
		return;
	}

	for (i = tree.heapsize >> 1; i >= 1; i--)
		downHeap(&tree, i);  /* make priority queue */

	tree.sortptr = tree.code;

	do
	{
		int i, j;

		/* while queue has at least two entries */
		i = tree.heap[1];  /* take out least-freq entry */

		if (i < tree.num_elements)
			*tree.sortptr++ = (short) i; 

		tree.heap[1] = tree.heap[tree.heapsize--];
		downHeap(&tree, 1);

		j = tree.heap[1];  /* next least-freq entry */

		if (j < tree.num_elements)
			*tree.sortptr++ = (short) j; 

		k = avail++;  /* generate new node */

		tree.freq[k] = tree.freq[i] + tree.freq[j];
		tree.heap[1] = k;
		downHeap(&tree, 1);  /* put into queue */

//		tree.left[k] = (short) i;
//		tree.right[k] = (short) j;

        _ASSERT(k >= 0 && k < 2*tree.num_elements);
		tree.left_right[k] = (j << 16) | i;

	} while (tree.heapsize > 1);

	tree.sortptr = tree.code;

	makeLen(&tree, k, len);
	makeCode(num_elements, tree.len_cnt, len, code);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fstdebug.c ===
/*
 * fstdebug.c
 *
 * Debugging stubs for fast encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef FULL_DEBUG
void FastEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
	int i;
	const t_search_node *lookup = context->fast_encoder->lookup;
	const t_search_node *prev = context->fast_encoder->prev;
	const BYTE *window = context->fast_encoder->window;

	for (i = 0; i < FAST_ENCODER_HASH_TABLE_SIZE; i++)
	{
		t_search_node where = lookup[i];
		t_search_node next_where;

		while (where != 0 && bufpos - where < FAST_ENCODER_WINDOW_SIZE)
		{
			int hash = FAST_ENCODER_RECALCULATE_HASH(where);

			_ASSERT(hash == i);

			next_where = prev[where & FAST_ENCODER_WINDOW_MASK];

			if (bufpos - next_where >= FAST_ENCODER_WINDOW_SIZE)
				break;

			_ASSERT(next_where < where);

			where = next_where;
		} 
	}
}


void FastEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number)
{
	const t_search_node *lookup = context->fast_encoder->lookup;
	const t_search_node *prev = context->fast_encoder->prev;
	BYTE *window = context->fast_encoder->window;
	t_search_node where;
	t_search_node next_where;
	int print = 0;

top:
	where = lookup[chain_number];

	if (print)
		printf("Verify chain %d\n", chain_number);

	while (where != 0 && bufpos - where < FAST_ENCODER_WINDOW_SIZE)
	{
		int hash = FAST_ENCODER_RECALCULATE_HASH(where);
        BYTE *window = context->fast_encoder->window;

		if (print)
			printf("   loc %d: char = %3d %3d %3d\n", where, window[where], window[where+1], window[where+2]);

		if (hash != chain_number && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(hash == chain_number);

		next_where = prev[where & FAST_ENCODER_WINDOW_MASK];

		if (bufpos - next_where >= FAST_ENCODER_WINDOW_SIZE)
			break;

		if (next_where >= where && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(next_where < where);

		where = next_where;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fasttbl.h ===
#ifdef DECLARE_DATA
const BYTE g_FastEncoderLiteralTreeLength[] = {
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0c,0x06,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0d,0x0e,
0x06,0x0e,0x0a,0x0c,0x0e,0x0e,0x0d,0x0a,0x08,0x09,0x0b,0x0a,0x07,0x08,0x07,0x09,
0x08,0x08,0x08,0x09,0x08,0x09,0x0a,0x09,0x08,0x09,0x09,0x08,0x09,0x0a,0x08,0x0e,
0x0e,0x08,0x09,0x08,0x09,0x08,0x09,0x0a,0x0b,0x08,0x0b,0x0e,0x09,0x0a,0x09,0x0a,
0x09,0x0c,0x09,0x09,0x09,0x0a,0x0c,0x0b,0x0e,0x0e,0x0c,0x0b,0x0e,0x0b,0x0e,0x0e,
0x0e,0x06,0x07,0x07,0x07,0x06,0x08,0x08,0x07,0x06,0x0c,0x09,0x06,0x07,0x07,0x06,
0x07,0x0d,0x06,0x06,0x06,0x07,0x08,0x08,0x09,0x08,0x0b,0x0d,0x0c,0x0d,0x0d,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0d,0x0d,0x0d,0x0e,0x0d,0x0e,0x0d,0x0e,0x0d,0x0e,0x0e,0x0e,0x0e,
0x0e,0x04,0x03,0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x05,0x06,0x06,0x05,0x06,0x07,
0x08,0x08,0x09,0x0a,0x09,0x0a,0x0c,0x0b,0x0c,0x0e,0x0e,0x0e,0x0c,0x0b,
};
const USHORT g_FastEncoderLiteralTreeCode[] = {
0x06bf,0x26bf,0x16bf,0x36bf,0x0ebf,0x2ebf,0x1ebf,0x3ebf,
0x01bf,0x063f,0x0009,0x21bf,0x11bf,0x31bf,0x09bf,0x29bf,
0x19bf,0x39bf,0x05bf,0x25bf,0x15bf,0x35bf,0x0dbf,0x2dbf,
0x1dbf,0x3dbf,0x03bf,0x23bf,0x13bf,0x33bf,0x00bf,0x0bbf,
0x0029,0x2bbf,0x011f,0x0e3f,0x1bbf,0x3bbf,0x10bf,0x031f,
0x005b,0x0077,0x02df,0x009f,0x0023,0x00db,0x0063,0x0177,
0x003b,0x00bb,0x007b,0x00f7,0x00fb,0x01f7,0x029f,0x000f,
0x0007,0x010f,0x008f,0x0087,0x018f,0x019f,0x0047,0x07bf,
0x27bf,0x00c7,0x004f,0x0027,0x014f,0x00a7,0x00cf,0x039f,
0x06df,0x0067,0x01df,0x17bf,0x01cf,0x005f,0x002f,0x025f,
0x012f,0x013f,0x00af,0x01af,0x006f,0x015f,0x093f,0x05df,
0x37bf,0x0fbf,0x053f,0x03df,0x2fbf,0x07df,0x1fbf,0x3fbf,
0x007f,0x0019,0x0013,0x0053,0x0033,0x0039,0x00e7,0x0017,
0x0073,0x0005,0x0d3f,0x016f,0x0025,0x000b,0x004b,0x0015,
0x002b,0x08bf,0x0035,0x000d,0x002d,0x006b,0x0097,0x0057,
0x00ef,0x00d7,0x003f,0x18bf,0x033f,0x04bf,0x14bf,0x207f,
0x107f,0x307f,0x087f,0x287f,0x187f,0x387f,0x047f,0x247f,
0x147f,0x347f,0x0c7f,0x2c7f,0x1c7f,0x3c7f,0x027f,0x227f,
0x127f,0x327f,0x0a7f,0x2a7f,0x1a7f,0x3a7f,0x067f,0x267f,
0x167f,0x367f,0x0e7f,0x2e7f,0x1e7f,0x3e7f,0x017f,0x217f,
0x117f,0x317f,0x097f,0x297f,0x197f,0x397f,0x057f,0x257f,
0x157f,0x357f,0x0d7f,0x2d7f,0x1d7f,0x3d7f,0x037f,0x237f,
0x137f,0x337f,0x0b7f,0x2b7f,0x1b7f,0x3b7f,0x077f,0x277f,
0x177f,0x377f,0x0f7f,0x2f7f,0x1f7f,0x3f7f,0x00ff,0x20ff,
0x10ff,0x30ff,0x08ff,0x28ff,0x18ff,0x38ff,0x04ff,0x24ff,
0x14ff,0x34ff,0x0cff,0x2cff,0x1cff,0x3cff,0x02ff,0x22ff,
0x12ff,0x32ff,0x0aff,0x2aff,0x1aff,0x3aff,0x06ff,0x26ff,
0x16ff,0x36ff,0x0eff,0x2eff,0x1eff,0x3eff,0x01ff,0x21ff,
0x11ff,0x31ff,0x09ff,0x29ff,0x19ff,0x39ff,0x05ff,0x25ff,
0x15ff,0x35ff,0x0dff,0x2dff,0x1dff,0x3dff,0x03ff,0x23ff,
0x13ff,0x33ff,0x0bff,0x0cbf,0x1cbf,0x02bf,0x2bff,0x12bf,
0x1bff,0x0abf,0x3bff,0x1abf,0x07ff,0x27ff,0x17ff,0x37ff,
0x0fff,0x0004,0x0000,0x000c,0x0002,0x000a,0x0006,0x0016,
0x000e,0x001e,0x0001,0x001d,0x003d,0x0011,0x0003,0x001b,
0x0037,0x00b7,0x01ef,0x035f,0x001f,0x00df,0x0b3f,0x043f,
0x073f,0x2fff,0x1fff,0x3fff,0x0f3f,0x023f,
};
#else /* !DECLARE_DATA */
extern const BYTE g_FastEncoderLiteralTreeLength[];
extern const USHORT g_FastEncoderLiteralTreeCode[];
#endif /* DECLARE_DATA */
#ifdef DECLARE_DATA
const BYTE g_FastEncoderDistanceTreeLength[] = {
0x06,0x0a,0x0b,0x0b,0x09,0x08,0x08,0x08,0x07,0x07,0x05,0x06,0x04,0x05,0x04,0x05,
0x04,0x05,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x00,0x00,
};
const USHORT g_FastEncoderDistanceTreeCode[] = {
0x000f,0x01ff,0x03ff,0x07ff,0x00ff,0x003f,0x00bf,0x007f,
0x001f,0x005f,0x000d,0x002f,0x0000,0x001d,0x0008,0x0003,
0x0004,0x0013,0x000c,0x0002,0x000a,0x0006,0x000e,0x0001,
0x0009,0x000b,0x0005,0x001b,0x0007,0x0017,0x0000,0x0001,
};
#else /* !DECLARE_DATA */
extern const BYTE g_FastEncoderDistanceTreeLength[];
extern const USHORT g_FastEncoderDistanceTreeCode[];
#endif /* DECLARE_DATA */



#ifdef DECLARE_DATA
const ULONG g_FastEncoderLiteralCodeInfo[] = {

0x0000d7ee,0x0004d7ee,0x0002d7ee,0x0006d7ee,0x0001d7ee,0x0005d7ee,0x0003d7ee,
0x0007d7ee,0x000037ee,0x0000c7ec,0x00000126,0x000437ee,0x000237ee,0x000637ee,
0x000137ee,0x000537ee,0x000337ee,0x000737ee,0x0000b7ee,0x0004b7ee,0x0002b7ee,
0x0006b7ee,0x0001b7ee,0x0005b7ee,0x0003b7ee,0x0007b7ee,0x000077ee,0x000477ee,
0x000277ee,0x000677ee,0x000017ed,0x000177ee,0x00000526,0x000577ee,0x000023ea,
0x0001c7ec,0x000377ee,0x000777ee,0x000217ed,0x000063ea,0x00000b68,0x00000ee9,
0x00005beb,0x000013ea,0x00000467,0x00001b68,0x00000c67,0x00002ee9,0x00000768,
0x00001768,0x00000f68,0x00001ee9,0x00001f68,0x00003ee9,0x000053ea,0x000001e9,
0x000000e8,0x000021e9,0x000011e9,0x000010e8,0x000031e9,0x000033ea,0x000008e8,
0x0000f7ee,0x0004f7ee,0x000018e8,0x000009e9,0x000004e8,0x000029e9,0x000014e8,
0x000019e9,0x000073ea,0x0000dbeb,0x00000ce8,0x00003beb,0x0002f7ee,0x000039e9,
0x00000bea,0x000005e9,0x00004bea,0x000025e9,0x000027ec,0x000015e9,0x000035e9,
0x00000de9,0x00002bea,0x000127ec,0x0000bbeb,0x0006f7ee,0x0001f7ee,0x0000a7ec,
0x00007beb,0x0005f7ee,0x0000fbeb,0x0003f7ee,0x0007f7ee,0x00000fee,0x00000326,
0x00000267,0x00000a67,0x00000667,0x00000726,0x00001ce8,0x000002e8,0x00000e67,
0x000000a6,0x0001a7ec,0x00002de9,0x000004a6,0x00000167,0x00000967,0x000002a6,
0x00000567,0x000117ed,0x000006a6,0x000001a6,0x000005a6,0x00000d67,0x000012e8,
0x00000ae8,0x00001de9,0x00001ae8,0x000007eb,0x000317ed,0x000067ec,0x000097ed,
0x000297ed,0x00040fee,0x00020fee,0x00060fee,0x00010fee,0x00050fee,0x00030fee,
0x00070fee,0x00008fee,0x00048fee,0x00028fee,0x00068fee,0x00018fee,0x00058fee,
0x00038fee,0x00078fee,0x00004fee,0x00044fee,0x00024fee,0x00064fee,0x00014fee,
0x00054fee,0x00034fee,0x00074fee,0x0000cfee,0x0004cfee,0x0002cfee,0x0006cfee,
0x0001cfee,0x0005cfee,0x0003cfee,0x0007cfee,0x00002fee,0x00042fee,0x00022fee,
0x00062fee,0x00012fee,0x00052fee,0x00032fee,0x00072fee,0x0000afee,0x0004afee,
0x0002afee,0x0006afee,0x0001afee,0x0005afee,0x0003afee,0x0007afee,0x00006fee,
0x00046fee,0x00026fee,0x00066fee,0x00016fee,0x00056fee,0x00036fee,0x00076fee,
0x0000efee,0x0004efee,0x0002efee,0x0006efee,0x0001efee,0x0005efee,0x0003efee,
0x0007efee,0x00001fee,0x00041fee,0x00021fee,0x00061fee,0x00011fee,0x00051fee,
0x00031fee,0x00071fee,0x00009fee,0x00049fee,0x00029fee,0x00069fee,0x00019fee,
0x00059fee,0x00039fee,0x00079fee,0x00005fee,0x00045fee,0x00025fee,0x00065fee,
0x00015fee,0x00055fee,0x00035fee,0x00075fee,0x0000dfee,0x0004dfee,0x0002dfee,
0x0006dfee,0x0001dfee,0x0005dfee,0x0003dfee,0x0007dfee,0x00003fee,0x00043fee,
0x00023fee,0x00063fee,0x00013fee,0x00053fee,0x00033fee,0x00073fee,0x0000bfee,
0x0004bfee,0x0002bfee,0x0006bfee,0x0001bfee,0x0005bfee,0x0003bfee,0x0007bfee,
0x00007fee,0x00047fee,0x00027fee,0x00067fee,0x00017fee,0x000197ed,0x000397ed,
0x000057ed,0x00057fee,0x000257ed,0x00037fee,0x000157ed,0x00077fee,0x000357ed,
0x0000ffee,0x0004ffee,0x0002ffee,0x0006ffee,0x0001ffee,0x00000084,0x00000003,
0x00000184,0x00000044,0x00000144,0x000000c5,0x000002c5,0x000001c5,0x000003c6,
0x000007c6,0x00000026,0x00000426,0x000003a7,0x00000ba7,0x000007a7,0x00000fa7,
0x00000227,0x00000627,0x00000a27,0x00000e27,0x00000068,0x00000868,0x00001068,
0x00001868,0x00000369,0x00001369,0x00002369,0x00003369,0x000006ea,0x000026ea,
0x000046ea,0x000066ea,0x000016eb,0x000036eb,0x000056eb,0x000076eb,0x000096eb,
0x0000b6eb,0x0000d6eb,0x0000f6eb,0x00003dec,0x00007dec,0x0000bdec,0x0000fdec,
0x00013dec,0x00017dec,0x0001bdec,0x0001fdec,0x00006bed,0x0000ebed,0x00016bed,
0x0001ebed,0x00026bed,0x0002ebed,0x00036bed,0x0003ebed,0x000003ec,0x000043ec,
0x000083ec,0x0000c3ec,0x000103ec,0x000143ec,0x000183ec,0x0001c3ec,0x00001bee,
0x00009bee,0x00011bee,0x00019bee,0x00021bee,0x00029bee,0x00031bee,0x00039bee,
0x00041bee,0x00049bee,0x00051bee,0x00059bee,0x00061bee,0x00069bee,0x00071bee,
0x00079bee,0x000167f0,0x000367f0,0x000567f0,0x000767f0,0x000967f0,0x000b67f0,
0x000d67f0,0x000f67f0,0x001167f0,0x001367f0,0x001567f0,0x001767f0,0x001967f0,
0x001b67f0,0x001d67f0,0x001f67f0,0x000087ef,0x000187ef,0x000287ef,0x000387ef,
0x000487ef,0x000587ef,0x000687ef,0x000787ef,0x000887ef,0x000987ef,0x000a87ef,
0x000b87ef,0x000c87ef,0x000d87ef,0x000e87ef,0x000f87ef,0x0000e7f0,0x0002e7f0,
0x0004e7f0,0x0006e7f0,0x0008e7f0,0x000ae7f0,0x000ce7f0,0x000ee7f0,0x0010e7f0,
0x0012e7f0,0x0014e7f0,0x0016e7f0,0x0018e7f0,0x001ae7f0,0x001ce7f0,0x001ee7f0,
0x0005fff3,0x000dfff3,0x0015fff3,0x001dfff3,0x0025fff3,0x002dfff3,0x0035fff3,
0x003dfff3,0x0045fff3,0x004dfff3,0x0055fff3,0x005dfff3,0x0065fff3,0x006dfff3,
0x0075fff3,0x007dfff3,0x0085fff3,0x008dfff3,0x0095fff3,0x009dfff3,0x00a5fff3,
0x00adfff3,0x00b5fff3,0x00bdfff3,0x00c5fff3,0x00cdfff3,0x00d5fff3,0x00ddfff3,
0x00e5fff3,0x00edfff3,0x00f5fff3,0x00fdfff3,0x0003fff3,0x000bfff3,0x0013fff3,
0x001bfff3,0x0023fff3,0x002bfff3,0x0033fff3,0x003bfff3,0x0043fff3,0x004bfff3,
0x0053fff3,0x005bfff3,0x0063fff3,0x006bfff3,0x0073fff3,0x007bfff3,0x0083fff3,
0x008bfff3,0x0093fff3,0x009bfff3,0x00a3fff3,0x00abfff3,0x00b3fff3,0x00bbfff3,
0x00c3fff3,0x00cbfff3,0x00d3fff3,0x00dbfff3,0x00e3fff3,0x00ebfff3,0x00f3fff3,
0x00fbfff3,0x0007fff3,0x000ffff3,0x0017fff3,0x001ffff3,0x0027fff3,0x002ffff3,
0x0037fff3,0x003ffff3,0x0047fff3,0x004ffff3,0x0057fff3,0x005ffff3,0x0067fff3,
0x006ffff3,0x0077fff3,0x007ffff3,0x0087fff3,0x008ffff3,0x0097fff3,0x009ffff3,
0x00a7fff3,0x00affff3,0x00b7fff3,0x00bffff3,0x00c7fff3,0x00cffff3,0x00d7fff3,
0x00dffff3,0x00e7fff3,0x00effff3,0x00f7fff3,0x00fffff3,0x0001e7f1,0x0003e7f1,
0x0005e7f1,0x0007e7f1,0x0009e7f1,0x000be7f1,0x000de7f1,0x000fe7f1,0x0011e7f1,
0x0013e7f1,0x0015e7f1,0x0017e7f1,0x0019e7f1,0x001be7f1,0x001de7f1,0x001fe7f1,
0x0021e7f1,0x0023e7f1,0x0025e7f1,0x0027e7f1,0x0029e7f1,0x002be7f1,0x002de7f1,
0x002fe7f1,0x0031e7f1,0x0033e7f1,0x0035e7f1,0x0037e7f1,0x0039e7f1,0x003be7f1,
0x003de7f1,0x000047eb,
};
#else /* !DECLARE_DATA */
extern const ULONG g_FastEncoderLiteralCodeInfo[];
#endif /* DECLARE_DATA */
#ifdef DECLARE_DATA
const ULONG g_FastEncoderDistanceCodeInfo[] = {

0x00000f06,0x0001ff0a,0x0003ff0b,0x0007ff0b,0x0000ff19,0x00003f18,0x0000bf28,
0x00007f28,0x00001f37,0x00005f37,0x00000d45,0x00002f46,0x00000054,0x00001d55,
0x00000864,0x00000365,0x00000474,0x00001375,0x00000c84,0x00000284,0x00000a94,
0x00000694,0x00000ea4,0x000001a4,0x000009b4,0x00000bb5,0x000005c4,0x00001bc5,
0x000007d5,0x000017d5,0x00000000,0x00000100,
};
#else /* !DECLARE_DATA */
extern const ULONG g_FastEncoderDistanceCodeInfo[];
#endif /* DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\gzip.c ===
//
// gzip.c
//
// All of the gzip-related additions to deflate (both encoder and decoder) are in this file
//

#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "inflate.h"
#include "infmacro.h"
#include "defgzip.h"
#include "infgzip.h"
#include "crc32.h"


#define GZIP_FLG_FTEXT      1
#define GZIP_FLG_CRC        2
#define GZIP_FLG_FEXTRA     4
#define GZIP_FLG_FNAME      8
#define GZIP_FLG_FCOMMENT   16


typedef enum
{
    // GZIP header
    GZIP_HDR_STATE_READING_ID1,
    GZIP_HDR_STATE_READING_ID2,
    GZIP_HDR_STATE_READING_CM,
    GZIP_HDR_STATE_READING_FLG,
    GZIP_HDR_STATE_READING_MMTIME, // iterates 4 times
    GZIP_HDR_STATE_READING_XFL,
    GZIP_HDR_STATE_READING_OS,
    GZIP_HDR_STATE_READING_XLEN1,
    GZIP_HDR_STATE_READING_XLEN2,
    GZIP_HDR_STATE_READING_XLEN_DATA,
    GZIP_HDR_STATE_READING_FILENAME,
    GZIP_HDR_STATE_READING_COMMENT,
    GZIP_HDR_STATE_READING_CRC16_PART1,
    GZIP_HDR_STATE_READING_CRC16_PART2,
    GZIP_HDR_STATE_DONE, // done reading GZIP header

    // GZIP footer
    GZIP_FTR_STATE_READING_CRC, // iterates 4 times
    GZIP_FTR_STATE_READING_FILE_SIZE // iterates 4 times
} t_gzip_state;


void EncoderInitGzipVariables(t_encoder_context *context)
{
    context->gzip_crc32 = 0;
    context->gzip_input_stream_size = 0;
    context->gzip_fOutputGzipHeader = FALSE;
}


void DecoderInitGzipVariables(t_decoder_context *context)
{
    context->gzip_crc32 = 0;
    context->gzip_output_stream_size = 0;
}


void WriteGzipHeader(t_encoder_context *context, int compression_level)
{
    BYTE *output_curpos = context->output_curpos;

    // only need 11 bytes
    _ASSERT(context->output_curpos + 16 <  context->output_endpos);

#ifndef TESTING
    // the proper code path
    *output_curpos++ = 0x1F; // ID1
    *output_curpos++ = 0x8B; // ID2
    *output_curpos++ = 8; // CM = deflate
    *output_curpos++ = 0; // FLG, no text, no crc, no extra, no name, no comment

    *output_curpos++ = 0; // MTIME (Modification Time) - no time available
    *output_curpos++ = 0;
    *output_curpos++ = 0;
    *output_curpos++ = 0;

    // XFL
    // 2 = compressor used max compression, slowest algorithm
    // 4 = compressor used fastest algorithm
    if (compression_level == 10)
        *output_curpos++ = 2; 
    else
        *output_curpos++ = 4; 

    *output_curpos++ = 0; // OS: 0 = FAT filesystem (MS-DOS, OS/2, NT/Win32)
#else /* TESTING */
    // this code is for code path testing only
    // it uses all of the headers to ensure that the decoder can handle them correctly
    *output_curpos++ = 0x1F; // ID1
    *output_curpos++ = 0x8B; // ID2
    *output_curpos++ = 8; // CM = deflate
    *output_curpos++ = (GZIP_FLG_CRC|GZIP_FLG_FEXTRA|GZIP_FLG_FNAME|GZIP_FLG_FCOMMENT); // FLG

    *output_curpos++ = 0; // MTIME (Modification Time) - no time available
    *output_curpos++ = 0;
    *output_curpos++ = 0;
    *output_curpos++ = 0;

    *output_curpos++ = 2; // XFL
    *output_curpos++ = 0; // OS: 0 = FAT filesystem (MS-DOS, OS/2, NT/Win32)
    
    // FEXTRA
    *output_curpos++ = 3; // LSB
    *output_curpos++ = 0; // MSB
    output_curpos += 3; // 3 bytes of data

    // FNAME, null terminated filename
    output_curpos += strlen(strcpy(output_curpos, "my filename"))+1;

    // FCOMMENT, null terminated comment
    output_curpos += strlen(strcpy(output_curpos, "my comment"))+1;

    // CRC16
    *output_curpos++ = 0x12;
    *output_curpos++ = 0x34;
#endif

	context->output_curpos = output_curpos;
}


void WriteGzipFooter(t_encoder_context *context)
{
    BYTE *output_curpos = context->output_curpos;

    *output_curpos++ = (BYTE) (context->gzip_crc32 & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 8) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 16) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 24) & 255);

    *output_curpos++ = (BYTE) (context->gzip_input_stream_size & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 8) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 16) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 24) & 255);

	context->output_curpos = output_curpos;
}


BOOL ReadGzipFooter(t_decoder_context *context)
{
	if (context->state == STATE_START_READING_GZIP_FOOTER)
    {
        context->state = STATE_READING_GZIP_FOOTER;
        context->gzip_footer_substate = GZIP_FTR_STATE_READING_CRC;
        context->gzip_footer_loop_counter = 0;
    }

    _ASSERT(context->state == STATE_READING_GZIP_FOOTER);

	if (INPUT_EOF())
		return TRUE;

    if (context->gzip_footer_substate == GZIP_FTR_STATE_READING_CRC)
    {
        if (context->gzip_footer_loop_counter == 0)
            context->gzip_footer_crc32 = 0;

        while (context->gzip_footer_loop_counter < 4)
        {
            context->gzip_footer_crc32 |= ((*context->input_curpos++) << (8*context->gzip_footer_loop_counter));
            context->gzip_footer_loop_counter++;

            if (INPUT_EOF())
			    break;
        }

        if (context->gzip_footer_loop_counter >= 4)
        {
            context->gzip_footer_substate = GZIP_FTR_STATE_READING_FILE_SIZE;
            context->gzip_footer_loop_counter = 0;
        }

        if (INPUT_EOF())
	        return TRUE;
    }

    if (context->gzip_footer_substate == GZIP_FTR_STATE_READING_FILE_SIZE)
    {
        if (context->gzip_footer_loop_counter == 0)
            context->gzip_footer_output_stream_size = 0;

        while (context->gzip_footer_loop_counter < 4)
        {
            context->gzip_footer_output_stream_size |= ((*context->input_curpos++) << (8*context->gzip_footer_loop_counter));
            context->gzip_footer_loop_counter++;

            if (INPUT_EOF())
                break;
        }

        if (context->gzip_footer_loop_counter >= 4)
            context->state = STATE_VERIFYING_GZIP_FOOTER;
    }

    return TRUE;
}


BOOL ReadGzipHeader(t_decoder_context *context)
{
	if (context->state != STATE_READING_GZIP_HEADER)
    {
        context->state = STATE_READING_GZIP_HEADER;
        context->gzip_header_substate = GZIP_HDR_STATE_READING_ID1;
    }

	if (INPUT_EOF())
		return TRUE;

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_ID1)
    {
        if (*context->input_curpos++ != 0x1F)
            return FALSE;

        context->gzip_header_substate = GZIP_HDR_STATE_READING_ID2;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_ID2)
    {
        if (*context->input_curpos++ != 0x8B)
            return FALSE;

        context->gzip_header_substate = GZIP_HDR_STATE_READING_CM;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_CM)
    {
        // compression mode must be 8 (deflate)
        if (*context->input_curpos++ != 8)
            return FALSE;

        context->gzip_header_substate = GZIP_HDR_STATE_READING_FLG;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_FLG)
    {
        context->gzip_header_flag = *context->input_curpos++;
        context->gzip_header_substate = GZIP_HDR_STATE_READING_MMTIME;
        context->gzip_header_loop_counter = 0; // 4 MMTIME bytes

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_MMTIME)
    {
        // MTIME
        while (context->gzip_header_loop_counter < 4)
        {
            context->input_curpos++;
            context->gzip_header_loop_counter++;

            if (INPUT_EOF())
			    return TRUE;
        }

        context->gzip_header_substate = GZIP_HDR_STATE_READING_XFL;
        context->gzip_header_loop_counter = 0;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XFL)
    {
        context->input_curpos++; // ignore XFL
        context->gzip_header_substate = GZIP_HDR_STATE_READING_OS;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_OS)
    {
        context->input_curpos++; // ignore OS
        context->gzip_header_substate = GZIP_HDR_STATE_READING_XLEN1;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XLEN1)
    {
        // skip over some states if there's no "extra" data
        if ((context->gzip_header_flag & GZIP_FLG_FEXTRA) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_READING_FILENAME;
            goto gzip_state_reading_fname;
        }

        context->gzip_header_xlen1_byte = *context->input_curpos++; 
        context->gzip_header_substate = GZIP_HDR_STATE_READING_XLEN2;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XLEN2)
    {
        BYTE xlen2 = *context->input_curpos++; 
        context->gzip_header_xlen = context->gzip_header_xlen1_byte | (xlen2 << 8);
        context->gzip_header_substate = GZIP_HDR_STATE_READING_XLEN_DATA;
        context->gzip_header_loop_counter = 0; // 0 bytes of XLEN data read so far

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XLEN_DATA)
    {
        while (context->gzip_header_loop_counter < context->gzip_header_xlen)
        {
            context->input_curpos++;
            context->gzip_header_loop_counter++;

            if (INPUT_EOF())
                break;
        }

        if (context->gzip_header_loop_counter >= context->gzip_header_xlen)
            context->gzip_header_substate = GZIP_HDR_STATE_READING_FILENAME;

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_reading_fname:

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_FILENAME)
    {
        // skip over this state if there's no filename
        if ((context->gzip_header_flag & GZIP_FLG_FNAME) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_READING_COMMENT;
            goto gzip_state_reading_comment;
        }

        do
        {
            if (*context->input_curpos++ == 0)
            {
                // filename null terminator found
                context->gzip_header_substate = GZIP_HDR_STATE_READING_COMMENT;
                break;
            }
        } while (!INPUT_EOF());

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_reading_comment:

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_COMMENT)
    {
        // skip over this state if there's no filename
        if ((context->gzip_header_flag & GZIP_FLG_FCOMMENT) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_READING_CRC16_PART1;
            goto gzip_state_reading_crc16;
        }

        do
        {
            if (*context->input_curpos++ == 0)
            {
                // filename null terminator found
                context->gzip_header_substate = GZIP_HDR_STATE_READING_CRC16_PART1;
                break;
            }
        } while (!INPUT_EOF());

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_reading_crc16:

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_CRC16_PART1)
    {
        // skip over these states if there's no crc16
        if ((context->gzip_header_flag & GZIP_FLG_CRC) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_DONE;
            goto gzip_state_done;
        }

        context->input_curpos++; // ignore crc
        context->gzip_header_substate = GZIP_HDR_STATE_READING_CRC16_PART2;

        if (INPUT_EOF())
            return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_CRC16_PART2)
    {
        context->input_curpos++; // ignore crc
        context->gzip_header_substate = GZIP_HDR_STATE_DONE;

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_done:

    if (context->gzip_header_substate == GZIP_HDR_STATE_DONE)
        context->state = STATE_READING_BFINAL_NEED_TO_INIT_BITBUF;

    return TRUE;
}


#define DO1(buf) crc = g_CrcTable[((ULONG)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

ULONG GzipCRC32(ULONG crc, const BYTE *buf, ULONG len)
{
    crc = crc ^ 0xffffffffUL;

    while (len >= 8)
    {
        DO8(buf);
        len -= 8;
    }

    if (len)
    {
        do
        {
          DO1(buf);
        } while (--len);
    }

    return crc ^ 0xffffffffUL;
}


//
// Works just like memcpy() except that we update context->crc32 and context->input_stream_size
// at the same time.
//
// Could possibly improve the perf by copying 4 or 8 bytes at a time as above
//
void GzipCRCmemcpy(t_encoder_context *context, BYTE *dest, const BYTE *src, ULONG count)
{
    ULONG crc = context->gzip_crc32 ^ 0xffffffffUL;

    context->gzip_input_stream_size += count;

    while (count-- > 0)
    {
        *dest++ = *src;
        DO1(src); // increments src
    }

    context->gzip_crc32 = crc ^ 0xffffffffUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infdata.h ===
//
// infdata.h
//
#ifdef DECLARE_DATA
SHORT           g_StaticDistanceTreeTable[STATIC_BLOCK_DISTANCE_TABLE_SIZE];
SHORT           g_StaticLiteralTreeTable[STATIC_BLOCK_LITERAL_TABLE_SIZE];
#else
extern SHORT    g_StaticDistanceTreeTable[STATIC_BLOCK_DISTANCE_TABLE_SIZE];
extern SHORT    g_StaticLiteralTreeTable[STATIC_BLOCK_LITERAL_TABLE_SIZE];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\fstenc.c ===
/*
 * fstenc.c
 *
 * Fast encoder
 *
 * This is a one pass encoder which uses predefined trees.  However, since these are not the same
 * trees defined for a fixed block (we use better trees than that), we output a dynamic block header.
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "fasttbl.h"


//
// For debugging purposes:
//
// Verifies that all of the hash pointers in the hash table are correct, and that everything
// in the same hash chain has the same hash value
//
#ifdef FULL_DEBUG
#define VERIFY_HASHES(bufpos) FastEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif


//
// Update hash variable "h" with character c
//
#define UPDATE_HASH(h,c) \
    h = ((h) << FAST_ENCODER_HASH_SHIFT) ^ (c);


//
// Insert a string into the hash chain at location bufpos
//
#define INSERT_STRING(search,bufpos) \
{ \
    UPDATE_HASH(hash, window[bufpos+2]); \
\
    _ASSERT((unsigned int) FAST_ENCODER_RECALCULATE_HASH(bufpos) == (unsigned int) (hash & FAST_ENCODER_HASH_MASK)); \
\
    search = lookup[hash & FAST_ENCODER_HASH_MASK]; \
    lookup[hash & FAST_ENCODER_HASH_MASK] = (t_search_node) (bufpos); \
    prev[bufpos & FAST_ENCODER_WINDOW_MASK] = (t_search_node) (search); \
}


//
// Output bits function which uses local variables for the bit buffer
//
#define LOCAL_OUTPUT_BITS(n, x) \
{ \
    bitbuf |= ((x) << bitcount); \
    bitcount += (n); \
    if (bitcount >= 16) \
    { \
        *output_curpos++ = (BYTE) bitbuf; \
        *output_curpos++ = (BYTE) (bitbuf >> 8); \
        bitcount -= 16; \
        bitbuf >>= 16; \
    } \
}


//
// Output unmatched symbol c
//
#define OUTPUT_CHAR(c) \
    LOCAL_OUTPUT_BITS(g_FastEncoderLiteralCodeInfo[c] & 31, g_FastEncoderLiteralCodeInfo[c] >> 5);


//
// Output a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
// Optimisation: unlike the other encoders, here we have an array of codes for each match
// length (not just each match length slot), complete with all the extra bits filled in, in
// a single array element.  
//
// There are many advantages to doing this:
//
// 1. A single array lookup on g_FastEncoderLiteralCodeInfo, instead of separate array lookups
//    on g_LengthLookup (to get the length slot), g_FastEncoderLiteralTreeLength, 
//    g_FastEncoderLiteralTreeCode, g_ExtraLengthBits, and g_BitMask
//
// 2. The array is an array of ULONGs, so no access penalty, unlike for accessing those USHORT
//    code arrays in the other encoders (although they could be made into ULONGs with some
//    modifications to the source).
//
// Note, if we could guarantee that code_len <= 16 always, then we could skip an if statement here.
//
// A completely different optimisation is used for the distance codes since, obviously, a table for 
// all 8192 distances combining their extra bits is not feasible.  The distance codeinfo table is 
// made up of code[], len[] and # extra_bits for this code.
//
// The advantages are similar to the above; a ULONG array instead of a USHORT and BYTE array, better
// cache locality, fewer memory operations.
//
#define OUTPUT_MATCH(match_len, match_pos) \
{ \
    int extra_bits; \
    int code_len; \
    ULONG code_info; \
\
    _ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
\
    code_info = g_FastEncoderLiteralCodeInfo[(NUM_CHARS+1-MIN_MATCH)+match_len]; \
    code_len = code_info & 31; \
    _ASSERT(code_len != 0); \
    if (code_len <= 16) \
    { \
        LOCAL_OUTPUT_BITS(code_len, code_info >> 5); \
    } \
    else \
    { \
        LOCAL_OUTPUT_BITS(16, (code_info >> 5) & 65535); \
        LOCAL_OUTPUT_BITS(code_len-16, code_info >> (5+16)); \
    } \
    code_info = g_FastEncoderDistanceCodeInfo[POS_SLOT(match_pos)]; \
    LOCAL_OUTPUT_BITS(code_info & 15, code_info >> 8); \
    extra_bits = (code_info >> 4) & 15; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_pos) & g_BitMask[extra_bits]); \
}


//
// This commented out code is the old way of doing things, which is what the other encoders use
//
#if 0
#define OUTPUT_MATCH(match_len, match_pos) \
{ \
    int pos_slot = POS_SLOT(match_pos); \
    int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
    int extra_bits; \
\
    _ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
    _ASSERT(g_FastEncoderLiteralTreeLength[(NUM_CHARS+1)+len_slot] != 0); \
    _ASSERT(g_FastEncoderDistanceTreeLength[pos_slot] != 0); \
\
    LOCAL_OUTPUT_BITS(g_FastEncoderLiteralTreeLength[(NUM_CHARS+1)+len_slot], g_FastEncoderLiteralTreeCode[(NUM_CHARS+1)+len_slot]); \
    extra_bits = g_ExtraLengthBits[len_slot]; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_len-MIN_MATCH) & g_BitMask[extra_bits]); \
\
    LOCAL_OUTPUT_BITS(g_FastEncoderDistanceTreeLength[pos_slot], g_FastEncoderDistanceTreeCode[pos_slot]); \
    extra_bits = g_ExtraDistanceBits[pos_slot]; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_pos) & g_BitMask[extra_bits]); \
}
#endif


//
// Local function prototypes
//
static void FastEncoderMoveWindows(t_encoder_context *context);

static int FastEncoderFindMatch(
    const BYTE *    window,
    const USHORT *  prev,
    long            bufpos, 
    long            search, 
    t_match_pos *   match_pos, 
    int             cutoff,
    int             nice_length
);


//
// Output the block type and tree structure for our hard-coded trees.
//
// Functionally equivalent to:
//
// outputBits(context, 1, 1); // "final" block flag
// outputBits(context, 2, BLOCKTYPE_DYNAMIC);
// outputTreeStructure(context, g_FastEncoderLiteralTreeLength, g_FastEncoderDistanceTreeLength);
//
// However, all of the above has smartly been cached in global data, so we just memcpy().
//
void FastEncoderOutputPreamble(t_encoder_context *context)
{
#if 0
    // slow way:
    outputBits(context, 1+2, 1 | (BLOCKTYPE_DYNAMIC << 1));
    outputTreeStructure(context, g_FastEncoderLiteralTreeLength, g_FastEncoderDistanceTreeLength);
#endif

    // make sure tree has been init
    _ASSERT(g_FastEncoderTreeLength > 0);

    // make sure we have enough space to output tree
    _ASSERT(context->output_curpos + g_FastEncoderTreeLength < context->output_endpos);

    // fast way:
    memcpy(context->output_curpos, g_FastEncoderTreeStructureData, g_FastEncoderTreeLength);
    context->output_curpos += g_FastEncoderTreeLength;

    // need to get final states of bitbuf and bitcount after outputting all that stuff
    context->bitbuf = g_FastEncoderPostTreeBitbuf;
    context->bitcount = g_FastEncoderPostTreeBitcount;
}


//
// Fast encoder deflate function
//
void FastEncoderDeflate(
    t_encoder_context * context, 
    int                 search_depth, // # hash links to traverse
    int                 lazy_match_threshold, // don't search @ X+1 if match length @ X is > lazy
    int                 good_length, // divide traversal depth by 4 if match length > good
    int                 nice_length // in match finder, if we find >= nice_length match, quit immediately
)
{
    long            bufpos;
    unsigned int    hash;
    unsigned long   bitbuf;
    int             bitcount;
    BYTE *          output_curpos;
    t_fast_encoder *encoder = context->fast_encoder;
    byte *          window = encoder->window; // make local copies of context variables
    t_search_node * prev = encoder->prev;
    t_search_node * lookup = encoder->lookup;

    //
    // If this is the first time in here (since last reset) then we need to output our dynamic
    // block header
    //
    if (encoder->fOutputBlockHeader == FALSE)
    {
        encoder->fOutputBlockHeader = TRUE;

        //
        // Watch out!  Calls to outputBits() and outputTreeStructure() use the bit buffer 
        // variables stored in the context, not our local cached variables.
        //
        FastEncoderOutputPreamble(context);
    }

    //
    // Copy bitbuf vars into local variables since we're now using OUTPUT_BITS macro.
    // Do not call anything that uses the context structure's bit buffer variables!
    //
    output_curpos   = context->output_curpos;
    bitbuf          = context->bitbuf;
    bitcount        = context->bitcount;

    // copy bufpos into local variable
    bufpos = context->bufpos;

    VERIFY_HASHES(bufpos); // debug mode: verify that the hash table is correct

    // initialise the value of the hash
    // no problem if locations bufpos, bufpos+1 are invalid (not enough data), since we will 
    // never insert using that hash value
    hash = 0;
    UPDATE_HASH(hash, window[bufpos]);
    UPDATE_HASH(hash, window[bufpos+1]);

    // while we haven't come to the end of the input, and we still aren't close to the end
    // of the output
    while (bufpos < context->bufpos_end && output_curpos < context->output_near_end_threshold)
    {
        int             match_len;
        t_match_pos     match_pos;
        t_match_pos     search;

        VERIFY_HASHES(bufpos); // debugger: verify that hash table is correct

        if (context->bufpos_end - bufpos <= 3)
        {
            // The hash value becomes corrupt when we get within 3 characters of the end of the
            // input buffer, since the hash value is based on 3 characters.  We just stop
            // inserting into the hash table at this point, and allow no matches.
            match_len = 0;
        }
        else
        {
            // insert string into hash table and return most recent location of same hash value
            INSERT_STRING(search,bufpos);

            // did we find a recent location of this hash value?
            if (search != 0)
            {
                // yes, now find a match at what we'll call position X
                match_len = FastEncoderFindMatch(window, prev, bufpos, search, &match_pos, search_depth, nice_length);

                // truncate match if we're too close to the end of the input buffer
                if (bufpos + match_len > context->bufpos_end)
                    match_len = context->bufpos_end - bufpos;
            }
            else
            {
                // no most recent location found
                match_len = 0;
            }
        }

        if (match_len < MIN_MATCH)
        {
            // didn't find a match, so output unmatched char
            OUTPUT_CHAR(window[bufpos]);
            bufpos++;
        }
        else
        {
            // bufpos now points to X+1
            bufpos++;

            // is this match so good (long) that we should take it automatically without
            // checking X+1 ?
            if (match_len <= lazy_match_threshold)
            {
                int             next_match_len;
                t_match_pos     next_match_pos;

                // sets search
                INSERT_STRING(search,bufpos);

                // no, so check for a better match at X+1
                if (search != 0)
                {
                    next_match_len = FastEncoderFindMatch(
                        window,
                        prev,
                        bufpos, 
                        search,
                        &next_match_pos,
                        match_len < good_length ? search_depth : (search_depth >> 2),
                        nice_length
                    );
                
                    // truncate match if we're too close to the end of the buffer
                    // note: next_match_len could now be < MIN_MATCH
                    if (bufpos + next_match_len > context->bufpos_end)
                        next_match_len = context->bufpos_end - bufpos;
                }
                else
                {
                    next_match_len = 0;
                }

                // right now X and X+1 are both inserted into the search tree
                if (next_match_len > match_len)
                {
                    // since next_match_len > match_len, it can't be < MIN_MATCH here

                    // match at X+1 is better, so output unmatched char at X
                    OUTPUT_CHAR(window[bufpos-1]);

                    // now output match at location X+1
                    OUTPUT_MATCH(next_match_len, next_match_pos);

                    // insert remainder of second match into search tree
                    // 
                    // example: (*=inserted already)
                    //
                    // X      X+1               X+2      X+3     X+4
                    // *      *
                    //        nextmatchlen=3
                    //        bufpos
                    //
                    // If next_match_len == 3, we want to perform 2
                    // insertions (at X+2 and X+3).  However, first we must 
                    // inc bufpos.
                    //
                    bufpos++; // now points to X+2
                    match_len = next_match_len;
                    goto insert;
                }
                else
                {
                    // match at X is better, so take it
                    OUTPUT_MATCH(match_len, match_pos);

                    //
                    // Insert remainder of first match into search tree, minus the first
                    // two locations, which were inserted by the FindMatch() calls.
                    // 
                    // For example, if match_len == 3, then we've inserted at X and X+1
                    // already (and bufpos is now pointing at X+1), and now we need to insert 
                    // only at X+2.
                    //
                    match_len--;
                    bufpos++; // now bufpos points to X+2
                    goto insert;
                }
            }
            else /* match_length >= good_match */
            {
                // in assertion: bufpos points to X+1, location X inserted already
                    
                // first match is so good that we're not even going to check at X+1
                OUTPUT_MATCH(match_len, match_pos);

                // insert remainder of match at X into search tree
insert:
                if (context->bufpos_end - bufpos <= match_len)
                {
                    bufpos += (match_len-1);
                }
                else
                {
                    while (--match_len > 0)
                    {
                        t_match_pos ignore;

                        INSERT_STRING(ignore,bufpos);
                        bufpos++;
                    }
                }
            }
        }
    } /* end ... while (bufpos < bufpos_end) */

    // store local variables back in context
    context->bufpos = bufpos;
    context->bitbuf = bitbuf;
    context->bitcount = bitcount;
    context->output_curpos = output_curpos;

    VERIFY_HASHES(bufpos); // debugger: verify that hash table is correct

    if (bufpos == context->bufpos_end)
        context->state = STATE_NORMAL;
    else
        context->state = STATE_OUTPUTTING_BLOCK;

    // slide the window if bufpos has reached 2*window size
    if (context->bufpos == 2*FAST_ENCODER_WINDOW_SIZE)
        FastEncoderMoveWindows(context);
}


static void FastEncoderMoveWindows(t_encoder_context *context)
{
    t_search_node *lookup = context->fast_encoder->lookup;
    t_search_node *prev = context->fast_encoder->prev;
    BYTE *window = context->fast_encoder->window;
    int i;

    _ASSERT(context->bufpos == 2*FAST_ENCODER_WINDOW_SIZE);

    // verify that the hash table is correct
    VERIFY_HASHES(2*FAST_ENCODER_WINDOW_SIZE);

    memcpy(&window[0], &window[context->bufpos - FAST_ENCODER_WINDOW_SIZE], FAST_ENCODER_WINDOW_SIZE);

    // move all the hash pointers back
    // NOTE - We are incurring a performance penalty since lookup[] is a USHORT array.  Would be
    // nice to subtract from two locations at a time.
    for (i = 0; i < FAST_ENCODER_HASH_TABLE_SIZE; i++)
    {
        long val = ((long) lookup[i]) - FAST_ENCODER_WINDOW_SIZE;

        if (val <= 0) // too far away now? then set to zero
            lookup[i] = (t_search_node) 0;
        else
            lookup[i] = (t_search_node) val;
    }

    // prev[]'s are absolute pointers, not relative pointers, so we have to move them back too
    // making prev[]'s into relative pointers poses problems of its own
    for (i = 0; i < FAST_ENCODER_WINDOW_SIZE; i++)
    {
        long val = ((long) prev[i]) - FAST_ENCODER_WINDOW_SIZE;

        if (val <= 0)
            prev[i] = (t_search_node) 0;
        else
            prev[i] = (t_search_node) val;
    }

#ifdef FULL_DEBUG
    // For debugging, wipe the window clean, so that if there is a bug in our hashing,
    // the hash pointers will now point to locations which are not valid for the hash value
    // (and will be caught by our ASSERTs).
    memset(&window[FAST_ENCODER_WINDOW_SIZE], 0, FAST_ENCODER_WINDOW_SIZE);
#endif

    VERIFY_HASHES(2*FAST_ENCODER_WINDOW_SIZE); // debug: verify hash table is correct

    context->bufpos = FAST_ENCODER_WINDOW_SIZE;
    context->bufpos_end = context->bufpos;
}


//
// Find match
//
// Returns match length found.  A match length < MIN_MATCH means no match was found.
//
static int FastEncoderFindMatch(
    const BYTE *    window, // window array
    const USHORT *  prev,   // prev ptr array
    long            bufpos, // current buffer position
    long            search, // where to start searching
    t_match_pos *   match_pos, // return match position here
    int             cutoff, // # links to traverse
    int             nice_length // stop immediately if we find a match >= nice_length
)
{
    // make local copies of context variables
    long            earliest;
    int             best_match = 0; // best match length found so far
    t_match_pos     l_match_pos; // absolute match position of best match found
    BYTE            want_char;

    _ASSERT(bufpos >= 0 && bufpos < 2*FAST_ENCODER_WINDOW_SIZE);
    _ASSERT(search < bufpos);
    _ASSERT(FAST_ENCODER_RECALCULATE_HASH(search) == FAST_ENCODER_RECALCULATE_HASH(bufpos));

    // the earliest we can look
    earliest = bufpos - FAST_ENCODER_WINDOW_SIZE;
    _ASSERT(earliest >= 0);

    // store window[bufpos + best_match]
    want_char = window[bufpos];

    while (search > earliest)
    {
        // make sure all our hash links are valid
        _ASSERT(FAST_ENCODER_RECALCULATE_HASH(search) == FAST_ENCODER_RECALCULATE_HASH(bufpos));

        // Start by checking the character that would allow us to increase the match
        // length by one.  This improves performance quite a bit.
        if (window[search + best_match] == want_char)
        {
            int j;

            // Now make sure that all the other characters are correct
            for (j = 0; j < MAX_MATCH; j++)
            {
                if (window[bufpos+j] != window[search+j])
                    break;
            }
    
            if (j > best_match)
            {
                best_match  = j;
                l_match_pos = search; // absolute position

                if (j > nice_length)
                    break;

                want_char = window[bufpos+j];
            }
        }

        if (--cutoff == 0)
            break;

        // make sure we're always going backwards
        _ASSERT(prev[search & FAST_ENCODER_WINDOW_MASK] < search);

        search = (long) prev[search & FAST_ENCODER_WINDOW_MASK];
    }

    // doesn't necessarily mean we found a match; best_match could be > 0 and < MIN_MATCH
    *match_pos = bufpos - l_match_pos - 1; // convert absolute to relative position

    // don't allow match length 3's which are too far away to be worthwhile
    if (best_match == 3 && *match_pos >= FAST_ENCODER_MATCH3_DIST_THRESHOLD)
        return 0;

    _ASSERT(best_match < MIN_MATCH || *match_pos < FAST_ENCODER_WINDOW_SIZE);

    return best_match;
}


void FastEncoderReset(t_encoder_context *context)
{
    _ASSERT(context->fast_encoder != NULL);

    // zero hash table
    memset(context->fast_encoder->lookup, 0, sizeof(context->fast_encoder->lookup));

    context->window_size = FAST_ENCODER_WINDOW_SIZE;
    context->bufpos = FAST_ENCODER_WINDOW_SIZE;
    context->bufpos_end = context->bufpos;
    context->fast_encoder->fOutputBlockHeader = FALSE;
}


BOOL FastEncoderInit(t_encoder_context *context)
{
    context->fast_encoder = (t_fast_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_fast_encoder));

    if (context->fast_encoder == NULL)
        return FALSE;

    FastEncoderReset(context);
    return TRUE;
}


//
// Pregenerate the structure of the dynamic tree header which is output for
// the fast encoder.  Also record the final states of bitcount and bitbuf
// after outputting.
//
void FastEncoderGenerateDynamicTreeEncoding(void)
{
    t_encoder_context context;

    // Create a fake context with output pointers into our global data
    memset(&context, 0, sizeof(context));
    context.output_curpos = g_FastEncoderTreeStructureData;
    context.output_endpos = g_FastEncoderTreeStructureData + sizeof(g_FastEncoderTreeStructureData);
    context.output_near_end_threshold = context.output_endpos - 16;
    InitBitBuffer(&context);

    outputBits(&context, 1, 1); // "final" block flag
    outputBits(&context, 2, BLOCKTYPE_DYNAMIC);
   
    outputTreeStructure(
        &context,
        g_FastEncoderLiteralTreeLength, 
        g_FastEncoderDistanceTreeLength
    );

    g_FastEncoderTreeLength = (int)(context.output_curpos - (BYTE *) g_FastEncoderTreeStructureData);
    g_FastEncoderPostTreeBitbuf = context.bitbuf;
    g_FastEncoderPostTreeBitcount = context.bitcount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\gentable.c ===
//
// gentable.c
//
// Generates static Huffman tables to be included in the DLL
//
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//#define GENERATE_C_CODE_TABLES

#ifdef GENERATE_C_CODE_TABLES
//
// Generates outputting tables for the fast encoder.
// 
// The other encoders do things differently; they have separate arrays for
// code[], len[], and they then have to check extra_bits[] afterwards to see
// how many (if any) low order bits to output.
//
// The fast encoder, on the other hand, is lean and mean.
//
// For a set of literal codes and lengths, generate a set of DWORDs with 
// these properties:
//
// [ code ] [ code_length ] 
//  27 bits     5 bits       
//
// Where "len" is the # bits in the code, and "code" is the FULL code to output,
// including ALL necessary g_LengthExtraBits[].
//
// The bitwise outputter cannot handle codes more than 16 bits in length, so
// if this happens (quite rare) whoever is using this table must output
// the code in two instalments.  
//
void MakeFastEncoderLiteralTable(BYTE *len, USHORT *code)
{
    ULONG outcode[(NUM_CHARS+1+(MAX_MATCH-MIN_MATCH+1))];
    int elements_to_output;
    int i;
    int match_length;

    elements_to_output = (NUM_CHARS+1+(MAX_MATCH-MIN_MATCH+1));

    // literals and end of block code are output without much fanfare
    for (i = 0; i <= NUM_CHARS; i++)
    {
        outcode[i] = len[i] | (code[i] << 5);
    }

    // match lengths are more interesting
    for (match_length = 0; match_length <= (MAX_MATCH-MIN_MATCH); match_length++)
    {
        int length_slot = g_LengthLookup[match_length];
        int extra_bits = g_ExtraLengthBits[length_slot];
        ULONG orig_code;
        int orig_len;
        ULONG tbl_code;
        int tbl_len;

        orig_code = (ULONG) code[(NUM_CHARS+1)+length_slot];
        orig_len = len[(NUM_CHARS+1)+length_slot];

        if (extra_bits == 0)
        {
            // if no extra bits, it's quite simple
            tbl_code = orig_code;
            tbl_len = orig_len;
        }
        else
        {
            // get extra bits data
            int extra_bits_data = match_length & g_BitMask[extra_bits];

            // stick it in the code and increase the code length appropriately
            tbl_code = orig_code | (extra_bits_data << orig_len);
            tbl_len = orig_len + extra_bits;
        }

        _ASSERT(tbl_len <= 27);
        outcode[(NUM_CHARS+1)+match_length] = tbl_len | (tbl_code << 5);
    }

    printf("#ifdef DECLARE_DATA\n");

    printf("const ULONG g_FastEncoderLiteralCodeInfo[] = {\n");

    for (i = 0; i < elements_to_output; i++)
    {
        if ((i % 7) == 0)
            printf("\n");

        printf("0x%08x,", outcode[i]);
    }

    printf("\n};\n");

    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const ULONG g_FastEncoderLiteralCodeInfo[];\n");
    printf("#endif /* DECLARE_DATA */\n");

}


//
// The distance table is slightly different; obviously we cannot have an element
// for all 8192 possible distances.  Instead we merge the code[] and len[] arrays,
// and store extra_bits[] in there.
//
// [ code ]  [ # extra_bits ] [ len ]
//  24 bits      4 bits       4 bits
//
// The code part is always < 16 bits, since we aren't merging the actual extra 
// bits with it, unlike for the literals.
//
void MakeFastEncoderDistanceTable(BYTE *len, USHORT *code)
{
    ULONG outcode[MAX_DIST_TREE_ELEMENTS];
    int i;
    int pos_slot;

    for (pos_slot = 0; pos_slot < MAX_DIST_TREE_ELEMENTS; pos_slot++)
    {
        int extra_bits = g_ExtraDistanceBits[pos_slot];
        ULONG orig_code;
        int orig_len;

        orig_code = (ULONG) code[pos_slot];
        orig_len = len[pos_slot];

        outcode[pos_slot] = orig_len | (extra_bits << 4) | (orig_code << 8);
    }

    printf("#ifdef DECLARE_DATA\n");

    printf("const ULONG g_FastEncoderDistanceCodeInfo[] = {\n");

    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
    {
        if ((i % 7) == 0)
            printf("\n");

        printf("0x%08x,", outcode[i]);
    }

    printf("\n};\n");

    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const ULONG g_FastEncoderDistanceCodeInfo[];\n");
    printf("#endif /* DECLARE_DATA */\n");

}


void GenerateTable(char *table_name, int elements, BYTE *len, USHORT *code)
{
    int i;

    printf("#ifdef DECLARE_DATA\n");
    printf("const BYTE %sLength[] = {", table_name);

    for (i = 0; i < elements; i++)
    {
        if ((i % 16) == 0)
            printf("\n");

        printf("0x%02x,", len[i]);
    }

    printf("\n};\n");

    printf("const USHORT %sCode[] = {", table_name);

    for (i = 0; i < elements; i++)
    {
        if ((i % 8) == 0)
            printf("\n");

        printf("0x%04x,", code[i]);
    }

    printf("\n};\n");
    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const BYTE %sLength[];\n", table_name);
    printf("extern const USHORT %sCode[];\n", table_name);
    printf("#endif /* DECLARE_DATA */\n");

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infinit.c ===
//
// infinit.c
//
// Inflate initialisation
//
#include <crtdbg.h>
#include "inflate.h"
#include "maketbl.h"


//
// Generate global tables for decoding static blocks
//
static unsigned int bitReverse(unsigned int code, int len)
{
	unsigned int new_code = 0;

    _ASSERT(len > 0);

	do
	{
		new_code |= (code & 1);
		new_code <<= 1;
		code >>= 1;
	} while (--len > 0);

	return new_code >> 1;
}

#include <stdio.h>
static VOID CreateStaticDecodingTables(VOID)
{
    SHORT StaticDistanceTreeLeft[MAX_DIST_TREE_ELEMENTS*2]; // temporary: not exported
    SHORT StaticDistanceTreeRight[MAX_DIST_TREE_ELEMENTS*2]; // temporary: not exported

    SHORT StaticLiteralTreeLeft[MAX_LITERAL_TREE_ELEMENTS*2]; // temporary: not exported
    SHORT StaticLiteralTreeRight[MAX_LITERAL_TREE_ELEMENTS*2]; // temporary: not exported
    
    SHORT TempStaticDistanceTreeTable[STATIC_BLOCK_DISTANCE_TABLE_SIZE];
    BYTE  TempStaticDistanceTreeLength[MAX_DIST_TREE_ELEMENTS];

    int i;

    _ASSERT(STATIC_BLOCK_LITERAL_TABLE_BITS == 9);
    _ASSERT(STATIC_BLOCK_DISTANCE_TABLE_BITS == 5);

    // The Table[] and Left/Right arrays are for the decoder only
    // We don't output Left/Right because they are not used; everything
    // fits in the lookup table, since max code length is 9, and tablebits
    // > 9.
    makeTable(
		MAX_LITERAL_TREE_ELEMENTS,
		STATIC_BLOCK_LITERAL_TABLE_BITS,
		g_StaticLiteralTreeLength,
		g_StaticLiteralTreeTable,
		StaticLiteralTreeLeft,
		StaticLiteralTreeRight);

    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
        TempStaticDistanceTreeLength[i] = 5;

    makeTable(
		MAX_DIST_TREE_ELEMENTS,
		STATIC_BLOCK_DISTANCE_TABLE_BITS,
		TempStaticDistanceTreeLength,
		TempStaticDistanceTreeTable,
		StaticDistanceTreeLeft,
		StaticDistanceTreeRight);
    
    // Since all values are < 256, use a BYTE array
    for (i = 0; i < STATIC_BLOCK_DISTANCE_TABLE_SIZE; i++)
        g_StaticDistanceTreeTable[i] = TempStaticDistanceTreeTable[i];
}


VOID inflateInit(VOID)
{
    InitStaticBlock();
    CreateStaticDecodingTables();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infgzip.h ===
//
// infgzip.h
//
// Gzip additions to inflate
//

// decompressing
BOOL ReadGzipHeader(t_decoder_context *context);
BOOL ReadGzipFooter(t_decoder_context *context);
void DecoderInitGzipVariables(t_decoder_context *context);
ULONG GzipCRC32(ULONG crc, const BYTE *buf, ULONG len);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infdyna.c ===
//
// infdyna.c
//
// Decompress a dynamically compressed block
//
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"
#include "maketbl.h"


#define OUTPUT_EOF() (output_curpos >= context->end_output_buffer)

//
// This is the slow version, which worries about the input running out or the output
// running out.  The trick here is to not read any more bytes than we need to; theoretically
// the "end of block" code could be 1 bit, so we cannot always assume that it is ok to fill
// the bit buffer with 16 bits right before a table decode.
//
BOOL DecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;
    t_decoder_state old_state;
    BYTE            fCanTryFastEncoder = TRUE;

	*end_of_block_code_seen = FALSE;

	//
	// Store these variables locally for speed
	//
top:
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(bitcount >= -16);

    old_state = context->state;
    context->state = STATE_DECODE_TOP; // reset state

	switch (old_state)
	{
		case STATE_DECODE_TOP:
			break;

		case STATE_HAVE_INITIAL_LENGTH:
			length = context->length;
			goto reenter_state_have_initial_length;

		case STATE_HAVE_FULL_LENGTH:
			length = context->length;
			goto reenter_state_have_full_length;

		case STATE_HAVE_DIST_CODE:
			length = context->length;
			dist_code = context->dist_code;
			goto reenter_state_have_dist_code;

		case STATE_INTERRUPTED_MATCH:
			length = context->length;
			offset = context->offset;
			goto reenter_state_interrupted_match;

        default:
            _ASSERT(0); // error, invalid state!
	}

	do
	{
        //
        // The first time we're at the top of this loop, check whether we can use the
        // fast encoder; we will do this if the input and output buffers are nowhere
        // near the end, which allows the fast encoder to be a little more relaxed
        // about checking for these conditions
        //
        // If we cannot enter the fast encoder when we first check, then we will not
        // be able to enter it again while we're in this function (the amount of
        // input/output available is not going to get any larger), so don't check
        // again.
        //
        if (fCanTryFastEncoder)
        {
    		if (context->output_curpos + MAX_MATCH < context->end_output_buffer &&
	    		context->input_curpos + 12 < context->end_input_buffer)
    		{
	    		SAVE_BITBUF_VARS();
		    	context->output_curpos = output_curpos;
    			context->bufpos = bufpos;

    			if (FastDecodeDynamicBlock(context, end_of_block_code_seen) == FALSE)
	    			return FALSE;

    			if (*end_of_block_code_seen)
	    			return TRUE;

    			goto top;
	    	}
            else
            {
                // don't check again
                fCanTryFastEncoder = FALSE;
            }
        }

		//
		// decode an element from the main tree
		//

		// we must have at least 1 bit available
		_ASSERT(bitcount >= -16);

		if (bitcount == -16)
		{
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
		}

retry_decode_literal:

		// assert that at least 1 bit is present
		_ASSERT(bitcount > -16);

		// decode an element from the literal tree
		length = context->literal_table[bitbuf & LITERAL_TABLE_MASK]; 
		
		while (length < 0) 
		{ 
			unsigned long mask = 1 << LITERAL_TABLE_BITS; 
			do 
			{ 
				length = -length; 
				if ((bitbuf & mask) == 0) 
					length = context->literal_left[length]; 
				else 
					length = context->literal_right[length]; 
				mask <<= 1; 
			} while (length < 0); 
		}

		//
		// If this code is longer than the # bits we had in the bit buffer (i.e.
		// we read only part of the code - but enough to know that it's too long),
		// read more bits and retry
		//
		if (context->literal_tree_code_length[length] > (bitcount+16))
		{
			// if we run out of bits, break
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
			goto retry_decode_literal;		
		}

		DUMPBITS(context->literal_tree_code_length[length]);
		_ASSERT(bitcount >= -16);

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

reenter_state_have_initial_length:

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					// make sure we have this many bits in the bit buffer
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_INITIAL_LENGTH;
							context->length = length;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
						
						// extra_length_bits will be no more than 5, so we need to read at
						// most one byte of input to satisfy this request
					}

					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);
					_ASSERT(bitcount >= -16);
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
reenter_state_have_full_length:

			// we must have at least 1 bit available
			if (bitcount == -16)
			{
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 
			}


retry_decode_distance:

			// assert that at least 1 bit is present
			_ASSERT(bitcount > -16);

			dist_code = context->distance_table[bitbuf & DISTANCE_TABLE_MASK]; 
			
			while (dist_code < 0) 
			{ 
				unsigned long mask = 1 << DISTANCE_TABLE_BITS; 
			
				do 
				{ 
					dist_code = -dist_code; 
				
					if ((bitbuf & mask) == 0) 
						dist_code = context->distance_left[dist_code]; 
					else 
						dist_code = context->distance_right[dist_code]; 
					
					mask <<= 1; 
				} while (dist_code < 0); 
			}

			//
			// If this code is longer than the # bits we had in the bit buffer (i.e.
			// we read only part of the code - but enough to know that it's too long),
			// read more bits and retry
			//
			if (context->distance_tree_code_length[dist_code] > (bitcount+16))
			{
				// if we run out of bits, break
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 

				_ASSERT(bitcount >= -16);
				goto retry_decode_distance;		
			}


			DUMPBITS(context->distance_tree_code_length[dist_code]);

			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);

reenter_state_have_dist_code:

			_ASSERT(bitcount >= -16);

			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				// make sure we have this many bits in the bit buffer
				if (extra_bits > bitcount + 16)
				{
					// if we run out of bits, break
					if (input_ptr >= end_input_buffer)
					{
						context->state = STATE_HAVE_DIST_CODE;
						context->length = length;
						context->dist_code = dist_code;
						break;
					}

					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;
						
					// extra_length_bits can be > 8, so check again
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_DIST_CODE;
							context->length = length;
							context->dist_code = dist_code;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}

				offset = g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]); 

				DUMPBITS(extra_bits);
				_ASSERT(bitcount >= -16);
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
reenter_state_interrupted_match:

			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;

				if (--length == 0)
					break;

			} while (output_curpos < context->end_output_buffer);

			if (length > 0)
			{
				context->state = STATE_INTERRUPTED_MATCH;
				context->length = length;
				context->offset = offset;
				break;
			}
		}

		// it's "<=" because we end when we received the end-of-block code,
		// not when we fill up the output, however, this will catch cases
		// of corrupted data where there is no end-of-output code
	} while (output_curpos < context->end_output_buffer);

	_ASSERT(bitcount >= -16);

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}


//
// This is the fast version, which assumes that, at the top of the loop:
//
// 1. There are at least 12 bytes of input available at the top of the loop (so that we don't
// have to check input EOF several times in the middle of the loop)
//
// and
//
// 2. There are at least MAX_MATCH bytes of output available (so that we don't have to check
// for output EOF while we're copying matches)
//
// The state must also be STATE_DECODE_TOP on entering and exiting this function
//
BOOL FastDecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;

	*end_of_block_code_seen = FALSE;

	//
	// Store these variables locally for speed
	//
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(context->state == STATE_DECODE_TOP);
	_ASSERT(input_ptr + 12 < end_input_buffer);
	_ASSERT(output_curpos + MAX_MATCH < context->end_output_buffer);

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	do
	{
		//
		// decode an element from the main tree
		//

		// decode an element from the literal tree
		length = context->literal_table[bitbuf & LITERAL_TABLE_MASK]; 
		
		while (length < 0) 
		{ 
			unsigned long mask = 1 << LITERAL_TABLE_BITS; 
			do 
			{ 
				length = -length; 
				if ((bitbuf & mask) == 0) 
					length = context->literal_left[length]; 
				else 
					length = context->literal_right[length]; 
				mask <<= 1; 
			} while (length < 0); 
		}

		DUMPBITS(context->literal_tree_code_length[length]);

		if (bitcount <= 0)
		{
			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8;

			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;
			}
		}

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;

						if (bitcount <= 0)
						{
							bitbuf |= ((*input_ptr++) << (bitcount+16)); 
							bitcount += 8;
						}
					}
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
			dist_code = context->distance_table[bitbuf & DISTANCE_TABLE_MASK]; 
			
			while (dist_code < 0) 
			{ 
				unsigned long mask = 1 << DISTANCE_TABLE_BITS; 
			
				do 
				{ 
					dist_code = -dist_code; 
				
					if ((bitbuf & mask) == 0) 
						dist_code = context->distance_left[dist_code]; 
					else 
						dist_code = context->distance_right[dist_code]; 
					
					mask <<= 1; 
				} while (dist_code < 0); 
			}

			DUMPBITS(context->distance_tree_code_length[dist_code]);

			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;

				if (bitcount <= 0)
				{
					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;
				}
			}


			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);
			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				offset	= g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]);
                
				DUMPBITS(extra_bits);

				if (bitcount <= 0)
				{
					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;
			} while (--length != 0);
		}
	} while ((input_ptr + 12 < end_input_buffer) && (output_curpos + MAX_MATCH < context->end_output_buffer));

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infinput.c ===
//
// infinput.c
//
// Bitwise inputting for inflate (decompressor)
//
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"


void dumpBits(t_decoder_context *context, int n)
{
	context->bitbuf >>= n; 
	context->bitcount -= n; 
}


// retrieve n bits from the bit buffer, and dump them when done
// n can be up to 16
int getBits(t_decoder_context *context, int n)
{
	int result;

	context->bitcount -= n; 
	result = (context->bitbuf & g_BitMask[n]);
	context->bitbuf >>= n; 

	return result;
}


//
// Ensure that <num_bits> bits are in the bit buffer
//
// Returns FALSE if there are not and there was insufficient input to make this true
//
BOOL ensureBitsContext(t_decoder_context *context, int num_bits)
{
	if (context->bitcount + 16 < num_bits) 
	{ 
		if (INPUT_EOF())
			return FALSE;

		context->bitbuf |= ((*context->input_curpos++) << (context->bitcount+16)); 
		context->bitcount += 8; 
		
		if (context->bitcount + 16 < num_bits)
		{
			if (INPUT_EOF())
				return FALSE;

			context->bitbuf |= ((*context->input_curpos++) << (context->bitcount+16)); 
			context->bitcount += 8; 
		} 
	} 

	return TRUE;
}


// initialise the bit buffer
BOOL initBitBuffer(t_decoder_context *context) 
{
	if (context->input_curpos < context->end_input_buffer)
	{
		context->bitbuf = *context->input_curpos++;
		context->bitcount = -8;
		context->state = STATE_READING_BFINAL;
		return TRUE;
	}
	else
	{
		context->bitcount = -16;
		context->bitbuf = 0;
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infmacro.h ===
//
// infmacro.h
//

#define INPUT_EOF()	(context->input_curpos >= context->end_input_buffer)


// dump n bits from the bit buffer (n can be up to 16)
// in assertion: there must be at least n valid bits in the buffer
#define DUMPBITS(n) \
	bitbuf >>= n; \
	bitcount -= n; 


// return the next n bits in the bit buffer (n <= 16), then dump these bits
// in assertion: there must be at least n valid bits in the buffer
#define GETBITS(result, n) \
	bitcount -= n; \
	result = (bitbuf & g_BitMask[n]); \
	bitbuf >>= n; \


//
// Load bit buffer variables from context into local variables
//
#define LOAD_BITBUF_VARS() \
	bitbuf = context->bitbuf; \
	bitcount = context->bitcount; \
	input_ptr = context->input_curpos;


//
// Save bit buffer variables from local variables into context
//
#define SAVE_BITBUF_VARS() \
	context->bitbuf = bitbuf; \
	context->bitcount = bitcount; \
	context->input_curpos = input_ptr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\inflate.c ===
//
// inflate.c
//
// Decompressor
//
#include <crtdbg.h>
#include <stdio.h>
#include "inflate.h"
#include "infmacro.h"
#include "infgzip.h"
#include "maketbl.h"


//
// Local function prototypes
//
static BOOL decodeBlock(t_decoder_context *context);
static BOOL makeTables(t_decoder_context *context);


HRESULT WINAPI Decompress(
    PVOID               void_context,
    CONST BYTE *        input, 
    LONG                input_size,
    BYTE *              output, 
    LONG                output_size,
    PLONG               input_used,
    PLONG               output_used
)
{
    t_decoder_context *context = (t_decoder_context *) void_context;

    context->input_curpos       = input;
    context->end_input_buffer   = input + input_size;
    context->output_curpos      = output;
    context->end_output_buffer  = output + output_size;
    context->output_buffer      = output;

    //
    // Keep decoding blocks until the output fills up, we read all the input, or we enter
    // the "done" state
    //
    // Note that INPUT_EOF() is not a sufficient check for determining that all the input
    // has been used; there could be an additional block stored entirely in the bit buffer.
    // For this reason, if we're in the READING_BFINAL state (start of new block) after
    // calling decodeBlock(), don't quit the loop unless there is truly no input left in
    // the bit buffer.
    //
    while ( (context->output_curpos < context->end_output_buffer) && 
            (!INPUT_EOF()) && 
            (context->state != STATE_DONE && context->state != STATE_VERIFYING_GZIP_FOOTER)
          )
    {
retry:
        if (decodeBlock(context) == FALSE)
        {
            *input_used = 0;
            *output_used = 0;
            return E_FAIL;
        }

        // No more input bytes, but am starting a new block and there's at least one bit
        // in the bit buffer
        if (context->state == STATE_READING_BFINAL && INPUT_EOF() && context->bitcount > -16)
            goto retry;
    }

    *input_used  = (LONG)(context->input_curpos - input);
    *output_used = (LONG)(context->output_curpos - output);

    if (context->using_gzip)
    {
        // Calculate the crc32 of everything we just decompressed, and then, if our state
        // is STATE_DONE, verify the crc
        if (*output_used > 0)
        {
            context->gzip_crc32 = GzipCRC32(context->gzip_crc32, output, *output_used);
            context->gzip_output_stream_size += (*output_used);
        }

        if (context->state == STATE_VERIFYING_GZIP_FOOTER)
        {
            context->state = STATE_DONE;

            // Now do our crc/input size check
            if (context->gzip_crc32 != context->gzip_footer_crc32 ||
                context->gzip_output_stream_size != context->gzip_footer_output_stream_size)
            {
                *input_used = 0;
                *output_used = 0;
                return E_FAIL;
            }
        }
    }

    if (*input_used == 0 && *output_used == 0)
    {
        if (context->state == STATE_DONE)
            return S_FALSE; // End of compressed data
        else
            return E_FAIL; // Avoid infinite loops
    }
    else
    {
        return S_OK;
    }
}


//
// Returns TRUE for success, FALSE for an error of some kind (invalid data)
//
static BOOL decodeBlock(t_decoder_context *context)
{
    BOOL eob, result;

    if (context->state == STATE_DONE || context->state == STATE_VERIFYING_GZIP_FOOTER)
        return TRUE;

    if (context->using_gzip)
    {
        if (context->state == STATE_READING_GZIP_HEADER)
        {
            if (ReadGzipHeader(context) == FALSE)
                return FALSE;

            // If we're still reading the GZIP header it means we ran out of input
            if (context->state == STATE_READING_GZIP_HEADER)
                return TRUE;
        }

        if (context->state == STATE_START_READING_GZIP_FOOTER || context->state == STATE_READING_GZIP_FOOTER)
        {
            if (ReadGzipFooter(context) == FALSE)
                return FALSE;

            // Whether we ran out of input or not, return
            return TRUE;
        }
    }

    //
    // Do we need to fill our bit buffer?
    //
    // This will happen the very first time we call Decompress(), as well as after decoding
    // an uncompressed block
    //
    if (context->state == STATE_READING_BFINAL_NEED_TO_INIT_BITBUF)
    {
        //
        // If we didn't have enough bits to init, return
        //
        if (initBitBuffer(context) == FALSE)
            return TRUE;
    }

    //
    // Need to read bfinal bit
    //
    if (context->state == STATE_READING_BFINAL)
    {
        // Need 1 bit
        if (ensureBitsContext(context, 1) == FALSE)
            return TRUE;

        context->bfinal = getBits(context, 1);
        context->state = STATE_READING_BTYPE;
    }

    if (context->state == STATE_READING_BTYPE)
    {
        // Need 2 bits
        if (ensureBitsContext(context, 2) == FALSE)
            return TRUE;

        context->btype = getBits(context, 2);

        if (context->btype == BLOCKTYPE_DYNAMIC)
        {
            context->state = STATE_READING_NUM_LIT_CODES;
        }
        else if (context->btype == BLOCKTYPE_FIXED)
        {
            context->state = STATE_DECODE_TOP;
        }
        else if (context->btype == BLOCKTYPE_UNCOMPRESSED)
        {
            context->state = STATE_UNCOMPRESSED_ALIGNING;
        }
        else
        {
            // unsupported compression mode
            return FALSE;
        }
    }

    if (context->btype == BLOCKTYPE_DYNAMIC)
    {
        if (context->state < STATE_DECODE_TOP)
        {
            if (readDynamicBlockHeader(context) == FALSE)
                return FALSE;

            if (context->state == STATE_DECODE_TOP)
            {
                if (makeTables(context) == FALSE)
                    return FALSE; // bad tables
            }
        }

        result = DecodeDynamicBlock(context, &eob);

        if (eob)
            context->state = STATE_READING_BFINAL;
    }
    else if (context->btype == BLOCKTYPE_FIXED)
    {
        result = DecodeStaticBlock(context, &eob);

        if (eob)
            context->state = STATE_READING_BFINAL;
    }
    else if (context->btype == BLOCKTYPE_UNCOMPRESSED)
    {
        result = decodeUncompressedBlock(context, &eob);
    }
    else
    {
        //
        // Invalid block type
        //
        return FALSE;
    }

    //
    // If we reached the end of the block and the block we were decoding had
    // bfinal=1 (final block)
    //
    if (eob && context->bfinal)
    {
        if (context->using_gzip)
            context->state = STATE_START_READING_GZIP_FOOTER;
        else
            context->state = STATE_DONE;
    }

    return result;
}


//
// Will throw an exception if a corrupt table is detected
//
static BOOL makeTables(t_decoder_context *context) 
{
    if (makeTable(
        MAX_LITERAL_TREE_ELEMENTS,
        LITERAL_TABLE_BITS,
        context->literal_tree_code_length,
        context->literal_table,
        context->literal_left,
        context->literal_right) == FALSE)
        return FALSE;

    return makeTable(
        MAX_DIST_TREE_ELEMENTS,
        DISTANCE_TABLE_BITS,
        context->distance_tree_code_length,
        context->distance_table,
        context->distance_left,
        context->distance_right
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infproto.h ===
//
// infproto.h
//

// comninit.c
void InitStaticBlock(void);

// infinit.c
VOID inflateInit(VOID);

// inflate.c
BOOL ensureBitsContext(t_decoder_context *context, int num_bits);
int	 getBits(t_decoder_context *context, int n);
void dumpBits(t_decoder_context *context, int n);

// infuncmp.c
BOOL decodeUncompressedBlock(t_decoder_context *context, BOOL *end_of_block);

// inftree.c
BOOL readDynamicBlockHeader(t_decoder_context *context);

// infinput.c
void dumpBits(t_decoder_context *context, int n);
int getBits(t_decoder_context *context, int n);
BOOL ensureBitsContext(t_decoder_context *context, int num_bits);
BOOL initBitBuffer(t_decoder_context *context);

// infdyna.c
BOOL DecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen); 
BOOL FastDecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen);

// infstatic.c
BOOL DecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen);
BOOL FastDecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\inflate.h ===
#include "common.h"
#include "api_int.h"


// decoding tables for dynamic blocks
#define LITERAL_TABLE_BITS		9
#define LITERAL_TABLE_MASK		((1 << LITERAL_TABLE_BITS)-1)

#define DISTANCE_TABLE_BITS		7
#define DISTANCE_TABLE_MASK		((1 << DISTANCE_TABLE_BITS)-1)

#define PRETREE_TABLE_BITS		7
#define PRETREE_TABLE_MASK		((1 << PRETREE_TABLE_BITS)-1)


// decoding tables for static blocks
#define STATIC_BLOCK_LITERAL_TABLE_BITS		9
#define STATIC_BLOCK_LITERAL_TABLE_MASK		((1 << STATIC_BLOCK_LITERAL_TABLE_BITS)-1)
#define STATIC_BLOCK_LITERAL_TABLE_SIZE		(1 << STATIC_BLOCK_LITERAL_TABLE_BITS)

#define STATIC_BLOCK_DISTANCE_TABLE_BITS    5
#define STATIC_BLOCK_DISTANCE_TABLE_MASK	((1 << STATIC_BLOCK_DISTANCE_TABLE_BITS)-1)
#define STATIC_BLOCK_DISTANCE_TABLE_SIZE	(1 << STATIC_BLOCK_DISTANCE_TABLE_BITS)


//
// Various possible states
//
typedef enum
{
    STATE_READING_GZIP_HEADER, // Only applies to GZIP
	STATE_READING_BFINAL_NEED_TO_INIT_BITBUF, // Start of block, need to init bit buffer
	STATE_READING_BFINAL,				// About to read bfinal bit
	STATE_READING_BTYPE,				// About to read btype bits
	STATE_READING_NUM_LIT_CODES,		// About to read # literal codes
	STATE_READING_NUM_DIST_CODES,		// About to read # dist codes
	STATE_READING_NUM_CODE_LENGTH_CODES,// About to read # code length codes
	STATE_READING_CODE_LENGTH_CODES,	// In the middle of reading the code length codes
	STATE_READING_TREE_CODES_BEFORE,	// In the middle of reading tree codes (loop top)
	STATE_READING_TREE_CODES_AFTER,		// In the middle of reading tree codes (extension; code > 15)
	STATE_DECODE_TOP,					// About to decode a literal (char/match) in a compressed block
	STATE_HAVE_INITIAL_LENGTH,			// Decoding a match, have the literal code (base length)
	STATE_HAVE_FULL_LENGTH,				// Ditto, now have the full match length (incl. extra length bits)
	STATE_HAVE_DIST_CODE,				// Ditto, now have the distance code also, need extra dist bits
	STATE_INTERRUPTED_MATCH,			// In the middle of a match, but output buffer filled up

	/* uncompressed blocks */
	STATE_UNCOMPRESSED_ALIGNING,
	STATE_UNCOMPRESSED_1,
	STATE_UNCOMPRESSED_2,
	STATE_UNCOMPRESSED_3,
	STATE_UNCOMPRESSED_4,
	STATE_DECODING_UNCOMPRESSED,

    // These three apply only to GZIP
    STATE_START_READING_GZIP_FOOTER, // (Initialisation for reading footer)
    STATE_READING_GZIP_FOOTER, 
    STATE_VERIFYING_GZIP_FOOTER,

    STATE_DONE // Finished

} t_decoder_state;


typedef struct
{
	byte				window[WINDOW_SIZE];

	// output buffer
	byte *				output_curpos;		// current output pos
	byte *				end_output_buffer;	// ptr to end of output buffer
	byte *				output_buffer;		// ptr to start of output buffer

	// input buffer
	const byte *		input_curpos;		// current input pos
	const byte *		end_input_buffer;	// ptr to end of input buffer

	int					num_literal_codes;
	int					num_dist_codes;
	int					num_code_length_codes;
	int					temp_code_array_size;
	byte				temp_code_list[MAX_LITERAL_TREE_ELEMENTS + MAX_DIST_TREE_ELEMENTS];

	// is this the last block?
	int					bfinal;

	// type of current block
	int					btype;

	// state information
	t_decoder_state		state;
	long				state_loop_counter;
	byte				state_code;
    BOOL                using_gzip;

    // gzip-specific stuff
    byte                gzip_header_substate;
    byte                gzip_header_flag;
    byte                gzip_header_xlen1_byte; // first byte of XLEN
    unsigned int        gzip_header_xlen; // xlen (0...65535)
    unsigned int        gzip_header_loop_counter;

    byte                gzip_footer_substate;
    unsigned int        gzip_footer_loop_counter;
    unsigned long       gzip_footer_crc32; // what we're supposed to end up with
    unsigned long       gzip_footer_output_stream_size; // what we're supposed to end up with

    unsigned long       gzip_crc32; // running counter
    unsigned long       gzip_output_stream_size; // running counter
    // end of gzip-specific stuff

	int					length;
	int					dist_code;
	long				offset;

	// bit buffer and # bits available in buffer
	unsigned long		bitbuf;
	int					bitcount;

	// position in the window
	long				bufpos;

	// for decoding the uncompressed block header
	byte				unc_buffer[4];

	// bit lengths of tree codes
	byte				literal_tree_code_length[MAX_LITERAL_TREE_ELEMENTS];
	byte				distance_tree_code_length[MAX_DIST_TREE_ELEMENTS];
	byte				pretree_code_length[NUM_PRETREE_ELEMENTS];

	// tree decoding tables
	short				distance_table[1 << DISTANCE_TABLE_BITS];
	short				literal_table[1 << LITERAL_TABLE_BITS];

	short 				literal_left[MAX_LITERAL_TREE_ELEMENTS*2];
	short 				literal_right[MAX_LITERAL_TREE_ELEMENTS*2];

	short 				distance_left[MAX_DIST_TREE_ELEMENTS*2];
	short 				distance_right[MAX_DIST_TREE_ELEMENTS*2];

	short				pretree_table[1 << PRETREE_TABLE_BITS];
	short				pretree_left[NUM_PRETREE_ELEMENTS*2];
	short				pretree_right[NUM_PRETREE_ELEMENTS*2];

} t_decoder_context;


#include "infproto.h"

#include "infdata.h"
#include "comndata.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\maketbl.h ===
//
// maketbl.h
//
BOOL makeTable(
	int		num_elements, 
	int		table_bits, 
	const byte *code_length, 
	short *	table, 
	short *	left, 
	short *	right
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infstatic.c ===
//
// infstatic.c
//
// Decompress a static (fixed) compressed block
//
// This code was cloned from infdyna.c with the following changes:
// 1. Use global pre-initialised static tables
// 2. All distance prefixes are 5 bits, so don't look this up in a table
// 3. g_StaticDistanceTreeTable is a BYTE[] not a USHORT[]
// 4. Table lookup size for literals is 9 bits, for distances it is 5 bits
// 5. Due to #3 there is no table overflow, so there are no left/right arrays
// 6. When dumping 5 distance bits, no need to check for bitcount overflow twice
//
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"
#include "maketbl.h"


//
// Decoding table sizes; do not change!
//
// 9 is the largest code length for literals
// 5 is the largest code length for distances
//
// Therefore we don't need an overflow left/right table
//
#define STATIC_BLOCK_LITERAL_TABLE_BITS		9
#define STATIC_BLOCK_LITERAL_TABLE_MASK		((1 << STATIC_BLOCK_LITERAL_TABLE_BITS)-1)

#define STATIC_BLOCK_DISTANCE_TABLE_BITS	5
#define STATIC_BLOCK_DISTANCE_TABLE_MASK	((1 << STATIC_BLOCK_DISTANCE_TABLE_BITS)-1)


#define OUTPUT_EOF() (output_curpos >= context->end_output_buffer)

//
// This is the slow version, which worries about the input running out or the output
// running out.  The trick here is to not read any more bytes than we need to; theoretically
// the "end of block" code could be 1 bit, so we cannot always assume that it is ok to fill
// the bit buffer with 16 bits right before a table decode.
//
BOOL DecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;

	*end_of_block_code_seen = FALSE;

    //
	// Store these variables locally for speed
	//
top:
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(bitcount >= -16);

	//
	// Set the state to DECODE_TOP here
	//
	switch (context->state)
	{
		case STATE_DECODE_TOP:
			break;

		case STATE_HAVE_INITIAL_LENGTH:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			goto reenter_state_have_initial_length;

		case STATE_HAVE_FULL_LENGTH:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			goto reenter_state_have_full_length;

		case STATE_HAVE_DIST_CODE:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			dist_code = context->dist_code;
			goto reenter_state_have_dist_code;

		case STATE_INTERRUPTED_MATCH:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			offset = context->offset;
			goto reenter_state_interrupted_match;
	}

	do
	{
		if (context->output_curpos + MAX_MATCH < context->end_output_buffer &&
			context->input_curpos + 12 < context->end_input_buffer)
		{
			SAVE_BITBUF_VARS();
			context->output_curpos = output_curpos;
			context->bufpos = bufpos;

			if (FastDecodeStaticBlock(context, end_of_block_code_seen) == FALSE)
				return FALSE;

			if (*end_of_block_code_seen)
				return TRUE;

			goto top;
		}

		//
		// decode an element from the main tree
		//

		// we must have at least 1 bit available
		_ASSERT(bitcount >= -16);

		if (bitcount == -16)
		{
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
		}

retry_decode_literal:

		// assert that at least 1 bit is present
		_ASSERT(bitcount > -16);

		// decode an element from the literal tree
		length = g_StaticLiteralTreeTable[bitbuf & STATIC_BLOCK_LITERAL_TABLE_MASK]; 
		
		//
		// If this code is longer than the # bits we had in the bit buffer (i.e.
		// we read only part of the code - but enough to know that it's too long),
		// read more bits and retry
		//
		if (g_StaticLiteralTreeLength[length] > (bitcount+16))
		{
			// if we run out of bits, break
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
			goto retry_decode_literal;		
		}

		DUMPBITS(g_StaticLiteralTreeLength[length]);
		_ASSERT(bitcount >= -16);

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

reenter_state_have_initial_length:

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					// make sure we have this many bits in the bit buffer
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_INITIAL_LENGTH;
							context->length = length;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
						
						// extra_length_bits will be no more than 5, so we need to read at
						// most one byte of input to satisfy this request
					}

					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);
					_ASSERT(bitcount >= -16);
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
reenter_state_have_full_length:

			// we must have at least 1 bit available
			if (bitcount == -16)
			{
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 
			}


retry_decode_distance:

			// assert that at least 1 bit is present
			_ASSERT(bitcount > -16);

			dist_code = g_StaticDistanceTreeTable[bitbuf & STATIC_BLOCK_DISTANCE_TABLE_MASK]; 
			
			//
			// If this code is longer than the # bits we had in the bit buffer (i.e.
			// we read only part of the code - but enough to know that it's too long),
			// read more bits and retry
			//
            // g_StaticTreeDistanceLength[dist_code] == 5
            //
			if (5 > (bitcount+16))
			{
				// if we run out of bits, break
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 

				_ASSERT(bitcount >= -16);
				goto retry_decode_distance;		
			}


			DUMPBITS(5);

			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);

reenter_state_have_dist_code:

			_ASSERT(bitcount >= -16);

			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				// make sure we have this many bits in the bit buffer
				if (extra_bits > bitcount + 16)
				{
					// if we run out of bits, break
					if (input_ptr >= end_input_buffer)
					{
						context->state = STATE_HAVE_DIST_CODE;
						context->length = length;
						context->dist_code = dist_code;
						break;
					}

					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;
						
					// extra_length_bits can be > 8, so check again
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_DIST_CODE;
							context->length = length;
							context->dist_code = dist_code;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}

				offset = g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]); 

				DUMPBITS(extra_bits);
				_ASSERT(bitcount >= -16);
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
reenter_state_interrupted_match:

			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;

				if (--length == 0)
					break;

			} while (output_curpos < context->end_output_buffer);

			if (length > 0)
			{
				context->state = STATE_INTERRUPTED_MATCH;
				context->length = length;
				context->offset = offset;
				break;
			}
		}

		// it's "<=" because we end when we received the end-of-block code,
		// not when we fill up the output, however, this will catch cases
		// of corrupted data where there is no end-of-output code
	} while (output_curpos < context->end_output_buffer);

	_ASSERT(bitcount >= -16);

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}


//
// This is the fast version, which assumes that, at the top of the loop:
//
// 1. There are at least 12 bytes of input available at the top of the loop (so that we don't
// have to check input EOF several times in the middle of the loop)
//
// and
//
// 2. There are at least MAX_MATCH bytes of output available (so that we don't have to check
// for output EOF while we're copying matches)
//
// The state must also be STATE_DECODE_TOP on entering and exiting this function
//
BOOL FastDecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;

	*end_of_block_code_seen = FALSE;

	//
	// Store these variables locally for speed
	//
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(context->state == STATE_DECODE_TOP);
	_ASSERT(input_ptr + 12 < end_input_buffer);
	_ASSERT(output_curpos + MAX_MATCH < context->end_output_buffer);

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	do
	{
		//
		// decode an element from the main tree
		//

		// decode an element from the literal tree
		length = g_StaticLiteralTreeTable[bitbuf & STATIC_BLOCK_LITERAL_TABLE_MASK]; 
		
		DUMPBITS(g_StaticLiteralTreeLength[length]);

		if (bitcount <= 0)
		{
			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8;

			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;
			}
		}

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;

						if (bitcount <= 0)
						{
							bitbuf |= ((*input_ptr++) << (bitcount+16)); 
							bitcount += 8;
						}
					}
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
			dist_code = g_StaticDistanceTreeTable[bitbuf & STATIC_BLOCK_DISTANCE_TABLE_MASK]; 
			DUMPBITS(5);

            // unlike dynamic block, don't need to do this twice
			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;
			}


			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);
			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				offset	= g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]);
                
				DUMPBITS(extra_bits);

				if (bitcount <= 0)
				{
					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;
			} while (--length != 0);
		}
	} while ((input_ptr + 12 < end_input_buffer) && (output_curpos + MAX_MATCH < context->end_output_buffer));

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\inftree.c ===
//
// inftree.c
//
// Reads the tree for a dynamic block
//
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"
#include "maketbl.h"


//
// Decode an element from the pre-tree
//
static int decodePretreeElement(t_decoder_context *context)
{
    int element;
        
    element = context->pretree_table[context->bitbuf & PRETREE_TABLE_MASK];

    while (element < 0)
    {
        unsigned long mask = 1 << PRETREE_TABLE_BITS;

        do
        {
            element = -element;

            if ((context->bitbuf & mask) == 0)
                element = context->pretree_left[element];
            else
                element = context->pretree_right[element];

            mask <<= 1;
        } while (element < 0);
    }

    dumpBits(context, context->pretree_code_length[element]);

    return element;
}



//
// Dilemma: 
// 
// This code runs slowly because bitcount and bitbuf are accessed through the context,
// not as local variables.  However, if they were made into local variables, the code
// size would be massively increased.  Luckily the speed of this code isn't so important
// compared to that of decodeCompressedBlock().
//          
BOOL readDynamicBlockHeader(t_decoder_context *context)
{
    int     i;
    byte    code;

#define NUM_CODE_LENGTH_ORDER_CODES (sizeof(g_CodeOrder)/sizeof(g_CodeOrder[0]))
    // make sure extern g_CodeOrder[] declared with array size!

    switch (context->state)
    {
        case STATE_READING_NUM_LIT_CODES:
            goto reenter_state_reading_num_lit_codes;

        case STATE_READING_NUM_DIST_CODES:
            goto reenter_state_reading_num_dist_codes;

        case STATE_READING_NUM_CODE_LENGTH_CODES:
            goto reenter_state_reading_num_code_length_codes;

        case STATE_READING_CODE_LENGTH_CODES:
        {
            i = context->state_loop_counter;
            goto reenter_state_reading_code_length_codes;
        }

        case STATE_READING_TREE_CODES_BEFORE:
        {
            i = context->state_loop_counter;
            goto reenter_state_reading_tree_codes_before;
        }

        case STATE_READING_TREE_CODES_AFTER:
        {
            i = context->state_loop_counter;
            code = context->state_code;
            goto reenter_state_reading_tree_codes_after;
        }

        default:
            return TRUE;
    }


reenter_state_reading_num_lit_codes:

    if (ensureBitsContext(context, 5) == FALSE)
    {
        context->state = STATE_READING_NUM_LIT_CODES;
        return TRUE;
    }

    context->num_literal_codes      = getBits(context, 5) + 257;



reenter_state_reading_num_dist_codes:

    if (ensureBitsContext(context, 5) == FALSE)
    {
        context->state = STATE_READING_NUM_DIST_CODES;
        return TRUE;
    }

    context->num_dist_codes         = getBits(context, 5) + 1;



reenter_state_reading_num_code_length_codes:

    if (ensureBitsContext(context, 4) == FALSE)
    {
        context->state = STATE_READING_NUM_CODE_LENGTH_CODES;
        return TRUE;
    }

    context->num_code_length_codes  = getBits(context, 4) + 4;



    for (i = 0; i < context->num_code_length_codes; i++)
    {

reenter_state_reading_code_length_codes:

        if (ensureBitsContext(context, 3) == FALSE)
        {
            context->state = STATE_READING_CODE_LENGTH_CODES;
            context->state_loop_counter = i;
            return TRUE;
        }

        context->pretree_code_length[ g_CodeOrder[i] ] = (byte) getBits(context, 3);
    }

    for (i = context->num_code_length_codes; i < NUM_CODE_LENGTH_ORDER_CODES; i++)
        context->pretree_code_length[ g_CodeOrder[i] ] = 0;

    if (makeTable(
        NUM_PRETREE_ELEMENTS,
        PRETREE_TABLE_BITS,
        context->pretree_code_length,
        context->pretree_table,
        context->pretree_left,
        context->pretree_right
    ) == FALSE)
    {
        return FALSE;
    }

    context->temp_code_array_size = context->num_literal_codes + context->num_dist_codes;


    for (i = 0; i < context->temp_code_array_size; )
    {

reenter_state_reading_tree_codes_before:

        if (ensureBitsContext(context, 16) == FALSE)
        {
            context->state = STATE_READING_TREE_CODES_BEFORE;
            context->state_loop_counter = i;
            return TRUE;
        }

        code = (byte)decodePretreeElement(context);

reenter_state_reading_tree_codes_after:

        if (code <= 15)
        {
            context->temp_code_list[i++] = code;
        }
        else
        {
            int     repeat_count, j;

            //
            // If the code is > 15 it means there is a repeat count of 2, 3, or 7 bits
            //
            if (ensureBitsContext(context, 7) == FALSE)
            {
                context->state = STATE_READING_TREE_CODES_AFTER;
                context->state_code = code;
                context->state_loop_counter = i;
                return TRUE;
            }

            if (code == 16)
            {
                byte prev_code;

                // can't have "prev code" on first code
                if (i == 0)
                    return FALSE;

                prev_code = context->temp_code_list[i-1];

                repeat_count = getBits(context, 2) + 3;

                if (i + repeat_count > context->temp_code_array_size)
                    return FALSE;

                for (j = 0; j < repeat_count; j++)
                    context->temp_code_list[i++] = prev_code;
            }
            else if (code == 17)
            {
                repeat_count = getBits(context, 3) + 3;

                if (i + repeat_count > context->temp_code_array_size)
                    return FALSE;

                for (j = 0; j < repeat_count; j++)
                    context->temp_code_list[i++] = 0;
            }
            else // code == 18
            {
                repeat_count = getBits(context, 7) + 11;

                if (i + repeat_count > context->temp_code_array_size)
                    return FALSE;

                for (j = 0; j < repeat_count; j++)
                    context->temp_code_list[i++] = 0;
            }
        }
    }

    //
    // Create literal and distance tables
    //
    memcpy(context->literal_tree_code_length, context->temp_code_list, context->num_literal_codes);

    for (i = context->num_literal_codes; i < MAX_LITERAL_TREE_ELEMENTS; i++)
        context->literal_tree_code_length[i] = 0;

    for (i = 0; i < context->num_dist_codes; i++)
        context->distance_tree_code_length[i] = context->temp_code_list[i + context->num_literal_codes];

    for (i = context->num_dist_codes; i < MAX_DIST_TREE_ELEMENTS; i++)
        context->distance_tree_code_length[i] = 0;

    //
    // Make sure there is an end-of-block code, otherwise how could we ever end?
    //
    if (context->literal_tree_code_length[END_OF_BLOCK_CODE] == 0)
        return FALSE;

    context->state = STATE_DECODE_TOP;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\infuncmp.c ===
//
// infuncmp.c
//
// Decodes uncompressed blocks
//
#include "inflate.h"
#include "infmacro.h"


//
// Returns whether there are >= n valid bits in the bit buffer
//
#define ASSERT_BITS_IN_BIT_BUFFER(n) (context->bitcount + 16 >= (n))


static int twoBytesToInt(byte a, byte b)
{
	return (((int) a) & 255) | ((((int) b) & 255) << 8);
}


static void dumpBits(t_decoder_context *context, int n)
{
	context->bitbuf >>= n; 
	context->bitcount -= n; 
}


// retrieve n bits from the bit buffer, and dump them when done
// n can be up to 16
static int getBits(t_decoder_context *context, int n)
{
	int result;

	context->bitcount -= n; 
	result = (context->bitbuf & g_BitMask[n]);
	context->bitbuf >>= n; 

	return result;
}


BOOL decodeUncompressedBlock(t_decoder_context *context, BOOL *end_of_block)
{
	unsigned int unc_len, complement;

	*end_of_block = FALSE;

	if (context->state == STATE_DECODING_UNCOMPRESSED)
	{
		unc_len = context->state_loop_counter;
	}
	else
	{
		int i;

		if (context->state == STATE_UNCOMPRESSED_ALIGNING)
		{
			// 
			// Right now we have between 0 and 32 bits in bitbuf
			//
			// However, we must flush to a byte boundary
			//
			if ((context->bitcount & 7) != 0)
			{
				int result;

				result = getBits(context, (context->bitcount & 7));

				//
				// Since this is supposed to be padding, we should read all zeroes,
				// however, it's not really specified in the spec that they have to
				// be zeroes, so don't count this as an error
				//
			}

			//
			// Now we have exactly 0, 8, 16, 24, or 32 bits in the bit buffer
			//
			context->state = STATE_UNCOMPRESSED_1;
		}

		//
		// Now we need to read 4 bytes from the input - however, some of these bytes may
		// be inside our bit buffer, so take them from there first
		//
		for (i = 0; i < 4; i++)
		{
			if (context->state == STATE_UNCOMPRESSED_1 + i)
			{
				if (ASSERT_BITS_IN_BIT_BUFFER(8))
				{
					context->unc_buffer[i] = (byte) ((context->bitbuf) & 255);
					context->bitbuf >>= 8;
					context->bitcount -= 8;
				}
				else
				{
					if (INPUT_EOF())
						return TRUE;

					context->unc_buffer[i] = *context->input_curpos++;
				}

				context->state++;
			}
		}

		unc_len = twoBytesToInt(
			context->unc_buffer[0], context->unc_buffer[1]
		);

		complement = twoBytesToInt(
			context->unc_buffer[2], context->unc_buffer[3]
		);

		// make sure complement matches
		if ((unsigned short) unc_len != (unsigned short) (~complement))
			return FALSE; // error!
	}

	while (unc_len > 0 && context->input_curpos < context->end_input_buffer && context->output_curpos < context->end_output_buffer)
	{
		unc_len--;
		*context->output_curpos++ = context->window[context->bufpos++] = *context->input_curpos++;
		context->bufpos &= WINDOW_MASK;
	}

	//
	// More bytes left to compress in this block?
	//
	if (unc_len != 0)
	{
		context->state = STATE_DECODING_UNCOMPRESSED;
		context->state_loop_counter = unc_len;
	}
	else
	{
		//
		// Done with this block, need to re-init bit buffer for next block
		//
		context->state = STATE_READING_BFINAL_NEED_TO_INIT_BITBUF;
		*end_of_block = TRUE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optenc.c ===
/*
 * optenc.c
 *
 * Optimal encoder
 *
 * Can improve compression by using the "redo" method of LZX; after the first 32K bytes,
 * reset the compressor but keep the tables, and start over.
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//
// If we get a match this good, take it automatically
//
// Note: FAST_DECISION_THRESHOLD can be set to anything; it's been set to BREAK_LENGTH
//       arbitrarily
//
#define FAST_DECISION_THRESHOLD BREAK_LENGTH


//
// After we have this many literals, create a tree to get updated statistical estimates
//
#define FIRST_TREE_UPDATE 1024


//
// Verifies that all of the hash pointers in the hash table are correct, and that
// the tree structure is valid.
//
//#define DISABLE_VERIFY_HASHES

#ifdef _DEBUG
#ifndef DISABLE_VERIFY_HASHES
#define VERIFY_HASHES(bufpos) OptimalEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif
#else
#define VERIFY_HASHES(bufpos) ;
#endif


#define CHECK_FLUSH_RECORDING_BUFFER() \
	if (recording_bitcount >= 16) \
	{ \
		*recording_bufptr++ = (BYTE) recording_bitbuf; \
		*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); \
		recording_bitbuf >>= 16; \
		recording_bitcount -= 16; \
	}


#define OUTPUT_RECORDING_DATA(count,data) \
	recording_bitbuf |= ((data) << recording_bitcount); \
	recording_bitcount += (count);


//
// Record unmatched symbol c
//
#define RECORD_CHAR(c) \
    context->outputting_block_num_literals++; \
    encoder->literal_tree_freq[c]++; \
	_ASSERT(encoder->recording_literal_tree_len[c] != 0); \
	OUTPUT_RECORDING_DATA(encoder->recording_literal_tree_len[c], encoder->recording_literal_tree_code[c]); \
	CHECK_FLUSH_RECORDING_BUFFER();


//
// Record a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
#define RECORD_MATCH(match_len, match_pos) \
{ \
	int pos_slot = POS_SLOT(match_pos); \
	int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
	int item = (NUM_CHARS+1) + len_slot; \
	int extra_dist_bits = g_ExtraDistanceBits[pos_slot]; \
	int extra_len_bits = g_ExtraLengthBits[len_slot]; \
	_ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
	_ASSERT(context->outputting_block_num_literals >= 0 && context->outputting_block_num_literals < OPT_ENCODER_MAX_ITEMS); \
	_ASSERT(encoder->recording_literal_tree_len[item] != 0); \
	_ASSERT(encoder->recording_dist_tree_len[pos_slot] != 0); \
    context->outputting_block_num_literals++; \
    encoder->literal_tree_freq[(NUM_CHARS + 1) + len_slot]++; \
    encoder->dist_tree_freq[pos_slot]++; \
	OUTPUT_RECORDING_DATA(encoder->recording_literal_tree_len[item], encoder->recording_literal_tree_code[item]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_len_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_len_bits, (match_len-MIN_MATCH) & ((1 << extra_len_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
	OUTPUT_RECORDING_DATA(encoder->recording_dist_tree_len[pos_slot], encoder->recording_dist_tree_code[pos_slot]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_dist_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_dist_bits, match_pos & ((1 << extra_dist_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
}


#define FLUSH_RECORDING_BITBUF() \
    *recording_bufptr++ = (BYTE) recording_bitbuf; \
	*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); 


static void calculateUpdatedEstimates(t_encoder_context *context);
static void OptimalEncoderMoveWindows(t_encoder_context *context);


static int match_est(t_optimal_encoder *encoder, int match_length, unsigned int match_pos)
{
	int dist_slot;
	int len_slot;

	// output match position
	len_slot = g_LengthLookup[match_length-MIN_MATCH];
	dist_slot = POS_SLOT(match_pos);

	return	encoder->literal_tree_len[NUM_CHARS + 1 + len_slot] +
			g_ExtraLengthBits[len_slot] +
			encoder->dist_tree_len[dist_slot] + 
			g_ExtraDistanceBits[dist_slot];
}


//
// Create initial estimations to output each element
//
static void initOptimalEstimates(t_encoder_context *context)
{
	int i, p;
    t_optimal_encoder *encoder = context->optimal_encoder;

	for (i = 0; i < NUM_CHARS; i++)
		encoder->literal_tree_len[i] = 8;

	p = NUM_CHARS+1;
	encoder->literal_tree_len[p] = 3;
	encoder->literal_tree_len[p+1] = 4;
	encoder->literal_tree_len[p+2] = 5;

	for (; p < MAX_LITERAL_TREE_ELEMENTS; p++)
		encoder->literal_tree_len[p] = 6;

	for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
		encoder->dist_tree_len[i] = (i/2)+1;
}


//
// Fix optimal estimates; if bitlen == 0 it doesn't mean that the element takes 0
// bits to output, it means that the element didn't occur, so come up with some estimate.
//
static void fixOptimalEstimates(t_encoder_context *context)
{
	int i;
    t_optimal_encoder *encoder = context->optimal_encoder;

	for (i = 0; i < NUM_CHARS; i++)
	{
		if (encoder->literal_tree_len[i] == 0)
			encoder->literal_tree_len[i] = 13;
	}

	for (i = NUM_CHARS+1; i < MAX_LITERAL_TREE_ELEMENTS; i++)
	{
		if (encoder->literal_tree_len[i] == 0)
			encoder->literal_tree_len[i] = 12;
	}

	for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
	{
		if (encoder->dist_tree_len[i] == 0)
			encoder->dist_tree_len[i] = 10;
	}
}


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (encoder->literal_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 */
#define MATCH_EST(ml,mp,result) result = match_est(encoder, ml,mp);


//
// Returns whether the literal buffers are just about full
//
// Since we could output a large number of matches/chars in between these checks, we
// have to be careful.
//
//        should check after each item output, so we don't have to be so careful; this
//        means we will utilise more of the recording buffer
//
#define LITERAL_BUFFERS_FULL() \
    (context->outputting_block_num_literals >= OPT_ENCODER_MAX_ITEMS-4-LOOK-MAX_MATCH || \
            recording_bufptr + 3*(MAX_MATCH + LOOK) >= end_recording_bufptr)


void OptimalEncoderDeflate(t_encoder_context *context)
{
	unsigned long	bufpos_end;
	unsigned long	MatchPos;
	unsigned long	i;
	int				EncMatchLength; /* must be a signed number */
	unsigned long	bufpos;
	unsigned long	recording_bitbuf;
	int				recording_bitcount;
	byte *			recording_bufptr;
    byte *          end_recording_bufptr;
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);
	_ASSERT(context->state == STATE_NORMAL);

	// reinsert the up to BREAK_LENGTH nodes we removed the last time we exit this function
	VERIFY_HASHES(context->bufpos);
	reinsertRemovedNodes(context);
	VERIFY_HASHES(context->bufpos);

	// restore literal/match bitmap variables
    end_recording_bufptr = &encoder->lit_dist_buffer[OPT_ENCODER_LIT_DIST_BUFFER_SIZE-8];
	recording_bufptr = encoder->recording_bufptr;
    recording_bitbuf = encoder->recording_bitbuf;
    recording_bitcount = encoder->recording_bitcount;

    bufpos			= context->bufpos;
	bufpos_end		= context->bufpos_end;

    _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);

	/*
	 * While we haven't reached the end of the data
	 */
after_output_block:

    _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);

	while (bufpos < bufpos_end)
	{
		// time to update our stats?
		if (context->outputting_block_num_literals >= encoder->next_tree_update)
		{
			encoder->next_tree_update += 1024;

            calculateUpdatedEstimates(context);
			fixOptimalEstimates(context);
		}

		// literal buffer or distance buffer filled up (or close to filling up)?
		if (LITERAL_BUFFERS_FULL())
			break;

		/*
		 * Search for matches of all different possible lengths, at bufpos
		 */
		EncMatchLength = optimal_find_match(context, bufpos); 

		if (EncMatchLength < MIN_MATCH)
		{

output_literal:
			/*
			 * No match longer than 1 character exists in the history 
			 * window, so output the character at bufpos as a symbol.
			 */
			RECORD_CHAR(encoder->window[bufpos]);
			bufpos++;
			continue;
		}

		/*
		 * Found a match.
		 *
		 * Make sure it cannot exceed the end of the buffer.
		 */
		if ((unsigned long) EncMatchLength + bufpos > bufpos_end)
		{
			EncMatchLength = bufpos_end - bufpos;    

			/*
			 * Oops, not enough for even a small match, so we 
			 * have to output a literal
			 */
			if (EncMatchLength < MIN_MATCH)
				goto output_literal;
		}

		if (EncMatchLength < FAST_DECISION_THRESHOLD)
		{
			/*
			 *  A match has been found that is between MIN_MATCH and 
			 *  FAST_DECISION_THRESHOLD bytes in length.  The following 
			 *  algorithm is the optimal encoder that will determine the 
			 *  most efficient order of matches and unmatched characters 
			 *  over a span area defined by LOOK.  
			 *
			 *  The code is essentially a shortest path determination 
			 *  algorithm.  A stream of data can be encoded in a vast number 
			 *  of different ways depending on the match lengths and offsets
			 *  chosen.  The key to good compression ratios is to chose the 
			 *  least expensive path.
			 */
			unsigned long	span;
			unsigned long	epos, bpos, NextPrevPos, MatchPos;
			t_decision_node *decision_node_ptr;
			t_decision_node *context_decision_node = encoder->decision_node;
			t_match_pos *matchpos_table = encoder->matchpos_table;
			long		iterations;

			/*
			 * Points to the end of the area covered by this match; the span
			 * will continually be extended whenever we find more matches
			 * later on.  It will stop being extended when we reach a spot
			 * where there are no matches, which is when we decide which
			 * path to take to output the matches.
			 */
			span = bufpos + EncMatchLength;

			/*
			 * The furthest position into which we will do our lookahead parsing 
			 */
			epos = bufpos + LOOK;

			/*
			 * Temporary bufpos variable
			 */
			bpos = bufpos;

			/* 
			 * Calculate the path to the next character if we output
			 * an unmatched symbol.
			 */

			/* bits required to get here */
			context_decision_node[1].numbits = CHAR_EST(encoder->window[bufpos]);
				
			/* where we came from */
			context_decision_node[1].path    = bufpos;

			/* bits required to get here */
			context_decision_node[2].numbits = CHAR_EST(encoder->window[bufpos+1]) + context_decision_node[1].numbits;
				
			/* where we came from */
			context_decision_node[2].path    = bufpos+1;

			/*
			 * For the match found, estimate the cost of encoding the match
			 * for each possible match length, shortest offset combination.
			 *
			 * The cost, path and offset is stored at bufpos + Length.  
			 */
			for (i = MIN_MATCH; i <= (unsigned long) EncMatchLength; i++)
			{
				/*
				 * Get estimation of match cost given match length = i,
				 * match position = matchpos_table[i], and store
				 * the result in numbits[i]
				 */
				MATCH_EST(i, matchpos_table[i], context_decision_node[i].numbits);

				/*
				 * Where we came from 
				 */
				context_decision_node[i].path = bufpos;

				/*
				 * Associated match position with this path
				 */
				context_decision_node[i].link = matchpos_table[i];
			}

			/*
			 * Set bit counter to zero at the start 
			 */
			context_decision_node[0].numbits = 0;

			decision_node_ptr = &context_decision_node[-(long) bpos];

			while (1)
			{
				numbits_t est, cum_numbits;

				bufpos++;
	
				/* 
				 *  Set the proper repeated offset locations depending on the
				 *  shortest path to the location prior to searching for a 
				 *  match.
				 */

				/*
				 * The following is one of the two possible break points from
				 * the inner encoding loop.  This break will exit the loop if 
				 * a point is reached that no match can incorporate; i.e. a
				 * character that does not match back to anything is a point 
				 * where all possible paths will converge and the longest one
				 * can be chosen.
				 */
				if (span == bufpos)
					break;
					
				/*
				 * Search for matches at bufpos 
				 */
				EncMatchLength = optimal_find_match(context, bufpos); 

				/* 
				 * Make sure that the match does not exceed the stop point
				 */
				if ((unsigned long) EncMatchLength + bufpos > bufpos_end)
				{
					EncMatchLength = bufpos_end - bufpos; 
					
					if (EncMatchLength < MIN_MATCH)
						EncMatchLength = 0;
				}

				/*
				 * If the match is very long or it exceeds epos (either 
				 * surpassing the LOOK area, or exceeding past the end of the
				 * input buffer), then break the loop and output the path.
				 */
				if (EncMatchLength > FAST_DECISION_THRESHOLD || 
					bufpos + (unsigned long) EncMatchLength >= epos)
				{
					MatchPos = matchpos_table[EncMatchLength];

					decision_node_ptr[bufpos+EncMatchLength].link = MatchPos;
					decision_node_ptr[bufpos+EncMatchLength].path = bufpos;

					/*
					 * Quickly insert data into the search tree without
					 * returning match positions/lengths
					 */
#ifndef INSERT_NEAR_LONG_MATCHES
					if (MatchPos == 3 && EncMatchLength > 16)
					{
						/*
						 * If we found a match 1 character away and it's
						 * length 16 or more, it's probably a string of
						 * zeroes, so don't insert that into the search
						 * engine, since doing so can slow things down
						 * significantly!
						 */
						optimal_insert(
							context,
                               bufpos + 1,
                               bufpos - WINDOW_SIZE + 2
                           );
					}
					else
#endif
					{
						for (i = 1; i < (unsigned long) EncMatchLength; i++)
							optimal_insert(
								context,
                                   bufpos + i,
                                   bufpos + i - WINDOW_SIZE + 4
                                );
					}

					bufpos += EncMatchLength;
					break;
				}


				/*
				 * The following code will extend the area spanned by the 
				 * set of matches if the current match surpasses the end of
				 * the span.  A match of length two that is far is not 
				 * accepted, since it would normally be encoded as characters,
				 * thus allowing the paths to converge.
				 */
				if (EncMatchLength >= 3)
				{
					if (span < (unsigned long) (bufpos + EncMatchLength))
					{
						long end;
						long i;

						end = min(bufpos+EncMatchLength-bpos, LOOK-1);

						/*
						 * These new positions are undefined for now, since we haven't
						 * gone there yet, so put in the costliest value
						 */
						for (i = span-bpos+1; i <= end; i++)
							context_decision_node[i].numbits = (numbits_t) -1;

						span = bufpos + EncMatchLength;
					}
				}

				/*
				 *  The following code will iterate through all combinations
				 *  of match lengths for the current match.  It will estimate
				 *  the cost of the path from the beginning of LOOK to 
				 *  bufpos and to every locations spanned by the current 
				 *  match.  If the path through bufpos with the found matches
				 *  is estimated to take fewer number of bits to encode than
				 *  the previously found match, then the path to the location
				 *  is altered.
				 *
				 *  The code relies on accurate estimation of the cost of 
				 *  encoding a character or a match.  Furthermore, it requires
				 *  a search engine that will store the smallest match offset
				 *  of each possible match length.
				 *
				 *  A match of length one is simply treated as an unmatched 
				 *  character.
				 */

				/* 
				 *  Get the estimated number of bits required to encode the 
				 *  path leading up to bufpos.
				 */
				cum_numbits = decision_node_ptr[bufpos].numbits;

				/*
				 *  Calculate the estimated cost of outputting the path through
				 *  bufpos and outputting the next character as an unmatched byte
				 */
				est = cum_numbits + CHAR_EST(encoder->window[bufpos]);

				/*
				 *  Check if it is more efficient to encode the next character
				 *  as an unmatched character rather than the previously found 
				 *  match.  If so, then update the cheapest path to bufpos + 1.
				 *
				 *  What happens if est == numbits[bufpos-bpos+1]; i.e. it
				 *  works out as well to output a character as to output a
				 *  match?  It's a tough call; however, we will push the
				 *  encoder to use matches where possible.
				 */
				if (est < decision_node_ptr[bufpos+1].numbits)
				{
					decision_node_ptr[bufpos+1].numbits = est;
					decision_node_ptr[bufpos+1].path    = bufpos;
				}

				/*
				 *	Now, iterate through the remaining match lengths and 
				 *  compare the new path to the existing.  Change the path
				 *  if it is found to be more cost effective to go through
				 *  bufpos.
				 */
				for (i = MIN_MATCH; i <= (unsigned long) EncMatchLength; i++)
				{
					MATCH_EST(i, matchpos_table[i], est);
					est += cum_numbits;

					/*
					 * If est == numbits[bufpos+i] we want to leave things
					 * alone, since this will tend to force the matches
					 * to be smaller in size, which is beneficial for most
					 * data.
					 */
					if (est < decision_node_ptr[bufpos+i].numbits)
					{
						decision_node_ptr[bufpos+i].numbits	= est;
						decision_node_ptr[bufpos+i].path	= bufpos;
						decision_node_ptr[bufpos+i].link	= matchpos_table[i];
					}
				}
			} /* continue to loop through span of matches */

			/*
			 *  Here bufpos == span, ie. a non-matchable character found.  The
			 *  following code will output the path properly.
			 */

			/*
			 *  Unfortunately the path is stored in reverse; how to get from
			 *  where we are now, to get back to where it all started.
			 *
			 *  Traverse the path back to the original starting position
			 *  of the LOOK span.  Invert the path pointers in order to be
			 *  able to traverse back to the current position from the start.
			 */

			/*
			 * Count the number of iterations we did, so when we go forwards
			 * we'll do the same amount
			 */
			iterations = 0;

			NextPrevPos = decision_node_ptr[bufpos].path;

   			do
			{
				unsigned long	PrevPos;

      			PrevPos = NextPrevPos;

   				NextPrevPos = decision_node_ptr[PrevPos].path;
   				decision_node_ptr[PrevPos].path = bufpos;

   				bufpos = PrevPos;
   				iterations++;
			} while (bufpos != bpos);

			/*
			 * Traverse from the beginning of the LOOK span to the end of 
			 * the span along the stored path, outputting matches and 
			 * characters appropriately.
			 */
			do
			{
   				if (decision_node_ptr[bufpos].path > bufpos+1)
   				{
					/*
					 * Path skips over more than 1 character; therefore it's a match
					 */
					RECORD_MATCH(
						decision_node_ptr[bufpos].path - bufpos,
						decision_node_ptr[ decision_node_ptr[bufpos].path ].link
					);

					bufpos = decision_node_ptr[bufpos].path;
				}
   				else
   				{
					/*
					 * Path goes to the next character; therefore it's a symbol
					 */
					RECORD_CHAR(encoder->window[bufpos]);
					bufpos++;
				}
			} while (--iterations != 0);
		}
		else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
		{
			/*
			 *  This code reflects a speed optimization that will always take
			 *  a match of length >= FAST_DECISION_THRESHOLD characters.
			 */

			/*
			 * The position associated with the match we found
			 */
			MatchPos = encoder->matchpos_table[EncMatchLength];

			/*
			 * Quickly insert match substrings into search tree
			 * (don't look for new matches; just insert the strings)
			 */
#ifndef INSERT_NEAR_LONG_MATCHES
			if (MatchPos == 3 && EncMatchLength > 16)
			{
				optimal_insert(
					context,
                       bufpos + 1,
                       bufpos - WINDOW_SIZE + 2 
                   );
			}
			else
#endif
			{
				for (i = 1; i < (unsigned long) EncMatchLength; i++)
					optimal_insert(
						context,
                           bufpos + i,
                           bufpos + i - WINDOW_SIZE + 1
                        );
			}

			/*
			 * Advance our position in the window
			 */
			bufpos += EncMatchLength;

			/*
			 * Output the match
			 */
			RECORD_MATCH(EncMatchLength, MatchPos);

		}  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
	} /* end while ... bufpos <= bufpos_end */

	if (LITERAL_BUFFERS_FULL())
	{
		_ASSERT(context->outputting_block_num_literals <= OPT_ENCODER_MAX_ITEMS);

		// flush our recording matches bit buffer
        FLUSH_RECORDING_BITBUF();

        // Should check for failure result.  Luckily the only failure condition is
        // that the tree didn't fit into 500 bytes, which is basically impossible anyway.
		_ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);

		(void) OptimalEncoderOutputBlock(context);

		// fix estimates for optimal parser
		fixOptimalEstimates(context);

		encoder->next_tree_update = FIRST_TREE_UPDATE;

		// did we output the whole block?
		if (context->state == STATE_NORMAL)
		{
			// reset literal recording
        	recording_bufptr = encoder->recording_bufptr;
            recording_bitbuf = encoder->recording_bitbuf;
            recording_bitcount = encoder->recording_bitcount;
			goto after_output_block;
		}
	}

	// save recording state
	encoder->recording_bufptr = recording_bufptr;
    encoder->recording_bitbuf = recording_bitbuf;
    encoder->recording_bitcount = recording_bitcount;

    context->bufpos	= bufpos;

	VERIFY_HASHES(bufpos);
	removeNodes(context);
	VERIFY_HASHES(bufpos);

    if (context->bufpos == 2*WINDOW_SIZE)
        OptimalEncoderMoveWindows(context);
}


//
// Move the search windows when bufpos reaches 2*WINDOW_SIZE
//
static void OptimalEncoderMoveWindows(t_encoder_context *context)
{
	long	delta;
	int		i;
    t_optimal_encoder *encoder = context->optimal_encoder;
	t_search_node *search_tree_root = encoder->search_tree_root;
	t_search_node *left = encoder->search_left;
	t_search_node *right = encoder->search_right;

   	_ASSERT(context->bufpos == 2*WINDOW_SIZE);
 
	VERIFY_HASHES(context->bufpos);

	delta = context->bufpos - WINDOW_SIZE;

	memcpy(&encoder->window[0], &encoder->window[context->bufpos - WINDOW_SIZE], WINDOW_SIZE);

	for (i = 0; i < NUM_DIRECT_LOOKUP_TABLE_ELEMENTS; i++)
	{
		long val = ((long) search_tree_root[i]) - delta;
	
		if (val <= 0)
			search_tree_root[i] = (t_search_node) 0;
		else
			search_tree_root[i] = (t_search_node) val;

		_ASSERT(search_tree_root[i] < WINDOW_SIZE);
	}

	memcpy(&left[0], &left[context->bufpos - WINDOW_SIZE], sizeof(t_search_node)*WINDOW_SIZE);
	memcpy(&right[0], &right[context->bufpos - WINDOW_SIZE], sizeof(t_search_node)*WINDOW_SIZE);

	for (i = 0; i < WINDOW_SIZE; i++)
	{
		long val;
			
		// left
		val = ((long) left[i]) - delta;

		if (val <= 0)
			left[i] = (t_search_node) 0;
		else
			left[i] = (t_search_node) val;

		// right
		val = ((long) right[i]) - delta;

		if (val <= 0)
			right[i] = (t_search_node) 0;
		else
			right[i] = (t_search_node) val;
	}

#ifdef _DEBUG
	// force any search table references to be invalid
	memset(&encoder->window[WINDOW_SIZE], 0, WINDOW_SIZE);
#endif

	context->bufpos = WINDOW_SIZE;
	context->bufpos_end = context->bufpos;

	VERIFY_HASHES(context->bufpos);
}


//
// Calculate the frequencies of all literal and distance codes, for tree-making, then
// make the trees
//
static void calculateUpdatedEstimates(t_encoder_context *context)
{
    USHORT code[MAX_LITERAL_TREE_ELEMENTS];
    t_optimal_encoder *encoder = context->optimal_encoder;

	// create the trees, we're interested only in len[], not code[]
    // perf optimisation: make makeTree() not call MakeCode() in this situation
	makeTree(
		MAX_LITERAL_TREE_ELEMENTS, 
		15, 
		encoder->literal_tree_freq, 
		code,
		encoder->literal_tree_len
	);

	makeTree(
		MAX_DIST_TREE_ELEMENTS, 
		15, 
		encoder->dist_tree_freq, 
		code,
		encoder->dist_tree_len
	);
}


//
// Zero the running frequency counts
//
// Also set freq[END_OF_BLOCK_CODE] = 1
//
void OptimalEncoderZeroFrequencyCounts(t_optimal_encoder *encoder)
{
    _ASSERT(encoder != NULL);

    memset(encoder->literal_tree_freq, 0, sizeof(encoder->literal_tree_freq));
    memset(encoder->dist_tree_freq, 0, sizeof(encoder->dist_tree_freq));
    encoder->literal_tree_freq[END_OF_BLOCK_CODE] = 1;
}


void OptimalEncoderReset(t_encoder_context *context)
{
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);

	encoder->recording_bitbuf		= 0;
	encoder->recording_bitcount     = 0;
    encoder->recording_bufptr       = encoder->lit_dist_buffer;

    context->window_size            = WINDOW_SIZE;
	context->bufpos		            = context->window_size;
	context->bufpos_end             = context->bufpos;

	DeflateInitRecordingTables(
	    encoder->recording_literal_tree_len,
    	encoder->recording_literal_tree_code, 
	    encoder->recording_dist_tree_len,
    	encoder->recording_dist_tree_code
    );

	// clear the search table
	memset(
		encoder->search_tree_root,
		0, 
		sizeof(encoder->search_tree_root)
	);

	encoder->next_tree_update = FIRST_TREE_UPDATE;

	initOptimalEstimates(context);
    OptimalEncoderZeroFrequencyCounts(encoder);
}


BOOL OptimalEncoderInit(t_encoder_context *context)
{
	context->optimal_encoder = (t_optimal_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_optimal_encoder));

    if (context->optimal_encoder == NULL)
        return FALSE;

    OptimalEncoderReset(context);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optdebug.c ===
/*
 * optdebug.c
 *
 * Optimal encoder debugging stubs
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef _DEBUG
static void OptimalEncoderVerifyTreeStructure(t_encoder_context *context, byte val1, byte val2, long where)
{
	long left, right;

	if (where == 0)
		return;

	_ASSERT(context->optimal_encoder->window[where] == val1);
	_ASSERT(context->optimal_encoder->window[where+1] == val2);

	left = context->optimal_encoder->search_left[where];
	right = context->optimal_encoder->search_right[where];

	OptimalEncoderVerifyTreeStructure(context, val1, val2, left);
	OptimalEncoderVerifyTreeStructure(context, val1, val2, right);
}


void OptimalEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
	long i;

	for (i = 0; i < NUM_DIRECT_LOOKUP_TABLE_ELEMENTS; i++)
	{
		long	where = context->optimal_encoder->search_tree_root[i];
		USHORT	tree_to_use;

		if (where == 0)
			continue;

		tree_to_use = *((USHORT UNALIGNED *) &context->optimal_encoder->window[where]);

		_ASSERT(where < bufpos);
		_ASSERT(tree_to_use == i);

		OptimalEncoderVerifyTreeStructure(context, context->optimal_encoder->window[where], context->optimal_encoder->window[where+1], where);
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optblock.c ===
//
// optblock.c
//
// Outputting blocks
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "maketbl.h"


//
// Decode a recorded literal
//
#define DECODE_LITERAL(slot) \
	slot = encoder->recording_literal_tree_table[read_bitbuf & REC_LITERALS_DECODING_TABLE_MASK]; \
	while (slot < 0) \
	{  \
		unsigned long mask = 1 << REC_LITERALS_DECODING_TABLE_BITS; \
		do \
		{ \
			slot = -slot; \
			if ((read_bitbuf & mask) == 0) \
				slot = encoder->recording_literal_tree_left[slot]; \
			else \
				slot = encoder->recording_literal_tree_right[slot]; \
			mask <<= 1; \
		} while (slot < 0); \
	}


//
// Decode a recorded distance slot
//
#define DECODE_POS_SLOT(slot) \
	slot = encoder->recording_dist_tree_table[read_bitbuf & REC_DISTANCES_DECODING_TABLE_MASK]; \
	while (slot < 0) \
	{  \
		unsigned long mask = 1 << REC_DISTANCES_DECODING_TABLE_BITS; \
		do \
		{ \
			slot = -slot; \
			if ((read_bitbuf & mask) == 0) \
				slot = encoder->recording_dist_tree_left[slot]; \
			else \
				slot = encoder->recording_dist_tree_right[slot]; \
			mask <<= 1; \
		} while (slot < 0); \
	}


//
// Remove count bits from the bit buffer
//
#define DUMP_READBUF_BITS(count) \
	read_bitbuf >>= count; \
	read_bitcount -= count;


//
// Read more bits into the read buffer if our bit buffer if we need to
//
#define CHECK_MORE_READBUF() \
	if (read_bitcount <= 0) \
	{ \
		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
		read_bitcount += 8; \
		if (read_bitcount <= 0) \
		{ \
			read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
			read_bitcount += 8; \
		} \
	}


// output an element from the literal tree
#define OUTPUT_LITERAL(element) \
{ \
	_ASSERT(encoder->literal_tree_len[element] != 0); \
	outputBits(context, encoder->literal_tree_len[element], encoder->literal_tree_code[element]); \
}


// output an element from the distance tree
#define OUTPUT_DIST_SLOT(element) \
{ \
	_ASSERT(encoder->dist_tree_len[element] != 0); \
	outputBits(context, encoder->dist_tree_len[element], encoder->dist_tree_code[element]); \
}



//
// Output a dynamic block
//
static BOOL OptimalEncoderOutputDynamicBlock(t_encoder_context *context)
{
	unsigned long	read_bitbuf;
	int				read_bitcount;
	byte *			read_bufptr;
    t_optimal_encoder *encoder = context->optimal_encoder;

	if (context->state == STATE_NORMAL)
	{
		//
		// If we haven't started to output a block yet
		//
        read_bufptr     = encoder->lit_dist_buffer;
		read_bitbuf		= 0;
		read_bitcount	= -16;

		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
		read_bitcount += 8;

		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
		read_bitcount += 8;

		context->outputting_block_bitbuf		= read_bitbuf;
		context->outputting_block_bitcount		= read_bitcount;
		context->outputting_block_bufptr		= read_bufptr;

		outputBits(context, 1, 0); // "final" block flag
		outputBits(context, 2, BLOCKTYPE_DYNAMIC); 

		context->state = STATE_OUTPUTTING_TREE_STRUCTURE;
	}

	if (context->state == STATE_OUTPUTTING_TREE_STRUCTURE)
	{
		//
		// Make sure there is enough room to output the entire tree structure at once
		//
		if (context->output_curpos > context->output_endpos - MAX_TREE_DATA_SIZE)
		{
            _ASSERT(0); // not enough room to output tree structure, fatal error!
			return FALSE;
		}

		outputTreeStructure(context, encoder->literal_tree_len, encoder->dist_tree_len);

		context->state = STATE_OUTPUTTING_BLOCK;
	}

	_ASSERT(context->state == STATE_OUTPUTTING_BLOCK);

	// load state into local variables
	read_bufptr		= context->outputting_block_bufptr;
	read_bitbuf		= context->outputting_block_bitbuf;
	read_bitcount	= context->outputting_block_bitcount;

	// output literals
	while (context->outputting_block_current_literal < context->outputting_block_num_literals)
	{
		int literal;

		// break when we get near the end of our output buffer
		if (context->output_curpos >= context->output_near_end_threshold)
			break;

		DECODE_LITERAL(literal);
		DUMP_READBUF_BITS(encoder->recording_literal_tree_len[literal]);
		CHECK_MORE_READBUF();

		if (literal < NUM_CHARS)
		{
			// it's a char
			OUTPUT_LITERAL(literal);
		}
		else
		{
			// it's a match
			int len_slot, pos_slot, extra_pos_bits;

			// literal == len_slot + (NUM_CHARS+1)
			_ASSERT(literal != END_OF_BLOCK_CODE);

			OUTPUT_LITERAL(literal);

			len_slot = literal - (NUM_CHARS+1);

			//
			// extra_length_bits[len_slot] > 0 when len_slot >= 8
			// (except when length is MAX_MATCH).
			//
			if (len_slot >= 8)
			{
				int extra_bits = g_ExtraLengthBits[len_slot];

				if (extra_bits > 0)
				{
					unsigned int extra_data = read_bitbuf & ((1 << extra_bits)-1);

					outputBits(context, extra_bits, extra_data);
					
					DUMP_READBUF_BITS(extra_bits);
					CHECK_MORE_READBUF();
				}
			}

			DECODE_POS_SLOT(pos_slot);
			DUMP_READBUF_BITS(encoder->recording_dist_tree_len[pos_slot]);
			CHECK_MORE_READBUF();

			_ASSERT(pos_slot < 30);

			OUTPUT_DIST_SLOT(pos_slot);

			extra_pos_bits = g_ExtraDistanceBits[pos_slot];

			if (extra_pos_bits > 0)
			{
				unsigned int extra_data = read_bitbuf & ((1 << extra_pos_bits)-1);

				outputBits(context, extra_pos_bits, extra_data);

				DUMP_READBUF_BITS(extra_pos_bits);
				CHECK_MORE_READBUF();
			}
		}

		context->outputting_block_current_literal++;
	}

	// did we output all of our literals without running out of output space?
	if (context->outputting_block_current_literal >= context->outputting_block_num_literals)
	{
		// output the code signifying end-of-block
		OUTPUT_LITERAL(END_OF_BLOCK_CODE);

		// reset state
		context->state = STATE_NORMAL;
	}
	else
	{
		context->outputting_block_bitbuf	= read_bitbuf;
		context->outputting_block_bitcount	= read_bitcount;
		context->outputting_block_bufptr	= read_bufptr;
		context->state					    = STATE_OUTPUTTING_BLOCK;
	}

    return TRUE;
}



//
// Output a block.  This routine will resume outputting a block that was already being
// output if state != STATE_NORMAL.
//
BOOL OptimalEncoderOutputBlock(t_encoder_context *context)
{
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);

	//
	// The tree creation routines cannot >= 65536 literals.
	//
	_ASSERT(context->outputting_block_num_literals < 65536);

	if (context->state == STATE_NORMAL)
	{
        //
		// Start outputting literals and distances from the beginning
		//
		context->outputting_block_current_literal = 0;
	
		//
		// Nothing to output?  Then return
		//
		if (context->outputting_block_num_literals == 0)
			return TRUE;

		// make decoding table so that we can decode recorded items
		makeTable(
			MAX_LITERAL_TREE_ELEMENTS,
			REC_LITERALS_DECODING_TABLE_BITS,
			encoder->recording_literal_tree_len,
			encoder->recording_literal_tree_table,
			encoder->recording_literal_tree_left,
			encoder->recording_literal_tree_right
		);

		makeTable(
			MAX_DIST_TREE_ELEMENTS,
			REC_DISTANCES_DECODING_TABLE_BITS,
			encoder->recording_dist_tree_len,
			encoder->recording_dist_tree_table,
			encoder->recording_dist_tree_left,
			encoder->recording_dist_tree_right
		);

		// now make the trees used for encoding
	    makeTree(
    		MAX_LITERAL_TREE_ELEMENTS, 
	    	15, 
    		encoder->literal_tree_freq, 
	    	encoder->literal_tree_code,
    		encoder->literal_tree_len
    	);

	    makeTree(
    		MAX_DIST_TREE_ELEMENTS, 
	    	15, 
    		encoder->dist_tree_freq, 
	    	encoder->dist_tree_code,
    		encoder->dist_tree_len
    	);
	}

	//
	// Try outputting as a dynamic block
	//
	if (OptimalEncoderOutputDynamicBlock(context) == FALSE)
    {
        return FALSE;
    }

    if (context->state == STATE_NORMAL)
    {
   	    encoder->recording_bufptr           = context->optimal_encoder->lit_dist_buffer;
        encoder->recording_bitbuf           = 0;
        encoder->recording_bitcount         = 0;

		context->outputting_block_num_literals = 0;

		// make sure there are no zero frequency items
		NormaliseFrequencies(encoder->literal_tree_freq, encoder->dist_tree_freq);

		// make tree for recording new items
		makeTree(
			MAX_DIST_TREE_ELEMENTS, 
			RECORDING_DIST_MAX_CODE_LEN,
			encoder->dist_tree_freq, 
			encoder->recording_dist_tree_code, 
			encoder->recording_dist_tree_len
		);

		makeTree(
			MAX_LITERAL_TREE_ELEMENTS, 
			RECORDING_LIT_MAX_CODE_LEN,
			encoder->literal_tree_freq, 
			encoder->recording_literal_tree_code, 
			encoder->recording_literal_tree_len
		);

		OptimalEncoderZeroFrequencyCounts(encoder);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\maketbl.c ===
//
// maketbl.c
//
// Creates Huffman decoding tables
//
#include <crtdbg.h>
#include <windows.h>
#include "common.h"
#include "maketbl.h"


//
// Reverse the bits, len > 0
//
static unsigned int bitReverse(unsigned int code, int len)
{
	unsigned int new_code = 0;

    _ASSERT(len > 0);

	do
	{
		new_code |= (code & 1);
		new_code <<= 1;
		code >>= 1;
	} while (--len > 0);

	return new_code >> 1;
}


BOOL makeTable(
	int				num_elements, 
	int				table_bits, 
	const byte *	code_length, 
	short *			table, 
	short *			left, 
	short *			right
)
{
	int				bl_count[17];
	unsigned int	next_code[17];
	unsigned int	code[MAX_LITERAL_TREE_ELEMENTS];
	int				temp_code;
	int				avail;
	int				i, bits, ch;
	int				table_size, table_mask;

	table_size = 1 << table_bits;
	table_mask = table_size - 1;

	for (i = 0; i <= 16; i++)
		bl_count[i] = 0;

	for (i = 0; i < num_elements; i++)
		bl_count[ code_length[i] ]++;

	//
	// If there are any codes larger than table_bits in length, then
	// we will have to clear the table for our left/right spillover
    // code to work correctly.
	//
	// If there aren't any codes that large, then all table entries
	// will be written over without being read, so we don't need to
	// initialise them
	//
	for (i = table_bits; i <= 16; i++)
	{
		if (bl_count[i] > 0)
		{
			int j;

			// found a code larger than table_bits
			for (j = 0; j < table_size; j++)
				table[j] = 0;

			break;
		}
	}

	temp_code	= 0;
	bl_count[0] = 0;

	for (bits = 1; bits <= 16; bits++)
	{
		temp_code = (temp_code + bl_count[bits-1]) << 1;
		next_code[bits] = temp_code;
	}

	for (i = 0; i < num_elements; i++)
	{
		int len = code_length[i];

		if (len > 0)
		{
			code[i] = bitReverse(next_code[len], len);
			next_code[len]++;
		}
	}

	avail = num_elements;

	for (ch = 0; ch < num_elements; ch++)
	{
		int	start_at, len;

		// length of this code
		len = code_length[ch];

		// start value (bit reversed)
		start_at = code[ch];

		if (len > 0)
		{
			if (len <= table_bits)
			{
				int locs = 1 << (table_bits - len);
				int increment = 1 << len;
				int j;

				// 
				// Make sure that in the loop below, start_at is always
				// less than table_size.
				//
				// On last iteration we store at array index:
				//    initial_start_at + (locs-1)*increment
				//  = initial_start_at + locs*increment - increment
				//  = initial_start_at + (1 << table_bits) - increment
				//  = initial_start_at + table_size - increment
				//
				// Therefore we must ensure:
				//     initial_start_at + table_size - increment < table_size
				// or: initial_start_at < increment
				//
				if (start_at >= increment)
					return FALSE; // invalid table!

				for (j = 0; j < locs; j++)
				{
					table[start_at] = (short) ch;
					start_at += increment;
				}
			}
			else
			{
				int		overflow_bits;
				int		code_bit_mask;
				short *	p;

				overflow_bits = len - table_bits;
				code_bit_mask = 1 << table_bits;

				p = &table[start_at & table_mask];
                if (*p > 0)
                    return FALSE; // someone else already wrote a code here - invalid table!

				do
				{
					short value;

					value = *p;
                    _ASSERTE(value <= 0);

					if (value == 0)
					{
						left[avail]		= 0;
						right[avail]	= 0;

						*p = -avail;
                        
						value = -avail;
						avail++;
					}

                    _ASSERTE((-value >= 0) && (-value < table_size));

					if ((start_at & code_bit_mask) == 0)
						p = &left[-value];
					else
						p = &right[-value];

					code_bit_mask <<= 1;
					overflow_bits--;
				} while (overflow_bits != 0);

				*p = (short) ch;
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optenc.h ===
/*
 * optenc.h
 *
 * Defines for the optimal encoder
 */


// lookahead
#define LOOK			1024

// don't-care threshold for tree structure
#define BREAK_LENGTH	50

#define NUM_DIRECT_LOOKUP_TABLE_ELEMENTS    65536

// see stdenc.h for comments on these values
#define OPT_ENCODER_LIT_DIST_BUFFER_SIZE    65536
#define OPT_ENCODER_MAX_ITEMS				65534


//
// For the optimal parser
//
typedef unsigned long numbits_t;

typedef struct
{
	ULONG		link;
	ULONG		path;
	numbits_t	numbits;
} t_decision_node;


//
// Optimal encoder context
//
typedef struct optimal_encoder
{
	BYTE 					window[2*WINDOW_SIZE + MAX_MATCH + 4];
	t_decision_node 		decision_node[LOOK+MAX_MATCH+16];
	t_match_pos				matchpos_table[MAX_MATCH+1];
	t_search_node			search_left[2*WINDOW_SIZE];
	t_search_node			search_right[2*WINDOW_SIZE];
	t_search_node			search_tree_root[65536];

	// recording buffer for recording literals and distances
	BYTE					lit_dist_buffer[OPT_ENCODER_LIT_DIST_BUFFER_SIZE];
	unsigned long			recording_bitbuf;
	unsigned long			recording_bitcount;
    BYTE *                  recording_bufptr;

	unsigned int			next_tree_update;

	short					recording_dist_tree_table[REC_DISTANCES_DECODING_TABLE_SIZE];
	short					recording_dist_tree_left[2*MAX_DIST_TREE_ELEMENTS];
	short					recording_dist_tree_right[2*MAX_DIST_TREE_ELEMENTS];
    BYTE					recording_dist_tree_len[MAX_DIST_TREE_ELEMENTS];
    USHORT                  recording_dist_tree_code[MAX_DIST_TREE_ELEMENTS];

	short					recording_literal_tree_table[REC_LITERALS_DECODING_TABLE_SIZE];
	short					recording_literal_tree_left[2*MAX_LITERAL_TREE_ELEMENTS];
	short					recording_literal_tree_right[2*MAX_LITERAL_TREE_ELEMENTS];
	BYTE					recording_literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  recording_literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];

	// literal trees
    unsigned short          literal_tree_freq[2*MAX_LITERAL_TREE_ELEMENTS];
	unsigned short			literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];
	BYTE					literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	
	// dist trees
    unsigned short          dist_tree_freq[2*MAX_DIST_TREE_ELEMENTS];
	unsigned short			dist_tree_code[MAX_DIST_TREE_ELEMENTS];
	BYTE					dist_tree_len[MAX_DIST_TREE_ELEMENTS];

} t_optimal_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stdblock.c ===
//
// stdblock.c
//
// Outputting blocks
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "maketbl.h"


//
// Decode a recorded literal
//
#define DECODE_LITERAL(slot) \
	slot = encoder->recording_literal_tree_table[read_bitbuf & REC_LITERALS_DECODING_TABLE_MASK]; \
	while (slot < 0) \
	{  \
		unsigned long mask = 1 << REC_LITERALS_DECODING_TABLE_BITS; \
		do \
		{ \
			slot = -slot; \
			if ((read_bitbuf & mask) == 0) \
				slot = encoder->recording_literal_tree_left[slot]; \
			else \
				slot = encoder->recording_literal_tree_right[slot]; \
			mask <<= 1; \
		} while (slot < 0); \
	}


//
// Decode a recorded distance slot
//
#define DECODE_POS_SLOT(slot) \
	slot = encoder->recording_dist_tree_table[read_bitbuf & REC_DISTANCES_DECODING_TABLE_MASK]; \
	while (slot < 0) \
	{  \
		unsigned long mask = 1 << REC_DISTANCES_DECODING_TABLE_BITS; \
		do \
		{ \
			slot = -slot; \
			if ((read_bitbuf & mask) == 0) \
				slot = encoder->recording_dist_tree_left[slot]; \
			else \
				slot = encoder->recording_dist_tree_right[slot]; \
			mask <<= 1; \
		} while (slot < 0); \
	}


//
// Remove count bits from the bit buffer
//
#define DUMP_READBUF_BITS(count) \
	read_bitbuf >>= count; \
	read_bitcount -= count;


//
// Read more bits into the read buffer if our bit buffer if we need to
//
#define CHECK_MORE_READBUF() \
	if (read_bitcount <= 0) \
	{ \
		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
		read_bitcount += 8; \
		if (read_bitcount <= 0) \
		{ \
			read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
			read_bitcount += 8; \
		} \
	}


// output an element from the literal tree
#define OUTPUT_LITERAL(element) \
{ \
	_ASSERT(encoder->literal_tree_len[element] != 0); \
	outputBits(context, encoder->literal_tree_len[element], encoder->literal_tree_code[element]); \
}


// output an element from the distance tree
#define OUTPUT_DIST_SLOT(element) \
{ \
	_ASSERT(encoder->dist_tree_len[element] != 0); \
	outputBits(context, encoder->dist_tree_len[element], encoder->dist_tree_code[element]); \
}



//
// Output a dynamic block
//
static BOOL StdEncoderOutputDynamicBlock(t_encoder_context *context)
{
	unsigned long	read_bitbuf;
	int				read_bitcount;
	byte *			read_bufptr;
    t_std_encoder *encoder = context->std_encoder;

	if (context->state == STATE_NORMAL)
	{
		//
		// If we haven't started to output a block yet
		//
        read_bufptr     = encoder->lit_dist_buffer;
		read_bitbuf		= 0;
		read_bitcount	= -16;

		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
		read_bitcount += 8;

		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
		read_bitcount += 8;

		context->outputting_block_bitbuf		= read_bitbuf;
		context->outputting_block_bitcount		= read_bitcount;
		context->outputting_block_bufptr		= read_bufptr;

		outputBits(context, 1, 0); // "final" block flag
		outputBits(context, 2, BLOCKTYPE_DYNAMIC); 

		context->state = STATE_OUTPUTTING_TREE_STRUCTURE;
	}

	if (context->state == STATE_OUTPUTTING_TREE_STRUCTURE)
	{
		//
		// Make sure there is enough room to output the entire tree structure at once
		//
		if (context->output_curpos > context->output_endpos - MAX_TREE_DATA_SIZE)
		{
            _ASSERT(0); // not enough room to output tree structure, fatal error!
			return FALSE;
		}

		outputTreeStructure(context, encoder->literal_tree_len, encoder->dist_tree_len);

		context->state = STATE_OUTPUTTING_BLOCK;
	}

	_ASSERT(context->state == STATE_OUTPUTTING_BLOCK);

	// load state into local variables
	read_bufptr		= context->outputting_block_bufptr;
	read_bitbuf		= context->outputting_block_bitbuf;
	read_bitcount	= context->outputting_block_bitcount;

	// output literals
	while (context->outputting_block_current_literal < context->outputting_block_num_literals)
	{
		int literal;

		// break when we get near the end of our output buffer
		if (context->output_curpos >= context->output_near_end_threshold)
			break;

		DECODE_LITERAL(literal);
		DUMP_READBUF_BITS(encoder->recording_literal_tree_len[literal]);
		CHECK_MORE_READBUF();

		if (literal < NUM_CHARS)
		{
			// it's a char
			OUTPUT_LITERAL(literal);
		}
		else
		{
			// it's a match
			int len_slot, pos_slot, extra_pos_bits;

			// literal == len_slot + (NUM_CHARS+1)
			_ASSERT(literal != END_OF_BLOCK_CODE);

			OUTPUT_LITERAL(literal);

			len_slot = literal - (NUM_CHARS+1);

			//
			// extra_length_bits[len_slot] > 0 when len_slot >= 8
			// (except when length is MAX_MATCH).
			//
			if (len_slot >= 8)
			{
				int extra_bits = g_ExtraLengthBits[len_slot];

				if (extra_bits > 0)
				{
					unsigned int extra_data = read_bitbuf & ((1 << extra_bits)-1);

					outputBits(context, extra_bits, extra_data);
					
					DUMP_READBUF_BITS(extra_bits);
					CHECK_MORE_READBUF();
				}
			}

			DECODE_POS_SLOT(pos_slot);
			DUMP_READBUF_BITS(encoder->recording_dist_tree_len[pos_slot]);
			CHECK_MORE_READBUF();

			_ASSERT(pos_slot < 30);

			OUTPUT_DIST_SLOT(pos_slot);

			extra_pos_bits = g_ExtraDistanceBits[pos_slot];

			if (extra_pos_bits > 0)
			{
				unsigned int extra_data = read_bitbuf & ((1 << extra_pos_bits)-1);

				outputBits(context, extra_pos_bits, extra_data);

				DUMP_READBUF_BITS(extra_pos_bits);
				CHECK_MORE_READBUF();
			}
		}

		context->outputting_block_current_literal++;
	}

	// did we output all of our literals without running out of output space?
	if (context->outputting_block_current_literal >= context->outputting_block_num_literals)
	{
		// output the code signifying end-of-block
		OUTPUT_LITERAL(END_OF_BLOCK_CODE);

		// reset state
		context->state = STATE_NORMAL;
	}
	else
	{
		context->outputting_block_bitbuf	= read_bitbuf;
		context->outputting_block_bitcount	= read_bitcount;
		context->outputting_block_bufptr	= read_bufptr;
		context->state					    = STATE_OUTPUTTING_BLOCK;
	}

    return TRUE;
}


//
// Output a block.  This routine will resume outputting a block that was already being
// output if state != STATE_NORMAL.
//
BOOL StdEncoderOutputBlock(t_encoder_context *context)
{
    t_std_encoder *encoder = context->std_encoder;

	//
	// The tree creation routines cannot handle this overflow
	//
	_ASSERT(context->outputting_block_num_literals < 65536);

	if (context->state == STATE_NORMAL)
	{
		//
		// Start outputting literals and distances from the beginning
		//
		context->outputting_block_current_literal = 0;
	
		//
		// Nothing to output?  Then return
		//
		if (context->outputting_block_num_literals == 0)
			return TRUE;

		// make decoding table so that we can decode recorded items
		makeTable(
			MAX_LITERAL_TREE_ELEMENTS,
			REC_LITERALS_DECODING_TABLE_BITS,
			encoder->recording_literal_tree_len,
			encoder->recording_literal_tree_table,
			encoder->recording_literal_tree_left,
			encoder->recording_literal_tree_right
		);

		makeTable(
			MAX_DIST_TREE_ELEMENTS,
			REC_DISTANCES_DECODING_TABLE_BITS,
			encoder->recording_dist_tree_len,
			encoder->recording_dist_tree_table,
			encoder->recording_dist_tree_left,
			encoder->recording_dist_tree_right
		);

//        NormaliseFrequencies(context->literal_tree_freq, context->dist_tree_freq);
//context->dist_tree_freq[30] = 0;
//context->dist_tree_freq[31] = 0;

		// now make the trees used for encoding
	    makeTree(
    		MAX_LITERAL_TREE_ELEMENTS, 
	    	15, 
    		encoder->literal_tree_freq, 
	    	encoder->literal_tree_code,
    		encoder->literal_tree_len
    	);

	    makeTree(
    		MAX_DIST_TREE_ELEMENTS, 
	    	15, 
    		encoder->dist_tree_freq, 
	    	encoder->dist_tree_code,
    		encoder->dist_tree_len
    	);

//GenerateTable("g_FastEncoderLiteralTree", MAX_LITERAL_TREE_ELEMENTS, context->literal_tree_len, context->literal_tree_code);
//GenerateTable("g_FastEncoderDistanceTree", MAX_DIST_TREE_ELEMENTS, context->dist_tree_len, context->dist_tree_code);
	}

	//
	// Try outputting as a dynamic block
	//
	if (StdEncoderOutputDynamicBlock(context) == FALSE)
    {
        return FALSE;
    }

    if (context->state == STATE_NORMAL)
    {
   	    encoder->recording_bufptr           = context->std_encoder->lit_dist_buffer;
        encoder->recording_bitbuf           = 0;
        encoder->recording_bitcount         = 0;

		context->outputting_block_num_literals = 0;

		// make sure there are no zero frequency items
		NormaliseFrequencies(encoder->literal_tree_freq, encoder->dist_tree_freq);

		// make tree for recording new items
		makeTree(
			MAX_DIST_TREE_ELEMENTS, 
			RECORDING_DIST_MAX_CODE_LEN,
			encoder->dist_tree_freq, 
			encoder->recording_dist_tree_code, 
			encoder->recording_dist_tree_len
		);

		makeTree(
			MAX_LITERAL_TREE_ELEMENTS, 
			RECORDING_LIT_MAX_CODE_LEN,
			encoder->literal_tree_freq, 
			encoder->recording_literal_tree_code, 
			encoder->recording_literal_tree_len
		);

		StdEncoderZeroFrequencyCounts(encoder);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\optfmtch.c ===
/*
 * optfmtch.c
 *
 * Match finder for the optimal parser
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#define VERIFY_SEARCH_CODE(routine_name) \
{ \
	int debug_search; \
	for (debug_search = 0; debug_search < clen; debug_search++) \
	{ \
		if (window[ptr+debug_search] != window[BufPos+debug_search]) \
		{ \
			_RPT2( \
				_CRT_WARN, \
				routine_name \
				" char mismatch @%3d (clen=%d)\n", \
				debug_search, clen); \
			\
			_RPT3( \
				_CRT_WARN, \
				" ptr=%8d, bufpos=%8d, end_pos=%8d\n\n", \
				ptr, BufPos, end_pos); \
			_ASSERT(0); \
		} \
	} \
}


#define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
	_ASSERT(window[BufPos] == window[ptr]); \
	_ASSERT(window[BufPos+1] == window[ptr+1]);


/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */
int optimal_find_match(t_encoder_context *context, long BufPos)
{
	ULONG		ptr;
	ULONG       a, b;
	t_search_node *small_ptr, *big_ptr;
	t_search_node *left = context->optimal_encoder->search_left;
	t_search_node *right = context->optimal_encoder->search_right;
	t_match_pos *matchpos_table = context->optimal_encoder->matchpos_table;
	BYTE *window = context->optimal_encoder->window;
	ULONG       end_pos;
	int         val; /* must be signed */
	int         clen;
	int         same;
	int         match_length;
	int         small_len, big_len;
	USHORT      tree_to_use;

	/*
	 * Retrieve root node of tree to search, and insert current node at
	 * the root.
	 */
	tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);
	
	ptr        = context->optimal_encoder->search_tree_root[tree_to_use];
	context->optimal_encoder->search_tree_root[tree_to_use] = (t_search_node) BufPos;

	/*
	 * end_pos is the furthest location back we will search for matches 
	 *
	 * Remember that our window size is reduced by 3 bytes because of
	 * our repeated offset codes.
	 *
	 * Since BufPos starts at WINDOW_SIZE when compression begins,
	 * end_pos will never become negative.  
	 */
	end_pos = BufPos - (WINDOW_SIZE-4);

	/*
	 * Root node is either NULL, or points to a really distant position.
	 */
	if (ptr <= end_pos)
	{
		left[BufPos] = right[BufPos] = 0;
		return 0;
	}

	/*
	 * confirmed length (no need to check the first clen chars in a search)
	 *
	 * note: clen is always equal to min(small_len, big_len)
	 */
	clen            = 2;

	/*
	 * current best match length
	 */
	match_length    = 2;

	/*
	 * longest match which is < our string
	 */
	small_len       = 2;

	/*
	 * longest match which is > our string
	 */
	big_len         = 2;

#ifdef _DEBUG
	VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
#endif

	/*
	 * pointers to nodes to check
	 */
	small_ptr             = &left[BufPos];
	big_ptr               = &right[BufPos];

	do
	{
		/* compare bytes at current node */
		same = clen;

#ifdef _DEBUG
		VERIFY_SEARCH_CODE("optimal_findmatch()")
#endif

		/* don't need to check first clen characters */
		a    = ptr + clen;
		b    = BufPos + clen;

		while ((val = ((int) window[a++]) - ((int) window[b++])) == 0)
		{
			/* don't exceed MAX_MATCH */
			if (++same >= MAX_MATCH)
				goto long_match;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same > match_length)
				{
long_match:
					do
					{
						matchpos_table[++match_length] = BufPos-ptr-1;
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
						goto end_bsearch;
					}
				}

				big_len = same;
				clen = min(small_len, big_len);
			}

			*big_ptr = (t_search_node) ptr;
			big_ptr  = &left[ptr];
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same > match_length)
				{
					do
					{
						matchpos_table[++match_length] = BufPos-ptr-1;
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
						goto end_bsearch;
					}
				}

				small_len = same;
				clen = min(small_len, big_len);
			}
		
			*small_ptr = (t_search_node) ptr;
			small_ptr  = &right[ptr];
			ptr        = *small_ptr;
		}
	} while (ptr > end_pos); /* while we don't go too far backwards */

	*small_ptr = 0;
	*big_ptr   = 0;


end_bsearch:

	/*
	 * If we have multiple search trees, we are already guaranteed
	 * a minimum match length of 2 when we reach here.
	 *
	 * If we only have one tree, then we're not guaranteed anything.
	 */
    if (match_length < MIN_MATCH)
        return 0;
    else
	    return (long) match_length;
}


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
void optimal_insert(t_encoder_context *context, long BufPos, long end_pos)
{
	long        ptr;
	ULONG       a,b;
	t_search_node *small_ptr, *big_ptr;
	t_search_node *left = context->optimal_encoder->search_left;
	t_search_node *right = context->optimal_encoder->search_right;
	BYTE *window = context->optimal_encoder->window;
	int         val;
	int         small_len, big_len;
	int         same;
	int         clen;
	USHORT      tree_to_use;

	tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);
	ptr        = context->optimal_encoder->search_tree_root[tree_to_use];
	context->optimal_encoder->search_tree_root[tree_to_use] = (t_search_node) BufPos;

	if (ptr <= end_pos)
	{
		left[BufPos] = right[BufPos] = 0;
		return;
	}

	clen            = 2;
	small_len       = 2;
	big_len         = 2;

#ifdef _DEBUG
	VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
#endif

	small_ptr       = &left[BufPos];
	big_ptr         = &right[BufPos];

	do
	{
		same = clen;

		a    = ptr+clen;
		b    = BufPos+clen;

#ifdef _DEBUG
		VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
#endif

		while ((val = ((int) window[a++]) - ((int) window[b++])) == 0)
		{
			/*
			 * Here we break on BREAK_LENGTH, not MAX_MATCH
			 */
			if (++same >= BREAK_LENGTH) 
				break;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same >= BREAK_LENGTH)
				{
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
					return;
				}

				big_len = same;
				clen = min(small_len, big_len);
			}
			
			*big_ptr = (t_search_node) ptr;
			big_ptr  = &left[ptr];
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same >= BREAK_LENGTH)
				{
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
					return;
				}

				small_len = same;
				clen = min(small_len, big_len);
			}

			*small_ptr = (t_search_node) ptr;
			small_ptr  = &right[ptr];
			ptr        = *small_ptr;
		}
   } while (ptr > end_pos);

	*small_ptr = 0;
	*big_ptr   = 0;
}


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void optimal_remove_node(t_encoder_context *context, long BufPos, ULONG end_pos)
{
	ULONG   ptr;
	ULONG   left_node_pos;
	ULONG   right_node_pos;
	USHORT  tree_to_use;
	t_search_node *link;
	t_search_node *left = context->optimal_encoder->search_left;
	t_search_node *right = context->optimal_encoder->search_right;
	BYTE *window = context->optimal_encoder->window;

	/*
	 * The root node of tree_to_use should equal BufPos, since that is
	 * the most recent insertion into that tree - but if we never
	 * inserted this string (because it was a near match or a long
	 * string of zeroes), then we can't remove it.
	 */
	tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);


	/*
	 * If we never inserted this string, do not attempt to remove it
	 */

	if (context->optimal_encoder->search_tree_root[tree_to_use] != BufPos)
		return;

	link = &context->optimal_encoder->search_tree_root[tree_to_use];

	/*
	 * If the last occurence was too far away
	 */
	if (*link <= end_pos)
	{
		*link = 0;
		left[BufPos] = right[BufPos] = 0;
		return;
	}

	/*
	 * Most recent location of these chars
	 */
	ptr             = BufPos;

	/*
	 * Most recent location of a string which is "less than" it
	 */
	left_node_pos   = left[ptr];

	if (left_node_pos <= end_pos)
		left_node_pos = left[ptr] = 0;

	/*
	 * Most recent location of a string which is "greater than" it
	 */
	right_node_pos  = right[ptr];

	if (right_node_pos <= end_pos)
		right_node_pos = right[ptr] = 0;

	while (1)
	{
		/*
		 * If left node position is greater than right node position
		 * then follow the left node, since that is the more recent
		 * insertion into the tree.  Otherwise follow the right node.
		 */
		if (left_node_pos > right_node_pos)
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (left_node_pos <= end_pos)
				left_node_pos = 0;

			ptr = *link = (t_search_node) left_node_pos;

			if (!ptr)
				break;

			left_node_pos   = right[ptr];
			link            = &right[ptr];
		}
		else
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (right_node_pos <= end_pos)
				right_node_pos = 0;

			ptr = *link = (t_search_node) right_node_pos;

			if (!ptr) 
				break;

			right_node_pos  = left[ptr];
			link            = &left[ptr];
		}
	}
}


void removeNodes(t_encoder_context *context)
{
	long i;

	// remove the most recent insertions into the hash table, since we had invalid data 
	// sitting at the end of the window
	for (i = 0; i <= BREAK_LENGTH; i++)
	{
		if (context->bufpos-i-1 < WINDOW_SIZE)
			break;

		optimal_remove_node(context, context->bufpos-i-1, context->bufpos-WINDOW_SIZE+BREAK_LENGTH);
	}
}


//
// Reinsert the tree nodes we removed previously
//
void reinsertRemovedNodes(t_encoder_context *context)
{
	long j;

	for (j = BREAK_LENGTH; j > 0; j--)
	{
		if (context->bufpos - j > WINDOW_SIZE)
		{
			optimal_insert(
				context,
	            context->bufpos - j,
		        context->bufpos - j - WINDOW_SIZE + 4
			);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\types.h ===
//
// types.h
//
// Type definitions
//
#ifndef _DEFLATE_TYPES_H
#define _DEFLATE_TYPES_H

#include <windows.h>
#include <wtypes.h>
#include "api_int.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\output.c ===
/*
 * output.c
 *
 * General outputting routines
 */
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// Output an element from the pre-tree
//
#define OUTPUT_PRETREE_ELEMENT(element) \
	_ASSERT(pretree_len[element] != 0); \
	outputBits(context, pretree_len[element], pretree_code[element]);


//
// Output the tree structure for a dynamic block
//
void outputTreeStructure(t_encoder_context *context, const BYTE *literal_tree_len, const BYTE *dist_tree_len)
{
	int		hdist, hlit, combined_tree_elements, i, pass;
	USHORT	pretree_freq[NUM_PRETREE_ELEMENTS*2];
	USHORT	pretree_code[NUM_PRETREE_ELEMENTS];
	byte	pretree_len[NUM_PRETREE_ELEMENTS];

	//
	// combined literal + distance length code array for outputting the trees
	// in compressed form
	//
	// +3 is so we can overflow the array when performing run length encoding
	// (dummy values are inserted at the end so that run length encoding fails
	// before falling off the end of the array)
	//
	BYTE	lens[MAX_LITERAL_TREE_ELEMENTS + MAX_DIST_TREE_ELEMENTS + 3];

	//
	// Calculate HDIST
	//
	for (hdist = MAX_DIST_TREE_ELEMENTS - 1; hdist >= 1; hdist--)
	{
		if (dist_tree_len[hdist] != 0)
			break;
	}

	hdist++;

	//
	// Calculate HLIT
	//
	for (hlit = MAX_LITERAL_TREE_ELEMENTS - 1; hlit >= 257; hlit--)
	{
		if (literal_tree_len[hlit] != 0)
			break;
	}

	hlit++;

	//
	// Now initialise the array to have all of the hlit and hdist codes
	// in it
	//
	combined_tree_elements = hdist + hlit;

	memcpy(lens, literal_tree_len, hlit);
	memcpy(&lens[hlit], dist_tree_len, hdist);

	//
	// Stick in some dummy values at the end so that we don't overflow the 
	// array when comparing
	//
	for (i = combined_tree_elements; i < sizeof(lens); i++)
		lens[i] = -1;

	for (i = 0; i < NUM_PRETREE_ELEMENTS; i++)
		pretree_freq[i] = 0;

	//
	// Output the bitlengths in compressed (run length encoded) form.
	//
	// Make two passes; on the first pass count the various codes, create
	// the tree and output it, on the second pass output the codes using
	// the tree.
	//
	for (pass = 0; pass < 2; pass++)
	{
		int		cur_element;

		// are we outputting during this pass?
		BOOL	outputting = (pass == 1); 

		cur_element = 0;

		while (cur_element < combined_tree_elements)
		{
			int curlen = lens[cur_element];
			int run_length;

			//
			// See how many consecutive elements have the same value
			//
			// This won't run off the end of the array; it will hit the -1's
			// we stored there
			//
			for (run_length = cur_element+1; lens[run_length] == curlen; run_length++)
				;

			run_length -= cur_element;

			//
			// For non-zero codes need 4 identical in a row (original code
			// plus 3 repeats).  We decrement the run_length by one if the
			// code is not zero, since we don't count the first (original)
			// code in this case.
			//
			// For zero codes, need 3 zeroes in a row.
			//
			if (curlen != 0)
				run_length--;

			if (run_length < 3)
			{
				if (outputting)
				{
					OUTPUT_PRETREE_ELEMENT(curlen);
				}
				else
					pretree_freq[curlen]++;

				cur_element++;
			}
			else 
			{
				//
				// Elements with zero values are encoded specially
				//
				if (curlen == 0)
				{
					//
					// Do we use code 17 (3-10 repeated zeroes) or 
					// code 18 (11-138 repeated zeroes)?
					//
					if (run_length <= 10)
					{
						// code 17
						if (outputting)
						{
							OUTPUT_PRETREE_ELEMENT(17);
							outputBits(context, 3, run_length - 3);
						}
						else
						{
							pretree_freq[17]++;
						}
					}
					else
					{
						// code 18
						if (run_length > 138)
							run_length = 138;

						if (outputting)
						{
							OUTPUT_PRETREE_ELEMENT(18);
							outputBits(context, 7, run_length - 11);
						}
						else
						{
							pretree_freq[18]++;
						}
					}  

					cur_element += run_length;
				}
				else
				{
					//
					// Number of lengths actually encoded.  This may end up 
					// being less than run_length if we have a run length of
					// 7 (6 + 1 [which cannot be encoded with a code 16])
					//
					int run_length_encoded = 0;

					// curlen != 0

					// can output 3...6 repeats of a non-zero code, so split
					// longer runs into short ones (if possible)

					// remember to output the code itself first!
					if (outputting)
					{
						OUTPUT_PRETREE_ELEMENT(curlen);

						while (run_length >= 3)
						{
							int this_run = (run_length <= 6) ? run_length : 6;

							OUTPUT_PRETREE_ELEMENT(16);
							outputBits(context, 2, this_run - 3);

							run_length_encoded += this_run;
							run_length -= this_run;
						}
					}
					else
					{
						pretree_freq[curlen]++;

						while (run_length >= 3)
						{
							int this_run = (run_length <= 6) ? run_length : 6;

							pretree_freq[16]++;

							run_length_encoded += this_run;
							run_length -= this_run;
						}
					}

					// +1 for the original code itself
					cur_element += (run_length_encoded+1);
				}
			}
		}

		//
		// If this is the first pass, create the pretree from the
		// frequency data and output it, as well as the values of
		// HLIT, HDIST, HDCLEN (# pretree codes used)
		//
		if (pass == 0)
		{
			int hclen, i;

			makeTree(
				NUM_PRETREE_ELEMENTS,
				7, 
				pretree_freq, 
				pretree_code,
				pretree_len
			);

			//
			// Calculate HCLEN
			//
			for (hclen = NUM_PRETREE_ELEMENTS-1; hclen >= 4; hclen--)
			{
				if (pretree_len[ g_CodeOrder[hclen] ] != 0)
					break;
			}
			
			hclen++;

			//
			// Dynamic block header
			//
			outputBits(context, 5, hlit - 257);
			outputBits(context, 5, hdist - 1);
			outputBits(context, 4, hclen - 4);

			for (i = 0; i < hclen; i++)
			{
				outputBits(context, 3, pretree_len[g_CodeOrder[i]]);
			}
		}
	}
}


//
// bitwise i/o
//
void flushOutputBitBuffer(t_encoder_context *context)
{
	if (context->bitcount > 0)
	{
		int prev_bitcount = context->bitcount;
			
		outputBits(context, 16 - context->bitcount, 0);

		// backtrack if we have to; ZIP is byte aligned, not 16-bit word aligned
		if (prev_bitcount <= 8)
			context->output_curpos--;
	}
}


//
// Does not check for output overflow, so make sure to call checkOutputOverflow()
// often enough!
//
void outputBits(t_encoder_context *context, int n, int x)
{
	_ASSERT(context->output_curpos < context->output_endpos-1);
    _ASSERT(n > 0 && n <= 16);

	context->bitbuf |= (x << context->bitcount);
	context->bitcount += n;

	if (context->bitcount >= 16)                     
	{   
		*context->output_curpos++ = (BYTE) context->bitbuf;
		*context->output_curpos++ = (BYTE) (context->bitbuf >> 8);

		context->bitbuf >>= 16;
		context->bitcount -= 16;                         
	} 
}


// initialise the bit buffer
void InitBitBuffer(t_encoder_context *context)
{
	context->bitbuf		= 0;
	context->bitcount	= 0;
}


void OutputBlock(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL);
    
    // we never call OutputBlock() with the fast encoder
    _ASSERT(context->fast_encoder == NULL);

    if (context->std_encoder != NULL)
	    StdEncoderOutputBlock(context);
    else if (context->optimal_encoder != NULL)
        OptimalEncoderOutputBlock(context);
}


void FlushRecordingBuffer(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL);
    _ASSERT(context->fast_encoder == NULL); // fast encoder does not record

    if (context->std_encoder != NULL)
    {
        *context->std_encoder->recording_bufptr++ = (BYTE) context->std_encoder->recording_bitbuf; 
		*context->std_encoder->recording_bufptr++ = (BYTE) (context->std_encoder->recording_bitbuf >> 8); 
    }
    else if (context->optimal_encoder != NULL)
    {
        *context->optimal_encoder->recording_bufptr++ = (BYTE) context->optimal_encoder->recording_bitbuf; 
	    *context->optimal_encoder->recording_bufptr++ = (BYTE) (context->optimal_encoder->recording_bitbuf >> 8); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stdenc.c ===
/*
 * stdenc.c
 *
 * Standard encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//
// Update hash variable "h" with character c
//
#define UPDATE_HASH(h,c) \
	h = ((h) << STD_ENCODER_HASH_SHIFT) ^ (c);


//
// Insert a string into the hash chain at location bufpos
//
// Assertions check that we never attempt to insert near the end of the buffer
// (since our hash value is based on values at bufpos, bufpos+1, bufpos+2) and
// that our hash value is always valid for the bytes we are inserting.
//
#define INSERT_STRING(search,bufpos) \
{ \
    _ASSERT((bufpos + 2) < context->bufpos_end); \
	UPDATE_HASH(hash, window[bufpos+2]); \
	_ASSERT((unsigned int) STD_ENCODER_RECALCULATE_HASH(bufpos) == (unsigned int) (hash & STD_ENCODER_HASH_MASK)); \
	search = lookup[hash & STD_ENCODER_HASH_MASK]; \
	lookup[hash & STD_ENCODER_HASH_MASK] = (t_search_node) (bufpos); \
	prev[bufpos & WINDOW_MASK] = (t_search_node) search; \
}


#define CHECK_FLUSH_RECORDING_BUFFER() \
	if (recording_bitcount >= 16) \
	{ \
		*recording_bufptr++ = (BYTE) recording_bitbuf; \
		*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); \
		recording_bitbuf >>= 16; \
		recording_bitcount -= 16; \
	}


#define OUTPUT_RECORDING_DATA(count,data) \
	recording_bitbuf |= ((data) << recording_bitcount); \
	recording_bitcount += (count);


//
// Record unmatched symbol c
//
#define RECORD_CHAR(c) \
    context->outputting_block_num_literals++; \
    context->std_encoder->literal_tree_freq[c]++; \
	_ASSERT(context->std_encoder->recording_literal_tree_len[c] != 0); \
	OUTPUT_RECORDING_DATA(context->std_encoder->recording_literal_tree_len[c], context->std_encoder->recording_literal_tree_code[c]); \
	CHECK_FLUSH_RECORDING_BUFFER();


//
// Record a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
#define RECORD_MATCH(match_len, match_pos) \
{ \
	int pos_slot = POS_SLOT(match_pos); \
	int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
	int item = (NUM_CHARS+1) + len_slot; \
	int extra_dist_bits = g_ExtraDistanceBits[pos_slot]; \
	int extra_len_bits = g_ExtraLengthBits[len_slot]; \
	_ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
	_ASSERT(context->outputting_block_num_literals >= 0 && context->outputting_block_num_literals < STD_ENCODER_MAX_ITEMS); \
	_ASSERT(context->std_encoder->recording_literal_tree_len[item] != 0); \
	_ASSERT(context->std_encoder->recording_dist_tree_len[pos_slot] != 0); \
    context->outputting_block_num_literals++; \
    context->std_encoder->literal_tree_freq[(NUM_CHARS + 1) + len_slot]++; \
    context->std_encoder->dist_tree_freq[pos_slot]++; \
	OUTPUT_RECORDING_DATA(context->std_encoder->recording_literal_tree_len[item], context->std_encoder->recording_literal_tree_code[item]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_len_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_len_bits, (match_len-MIN_MATCH) & ((1 << extra_len_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
	OUTPUT_RECORDING_DATA(context->std_encoder->recording_dist_tree_len[pos_slot], context->std_encoder->recording_dist_tree_code[pos_slot]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_dist_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_dist_bits, match_pos & ((1 << extra_dist_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
}


#define FLUSH_RECORDING_BITBUF() \
    *recording_bufptr++ = (BYTE) recording_bitbuf; \
	*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); 


//
// Verifies that all of the hash pointers in the hash table are correct, and that everything
// in the same hash chain has the same hash value
//
#ifdef FULL_DEBUG
#define VERIFY_HASHES(bufpos) StdEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif


static void StdEncoderMoveWindows(t_encoder_context *context);

static int StdEncoderFindMatch(
    const BYTE *        window,
    const USHORT *      prev,
    long                bufpos, 
    long                search, 
    unsigned int *      match_pos, 
    int                 cutoff,
    int                 nice_length
);


void StdEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
)
{
	long			bufpos;
	unsigned int	hash;
    t_std_encoder * encoder = context->std_encoder;
	byte *			window = encoder->window;
	t_search_node *	prev = encoder->prev;
	t_search_node *	lookup = encoder->lookup;
	unsigned long	recording_bitbuf;
	int				recording_bitcount;
	byte *			recording_bufptr;
    byte *          end_recording_bufptr;

	// restore literal/match bitmap variables
    end_recording_bufptr    = &encoder->lit_dist_buffer[STD_ENCODER_LIT_DIST_BUFFER_SIZE-8];
	recording_bufptr        = encoder->recording_bufptr;
    recording_bitbuf        = encoder->recording_bitbuf;
    recording_bitcount      = encoder->recording_bitcount;
	bufpos			        = context->bufpos;

	VERIFY_HASHES(bufpos);

    //
    // Recalculate our hash
    //
    // One disadvantage of the way we do our hashing is that matches are not permitted in the last
    // few characters near bufpos_end.
	//
    hash = 0;
	UPDATE_HASH(hash, window[bufpos]);
	UPDATE_HASH(hash, window[bufpos+1]);

	while (bufpos < context->bufpos_end)
	{
		int				match_len;
		t_match_pos		match_pos;
		t_match_pos		search;

        if (context->bufpos_end - bufpos <= 3)
		{
			// don't insert any strings when we get close to the end of the buffer,
            // since we will end up using corrupted hash values (the data after bufpos_end
            // is undefined, and those bytes would be swept into the hash value if we
            // calculated a hash at bufpos_end-2, for example, since our hash value is
            // build from 3 consecutive characters in the buffer).
			match_len = 0;
		}
		else
		{
			INSERT_STRING(search,bufpos);

			// find a match at what we'll call position X
			if (search != 0)
			{
				match_len = StdEncoderFindMatch(window, prev, bufpos, search, &match_pos, search_depth, nice_length);

				// truncate match if we're too close to the end of the buffer
				if (bufpos + match_len > context->bufpos_end)
					match_len = context->bufpos_end - bufpos;
			}
			else
			{
				match_len = 0;
			}
		}

		if (match_len < MIN_MATCH)
		{
			// didn't find a match, so output unmatched char
			RECORD_CHAR(window[bufpos]);
    		bufpos++;
		}
		else
		{
    		// bufpos now points to X+1
    		bufpos++;

			// is this match so good (long) that we should take it automatically without
			// checking X+1 ?
			if (match_len <= lazy_match_threshold)
			{
				int				next_match_len;
				t_match_pos		next_match_pos;

                // sets search
                INSERT_STRING(search,bufpos);

				// no, so check for a better match at X+1
				if (search != 0)
				{
					next_match_len = StdEncoderFindMatch(
						window,
                        prev,
						bufpos, 
						search,
						&next_match_pos,
						match_len < good_length ? search_depth : (search_depth >> 2),
                        nice_length
					);
				
					// truncate match if we're too close to the end of the buffer
					// note: next_match_len could now be < MIN_MATCH
					if (bufpos + next_match_len > context->bufpos_end)
						next_match_len = context->bufpos_end - bufpos;
				}
				else
				{
					next_match_len = 0;
				}

				// right now X and X+1 are both inserted into the search tree
				if (next_match_len > match_len)
				{
					// since next_match_len > match_len, it can't be < MIN_MATCH here

					// match at X+1 is better, so output unmatched char at X
					RECORD_CHAR(window[bufpos-1]);

					// now output match at location X+1
					RECORD_MATCH(next_match_len, next_match_pos);

					// insert remainder of second match into search tree
					// 
					// example: (*=inserted already)
					//
					// X      X+1               X+2      X+3     X+4
					// *      *
					//        nextmatchlen=3
					//        bufpos
					//
					// If next_match_len == 3, we want to perform 2
					// insertions (at X+2 and X+3).  However, first we must 
					// inc bufpos.
					//
					bufpos++; // now points to X+2
					match_len = next_match_len;
					goto insert;
				}
				else
				{
					// match at X is better, so take it
					RECORD_MATCH(match_len, match_pos);

					//
					// Insert remainder of first match into search tree, minus the first
					// two locations, which were inserted by the FindMatch() calls.
					// 
					// For example, if match_len == 3, then we've inserted at X and X+1
					// already (and bufpos is now pointing at X+1), and now we need to insert 
					// only at X+2.
					//
					match_len--;
					bufpos++; // now bufpos points to X+2
					goto insert;
				}
			}
			else /* match_length >= good_match */
			{
				// in assertion: bufpos points to X+1, location X inserted already
					
				// first match is so good that we're not even going to check at X+1
				RECORD_MATCH(match_len, match_pos);

				// insert remainder of match at X into search tree
insert:
				if (context->bufpos_end - bufpos <= match_len)
				{
					bufpos += (match_len-1);
				}
				else
				{
					while (--match_len > 0)
					{
						t_match_pos ignore; // we're not interested in the search position

						INSERT_STRING(ignore,bufpos);
						bufpos++;
					}
				}
			}
		}

		// literal buffer or distance buffer filled up (or close to filling up)?
		if (context->outputting_block_num_literals >= STD_ENCODER_MAX_ITEMS-4 ||
            recording_bufptr >= end_recording_bufptr)
		{
			// yes, then we must output a block
			_ASSERT(context->outputting_block_num_literals <= STD_ENCODER_MAX_ITEMS);

			// flush our recording matches bit buffer
            FLUSH_RECORDING_BITBUF();

			StdEncoderOutputBlock(context);

			// did we output the whole block?
			if (context->state != STATE_NORMAL)
				break;

			// we did output the whole block, so reset literal encoding
        	recording_bufptr = encoder->recording_bufptr;
            recording_bitbuf = encoder->recording_bitbuf;
            recording_bitcount = encoder->recording_bitcount;
		}
	} /* end ... while (bufpos < bufpos_end) */

    _ASSERT(bufpos <= context->bufpos_end);

	// save recording state
	encoder->recording_bufptr = recording_bufptr;
    encoder->recording_bitbuf = recording_bitbuf;
    encoder->recording_bitcount = recording_bitcount;

	context->bufpos = bufpos;

	VERIFY_HASHES(bufpos);

    if (context->bufpos == 2*WINDOW_SIZE)
        StdEncoderMoveWindows(context);
}


static int StdEncoderFindMatch(
    const BYTE *        window,
    const USHORT *      prev,
    long                bufpos, 
    long                search, 
    unsigned int *      match_pos, 
    int                 cutoff,
    int                 nice_length
)
{
	const BYTE *	window_bufpos = &window[bufpos];
	long			earliest; // how far back we can look
	int				best_match = 0; // best match length found so far
	t_match_pos		l_match_pos;

	_ASSERT(bufpos >= 0 && bufpos < 2*WINDOW_SIZE);
	_ASSERT(search < bufpos);
	_ASSERT(STD_ENCODER_RECALCULATE_HASH(search) == STD_ENCODER_RECALCULATE_HASH(bufpos));

	earliest = bufpos - WINDOW_SIZE;
    _ASSERT(earliest >= 0);

	while (search > earliest)
	{
		_ASSERT(STD_ENCODER_RECALCULATE_HASH(search) == STD_ENCODER_RECALCULATE_HASH(bufpos));
        _ASSERT(search < bufpos);

		if (window_bufpos[best_match] == window[search + best_match])
		{
			int j;

			for (j = 0; j < MAX_MATCH; j++)
			{
				if (window_bufpos[j] != window[search+j])
					break;
			}
	
			if (j > best_match)
			{
				best_match	= j;
				l_match_pos	= search; // absolute position

				if (j > nice_length)
					break;
			}
		}

		if (--cutoff == 0)
			break;

		search = (long) prev[search & WINDOW_MASK];
	}

    // turn l_match_pos into relative position
	l_match_pos = bufpos - l_match_pos - 1; 

	if (best_match == 3 && l_match_pos >= STD_ENCODER_MATCH3_DIST_THRESHOLD)
		return 0;

	_ASSERT(best_match < MIN_MATCH || l_match_pos < WINDOW_SIZE);
    *match_pos = l_match_pos;

	return best_match;
}


static void StdEncoderMoveWindows(t_encoder_context *context)
{
	if (context->bufpos >= 2*WINDOW_SIZE)
	{
		int		i;
		t_search_node *lookup = context->std_encoder->lookup;
		t_search_node *prev = context->std_encoder->prev;
		BYTE *window = context->std_encoder->window;

		VERIFY_HASHES(2*WINDOW_SIZE);

		memcpy(&window[0], &window[context->bufpos - WINDOW_SIZE], WINDOW_SIZE);

		for (i = 0; i < STD_ENCODER_HASH_TABLE_SIZE; i++)
		{
			long val = ((long) lookup[i]) - WINDOW_SIZE;
	
			if (val <= 0)
				lookup[i] = (t_search_node) 0;
			else
				lookup[i] = (t_search_node) val;
		}

		for (i = 0; i < WINDOW_SIZE; i++)
		{
			long val = ((long) prev[i]) - WINDOW_SIZE;
	
			if (val <= 0)
				prev[i] = (t_search_node) 0;
			else
				prev[i] = (t_search_node) val;
		}

#ifdef FULL_DEBUG
		memset(&window[WINDOW_SIZE], 0, WINDOW_SIZE);
#endif

		VERIFY_HASHES(2*WINDOW_SIZE);

		
		context->bufpos = WINDOW_SIZE;
		context->bufpos_end = context->bufpos;
	}
}


//
// Zero the running frequency counts
//
// Also set freq[END_OF_BLOCK_CODE] = 1
//
void StdEncoderZeroFrequencyCounts(t_std_encoder *encoder)
{
    _ASSERT(encoder != NULL);

  	memset(encoder->literal_tree_freq, 0, sizeof(encoder->literal_tree_freq));
    memset(encoder->dist_tree_freq, 0, sizeof(encoder->dist_tree_freq));
    encoder->literal_tree_freq[END_OF_BLOCK_CODE] = 1;
}


void StdEncoderReset(t_encoder_context *context)
{
    t_std_encoder *encoder = context->std_encoder;

	_ASSERT(encoder != NULL);
	memset(encoder->lookup, 0, sizeof(encoder->lookup));

    context->window_size        = WINDOW_SIZE;
	context->bufpos		        = context->window_size;
	context->bufpos_end         = context->bufpos;

	encoder->recording_bitbuf	= 0;
	encoder->recording_bitcount = 0;
    encoder->recording_bufptr   = encoder->lit_dist_buffer;

	DeflateInitRecordingTables(
	    encoder->recording_literal_tree_len,
    	encoder->recording_literal_tree_code, 
	    encoder->recording_dist_tree_len,
    	encoder->recording_dist_tree_code
    );

    StdEncoderZeroFrequencyCounts(encoder);
}


BOOL StdEncoderInit(t_encoder_context *context)
{
	context->std_encoder = (t_std_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_std_encoder));

    if (context->std_encoder == NULL)
        return FALSE;

	StdEncoderReset(context);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stdenc.h ===
/*
 * stdenc.h
 *
 * Defines for the standard encoder
 */

//
// Size of hash table for std encoder
//
#define STD_ENCODER_HASH_TABLE_SIZE				8192
#define STD_ENCODER_HASH_MASK					(STD_ENCODER_HASH_TABLE_SIZE-1)
#define STD_ENCODER_HASH_SHIFT					5

#define STD_ENCODER_RECALCULATE_HASH(loc) \
	(((window[loc] << (2*STD_ENCODER_HASH_SHIFT)) ^ \
	(window[loc+1] << STD_ENCODER_HASH_SHIFT) ^ \
	(window[loc+2])) & STD_ENCODER_HASH_MASK)


//
// Maximum number of item we allow; this must be <= 65534, since this doesn't include
// freq[END_OF_BLOCK_CODE] = 1, which brings us to 65535; any more than this would make
// the frequency counts overflow, since they are stored in ushort's
//
// Note that this number does not affect the memory requirements in any way; that is
// determined by LIT_DIST_BUFFER_SIZE
//
// -8 for some slack (not really necessary)
//
#define STD_ENCODER_MAX_ITEMS				(65534-8)

//
// Size of the literal/distance buffer
//
#define STD_ENCODER_LIT_DIST_BUFFER_SIZE	32768

//
// Don't take a match 3 further away than this
// 4K seems a little close, but does do a marginally better job than 8K on 
// an 80K html file, so might as well leave it be
//
#define STD_ENCODER_MATCH3_DIST_THRESHOLD   4096


//
// Standard encoder context
//
typedef struct std_encoder
{
	// history window
	BYTE 					window[2*WINDOW_SIZE + MAX_MATCH + 4];

	// next most recent occurance of chars with same hash value
    t_search_node			prev[WINDOW_SIZE + MAX_MATCH];

	// hash table to find most recent occurance of chars with same hash value
	t_search_node			lookup[STD_ENCODER_HASH_TABLE_SIZE];

	// recording buffer for recording literals and distances
	BYTE					lit_dist_buffer[STD_ENCODER_LIT_DIST_BUFFER_SIZE];
	unsigned long			recording_bitbuf;
	unsigned long			recording_bitcount;
    BYTE *                  recording_bufptr;

	short					recording_dist_tree_table[REC_DISTANCES_DECODING_TABLE_SIZE];
	short					recording_dist_tree_left[2*MAX_DIST_TREE_ELEMENTS];
	short					recording_dist_tree_right[2*MAX_DIST_TREE_ELEMENTS];
    BYTE					recording_dist_tree_len[MAX_DIST_TREE_ELEMENTS];
    USHORT                  recording_dist_tree_code[MAX_DIST_TREE_ELEMENTS];

	short					recording_literal_tree_table[REC_LITERALS_DECODING_TABLE_SIZE];
	short					recording_literal_tree_left[2*MAX_LITERAL_TREE_ELEMENTS];
	short					recording_literal_tree_right[2*MAX_LITERAL_TREE_ELEMENTS];
	BYTE					recording_literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  recording_literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];

	// literal trees
    USHORT                  literal_tree_freq[2*MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];
	BYTE					literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	
	// dist trees
    USHORT                  dist_tree_freq[2*MAX_DIST_TREE_ELEMENTS];
	USHORT                  dist_tree_code[MAX_DIST_TREE_ELEMENTS];
	BYTE					dist_tree_len[MAX_DIST_TREE_ELEMENTS];
} t_std_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\gzip\stddebug.c ===
/*
 * stddebug.c
 *
 * Debugging stubs for std encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef FULL_DEBUG
// verify all hash chains
void StdEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
	int i;
	const t_search_node *lookup = context->std_encoder->lookup;
	const t_search_node *prev = context->std_encoder->prev;
	const BYTE *window = context->std_encoder->window;

	for (i = 0; i < STD_ENCODER_HASH_TABLE_SIZE; i++)
	{
		t_search_node where = lookup[i];
		t_search_node next_where;

		while (where != 0 && bufpos - where < WINDOW_SIZE)
		{
			int hash = STD_ENCODER_RECALCULATE_HASH(where);

			_ASSERT(hash == i);

			next_where = prev[where & WINDOW_MASK];

			if (bufpos - next_where >= WINDOW_SIZE)
				break;

			_ASSERT(next_where < where);

			where = next_where;
		} 
	}
}


// verify that a particular hash chain is correct
void StdEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number)
{
	const t_search_node *lookup = context->std_encoder->lookup;
	const t_search_node *prev = context->std_encoder->prev;
	BYTE *window = context->std_encoder->window;
	t_search_node where;
	t_search_node next_where;
	int print = 0;

top:
	where = lookup[chain_number];

//	if (print)
//		printf("Verify chain %d\n", chain_number);

	while (where != 0 && bufpos - where < WINDOW_SIZE)
	{
		int hash = STD_ENCODER_RECALCULATE_HASH(where);
        BYTE *window = context->std_encoder->window;

//		if (print)
//			printf("   loc %d: char = %3d %3d %3d\n", where, window[where], window[where+1], window[where+2]);

		if (hash != chain_number && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(hash == chain_number);

		next_where = prev[where & WINDOW_MASK];

		if (bufpos - next_where >= WINDOW_SIZE)
			break;

		if (next_where >= where && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(next_where < where);

		where = next_where;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\inc\api.h ===
/*
 * api.h
 */
typedef HRESULT (WINAPI *PFNCODEC_INIT_COMPRESSION)(VOID);
typedef HRESULT (WINAPI *PFNCODEC_INIT_DECOMPRESSION)(VOID);

typedef VOID (WINAPI *PFNCODEC_DEINIT_COMPRESSION)(VOID);
typedef VOID (WINAPI *PFNCODEC_DEINIT_DECOMPRESSION)(VOID);

typedef HRESULT (WINAPI *PFNCODEC_CREATE_COMPRESSION)(PVOID *context, ULONG flags);
typedef HRESULT (WINAPI *PFNCODEC_CREATE_DECOMPRESSION)(PVOID *context, ULONG flags);

typedef HRESULT (WINAPI *PFNCODEC_COMPRESS)(
	PVOID		context, 
	CONST PBYTE	input, 
	LONG		input_size, 
	PBYTE		output, 
	LONG		output_size,
	PLONG		input_used,
	PLONG		output_used,
	INT			compression_level
);

typedef HRESULT (WINAPI *PFNCODEC_DECOMPRESS)(
	PVOID		context,
	CONST PBYTE	input,
	LONG		input_size,
	PBYTE		output,
	LONG		output_size,
	PLONG		input_used,
	PLONG		output_used
);

typedef VOID (WINAPI *PFNCODEC_DESTROY_COMPRESSION)(PVOID context);
typedef VOID (WINAPI *PFNCODEC_DESTROY_DECOMPRESSION)(PVOID context);

typedef HRESULT (WINAPI *PFNCODEC_RESET_COMPRESSION)(PVOID context);
typedef HRESULT (WINAPI *PFNCODEC_RESET_DECOMPRESSION)(PVOID context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\md5filt\authfilt.h ===
#ifndef _AUTHFILT_H_
#define _AUTHFILT_H_

BOOL
SubAuthGetFilterVersion(
    VOID
);

DWORD
SubAuthHttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType,
    LPVOID                      pvNotification
);

BOOL
SubAuthTerminateFilter(
    DWORD                       dwFlags
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\md5filt\authfilt.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation


Module Name:

    authfilt.cxx

Abstract:

    This module is an ISAPI Authentication Filter.

--*/

#ifdef __cplusplus
extern "C" {
#endif


# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
#if 1 // DBCS
# include <mbstring.h>
#endif
#include <lmcons.h>
#include <lmjoin.h>

#ifdef __cplusplus
};
#endif


# include <iis64.h>
# include <inetcom.h>
# include <inetinfo.h>

//
//  System include files.
//

# include "dbgutil.h"
#include <tcpdll.hxx>
#include <tsunami.hxx>


extern "C" {

#include <tchar.h>

//
//  Project include files.
//

#include <time.h>
#include <w3svc.h>
#include <iisfiltp.h>
#include <sspi.h>

} // extern "C"

#include <iismap.hxx>
#include <mapmsg.h>
#include <lonsi.hxx>
#include "authfilt.h"

#define RANDOM_SIZE 8 //# of random bytes at beginning of nonce
#define TIMESTAMP_SIZE 12 //size of timestamp in nonce
#define MD5_HASH_SIZE 16 //MD5 hash size
#define NONCE_SIZE (2*RANDOM_SIZE + TIMESTAMP_SIZE + 2*MD5_HASH_SIZE)

typedef struct _DIGEST_CONTEXT {
    BOOL    fStale;
    DWORD   tLastNonce;
    CHAR    achNonce[NONCE_SIZE + 1];
    CHAR    achUserName[SF_MAX_USERNAME*2+sizeof(" ( )")];
} DIGEST_CONTEXT, *PDIGEST_CONTEXT;

//
// value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAMES
//

enum MD5_AUTH_NAME
{
    MD5_AUTH_USERNAME,
    MD5_AUTH_URI,
    MD5_AUTH_REALM,
    MD5_AUTH_NONCE,
    MD5_AUTH_RESPONSE,
    MD5_AUTH_ALGORITHM,
    MD5_AUTH_DIGEST,
    MD5_AUTH_OPAQUE,
    MD5_AUTH_QOP,
    MD5_AUTH_CNONCE,
    MD5_AUTH_NC,
    MD5_AUTH_LAST,
};

#define NONCE_GRANULARITY   512

#define MAX_URL_SIZE        512

//
//  Globals
//

HCRYPTPROV g_hCryptProv;

DECLARE_DEBUG_PRINTS_OBJECT()
#include <initguid.h>
DEFINE_GUID(IisMD5FiltGuid, 
0x784d8933, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

//
// value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAME
//

PSTR MD5_AUTH_NAMES[] = {
    "username",
    "uri",
    "realm",
    "nonce",
    "response",
    "algorithm",
    "digest",
    "opaque",
    "qop",
    "cnonce",
    "nc"
};

//
//  Private prototypes
//


VOID
LogMd5Event(
    DWORD dwId,
    WORD  wType,
    LPSTR pszUser,
    LPSTR pszRealm
    )
/*++

Routine Description:

    Log an event

Arguments:

    dwId - event ID ( from iismap\mapmsg.h )
    wType - event type
    pszUser - user name
    pszRealm - realm

Return Value:

    Nothing

--*/
{
    LPCTSTR pA[2];

    pA[0] = pszUser;
    pA[1] = pszRealm;

    ReportIisMapEvent( wType,
            dwId,
            2,
            pA );
}


VOID safe_strcpy( LPSTR pszDest,
                  LPSTR pszSource )
/*++

Routine Description:

    strcpy used to make sure that GetLanGroupDomaiName() is thread-safe

Arguments:

    pszDest - pointer to destination buffer
    pszSource - pointer to source buffer

Return Value:

    Nothing

--*/

{
    while ( *pszSource )
    {
        *pszDest++ = *pszSource++;
    }
    *pszDest = '\0';
}

VOID
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )
/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/
{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}


BOOL HashData( BYTE *pbData,
               DWORD cbData,
               BYTE *pbHash )
/*++

Routine Description:

    Creates MD5 hash of input buffer

Arguments:

    pbData - data to hash
    cbData - size of data pointed to by pbData
    pbHash - buffer that receives hash; is assumed to be big enough to contain MD5 hash

Return Value:

    TRUE if successful, FALSE if not

--*/

{
    HCRYPTHASH hHash = NULL;

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptCreateHash() failed : 0x%x\n", GetLastError()));
        return FALSE;
    }

    if ( !CryptHashData( hHash,
                         pbData,
                         cbData,
                         0 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptHashData() failed : 0x%x\n", GetLastError()));
        
        CryptDestroyHash( hHash );
        return FALSE;
    }

    DWORD cbHash = MD5_HASH_SIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pbHash,
                             &cbHash,
                             0 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptGetHashParam() failed : 0x%x\n", GetLastError()));

        CryptDestroyHash( hHash );
        return FALSE;
    }

    CryptDestroyHash( hHash );
    return TRUE;
}


BOOL IsExpiredNonce( CHAR *pszRequestNonce,
                     CHAR *pszPresentNonce )
/*++

Routine Description:

    Checks whether nonce is expired or not by looking at the timestamp on the nonce
    that came in with the request and comparing it with the timestamp on the latest nonce

Arguments:

    pszRequestNonce - nonce that came in with request
    pszPresentNonce - latest nonce

Return Value:

    TRUE if nonce has expired, FALSE if not

--*/
{
    //
    // Timestamp is after first 2*RANDOM_SIZE bytes of nonce; also, note that
    // timestamp is time() mod NONCE_GRANULARITY, so all we have to do is simply
    // compare for equality to check that the request nonce hasn't expired
    //
    if ( memcmp( pszPresentNonce + 2*RANDOM_SIZE, 
                 pszRequestNonce + 2*RANDOM_SIZE,
                 TIMESTAMP_SIZE ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Nonce is expired.\n"));
        return TRUE;
    }

    return FALSE;
}

BOOL IsWellFormedNonce( CHAR *pszNonce )
/*++

Routine Description:

    Checks whether a nonce is "well-formed" by checking hash value, length etc 
    

Arguments:

    pszNonce - nonce to be checked

Return Value:

    TRUE if nonce is well-formed, FALSE if not

--*/

{
    if ( !pszNonce || ( strlen(pszNonce) != NONCE_SIZE ) )
    {
        DBGPRINTF((DBG_CONTEXT, "Nonce is not well-formed\n"));
        return FALSE;
    }

    //
    //Format of nonce : <random bytes><time stamp><hash of (secret,random bytes,time stamp)>
    // 
    DWORD dwSecretLen = sizeof("IISMD5") - 1;
    BYTE abBuffer[2*RANDOM_SIZE + TIMESTAMP_SIZE + sizeof("IISMD5") - 1];
    BYTE abHash[MD5_HASH_SIZE];
    CHAR achAsciiHash[2*MD5_HASH_SIZE + 1];

    DWORD cbBuffer = 2*RANDOM_SIZE + TIMESTAMP_SIZE + dwSecretLen;

    memcpy( abBuffer, "IISMD5", dwSecretLen );
    memcpy( abBuffer + dwSecretLen, pszNonce, 2*RANDOM_SIZE + TIMESTAMP_SIZE );

    if ( !HashData( abBuffer, 
                    2*RANDOM_SIZE + TIMESTAMP_SIZE + dwSecretLen,
                    abHash ) )
    {
        return FALSE;
    }
    ToHex( abHash, MD5_HASH_SIZE, achAsciiHash );

    if ( memcmp( achAsciiHash,
                 pszNonce + 2*RANDOM_SIZE + TIMESTAMP_SIZE,
                 2*MD5_HASH_SIZE ) )
    {
        DBGPRINTF((DBG_CONTEXT, "Nonce is not well-formed\n"));
        return FALSE;
    }

    return TRUE;
                    
}

BOOL 
GenerateNonce( 
    HTTP_FILTER_CONTEXT *      pfc
)
/*++

Routine Description:

    Generate nonce to be stored in user filter context. Nonce is

    <ASCII rep of Random><Time><ASCII of MD5(Secret:Random:Time)>

    Random = <8 random bytes>
    Time = <16 bytes, reverse string rep of result of time() call>
    Secret = 'IISMD5'

Arguments:

    pfc - filter context

Return Value:

    TRUE if success, FALSE if error

--*/
{
    PDIGEST_CONTEXT pC = (PDIGEST_CONTEXT)pfc->pFilterContext;
    DWORD cbNonce = 0;
    DWORD tNow = (DWORD)(time(NULL)/NONCE_GRANULARITY);

    if ( !pC )
    {
        return FALSE;
    }

    //
    // If nonce has timed out, generate a new one
    //
    if ( pC->tLastNonce < tNow )
    {
        DWORD dwSecretLen = sizeof("IISMD5")  - 1;
        BYTE abTempBuffer[ 2*RANDOM_SIZE + TIMESTAMP_SIZE + sizeof("IISMD5") - 1 ];
        DWORD cbTemp = 0;
        BYTE abDigest[MD5_HASH_SIZE];
        BYTE abRandom[RANDOM_SIZE];
        CHAR achAsciiDigest[2 * MD5_HASH_SIZE + 1];
        CHAR achAsciiRandom[2 * RANDOM_SIZE + 1];


        pC->tLastNonce = tNow;

        //
        // First, random bytes
        //
        if ( !CryptGenRandom( g_hCryptProv,
                              RANDOM_SIZE,
                              abRandom ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CryptGenRandom() failed : 0x%x\n", GetLastError()));
            return FALSE;
        }
        
        //
        // Convert to ASCII, doubling the length, and add to nonce 
        //
        ToHex( abRandom, RANDOM_SIZE, achAsciiRandom );
        memcpy( pC->achNonce + cbNonce, achAsciiRandom, 2 * RANDOM_SIZE );

        cbNonce += 2*RANDOM_SIZE;

        //
        // Next, reverse string representation of current time; pad with zeros if necessary
        //
        while ( tNow )
        {
            pC->achNonce[cbNonce++] = (CHAR)('0' + tNow % 10);
            tNow /= 10;
        }

        DBG_ASSERT( cbNonce < 2*RANDOM_SIZE + TIMESTAMP_SIZE );

        while ( cbNonce < 2*RANDOM_SIZE + TIMESTAMP_SIZE )
        {
            pC->achNonce[cbNonce++] = '0';
        }

        //
        // Now hash everything, together with a private key that's really difficult to guess,
        // like IISMD5 ;-)
        //
        // UNDONE : make this secret key a MB setting ?
        //
        strcpy( (CHAR *) abTempBuffer, "IISMD5" );

        memcpy( abTempBuffer + dwSecretLen, 
                pC->achNonce, 
                2*RANDOM_SIZE + TIMESTAMP_SIZE );

        cbTemp = 2*RANDOM_SIZE + TIMESTAMP_SIZE + dwSecretLen;

        if ( !HashData( abTempBuffer,
                        cbTemp,
                        abDigest ) )
        {
            return FALSE;
        }

        //
        // Convert to ASCII, doubling the length, and add to nonce 
        //
        ToHex( abDigest, MD5_HASH_SIZE, achAsciiDigest );
        memcpy( pC->achNonce + cbNonce, achAsciiDigest, 2*MD5_HASH_SIZE );
        
        //
        // terminate the nonce
        //
        pC->achNonce[NONCE_SIZE] = '\0';

    }

    return TRUE;
}

BOOL AllocateFilterContext(
    HTTP_FILTER_CONTEXT *      pfc
)
/*++

Routine Description:

    Allocate filter user context as a DIGEST_CONTEXT if not already done

Arguments:

    pfc - Filter Context

Return Value:

    TRUE if success, FALSE if error

--*/
{
    //
    // allocate filter context
    //

    if ( !pfc->pFilterContext )
    {
        pfc->pFilterContext = pfc->AllocMem( pfc, sizeof(DIGEST_CONTEXT), 0 );

        if ( !pfc->pFilterContext )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
        memset( pfc->pFilterContext, '\0', sizeof(DIGEST_CONTEXT) );
    }

    return TRUE;
}


LPSTR
SkipWhite(
    LPSTR p
    )
/*++

Routine Description:

    Skip white space and ','

Arguments:

    p - ptr to string

Return Value:

    updated ptr after skiping white space

--*/
{
    while ( isspace((UCHAR)(*p) ) || *p == ',' )
    {
        ++p;
    }

    return p;
}


BOOL ParseForName(
    PSTR pszStr,
    PSTR *pNameTable,
    UINT cNameTable,
    PSTR *pValueTable
    )
/*++

Routine Description:

    Parse list of name=value pairs for known names

Arguments:

    pszStr - line to parse ( '\0' delimited )
    pNameTable - table of known names
    cNameTable - number of known names
    pValueTable - updated with ptr to parsed value for corresponding name

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    PSTR pszBeginName;
    PSTR pszEndName;
    PSTR pszBeginVal;
    PSTR pszEndVal;
    UINT iN;
    int ch;


    for ( iN = 0 ; iN < cNameTable ; ++iN )
    {
        pValueTable[iN] = NULL;
    }

    for ( ; *pszStr && fSt ; )
    {
        pszStr = SkipWhite( pszStr );

        pszBeginName = pszStr;

        for ( pszEndName = pszStr ; (ch=*pszEndName) && ch != '=' && ch != ' ' ; ++pszEndName )
        {
        }

        if ( *pszEndName )
        {
            *pszEndName = '\0';
            pszEndVal = NULL;

            if ( !_stricmp( pszBeginName, "NC" ) )
            {
                for ( pszBeginVal = ++pszEndName ; (ch=*pszBeginVal) && !isxdigit((UCHAR)ch) ; ++pszBeginVal )
                {
                }
                
                if ( isxdigit((UCHAR)(*pszBeginVal)) )
                {
                    if ( strlen( pszBeginVal ) >= 8 )
                    {
                        pszEndVal = pszBeginVal + 8;
                    }
                }
            }
            else
            {   
                //
                // Actually this routine is not compatible with rfc2617 at all. It treats all 
                // values as quoted string which is not right. To fix the whole parsing problem, 
                // we will need to rewrite the routine. As for now, the following is a simple 
                // fix for whistler bug 95886. 
                //
                if( !_stricmp( pszBeginName, "qop" ) )
                {
                    BOOL fQuotedQop = FALSE;

                    for( pszBeginVal = ++pszEndName; ( ch=*pszBeginVal ) && ( ch == '=' || ch == ' ' ); ++pszBeginVal )
                    {
                    }

                    if( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        fQuotedQop = TRUE;
                    }

                    for( pszEndVal = pszBeginVal; ( ch = *pszEndVal ); ++pszEndVal )
                    {
                        if( ch == '"' || ch == ' ' || ch == ',' || ch == '\0' )
                        {
                            break;
                        }
                    }

                    if( *pszEndVal != '"' && fQuotedQop )
                    {
                        pszEndVal = NULL;
                    }
                }
                else
                {                
                    for ( pszBeginVal = ++pszEndName ; (ch=*pszBeginVal) && ch != '"' ; ++pszBeginVal )
                    {
                    }
                    if ( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        for ( pszEndVal = pszBeginVal ; (ch=*pszEndVal) ; ++pszEndVal )
                        {
                            if ( ch == '"' )
                            {
                                break;
                            }
                        }
                        if ( *pszEndVal != '"' )
                        {
                            pszEndVal = NULL;
                        }
                    }
                }
            }
            
            if ( pszEndVal )
            {
                // find name in table
                for ( iN = 0 ; iN < cNameTable ; ++iN )
                {
                    if ( !_stricmp( pNameTable[iN], pszBeginName ) )
                    {
                        break;
                    }
                }
                if ( iN < cNameTable )
                {
                    pValueTable[iN] = pszBeginVal;
                }
                
                pszStr = pszEndVal;
                
                if ( *pszEndVal != '\0' )
                {
                    *pszEndVal = '\0';
                    pszStr++;
                }

                continue;
            }
        }
        
        fSt = FALSE;
    }

    return fSt;
}



BOOL 
GetLanGroupDomainName( 
    OUT CHAR *          pszDigestDomain,
    IN DWORD            cbDigestDomain
)
/*++

Routine Description:

    Tries to retrieve the "LAN group"/domain this machine is a member of.

Arguments:

    pszDigestDomain - string updated with the domain name on success
    cbDigestDomain - size of domain buffer

Returns:

    TRUE if success, FALSE if failure


--*/
{
    static CHAR achDomainName[IIS_DNLEN + 1];
    static BOOL fInitialized = FALSE;
    BOOL fOK = TRUE;

    if ( cbDigestDomain < IIS_DNLEN+1 )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    // Only retrieve the domain name once
    // This routine is thread-safe by virtue of not doing any operation that it'd be
    // harmful to do twice; it's ok if several threads go through the loop that initializes
    // achDomainName because the strcpy at the end can be done several times with no ill effects
    //
    if ( !fInitialized )
    {
        NET_API_STATUS dwNASStatus = 0;
        NETSETUP_JOIN_STATUS JoinStatus;
        LPWSTR pwszInfo = NULL;

        if ( NT_SUCCESS( dwNASStatus = NetGetJoinInformation( NULL,
                                                              &pwszInfo,
                                                              &JoinStatus ) ) )
        {
            switch ( JoinStatus )
            {
            case NetSetupUnknownStatus:
                DBGPRINTF((DBG_CONTEXT,
                           "UnknownStatus returned from NetGetJoinInformation !\n"));
                *pszDigestDomain = '\0';
                break;

            case NetSetupUnjoined:
                //
                // No domain yet
                //
                DBGPRINTF((DBG_CONTEXT,
                           "UnjoinedStatus returned from NetGetJoinInformation !\n"));
                *pszDigestDomain = '\0';
                break;

            case NetSetupWorkgroupName:
                //
                // We need a domain to authenticate against, a workgroup won't do it
                //
                DBGPRINTF((DBG_CONTEXT,
                           "WorkgroupName returned from NetGetJoinInformation !\n"));
                *pszDigestDomain = '\0';
                break;

            case NetSetupDomainName:
                //
                // we got a domain, whee ....
                //
                if ( !pwszInfo )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Null pointer returned from NetGetJoinInformation !\n"));
                    fOK = FALSE;
                }
                else
                {
                    //
                    // If we don't have space for the name in the static buffer, we're
                    // in trouble
                    //
                    if ( wcslen( pwszInfo ) > IIS_DNLEN )
                    {
                        fOK = FALSE;
                    }
                    else
                    {
                        if ( !WideCharToMultiByte( CP_ACP,
                                                   0,
                                                   pwszInfo,
                                                   -1,
                                                   achDomainName,
                                                   IIS_DNLEN + 1,
                                                   NULL,
                                                   NULL ) )
                        {
                            fOK = FALSE;
                        }
                        else
                        {
                            //
                            // At this point, we should have a valid domain name
                            //
                            safe_strcpy( pszDigestDomain, achDomainName );
                            fInitialized = TRUE;
                        }
                    }

                    NetApiBufferFree( (LPVOID) pwszInfo );
                }
                break;

            default:
                DBGPRINTF((DBG_CONTEXT,
                           "Unknown value returned from NetGetJoinInformation !\n"));
                fOK = FALSE;
            }
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "NetGetJoinInformation failed with status 0x%x\n",
                       dwNASStatus));
            fOK = FALSE;
        }
    } // if ( achDomainName[0] == '\0'
    else
    {
        //
        // We've already retrieved the domain, just copy it 
        //
        strcpy( pszDigestDomain, achDomainName );
    }

    return fOK;
}

BOOL
SubAuthGetFilterVersion(
    VOID
)
/*++

Routine Description:

    Filter Init entry point

Arguments:

    None

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL fFirst;

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("md5filt");
#else
    CREATE_DEBUG_PRINT_OBJECT("md5filt", IisMD5FiltGuid);
#endif
    if (!VALID_DEBUG_PRINT_OBJECT()) {
        return FALSE;
    }

    //
    //  Get a handle to the CSP we'll use for all our hash functions etc
    //
    
    if ( !CryptAcquireContext( &g_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CryptAcquireContext() failed : 0x%x\n", GetLastError()));
        return FALSE;
    }

    return TRUE;
}

BOOL
SubAuthTerminateFilter(
    DWORD                       dwFlags
)
/*++

Routine Description:

    Filter cleanup code

Arguments:

    dwFlags - unused

Return Value:

    TRUE if success, FALSE if error

--*/
{
    DELETE_DEBUG_PRINT_OBJECT();
        
    if ( g_hCryptProv )
    {
        CryptReleaseContext( g_hCryptProv,
                             0 );
        g_hCryptProv = NULL;
    }
    
    return TRUE;
}

BOOL
BreakUserAndDomain(
    IN LPSTR            pAcct,
    IN LPSTR            pszConfiguredAuthDomain,
    OUT LPSTR           achDomain,
    IN DWORD            cbDomain,
    OUT LPSTR           achNtUser,
    IN DWORD            cbUser
    )
/*++

Routine Description:

    Breaks up the supplied account into a domain and username; if no domain is specified
    in the account, tries to use either domain configured in metabase or domain the computer
    is a part of.

Arguments:

    pAcct - account, of the form domain\username or just username
    pszConfiguredAuthDomain - auth domain configured in metabase 
    achDomain - buffer filled in with domain to use for authentication, on success
    cbDomain - size of domain buffer
    achNtUser - buffer filled in with username on success
    cbUser - size of user buffer

Return Value:

    TRUE/FALSE indicating success/failure

--*/

{
    LPSTR pSep;
    LPSTR pUser;
    BOOL fContainsDomain = FALSE;

    // break in domain & user name
    // copy to local storage so we can unlock mapper object

#if 1 // DBCS enabling for user name
    if ( (pSep = (PCHAR)_mbschr( (PUCHAR)pAcct, '\\' )) )
#else
    if ( (pSep = strchr( pAcct, '\\' )) )
#endif
    {
        fContainsDomain = TRUE;
        if ( DIFF(pSep - pAcct) < cbDomain )
        {
            memcpy( achDomain, pAcct, DIFF(pSep - pAcct) );
            achDomain[ DIFF( pSep - pAcct ) ] = '\0';
        }
        else
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        pUser = pSep + 1;
    }
    else
    {
        achDomain[0] = '\0';
        pUser = pAcct;
    }
    if ( strlen( pUser ) >= cbUser )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }
    strcpy( achNtUser, pUser );

    //
    // If no domain name specified, try using the metabase-configured domain name; if that
    // is non-existent, try getting the name of the domain the computer is a part of 
    //
    
    if ( !fContainsDomain && achDomain[0] == '\0' )
    {
        if ( pszConfiguredAuthDomain && *pszConfiguredAuthDomain != '\0' )
        {
            if ( strlen( pszConfiguredAuthDomain ) >= cbDomain )
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                return FALSE;
            }
            strcpy( achDomain, pszConfiguredAuthDomain );
        }
        else
        {
            if ( !GetLanGroupDomainName( achDomain, cbDomain ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


DWORD
SubAuthHttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData
    )
/*++

Routine Description:

    Filter notification entry point

Arguments:

    pfc -              Filter context
    NotificationType - Type of notification
    pvData -           Notification specific data

Return Value:

    One of the SF_STATUS response codes

--*/
{
    DWORD                 dwRet;
    BOOL                  fAllowed;
    CHAR                  achUser[SF_MAX_USERNAME];
    CHAR                  achMethod[256];
    CHAR                  achRealm[256];
    DWORD                 cbRealm;
    DWORD                 cbMethod;
    HTTP_FILTER_AUTHENTEX*pAuth;
    HTTP_FILTER_LOG *     pLog;
    CHAR *                pch;
    CIisMapping *         pQuery;
    CIisMapping *         pResult = NULL;
    BOOL                  fFirst;
    LPSTR                 aValueTable[ MD5_AUTH_LAST ];
    BOOL                  fStale;
    LPSTR                 pszA2;
    LPSTR                 pszH;
    LPSTR                 pAcct;
    BOOL                  fMd5;
    BOOL                  fNtDigest = FALSE;
    CHAR                  achDomain[IIS_DNLEN+1];
    CHAR                  achNtUser[64];
    CHAR                  achCookie[64];
    CHAR                  achPwd[64];
    LPSTR                 pPwd;
    LPSTR                 pNtPwd;
    CHAR                  achUrl[MAX_URL_SIZE];
    CHAR                  achDigestUri[MAX_URL_SIZE];
    DWORD                 cbUrl;
    LPSTR                 pSep;
    LPSTR                 pUser;
    BOOL                  fSt;
    BOOL                  fRetNow = FALSE;
    CIisMd5Mapper*        pMd5Mapper = NULL;
    RefBlob*              pBlob = NULL;
    BOOL                  fQOPAuth = FALSE;

    //
    //  Handle this notification
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_ACCESS_DENIED:

        if ( pfc->ServerSupportFunction( pfc,
                                    SF_REQ_GET_PROPERTY,
                                    (LPVOID)&fMd5,
                                    (UINT)SF_PROPERTY_MD5_ENABLED,
                                    NULL ) && fMd5 )
        {
            cbRealm = sizeof(achRealm);

            if ( !AllocateFilterContext( pfc ) ||
                 !GenerateNonce( pfc ) ||
                 !pfc->GetServerVariable( pfc,
                                          "HTTP_REQ_REALM",
                                          achRealm,
                                          &cbRealm ) )
            {
                return SF_STATUS_REQ_ERROR;
            }

            fStale = ((PDIGEST_CONTEXT)pfc->pFilterContext)->fStale;

#ifdef NT_DIGEST
            wsprintf( achMethod,
                      "WWW-Authenticate: Digest realm=\"%s\", nonce=\"%s\"%s\r\n"
                      "WWW-Authenticate: NT-Digest realm=\"%s\", nonce=\"%s\"%s\r\n",
                      achRealm,
                      ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce,
                      fStale ? ", stale=\"true\"" : "" ,
                      achRealm,
                      ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce,
                      fStale ? ", stale=\"true\"" : "" );
#else
            wsprintf( achMethod,
                      "WWW-Authenticate: Digest qop=\"auth\", realm=\"%s\", nonce=\"%s\"%s\r\n",
                      achRealm,
                      ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce,
                      fStale ? ", stale=\"true\"" : ""  );
#endif //NT_DIGEST

            if ( !pfc->ServerSupportFunction( pfc,
                                              SF_REQ_ADD_HEADERS_ON_DENIAL,
                                              achMethod,
                                              NULL,
                                              NULL) )
            {
                return SF_STATUS_REQ_ERROR;
            }
        }

        break;

    case SF_NOTIFY_AUTHENTICATIONEX:

        pAuth = (HTTP_FILTER_AUTHENTEX *) pvData;

        //
        //  Ignore the anonymous user ( mapped by IIS )
        //

        if ( !*pAuth->pszPassword )
        {
            fRetNow = TRUE;
        }
        else
        {
            if ( !_stricmp( pAuth->pszAuthType, "NT-Digest" ) )
            {
                fNtDigest = TRUE;
            }
            else if ( _stricmp( pAuth->pszAuthType, "Digest" ) )
            {
                fRetNow = TRUE;
            }
        }

        if ( fRetNow )
        {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        //
        // make sure filter context is allocated
        //

        if ( !AllocateFilterContext( pfc ) )
        {
            return SF_STATUS_REQ_ERROR;
        }
        ((PDIGEST_CONTEXT)pfc->pFilterContext)->fStale = FALSE;


        if ( !ParseForName( pAuth->pszPassword,
                            MD5_AUTH_NAMES,
                            MD5_AUTH_LAST,
                            aValueTable ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return SF_STATUS_REQ_ERROR;
        }
        
        if ( aValueTable[MD5_AUTH_USERNAME] == NULL ||
             aValueTable[MD5_AUTH_REALM] == NULL ||
             aValueTable[MD5_AUTH_URI] == NULL ||
             aValueTable[MD5_AUTH_NONCE] == NULL ||
             aValueTable[MD5_AUTH_RESPONSE] == NULL )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return SF_STATUS_REQ_ERROR;
        }
        
        if ( aValueTable[MD5_AUTH_QOP] != NULL )
        {
            if ( _stricmp( aValueTable[MD5_AUTH_QOP], "auth" ) )
            {
                SetLastError( ERROR_NOT_SUPPORTED );
                return SF_STATUS_REQ_ERROR;
            }
            
            if ( aValueTable[MD5_AUTH_CNONCE] == NULL ||
                 aValueTable[MD5_AUTH_NC] == NULL )
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                return SF_STATUS_REQ_ERROR;
            }
            
            fQOPAuth = TRUE;
        }
        else
        {
            aValueTable[MD5_AUTH_QOP] = "none";
            aValueTable[MD5_AUTH_CNONCE] = "none";
            aValueTable[MD5_AUTH_NC] = "none";
        }

        cbMethod = sizeof(achMethod);
        if ( !pfc->GetServerVariable( pfc,
                                      "REQUEST_METHOD",
                                      achMethod,
                                      &cbMethod ))
        {
            return SF_STATUS_REQ_ERROR;
        }

        //
        // Check URI field match URL
        //

        if ( strlen(aValueTable[MD5_AUTH_URI]) > MAX_URL_SIZE )
        {
            return SF_STATUS_REQ_ERROR;
        }

        //
        // Verify that the nonce is well-formed
        //
        if ( !IsWellFormedNonce( aValueTable[MD5_AUTH_NONCE] ) )
        {
            SetLastError( ERROR_ACCESS_DENIED );

            return SF_STATUS_REQ_ERROR;
        }

        strcpy( achDigestUri, aValueTable[MD5_AUTH_URI] );
        cbUrl = sizeof( achUrl );

        if ( !pfc->ServerSupportFunction( pfc,
                                          SF_REQ_NORMALIZE_URL,
                                          achDigestUri,
                                          NULL,
                                          NULL) ||
             !pfc->GetServerVariable( pfc,
                                     "URL_PATH_INFO",
                                     achUrl,
                                     &cbUrl ) )
        {
            return SF_STATUS_REQ_ERROR;
        }

        if ( strcmp( achDigestUri, achUrl ) )
        {
            SetLastError( ERROR_ACCESS_DENIED );

            return SF_STATUS_REQ_ERROR;
        }

        //
        //  Save the unmapped username so we can log it later
        //

        if ( strlen(aValueTable[MD5_AUTH_USERNAME]) < pAuth->cbUserBuff )
        {
            strcpy( pAuth->pszUser, aValueTable[MD5_AUTH_USERNAME] );
        }

        if ( strlen(aValueTable[MD5_AUTH_USERNAME]) < sizeof(achUser) )
        {
            strcpy( achUser, aValueTable[MD5_AUTH_USERNAME] );
        }

        if ( 1 || fNtDigest )
        {
            DIGEST_LOGON_INFO           DigestLogonInfo;
            
            if ( !GenerateNonce( pfc ) )
            {
                return SF_STATUS_REQ_ERROR;
            }

            if ( !BreakUserAndDomain( aValueTable[MD5_AUTH_USERNAME],
                                      pAuth->pszAuthDomain,
                                      achDomain,
                                      sizeof( achDomain ),
                                      achNtUser,
                                      sizeof( achNtUser ) ) )
            {
                return SF_STATUS_REQ_ERROR;
            }
            
            if ( strlen( aValueTable[MD5_AUTH_USERNAME] )
                 < pAuth->cbLogonUserBuff )
            {
                strcpy( pAuth->pszLogonUser, aValueTable[MD5_AUTH_USERNAME] );
            }
            
            DigestLogonInfo.pszNtUser = achNtUser;
            DigestLogonInfo.pszDomain = achDomain;
            DigestLogonInfo.pszUser = aValueTable[MD5_AUTH_USERNAME];
            DigestLogonInfo.pszRealm = aValueTable[MD5_AUTH_REALM];
            DigestLogonInfo.pszURI = aValueTable[MD5_AUTH_URI];
            DigestLogonInfo.pszMethod = achMethod;
            DigestLogonInfo.pszNonce = aValueTable[MD5_AUTH_NONCE];
            DigestLogonInfo.pszCurrentNonce = ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce;
            DigestLogonInfo.pszCNonce = aValueTable[MD5_AUTH_CNONCE];
            DigestLogonInfo.pszQOP = aValueTable[MD5_AUTH_QOP];
            DigestLogonInfo.pszNC = aValueTable[MD5_AUTH_NC];
            DigestLogonInfo.pszResponse = aValueTable[MD5_AUTH_RESPONSE];

            fSt = LogonDigestUserA( &DigestLogonInfo,
                                    (fNtDigest ? IISSUBA_NT_DIGEST : IISSUBA_DIGEST ),
                                    &pAuth->hAccessTokenImpersonation );

            //
            // Response from the client was correct but the nonce has expired,
            // 
            if ( fSt && 
                 IsExpiredNonce( aValueTable[MD5_AUTH_NONCE],
                                 ((PDIGEST_CONTEXT)pfc->pFilterContext)->achNonce ) )
            {
                goto stalled_nonce;
            }

            goto logged_on;
        }


stalled_nonce:
       ((PDIGEST_CONTEXT)pfc->pFilterContext)->fStale = TRUE;
       // do not log stalled authentication
       SetLastError( ERROR_ACCESS_DENIED );
       return SF_STATUS_REQ_ERROR;

logged_on:
        if ( !fSt )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Digest logon failed : 0x%x\n", GetLastError()));
            pAuth->hAccessTokenImpersonation = NULL;

            return SF_STATUS_REQ_ERROR;
        }

        //
        //  Save the unmapped user name so we can log it later on.  We allocate
        //  enough space for two usernames so we can use this memory block
        //  for logging.  Note we may have already allocated it from a previous
        //  request on this TCP session
        //

        strcpy( ((PDIGEST_CONTEXT)pfc->pFilterContext)->achUserName, achUser );

        return SF_STATUS_REQ_HANDLED_NOTIFICATION;

    case SF_NOTIFY_LOG:

        //
        //  The unmapped username is in pFilterContext if this filter
        //  authenticated this user
        //

        if ( pfc->pFilterContext )
        {
            pch  = ((PDIGEST_CONTEXT)pfc->pFilterContext)->achUserName;
            pLog = (HTTP_FILTER_LOG *) pvData;

            //
            //  Put both the original username and the NT mapped username
            //  into the log in the form "Original User (NT User)"
            //

            if ( strchr( pch, '(' ) == NULL )
            {
                strcat( pch, " (" );
                strcat( pch, pLog->pszClientUserName );
                strcat( pch, ")" );
            }

            pLog->pszClientUserName = pch;
        }

        return SF_STATUS_REQ_NEXT_NOTIFICATION;

    default:

        break;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\homescrp\homescrp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sampfilt.c

Abstract:

    This module shows how to replace a particular url

Author:

    John Ludeman (johnl)   13-Oct-1995

Revision History:
--*/

#include <windows.h>
#include <httpfilt.h>

//
//  This could be to a file or other output device
//

#define DEST               buff
#define Write( x )         {                                    \
                                char buff[256];                 \
                                wsprintf x;                     \
                                OutputDebugString( buff );      \
                           }

//
//  Private prototypes
//

DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    );

//
//  Globals
//

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
    Write(( DEST,
            "[GetFilterVersion] Server filter version is %d.%d\n",
            HIWORD( pVer->dwServerFilterVersion ),
            LOWORD( pVer->dwServerFilterVersion ) ));

    pVer->dwFilterVersion = MAKELONG( 0, 1 );   // Version 1.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
                     SF_NOTIFY_NONSECURE_PORT     |

                     SF_NOTIFY_PREPROC_HEADERS    |

                     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "URL Redirector, v1.0" );

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData
    )
{
    DWORD dwRet;

    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_PREPROC_HEADERS:

        dwRet = OnPreprocHeaders( pfc,
                                  (PHTTP_FILTER_PREPROC_HEADERS) pvData );
        break;

    default:
        Write(( DEST,
                "[HttpFilterProc] Unknown notification type, %d\n",
                NotificationType ));

        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwRet;
}


DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    )
{
    CHAR  achUrl[2048];
    DWORD cb;

    //
    //  Get the url and user agent fields
    //

    cb = sizeof( achUrl );

    if ( !pvData->GetHeader( pfc,
                             "url",
                             achUrl,
                             &cb ))
    {
        return SF_STATUS_REQ_ERROR;
    }

    //
    //  Redirect as appropriate
    //

    if ( achUrl[0] == '/' && achUrl[1] == '\0' )
    {
        if ( !pvData->SetHeader( pfc,
                                 "url",
                                 "/scripts/env.bat" ))
        {
            return SF_STATUS_REQ_ERROR;
        }
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\compress\inc\compfilt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    compfilt.h

Abstract:

    Global header file for the ISAPI compression filter.

Author:

    David Treadwell (davidtr)   8-April-1997

Revision History:

--*/

#ifndef __COMPFILT__
#define __COMPFILT__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "dbgutil.h"
#include <iisfilt.h>
#include <iisfiltp.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ole2.h>
#include <coguid.h>

#include <iadmw.h>
#include <iiscnfg.h>
#include <iis64.h>
#include <tsunami.hxx>
#include <tscache.hxx>

extern "C" {
#include "api.h"
}

#ifdef CMDLINE
#include <stdio.h>
#endif

//
//  This could be to a file or other output device
//

#if DBG

extern BOOL EnableDbgPrints;

#define DEST               __buff

#ifdef CMDLINE
#define Write( x )         {                                        \
                                if ( EnableDbgPrints ) {            \
                                    char __buff[1024];              \
                                    wsprintf x;                     \
                                    printf( __buff );               \
                                }                                   \
                           }
#else

#define Write( x )         {                                        \
                                if ( EnableDbgPrints ) {            \
                                    char __buff[1024];              \
                                    wsprintf x;                     \
                                    OutputDebugString( __buff );    \
                                }                                   \
                           }
#endif

#else

#define DEST
#define Write( x )

#endif

#ifdef CMDLINE
#define DISPLAY( x ) printf( x )
#else
#define DISPLAY( x )
#endif


//
// Manifest constants.
//

#define MAX_CLIENT_COMPRESSION_SCHEMES 20

//
// Private structures and data.
//

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );

typedef
VOID
(*PMETABASE_ID_CHANGE_HANDLER)(
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    );

typedef struct _METABASE_DATA {
    DWORD dwIdentifier;
    DWORD dwValueType;
    PVOID pvResult;
    DWORD dwOffset;
    PVOID DefaultValue;
    DWORD dwMinimum;
    DWORD dwMaximum;
    PMETABASE_ID_CHANGE_HANDLER pChangeHandler;
} METABASE_DATA, *PMETABASE_DATA;

typedef struct _COMPRESSION_REQUEST_CONTEXT {
    CHAR achAcceptEncoding[512];
} COMPRESSION_REQUEST_CONTEXT, *PCOMPRESSION_REQUEST_CONTEXT;

typedef struct _SUPPORTED_COMPRESSION_SCHEME {
    LPSTR pszCompressionSchemeName;
    LPSTR pszCompressionSchemeNamePrefix;
    LPSTR pszResponseHeaders;
    LPSTR pszMimeType;
    LPSTR *ppszFileExtensions;
    LPSTR *ppszScriptFileExtensions;
    LPSTR pszCompressionDll;
    DWORD dwPriority;
    HMODULE hDllHandle;
    PFNCODEC_INIT_COMPRESSION InitCompressionRoutine;
    PFNCODEC_INIT_DECOMPRESSION InitDecompressionRoutine;
    PFNCODEC_DEINIT_COMPRESSION DeinitCompressionRoutine;
    PFNCODEC_DEINIT_DECOMPRESSION DeinitDecompressionRoutine;
    PFNCODEC_CREATE_COMPRESSION CreateCompressionRoutine;
    PFNCODEC_CREATE_DECOMPRESSION CreateDecompressionRoutine;
    PFNCODEC_COMPRESS CompressRoutine;
    PFNCODEC_DECOMPRESS DecompressRoutine;
    PFNCODEC_DESTROY_COMPRESSION DestroyCompressionRoutine;
    PFNCODEC_DESTROY_DECOMPRESSION DestroyDecompressionRoutine;
    PFNCODEC_RESET_COMPRESSION ResetCompressionRoutine;
    PFNCODEC_RESET_DECOMPRESSION ResetDecompressionRoutine;
    PVOID CompressionContext;
    DWORD DynamicCompressionLevel;
    DWORD OnDemandCompressionLevel;
    DWORD CreateFlags;
    BOOL DoDynamicCompression;
    BOOL DoStaticCompression;
    BOOL DoOnDemandCompression;
} SUPPORTED_COMPRESSION_SCHEME, *PSUPPORTED_COMPRESSION_SCHEME;

typedef struct _COMPRESSION_WORK_ITEM {
    LIST_ENTRY ListEntry;
    PWORKER_THREAD_ROUTINE WorkRoutine;
    PVOID Context;
} COMPRESSION_WORK_ITEM, *PCOMPRESSION_WORK_ITEM;

typedef struct _COMPRESS_FILE_INFO {
    COMPRESSION_WORK_ITEM WorkItem;
    PSUPPORTED_COMPRESSION_SCHEME CompressionScheme;
    LPSTR OutputFileName;
    FILETIME ftOriginalLastWriteTime;
    CHAR pszPhysicalPath[MAX_PATH];
} COMPRESS_FILE_INFO, *PCOMPRESS_FILE_INFO;
typedef enum {
    IN_CHUNK_LENGTH,
    IN_CHUNK_EXTENSION,
    IN_CHUNK_HEADER_NEW_LINE,
    IN_CHUNK_DATA_NEW_LINE,
    AT_CHUNK_DATA_NEW_LINE,
    CHUNK_DATA_DONE,
    IN_CHUNK_DATA
}   COMPRESS_CHUNK_STATE, *PCOMPRESS_CHUNK_STATE;
typedef struct _COMPFILT_FILTER_CONTEXT {
    BOOLEAN RequestHandled;
    BOOLEAN OnSendResponseCalled;
    BOOLEAN HeaderPassed;
    BOOLEAN InEndOfRequest;
    BOOLEAN DynamicRequest;
    BOOLEAN TransferChunkEncoded;
    PSUPPORTED_COMPRESSION_SCHEME Scheme;
    PVOID CompressionContext;
    DWORD ChunkedBytesRemaining;
    COMPRESS_CHUNK_STATE pcsState;
    BYTE    HeadersNewLineStatus;
} COMPFILT_FILTER_CONTEXT, *PCOMPFILT_FILTER_CONTEXT;


typedef enum {
    DO_STATIC_COMPRESSION,
    DO_DYNAMIC_COMPRESSION,
    DONT_DO_COMPRESSION
}   COMPRESSION_TO_PERFORM, *PCOMPRESSION_TO_PERFORM;


// an id that this work item is not for compression but for deleting
#define ID_FOR_FILE_DELETION_ROUTINE    ((PSUPPORTED_COMPRESSION_SCHEME)((ULONG_PTR)(0xfffffff0)))

//
// Some manifests to handle the COMPFILT_FILTER_CONTEXT structure.  For
// a successful static compression request, the pfc->pFilterContext
// structure gets set to COMPFILT_SUCCESSFUL_STATIC.  For potentially
// successful dynamic compression, pfc->pFilterContext gets set to a
// pointer to a COMPFILT_FILTER_CONTEXT structure.
//

#define COMPFILT_SUCCESSFUL_STATIC ( (PVOID)((ULONG_PTR)(0xCF0000CF)) )
#define COMPFILT_URLMAP_DONE ( (PVOID)((ULONG_PTR)(0xCF0000CE)) )
#define COMPFILT_NO_COMPRESSION ( (PVOID)((ULONG_PTR)(0xCF0000CD)) )

#define GET_COMPFILT_CONTEXT( pfc )                                \
    ( ( ( (pfc)->pFilterContext == COMPFILT_SUCCESSFUL_STATIC ) || \
        ( (pfc)->pFilterContext == COMPFILT_NO_COMPRESSION ) || \
        ( (pfc)->pFilterContext == COMPFILT_URLMAP_DONE ) ) ? NULL : \
      (pfc)->pFilterContext )
#define IS_SUCCESSFUL_STATIC( pfc )                                \
    ( (pfc)->pFilterContext == COMPFILT_SUCCESSFUL_STATIC )
#define IS_URLMAP_DONE( pfc )                                \
    ( (pfc)->pFilterContext == COMPFILT_URLMAP_DONE )

/*
#define SET_SUCCESSFUL_STATIC( pfc )                               \
    { ASSERT( ((pfc->pFilterContext) == NULL) || ((pfc->pFilterContext) == COMPFILT_URLMAP_DONE) );                       \
      (pfc)->pFilterContext = COMPFILT_SUCCESSFUL_STATIC; }
      */

#define SET_SUCCESSFUL_STATIC( pfc )                               \
    {  (pfc)->pFilterContext = COMPFILT_SUCCESSFUL_STATIC; }


#define SET_URLMAP_DONE( pfc )                               \
      (pfc)->pFilterContext = COMPFILT_URLMAP_DONE;
#define SET_REQUEST_DONE( pfc )                               \
      (pfc)->pFilterContext = NULL;


// notification flags
#define ALL_NOTIFICATIONS (0xffffffff)
#define RAW_DATA_AND_END_OF_REQ (SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_END_OF_REQUEST )

// mask for clearing bits when comparing file ackls
#define ACL_CLEAR_BIT_MASK (~(SE_DACL_AUTO_INHERITED |      \
                              SE_SACL_AUTO_INHERITED |      \
                              SE_DACL_PROTECTED      |      \
                              SE_SACL_PROTECTED))


// bit fileds for double new line tracking in sendrawdata
#define HEADERS_NEW_LINE_STATUS_0A  0x01
#define HEADERS_NEW_LINE_STATUS_0D  0x04
#define HEADERS_NEW_LINE_STATUS_COMPLETE 0x0a //HEADERS_NEW_LINE_STATUS_0A* 2 +HEADERS_NEW_LINE_STATUS_0D*2

extern PSUPPORTED_COMPRESSION_SCHEME SupportedCompressionSchemes[];

extern LPSTR CompressionDirectory;
extern LPSTR CacheControlHeader;
extern LPSTR ExpiresHeader;
extern BOOL DoDynamicCompression;
extern BOOL DoStaticCompression;
extern BOOL DoOnDemandCompression;
extern BOOL DoDiskSpaceLimiting;
extern BOOL NoCompressionForHttp10;
extern BOOL NoCompressionForProxies;
extern BOOL NoCompressionForRangeRequests;
extern BOOL SendCacheHeaders;
extern BOOL CompressStaticFiles;
extern DWORD MaxDiskSpaceUsage;
extern DWORD IoBufferSize;
extern PBYTE IoBuffer;
extern DWORD CompressionBufferSize;
extern PBYTE CompressionBuffer;
extern DWORD MaxQueueLength;
extern DWORD FilesDeletedPerDiskFree;
extern DWORD MinFileSizeForCompression;

extern CHAR CompressionDirectoryWildcard[];
extern CRITICAL_SECTION CompressionDirectoryLock;
extern HANDLE hThreadEvent;
extern LIST_ENTRY CompressionThreadWorkQueue;
extern CRITICAL_SECTION CompressionThreadLock;
extern DWORD CurrentQueueLength;
extern DWORD CurrentDiskSpaceUsage;
extern HANDLE CompressionThreadHandle;
extern BOOL CompressionVolumeIsFat;
extern DWORD NotificationFlags;
extern BOOL IsTerminating;

//
//  Private prototypes
//

BOOL
AdjustFilterFlags(
    PVOID   pfnSFProc,
    DWORD   dwNewFlags
    );

VOID
BuildMetadataRecordForSet (
    IN PMETABASE_DATA Data,
    OUT PMETADATA_RECORD mdrMDData
    );

BOOL
CalculateDiskSpaceUsage (
    VOID
    );

BOOL
CompressAndSendDataToClient (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme,
    IN PVOID CompressionContext,
    IN PBYTE InputBuffer,
    IN DWORD BytesToCompress,
    IN PHTTP_FILTER_CONTEXT pfc
    );

BOOL
CompressAndWriteData (
    PSUPPORTED_COMPRESSION_SCHEME Scheme,
    PBYTE InputBuffer,
    DWORD BytesToCompress,
    PDWORD BytesWritten,
    HANDLE hCompressedFile
    );

VOID
CompressFile (
    IN PVOID Context
    );

DWORD
CompressionThread (
    IN PVOID Dummy
    );

VOID
ConvertPhysicalPathToCompressedPath (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme,
    IN PSTR pszPhysicalPath,
    OUT PSTR pszCompressedPath,
    OUT PDWORD cbCompressedPath
    );

BOOL
DoesCacheControlNeedMaxAge (
    IN PCHAR CacheControlHeaderValue
    );

DWORD
FindMatchingScheme (
    IN DWORD dwSchemeIndex,
    IN LPSTR ClientCompressionArray[],
    IN DWORD dwClientCompressionCount,
    IN LPSTR FileExtension,
    IN COMPRESSION_TO_PERFORM performCompr
    );

VOID
FreeDiskSpace (
    VOID
    );

VOID
DeleteChunkExtension (
    IN OUT PBYTE *Start,
    IN OUT PDWORD Bytes,
    IN OUT PCOMPRESS_CHUNK_STATE pcsState
    );

VOID
GetChunkedByteCount (
    IN OUT PBYTE *Start,
    IN OUT PDWORD Bytes,
    IN OUT PDWORD pdwChunkDataLen,
    IN OUT PCOMPRESS_CHUNK_STATE pcsState
    );

VOID
ProcessChunkHeader (
    IN OUT PBYTE *Start,
    IN OUT PDWORD Bytes,
    IN OUT PDWORD pdwChunkDataLen,
    IN OUT PCOMPRESS_CHUNK_STATE pcsState
    );

BOOL
Initialize (
    VOID
    );

BOOL
InitializeCompressionDirectory (
    VOID
    );

BOOL
InitializeCompressionScheme (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme
    );

BOOL
InitializeCompressionThread (
    VOID
    );

DWORD
OnEndOfRequest(
    PHTTP_FILTER_CONTEXT pfc
    );

DWORD
OnSendRawData (
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_RAW_DATA pvData,
    IN BOOL InEndOfRequest
    );

DWORD
OnSendResponse (
    PHTTP_FILTER_CONTEXT pfc,
    PHTTP_FILTER_SEND_RESPONSE pvData
    );

BOOL
CheckForExistenceOfCompressedFile (
    IN  LPSTR fileName,
    IN  LPTS_OPEN_FILE_INFO pofiOriginalFile,
    IN  BOOL  dDeleteAllowed = TRUE
    );

void 
DisableNotifications (
    PHTTP_FILTER_CONTEXT pfc,
    DWORD   flags,
    PVOID   pfcStatus
    );

DWORD
OnUrlMap (
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_URL_MAP pvData
    );

BOOL
QueueCompressFile (
    IN PSUPPORTED_COMPRESSION_SCHEME Scheme,
    IN PSTR pszPhysicalPath,
    IN FILETIME *pftOriginalLastWriteTime
    );

BOOL
QueueWorkItem (
    IN PWORKER_THREAD_ROUTINE WorkRoutine,
    IN PVOID Context,
    IN PCOMPRESSION_WORK_ITEM WorkItem OPTIONAL,
    IN BOOLEAN MustSucceed,
    IN BOOLEAN QueueAtHead
    );

BOOL
ReadCompressionSchemes (
    IN METADATA_HANDLE hMd
    );

VOID
ReadMetabaseValue (
    IN METADATA_HANDLE hMd,
    IN LPWSTR pszParentPath,
    IN DWORD dwIdentifier,
    IN DWORD dwValueType,
    IN PVOID pvResult,
    IN PVOID DefaultValue,
    IN DWORD Minimum,
    IN DWORD Maximum
    );

VOID
Terminate (
    VOID
    );

INT
CheckMetabaseValue(
    IN METADATA_HANDLE hmdParentHandle,
    IN PMETABASE_DATA Data,
    IN LPWSTR pszMDPath
    );

HRESULT
WriteMetabaseValue (
    IN METADATA_HANDLE hmdParentHandle,
    IN PMETABASE_DATA Data,
    IN LPWSTR pszMDPath
    );

//
// Metabase change handler routines.
//

VOID
CompressionDirectoryChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    );

VOID
DoDiskSpaceChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    );

VOID
DoDynamicChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    );

VOID
DoStaticChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    );

VOID
GlobalMetabaseChangeHandler (
    IN DWORD dwIdentifier,
    IN METADATA_HANDLE hmdParentHandle
    );

#endif // ndef __COMPFILT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\md5filt\md5filt.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation


Module Name:

    md5filt.cxx

Abstract:

    Wrapper module which will call either new Digest SSP code or old
    (subauth) implementation.
    
    Except for init/cleanup; in this case both are called

--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

};

#include <iisfiltp.h>
#include "authfilt.h"
#include "sspdigest.h"

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
/*++

Routine Description:

    Get filter version (calls all initialization code)

Arguments:

    pVer - Version

Returns:

    TRUE if success, FALSE if failure

--*/
{
    if ( !SubAuthGetFilterVersion() )
    {
        return FALSE;
    } 
    
    if ( !SSPGetFilterVersion() )
    {
        //
        // The Digest SSP isn't installed on NT yet
        //
        
        // return FALSE;
    }

    //
    // Set the version of the filter
    //
    pVer->dwFilterVersion = MAKELONG(0, 2);//2.0
    
    //
    // Set the description of the filter 
    //
    strcpy( pVer->lpszFilterDesc, "Digest Authentication, version 2.0");

    //
    //set the flag of the filter
    //
    pVer->dwFlags = (SF_NOTIFY_ACCESS_DENIED        | 
                     SF_NOTIFY_END_OF_NET_SESSION   |
                     SF_NOTIFY_ORDER_HIGH           |
                     SF_NOTIFY_AUTHENTICATIONEX     |
                     SF_NOTIFY_LOG );

    return TRUE;
}

BOOL
WINAPI
TerminateFilter(
    DWORD               dwFlags
    )
/*++

Routine Description:

    Do filter cleanup

Arguments:

    None

Returns:

    TRUE if success, FALSE if failure

--*/
{
    SSPTerminateFilter( dwFlags );
    
    SubAuthTerminateFilter( dwFlags );
    
    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType,
    LPVOID                      pvNotification
)
/*++

Routine Description:

    The filters notification routine

Arguments:

    pfc -              Filter context
    NotificationType - Type of notification
    pvData -           Notification specific data

Return Value:

    One of the SF_STATUS response codes

--*/
{
    BOOL                fUseSSP = FALSE;

    //
    // Joy.  We need to figure out what Digest path to execute for this
    // request.
    //
    
    if ( !pfc->ServerSupportFunction( pfc,
                                      SF_REQ_GET_PROPERTY,
                                      (LPVOID)&fUseSSP,
                                      (UINT)SF_PROPERTY_DIGEST_SSP_ENABLED,
                                      NULL ) )
    {
        return SF_STATUS_REQ_ERROR;
    }
    
    //
    // Choose the right digest support to use.
    //
    
    if ( fUseSSP )
    {
        return SSPHttpFilterProc( pfc,
                                  notificationType,
                                  pvNotification );
    }
    else
    {
        return SubAuthHttpFilterProc( pfc,
                                      notificationType,
                                      pvNotification );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\httpspy\httpspy.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    httpspy.c

Abstract:

    This module will dump the HTTP header on both requests and responses

Author:

    Cameron Ferroni (cameronf)  7-11-96

Revision History:
--*/

#include <windows.h>
#include <httpfilt.h>
#include <stdio.h>

//
//  This could be to a file or other output device
//

FILE *OutFile;

#define DEST               OutFile
#define Write( x )         {                                    \
                                fprintf x;                      \
                           }

//
//  Private prototypes
//

DWORD
OnReadRaw(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA * pvData
    );

DWORD
OnSendRawData(
    HTTP_FILTER_CONTEXT *   pfc,
    HTTP_FILTER_RAW_DATA *  pvData
    );

DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    );

DWORD
SendDenyMessage(
    HTTP_FILTER_CONTEXT * pfc
    );

//
//  Globals
//

//
// Hacky Context Number
//

DWORD ReqNumber=1000;

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
    OutFile=fopen("e:\\scripts\\httpspy.log","w");

    pVer->dwFilterVersion = MAKELONG( 0, 2 );   // Version 2.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_READ_RAW_DATA      |
                     SF_NOTIFY_SEND_RAW_DATA      |
                     SF_NOTIFY_END_OF_NET_SESSION |
                     SF_NOTIFY_ORDER_HIGH);

    strcpy( pVer->lpszFilterDesc, "HTTP Spy Filter, v1.0" );

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
{
    DWORD dwRet;


    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_READ_RAW_DATA:

        dwRet = OnReadRaw( pfc,
                           (PHTTP_FILTER_RAW_DATA) pvData );
        break;

    case SF_NOTIFY_SEND_RAW_DATA:

        dwRet = OnSendRawData( pfc,
                               (PHTTP_FILTER_RAW_DATA) pvData );
        break;

    case SF_NOTIFY_END_OF_NET_SESSION:

        dwRet = OnEndOfNetSession( pfc,
                                   (PHTTP_FILTER_LOG) pvData );

        //
        //  We would delete any allocated memory here
        //

        pfc->pFilterContext = 0;

        break;

    default:
        Write(( DEST,
                "[HttpFilterProc] Unknown notification type, %d\n",
                NotificationType ));

        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwRet;
}


DWORD
OnReadRaw(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA * pvData
    )
{
    DWORD cbText;
    CHAR  *pEndHeader;
    CHAR  cEndHeader; 
    CHAR  buff[1024];

    //
    // Start a new context for each request.  This is the best way to track the responses.
    //

    pfc->pFilterContext = (VOID *) ReqNumber++;

    //
    // Parse the Entire HTTP Header Out - put a NULL at the end of the
    // header and do a string copy.
    //

    if (pEndHeader=strstr(pvData->pvInData,"\r\n\r\n"))
    {
        pEndHeader += 4;
        cEndHeader = *pEndHeader;
        *pEndHeader = '\0';
    
        Write(( DEST,
                "[OnReadRaw] - Context #%d\n%s",
                pfc->pFilterContext,
                pvData->pvInData ));

        //
        // Restore the header marker
        // 

        *pEndHeader=cEndHeader;
    }

    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_READRAW" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnSendRawData(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA *  pvData
    )
{
    DWORD cbText;
    CHAR  *pEndHeader;
    CHAR  cEndHeader; 
    CHAR  buff[1024];

    // Parse the Entire HTTP Header Out - put a NULL at the end of the
    // header and do a string copy.
    //

    if(((CHAR *)pvData->pvInData)[0]=='H' &&
       ((CHAR *)pvData->pvInData)[1]=='T' &&
       ((CHAR *)pvData->pvInData)[2]=='T' &&
       ((CHAR *)pvData->pvInData)[3]=='P' &&
       (pEndHeader=strstr(pvData->pvInData,"\r\n\r\n")))
    {
        pEndHeader+=4;
        cEndHeader = *pEndHeader;
        *pEndHeader = '\0';
        
        Write(( DEST,
                "[OnSendRaw] - Context #%d\n%s",
                pfc->pFilterContext,
                pvData->pvInData ));
    
        //
        // Restore the header marker
        // 
    
        *pEndHeader=cEndHeader;
    }

    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_SENDRAW" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    )
{
    Write(( DEST,
            "%d [OnEndOfNetSession] End of request indicated\n",
            pfc->pFilterContext ));

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
SendDenyMessage(
    HTTP_FILTER_CONTEXT * pfc
    )
{
    DWORD cbText;

#define MESSAGE_TEXT    "I'm Terribly sorry but you have been denied access"

    pfc->ServerSupportFunction( pfc,
                                SF_REQ_SEND_RESPONSE_HEADER,
                                "401 Access Denied",
                                (DWORD) "WWW-Authenticate: Basic\r\n",
                                0 );

    cbText = sizeof(MESSAGE_TEXT) - sizeof(CHAR);

    pfc->WriteClient( pfc,
                      MESSAGE_TEXT,
                      &cbText,
                      0 );

    return SF_STATUS_REQ_FINISHED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\md5filt\sspdigest.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation


Module Name:

    sspdigest.cxx

Abstract:

    New digest support which uses Whistler's new server side digest SSP

Developed by:

    Andres Sanabria - AndresS@Microsoft.com
    Kevin Damour    - KDamour@Microsoft.com

Last Modification:
    6/11/00 adding DisableThreadLibraryCalls        
    6/11/00 changing the Allocate Memory after ASC  Succeed 
    6/11/00 solving when deleting a null the Context Handle on SF_NOTIFY_END_OF_NET_SESSION 
    6/11/00 adding DuplicateTocken to solve exemptions in InetInfo.exe                  
    6/11/00 moving content from the DLL_PROCESS_ATTACH to GetFilterVersion              
    6/11/00 adding CompleateAuthToken           
    6/11/00 removing the code that checks that the auth was digest
    6/13/00 changing from bStale to m_bStale
    6/13/00 removing fAreIdentical 
    6/13/00 Moving the case DLL_PROCESS_DETACH to the Terminate Filter function
    6/13/00 adding the implementation for the new secbuffer for the realm
    6/13/00 adding close handle in OnAuthenticatioEx in SEC_E_CONTEXT_EXPIRED to force Acces denied
    6/13/00 Adding g_MaxOutPutBuffSize , querying that information from the package

--*/

#ifdef __cplusplus
extern "C" {
#endif

#define SECURITY_WIN32   

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
#if 1 // DBCS
# include <mbstring.h>
#endif
#include <lmcons.h>
#include <lmjoin.h>

#ifdef __cplusplus
};
#endif


# include <iis64.h>
# include <inetcom.h>
# include <inetinfo.h>

//
//  System include files.
//

# include "dbgutil.h"
#include <tcpdll.hxx>
#include <tsunami.hxx>


extern "C" {

#include <tchar.h>

//
//  Project include files.
//

#include <time.h>
#include <w3svc.h>
#include <iisfiltp.h>
#include <sspi.h>

} // extern "C"

#include "sspdigest.h"

//////////////////////////////////////////////////////////////////////////////////////////////////
/// Global Variables
//////////////////////////////////////////////////////////////////////////////////////////////////
#define MAX_URL_SIZE        512
#define NTDIGEST_SP_NAME    "wdigest"

CredHandle  g_ServerCred;           // This is a global Credential handel used for authentication
TimeStamp   g_Lifetime;             // cotain the lifetime of the credenial handl
DWORD       g_cbMaxOutPutBuffSize =0;   // contains the max size of the buffer 

typedef struct _DIGEST_CONTEXT 
{
    CtxtHandle  m_CtxtHandle;
    BOOL        m_bStale;
    DWORD       m_Reserve;
} 
DIGEST_CONTEXT, *PDIGEST_CONTEXT;

BOOL 
SSPGetFilterVersion(
    VOID
)
/*++
Routine Description:

    Do SSP initialization

Arguments:

    None

Return Value:
    TRUE    your filter to remain loaded and working properly
    FALSE   IIS will not send the filter any notifications
--*/
{
    SECURITY_STATUS     secStatus       = SEC_E_OK;
    PSecPkgInfo         pPackageInfo    = NULL;

    //
    //  Get a Credential handle
    //
    secStatus = AcquireCredentialsHandle(
                    NULL,               // New principal
                    NTDIGEST_SP_NAME,   // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &g_ServerCred,
                    &g_Lifetime );

    if (FAILED(secStatus)) 
    {
        return (FALSE); 
    }
    else
    {
        // getting the package size
        secStatus = QuerySecurityPackageInfo( NTDIGEST_SP_NAME, &pPackageInfo );
        if (SUCCEEDED(secStatus))
        {
            // get the maximun tocken size from the DIGEST sspi
            //
        
            g_cbMaxOutPutBuffSize = pPackageInfo->cbMaxToken;
        
            if (0 == g_cbMaxOutPutBuffSize)
            {
                return (FALSE);
            }
            else
            {
                return (TRUE);
            }
        }
        else 
        {
            return (FALSE);
        }   
    }
}

DWORD
SSPHttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType, 
    LPVOID                      pvNotification
)
/*++
Routine Description:
    Entry point function whenever a notification event for which the filter has registered occurs. 

Arguments:
   pfc                  Points to the HTTP_FILTER_CONTEXT data structure that is 
                        associated with the current, active HTTP transaction
   notificationType     Points to a bitmask that indicates the type of notification 
                        event being processed. 
   pvNotification       The notification-specific structure that contains more 
                        information about the current context of the request. 

Return Value:
    Returns one of the following values that indicate how the application handled the event.
    SF_STATUS_REQ_ERROR
    SF_STATUS_REQ_READ_NEXT

 ++*/
{
    HRESULT hrResult = S_OK;
    BOOL    fMd5     = FALSE;

    switch(notificationType)
    {
    case (SF_NOTIFY_ACCESS_DENIED): 
        if ( pfc->ServerSupportFunction( pfc,
                                         SF_REQ_GET_PROPERTY,
                                         (LPVOID)&fMd5,
                                         (UINT)SF_PROPERTY_MD5_ENABLED,
                                         NULL ) && fMd5 )
        {
            //
            // Call this function to process the authentication in order to change Usrname
            //
            hrResult = SSPOnAccessDenied (pfc, pvNotification);
        }

        break;

    case (SF_NOTIFY_AUTHENTICATIONEX):  
        //
        // Call this function to process the authentication in order to change Usrname
        //
        hrResult = SSPOnAuthenticationEx (pfc, pvNotification);
        break;

    case (SF_NOTIFY_END_OF_NET_SESSION):    
        { 
            //
            // Delete the security context
            //
            DIGEST_CONTEXT *pDigestContext;
            pDigestContext = (DIGEST_CONTEXT *)(pfc->pFilterContext);
            // check to see if there is any content in the pFilterContexet
            if (NULL != pDigestContext)
            {
                DeleteSecurityContext (&(pDigestContext->m_CtxtHandle));
            }
            break;
        }   
    }

    if (SUCCEEDED(hrResult))
    {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }
    else 
    {
        return SF_STATUS_REQ_ERROR;
    }
}

HRESULT 
SSPOnAccessDenied(
    HTTP_FILTER_CONTEXT *       pfc, 
    void *                      pvNotification
)
/*++
Routine Description:
    This function is design to process the Access_Denied notification. This routined
    will set the WWW-Authenticate to set digest. this will happen in when a 401 server 
    error is sent to the client 

Arguments:
    pfc             Points to the HTTP_FILTER_CONTEXT data structure that is 
                    associated with the current, active HTTP transaction
    pAccessDenied   pointer to this structure when a user is presented 
                    with an Access Denied error message. 

Return Value:
    TRUE    if the processs sucess 
    FALSE   if the process failed
--*/
{
    BOOL                    bReturnOk           = FALSE;
    BOOL                    bIsAllocated        = FALSE;

    char                    achMethod       [MAX_URL_SIZE];
    char                    achUrl          [MAX_URL_SIZE];
    char                    achRealm        [MAX_URL_SIZE];
    char                    *pchRealmPosition   = NULL;
    char                    *pszOutputBuffer    = NULL;
    char                    *pszOutputHeader    = NULL; // this is the output buffer that will be return to iis

    CtxtHandle              ServerCtxtHandle;

    DIGEST_CONTEXT          *pDigestContext = 0;

    DWORD                   cbMethod    = 0;
    DWORD                   cbUrl       = 0;
    DWORD                   cbUri       = 0;
    DWORD                   cbRealm     = 0;
    DWORD                   cbBuffer    = 0;
    DWORD                   cbOutputHeader = 0;


    HRESULT                 hrResult    = E_FAIL;
    
    HTTP_FILTER_ACCESS_DENIED   *pAuth;
    
    SecBufferDesc           SecBuffDescOutput;
    SecBufferDesc           SecBuffDescInput;

    SecBuffer               SecBuffTokenOut[1];
    SecBuffer               SecBuffTokenIn[5];

    SECURITY_STATUS         secStatus           = SEC_E_OK;

    TimeStamp               Lifetime;

    ULONG                   ContextReqFlags     = 0;
    ULONG                   TargetDataRep       = 0;
    ULONG                   ContextAttributes   = 0;

    pszOutputBuffer = new char[g_cbMaxOutPutBuffSize];
    if (NULL == pszOutputBuffer)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }

    // we add the MAX_URL_SIZE to provide space for www-authetication into output buffer
    //
    pszOutputHeader = new char[g_cbMaxOutPutBuffSize + MAX_URL_SIZE]; 
    if (NULL == pszOutputHeader)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }

    //  cast the pointer 
    pAuth = (HTTP_FILTER_ACCESS_DENIED *)pvNotification;

    //  clean the memory and set it to zero
    ZeroMemory(&SecBuffDescOutput, sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenOut   , sizeof(SecBuffTokenOut));

    ZeroMemory(&SecBuffDescInput , sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenIn    , sizeof(SecBuffTokenOut));

    ///////////////////////
    //  defined the OUTPUT
    ///////////////////////
    
    //  define the buffer descriptor for the Outpt
    //
    SecBuffDescOutput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescOutput.cBuffers      = 1;
    SecBuffDescOutput.pBuffers      = SecBuffTokenOut;

    SecBuffTokenOut[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenOut[0].cbBuffer     = g_cbMaxOutPutBuffSize;  // use any space here
    SecBuffTokenOut[0].pvBuffer     = pszOutputBuffer;


    ///////////////////////
    //  defined the INPUT
    ///////////////////////

    //  define the buffer descriptor for the Input
    //
    SecBuffDescInput.ulVersion      = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers       = 5;
    SecBuffDescInput.pBuffers       = SecBuffTokenIn;

    //
    //  Get and Set the information for the challange
    //


    // set the inforamtion in the buffer . this case is Null to authenticate user
    SecBuffTokenIn[0].BufferType    = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer      = 0; 
    SecBuffTokenIn[0].pvBuffer      = NULL;

    //  
    //  Get and Set the information for the method
    //
    
    //  Get size of the string alocated for the method
    cbMethod =  sizeof(achMethod);

    //  Get method
    bReturnOk = pfc->GetServerVariable( pfc,"REQUEST_METHOD",achMethod,&cbMethod);
    if (FALSE == bReturnOk)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }

    //  set the information in the buffer
    SecBuffTokenIn[1].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer      = cbMethod;
    SecBuffTokenIn[1].pvBuffer      = achMethod;

    //
    //  Get size of the string alocated for the method URL
    cbUrl = sizeof(achUrl);
    //
    //  Get the inforamtion of the URL
    bReturnOk = pfc->GetServerVariable( pfc,"URL",achUrl,&cbUrl);
    if (FALSE == bReturnOk)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    
    //
    //  set the information in the buffer
    SecBuffTokenIn[2].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer      = cbUrl;
    SecBuffTokenIn[2].pvBuffer      = achUrl;

    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer      = 0;    // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer      = NULL; // this is not yet implemeted   

    //
    //Get and Set the Realm Information
    //
    cbRealm =  sizeof(achRealm);
    bReturnOk = pfc->GetServerVariable( pfc,"HTTP_REQ_REALM",achRealm,&cbRealm );
    if (FALSE == bReturnOk)
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    SecBuffTokenIn[4].BufferType    = SECBUFFER_PKG_PARAMS;
//    SecBuffTokenIn[4].cbBuffer        = cbRealm;  
//    SecBuffTokenIn[4].pvBuffer        = achRealm; 
    SecBuffTokenIn[4].cbBuffer      = 0;                    
    SecBuffTokenIn[4].pvBuffer      = "\0"; 

    //
    //  Get a Security Context
    //

    //  set the flags
    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION;

    // get the security context
    secStatus = AcceptSecurityContext(
                    &g_ServerCred,
                    NULL,
                    &SecBuffDescInput,
                    ContextReqFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerCtxtHandle,
                    &SecBuffDescOutput,
                    &ContextAttributes,
                    &Lifetime);

    // a challange has to be send back to the client
    if (SEC_I_CONTINUE_NEEDED == secStatus)
    {

        //  Format and concatenate the header for the authentication
        //
        pDigestContext =((DIGEST_CONTEXT *)(pfc->pFilterContext));
        if (NULL != pDigestContext)
        {
            if (TRUE == pDigestContext->m_bStale)
            {
                strcpy(pszOutputHeader,"WWW-Authenticate: Digest stale=TRUE ,");
            }
            else
            {
                strcpy(pszOutputHeader,"WWW-Authenticate: Digest ");
            }
        }
        else
        {
            strcpy(pszOutputHeader,"WWW-Authenticate: Digest ");
        }
        
        cbOutputHeader = strlen(pszOutputHeader);

        
        //
        //  add the challange to the OutPutHeader
        //
        if ((cbOutputHeader+cbBuffer+1) < (g_cbMaxOutPutBuffSize + MAX_URL_SIZE))   //check the size
        {
            strncat(pszOutputHeader, (char *)SecBuffDescOutput.pBuffers[0].pvBuffer, 
                    (SecBuffDescOutput.pBuffers[0].cbBuffer));  
        }

        //
        //  Add the header WWW-Authenticate to the response after a 401 server error
        //
        bReturnOk = pfc->ServerSupportFunction(pfc, SF_REQ_ADD_HEADERS_ON_DENIAL, pszOutputHeader, NULL, NULL);
        if (FALSE == bReturnOk)
        {
            hrResult = SF_STATUS_REQ_ERROR;
            goto CleanUp;
        }
    }
    
    // in case that ASC failed
    if (FAILED(secStatus)) 
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    else 
    {
        hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto CleanUp;
    }

    ////////////////////////////////////////////////
    // Clean UP
    ///////////////////////////////////////////////
CleanUp:
    if (pszOutputBuffer)
    {
        delete [] pszOutputBuffer;
        pszOutputBuffer = NULL;
    }
    if (pszOutputHeader)
    {
        delete [] pszOutputHeader;
        pszOutputHeader = NULL;
    }
    return hrResult;
}

HRESULT 
SSPOnAuthenticationEx(
    HTTP_FILTER_CONTEXT *       pfc, 
    void *                      pvNotification
)
{
    HTTP_FILTER_AUTHENTEX   *pAuth;

    int                     fAreIdentical   = -1000;
    BOOL                    bReturnOk       = FALSE;
    BOOL                    bDuplicateToken = FALSE;

    char                    achMethod       [MAX_URL_SIZE];
//  char                    achOutBuffer    [MAX_URL_SIZE];
    char                    achUrl          [MAX_URL_SIZE];
    char                    achRealm        [MAX_URL_SIZE]; 
    char                    *pszOutputBuffer    =NULL;
    
    CtxtHandle              ServerCtxtHandle;

    DWORD                   cbMethod    = 0;
    DWORD                   cbUrl       = 0;
    DWORD                   cbUri       = 0;
    DWORD                   cbRealm     = 0;

    HRESULT                 hrResult    = E_FAIL;

    HANDLE                  hToken      = NULL;
    DIGEST_CONTEXT          *pDigestContext = 0;
    
    
    SecBufferDesc           SecBuffDescOutput;
    SecBufferDesc           SecBuffDescInput;

    SecBuffer               SecBuffTokenOut[1];
    SecBuffer               SecBuffTokenIn[6];

    SECURITY_STATUS         secStatus           = SEC_E_OK;

    TimeStamp               Lifetime;

    ULONG                   ContextReqFlags     = 0;
    ULONG                   TargetDataRep       = 0;
    ULONG                   ContextAttributes   = 0;

    pszOutputBuffer = new char[g_cbMaxOutPutBuffSize];
    if (NULL == pszOutputBuffer)
    {
        return SF_STATUS_REQ_ERROR;
    }

    
    pAuth = (HTTP_FILTER_AUTHENTEX *)pvNotification;

    //
    //  check that there is a username if not then is anonymous and is not authentucated
    //
    if ( !*pAuth->pszPassword ) 
    {
        hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
        goto CleanUp;
    }

    
    //  clean the memory and set it to zero
    ZeroMemory(&SecBuffDescOutput, sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenOut   , sizeof(SecBuffTokenOut));

    ZeroMemory(&SecBuffDescInput , sizeof(SecBufferDesc));
    ZeroMemory(SecBuffTokenIn    , sizeof(SecBuffTokenOut));

    ///////////////////////
    //  defined the OUTPUT
    ///////////////////////
    
    //  define the buffer descriptor for the Outpt
    //
    SecBuffDescOutput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescOutput.cBuffers      = 1;
    SecBuffDescOutput.pBuffers      = SecBuffTokenOut;

    SecBuffTokenOut[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenOut[0].cbBuffer     = g_cbMaxOutPutBuffSize;  // use any space here
    SecBuffTokenOut[0].pvBuffer     = pszOutputBuffer;


    ///////////////////////
    //  defined the INPUT
    ///////////////////////

    //  define the buffer descriptor for the Input
    //
    SecBuffDescInput.ulVersion      = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers       = 5;
    SecBuffDescInput.pBuffers       = SecBuffTokenIn;

    //
    //  Get and Set the information for the challange
    //
    
    // set the inforamtion in the buffer . this case is Null to authenticate user
    SecBuffTokenIn[0].BufferType    = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer      = (strlen(pAuth->pszPassword)+1); 
    SecBuffTokenIn[0].pvBuffer      = pAuth->pszPassword;

    //  
    //  Get and Set the information for the method
    //
    
    //  Get size of the string alocated for the method
    cbMethod =  sizeof(achMethod);

    //  Get method
    bReturnOk = pfc->GetServerVariable( pfc,"REQUEST_METHOD",achMethod,&cbMethod);
    if (FALSE == bReturnOk)
    {
        return SF_STATUS_REQ_ERROR;
    }

    //  set the information in the buffer
    SecBuffTokenIn[1].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer      = cbMethod;
    SecBuffTokenIn[1].pvBuffer      = achMethod;

    //
    //  Get and Set the information for the URL & URI
    //

    //
    //  Get size of the string alocated for the method URL
    cbUrl = sizeof(achUrl);
    //
    //  Get the inforamtion of the URL
    bReturnOk = pfc->GetServerVariable( pfc,"URL",achUrl,&cbUrl);
    if (FALSE == bReturnOk)
    {
        return SF_STATUS_REQ_ERROR;
    }
    
    
    //
    //  set the information in the buffer
    SecBuffTokenIn[2].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer      = cbUrl;
    SecBuffTokenIn[2].pvBuffer      = achUrl;

    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer      = 0;    // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer      = 0;    // this is not yet implemeted   


    //
    // Get and set the REALM
    //

    cbRealm =  sizeof(achRealm);
    bReturnOk = pfc->GetServerVariable( pfc,"HTTP_REQ_REALM",achRealm,&cbRealm );
    if (FALSE == bReturnOk)
    {
        return SF_STATUS_REQ_ERROR;
    }
    SecBuffTokenIn[4].BufferType    = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[4].cbBuffer      = 0;                        
    SecBuffTokenIn[4].pvBuffer      = "\0"; //This is where you should put the realm
    
    
    //
    //  Get a Security Context
    //

    //  set the flags
    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION;


    //
    //check to see if there is an old Context Handle
    pDigestContext =((DIGEST_CONTEXT *)(pfc->pFilterContext));
    if (NULL != pDigestContext)
    {
        //defined the buffer
        SecBuffTokenIn[4].BufferType    = SECBUFFER_TOKEN;
        SecBuffTokenIn[4].cbBuffer      = g_cbMaxOutPutBuffSize;  // use any space here
        SecBuffTokenIn[4].pvBuffer      = pszOutputBuffer;


        secStatus = VerifySignature(
                            &(pDigestContext->m_CtxtHandle),
                            &SecBuffDescInput,
                            0,
                            0);

        // Check to see if the nonce has expired
        //
        if (SEC_E_CONTEXT_EXPIRED ==  secStatus)
        {
            //Delete the old Security Context
            //
            DeleteSecurityContext (&(pDigestContext->m_CtxtHandle));
        
            ZeroMemory(&(pDigestContext->m_CtxtHandle) , sizeof(CtxtHandle));

            pDigestContext->m_bStale = TRUE;

            if (NULL != pAuth->hAccessTokenImpersonation)
            {
                // close the SecToken = handle to avoid leaking of resources 
                //
                bReturnOk = CloseHandle( pAuth->hAccessTokenImpersonation); //avoif leaking
                if (TRUE == bReturnOk)
                {
                    //force and access denied to be fire
                    pAuth->hAccessTokenImpersonation = NULL;            
                    hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
                }
                else
                {
                    hrResult = SF_STATUS_REQ_ERROR;
                }
            }           
            goto CleanUp;
        }
    }

    //
    // there is no an old context handle
    // this case handle the non persistent connection 
    else
    {
        // get the security context
        secStatus = AcceptSecurityContext(
                        &g_ServerCred,
                        NULL,
                        &SecBuffDescInput,
                        ContextReqFlags,
                        SECURITY_NATIVE_DREP,
                        &ServerCtxtHandle,
                        &SecBuffDescOutput,
                        &ContextAttributes,
                        &Lifetime);


        if (SUCCEEDED(secStatus))
        {
            // Allocate memory for the Digest context
            if (FALSE == SSPAllocateFilterContext(pfc))
            {
                hrResult = SF_STATUS_REQ_ERROR;
                goto CleanUp;   
            }

            //
            // set the new context handle in the struct 
            pDigestContext =((PDIGEST_CONTEXT)(pfc->pFilterContext));
            pDigestContext->m_CtxtHandle = ServerCtxtHandle;
        }

        if(SEC_I_COMPLETE_NEEDED == secStatus) //SEC_I_COMPLETE_NEEDED
        {
            //defined the buffer
            SecBuffTokenIn[4].BufferType    = SECBUFFER_TOKEN;
            SecBuffTokenIn[4].cbBuffer      = g_cbMaxOutPutBuffSize;  // use any space here
            SecBuffTokenIn[4].pvBuffer      = pszOutputBuffer;


            secStatus = CompleteAuthToken(&ServerCtxtHandle, &SecBuffDescInput);
        }

    }
    
    if (FAILED(secStatus)) 
    {
        hrResult = SF_STATUS_REQ_ERROR;
        goto CleanUp;
    }
    else 
    {
        //
        // get the token to impersonate later
        secStatus = QuerySecurityContextToken(&(pDigestContext->m_CtxtHandle),&(pAuth->hAccessTokenImpersonation));
        if (SUCCEEDED(secStatus))
        {
            hrResult = SF_STATUS_REQ_NEXT_NOTIFICATION;
            goto CleanUp;
        }
        else 
        {
            hrResult = SF_STATUS_REQ_ERROR;
            goto CleanUp;
        }
    }



CleanUp:
    if (pszOutputBuffer)
    {
        delete [] pszOutputBuffer;
        pszOutputBuffer =0;
    }
    return hrResult;
}


BOOL 
SSPAllocateFilterContext(
    HTTP_FILTER_CONTEXT *           pfc
)
/*++
Routine Description:
    Allocate filter user context as a DIGEST_CONTEXT if not already done

Arguments:
    pfc - Filter Context

Return Value:
    TRUE if success, FALSE if error

--*/
{
    //
    // allocate filter context
    //

    if ( !pfc->pFilterContext )
    {
        pfc->pFilterContext = pfc->AllocMem( pfc, sizeof(DIGEST_CONTEXT), 0 );

        if ( !pfc->pFilterContext )
        {
            return FALSE;
        }
        memset( pfc->pFilterContext, 0, sizeof(DIGEST_CONTEXT) );
        ((DIGEST_CONTEXT *)pfc->pFilterContext)->m_bStale = FALSE;
    }

    return TRUE;
}

BOOL 
SSPTerminateFilter(
    DWORD               dwFlags 
)
/*++

Routine Description:
    This routing will clean the filter for a successful unload avoiding resource leaking 

Arguments:
    dwFlags No values for dwFlags have been identified at this time. 

Return Value:
    TRUE if success

--*/
{
    SECURITY_STATUS  secStatus  = SEC_E_OK;

    //
    // releasing the local creadential handle
    //
    secStatus = FreeCredentialsHandle( &g_ServerCred);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\md5filt\sspdigest.h ===
#ifndef _SSPDIGEST_H_
#define _SSPDIGEST_H_

BOOL
SSPGetFilterVersion(
    VOID
);

DWORD
SSPHttpFilterProc(
    PHTTP_FILTER_CONTEXT        pfc, 
    DWORD                       notificationType,
    LPVOID                      pvNotification
);

HRESULT
SSPOnAccessDenied(
    HTTP_FILTER_CONTEXT *       pfc,
    VOID *                      pvNotification
);

HRESULT
SSPOnAuthenticationEx(
    HTTP_FILTER_CONTEXT *       pfc,
    VOID *                      pvNotification
);

BOOL
SSPAllocateFilterContext(
    HTTP_FILTER_CONTEXT *       pfc
);

BOOL
SSPTerminateFilter(
    DWORD                       dwFlags
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\redirect\redirect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    redirect.cxx

Abstract:

    HTTP redirection support filter.  See \iis\spec\redirect.doc for spec

    This version assumes the redirections are stored in the METABASE.
    Metadata corresponding to a source and destination entry (as in the
    REDIRECT.INI file of the 2.0 filter) is stored for each object for
    which a redirection is specified.

    For example to redirect on server SERV: /foo ==> /newfoo

    The metadata values of /foo and /newfoo are stored in the object
    "ROOT/SERV/foo" under the IDs REDIR_SOURCE and REDIR_DESTINATION

****************************************************************************
TO DO:  - figure out how wildcards/physical redirs fit into metabase scheme
        - add lookupvirtualroot() functionality to K2 filter
****************************************************************************

Author:

    Bilal Alam (t-bilala)       8-July-1996
--*/

#include "redirect.hxx"

enum REDIR_TOKEN
{
    REDIR_TOKEN_EXACT_SRC,
    REDIR_TOKEN_EXACT_DST,
    REDIR_TOKEN_PERMANENT,
    REDIR_TOKEN_PHYSICAL,
    REDIR_TOKEN_SUFFIX,
    REDIR_TOKEN_FULL,
    REDIR_TOKEN_PARAMETERS,
    REDIR_TOKEN_QMARK_PARAMETERS,
    REDIR_TOKEN_VROOT_REQUEST,
    REDIR_TOKEN_ERROR,
    REDIR_TOKEN_ERROR_LOGON,
    REDIR_TOKEN_ERROR_RESOURCE,
    REDIR_TOKEN_ERROR_FILTER,
    REDIR_TOKEN_ERROR_APPLICATION,
    REDIR_TOKEN_ERROR_BY_CONFIG,
    REDIR_TOKEN_UNKNOWN
};

struct _REDIR_TOKEN_LIST
{
    CHAR *           pszKeyword;
    DWORD            cbLen;
    REDIR_TOKEN      rtType;
}
RedirectTokenList[] =
{
    "EXACT_SOURCE",     12, REDIR_TOKEN_EXACT_SRC,
    "EXACT_DESTINATION",17, REDIR_TOKEN_EXACT_DST,
    "PERMANENT",        9,  REDIR_TOKEN_PERMANENT,
    "PHYSICAL",         8,  REDIR_TOKEN_PHYSICAL,
    "$S",               2,  REDIR_TOKEN_SUFFIX,
    "$F",               2,  REDIR_TOKEN_FULL,
    "$P",               2,  REDIR_TOKEN_PARAMETERS,
    "$Q",               2,  REDIR_TOKEN_QMARK_PARAMETERS,
    "$V",               2,  REDIR_TOKEN_VROOT_REQUEST,
    "ERROR",            5,  REDIR_TOKEN_ERROR,
    "LOGON",            5,  REDIR_TOKEN_ERROR_LOGON,
    "RESOURCE",         8,  REDIR_TOKEN_ERROR_RESOURCE,
    "FILTER",           6,  REDIR_TOKEN_ERROR_FILTER,
    "APPLICATION",      11, REDIR_TOKEN_ERROR_APPLICATION,
    "BY_CONFIG",        9,  REDIR_TOKEN_ERROR_BY_CONFIG,
    NULL,               0,  REDIR_TOKEN_UNKNOWN
};

// prototypes

DWORD
GetRedirectToken(
    IN CHAR *           pszBuffer,
    OUT DWORD *         dwLen = NULL
);

CHAR *
RedirectSkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
);

CHAR *
RedirectSkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
);

DWORD
RedirectThread(
    IN PVOID            Param
);

BOOL
GetLastModTime(
    IN STR &            strFilename,
    OUT FILETIME *      pftModTime
);

BOOL
REDIRECTION_ITEM::ParseSource(
    IN CHAR *           pszSource
)
{
    CHAR *              pchWild;

    if ( !_strSource.Copy( pszSource ) )
    {
        return FALSE;
    }
    // cache the string length
    _cbSource = _strSource.QueryCB();

    // check for wildcards
    // if wildcard exists, then the inheritance portion of the string (
    // that which is used to place properly in REDIRECTION_CHUNK) is only
    // the portion of the string before the first wildcard (asterisk).

    pchWild = strchr( pszSource, '*' );
    if ( pchWild != NULL )
    {
        _fWildCard = TRUE;
        _cbWildCard = pchWild - pszSource;
    }

    return TRUE;
}

BOOL
REDIRECTION_ITEM::ParseDestination(
    IN CHAR *           pszDestination
)
/*++

Routine Description:

    Check destination template for options, tokens

Arguments:

    pszDestination - Destination template

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR *              pchNextComma;
    DWORD               cbTokenLen;

    // first get the destination path

    pchNextComma = strchr( pszDestination, ',' );
    if ( pchNextComma != NULL )
    {
        CHAR *              pchWhiteSpace;

        *pchNextComma = '\0';

        //
        // look for any trailing white space in destination, remove it
        //

        pchWhiteSpace = pchNextComma;
        while( pchWhiteSpace > pszDestination )
        {
            if ( !isspace( (UCHAR)(*( pchWhiteSpace - 1 )) ) )
            {
                break;
            }
            pchWhiteSpace--;
        }
        *pchWhiteSpace = '\0';
    }

    if ( !_strDestination.Copy( pszDestination ) )
    {
        return FALSE;
    }
    // cache the string length
    _cbDestination = _strDestination.QueryCB();

    if ( strchr( pszDestination, '$' ) )
    {
        _fHasTokens = TRUE;
    }

    if ( pchNextComma == NULL ) // no parms
    {
        return TRUE;
    }

    while ( TRUE )
    {
        pchNextComma++;

        while ( isspace( (UCHAR)(*pchNextComma) ) )
        {
            pchNextComma++;
        }
        switch ( GetRedirectToken( pchNextComma, &cbTokenLen ) )
        {
            case REDIR_TOKEN_EXACT_SRC:
                _fExactSource = TRUE;
                break;
            case REDIR_TOKEN_EXACT_DST:
                _fExactDestination = TRUE;
                break;
            case REDIR_TOKEN_PERMANENT:
                _fPermanent = TRUE;
                break;
            case REDIR_TOKEN_PHYSICAL:
                _fPhysical = TRUE;
                break;
            case REDIR_TOKEN_ERROR:
            {
                CHAR *      pchNext;

                pchNextComma += cbTokenLen;

                pchNext = strchr( pchNextComma, ',' );
                if ( pchNext == NULL )
                {
                    pchNext = _strDestination.QueryStr() + _cbDestination;
                }
                _fErrorConfig = TRUE;
                if ( !ParseErrorConfig( pchNextComma, pchNext ) )
                {
                    return FALSE;
                }
                break;
            }
            default:
                break;
        }

        pchNextComma = strchr( pchNextComma, ',' );

        if ( pchNextComma == NULL )
        {
            break;
        }
    }

    return TRUE;
}

BOOL
REDIRECTION_ITEM::ParseErrorConfig(
    IN CHAR *           pchErrorConfig,
    IN CHAR *           pchEndErrorConfig
)
/*++

Routine Description:

    Parse error configuration template for errors to redirect

    /foo=/newfoo,ERROR(x|y|z)

    Parse out x,y,z

Arguments:

    pchErrorConfig - Pointer to beginning of error statement
    pchEndErrorConfig - Pointer to end of error statement

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR *              pchCursor = pchErrorConfig;
    CHAR *              pchBegin;
    DWORD               cbTokenLen;

    pchCursor = RedirectSkipWhite( pchCursor, pchEndErrorConfig );
    if ( pchCursor == NULL )
    {
        // if only the ERROR keyword is there,
        // then mask all errors

        _dwErrorCode = 0xffffffff;
        return TRUE;
    }

    pchBegin = RedirectSkipTo( pchCursor,
                               '(',
                               pchEndErrorConfig );

    if ( pchBegin == NULL )
    {
        return FALSE;
    }

    pchBegin++;

    while ( pchBegin != NULL )
    {
        pchBegin = RedirectSkipWhite( pchBegin, pchEndErrorConfig );
        if ( pchBegin == NULL )
        {
            break;
        }
        else if ( *pchBegin == '|' )
        {
            pchBegin++;
            continue;
        }
        else if ( *pchBegin == ')' )
        {
            break;
        }

        switch( GetRedirectToken( pchBegin, &cbTokenLen ) )
        {
        case REDIR_TOKEN_ERROR_LOGON:
            pchBegin += cbTokenLen;
            _dwErrorCode |= SF_DENIED_LOGON;
            break;
        case REDIR_TOKEN_ERROR_RESOURCE:
            pchBegin += cbTokenLen;
            _dwErrorCode |= SF_DENIED_RESOURCE;
            break;
        case REDIR_TOKEN_ERROR_FILTER:
            pchBegin += cbTokenLen;
            _dwErrorCode |= SF_DENIED_FILTER;
            break;
        case REDIR_TOKEN_ERROR_APPLICATION:
            pchBegin += cbTokenLen;
            _dwErrorCode |= SF_DENIED_APPLICATION;
            break;
        case REDIR_TOKEN_ERROR_BY_CONFIG:
            pchBegin += cbTokenLen;
            _dwErrorCode != SF_DENIED_BY_CONFIG;
            break;
        default:
            return FALSE;
        }
    }

    return TRUE;
}

/* GetDestination()

   Takes internal destination template and generates new redirected URL.

   Input:  strSource --> Source string (source of redirection)
           strQueryString --> Query string of original URL request
           strVirtualRequest --> Original URL request (will be same
                                 as strSource UNLESS this is a physical
                                 redirection, in which case, strSource
                                 will be the physical path of the request
           pwmlList --> List containing matched wildcard strings
                        (used if $0-$9 exist in destination template)
   Output: pstrDestination --> receives the final redirected URL

   Returns TRUE if successful, else FALSE
*/

BOOL
REDIRECTION_ITEM::GetDestination(
    IN STR &                    strSource,
    IN STR &                    strQueryString,
    IN STR &                    strVirtualRequest,
    IN WILDCARD_MATCH_LIST *    pwmlList,
    OUT STR *                   pstrDestination
)
/*++

Routine Description:

    Takes internal destination template and generates new redirected URL.

Arguments:

    strSource - Source string (source of redirection)
    strQueryString - Query string of original URL request
    strVirtualRequest - Original URL request (will be same
                        as strSource UNLESS this is a physical
                        redirection, in which case, strSource
                        will be the physical path of the request
    pwmlList - List containing matched wildcard strings
                        (used if $0-$9 exist in destination template)
    pstrDestination - receives the final redirected URL

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    STR             strMatchedSuffix;
    CHAR *          pchQuery;


    // If destination template starts with !, then this is a NULL
    // redirection -> simply return out

    if ( *(_strDestination.QueryStr()) == '!' )
    {
        return FALSE;
    }

    // If not a wildcard source, get the matched suffix

    if ( !_fWildCard )
    {
        if ( !strMatchedSuffix.Copy( strSource.QueryStr() + _cbSource ) )
        {
            return FALSE;
        }
    }

    if ( !_fHasTokens )
    {
        if ( !pstrDestination->Copy( _strDestination.QueryStr() ) )
        {
            return FALSE;
        }
    }
    else
    {
        CHAR            achAdd[ 2 ] = { '\0', '\0' };
        CHAR            ch;
        STR             strTemp( _strDestination.QueryStr() );
        CHAR *          pchCursor = strTemp.QueryStr();
        DWORD           cbLen;
        CHAR *          pchNext;

        while ( ( ch = *pchCursor ) != '\0' )
        {
            switch ( ch )
            {
            case '$':
                // Substitute for special tokens in destination template

                switch ( GetRedirectToken( pchCursor, &cbLen ) )
                {
                case REDIR_TOKEN_SUFFIX:
                    pchCursor += ( cbLen - 1 );
                    if ( !_fWildCard )
                    {
                        if ( !pstrDestination->Append( strMatchedSuffix.QueryStr() ) )
                        {
                            return FALSE;
                        }
                    }
                    break;
                case REDIR_TOKEN_FULL:
                    pchCursor += ( cbLen - 1 );
                    if ( !pstrDestination->Append( strSource.QueryStr() ) )
                    {
                        return FALSE;
                    }
                    break;
                case REDIR_TOKEN_PARAMETERS:
                    pchCursor += ( cbLen - 1 );
                    if ( !pstrDestination->Append( strQueryString.QueryStr() ) )
                    {
                        return FALSE;
                    }
                    break;
                case REDIR_TOKEN_QMARK_PARAMETERS:
                    pchCursor += ( cbLen - 1 );

                    if ( !strQueryString.IsEmpty() )
                    {
                        if ( !pstrDestination->Append( "?" ) ||
                             !pstrDestination->Append( strQueryString.QueryStr() ) )
                        {
                            return FALSE;
                        }
                    }
                    break;
                case REDIR_TOKEN_VROOT_REQUEST:
                    pchCursor += ( cbLen - 1 );
                    if ( !pstrDestination->Append( strVirtualRequest.QueryStr() ) )
                    {
                        return FALSE;
                    }
                    break;
                default:
                    pchCursor++;
                    ch = *pchCursor;
                    if ( isdigit( (UCHAR)ch ) )
                    {
                        if ( !pstrDestination->Append( pwmlList->GetMatchNumber( ch - '0' ) ) )
                        {
                            return FALSE;
                        }
                    }
                    else
                    {
                        if ( !pstrDestination->Append( "$" ) )
                        {
                            return FALSE;
                        }
                        achAdd[ 0 ] = ch;
                        if ( !pstrDestination->Append( achAdd ) )
                        {
                            return FALSE;
                        }
                    }
                }
                break;
            default:
                pchNext = pchCursor;
                while ( pchCursor[ 1 ] != '$' && pchCursor[ 1 ] != '\0' )
                {
                    pchCursor++;
                }
                ch = pchCursor[ 1 ];
                pchCursor[ 1 ] = '\0';
                if ( !pstrDestination->Append( pchNext ) )
                {
                    return FALSE;
                }
                pchCursor[ 1 ] = ch;
                break;
            }
            pchCursor++;
        }
    }
    if ( _fExactDestination || _fWildCard )
    {
        return TRUE;
    }
    else
    {
        return pstrDestination->Append( strMatchedSuffix.QueryStr() );
    }
}

BOOL
REDIRECTION_ITEM::IsWildCardMatch(
    IN STR &                    strInput,
    OUT WILDCARD_MATCH_LIST *   pwmlList
)
/*++

Routine Description:

    Checks whether input string matches wildcard expression of internal
    source string.  For example:  given internal source of "a*b*c",
    "abooc", "asdfjbsdfc" match, "foobar", "scripts" do not match

Arguments:

    strInput - input string to check for wildcard match
    pwmlList - List of matched strings (one for each * in wildcard)
               Only generated if the destination string of
               REDIRECTION_ITEM contains special tokens.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR            chExpr;
    CHAR            chTemp;
    CHAR *          pchExpr = _strSource.QueryStr();
    CHAR *          pchTest = strInput.QueryStr();
    CHAR *          pchEnd;

    pchEnd = pchExpr + _cbSource;
    while ( TRUE )
    {
        chExpr = *pchExpr++;
        if ( chExpr == '\0' )
        {
            if ( *pchTest == '\0' )
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
        else if ( chExpr != '*' )
        {
            chTemp = *pchTest++;
            if ( chTemp != chExpr )
            {
                return 0;
            }
        }
        else
        {
            INT             iComLen;
            CHAR *          pchNextWild;

            while ( *pchExpr == '*' )
            {
                pchExpr++;
            }

            pchNextWild = strchr( pchExpr, '*' );
            iComLen = pchNextWild == NULL ? pchEnd - pchExpr :
                                           pchNextWild - pchExpr;
            while ( *pchTest != '\0' )
            {
                if ( strncmp( pchExpr,
                              pchTest,
                              iComLen ) || !iComLen )
                {
                    // if the destination has tokens, then generate WML
                    if ( _fHasTokens && !pwmlList->AddChar( *pchTest ) )
                    {
                        return FALSE;
                    }
                    pchTest++;
                }
                else
                {
                    break;
                }
            }
            if ( *pchTest == '\0' && iComLen )
            {
                return FALSE;
            }
            else if ( _fHasTokens && !pwmlList->NewString() )
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOL
REDIRECTION_CHUNK::AddRedirectionItem(
    IN REDIRECTION_ITEM *       pRIEntry
)
/*++

Routine Description:

    Adds REDIRECTION_ITEM to chunk.

Arguments:

    pRIEntry - REDIRECTION_ITEM to add

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY *            pEntry;
    REDIRECTION_ITEM *      pItem;

    // if pRIEntry is an error configuration, set flag

    if ( pRIEntry->IsErrorConfig() )
    {
        _fContainsErrorConfig = TRUE;
    }

    if ( pRIEntry->IsPhysicalRedirection() )
    {
        _fPhysical = TRUE;
    }

    for ( pEntry = _OrderedListHead.Flink;
          pEntry != &_OrderedListHead;
          pEntry = pEntry->Flink )
    {
        pItem = CONTAINING_RECORD( pEntry,
                                   REDIRECTION_ITEM,
                                   _ListEntry );

        if ( REDIRECTION_ITEM::Compare( *pItem, *pRIEntry ) > 0 )
        {
            break;
        }
    }

    InsertTailList( pEntry, &pRIEntry->_ListEntry );

    return TRUE;
}

BOOL
REDIRECTION_CHUNK::IsChunkMatch(
    IN REDIRECTION_ITEM *       pRIEntry
)
/*++

Routine Description:

    Checks whether REDIRECTION_ITEM belongs to this chunk.
    (for example, given chunk for "/scripts",
    "/scripts/foo", "/scr" belong, "/foo/bar", "/test" do not belong

Arguments:

    pRIEntry - REDIRECTION_ITEM to check

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    REDIRECTION_ITEM *      pRIHead;

    pRIHead = CONTAINING_RECORD( _OrderedListHead.Flink,
                                 REDIRECTION_ITEM,
                                 _ListEntry );

    TCP_ASSERT( pRIHead != NULL );

    if ( pRIHead->IsContainedIn( pRIEntry ) )
    {
        return TRUE;
    }

    if ( pRIEntry->IsContainedIn( pRIHead ) )
    {
        return TRUE;
    }

    return FALSE;
}

REDIRECTION_ITEM *
REDIRECTION_CHUNK::FindErrorMatch(
    IN STR &                    strSource,
    OUT WILDCARD_MATCH_LIST *   pwmlList,
    IN DWORD                    dwErrorCode
)
/*++

Routine Description:

    Finds ERROR configuration matches in chunk

Arguments:

    strSource - Source string to match
    dwErrorCode - Error notification number
    pwmlLIst - Contains list of wildcard matched strings

Return Value:

    Pointer to REDIRECTION_ITEM if matched, else NULL

--*/
{
    REDIRECTION_ITEM *      pMatch = NULL;
    REDIRECTION_ITEM *      pItem;
    LIST_ENTRY *            pEntry;

    for ( pEntry = _OrderedListHead.Flink;
          pEntry != &_OrderedListHead;
          pEntry = pEntry->Flink )
    {
        pItem = CONTAINING_RECORD( pEntry,
                                   REDIRECTION_ITEM,
                                   _ListEntry );

        if ( pItem->IsErrorConfig() )
        {
            if ( pItem->IsErrorCodeMatch( dwErrorCode ) )
            {
                if ( pItem->IsMatch( strSource,
                                     pwmlList ) )
                {
                    pMatch = pItem;
                }
            }
            else
            {
                break;
            }
        }
    }
    return pMatch;
}

REDIRECTION_ITEM *
REDIRECTION_CHUNK::FindMatch(
    IN STR &                    strSource,
    OUT WILDCARD_MATCH_LIST *   pwmlList
)
/*++

Routine Description:

    Traverses ordered linked list of REDIRECTION_CHUNK looking for match
    (should ignore ERROR configurations)

Arguments:

    strSource - Source string to match
    pwmlLIst - Contains list of wildcard matched strings

Return Value:

    Pointer to REDIRECTION_ITEM if matched, else NULL

--*/
{
    REDIRECTION_ITEM *      pMatch = NULL;
    REDIRECTION_ITEM *      pItem;
    LIST_ENTRY *            pEntry;

    for ( pEntry = _OrderedListHead.Flink;
          pEntry != &_OrderedListHead;
          pEntry = pEntry->Flink )
    {
        pItem = CONTAINING_RECORD( pEntry,
                                   REDIRECTION_ITEM,
                                   _ListEntry );

        if ( pItem->IsErrorConfig() )
        {
        }
        else if ( pItem->IsMatch( strSource,
                                  pwmlList ) )
        {
            pMatch = pItem;
        }
        else
        {
            break;
        }
    }
    return pMatch;
}

BOOL
REDIRECTION_LIST::AddRedirectionItemToList(
    IN CHAR *               pszSource,
    IN CHAR *               pszDestination
)
/*++

Routine Description:

    Adds REDIRECTION_ITEM to list.

Arguments:

    pszSource - URL_source part of redirection specification
    pszDestination - URL_destination part of redirection specification
                     (also contains parameters -> everything after =)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    REDIRECTION_ITEM *          pRI;
    REDIRECTION_CHUNK *         pChunk;
    LIST_ENTRY *                pEntry;

    pRI = new REDIRECTION_ITEM( pszSource, pszDestination );

    if ( pRI == NULL || !pRI->IsValid() )
    {
        delete pRI;
        return FALSE;
    }

    // Check if this is a root redirection
    // Handle roots differently because all URLs can be matched by the
    // root redirection.

    if ( !strcmp( pszSource,
                  "/" ) )
    {
        if ( _pRIRoot != NULL )
        {
            // already got a _pRIRoot, just free old one and use new one
            delete _pRIRoot;
        }
        _pRIRoot = pRI;

        return TRUE;
    }

    // Traverse list of chunks looking for a existing chunk for entry
    // (for example, if a chunk for "/scripts" exists, then, a
    // REDIRECTION_ITEM for "/scripts/foo" should be placed in this chunk

    for ( pEntry = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry = pEntry->Flink )
    {
        pChunk = CONTAINING_RECORD( pEntry,
                                    REDIRECTION_CHUNK,
                                    _ListEntry );

        if ( pChunk->IsChunkMatch( pRI ) )
        {
            return pChunk->AddRedirectionItem( pRI );
        }
    }

    // Couldn't find a suitable chunk, need to create a new chunk!

    pChunk = new REDIRECTION_CHUNK;
    if ( pChunk == NULL || !pChunk->IsValid() )
    {
        delete pChunk;
        return FALSE;
    }

    if ( !pChunk->AddRedirectionItem( pRI ) )
    {
        delete pChunk;
        return FALSE;
    }

    // keep physical redirections at the bottom of the list as they
    // have lower priority than virtual redirections

    if ( pChunk->IsPhysicalRedirection() )
    {
        InsertTailList( &_ListHead, &pChunk->_ListEntry );
    }
    else
    {
        InsertHeadList( &_ListHead, &pChunk->_ListEntry );
    }

    return TRUE;
}

BOOL
REDIRECTION_LIST::GetRedirectedURLFromList(
    IN STR &                    strURL,
    IN STR &                    strQueryString,
    OUT STR *                   pstrDestination,
    OUT STR *                   pstrRedirectMessage,
    IN DWORD                    dwErrorCode,
    IN HTTP_FILTER_CONTEXT *    pfc
)
/*++

Routine Description:

    Gets the redirected URL (if any) for the specified source URL by searching
    REDIRECTION_LIST

Arguments:

    strURL - Source URL requested (from client)
    strQueryString - Query String of request
    dwErrorCode - Error notification code ( 0 if no error)
    pstrDestination - Receives destination URL (if any)
    pstrRedirectMessage - Receives either a 301 or 302 message (permanent/temp)
    pfc - HTTP filter context

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    LIST_ENTRY *            pEntry;
    REDIRECTION_ITEM *      pRIEntry = NULL;
    REDIRECTION_CHUNK *     pChunk;
    STR                     strPhysical;
    WILDCARD_MATCH_LIST     wmlList( strURL.QueryCB() );
    BOOL                    fPhysical = FALSE;

    for ( pEntry = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry = pEntry->Flink )
    {
        pChunk = CONTAINING_RECORD( pEntry,
                                    REDIRECTION_CHUNK,
                                    _ListEntry );

        if ( dwErrorCode && !pChunk->ContainsErrorConfig() )
        {
            continue;
        }

        // only do a TsLookupVirtualRoot() once -> it's quite expensive

        // Apparently VROOT_TABLE isn't initialized and thus call
        // to LookupVirtualRoot() AVs on EnterCriticalSection()
        // --> Investigate

        if ( pChunk->IsPhysicalRedirection() )
        {
            if ( strPhysical.IsEmpty() )
            {
                HTTP_REQUEST *      pReq = (HTTP_REQUEST*) pfc;
                PIIS_VROOT_TABLE    pVrootTable;
                DWORD               cbBufLen = REDIR_MAX_PHYSICAL + 1;

                pVrootTable = pReq->QueryW3Instance()->QueryVrootTable();

                if ( !strPhysical.Resize( cbBufLen ) )
                {
                    return FALSE;
                }

                if ( !pVrootTable->LookupVirtualRoot( strURL.QueryStr(),
                                                      strPhysical.QueryStr(),
                                                      &cbBufLen ) )
                {
                    return FALSE;
                }
            }

            if ( dwErrorCode )
            {
                pRIEntry = pChunk->FindErrorMatch( strPhysical,
                                                   &wmlList,
                                                   dwErrorCode );
            }
            else
            {
                pRIEntry = pChunk->FindMatch( strPhysical,
                                              &wmlList );
            }

            fPhysical = TRUE;
        }
        else
        {
            if ( dwErrorCode )
            {
                pRIEntry = pChunk->FindErrorMatch( strURL,
                                                   &wmlList,
                                                   dwErrorCode );
            }
            else
            {
                pRIEntry = pChunk->FindMatch( strURL,
                                              &wmlList );
            }
        }

        if ( pRIEntry != NULL )
        {
            break;
        }
    }

    if ( pRIEntry == NULL )
    {
        //
        //  Root matches all except error code matches
        //

        if ( dwErrorCode || !_pRIRoot )
        {
            return FALSE;
        }

        pRIEntry = _pRIRoot;
    }

    // If redirection match was found, get the HTTP redirect message

    if ( !pRIEntry->GetRedirectMessage( pstrRedirectMessage ) )
    {
        return FALSE;
    }

    // and the new destination URL

    return pRIEntry->GetDestination( (fPhysical ? strPhysical : strURL),
                                     strQueryString,
                                     strURL,
                                     &wmlList,
                                     pstrDestination );
}

REDIRECTION_REQUEST::REDIRECTION_REQUEST( VOID ) :
    _pRLDefault    ( NULL ),
    _fEmpty        ( TRUE ),
    _hThread       ( NULL ),
    _fValid        ( FALSE ),
    _hEntryEvent   ( NULL ),
    _hRefreshEvent ( NULL ),
    _hShutdownEvent( NULL ),
    _cReadOccupancy( 0 )
{
    DWORD               dwThreadID;
    HKEY                hKey;
    DWORD               dwType;
    DWORD               cbBufLen = REDIR_MAX_PHYSICAL + 1;
    CHAR                achBuffer[ REDIR_MAX_PHYSICAL + 1 ];

    InitList();

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKey ) != NO_ERROR )
    {
        return;
    }

    if ( RegQueryValueEx( hKey,
                          REDIR_INSTALL_PATH,
                          NULL,
                          &dwType,
                          (LPBYTE) achBuffer,
                          &cbBufLen ) != NO_ERROR )
    {
        return;
    }

    RegCloseKey( hKey );

    if ( !_strDirectory.Copy( achBuffer ) ||
         !_strFilename.Copy( achBuffer ) ||
         !_strFilename.Append( "\\" ) ||
         !_strFilename.Append( REDIR_FILENAME ) )
    {
        return;
    }

    _hEntryEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( _hEntryEvent == NULL )
    {
        return;
    }

    _hRefreshEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( _hRefreshEvent == NULL )
    {
        return;
    }

    _hShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( _hShutdownEvent == NULL )
    {
        return;
    }

    if ( !ReadConfiguration() )
    {
        return;
    }

    _hThread = CreateThread( NULL,
                             0,
                             (LPTHREAD_START_ROUTINE) RedirectThread,
                             (LPVOID) this,
                             0,
                             &dwThreadID );
    if ( _hThread == NULL )
    {
        return;
    }

    _fValid = TRUE;
}

BOOL
REDIRECTION_REQUEST::ReadVirtualRedirections(
    IN REDIRECTION_LIST *   pRL,
    IN CHAR *               achObjectName
)
/*++

Routine Description:

    Recursive function that traverses the METABASE tree for redirections
    and adds them to the appropriate REDIRECTION_LIST.

Arguments:

    pRL - REDIRECTION_LIST which to add to
    achObjectName -> Root name of tree to traverse

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD                   dwRet;
    STACK_STR(              strBuffer, MAX_PATH);
    DWORD                   dwCounter = 0;
    DWORD                   cbStubLen;

#if 0
    if ( !strBuffer.Resize( METADATA_MAX_NAME_LEN ) ||
         !strBuffer.Copy( achObjectName ) ||
         !strBuffer.Append( "/" ) )
    {
        return FALSE;
    }

    cbStubLen = strBuffer.QueryCB();

    while ( TRUE )
    {
        dwRet = MDEnumMetaObjects( METADATA_MASTER_ROOT_HANDLE,
                                   achObjectName,
                                   strBuffer.QueryStr() + cbStubLen,
                                   dwCounter++ );

        if ( dwRet == ERROR_NO_MORE_ITEMS )
        {
            METADATA_RECORD         mdrSource;
            METADATA_RECORD         mdrDestination;
            STR                     strSource;
            STR                     strDestination;

            strSource.Resize( REDIR_MAX_SOURCE );
            strDestination.Resize( REDIR_MAX_DESTINATION );

            mdrSource.dwMDAttributes = 0;
            mdrSource.dwMDUserType = 0;
            mdrSource.dwMDIdentifier = REDIR_SOURCE;
            mdrSource.dwMDDataType = 0;
            mdrSource.dwMDDataLen = REDIR_MAX_SOURCE;
            mdrSource.pvMDData = strSource.QueryStr();

            dwRet = MDGetMetaData( METADATA_MASTER_ROOT_HANDLE,
                                   achObjectName,
                                   &mdrSource );

            if ( dwRet != ERROR_SUCCESS )
            {
                return TRUE;
            }

            mdrDestination.dwMDAttributes = 0;
            mdrDestination.dwMDUserType = 0;
            mdrDestination.dwMDIdentifier = REDIR_DESTINATION;
            mdrDestination.dwMDDataType = 0;
            mdrDestination.dwMDDataLen = REDIR_MAX_DESTINATION;
            mdrDestination.pvMDData = strDestination.QueryStr();

            dwRet = MDGetMetaData( METADATA_MASTER_ROOT_HANDLE,
                                   achObjectName,
                                   &mdrDestination );

            _fEmpty = FALSE;

            pRL->AddRedirectionItemToList( strSource.QueryStr(),
                                           strDestination.QueryStr() );

            return TRUE;
        }
        else if ( dwRet != ERROR_SUCCESS )
        {
            return TRUE;
        }
        else
        {
            if ( !ReadVirtualRedirections( pRL, strBuffer.QueryStr() ) )
            {
                return FALSE;
            }
        }
    }
#endif

    return TRUE;
}

BOOL
REDIRECTION_REQUEST::ReadConfiguration( VOID )
/*++

Routine Description:

    Read configuration from metabase

Arguments:

    none

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL                fSuccess = FALSE;
    DWORD               dwRet;
    METADATA_RECORD     mdrData;
    DWORD               dwCounter = 0;
    DWORD               dwPhysCounter = 0;
    CHAR                achRedir[ REDIR_MAX_SOURCE + REDIR_MAX_DESTINATION + 1 ];
    CHAR                achObjectName[ METADATA_MAX_NAME_LEN ];
    REDIRECTION_LIST *  pRL;

    EnterWriteState();

    FreeRedirectionLists();

    InitList();

    fSuccess = ReadFromIniFile();

#if 0

    if ( !fSuccess )
        goto Finish;

    dwRet = MDInitialize();
    if ( dwRet != ERROR_SUCCESS )
    {
        goto Finished;
    }

    // generate REDIRECTION_LIST for each server in metabase

    while ( TRUE )
    {
        dwRet = MDEnumMetaObjects( METADATA_MASTER_ROOT_HANDLE,
                                   NULL,
                                   achObjectName,
                                   dwCounter++ );

        if ( dwRet == ERROR_NO_MORE_ITEMS )
        {
            break;
        }
        else if ( dwRet != ERROR_SUCCESS )
        {
            goto Finished;
        }
        else
        {
            if ( !strcmp( achObjectName, "*" ) )
            {
                pRL = AddNewDefaultList();
            }
            else
            {
                pRL = AddNewRedirectionList( achObjectName );
            }
            if ( ( pRL == NULL ) || !pRL->IsValid() )
            {
                goto Finished;
            }

            if ( !ReadVirtualRedirections( pRL, achObjectName ) )
            {
                goto Finished;
            }

            // Now get physical redirections -> located in root object

            dwPhysCounter = 0;

            while ( TRUE )
            {
                mdrData.dwMDAttributes = 0;
                mdrData.dwMDUserType = REDIR_PHYSICAL;
                mdrData.dwMDDataType = ALL_METADATA;
                mdrData.dwMDDataLen = REDIR_MAX_SOURCE + REDIR_MAX_DESTINATION + 1;
                mdrData.pvMDData = achRedir;

                dwRet = MDEnumMetaData( METADATA_MASTER_ROOT_HANDLE,
                                        achObjectName,
                                        &mdrData,
                                        dwPhysCounter++ );

                if ( dwRet == ERROR_NO_MORE_ITEMS )
                {
                    break;
                }
                else if ( dwRet != ERROR_SUCCESS )
                {
                    break;
                }
                else
                {
                    CHAR *          pchNext;

                    pchNext = strstr( achRedir, "-->" );

                    if ( pchNext != NULL )
                    {
                        *pchNext = '\0';

                        pRL->AddRedirectionItemToList( achRedir,
                                                       pchNext + sizeof( "-->" ) );
                    }
                }
            }
        }
    }

    fSuccess = TRUE;
Finished:
    MDTerminate( FALSE );
#endif

    ExitWriteState();

    return fSuccess;
}

BOOL
REDIRECTION_REQUEST::ReadFromIniFile(
    VOID
    )
{
    DWORD               dwRet;
    STR                 strServerNameBuffer;
    DWORD               cbServerNameBuffer = REDIR_MAX_SERVER_BUFFER + 1;
    CHAR *              pszServerName;
    BOOL                fSuccess = FALSE;

    if ( !strServerNameBuffer.Resize( cbServerNameBuffer ) )
    {
        return FALSE;
    }

    while( TRUE )
    {
        dwRet = GetPrivateProfileString( NULL,
                                         NULL,
                                         "",
                                         strServerNameBuffer.QueryStr(),
                                         cbServerNameBuffer,
                                         _strFilename.QueryStr() );
        if ( dwRet == (cbServerNameBuffer - 2) )
        {
            cbServerNameBuffer *= 2;

            if ( !strServerNameBuffer.Resize( cbServerNameBuffer ) )
            {
                return FALSE;
            }
        }
        else
        {
            break;
        }
    }

    pszServerName = strServerNameBuffer.QueryStr();

    while ( *pszServerName != '\0' )
    {
        STR                 strRedirectList;
        DWORD               cbRedirectList = REDIR_MAX_REDIR_LIST + 1;
        CHAR *              pszRedirectItem;
        DWORD               dwListRet;
        REDIRECTION_LIST *  pRL;

        if ( !strcmp( pszServerName, REDIR_DEFAULT_SERVER ) )
        {
            pRL = AddNewDefaultList();
        }
        else
        {
            pRL = AddNewRedirectionList( pszServerName );
        }
        if ( pRL == NULL )
        {
            return FALSE;
        }

        if ( !strRedirectList.Resize( cbRedirectList ) )
        {
            return FALSE;
        }

        while ( TRUE )
        {
            dwListRet = GetPrivateProfileString( pszServerName,
                                                 NULL,
                                                 "",
                                                 strRedirectList.QueryStr(),
                                                 cbRedirectList,
                                                 _strFilename.QueryStr() );
            if ( dwListRet == ( cbRedirectList - 2 ) )
            {
                // buffer wasn't big enough

                cbRedirectList *= 2;

                if ( !strRedirectList.Resize( cbRedirectList ) )
                {
                    return FALSE;
                }
            }
            else
            {
                break;
            }
        }

        strRedirectList.SetLen( strlen( strRedirectList.QueryStr() ));

        pszRedirectItem = strRedirectList.QueryStr();

        while ( *pszRedirectItem != '\0' )
        {
            STR             strRedirectDest;
            DWORD           dwItemRet;
            DWORD           cbDestLen = REDIR_MAX_DESTINATION + 1;

            if ( !strRedirectDest.Resize( cbDestLen ) )
            {
                return FALSE;
            }

            dwItemRet = GetPrivateProfileString( pszServerName,
                                                 pszRedirectItem,
                                                 "",
                                                 strRedirectDest.QueryStr(),
                                                 cbDestLen,
                                                 _strFilename.QueryStr() );
            if ( dwItemRet != 0 )
            {
                // add the item to redirection list



                if ( pRL->AddRedirectionItemToList( pszRedirectItem,
                                                    strRedirectDest.QueryStr() ) )
                {
                    // at this point, we know that at least one redirection
                    // exists.

                    _fEmpty = FALSE;
                }
            }

            pszRedirectItem += strlen( pszRedirectItem ) + 1;
        }

        pszServerName += strlen( pszServerName ) + 1;
    }

    return TRUE;
}

BOOL
REDIRECTION_REQUEST::GetRedirectedURL(
    IN STR &                    strServerName,
    IN STR &                    strSource,
    IN STR &                    strQueryString,
    OUT STR *                   pstrDestination,
    OUT STR *                   pstrRedirectMessage,
    IN DWORD                    dwErrorCode,
    IN HTTP_FILTER_CONTEXT *    pfc
)
/*++

Routine Description:

    Gets the redirected URL (if any) for the specified source URL and server.

Arguments:

    strServerName - Name of server for which URL request was made.
    strSource - URL requested
    strQueryString - QueryString of Request
    pstrDestination - Destination URL after redirection (if any)
    pstrRedirectMessage - Redirect message (301 or 302)
    dwErrorCode - Error notification code ( 0 if no error)
    pfc - Filter context

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    REDIRECTION_LIST *      pRL;
    LIST_ENTRY *            pEntry;
    BOOL                    fRet = FALSE;

    EnterReadState();

    // First search for a matching REDIRECTION_LIST for strServerName

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pRL = CONTAINING_RECORD( pEntry,
                                 REDIRECTION_LIST,
                                 _ListEntry );
        if ( pRL->IsServerMatch( strServerName ) )
        {
            fRet = pRL->GetRedirectedURLFromList( strSource,
                                                  strQueryString,
                                                  pstrDestination,
                                                  pstrRedirectMessage,
                                                  dwErrorCode,
                                                  pfc );
            break;
        }
    }

    // If first search was unsuccessful and default REDIRECTION_LIST exists,
    // try it.

    if ( ( fRet == NULL ) && ( _pRLDefault != NULL ) )
    {
        fRet = _pRLDefault->GetRedirectedURLFromList( strSource,
                                                      strQueryString,
                                                      pstrDestination,
                                                      pstrRedirectMessage,
                                                      dwErrorCode,
                                                      pfc );
    }

    ExitReadState();

    return fRet;
}

/* REDIRECTION_REQUEST::AddNewDefaultList()

   Adds a DEFAULT SERVER list if specified in metabase
   If no redirection if found for a specific server, this list (if existing)
   is also searched for redirections.

   Input: None

   Returns:  Pointer to new REDIRECTION_LIST or NULL if failed
*/
REDIRECTION_LIST *
REDIRECTION_REQUEST::AddNewDefaultList( VOID )
{
    if ( _pRLDefault != NULL )
    {
        delete _pRLDefault;
    }

    _pRLDefault = new REDIRECTION_LIST( NULL );
    if ( _pRLDefault == NULL )
    {
        return NULL;
    }
    else if ( !_pRLDefault->IsValid() )
    {
        delete _pRLDefault;
        return NULL;
    }
    else
    {
        return _pRLDefault;
    }
}

/* REDIRECTION_REQUEST::AddNewRedirectionList()

   Adds a list specific to the given server name.

   Input:  pszServerName --> Name of server to associate list to.

   Returns:  Pointer to new REDIRECTION_LIST or NULL if failed

*/
REDIRECTION_LIST *
REDIRECTION_REQUEST::AddNewRedirectionList(
    IN CHAR *           pszServerName
)
{
    REDIRECTION_LIST        *pRL;

    pRL = new REDIRECTION_LIST( pszServerName );
    if ( pRL == NULL )
    {
        return NULL;
    }
    else if ( !pRL->IsValid() )
    {
        delete pRL;
        return NULL;
    }

    AddItem( pRL );
    return pRL;
}

/* GetRedirectToken()

   Searches token table for match.

   Input:  pchToken --> Pointer to string to check
   Output: pdwLen   --> (optional) Receives the length of the matched token.
*/
DWORD
GetRedirectToken(
    IN CHAR *       pchToken,
    OUT DWORD *     pdwLen
)
{
    DWORD           dwCounter = 0;
    CHAR *          pszEntry;

    while ( RedirectTokenList[ dwCounter ].pszKeyword != NULL )
    {
        if ( !_strnicmp( pchToken,
                         RedirectTokenList[ dwCounter ].pszKeyword,
                         RedirectTokenList[ dwCounter ].cbLen ) )
        {
            break;
        }
        dwCounter++;
    }
    if ( pdwLen != NULL )
    {
        *pdwLen = RedirectTokenList[ dwCounter ].cbLen;
    }
    return RedirectTokenList[ dwCounter ].rtType;
}

DWORD
UpdateRedirectionList(
    IN DWORD            dwCallBackType,
    MD_CHANGE_OBJECT    pObjList,
    IN PVOID            pvData
)
// Called by METABASE callback when changes are made.  Right now its not
// implemented, but when it is, should improve by only Re-reading
// configuration if necessary ?
{
    REDIRECTION_REQUEST * pReq = (REDIRECTION_REQUEST*) pvData;

    pReq->ReadConfiguration();

    return ERROR_SUCCESS;
}

CHAR *
RedirectSkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
    )
{
    return (CHAR*) memchr( pchFilePos, ch, pchEOF - pchFilePos );
}

CHAR *
RedirectSkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
    )
{
    while ( pchFilePos < pchEOF )
    {
        if ( !isspace( (UCHAR)(*pchFilePos) ) )
            return pchFilePos;

        pchFilePos++;
    }

    return NULL;
}

// globals

REDIRECTION_REQUEST *           g_pReq = NULL;
DECLARE_DEBUG_PRINTS_OBJECT()
DECLARE_DEBUG_VARIABLE();

BOOL
WINAPI
GetFilterVersion(
    IN PHTTP_FILTER_VERSION     pVer
)
{
    pVer->dwFilterVersion  = MAKELONG( 0, 3 );

    strcpy( pVer->lpszFilterDesc,
            "Microsoft HTTP Redirection filter v1.0" );

    pVer->dwFlags = SF_NOTIFY_ORDER_DEFAULT |
                    SF_NOTIFY_PREPROC_HEADERS |
                    SF_NOTIFY_SEND_RESPONSE;

    g_pReq = new REDIRECTION_REQUEST;
    if ( g_pReq == NULL )
    {
        return FALSE;
    }
    else if ( !g_pReq->IsValid() )
    {
        delete g_pReq;
        g_pReq = NULL;
        return FALSE;
    }

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData
    )
{

    // first check if there are any redirections at all
    // if not, just return out right away to save time

    if ( g_pReq->IsEmpty() )
    {
        goto Finished;
    }

    switch ( NotificationType )
    {
    case SF_NOTIFY_PREPROC_HEADERS:
    case SF_NOTIFY_SEND_RESPONSE:
    {
        STACK_STR(                  strDestination, MAX_PATH);
        DWORD                       cbBufLen = REDIR_MAX_SOURCE + 1;
        STACK_STR(                  strSource, REDIR_MAX_SOURCE + 1);
        STACK_STR(                  strRedirectMessage, MAX_PATH);
        STACK_STR(                  strTempOrPerm, MAX_PATH);
        STACK_STR(                  strServerName, MAX_PATH);
        STACK_STR(                  strQueryString, MAX_PATH);
        CHAR *                      pchQuery;
        DWORD                       dwErrorCode = 0;

TryAgain:

        if ( !strSource.Resize( cbBufLen ) )
        {
            goto Finished;
        }

        cbBufLen = strSource.QuerySize();

        // If this is an error notification, get URL using GetServerVariable

        if ( NotificationType != SF_NOTIFY_PREPROC_HEADERS )
        {
            if ( !pfc->GetServerVariable( pfc,
                                          "URL",
                                          strSource.QueryStr(),
                                          &cbBufLen ))
            {
                // If buffer was not large enough, loop back and resize
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    goto TryAgain;
                }

                goto Finished;
            }

            strSource.SetLen( cbBufLen - sizeof(CHAR) );
        }

        // Otherwise use GetHeader( url )

        else
        {
            if ( !((HTTP_FILTER_PREPROC_HEADERS*)pvData)->GetHeader( pfc,
                                                          "url",
                                                          strSource.QueryStr(),
                                                          &cbBufLen ) )
            {
                // If buffer was not large enough, loop back and resize
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    goto TryAgain;
                }

                goto Finished;
            }

            //
            // Remove query string (if any) from URL
            //

            pchQuery = strchr( strSource.QueryStr(), '?' );
            if ( pchQuery != NULL )
            {
                if ( !strQueryString.Copy( pchQuery + 1 ))
                {
                    goto Finished;
                }

                strSource.SetLen( pchQuery - strSource.QueryStr() );
            }
            else
            {
                strSource.SetLen( cbBufLen - sizeof(CHAR) );
            }
        }

        cbBufLen = REDIR_MAX_SERVER_NAME + 1;
        if ( !strServerName.Resize( cbBufLen ) )
        {
            goto Finished;
        }

        if ( !pfc->GetServerVariable( pfc,
                                      "LOCAL_ADDR",
                                      strServerName.QueryStr(),
                                      &cbBufLen ) )
        {
            goto Finished;
        }

        strServerName.SetLen( cbBufLen - sizeof(CHAR) );

        if ( NotificationType == SF_NOTIFY_SEND_RESPONSE )
        {
            dwErrorCode = ((HTTP_FILTER_SEND_RESPONSE*)pvData)->HttpStatus;
        }

        if ( !g_pReq->GetRedirectedURL( strServerName,
                                        strSource,
                                        strQueryString,
                                        &strDestination,
                                        &strTempOrPerm,
                                        dwErrorCode,
                                        pfc ) )
        {
            goto Finished;
        }
        else
        {
            if ( !strRedirectMessage.Copy( "Location: " ) ||
                 !strRedirectMessage.Append( strDestination ) ||
                 !strRedirectMessage.Append( "\r\n" ) )
            {
                goto Finished;
            }

            if ( !pfc->ServerSupportFunction( pfc,
                                              SF_REQ_SEND_RESPONSE_HEADER,
                                              (PVOID) strTempOrPerm.QueryStr(),
                                              (DWORD) strRedirectMessage.QueryStr(),
                                              0 ) )
            {
                goto Finished;
            }
            return SF_STATUS_REQ_FINISHED;
        }
        break;
    }
    default:
        goto Finished;
    }

Finished:
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

BOOL
WINAPI
TerminateFilter(
    DWORD  dwFlags
    )
{
    if ( g_pReq )
    {
        g_pReq->Shutdown();
        delete g_pReq;
        g_pReq = NULL;
    }

    return TRUE;
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        CREATE_DEBUG_PRINT_OBJECT( REDIR_DLL_NAME );
        SET_DEBUG_FLAGS( 0 );

        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }

    return TRUE;
}

DWORD
REDIRECTION_REQUEST::RedirectLoop( VOID )
/*++

Routine Description:

    Loop to be used by notification thread that waits for changes in
    REDIRECT.INI file.  As they occur, the REDIRECTION_LISTs in memory
    are deleted and rebuilt (but only after there are no more read threads
    accessing the lists).

Arguments:

    NONE

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    FILETIME                    ftLast;
    FILETIME                    ftCurrent;
    DWORD                       dwRet;
    HANDLE                      hHandleArray[ 2 ];
    HANDLE                      hNotification;

    // Get original LastModTime for use in comparison

    if ( !GetLastModTime( _strFilename,
                          &ftLast ) )
    {
        return FALSE;
    }

    hNotification = FindFirstChangeNotification( _strDirectory.QueryStr(),
                                                 FALSE,
                                                 FILE_NOTIFY_CHANGE_LAST_WRITE );

    if ( hNotification == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    while ( TRUE )
    {
        if ( !FindNextChangeNotification( hNotification ) )
        {
            goto Finished;
        }

        hHandleArray[ 0 ] = _hShutdownEvent;
        hHandleArray[ 1 ] = hNotification;

        // Wait for 2 events, upon shutdown, _hShutdownEvent will be
        // signaled, thus causing loop and thread to finish cleanly

        dwRet = WaitForMultipleObjects( 2,
                                        hHandleArray,
                                        FALSE,
                                        INFINITE );

        switch ( dwRet - WAIT_OBJECT_0 )
        {
        case 0:

            // Time to shutdown cleanly

            goto Finished;
        case 1:

            // Compare new LastModTime of file

            if ( !GetLastModTime( _strFilename,
                                  &ftCurrent ) )
            {
                continue;
            }

            // If newer, Reread the configuration file in memory

            if ( CompareFileTime( &ftLast,
                                  &ftCurrent ) == -1 )
            {
                ReadFromIniFile();
                memcpy( &ftLast, &ftCurrent, sizeof( FILETIME ) );
            }
            break;
        default:
            goto Finished;
        }
    }

Finished:
    return FindCloseChangeNotification( hNotification );
}

DWORD
RedirectThread(
    IN PVOID        Parms
)
/*++

Routine Description:

    Calls redirection loop

Arguments:

    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    REDIRECTION_REQUEST *       pReq;

    pReq = (REDIRECTION_REQUEST*) Parms;

    return pReq->RedirectLoop();
}

BOOL
GetLastModTime(
    IN STR &        strFilename,
    OUT FILETIME *  pftModTime
)
/*++

Routine Description:

    Retrieves the Last Modification time of file.

Arguments:

    strFilename - Filename of file to check
    pftModTime - Receives FILETIME structure containing LastModTime

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    HANDLE          hHandle;

    hHandle = CreateFile( strFilename.QueryStr(),
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );

    if ( hHandle == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    if ( !GetFileTime( hHandle,
                       NULL,
                       NULL,
                       pftModTime ) )
    {
        CloseHandle( hHandle );
        return FALSE;
    }

    CloseHandle( hHandle );
    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\sspi\credcach.cxx ===
/*++









Copyright (c) 1995  Microsoft Corporation

Module Name:

    credcach.cxx

Abstract:

    This module contains the code to associate and cache SSPI credential
    handles with local server addresses

Author:

    John Ludeman (johnl)   18-Oct-1995

Revision History:


Comments :

      This is a two-level cache : the first level is at the instance level [INSTANCE_CACHE_ITEM]
and just contains a pointer to the actual item holding the credential handles. The second level
[CRED_CACHE_ITEM] holds the actual credential handles, as well as pointers to the mappers.

An INSTANCE_CACHE_ITEM points to a CRED_CACHE_ITEM, with a single CRED_CACHE_ITEM potentially
being referenced by several INSTANCE_CACHE_ITEMS, if several instances share the relevant data.

      Each instance has 3 SSL-related components : the server certificate for the instance, the
certificate mappers for the instance and the trusted issuers for the instance [a combination of
the certificates in the ROOT store and the Certificate Trust List associated with the server]. Two
instances can share a CRED_CACHE_ITEM under the following circumstances :

1. The same server certificate
2. No/Same CTL
3. No mappers

The INSTANCE_CACHE_ITEM entries are keyed off "IP:port:<instance ptr>"; the CRED_CACHE_ITEM
entries are keyed off an "SSL info" blob which can be used to uniquely distinguish between
credential sets that don't fulfill the criteria listed above. The SSL info blob is obtained by
querying the instance and consists of "<SHA1 hash of server cert>:<SHA1 hash of CTL>",
which has the advantage of being fixed length [20 bytes for cert hash, 20 bytes for CTL hash,
1 byte for ':']. If there is no CTL, the length is still 41, but everything after the
cert hash is zeroed out.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>
#include <stdlib.h>

#include <w3p.hxx>

#define SECURITY_WIN32
#include <sspi.h>
#include <ntsecapi.h>
#include <spseal.h>
#include <schnlsp.h>
#include <iis64.h>
#include <credcach.hxx>
#include <w3svc.h>
#include <eventlog.hxx>
#if !defined(IIS3)
#include <iis2pflt.h>
#endif


#include <dbgutil.h>
#include <buffer.hxx>
#include <string.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <iiscnfgp.h>

#include <iistypes.hxx>
#include <cmnull.hxx>
#include <iiscrmap.hxx>
#include <iiscert.hxx>
#include <iisctl.hxx>
#include <capiutil.hxx>
#include <sslinfo.hxx>

#if DBG
#define PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define PRINTF( x )
#endif

#define SSPIFILT_CERT_MAP_LIST  "CertMapList"
#define SSPIFILT_INIT_MAP       "CreateInstance"
#define SSPIFILT_TERM_MAP       "TerminateMapper"

//
//  Globals
//

LIST_ENTRY CredCacheList;
LIST_ENTRY InstanceCacheList;
IMDCOM*    g_pMDObject;
BOOL    g_fCryptoParams = FALSE;
BOOL    g_fQueriedCryptoParams = FALSE;
DWORD   g_dwMinCipherStrength;
DWORD   g_dwMaxCipherStrength;


//
//  Prototypes
//


LoadKeys(
    IN  IIS_SSL_INFO *pSSLInfo,
    IN  PVOID        pvInstance,
    IN  HMAPPER**    ppMappers,
    IN  DWORD        cNbMappers,
    OUT CredHandle * phCreds,
    OUT DWORD *      pcCred,
    OUT CredHandle * phCredsMap,
    OUT DWORD *      pcCredMap,
    IN  LPSTR        pszMdPath
    );

BOOL
AddFullyQualifiedItem(
    CHAR *                  pszId,
    IN  UINT                cId,
    CHAR *                  pszAddress,
    IN  CHAR *              pszPort,
    IN  LPVOID              pvInstanceId,
    IN  HTTP_FILTER_CONTEXT*pfc,
    IN  DWORD               dwInstanceId
    );


BOOL
AddItem(
    CHAR * pszAddress,
    LPVOID pvInstanceId,
    RefBlob* pCert11,
    RefBlob* pCertW,
    IIS_SSL_INFO *pSSLInfo,
    CRED_CACHE_ITEM** ppcci,
    DWORD dwInstanceId,
    LPSTR pszMdPath
    );

BOOL
LookupCredential(
    IN  CHAR *              pszAddress,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI
    );

BOOL
InitializeCertMapping(
    LPVOID      pCert11,
    LPVOID      pCertW,
    LPVOID      pSslInfo,
    HMAPPER***  pppMappers,
    LPDWORD     pdwMappers,
    DWORD       dwInstanceId
    );

BOOL
GetDefaultCryptoParams(
    LPDWORD pdwMinCipherStrength,
    LPDWORD pdwMaxCipherStrength
    );


VOID CheckServerCertInfoIsValid( LPVOID pvParam ) ;

VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    );

VOID NotifySslChanges2( LPVOID pvParam );

BOOL GenerateSSLIdBlob( IIS_SSL_INFO *pSSLInfoObj,
                         PBYTE pbBlob );


VOID
InitCredCache(
    VOID
    )
/*++

Routine Description:

    Initializes the credential cache

--*/
{
    InitializeListHead( &CredCacheList );
    InitializeListHead( &InstanceCacheList );
}


VOID
FreeCredCache(
    VOID
    )
/*++

Routine Description:

    Releases all of the memory associated with the credential cache

--*/
{
    LIST_ENTRY * pEntry;
    CRED_CACHE_ITEM * pcci;
    INSTANCE_CACHE_ITEM * pici;

    LockSSPIGlobals();

    DBGPRINTF((DBG_CONTEXT,
              "[SSPIFILT] Freeing credential cache\n"));

    while ( !IsListEmpty( &InstanceCacheList ))
    {
        pici = CONTAINING_RECORD( InstanceCacheList.Flink,
                                  INSTANCE_CACHE_ITEM,
                                  m_ListEntry );

        RemoveEntryList( &pici->m_ListEntry );

        delete pici;
    }

    while ( !IsListEmpty( &CredCacheList ))
    {
        pcci = CONTAINING_RECORD( CredCacheList.Flink,
                                  CRED_CACHE_ITEM,
                                  m_ListEntry );

        RemoveEntryList( &pcci->m_ListEntry );

        pcci->Release();
    }

    UnlockSSPIGlobals();
}


//
// Secret value names. Each value exist in 4 variants,
// used to access the Lsa secret, the 1st one using IP + port
// the 2nd one IP only, the 3rd one port only
// The 4th entry specify designate the default value ( common to all address and ports )
//

struct
{
    WCHAR * pwchSecretNameFormat;
}
SecretTable[4][4] =
{
    L"W3_PUBLIC_KEY_%S:%S", L"W3_PUBLIC_KEY_%S", L"W3_PUBLIC_KEY_%0.0S:%S", L"W3_PUBLIC_KEY_default",
    L"W3_PRIVATE_KEY_%S:%S", L"W3_PRIVATE_KEY_%S", L"W3_PRIVATE_KEY_%0.0:S%S", L"W3_PRIVATE_KEY_default",
    L"W3_KEY_PASSWORD_%S:%S", L"W3_KEY_PASSWORD_%S", L"W3_KEY_PASSWORD_%0.0:S%S", L"W3_KEY_PASSWORD_default",
    L"%S:%S", L"%S", L"%0.0S%S", L"default",
};

LPSTR SecretTableA[4] =
{
    "%s:%s", "%s", "%0.0s%s", "default",
};

BOOL
GetMDSecret(
    MB*             pMB,
    LPSTR           pszObj,
    DWORD           dwId,
    UNICODE_STRING**ppusOut
    )
{
    DWORD           dwL = 0;
    PUNICODE_STRING pusOut;

    if ( pMB->GetData( pszObj,
                       dwId,
                       IIS_MD_UT_SERVER,
                       BINARY_METADATA,
                       NULL,
                       &dwL,
                       METADATA_SECURE ) || GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        pusOut = (PUNICODE_STRING)LocalAlloc( LMEM_FIXED, sizeof(UNICODE_STRING) );

        if ( pusOut )
        {
            pusOut->Buffer = (WORD*)LocalAlloc( LMEM_FIXED, dwL );

            if( pusOut->Buffer )
            {
                if ( pMB->GetData( pszObj,
                                   dwId,
                                   IIS_MD_UT_SERVER,
                                   BINARY_METADATA,
                                   pusOut->Buffer,
                                   &dwL,
                                   METADATA_SECURE ) )
                {
                    pusOut->Length = pusOut->MaximumLength = (WORD)dwL;
                    *ppusOut = pusOut;
                    return TRUE;
                }

                LocalFree( pusOut->Buffer );
            }

            LocalFree( pusOut );
        }
    }

    return FALSE;
}


BOOL
LookupFullyQualifiedCredential(
    IN  CHAR *              pszIpAddress,
    IN  DWORD               cbAddress,
    IN  CHAR *              pszPort,
    IN  DWORD               cbPort,
    IN  LPVOID              pvInstanceId,
    IN  HTTP_FILTER_CONTEXT*pfc,
    OUT CRED_CACHE_ITEM * * ppCCI,
    IN  DWORD               dwInstanceId
    )
/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pszIpAddress - Address name for this credential
    cbAddress - Number of bytes (including '\0') of pszIpAddress
    pszPort - Port ID for this credential
    cbPort - Number of bytes ( including '\0') of pszPort
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    pfc - ptr to filter context using the instance specified in pvInstanceId
    ppCCI - Receives pointer to a Credential Cache Item
    dwInstanceId - w3 instance Id

Returns:

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_INVALID_NAME is returned.

--*/
{
    INSTANCE_CACHE_ITEM *   pcci;
    LIST_ENTRY *            pEntry;
    CHAR                    achId[MAX_ADDRESS_LEN];
    LPSTR                   p = achId;
    UINT                    cId;
    W3_SERVER_INSTANCE      *pW3Instance = NULL;
    BOOL                    fInstanceLock = FALSE;

    DBG_ASSERT( pvInstanceId );

    pW3Instance = (W3_SERVER_INSTANCE *) pvInstanceId;

    if ( g_pMDObject == NULL )
    {
        if ( !pfc->ServerSupportFunction( pfc,
                                          SF_REQ_GET_PROPERTY,
                                          (IMDCOM*)&g_pMDObject,
                                          (UINT)SF_PROPERTY_MD_IF,
                                          NULL ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to get metabase interface, error 0x%d\n",
                       GetLastError()));
            return FALSE;
        }
    }

    //
    // build ID of this credential request : IP address + port + instance
    //

    memcpy( p, pszIpAddress, cbAddress );
    p += cbAddress;
    *p++ = ':';
    memcpy( p, pszPort, cbPort );
    p += cbPort;
    *p++ = ':';

    // old code (broken for 64bit)
    //*(LPVOID*)p = pvInstanceId;
    //cId = DIFF(p - achId) + sizeof(LPVOID);

    // new fixed code (working for 64bit)
    memcpy( p, &pvInstanceId, sizeof(pvInstanceId));
    cId = DIFF(p - achId) + sizeof(pvInstanceId);

    //
    // Note : this has to be outside the RescanList loop, so we only enter the critical
    // section once
    //
    LockSSPIGlobals();

RescanList:

    for ( pEntry  = InstanceCacheList.Flink;
          pEntry != &InstanceCacheList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, INSTANCE_CACHE_ITEM, m_ListEntry );

        if ( pcci->m_cbId == cId &&
             !memcmp( pcci->m_achId, achId, cId ) )
        {
             //
            //  If this is an item we failed to find previously, then return
            //  an error
            //

            if ( pcci->m_fValid )
            {
                *ppCCI = pcci->m_pcci;
                pcci->m_pcci->AddRef();

                if ( fInstanceLock )
                {
                   pW3Instance->UnlockThis();
                }
                UnlockSSPIGlobals();


                return TRUE;
            }

            SetLastError( ERROR_INVALID_NAME );
            *ppCCI = NULL;

            if ( fInstanceLock )
            {
               pW3Instance->UnlockThis();
            }

            UnlockSSPIGlobals();

            return FALSE;
        }
    }

    //
    //  This address isn't in the list, try getting it into the credential cache then
    //  rescan the list for the new item.  Note we leave the list locked
    //  while we try and get the item.  This prevents multiple threads from
    //  trying to create the same item. Also, we need to acquire the instance
    //  lock in order to avoid a deadlock between a thread trying to add/retrieve
    //  the credential [which requires some function calls that take the instance lock and the
    //  g_csGlobalLock that protects the cache] and another thread processing the
    //  notification that the server cert has changed [which first acquires the instance lock
    //  and then the g_csGlobalLock lock] - first we acquire the instance lock and then
    //  g_csGlobalLock, so that the locks concerned are always acquired in the same order.
    //

    UnlockSSPIGlobals();

    ((W3_SERVER_INSTANCE *) pvInstanceId)->LockThisForWrite();
    fInstanceLock = TRUE;
    LockSSPIGlobals();

    //
    // Rescan the list to see whether another thread has added the item
    // while we were acquiring the locks
    //
    for ( pEntry  = InstanceCacheList.Flink;
          pEntry != &InstanceCacheList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, INSTANCE_CACHE_ITEM, m_ListEntry );

        if ( pcci->m_cbId == cId &&
             !memcmp( pcci->m_achId, achId, cId ) )
        {
            //
            //  If this is an item we failed to find previously, then return
            //  an error
            //

            if ( pcci->m_fValid )
            {
                *ppCCI = pcci->m_pcci;
                pcci->m_pcci->AddRef();

               pW3Instance->UnlockThis();
               UnlockSSPIGlobals();


                return TRUE;
            }

             SetLastError( ERROR_INVALID_NAME );
             *ppCCI = NULL;

            pW3Instance->UnlockThis();
            UnlockSSPIGlobals();

            return FALSE;
        }
     }

    //
    // Credential hasn't been added, let's try to do so
    //
    if ( !AddFullyQualifiedItem( achId,
                                 cId,
                                 pszIpAddress,
                                 pszPort,
                                 pvInstanceId,
                                 pfc,
                                 dwInstanceId ))
    {
        pW3Instance->UnlockThis();
        UnlockSSPIGlobals();

        return FALSE;
    }

    //
    // Rescan the list to (hopefully) get the credential
    //
    goto RescanList;

}


VOID
ReleaseCredential(
    CRED_CACHE_ITEM * pcci
    )
/*++

Routine Description:

    Release a credential acquired via LookupFullyQualifiedCredential()

Arguments:

    pCCI - pointer to a Credential Cache Item

Returns:

    Nothing

--*/
{
    if ( pcci )
    {
        pcci->Release();
    }
}



BOOL
AddFullyQualifiedItem(
    IN  CHAR *              pszId,
    IN  UINT                cId,
    IN  CHAR *              pszAddress,
    IN  CHAR *              pszPort,
    IN  LPVOID              pvInstanceId,
    IN  HTTP_FILTER_CONTEXT*pfc,
    IN  DWORD               dwInstanceId
    )
/*++

Routine Description:

    Creates a new item in the credential cache and adds it to the list

    pszAddress must be a simple string that has no odd unicode mappings

    THIS ROUTINE MUST BE SINGLE-THREADED.

Arguments:

    pszId - ID of cache entry to add
    cId - size of pszId
    pszAddress - Address name for this credential
    pszPort - port for this credential
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    pfc - ptr to filter context using the instance specified in pvInstanceId
    dwInstanceId - w3 instance Id

Returns:

    TRUE on success, FALSE on failure

--*/
{
    WCHAR             achSecretName[MAX_SECRET_NAME+1];
    CHAR              achSecretNameA[MAX_SSL_ID_LEN + 1];
    UNICODE_STRING *  SecretValue[3];
    DWORD             i;
    DWORD             j;
    BOOL              fRet = TRUE;
    INSTANCE_CACHE_ITEM * pcci;
    CHAR              achPassword[MAX_PATH+1];
    DWORD             cch;
    CRED_CACHE_ITEM * pci = NULL;
    IIS_SSL_INFO      *pSSLInfoObj = NULL;
    PBYTE             pbSSLBlob = NULL;
    MB                mb( g_pMDObject );
    LPSTR             pszMDPath;
    RefBlob           *pBlob11 = NULL;
    RefBlob           *pBlobW = NULL;
    W3_SERVER_INSTANCE *pW3Instance = (W3_SERVER_INSTANCE *) pvInstanceId;

    DBG_ASSERT( pvInstanceId );

#if 1
    if ( !( pszMDPath = (LPSTR) pW3Instance->QueryMDPath() ) )
    {
        pszMDPath = DEFAULT_SERVER_CERT_MD_PATH ;
    }

    DBGPRINTF((DBG_CONTEXT,
               "Trying to retrieve credential for instance %d, w/ path %s \n",
               dwInstanceId,
               pszMDPath));


#else
    //
    // Get the metadata path for this instance
    //
    if ( !pfc->ServerSupportFunction( pfc,
                                      SF_REQ_GET_PROPERTY,
                                      (LPVOID) &pMdPath,
                                      (UINT) SF_PROPERTY_MD_PATH,
                                      NULL ) ||
         !pMdPath )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Null instance, using default instance path ..\n"));

        pMdPath = DEFAULT_SERVER_CERT_MD_PATH ;
    }

    DBGPRINTF((DBG_CONTEXT,
               "Trying to add credential for instance w/ path %s \n",
               pMdPath));
#endif

    if ( cId > MAX_ADDRESS_LEN )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Create and initialize the context item
    //

    pcci = new INSTANCE_CACHE_ITEM;

    if ( !pcci )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        mb.Close();
        return FALSE;
    }

    memcpy( pcci->m_achId, pszId, cId );
    pcci->m_cbId = cId;
    pcci->m_pvInstanceId = pvInstanceId;

    pcci->m_fValid = FALSE;
    pcci->m_pcci = NULL;

    InsertTailList( &InstanceCacheList, &pcci->m_ListEntry );

    fRet = FALSE;

    //
    // Get the "SSL id" blob used to locate the CRED_CACHE_ITEM for this instance
    //
    if ( ( pSSLInfoObj = pW3Instance->GetAndReferenceSSLInfoObj()) &&
         GenerateSSLIdBlob( pSSLInfoObj,
                            (PBYTE) achSecretNameA ) )
    {
        fRet = TRUE ;
    }

#if 0

    //
    //  Retrieve the secret from the registry
    //

    memset( SecretValue, 0, sizeof( SecretValue ));

    //
    // Try the 4 possible secret names
    //

    for ( j = 0 ; j < 4 ; ++j )
    {
#if defined(SSL_MD)

        wsprintf(  achSecretNameA,
                   SecretTableA[j],
                   pszAddress, pszPort );


        if ( GetMDSecret( &mb,
                          achSecretNameA,
                          MD_SSL_PUBLIC_KEY,
                          &SecretValue[0] ) &&
             GetMDSecret( &mb,
                          achSecretNameA,
                          MD_SSL_PRIVATE_KEY,
                          &SecretValue[1] ) &&
             GetMDSecret( &mb,
                          achSecretNameA,
                          MD_SSL_KEY_PASSWORD,
                          &SecretValue[2] ) )
        {
            fRet = TRUE;
            break;
        }
#else
        for ( i = 0; i < 3; i++ )
        {
            //
            //  Build the name
            //

            wsprintfW( achSecretName,
                       SecretTable[i][j].pwchSecretNameFormat,
                       pszAddress, pszPort );

            //
            //  Get the secrets
            //

            if ( !GetSecretW( achSecretName,
                              &SecretValue[i] ))
            {
                break;
            }
        }

        //
        // build net ID, used to locate CRED_CACHE_ITEM
        //

        if ( i == 3 )
        {
            wsprintf(  achSecretNameA,
                       SecretTableA[j],
                       pszAddress, pszPort );
            fRet = TRUE;
            break;
        }
#endif //SSL_MD

    }

#endif //if 0

    mb.Close();

    if ( fRet )
    {
#if 1
        pBlob11 = (RefBlob *) pW3Instance->QueryMapper( MT_CERT11 );

        pBlobW = (RefBlob *) pW3Instance->QueryMapper( MT_CERTW );

#else
        //
        // Retrieve blobs pointing to cert 1:1 mapper & cert wildcard mapper
        //

        if ( !pfc->ServerSupportFunction( pfc,
                                          SF_REQ_GET_PROPERTY,
                                          (LPVOID)&pBlob11,
                                          (UINT)SF_PROPERTY_GET_CERT11_MAPPER,
                                          NULL ) )
        {
            pBlob11 = NULL;
        }

        if ( !pfc->ServerSupportFunction( pfc,
                                          SF_REQ_GET_PROPERTY,
                                          (LPVOID)&pBlobW,
                                          (UINT)SF_PROPERTY_GET_RULE_MAPPER,
                                          NULL ) )
        {
            pBlobW = NULL;
        }
#endif
        //
        // All instances w/o mappers maps to NULL, so that they share a CRED_CACHE_ENTRY
        //

        if ( pBlob11 == NULL && pBlobW == NULL )
        {
            pvInstanceId = NULL;
        }

        //
        // try fo find it in cache
        // returned cache entry's refcount is incremented by LookupCredential or AddItem
        // if successfull
        //
        if ( !LookupCredential( (LPSTR)achSecretNameA,
                                pvInstanceId,
                                &pci ) )
        {
            if ( GetLastError() == ERROR_NO_MORE_ITEMS )
            {
                //
                //  This address isn't in the list, try getting it from the lsa then
                //  rescan the list for the new item.  Note we leave the list locked
                //  while we try and get the item.  This prevents multiple threads from
                //  trying to create the same item
                //
                if ( AddItem( (LPSTR) achSecretNameA,
                              pvInstanceId,
                              pBlob11,
                              pBlobW,
                              pSSLInfoObj,
                              &pci,
                              dwInstanceId,
                              pszMDPath ) )
                {
                    pcci->m_pcci = pci;
                    pcci->m_fValid = TRUE;
                }
            }
        }
        else
        {
            pcci->m_pcci = pci;
            pcci->m_fValid = TRUE;
        }
    }

    //
    // Release blob now. CRED_CACHE_ITEM added a reference to them
    // if entry created
    //

    if ( pBlob11 != NULL )
    {
        pBlob11->Release();
    }
    if ( pBlobW != NULL )
    {
        pBlobW->Release();
    }

    //
    // Release IIS_SSL_INFO object, since we're done with it
    //
    if ( pSSLInfoObj )
    {
        IIS_SSL_INFO::Release( pSSLInfoObj );
    }

    //
    //  Return TRUE to indicate we added the item to the list.  If the item
    //  wasn't found, then it's a place holder for that particular address
    //

    return TRUE;
}



BOOL
LookupCredential(
    IN  CHAR *              pszAddress,
    IN  LPVOID              pvInstanceId,
    OUT CRED_CACHE_ITEM * * ppCCI
    )

/*++

Routine Description:

    Finds an entry in the credential cache or creates one if it's not found

Arguments:

    pszAddress - Address name for this credential
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    ppCCI - Receives pointer to a Credential Cache Item

    TRUE on success, FALSE on failure.  If this item's key couldn't be found,
    then ERROR_NO_MORE_ITEMS is returned.
    If key exist but entry invalid then ERROR_INVALID_NAME is returned.

--*/
{
    CRED_CACHE_ITEM * pcci;
    LIST_ENTRY *      pEntry;

    LockSSPIGlobals();

    for ( pEntry  = CredCacheList.Flink;
          pEntry != &CredCacheList;
          pEntry  = pEntry->Flink )
    {
        pcci = CONTAINING_RECORD( pEntry, CRED_CACHE_ITEM, m_ListEntry );

        if ( !memcmp( pcci->m_achSSLIdBlob, pszAddress, MAX_SSL_ID_LEN ) &&
             pcci->m_pvInstanceId == pvInstanceId )
        {
            //
            //  If this is an item we failed to find previously, then return
            //  an error
            //

            if ( pcci->m_fValid )
            {
                *ppCCI = pcci;
                pcci->AddRef();

                UnlockSSPIGlobals();

                return TRUE;
            }

            UnlockSSPIGlobals();

            SetLastError( ERROR_INVALID_NAME );

            return FALSE;
        }
    }

    UnlockSSPIGlobals();

    SetLastError( ERROR_NO_MORE_ITEMS );

    return FALSE;
}

BOOL
AddItem(
    CHAR * pszAddress,
    LPVOID pvInstanceId,
    RefBlob* pCert11,
    RefBlob* pCertW,
    IIS_SSL_INFO *pSSLInfoObj,
    CRED_CACHE_ITEM** ppcci,
    DWORD             dwInstanceId,
    LPSTR             pszMdPath
    )
/*++

Routine Description:

    Creates a new item in the credential cache and adds it to the list

    pszAddress must be a simple string that has no odd unicode mappings

    This routine must be single threaded

Arguments:

    pszAddress - Address name for this credential
    pvInstanceId - ptr to be used as w3 instance ID for this credential
    pCert11 - ptr to blob storing cert 1:1 mapper or NULL if no mapper
    pCertW - ptr to blob storing cert wildcard mapper or NULL if no mapper
    pSSLInfObj - pointer to SSL info to be used for this item
    ppCCI - Receives pointer to a Credential Cache Item
    dwInstanceId - w3 instance ID
    pszMdPath - path to metadata, either instance if known or service

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL              fRet = TRUE;
    BOOL              fRetM;
    BOOL              fRetL;
    CRED_CACHE_ITEM * pcci;


    //
    //  Create and initialize the context item
    //

    pcci = new CRED_CACHE_ITEM;

    if ( !pcci )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    memcpy( pcci->m_achSSLIdBlob, pszAddress, MAX_SSL_ID_LEN );

    pcci->m_pvInstanceId = pvInstanceId;

    memset( pcci->m_ahCred, 0, sizeof( pcci->m_ahCred ));
    memset( pcci->m_ahCredMap, 0, sizeof( pcci->m_ahCredMap ));
    memset( pcci->m_acbTrailer, 0, sizeof( pcci->m_acbTrailer ));
    memset( pcci->m_acbHeader, 0, sizeof( pcci->m_acbHeader ));

    LockSSPIGlobals();

    InsertTailList( &CredCacheList, &pcci->m_ListEntry );

    UnlockSSPIGlobals();

    //
    // build cert mapper DLLs array
    //

    if ( fRetM = InitializeCertMapping( pCert11 ? pCert11->QueryPtr() : NULL,
                                        pCertW ? pCertW->QueryPtr() : NULL,
                                        pSSLInfoObj ? (LPVOID) pSSLInfoObj : NULL,
                                        &pcci->m_ppMappers,
                                        &pcci->m_cNbMappers,
                                        dwInstanceId ) )
    {
        //
        //  LoadKeys will zero out these values on success or failure.  Note
        //  the password is stored as an ansi string because the SSL
        //  security structure is expecting an ANSI string
        //
        fRetL = LoadKeys( pSSLInfoObj,
                          pvInstanceId,
                          pcci->m_ppMappers,
                          pcci->m_cNbMappers,
                          pcci->m_ahCred,
                          &pcci->m_cCred,
                          pcci->m_ahCredMap,
                          &pcci->m_cCredMap,
                          pszMdPath );
    }
    else
    {
        fRetL = FALSE;
    }


    //
    //  Indicate the credential handle is valid on this address if we
    //  succeeded
    //

    if ( fRetL && fRetM )
    {
        pcci->m_fValid = TRUE;
    }
    else
    {
        pCert11 = NULL;
        pCertW = NULL;

        if ( fRetM && !fRetL )
        {
            TerminateCertMapping( pcci->m_ppMappers, pcci->m_cNbMappers );
            pcci->m_ppMappers = NULL;
            pcci->m_cNbMappers = 0;
        }
    }

    //
    // Store reference to mappers
    //

    if ( pcci->m_pBlob11 = pCert11 )
    {
        pCert11->AddRef();
    }

    if ( pcci->m_pBlobW = pCertW )
    {
        pCertW->AddRef();
    }

    //
    // Store reference to SSL info
    //
    if ( pcci->m_pSslInfo = pSSLInfoObj )
    {
        pSSLInfoObj->Reference();
    }

    //
    // Add ref, as will be referenced by *ppcci
    //

    pcci->AddRef();

    *ppcci = pcci;

    //
    //  Return TRUE to indicate we added the item to the list.  If the item
    //  wasn't found, then it's a place holder for that particular address
    //

    return TRUE;
}

BOOL
LoadKeys(
    IN IIS_SSL_INFO *pSSLInfoObj,
    IN PVOID pvInstance,
    IN  HMAPPER**    ppMappers,
    IN  DWORD        cNbMappers,
    OUT CredHandle * phCreds,
    OUT DWORD *      pcCred,
    OUT CredHandle * phCredsMap,
    OUT DWORD *      pcCredMap,
    IN  LPSTR        pszMdPath
    )
/*++

Routine Description:

    Creates credential handles for SSL, for both mapped and non-mapped credentials.

Arguments:

    pSSLInfoObj - object containing SSL info to be used for this credential set
    ppMappers - ptr to array of mapper DLLs
    cNbMappers - number of entry in ppMappers
    phCreds - ptr to array where to store credential handles w/o cert mapping
    pcCred - ptr to counter where to store number of entry in phCreds
    phCredsMap - ptr to array where to store credential handles w/ cert mapping
    pcCredMap - ptr to counter where to store number of entry in phCredsMap
    pszMdPath - path to metabase properties

Returns:

    TRUE on success, FALSE on failure.

--*/
{
    DBG_ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

    SCH_CRED                    creds;
    SCHANNEL_CRED               xcreds;
    SECURITY_STATUS             scRet;
    SECURITY_STATUS             scRetM;
    TimeStamp                   tsExpiry;
    DWORD                       i;
    LPVOID                      ascsp[1];
    LPVOID                      ascpc[1];
    MB                          mb( g_pMDObject );
    DWORD                       dwV;
    BUFFER                      buAlg;
    PCCERT_CONTEXT              pcCert = NULL;
    LPVOID                      pcreds;
    HCERTSTORE                  hRootStore;

    *pcCred             = 0;
    *pcCredMap          = 0;


    memset(&xcreds, 0, sizeof(xcreds));
    xcreds.dwVersion = SCHANNEL_CRED_VERSION;
    xcreds.cCreds = 1;

    if ( pSSLInfoObj->GetCertificate() &&
         pSSLInfoObj->GetCertificate()->IsValid() )
    {
        xcreds.paCred = pSSLInfoObj->GetCertificate()->QueryCertContextAddr();
    }

    xcreds.cMappers = cNbMappers ;
    xcreds.aphMappers = ppMappers;

    if ( pSSLInfoObj->GetTrustedIssuerStore( &hRootStore ) )
    {
        xcreds.hRootStore = hRootStore;

#if DBG_SSL
        //
        // See what SSLanta Claus put in the store for us ..
        //
        PCCERT_CONTEXT pContext = NULL;
        PCCERT_CONTEXT pPrevContext = NULL;

        while ( (pContext  = CertEnumCertificatesInStore( hRootStore,
                                                          pContext ) ) )
        {
            CHAR szSubjectName[1024];
            if ( CertGetNameString( pContext,
                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                    0,
                                    NULL,
                                    szSubjectName,
                                    1024 ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "%s is trusted issuer \n",
                           szSubjectName));
            }
        }
#endif //DBG_SSL
    }
    else
    {
        xcreds.hRootStore = NULL;
    }
    pcreds = (LPVOID) &xcreds;




#if 0

    //
    // NOTE : GetDefaultCryptoParams always returns FALSE, so the code below never gets
    // called. It's in there for when we allow selecting SSL alg, protocol etc
    //
    if ( GetDefaultCryptoParams( &xcreds.dwMinimumCipherStrength,
                                 &xcreds.dwMaximumCipherStrength ) &&
         mb.Open( pszMdPath ) )
    {
        memset( &xcreds, '\0', sizeof(xcreds) );

        // get min cipher strength

        if ( mb.GetDword( "", MD_SSL_MINSTRENGTH, IIS_MD_UT_SERVER, &dwV ) )
        {
            xcreds.dwMinimumCipherStrength = dwV;
            creds.dwVersion = SCHANNEL_CRED_VERSION;
        }

        // get alg Ids

        if ( mb.GetBuffer( "", MD_SSL_ALG, IIS_MD_UT_SERVER, &buAlg, &dwV ) )
        {
            xcreds.palgSupportedAlgs = (ALG_ID*)buAlg.QueryPtr();
            xcreds.cSupportedAlgs = dwV / sizeof(ALG_ID);
            creds.dwVersion = SCHANNEL_CRED_VERSION;
        }
        else
        {
            xcreds.palgSupportedAlgs = NULL;
            xcreds.cSupportedAlgs = 0;
        }

        // get protocols

        if ( mb.GetDword( "", MD_SSL_PROTO, IIS_MD_UT_SERVER, &dwV ) )
        {
            xcreds.grbitEnabledProtocols = dwV;
            creds.dwVersion = SCHANNEL_CRED_VERSION;
        }
        else
        {
            xcreds.grbitEnabledProtocols = SP_PROT_SSL2_SERVER|SP_PROT_SSL3_SERVER|SP_PROT_PCT1_SERVER;
        }

        mb.Close();

        if ( creds.dwVersion == SCHANNEL_CRED_VERSION )
        {
            xcreds.dwVersion = SCHANNEL_CRED_VERSION;

            if ( pcCert = CertCreateCertificateContext( X509_ASN_ENCODING,
                                                        scpc.pCertChain,
                                                        scpc.cbCertChain) )
            {
                if ( !CertSetCertificateContextProperty( pcCert,
                                                    CERT_SCHANNEL_IIS_PRIVATE_KEY_PROP_ID,
                                                    0,
                                                    pvPrivateKey) ||
                     !CertSetCertificateContextProperty( pcCert,
                                                    CERT_SCHANNEL_IIS_PASSWORD_PROP_ID,
                                                    0,
                                                    pszPassword) )
                {
                    CertFreeCertificateContext( pcCert );
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }

            xcreds.paCred       = &pcCert;
            xcreds.hRootStore   = NULL;
            xcreds.cCreds       = 1;
            xcreds.aphMappers   = ppMappers;

            pcreds = (LPVOID)&xcreds;
        }
    }
#endif // if 0

    for ( i = 0; pEncProviders[i].pszName && i < MAX_PROVIDERS; i++ )
    {
        if ( !pEncProviders[i].fEnabled )
        {
            continue;
        }

        //
        // Credentials with no client cert mapping at all
        //
        ((SCHANNEL_CRED*)pcreds)->cMappers = 0;
        ((SCHANNEL_CRED*)pcreds)->dwFlags = SCH_CRED_NO_SYSTEM_MAPPER;

        DBG_ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        scRet = AcquireCredentialsHandleW(  NULL,               // My name (ignored)
                                            pEncProviders[i].pszName, // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            pcreds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &phCreds[*pcCred],  // Handle
                                            &tsExpiry );

#if DBG_SSL
        if ( SUCCEEDED(scRet) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Credentials for provider #%d, no mapping, are %08x:%08x\n",
                       i, phCreds[*pcCred].dwLower, phCreds[*pcCred].dwUpper));
        }
#endif //DBG_SSL

        //
        // DS mapper only - no mappers passed to AcquireCredentialsHandle(), clear the flag
        // telling Schannel not to use the DS mapper
        //
        if ( pSSLInfoObj->UseDSMapper() )
        {
            ((SCHANNEL_CRED*)pcreds)->cMappers = 0;
            ((SCHANNEL_CRED*)pcreds)->dwFlags = 0;
            DBGPRINTF((DBG_CONTEXT,
                       "[SSPIFILT] Using DS mapper \n"));

        }
        //
        // IIS mappers only - pass mappers to AcquireCredentialsHandle(), set flag in each one
        // indicating that only IIS mappers are to be called, keep flag telling Schannel
        // not to use DS mapper [set to SCH_CRED_NO_SYSTEM_MAPPER above]
        //
        else
        {
            ((SCHANNEL_CRED*)pcreds)->cMappers = cNbMappers;
            for ( DWORD dwI = 0; dwI < cNbMappers; dwI++ )
            {
                ((SCHANNEL_CRED*)pcreds)->aphMappers[dwI]->m_dwFlags = SCH_FLAG_DEFAULT_MAPPER;

            }
            DBGPRINTF((DBG_CONTEXT,
                       "[SSPIFILT] Using IIS mappers \n"));
        }

        DBG_ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        scRetM = AcquireCredentialsHandleW( NULL,               // My name (ignored)
                                            pEncProviders[i].pszName, // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            pcreds,             // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &phCredsMap[*pcCredMap],  // Handle
                                            &tsExpiry );

#if DBG_SSL
        if ( SUCCEEDED(scRet) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Credentials for provider #%d, with mapping, are %08x:%08x\n",
                       i, phCreds[*pcCred].dwLower, phCredsMap[*pcCredMap].dwUpper));
        }
#endif //DBG_SSL

        DBG_ASSERT( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) );

        if ( !FAILED( scRetM ) && !FAILED( scRet ) )
        {
            *pcCred += 1;
            *pcCredMap += 1;

            DBGPRINTF((DBG_CONTEXT,
                       "Successfully acquired cred handle for cert in path %s\n",
                       pszMdPath));
        }
#if DBG_SSL
        else
        {
            if ( FAILED(scRet) )
            {
                DBGPRINTF((DBG_CONTEXT,
                       "scRet failed for provider #%d: 0x%x\n", i, scRet));
            }
            if ( FAILED(scRetM) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "scRetM failed for provider #%d:0x%x\n", i, scRetM));
            }
        }
#endif //DBG_SSL
    }

    if ( xcreds.hRootStore )
    {
        CertCloseStore( xcreds.hRootStore,
                        0 );
    }

    //
    // Tell the caller about it.
    //

    if ( !*pcCred && FAILED( scRet ))
    {
        SetLastError( scRet );

        return FALSE;
    }

    return TRUE;
}


BOOL
GetSecretW(
    WCHAR *            pszSecretName,
    UNICODE_STRING * * ppSecretValue
    )
/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        pszSecretName - LSA Secret to retrieve
        ppSecretValue - Receives pointer to secret value.  Memory should be
            freed by calling LsaFreeMemory

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL                  fResult;
    NTSTATUS              ntStatus;
    LSA_UNICODE_STRING    unicodeSecret;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;


    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    unicodeSecret.Buffer        = pszSecretName;
    unicodeSecret.Length        = wcslen( pszSecretName ) * sizeof(WCHAR);
    unicodeSecret.MaximumLength = unicodeSecret.Length + sizeof(WCHAR);

    //
    //  Query the secret value.
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       (PLSA_UNICODE_STRING *) ppSecretValue );

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    LsaClose( hPolicy );

    if ( !fResult )
        SetLastError( LsaNtStatusToWinError( ntStatus ));

    return fResult;

}   // GetSecretW


BOOL
InitializeCertMapping(
    LPVOID      pCert11,
    LPVOID      pCertW,
    LPVOID      pSslInfo,
    HMAPPER***  pppMappers,
    LPDWORD     pdwMappers,
    DWORD       dwInstanceId
    )
/*++
    Description:

        Initialize the cert mapping DLL list

    Arguments:

        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    HKEY                hKey;
    DWORD               dwType;
    DWORD               cbData = 0;
    BOOL                fSt = TRUE;
    LPSTR               pszMapList = NULL;
    LPSTR               p;
    LPSTR               pDll;
    UINT                cMaxMap;
    PFN_INIT_CERT_MAP   pfnInit;
    HINSTANCE           hInst;
    PMAPPER_VTABLE      pVT;
    DWORD               cNbMappers = 0;
    HMAPPER**           ppMappers = NULL;
    IisMapper*          pIM;

    if ( pCert11 == NULL && pCertW == NULL )
    {
        *pppMappers = NULL;
        *pdwMappers = 0;

        return TRUE;
    }

    //
    // Open reg, count # mappers, allocate array, populate array
    //

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey ) == NO_ERROR )
    {

        if ( RegQueryValueEx( hKey,
                              SSPIFILT_CERT_MAP_LIST,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_SZ &&
             (pszMapList = (LPSTR)LocalAlloc( LMEM_FIXED, cbData )) &&
             RegQueryValueEx( hKey,
                              SSPIFILT_CERT_MAP_LIST,
                              NULL,
                              &dwType,
                              (LPBYTE)pszMapList,
                              &cbData ) == ERROR_SUCCESS )
        {
            //
            // Count mappers, allocate structures
            //

            for ( cMaxMap = 1, p = pszMapList ;
                  p = strchr( p, ',' ) ;
                  ++p, ++cMaxMap )
            {
            }

            if ( !(ppMappers = (HMAPPER**)LocalAlloc( LMEM_FIXED,
                    sizeof(HMAPPER*) * cMaxMap )) )
            {
                fSt = FALSE;
                goto cleanup;
            }
            
            ZeroMemory( ppMappers,
                        sizeof(HMAPPER*) * cMaxMap ); 

            //
            // Load libraries, call init entry point
            //

            for ( pDll = pszMapList, cNbMappers = 0 ;
                  *pDll ;
                )
            {
                p = strchr( pDll, ',' );
                if ( p )
                {
                    *p = '\0';
                }

                if ( (hInst = LoadLibrary( pDll )) )
                {
                    //
                    // Use CreateInstance() entry point if present
                    //

                    if ( (pfnInit = (PFN_INIT_CERT_MAP)GetProcAddress(
                                hInst,
                                SSPIFILT_INIT_MAP )) )
                    {
                        if ( (pfnInit)( (HMAPPER**)&pIM ) != SEC_E_OK )
                        {
                            FreeLibrary( hInst );
                            goto next;
                        }

                        //
                        // Mapper handle its own HMAPPER allocation,
                        // will be freed when refcount drops to zero.
                        // Initial refcount is 1
                        //

                        ppMappers[cNbMappers] = (HMAPPER*)pIM;
                        pIM->pCert11Mapper = pCert11;
                        pIM->pCertWMapper = pCertW;
                        pIM->pvInfo = pSslInfo;
                        pIM->dwInstanceId = dwInstanceId;
                    }
                    else
                    {
                        //
                        // if mapping DLL doesn't export CreateInstance 
                        // then it is not IIS Compliant
                        //
                        // Note: memory allocated here will have to be leaked
                        // since we don't own the refcounting for this object
                        // 
                        // Only IIS and SiteServer should be using Cert mapping
                        // interface and both are IIS compliant, so this codepath
                        // is probably never hit. It could be removed but I rather 
                        // leave it here just for the case
                        //
                        
                        pIM = (IisMapper*)LocalAlloc( LMEM_FIXED, sizeof(IisMapper) );
                        if( pIM == NULL )
                        {
                            FreeLibrary( hInst );
                            goto next;      
                        }
                        ppMappers[cNbMappers] = (HMAPPER*)pIM;

                        pIM->hMapper.m_vtable = pVT = &pIM->mvtEntryPoints;
                        pIM->hMapper.m_dwMapperVersion = MAPPER_INTERFACE_VER;
                        pIM->hMapper.m_Reserved1 = NULL;

                        pIM->hInst = hInst;
                        pIM->lRefCount = 0;
                        pIM->fIsIisCompliant = FALSE;
                        pIM->pCert11Mapper = pCert11;
                        pIM->pCertWMapper = pCertW;
                        pIM->pvInfo = pSslInfo;
                        pIM->dwInstanceId = dwInstanceId;

                        if ( !(pVT->ReferenceMapper
                                = (REF_MAPPER_FN)GetProcAddress(
                                        hInst,
                                        "ReferenceMapper" )) ||
                             !(pVT->DeReferenceMapper
                                = (DEREF_MAPPER_FN)GetProcAddress(
                                        hInst,
                                        "DeReferenceMapper" )) ||
                             !(pVT->GetIssuerList
                                = (GET_ISSUER_LIST_FN)GetProcAddress(
                                        hInst,
                                        "GetIssuerList" )) ||
                             !(pVT->GetChallenge
                                = (GET_CHALLENGE_FN)GetProcAddress(
                                        hInst,
                                        "GetChallenge" )) ||
                             !(pVT->MapCredential
                                = (MAP_CREDENTIAL_FN)GetProcAddress(
                                        hInst,
                                        "MapCredential" )) ||
                             !(pVT->GetAccessToken
                                = (GET_ACCESS_TOKEN_FN)GetProcAddress(
                                        hInst,
                                        "GetAccessToken" )) ||
                             !(pVT->CloseLocator
                                = (CLOSE_LOCATOR_FN)GetProcAddress(
                                        hInst,
                                        "CloseLocator" ))
                            )
                        {
                            LocalFree( pIM );
                            FreeLibrary( hInst );
                            goto next;
                        }

                        //
                        // optional functions
                        //

                        if ( !(pVT->QueryMappedCredentialAttributes
                                = (QUERY_MAPPED_CREDENTIAL_ATTRIBUTES_FN)GetProcAddress(
                                        hInst,
                                        "QueryMappedCredentialAttributes" )) )
                        {
                            pVT->QueryMappedCredentialAttributes = NullQueryMappedCredentialAttributes;
                        }
                    }

                    //
                    // Valid mapper. Store reference
                    //
                    ++cNbMappers;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "LoadLibrary(%s) failed : 0x%x\n",
                               pDll, GetLastError()));
                }
next:
                if ( p )
                {
                    pDll = p + 1;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            fSt = FALSE;
        }

        RegCloseKey( hKey );
    }


cleanup:
    if ( fSt == FALSE )
    {
        if ( ppMappers != NULL )
        {
            LocalFree( ppMappers );
        }
    }
    else
    {
        *pppMappers = ppMappers;
        *pdwMappers = cNbMappers;
    }

    if ( pszMapList != NULL )
    {
        LocalFree( pszMapList );
    }

    return fSt;
}


VOID
SetMapperToEmpty(
    UINT        cMappers,
    HMAPPER**   pMappers
    )
/*++
    Description:

        Set ptr to Null mapper ( fail Mapping requests )

    Arguments:

        cMappers - mapper count in pCertMapDlls, pMappers
        pMappers - ptr to array of mappers

    Returns:
        Nothing

--*/
{
    PMAPPER_VTABLE  pTbl;

    while ( cMappers-- )
    {
        if ( (*(IisMapper**)pMappers)->fIsIisCompliant )
        {
            pTbl = (*pMappers)->m_vtable;

            //
            // switch to infocomm-embedded mapper, so we can FreeLibrary the
            // mapper DLL. refcount is decremented, because we now longer
            // have a reference to the HMAPPER struct.
            //

            pTbl->ReferenceMapper = NullReferenceMapper;
            pTbl->DeReferenceMapper = NullDeReferenceMapper;
            pTbl->GetIssuerList = NullGetIssuerList;
            pTbl->GetChallenge = NullGetChallenge;
            pTbl->MapCredential = NullMapCredential;
            pTbl->GetAccessToken = NullGetAccessToken;
            pTbl->CloseLocator = NullCloseLocator;
            pTbl->QueryMappedCredentialAttributes = NullQueryMappedCredentialAttributes;

            if ( (*(IisMapper**)pMappers)->hInst != NULL )
            {
                FreeLibrary( (*(IisMapper**)pMappers)->hInst );
            }

            (pTbl->DeReferenceMapper)( *pMappers );
        }
        else
        {
            //
            // For not IIS compliant mappings there is structure allocate on heap
            // in InitializeCertMapping. But we don't own refcounting for it
            // so it is risky to free the memory here
            // 
            // Note that only IIS and SiteServer should be using Cert mapping
            // interface and both are IIS compliant, so this codepath
            // is probably never hit. 

        }
        ++pMappers;
    }
}


BOOL
TerminateCertMapping(
    HMAPPER** ppMappers,
    DWORD cNbMappers
    )
/*++
    Description:

        Terminate access to cert mapping DLL list

    Arguments:

        None

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    //
    // call terminate mapper for all DLLs, FreeLibrary
    //

    if ( ppMappers != NULL )
    {
        SetMapperToEmpty( cNbMappers, ppMappers );
        LocalFree( ppMappers );
    }

    return TRUE;
}


CRED_CACHE_ITEM::~CRED_CACHE_ITEM(
    )
{
    if ( m_fValid )
    {
        DWORD i;

        for ( i = 0; i < m_cCred; i++ )
        {
            FreeCredentialsHandle( &m_ahCred[i] );
        }
        for ( i = 0; i < m_cCredMap; i++ )
        {
            FreeCredentialsHandle( &m_ahCredMap[i] );
        }

        TerminateCertMapping( m_ppMappers, m_cNbMappers );

        if ( m_pBlob11 )
        {
            m_pBlob11->Release();
        }
        if ( m_pBlobW )
        {
            m_pBlobW->Release();
        }
        if ( m_pSslInfo )
        {
            IIS_SSL_INFO::Release( m_pSslInfo );
        }
    }
}


BOOL
GetDefaultCryptoParams(
    LPDWORD pdwMinCipherStrength,
    LPDWORD pdwMaxCipherStrength
    )
{
    CredHandle                  hCred;
    SECURITY_STATUS             scRet;
    TimeStamp                   tsExpiry;
    SecPkgCred_CipherStrengths  CipherStrengths;

    return FALSE;

    if ( !g_fQueriedCryptoParams )
    {
        scRet = AcquireCredentialsHandleW(
                                            NULL,               // My name (ignored)
                                            UNISP_NAME_W,       // Package
                                            SECPKG_CRED_INBOUND,// Use
                                            NULL,               // Logon Id (ign.)
                                            NULL,               // auth data
                                            NULL,               // dce-stuff
                                            NULL,               // dce-stuff
                                            &hCred,             // Handle
                                            &tsExpiry );
        if ( !FAILED(scRet) )
        {
            if ( !FAILED( scRet = QueryContextAttributes( &hCred,
                                                          SECPKG_ATTR_CIPHER_STRENGTHS,
                                                          &CipherStrengths ) ) )
            {
                g_dwMinCipherStrength = CipherStrengths.dwMinimumCipherStrength;
                g_dwMaxCipherStrength = CipherStrengths.dwMaximumCipherStrength;

                g_fCryptoParams = TRUE;
            }

            FreeCredentialsHandle( &hCred );
        }

        g_fQueriedCryptoParams = TRUE;
    }

    *pdwMinCipherStrength = g_dwMinCipherStrength;
    *pdwMaxCipherStrength = g_dwMaxCipherStrength;

    return g_fCryptoParams;
}


BOOL GenerateSSLIdBlob( IIS_SSL_INFO *pSSLInfoObj,
                         PBYTE pbBlob )
/*++

   Description

       Function called to get blob of data that uniquely identifies this set of SSL info

   Arguments:

        pSSLInfoObj - object containing SSL info to be used to generate the blob
        pbBlob - buffer that gets updated with blob

   Returns:

        True on success, FALSE on failure

--*/
{
    //
    // If we haven't loaded the info yet, do so now
    //
    IIS_SERVER_CERT *pCert = pSSLInfoObj->GetCertificate();

    IIS_CTL *pCTL = pSSLInfoObj->GetCTL();

    //
    // Definitely need a certificate
    //
    if ( !pCert || !pCert->IsValid() )
    {
        return FALSE;
    }

    DWORD dwSize = MAX_SSL_ID_LEN;
    PBYTE pbCurrent = pbBlob;

    //
    // Clear out old crud
    //
    memset( pbBlob, 0, MAX_SSL_ID_LEN );

    //
    //Try to get the cert hash
    //
    if ( !CertGetCertificateContextProperty( pCert->QueryCertContext(),
                                             CERT_SHA1_HASH_PROP_ID,
                                             (PVOID) pbCurrent,
                                             &dwSize ) )
    {
        return FALSE;
    }

    DBG_ASSERT( dwSize == SHA1_HASH_LEN );

    pbCurrent += dwSize;
    dwSize = MAX_SSL_ID_LEN - dwSize - 1;


    //
    // Get and append the CTL hash, if there is one
    //
    if ( pCTL && pCTL->IsValid() )
    {
        if ( !CertGetCTLContextProperty( pCTL->QueryCTLContext(),
                                         CERT_SHA1_HASH_PROP_ID,
                                         (PVOID) pbCurrent,
                                         &dwSize ) )
        {
            return FALSE;
        }

        DBG_ASSERT( dwSize == SHA1_HASH_LEN );

        pbBlob[SHA1_HASH_LEN] = ':';
    }

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\sspi\main.cxx ===
/*++







Copyright (c) 1995  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    This module is the main entry point for the SSPI filter for the web server

Author:

    John Ludeman (johnl)   05-Oct-1995

Revision History:
--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>

#define SECURITY_WIN32
#include <sspi.h>
extern "C" {
#include <spseal.h>
};

#include <ntsecapi.h>
#include <schnlsp.h>

#include <iis64.h>
#include <inetinfo.h>
#include <w3svc.h>
#include <eventlog.hxx>
#include <buffer.hxx>
#include <string.hxx>
#include <credcach.hxx>
#include <certnotf.hxx>

#ifdef IIS3
#include "dbgutil.h"
#endif

#ifndef _NO_TRACING_

#define PRINTF( x )     { char buff[256]; wsprintf x; DBGPRINTF((DBG_CONTEXT, buff)); }
#if DBG
#define VALIDATE_HEAP() DBG_ASSERT( RtlValidateProcessHeaps() )
#else
#define VALIDATE_HEAP()
#endif

#else

#if DBG
#define PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#define VALIDATE_HEAP() DBG_ASSERT( RtlValidateProcessHeaps() )
#else
#define PRINTF( x )
#define VALIDATE_HEAP()
#endif

#endif

#if 0 && DBG
#define NOISY_PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define NOISY_PRINTF( x )
#endif

#define SF_STATUS_REPROCESS     (SF_STATUS_TYPE)0x12341234

#define SSPI_FILTER_CONTEXT_SIGNATURE (DWORD) 'SFCS'
#define SSPI_FILTER_CONTEXT_SIGNATURE_BAD (DWORD) 'sfcs'

#define MAX_SSL_CACHED_BUFFER   (8*1024+2*64)


extern "C"
BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );

//
//  Lock for the credential cache and reused filter context cache.
//  This protects the following data members & variables :
//
//  SSPI_FILTER_CONTEXT::m_FreeHead
//  SSPI_FILTER_CONTEXT::m_InUseHead
//  CredCacheList
//  InstanceCacheList
//

CRITICAL_SECTION g_csGlobalLock;

BOOL
WINAPI
InitializeProviderList(
    VOID
    );

VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    );

#ifndef IIS3
  #ifdef ASSERT
    #undef ASSERT
  #endif
  #define ASSERT( a )
#endif

//
//  Definitions
//

enum FILTER_STATE
{
    STATE_STARTUP = 0,
    STATE_AUTHORIZING,
    STATE_AUTHORIZED
};


//
//  Context structure, one for every TCP session
//

class SSPI_FILTER_CONTEXT
{
public:
    SSPI_FILTER_CONTEXT()
        : m_pvSendBuff( NULL ),
          m_cbSendBuff( 0 ),
          m_pvSendBuffE( NULL ),
          m_cbSendBuffE( 0 ),
          m_dwSignature ( SSPI_FILTER_CONTEXT_SIGNATURE )
    {
        Initialize();
    }

    ~SSPI_FILTER_CONTEXT();

    //
    //  Initializes and frees the context cache.  Used for initialization
    //  and uninitialization
    //

    static VOID InitCache( VOID )
        { InitializeListHead( &m_FreeHead ); InitializeListHead( &m_InUseHead ); };

    static VOID FreeCache( VOID )
    {
        LIST_ENTRY * pEntry;
        SSPI_FILTER_CONTEXT * pssc;

        LockSSPIGlobals();

        while ( !IsListEmpty( &m_FreeHead ))
        {
            pssc = CONTAINING_RECORD( m_FreeHead.Flink,
                                      SSPI_FILTER_CONTEXT,
                                      m_ListEntry );

            RemoveEntryList( &pssc->m_ListEntry );

            delete pssc;
        }

        UnlockSSPIGlobals();
    }

    //
    //  Allocates or frees a context from cache, creating as necessary.  The
    //  lock needs to be taken before calling these
    //

    static SSPI_FILTER_CONTEXT * Alloc( VOID )
    {
        SSPI_FILTER_CONTEXT * pssc;

        LockSSPIGlobals();

        if ( !IsListEmpty( &m_FreeHead ))
        {
            LIST_ENTRY * pEntry = m_FreeHead.Flink;

            RemoveEntryList( pEntry );

            pssc = CONTAINING_RECORD( pEntry, SSPI_FILTER_CONTEXT, m_ListEntry );

            pssc->Initialize();
        }
        else
        {
            pssc = new SSPI_FILTER_CONTEXT;
        }

        if ( pssc )
        {
            InsertHeadList( &m_InUseHead,
                            &pssc->m_ListEntry );
        }

        UnlockSSPIGlobals();

        return pssc;
    }

    static VOID Free( SSPI_FILTER_CONTEXT * pssc )
    {
        LockSSPIGlobals();

        pssc->Close();

        RemoveEntryList( &pssc->m_ListEntry );

        InsertHeadList( &m_FreeHead,
                        &pssc->m_ListEntry );

        UnlockSSPIGlobals();
    }

    static VOID FlushOnDelete()
    {
        LIST_ENTRY * pEntry;
        SSPI_FILTER_CONTEXT * pssc;

        LockSSPIGlobals();

        for ( pEntry  = m_InUseHead.Flink;
              pEntry != &m_InUseHead;
              pEntry  = pEntry->Flink )
        {
            pssc = CONTAINING_RECORD( pEntry, SSPI_FILTER_CONTEXT, m_ListEntry );
            pssc->m_fFlushOnDelete = TRUE;
        }

        UnlockSSPIGlobals();
    }

    //
    //  Pseudo constructor and destructor called when an item comes out of
    //  the free cache and when it goes back to the free cache
    //

    VOID Initialize( VOID );
    VOID Close( VOID );

    BOOL IsAuthNeeded( VOID ) const
        { return m_State == STATE_AUTHORIZING ||
                 m_State == STATE_STARTUP; }

    BOOL IsAuthInProgress( VOID ) const
        { return m_State == STATE_AUTHORIZING; }

    BOOL IsInRenegotiate( VOID ) const
        { return m_fInRenegotiate; }

    BOOL IsMap( VOID ) const
        { return m_fIsMap; }

    VOID SetIsMap( BOOL f )
        { m_fIsMap = f; }

    BOOL CanRenegotiate() { return m_fCanRenegotiate; }

    VOID SignalRenegotiateRequested() { m_fCanRenegotiate = FALSE; }

    BOOL CheckSignature() { return SSPI_FILTER_CONTEXT_SIGNATURE == m_dwSignature; }

#if defined(RENEGOTIATE_CERT_ON_ACCESS_DENIED)
    BOOL AppendDeferredWrite( LPBYTE pV, DWORD cB )
        { return m_xbDeferredWrite.Append( pV, cB ); }
#endif

    DWORD             m_dwSignature;

    enum FILTER_STATE m_State;

    LIST_ENTRY        m_ListEntry;

    CtxtHandle        m_hContext;
    SecBufferDesc     m_Message;
    SecBuffer         m_Buffers[4];
    // these two are used to separate the buffers
    SecBufferDesc     m_MessageE;
    SecBuffer         m_BuffersE[4];
    
    SecBufferDesc     m_MessageOut;
    SecBuffer         m_OutBuffers[4];

    //
    //  Array of credential handles - Note this comes form the credential cache
    //  and should not be deleted.  m_phCredInUse is the pointer to the
    //  credential handle that is in use
    //

    CRED_CACHE_ITEM * m_phCreds;

    CredHandle *      m_phCredInUse;
    DWORD             m_cbTrailer;
    DWORD             m_cbHeader;
    DWORD             m_cbBlockSize;
    DWORD             m_iCredInUse;

    //
    //  This is the buffer used for send requests
    //

    VOID *            m_pvSendBuff;
    DWORD             m_cbSendBuff;

    //
    // This is used to have a buffer disting for Encription and Decryption
    //

    VOID *            m_pvSendBuffE;
    DWORD             m_cbSendBuffE;

    //
    //  It's possible multiple message blocks reside in a single network
    //  buffer.  These two members keep track of the case where we get
    //  a full message followed by a partial message.  m_cbEncryptedStart
    //  records the byte offset of where the next decryption operation
    //  needs to take place
    //
    //  m_cbDecrypted records the total number of bytes that have been
    //  decrypted.  This allows us go back and read the rest of the partial
    //  blob and start decrypting after the already decrypted data
    //

    DWORD             m_cbDecrypted;
    DWORD             m_cbEncryptedStart;
    DWORD             m_dwLastSslMsgSize;

    DWORD             m_dwAscReq;   // SSPI package flags

    BOOL              m_fCanRenegotiate;
    BOOL              m_fInRenegotiate;
    BOOL              m_fIsMap;
    //XBF               m_xbDeferredWrite;
    BOOL              m_fFlushOnDelete;

    static LIST_ENTRY m_FreeHead;
    static LIST_ENTRY m_InUseHead;
};

//
//  Globals
//

typedef VOID (WINAPI FAR *PFN_SCHANNEL_INVALIDATE_CACHE)(
    VOID
);

//
//  This caches the constant value returned from QueryContextAttributes
//

DWORD cbTrailerSize = 0;
DWORD dwNoKeepAlive = FALSE;
BOOL m_fInitNotifyDone = FALSE;

#define DEFAULT_LAST_MSG_SIZE   100
DWORD dwLastSslMsgSize = DEFAULT_LAST_MSG_SIZE;
BOOL g_fIsLsaSchannel = FALSE;
HINSTANCE g_hSchannel = NULL;

//
// NB : Under NT 5, the SslEmptyCache function is no longer supported
//
PFN_SCHANNEL_INVALIDATE_CACHE g_pfnFlushSchannelCache = NULL;

#include <initguid.h>
DEFINE_GUID(IisSspiGuid,
0x784d891D, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

#ifdef IIS3
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

#define SSL_NO_KEEP_ALIVE_FOR_NON_COMPLIANT_CLIENTS 2
#define SSL_MAX_MSG_SIZE        0x3fff

#define AVALANCHE_SERVER_CERTS

LIST_ENTRY SSPI_FILTER_CONTEXT::m_FreeHead;
LIST_ENTRY SSPI_FILTER_CONTEXT::m_InUseHead;

//
//  The list of encryption packages we support.  PCT goes first since it's a
//  superset of SSL
//

struct _ENC_PROVIDER EncProviders[] =
{
    UNISP_NAME_W,  ENC_CAPS_PCT|ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME_W, ENC_CAPS_PCT, FALSE,
    SSL3SP_NAME_W, ENC_CAPS_SSL, FALSE,
    SSL2SP_NAME_W, ENC_CAPS_SSL, FALSE,

    NULL,          FALSE,         FALSE
};


struct _ENC_PROVIDER EncLsaProviders[] =
{
    UNISP_NAME_W L" X",     ENC_CAPS_PCT|ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME_W L" X",    ENC_CAPS_PCT, FALSE,
    SSL3SP_NAME_W L" X",    ENC_CAPS_SSL, FALSE,
    SSL2SP_NAME_W L" X",    ENC_CAPS_SSL, FALSE,

    NULL,          FALSE,         FALSE
};

struct _ENC_PROVIDER*   pEncProviders = EncProviders;

//
//  Private prototypes
//

SF_STATUS_TYPE
OnAuthorizationInfo(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA * pfrd,
    SSPI_FILTER_CONTEXT *  pssc
    );

SF_STATUS_TYPE
EncryptData(
    HTTP_FILTER_CONTEXT  * pfc,
    HTTP_FILTER_RAW_DATA * pfrd,
    SSPI_FILTER_CONTEXT *  pssc
    );

SF_STATUS_TYPE
DecryptData(
    HTTP_FILTER_CONTEXT  * pfc,
    HTTP_FILTER_RAW_DATA * pfrd,
    SSPI_FILTER_CONTEXT *  pssc
    );

DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    SSPI_FILTER_CONTEXT *         pssc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    );

DWORD
RequestRenegotiate(
   HTTP_FILTER_CONTEXT* pfc,
   PHTTP_FILTER_REQUEST_CERT pInfo,
   SSPI_FILTER_CONTEXT* pssc
   );

BOOL
SignalAuthorizationComplete(
    BOOL fHaveCert,
    HTTP_FILTER_CONTEXT *  pfc,
    SSPI_FILTER_CONTEXT *  pssc
    );

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
/*++

Routine Description:

    Initialization routine called by the server during startup

--*/
{
    SECURITY_STATUS   ss;
    PSecPkgInfoW      pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             i;
    ULONG             j;
    ULONG             fCaps;
    DWORD             cbBuffNew = 0;
    DWORD             cbBuffOld = 0;
    UNICODE_STRING *  punitmp;
    HKEY              hkeyParam;
    DWORD             dwEncFlags = ENC_CAPS_DEFAULT;
    DWORD             dwType;
    DWORD             cbData;
    DWORD             cProviders = 0;
    DWORD             dwLsaSchannel;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_ALL_ACCESS,
                       &hkeyParam ) == NO_ERROR )
    {

#if 0

    //
    //  We'd really like to pull the list of providers out of the registry
    //


        if ( !RegQueryValueEx( hkeyParam,
                               W3_ENC_PROVIDER_LIST,
                               NULL,
                               &dwType,
                               achProviders,
                               &cbData ))
        {
        }
#endif

        cbData = sizeof( dwEncFlags );

        if ( RegQueryValueEx( hkeyParam,
                              W3_ENC_FLAGS,
                              NULL,
                              &dwType,
                              (BYTE *) &dwEncFlags,
                              &cbData ) ||
             dwType != REG_DWORD )
        {
            dwEncFlags = ENC_CAPS_DEFAULT;
        }

        cbData = sizeof( dwLastSslMsgSize );

        if ( RegQueryValueEx( hkeyParam,
                              "SslLastMsgSize",
                              NULL,
                              &dwType,
                              (BYTE *) &dwLastSslMsgSize,
                              &cbData ) ||
             dwType != REG_DWORD )
        {
            dwLastSslMsgSize = DEFAULT_LAST_MSG_SIZE;
        }

        cbData = sizeof( dwNoKeepAlive );

        if ( RegQueryValueEx( hkeyParam,
                              "SslNoKeepAlive",
                              NULL,
                              &dwType,
                              (BYTE *) &dwNoKeepAlive,
                              &cbData ) ||
             dwType != REG_DWORD )
        {
            dwNoKeepAlive = FALSE;
        }

        dwEncFlags &= ENC_CAPS_TYPE_MASK;

        RegCloseKey( hkeyParam );
    }


    //
    //  Make sure at least one encryption package is loaded
    //

    ss = EnumerateSecurityPackagesW( &cPackages,
                                     &pPackageInfo );

    if ( ss != STATUS_SUCCESS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "[GetFilterVersion] EnumerateSecurityPackages failed, error %lx\n",
                 ss ));

        SetLastError( ss );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  We'll only use the security package if it supports connection
        //  oriented security and the package name is the PCT/SSL package
        //

        fCaps = pPackageInfo[i].fCapabilities;

        if ( fCaps & SECPKG_FLAG_STREAM )
        {
            if ( fCaps & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCaps & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Does it match one of our known packages and are we configured
            //  to use it?
            //

            for ( j = 0; pEncProviders[j].pszName != NULL; j++ )
            {
                if ( !wcscmp( pPackageInfo[i].Name, pEncProviders[j].pszName ) &&
                     pEncProviders[j].dwFlags & dwEncFlags )
                {
                    pEncProviders[j].fEnabled = TRUE;
                    cProviders++;
                }
            }
        }
    }

    //
    // Free the enumerated packages
    //

    FreeContextBuffer( pPackageInfo );

    if ( !cProviders )
    {
        //
        //  The package wasn't found, fail this filter's load
        //

        DBGPRINTF(( DBG_CONTEXT,
                 "[GetFilterVersion] No security packages were found, failing load\n"));

        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        return FALSE;
    }
#if 0
    //
    //  The package is installed.  Check to see if there are any keys
    //  installed
    //

    if ( !GetSecretW( W3_SSL_KEY_LIST_SECRET,
                      &punitmp ))
    {
        PRINTF(( buff,
                 "[GetFilterVersion] GetSecretW returned error %d\n",
                 GetLastError() ));

        //
        //  Looks like no secrets are installed, fail to load, don't log an
        //  event
        //

        SetLastError( NO_ERROR );

        return FALSE;
    }

    PRINTF(( buff,
             "[GetFilterVersion] Installed keys: %S\n",
             punitmp->Buffer ));

    LsaFreeMemory( punitmp );
#endif
    pVer->dwFilterVersion  = MAKELONG( 0, 1 );
    strcpy( pVer->lpszFilterDesc,
            "Microsoft SSPI Encryption Filter, v1.0" );

    //
    //  Indicate the types of notification we're interested in
    //

    pVer->dwFlags = SF_NOTIFY_SECURE_PORT   |
                    SF_NOTIFY_ORDER_HIGH    |
                    SF_NOTIFY_PREPROC_HEADERS |
                    SF_NOTIFY_READ_RAW_DATA |
                    SF_NOTIFY_SEND_RAW_DATA |
                    SF_NOTIFY_RENEGOTIATE_CERT |
                    SF_NOTIFY_END_OF_NET_SESSION;

    PRINTF(( buff,
             "[GetFilterVersion] SSPIFILT installed\n"
              ));

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT * pfc,
    DWORD                 fsNotification,
    PVOID                 pvInfo )
/*++

Routine Description:

    This is the filter entry point that receives event notifications from
    the server.

--*/
{
    CHAR *                    pch;
    DWORD                     cbHeader;
    HTTP_FILTER_RAW_DATA *    pfrd;
    SSPI_FILTER_CONTEXT *     pssc;
    SF_STATUS_TYPE            sfStatus;

    switch ( fsNotification )
    {
    case SF_NOTIFY_RENEGOTIATE_CERT:
        if ( !pfc->pFilterContext )
        {
            return SF_STATUS_REQ_ERROR;
        }
        pssc = (SSPI_FILTER_CONTEXT *) pfc->pFilterContext;

        DBG_ASSERT( pssc->CheckSignature() );

        return RequestRenegotiate( pfc,
                                   (PHTTP_FILTER_REQUEST_CERT)pvInfo,
                                   pssc );

    case SF_NOTIFY_READ_RAW_DATA:

        pfrd = (HTTP_FILTER_RAW_DATA *) pvInfo;

        //
        //  Allocate a context for this request if we haven't already
        //

        if ( !pfc->pFilterContext )
        {
            CHAR       achLocalAddr[32];
            CHAR       achLocalPort[32];
            DWORD      cbLocalAddr = sizeof( achLocalAddr );
            DWORD      cbLocalPort = sizeof( achLocalPort );
            LPVOID     pvInstanceId;
            DWORD      dwInstanceId;
            CredHandle CredHandle;

            //
            //  Get the credential handle that should be used on this local
            //  IP address
            //

            if ( !pfc->GetServerVariable( pfc,
                                          "LOCAL_ADDR",
                                          achLocalAddr,
                                          &cbLocalAddr ))
            {
                return SF_STATUS_REQ_ERROR;
            }

            if ( !pfc->GetServerVariable( pfc,
                                          "SERVER_PORT",
                                          achLocalPort,
                                          &cbLocalPort ))
            {
                return SF_STATUS_REQ_ERROR;
            }

            if ( !pfc->ServerSupportFunction( pfc,
                                        SF_REQ_GET_PROPERTY,
                                        (LPVOID)&pvInstanceId,
                                        (UINT)SF_PROPERTY_GET_INSTANCE_ID,
                                        NULL ) )
            {
                return SF_STATUS_REQ_ERROR;
            }
            
            if ( pvInstanceId == NULL )
            {
                return SF_STATUS_REQ_ERROR;
            }

            if ( !pfc->ServerSupportFunction( pfc,
                                        SF_REQ_GET_PROPERTY,
                                        (LPVOID)&dwInstanceId,
                                        (UINT)SF_PROPERTY_INSTANCE_NUM_ID,
                                        NULL ) )
            {
                return SF_STATUS_REQ_ERROR;
            }

            //
            //  Get our filter context
            //

            if ( !m_fInitNotifyDone )
            {
                if ( !pfc->ServerSupportFunction( pfc,
                                            (SF_REQ_TYPE)SF_REQ_SET_NOTIFY,
                                            (LPVOID)NotifySslChanges,
                                            (UINT)SF_NOTIFY_MAPPER_CERT11_CHANGED,
                                            NULL ) ||
                     !pfc->ServerSupportFunction( pfc,
                                            (SF_REQ_TYPE)SF_REQ_SET_NOTIFY,
                                            (LPVOID)NotifySslChanges,
                                            (UINT)SF_NOTIFY_MAPPER_CERTW_CHANGED,
                                            NULL ) ||
                     !pfc->ServerSupportFunction( pfc,
                                            (SF_REQ_TYPE)SF_REQ_SET_NOTIFY,
                                            (LPVOID)NotifySslChanges,
                                            (UINT)SF_NOTIFY_MAPPER_SSLKEYS_CHANGED,
                                            NULL ) )
                {
                    DBG_ASSERT( FALSE );

                    return SF_STATUS_REQ_ERROR;
                }

                m_fInitNotifyDone = TRUE;
            }

            pssc = SSPI_FILTER_CONTEXT::Alloc();

            if ( !pssc )
            {
                return SF_STATUS_REQ_ERROR;
            }

            DBG_ASSERT( pssc->CheckSignature() );

            //
            //  Get the credentials for this IP address
            //

            if ( !LookupFullyQualifiedCredential( achLocalAddr,
                                                  cbLocalAddr,
                                                  achLocalPort,
                                                  cbLocalPort,
                                                  pvInstanceId,
                                                  pfc,
                                                  &pssc->m_phCreds,
                                                  dwInstanceId ))
            {
                DBGPRINTF(( DBG_CONTEXT,
                         "[HttpFilterProc] GetCredentials failed, error 0x%lx\n",
                         GetLastError() ));

                RemoveEntryList( &pssc->m_ListEntry );

                delete pssc;

                return SF_STATUS_REQ_ERROR;
            }

            pfc->pFilterContext = pssc;
        }
        else
        {
            pssc = (SSPI_FILTER_CONTEXT *) pfc->pFilterContext;

            DBG_ASSERT( pssc->CheckSignature() );
        }

        if ( pssc->IsAuthNeeded() )
        {
            sfStatus = OnAuthorizationInfo( pfc, pfrd, pssc );
            if ( sfStatus != SF_STATUS_REPROCESS )
            {
                return sfStatus;
            }
        }

        return DecryptData( pfc,
                            pfrd,
                            pssc );

    case SF_NOTIFY_SEND_RAW_DATA:

        pfrd = (HTTP_FILTER_RAW_DATA *) pvInfo;
        pssc = (SSPI_FILTER_CONTEXT *) pfc->pFilterContext;

        //
        //  If somebody tries to send on this session before we've negotiated
        //  with SSPI, abort this session
        //

        if ( !pssc || pssc->IsAuthNeeded() )
        {
            return SF_STATUS_REQ_FINISHED;
        }

        return EncryptData( pfc,
                            pfrd,
                            pssc );

    case SF_NOTIFY_END_OF_NET_SESSION:

        //
        //  Free any context information pertaining to this
        //  request
        //

        pssc = (SSPI_FILTER_CONTEXT *) pfc->pFilterContext;

        if ( pssc )
        {
            DBG_ASSERT( pssc->CheckSignature() );

            SSPI_FILTER_CONTEXT::Free( pssc );

        }

        break;

    case SF_NOTIFY_PREPROC_HEADERS:

        pssc = (SSPI_FILTER_CONTEXT *) pfc->pFilterContext;

        if ( pssc )
        {
            DBG_ASSERT( pssc->CheckSignature() );

            return OnPreprocHeaders( pfc,
                                     pssc,
                                     (PHTTP_FILTER_PREPROC_HEADERS) pvInfo );
        }
        break;

    default:
        break;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    )
{

    SSPI_FILTER_CONTEXT::FreeCache();
    FreeCredCache();

    //
    // NB : Under NT 5, the SslEmptyCache function is no longer supported
    //
#if 0
    if ( g_pfnFlushSchannelCache )
    {
        (g_pfnFlushSchannelCache)();
    }
#endif

    return(TRUE);
}

DWORD
RequestRenegotiate(
   HTTP_FILTER_CONTEXT* pfc,
   PHTTP_FILTER_REQUEST_CERT pInfo,
   SSPI_FILTER_CONTEXT* pssc
   )
{
    DWORD                dwSt = SF_STATUS_REQ_NEXT_NOTIFICATION;
    SECURITY_STATUS      scRet;
    TimeStamp            tsExpiry;
    DWORD                ContextAttributes;
    CtxtHandle           hOutContext;
    CredHandle *phCred;

    if ( !pssc->CanRenegotiate() )
    {
        pInfo->fAccepted = FALSE;
    }
    else
    {
        LPVOID     pvInstanceId;
        DWORD      dwInstanceId;
        CredHandle CredHandle;
        pssc->m_dwAscReq |= ASC_REQ_MUTUAL_AUTH;

        pssc->m_Buffers[0].BufferType = SECBUFFER_TOKEN;
        pssc->m_Buffers[0].pvBuffer   = "";
        pssc->m_Buffers[0].cbBuffer   = 0;
        pssc->m_Buffers[1].BufferType = SECBUFFER_EMPTY;
        pssc->m_Buffers[2].BufferType = SECBUFFER_EMPTY;
        pssc->m_Buffers[3].BufferType = SECBUFFER_EMPTY;

        pssc->SetIsMap( pInfo->fMapCert );

        hOutContext = pssc->m_hContext;

        DBGPRINTF((DBG_CONTEXT,
                   "[RequestRenegotiate] Requesting renegotiation ...\n"));

        scRet = AcceptSecurityContext(
#ifdef IIS3
                    pssc->m_phCredInUse =
                        pssc->IsMap()
                            ? &pssc->m_phCreds->m_ahCredMap[pssc->m_iCredInUse]
                            : &pssc->m_phCreds->m_ahCred[pssc->m_iCredInUse],
#else
                    pssc->m_phCredInUse,
#endif
                    &pssc->m_hContext,
                    &pssc->m_Message,
                    pssc->m_dwAscReq,
                    SECURITY_NATIVE_DREP,
                    &hOutContext,
                    &pssc->m_MessageOut,
                    &ContextAttributes,
                    &tsExpiry );

#if DBG_SSL

        phCred = (pssc->IsMap() ? &pssc->m_phCreds->m_ahCredMap[pssc->m_iCredInUse] :
                                  &pssc->m_phCreds->m_ahCred[pssc->m_iCredInUse] );


        DBGPRINTF((DBG_CONTEXT,
                   "[RequestRenegotiate] Passed in cred handle %08x:%08x, context %08x:%08x, got back new context %08x:%08x, %s : 0x%x\n", phCred->dwLower, phCred->dwUpper, pssc->m_hContext.dwLower,
                   pssc->m_hContext.dwUpper, hOutContext.dwLower, hOutContext.dwUpper,
                   (SUCCEEDED(scRet) ? "success" : "fail"), scRet ) );

#endif

        if ( SUCCEEDED( scRet ) )
        {
            pssc->m_hContext = hOutContext;

            BOOL fRet;

            fRet = pfc->WriteClient( pfc,
                                     pssc->m_OutBuffers[0].pvBuffer,
                                     &pssc->m_OutBuffers[0].cbBuffer,
                                     0 );

            FreeContextBuffer( pssc->m_OutBuffers[0].pvBuffer );

            if ( fRet )
            {
                pInfo->fAccepted = TRUE;

                pssc->m_fInRenegotiate = TRUE;

                pssc->m_cbHeader    = 0;
                pssc->m_cbTrailer   = 0;
                pssc->m_cbBlockSize = 0;

                dwSt = SF_STATUS_REQ_HANDLED_NOTIFICATION;
            }
            else
            {
                dwSt = SF_STATUS_REQ_ERROR;
            }

            pssc->SignalRenegotiateRequested();
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "[RequestRenegotiate] AcceptSecurityContext failed, error %x\n",
                       scRet));

            if (ContextAttributes & ASC_RET_EXTENDED_ERROR )
            {
                pfc->WriteClient( pfc,
                                  pssc->m_OutBuffers[0].pvBuffer,
                                  &pssc->m_OutBuffers[0].cbBuffer,
                                  0 );

                FreeContextBuffer( pssc->m_OutBuffers[0].pvBuffer );

            }

            SetLastError( scRet );
            dwSt = SF_STATUS_REQ_ERROR;
        }
    }

    return dwSt;
}


DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    SSPI_FILTER_CONTEXT *         pssc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    )
{
    CHAR  achUserAgent[512];
    DWORD cb;
    BOOL fClientKnownToHandleKeepAlives = FALSE;

    cb = sizeof(achUserAgent);
    if ( !pvData->GetHeader( pfc,
                         "User-Agent:",
                         achUserAgent,
                         &cb ) )
    {
        achUserAgent[0] = '\0';
    }

    //
    // Check if client known to handle keep-alives
    //

    if ( strstr( achUserAgent, "MSIE" ) )
    {
        // no need to modify the SSL msg size

        pssc->m_dwLastSslMsgSize = SSL_MAX_MSG_SIZE;
        fClientKnownToHandleKeepAlives = TRUE;
    }

    if ( dwNoKeepAlive )
    {
        if ( dwNoKeepAlive == SSL_NO_KEEP_ALIVE_FOR_NON_COMPLIANT_CLIENTS
                && fClientKnownToHandleKeepAlives )
        {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        //
        //  Remove the "Connection:" header, thus disabling keep-alives
        //

        if ( !pvData->SetHeader( pfc,
                                 "Connection:",
                                 "" ))
        {
            return SF_STATUS_REQ_ERROR;
        }
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


BOOL
SignalAuthorizationComplete(
    BOOL fHaveCert,
    HTTP_FILTER_CONTEXT *  pfc,
    SSPI_FILTER_CONTEXT *  pssc
    )
{
    if ( pssc->IsInRenegotiate() || fHaveCert )
    {
        //
        // Notify IIS of result of renegotiation
        //

        if ( !pfc->ServerSupportFunction( pfc,
                                    (SF_REQ_TYPE)SF_REQ_DONE_RENEGOTIATE,
                                    (LPVOID)&fHaveCert,
                                    NULL,
                                    NULL ) )
        {
            return FALSE;
        }

        pssc->m_fInRenegotiate = FALSE;
    }

    return TRUE;
}


SF_STATUS_TYPE
OnAuthorizationInfo(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA * pfrd,
    SSPI_FILTER_CONTEXT *  pssc
    )
/*++

Routine Description:

    This function deals with sending back and forth the SSPI blobs

    Note that in error cases, we just close the socket as we can't send a
    message since we haven't established any of the encrption information.

--*/
{
    TimeStamp            tsExpiry;
    DWORD                ContextAttributes;
    SECURITY_STATUS      scRet;
    SecPkgContext_Sizes  Sizes;
    DWORD                TotalSize;
    DWORD                i;
    SF_STATUS_TYPE       sfStatus = SF_STATUS_REQ_READ_NEXT;
    CtxtHandle           hOutContext;

ag:
    pssc->m_Buffers[0].pvBuffer   = pfrd->pvInData;
    pssc->m_Buffers[0].cbBuffer   = pfrd->cbInData;
    pssc->m_Buffers[0].BufferType = SECBUFFER_TOKEN;
    pssc->m_Buffers[1].BufferType = SECBUFFER_EMPTY;
    pssc->m_Buffers[2].BufferType = SECBUFFER_EMPTY;
    pssc->m_Buffers[3].BufferType = SECBUFFER_EMPTY;

    pssc->m_OutBuffers[0].pvBuffer = NULL;

    //
    //  The first time through we have to choose an encryption provider
    //

    if ( !pssc->IsAuthInProgress() )
    {
        for ( i = 0; i < pssc->m_phCreds->m_cCred; i++ )
        {
            scRet = AcceptSecurityContext(
#ifdef IIS3
                        pssc->IsMap()
                        ? &pssc->m_phCreds->m_ahCredMap[i]
                        : &pssc->m_phCreds->m_ahCred[i],
#else
                        &pssc->m_phCreds->m_ahCred[i],
#endif
                        NULL,
                        &pssc->m_Message,
                        pssc->m_dwAscReq,
                        SECURITY_NATIVE_DREP,
                        &pssc->m_hContext,
                        &pssc->m_MessageOut,
                        &ContextAttributes,
                        &tsExpiry );


#if DBG_SSL
        CredHandle *phCred = (pssc->IsMap() ? &pssc->m_phCreds->m_ahCredMap[i]
                                  : &pssc->m_phCreds->m_ahCred[i] );

        DBGPRINTF((DBG_CONTEXT,
                   "[OnAuthorizationInfo #1] Passed in cred handle %08x:%08x, NULL context, got back new context %08x:%08x, %s : 0x%x\n", phCred->dwLower, phCred->dwUpper, pssc->m_hContext.dwLower,
                   pssc->m_hContext.dwUpper, (SUCCEEDED(scRet) ? "success" : "fail" ), scRet ) );
#endif //DBG_SSL

            if ( SUCCEEDED( scRet ) )
            {
#ifdef IIS3
                pssc->m_phCredInUse = pssc->IsMap()
                    ? &pssc->m_phCreds->m_ahCredMap[i]
                    : &pssc->m_phCreds->m_ahCred[i];
#else
                pssc->m_phCredInUse = &pssc->m_phCreds->m_ahCred[i];
#endif
                pssc->m_iCredInUse  = i;

                //
                //  Note on the first request these values will get reset
                //  to the real values (we can't get this info until we've
                //  fully negotiated the encryption info)
                //

                pssc->m_cbHeader    = 0;    //pssc->m_phCreds->m_acbHeader[i];
                pssc->m_cbTrailer   = 0;    //pssc->m_phCreds->m_acbTrailer[i];
                pssc->m_cbBlockSize = 0;

                break;
            }
            else
            {
                //
                //  An error occurred, try the next encryption provider unless
                //  this is an incomplete message
                //

                if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
                {
                    return SF_STATUS_REQ_READ_NEXT;
                }
            }
        }
    }
    else
    {
        hOutContext = pssc->m_hContext;

        scRet = AcceptSecurityContext(
                    pssc->m_phCredInUse,
                    &pssc->m_hContext,
                    &pssc->m_Message,
                    pssc->m_dwAscReq,
                    SECURITY_NATIVE_DREP,
                    &hOutContext,
                    &pssc->m_MessageOut,
                    &ContextAttributes,
                    &tsExpiry );

#if DBG_SSL
        CredHandle *phCred = pssc->m_phCredInUse;

        DBGPRINTF((DBG_CONTEXT,
                   "[OnAuthorizationInfo #2, nego] Passed in cred handle %08x:%08x, context %08x:%08x, got back new context %08x:%08x, %s : 0x%x\n", phCred->dwLower, phCred->dwUpper,
                   pssc->m_hContext.dwLower,
                   pssc->m_hContext.dwUpper, hOutContext.dwLower, hOutContext.dwUpper,
                   (SUCCEEDED(scRet) ? "success" : "fail" ) , scRet) );
#endif //DBG_SSL


        if ( SUCCEEDED( scRet ) )
        {
            pssc->m_hContext = hOutContext;
        }
    }

    //
    //  Indicate we took all of the bytes
    //

    if ( SUCCEEDED( scRet ) )
    {
        BOOL fRet;

        if ( pssc->m_OutBuffers[0].pvBuffer )
        {
            fRet = pfc->WriteClient( pfc,
                                     pssc->m_OutBuffers[0].pvBuffer,
                                     &pssc->m_OutBuffers[0].cbBuffer,
                                     0 );

            FreeContextBuffer( pssc->m_OutBuffers[0].pvBuffer );

        }
        else
        {
            fRet = TRUE;
        }

        pssc->m_State = STATE_AUTHORIZING;

        if ( !fRet )
        {
            goto ErrorExit;
        }

        //
        //  If we need to get the next blob indicate that now
        //

        if ( scRet == SEC_I_CONTINUE_NEEDED )
        {
#if DBG_SSL
            DBGPRINTF((DBG_CONTEXT,
                       "[OnAuthorizationInfo] Continuing negotiation\n" ));
#endif
        }
        else
        {
            SecPkgContext_StreamSizes  StreamSizes;

            DBGPRINTF(( DBG_CONTEXT,
                        "[OnAuthorizationInfo] We're authorized!\n" ));

            if ( !pssc->m_cbHeader && !pssc->m_cbTrailer )
            {
                // Grab the header and trailer sizes.

                scRet = QueryContextAttributesW( &pssc->m_hContext,
                                                 SECPKG_ATTR_STREAM_SIZES,
                                                 &StreamSizes );

                if ( FAILED( scRet ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                             "[OnAuthorizationInfo] QueryContextAttributes failed, error %lx\n",
                                scRet ));

                    return SF_STATUS_REQ_FINISHED;
                }

                pssc->m_phCreds->m_acbHeader[pssc->m_iCredInUse] = StreamSizes.cbHeader;
                pssc->m_phCreds->m_acbTrailer[pssc->m_iCredInUse] = StreamSizes.cbTrailer;
                pssc->m_phCreds->m_acbBlockSize[pssc->m_iCredInUse] = StreamSizes.cbBlockSize;

                //
                //  Reset the header and trailer values
                //

                pssc->m_cbHeader    = StreamSizes.cbHeader;
                pssc->m_cbTrailer   = StreamSizes.cbTrailer;
                pssc->m_cbBlockSize = StreamSizes.cbBlockSize;
            }

            //
            //  Issue one more read for the real http request
            //

            pssc->m_State = STATE_AUTHORIZED;

            if ( pssc->IsInRenegotiate() )
            {
                sfStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }

            SECURITY_STATUS                     sc;
            SECURITY_STATUS                     scR;
            HANDLE                              hSSPToken = NULL;
#if 0
            SecPkgContext_RemoteCredentialInfo  spcRCI;
#else
            PCCERT_CONTEXT pClientCert = NULL;
#endif
            BOOL                                fCert = TRUE;

#if 0
            scR = QueryContextAttributes( &pssc->m_hContext,
                                          SECPKG_ATTR_REMOTE_CRED,
                                          &spcRCI );
#else
            scR = QueryContextAttributes( &pssc->m_hContext,
                                          SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                          &pClientCert );
#endif

#if 0
            if ( !NT_SUCCESS( scR ) || !spcRCI.cCertificates )
#else
            if ( !NT_SUCCESS( scR ) || !pClientCert )
#endif
            {
                fCert = FALSE;
            }
            else
            {
                DBGPRINTF((DBG_CONTEXT,
                           "[OnAuthorizationInfo] Certificate available!\n" ));
                CertFreeCertificateContext( pClientCert );
            }

#ifdef IIS3
            //
            // check if client authentication available
            //

            if ( 1 || pssc->IsMap() )
            {
                SecPkgContext_MappedCredAttr    Attributes;

                //
                // Check for special access denied handle (0x1).  We need to
                // do it now, because QuerySecurityContextToken() will no
                // longer merrily pass back the 0x1, since it now tries to
                // duplicate whatever handle is returned by the mapper. Nice.
                //

                if ( fCert )
                {
                    sc = QueryContextAttributes( &pssc->m_hContext,
                                                 SECPKG_ATTR_MAPPED_CRED_ATTR,
                                                 &Attributes );
                    if ( NT_SUCCESS( sc ) )
                    {
                        if ( *((HANDLE*) Attributes.pvBuffer ) == (HANDLE)1 )
                        {
                            hSSPToken = (HANDLE)1;
                        }
                        FreeContextBuffer( Attributes.pvBuffer );
                    }
                }

                if ( hSSPToken == NULL )
                {
                    sc = QuerySecurityContextToken( &pssc->m_hContext,
                                                    &hSSPToken );
                }

                if ( !NT_SUCCESS( sc ) )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Didn't get an access token from cert mapping, status : 0x%x\n",
                               sc));

                    hSSPToken = NULL;
                }
                else if ( hSSPToken != (HANDLE)1 )
                {
                    BOOL                    fRet;
                    TOKEN_TYPE              tokenType;
                    DWORD                   cbRequired;
                    HANDLE                  hNewPrimaryToken = NULL;

                    // Not done yet.  We need to determine whether this token
                    // is actually a primary token.  The DS Mapper may not
                    // return such, and if so we should dup it.

                    fRet = GetTokenInformation( hSSPToken,
                                                TokenType,
                                                &tokenType,
                                                sizeof( tokenType ),
                                                &cbRequired );
                    if ( !fRet )
                    {
                        CloseHandle( hSSPToken );
                        hSSPToken = NULL;
                    }
                    else if ( tokenType != TokenPrimary )
                    {
                        DBG_ASSERT( tokenType == TokenImpersonation );

                        fRet = DuplicateTokenEx( hSSPToken,
                                                 0,
                                                 NULL,
                                                 SecurityImpersonation,
                                                 TokenPrimary,
                                                 &hNewPrimaryToken );

                        CloseHandle( hSSPToken );

                        hSSPToken = fRet ? hNewPrimaryToken : NULL;
                    }

                    if ( hSSPToken != NULL )
                    {
                        DBGPRINTF((DBG_CONTEXT,
                                  "Got a primary access token from cert mapping.\n"));
                    }
                }

            }

            if ( !fCert && hSSPToken != NULL )
            {
#if 0
                DBGPRINTF(( DBG_CONTEXT,
                            "[OnAuthorizationInfo] no cert (status %u, nb cert %d) but access token ( %08x )\n",
                    scR, spcRCI.cCertificates, hSSPToken ));
#endif
                CloseHandle( hSSPToken );
                hSSPToken = NULL;
            }

            HTTP_FILTER_CERTIFICATE_INFO CertInfo;
            CertInfo.pbCert = NULL;
            CertInfo.cbCert = 0;
            if ( !pfc->ServerSupportFunction( pfc,
                                        SF_REQ_SET_CERTIFICATE_INFO,
                                        &CertInfo,
                                        (ULONG_PTR)&pssc->m_hContext,
                                        (ULONG_PTR)hSSPToken ) )
            {
                return SF_STATUS_REQ_ERROR;
            }
#else
            pfc->ServerSupportFunction( pfc,
                                        SF_REQ_SET_CERTIFICATE_INFO,
                                        NULL,
                                        (DWORD)&pssc->m_hContext,
                                        (DWORD)NULL );
#endif
            if ( !SignalAuthorizationComplete( fCert, pfc, pssc ) )
            {
                goto ErrorExit;
            }
        }

        if(SECBUFFER_EXTRA == pssc->m_Buffers[1].BufferType)
        {
            NOISY_PRINTF(( buff, "[OnAuthorizationInfo] SECBUFFER_EXTRA Detected\n" ));

            // We have extra data at the end of this input
            // Copy it back in the input buffer and ask for more data

            MoveMemory(pfrd->pvInData,
                       (PBYTE)pfrd->pvInData +
                               pfrd->cbInData -
                               pssc->m_Buffers[1].cbBuffer,
                       pssc->m_Buffers[1].cbBuffer);


            pfrd->cbInData = pssc->m_Buffers[1].cbBuffer;

            //
            // If we just processed the last message for initial handshake
            // then we must decrypt this data before requesting more
            //

            if ( pssc->m_State == STATE_AUTHORIZED )
            {
                sfStatus = SF_STATUS_REPROCESS;
            }
            else
            {
                goto ag;
            }
        }
        else
        {
            //
            //  Indicate there's nothing left in the buffer
            //

            pfrd->cbInData = 0;
        }

        return sfStatus;
    }
    else
    {
        if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
        {
            DBGPRINTF((DBG_CONTEXT,
                     "[OnAuthorizationInfo] Incomplete message, reading next chunk", scRet ));

            return SF_STATUS_REQ_READ_NEXT;
        }
        if (ContextAttributes & ASC_RET_EXTENDED_ERROR )
        {
            pfc->WriteClient( pfc,
                              pssc->m_OutBuffers[0].pvBuffer,
                              &pssc->m_OutBuffers[0].cbBuffer,
                              0 );

            FreeContextBuffer( pssc->m_OutBuffers[0].pvBuffer );
        }

        DBGPRINTF((DBG_CONTEXT,
                   "AcceptSecurityContext returned failure, %#x\n", scRet ));

        SignalAuthorizationComplete( FALSE, pfc, pssc );

        goto ErrorExit;
    }

ErrorExit:

    return SF_STATUS_REQ_FINISHED;
}

SF_STATUS_TYPE
EncryptData(
    HTTP_FILTER_CONTEXT  * pfc,
    HTTP_FILTER_RAW_DATA * pfrd,
    SSPI_FILTER_CONTEXT *  pssc
    )
{
    SECURITY_STATUS scRet;
    DWORD           cbToSend;
    DWORD           iBuff = 0;
    DWORD           cbToAlloc;

#define LAST_SSL_MSG_MAX_SIZE    pssc->m_dwLastSslMsgSize
#ifdef USE_ROUNDING
#define ROUND_DOWN(a,b) ((a)-(a)%(b))
#define ROUND_UP(a,b) ( (((a)+(b)-1)/(b))*(b) )
#else
#define ROUND_DOWN(a,b) (a)
#define ROUND_UP(a,b) (a)
#endif

    //
    // This work-around was created due to inter-operability problems
    // between Netscape 2.x <> IIS. Transfer stalls if more than 1
    // connections is used and the connections are keep alived.
    // This breaks SSL messages in 2 parts if the size
    // is > LAST_SSL_MSG_MAX_SIZE, which was empirically determined
    // to be around 100.
    // Another possible work-around is to disable keep-alives for SSL,
    // but the performance implications are more severe.
    //

    // make sure that last SSL message size < LAST_SSL_MSG_MAX_SIZE

    UINT cNbMsg;
    DWORD cbEstimateSend = pfrd->cbInData;
    DWORD cbSslProtocolData = pssc->m_cbHeader + pssc->m_cbTrailer;
    DWORD cbBlockSize = pssc->m_cbBlockSize;
    DWORD cbRoundUpData;

    //
    // Determine # of necessary SSL message based on following constraints:
    //   - no SSL message after adding protocol headers should be
    //     greater than SSL_MAX_MSG_SIZE
    //   - the last SSL message size should be < LAST_SSL_MSG_MAX_SIZE
    //

    cbToSend = 0;

    for ( cNbMsg = 0 ; cbEstimateSend ; ++cNbMsg )
    {
        DWORD cbInData = cbEstimateSend;
        if ( cbInData > ROUND_DOWN( SSL_MAX_MSG_SIZE - cbSslProtocolData, cbBlockSize ) )
        {
            cbInData = ROUND_DOWN( SSL_MAX_MSG_SIZE - cbSslProtocolData, cbBlockSize );
        }
        else if ( cbInData > LAST_SSL_MSG_MAX_SIZE )
        {
            cbInData = cbInData - LAST_SSL_MSG_MAX_SIZE;
        }
        cbEstimateSend -= cbInData;
        cbToSend += ROUND_UP( cbInData, cbBlockSize ) + cbSslProtocolData;
    }

    //
    //  Allocate a new send buffer if our current one is too small
    //

    if ( pssc->m_cbSendBuffE < cbToSend )
    {
        if ( pssc->m_pvSendBuffE )
        {
            LocalFree( pssc->m_pvSendBuffE );
        }

        cbToAlloc = max( MAX_SSL_CACHED_BUFFER, cbToSend );
        pssc->m_pvSendBuffE = LocalAlloc( LPTR, cbToAlloc );

        if ( !pssc->m_pvSendBuffE )
        {
            DBGPRINTF((DBG_CONTEXT,
                     "[EncryptData] LocalAlloc failed\n" ));

            pssc->m_cbSendBuffE = 0;

            return SF_STATUS_REQ_FINISHED;
        }

        pssc->m_cbSendBuffE = cbToAlloc;
    }

    //
    //  A token buffer of cbHeaderSize bytes must prefix the encrypted data.
    //  Since SealMessage works in place, we need to move a few things around
    //
    memset(&pssc->m_BuffersE[0],0,sizeof(pssc->m_BuffersE));

    PBYTE pSend = (PBYTE)pssc->m_pvSendBuffE;

    while ( pfrd->cbInData )
    {
        DWORD cbInData = pfrd->cbInData;
        if ( cbInData > ROUND_DOWN( SSL_MAX_MSG_SIZE - cbSslProtocolData, cbBlockSize ) )
        {
            cbInData = ROUND_DOWN( SSL_MAX_MSG_SIZE - cbSslProtocolData, cbBlockSize );
        }
        else if ( cbInData > LAST_SSL_MSG_MAX_SIZE )
        {
            cbInData -= LAST_SSL_MSG_MAX_SIZE;
        }

        memcpy( pSend + pssc->m_cbHeader,
                pfrd->pvInData,
                cbInData );

        iBuff = 0;
        cbRoundUpData = ROUND_UP(cbInData,cbBlockSize);

        if ( pssc->m_cbHeader )
        {
            pssc->m_BuffersE[iBuff].pvBuffer   = pSend;
            pssc->m_BuffersE[iBuff].cbBuffer   = pssc->m_cbHeader;
            pssc->m_BuffersE[iBuff].BufferType = SECBUFFER_TOKEN;

            iBuff++;
        }


        pssc->m_BuffersE[iBuff].pvBuffer   = (BYTE *) pSend + pssc->m_cbHeader;
        pssc->m_BuffersE[iBuff].cbBuffer   = cbRoundUpData;
        pssc->m_BuffersE[iBuff].BufferType = SECBUFFER_DATA;

        iBuff++;

        if ( pssc->m_cbTrailer )
        {
            pssc->m_BuffersE[iBuff].pvBuffer   = (BYTE *) pSend +
                                               pssc->m_cbHeader + cbRoundUpData;
            pssc->m_BuffersE[iBuff].cbBuffer   = pssc->m_cbTrailer;
            pssc->m_BuffersE[iBuff].BufferType = SECBUFFER_TOKEN;

            iBuff++;
        }

        scRet = SealMessage( &pssc->m_hContext,
                             0,
                             &pssc->m_MessageE,
                             0 );

        if ( FAILED( scRet ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                     "[EncryptData] SealMessage failed with error %lx\n",
                     scRet ));

            return SF_STATUS_REQ_FINISHED;
        }

        pfrd->pvInData = (PBYTE)pfrd->pvInData + cbInData;
        pfrd->cbInData -= cbInData;
#ifdef USE_ROUNDING
        pSend += cbSslProtocolData + cbRoundUpData;
#else
        while ( iBuff-- )
        {
            pSend += pssc->m_BuffersE[iBuff].cbBuffer;
        }
#endif
    }

    cbToSend = DIFF(pSend - (PBYTE)pssc->m_pvSendBuffE);


    //
    //  Update our return buffer
    //

#if defined(RENEGOTIATE_CERT_ON_ACCESS_DENIED)
    if ( pssc->IsInRenegotiate() )
    {
        pfrd->cbInData = 0;

        return pssc->AppendDeferredWrite( pssc->m_pvSendBuffE, cbToSend )
                ? SF_STATUS_REQ_HANDLED_NOTIFICATION
                : SF_STATUS_REQ_ERROR;
    }
#endif

    pfrd->pvInData = pssc->m_pvSendBuffE;
    pfrd->cbInData = cbToSend;

    //
    //  We indicate we handled the request since no subsequent filters can
    //  interpret the encrypted data
    //

    return SF_STATUS_REQ_HANDLED_NOTIFICATION;
}


SF_STATUS_TYPE
DecryptData(
    HTTP_FILTER_CONTEXT  * pfc,
    HTTP_FILTER_RAW_DATA * pfrd,
    SSPI_FILTER_CONTEXT *  pssc
    )
{
    SECURITY_STATUS      scRet;
    DWORD                iExtra;
    LPBYTE               pvInData;


    pssc->m_Buffers[0].pvBuffer   = (BYTE *) pfrd->pvInData +
                                             pssc->m_cbEncryptedStart;
    pssc->m_Buffers[0].cbBuffer   = pfrd->cbInData - pssc->m_cbEncryptedStart;

    pssc->m_Buffers[0].BufferType = SECBUFFER_DATA;
    pssc->m_Buffers[1].BufferType = SECBUFFER_EMPTY;
    pssc->m_Buffers[2].BufferType = SECBUFFER_EMPTY;
    pssc->m_Buffers[3].BufferType = SECBUFFER_EMPTY;

DecryptNext:

    scRet = UnsealMessage( &pssc->m_hContext,
                           &pssc->m_Message,
                           0,
                           NULL );

    if ( FAILED( scRet ) )
    {
        if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
        {
            //
            //  This encrypted message spans multiple packets.  We must continue
            //  reading and get the full message and Unseal it as a single unit
            //
            //  We leave pfrd->cbInData as is so the new data will be appended
            //  onto the existing buffer
            //

            DBGPRINTF((DBG_CONTEXT,
                     "[DecryptData] Message is short %d bytes\n",
                     pssc->m_Buffers[1].cbBuffer ));

            pfc->ServerSupportFunction( pfc,
                                        SF_REQ_SET_NEXT_READ_SIZE,
                                        NULL,
                                        pssc->m_Buffers[1].cbBuffer,
                                        0 );

            //
            //  Save where the beginning of the next encrypted chunk is
            //

            pssc->m_cbEncryptedStart = DIFF((BYTE *)pssc->m_Buffers[0].pvBuffer -
                                            (BYTE *)pfrd->pvInData);
            return SF_STATUS_REQ_READ_NEXT;
        }

        DBGPRINTF(( DBG_CONTEXT,
                 "[DecryptData] Failed to decrypt message sz %d, error %lx\n",
                 pfrd->cbInData, scRet ));

        return SF_STATUS_REQ_FINISHED;
    }

    //
    //  Fix up the buffer of decrypted data so it's contiguous by
    //  overwriting the intervening stream header/trailer.
    //

    memmove( (BYTE *) pfrd->pvInData +
                             pssc->m_cbDecrypted,
             pssc->m_Buffers[1].pvBuffer,
             pssc->m_Buffers[1].cbBuffer );

    pssc->m_cbDecrypted += pssc->m_Buffers[1].cbBuffer;

    //
    //  Check to see if there were multiple SSL messages in this network buffer
    //
    //  The extra buffer will be the second one for SSL, the third one for PCT
    //

    iExtra = (pssc->m_Buffers[2].BufferType == SECBUFFER_EXTRA) ? 2 :
                 (pssc->m_Buffers[3].BufferType == SECBUFFER_EXTRA) ? 3 : 0;

    if ( iExtra )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[DecryptData] Extra data in buffer, size %d\n",
                    pssc->m_Buffers[iExtra].cbBuffer ));

        //
        //  Reset the buffer types and decrypt the extra chunk
        //

        pssc->m_Buffers[0].pvBuffer   = pssc->m_Buffers[iExtra].pvBuffer;
        pssc->m_Buffers[0].cbBuffer   = pssc->m_Buffers[iExtra].cbBuffer;
        pssc->m_Buffers[0].BufferType = SECBUFFER_DATA;
        pssc->m_Buffers[1].BufferType = SECBUFFER_EMPTY;
        pssc->m_Buffers[2].BufferType = SECBUFFER_EMPTY;
        pssc->m_Buffers[3].BufferType = SECBUFFER_EMPTY;

        //
        //  Recalculate the beginning of this encrypted chunk
        //

        pssc->m_cbEncryptedStart = DIFF((BYTE *)pssc->m_Buffers[0].pvBuffer -
                                        (BYTE *)pfrd->pvInData);

        if ( scRet != SEC_I_RENEGOTIATE )
            goto DecryptNext;
    }

    //
    //  Set our output buffers to the decrypted data
    //

    pfrd->cbInData   = pssc->m_cbDecrypted;

    //
    // Handle cert renegotiate request from client
    //

    if ( scRet == SEC_I_RENEGOTIATE )
    {
        pssc->m_State    = STATE_AUTHORIZING;
        pvInData         = (LPBYTE)pfrd->pvInData;
        pfrd->pvInData   = (BYTE *) pssc->m_Buffers[iExtra].pvBuffer;
        pfrd->cbInData   = iExtra ? pssc->m_Buffers[iExtra].cbBuffer : 0;
        if ( OnAuthorizationInfo( pfc, pfrd, pssc )
            != SF_STATUS_REQ_READ_NEXT )
        {
            return SF_STATUS_REQ_FINISHED;
        }
        pfrd->pvInData   = pvInData;
        pfrd->cbInData   = pssc->m_cbDecrypted;
    }

    //
    //  We have a complete set of messages, reset the tracking members
    //

    pssc->m_cbDecrypted      = 0;
    pssc->m_cbEncryptedStart = 0;

    //
    //  Indicate other filters can now be notified
    //

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

VOID
SSPI_FILTER_CONTEXT::Initialize( VOID )
{
    //
    // Initialize security buffer structs
    //

    m_Message.ulVersion = SECBUFFER_VERSION;
    m_Message.cBuffers = 4;
    m_Message.pBuffers = m_Buffers;

    m_Buffers[0].BufferType = SECBUFFER_EMPTY;
    m_Buffers[1].BufferType = SECBUFFER_EMPTY;
    m_Buffers[2].BufferType = SECBUFFER_EMPTY;
    m_Buffers[3].BufferType = SECBUFFER_EMPTY;

    // Encryption buffer descriptors
    m_MessageE.ulVersion = SECBUFFER_VERSION;
    m_MessageE.cBuffers = 4;
    m_MessageE.pBuffers = m_BuffersE;

    m_BuffersE[0].BufferType = SECBUFFER_EMPTY;
    m_BuffersE[1].BufferType = SECBUFFER_EMPTY;
    m_BuffersE[2].BufferType = SECBUFFER_EMPTY;
    m_BuffersE[3].BufferType = SECBUFFER_EMPTY;


    m_MessageOut.ulVersion = SECBUFFER_VERSION;
    m_MessageOut.cBuffers = 4;
    m_MessageOut.pBuffers = m_OutBuffers;

    m_OutBuffers[0].BufferType = SECBUFFER_EMPTY;
    m_OutBuffers[1].BufferType = SECBUFFER_EMPTY;
    m_OutBuffers[2].BufferType = SECBUFFER_EMPTY;
    m_OutBuffers[3].BufferType = SECBUFFER_EMPTY;

    memset( &m_hContext, 0, sizeof( m_hContext ));

    m_phCreds    = NULL;
    m_cbTrailer  = 0;
    m_cbHeader   = 0;
    m_iCredInUse = 0xffffffff;

    m_cbDecrypted      = 0;
    m_cbEncryptedStart = 0;
    m_dwLastSslMsgSize = dwLastSslMsgSize;

    m_State = STATE_STARTUP;

    m_dwAscReq = ASC_REQ_EXTENDED_ERROR |
            ASC_REQ_SEQUENCE_DETECT |
            ASC_REQ_REPLAY_DETECT |
            ASC_REQ_CONFIDENTIALITY |
            ASC_REQ_STREAM |
            ASC_REQ_ALLOCATE_MEMORY;

    m_fCanRenegotiate = TRUE;
    m_fInRenegotiate = FALSE;
    m_fIsMap = FALSE;
#if defined(RENEGOTIATE_CERT_ON_ACCESS_DENIED)
    m_xbDeferredWrite.Reset();
#endif
    m_fFlushOnDelete = FALSE;
}


BOOL
WINAPI
InitializeProviderList(
    VOID
    )
{
    HKEY              hkeyParam;
    DWORD             dwType;
    DWORD             cbData;
    DWORD             dwLsaSchannel;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_ALL_ACCESS,
                       &hkeyParam ) == NO_ERROR )
    {
        cbData = sizeof( dwLsaSchannel );
        if ( RegQueryValueEx( hkeyParam,
                              "LsaSchannel",
                              NULL,
                              &dwType,
                              (BYTE *) &dwLsaSchannel,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwLsaSchannel )
        {
            g_fIsLsaSchannel = TRUE;
            pEncProviders = EncLsaProviders;
        }

        RegCloseKey( hkeyParam );

        return TRUE;
    }

    return FALSE;
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
#ifdef IIS3
        CREATE_DEBUG_PRINT_OBJECT( "SSPI" );
#endif
#else
        CREATE_DEBUG_PRINT_OBJECT( "SSPI", IisSspiGuid );
#endif

        INITIALIZE_CRITICAL_SECTION( &g_csGlobalLock );

        InitializeProviderList();
        SSPI_FILTER_CONTEXT::InitCache();
        InitCredCache();
        if ( g_hSchannel = LoadLibrary( "schannel.dll" ) )
        {
            g_pfnFlushSchannelCache = (PFN_SCHANNEL_INVALIDATE_CACHE)GetProcAddress(
                    g_hSchannel, "SslEmptyCache" );
        }

        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:

        DeleteCriticalSection( &g_csGlobalLock );

        if ( g_hSchannel )
        {
            FreeLibrary( g_hSchannel );
        }
#ifdef IIS3
        DELETE_DEBUG_PRINT_OBJECT( );
#endif
        break;

    default:
        break;
    }

    return TRUE;
}


VOID WINAPI NotifySslChanges(
    DWORD                         dwNotifyType,
    LPVOID                        pInstance
    )
{
    if ( dwNotifyType == SF_NOTIFY_MAPPER_SSLKEYS_CHANGED )
    {
        FreeCredCache();

        //
        // NB : Under NT 5, the SslEmptyCache function is no longer supported
        //
#if 0
        if ( g_pfnFlushSchannelCache )
        {
            (g_pfnFlushSchannelCache)();
        }
#endif

    }
    else if ( dwNotifyType == SF_NOTIFY_MAPPER_CERT11_CHANGED ||
              dwNotifyType == SF_NOTIFY_MAPPER_CERTW_CHANGED )
    {
        FreeCredCache();
    }
    else if ( dwNotifyType == SF_NOTIFY_MAPPER_CERT11_TOUCHED )
    {
        //
        // NB : Under NT 5, the SslEmptyCache function is no longer supported
        //
#if 0
        if ( g_pfnFlushSchannelCache )
        {
            (g_pfnFlushSchannelCache)();
        }
#endif
        SSPI_FILTER_CONTEXT::FlushOnDelete();
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

}


SSPI_FILTER_CONTEXT::~SSPI_FILTER_CONTEXT()
{
    if ( m_State != STATE_STARTUP )
    {
        NOISY_PRINTF(( buff,
                 "[DeleteSecurityContext] dest: %08x:%08x\n",
                       m_hContext.dwLower,
                       m_hContext.dwUpper));

        //
        // DeleteSecurityContext may AV during handle validation
        // because schannel may have already closed the handle on
        // some error conditions ( such as invalid data during negotiation )
        //

        __try
        {
            DeleteSecurityContext( &m_hContext );
        } __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            PRINTF(( buff,
                    "[~SSPI_FILTER_CONTEXT] DeleteSecurityContext exception\n" ));
        }

        if ( m_fFlushOnDelete && g_pfnFlushSchannelCache )
        {
            //
            // NB : Under NT 5, the SslEmptyCache function is no longer supported
            //
#if 0
            (g_pfnFlushSchannelCache)();
#endif
        }
    }

    if ( m_pvSendBuff )
    {
        LocalFree( m_pvSendBuff );
    }
    if ( m_pvSendBuffE )
    {
        LocalFree( m_pvSendBuffE );
    }
    m_dwSignature = SSPI_FILTER_CONTEXT_SIGNATURE_BAD;

}


VOID SSPI_FILTER_CONTEXT::Close( VOID )
{
    if ( m_State != STATE_STARTUP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                 "[DeleteSecurityContext], context %p, dest: %08x:%08x\n",
                    this,
                    m_hContext.dwLower,
                    m_hContext.dwUpper));

        //
        // DeleteSecurityContext may AV during handle validation
        // because schannel may have already closed the handle on
        // some error conditions ( such as invalid data during negotiation )
        //
        __try
        {
            DeleteSecurityContext( &m_hContext );
        } __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "[Close] DeleteSecurityContext exception\n" ));
        }

        if ( m_fFlushOnDelete && g_pfnFlushSchannelCache )
        {
            //
            // NB : Under NT 5, the SslEmptyCache function is no longer supported
            //
#if 0
            (g_pfnFlushSchannelCache)();
#endif
        }
        m_State = STATE_STARTUP;
        m_fFlushOnDelete = FALSE;

        memset( &m_hContext, 0, sizeof(m_hContext) );
    }

    if ( m_phCreds != NULL )
    {
        ReleaseCredential( m_phCreds );
        m_phCreds = NULL;
    }
    m_phCredInUse = NULL;

    if ( m_cbSendBuff > MAX_SSL_CACHED_BUFFER )
    {
        LocalFree( m_pvSendBuff );
        m_pvSendBuff = NULL;
        m_cbSendBuff = 0;
    }

    if ( m_cbSendBuffE > MAX_SSL_CACHED_BUFFER )
    {
        LocalFree( m_pvSendBuffE );
        m_pvSendBuffE = NULL;
        m_cbSendBuffE = 0;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\pwsdata\pwsadmin.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsadmin.cxx

Abstract:

    This module implements the PWS filter admin interface

Author:

    Johnson Apacible (JohnsonA)     1-15-97

Revision History:
--*/

#include <windows.h>
#include <iisfilt.h>
//#include <stdlib.h>
#include <pwsdata.hxx>
#include <inetsvcs.h>
#include <stdio.h>

#ifndef _NO_TRACING_
#include <initguid.h>
#include "pudebug.h"
DEFINE_GUID(IisPwsDataGuid, 
0x784d891E, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
DECLARE_DEBUG_PRINTS_OBJECT()
#endif

void CheckTimePeriod( PPWS_DATA pData );


VOID
ClosePwsData(
    IN PVOID PwsData
    )
{
    UnmapViewOfFile(PwsData);
#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
#endif
    return;

}  // ClosePwsData


PVOID
OpenPwsData(
    VOID
    )
{
    HANDLE hMap;
    PPWS_DATA_PRIVATE pwsData;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("pwsdata", IisPwsDataGuid);
#endif

    hMap = OpenFileMapping(
                    FILE_MAP_READ,
                    FALSE,
                    PWS_DATA_SPACE_NAME
                    );

    if ( hMap == NULL ) {
        IIS_PRINTF((buff,
            "Error %d in OpenFileMapping\n", GetLastError()));
        printf("error %d in openfile\n",GetLastError());
#ifndef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
        return(NULL);
    }

    pwsData = (PPWS_DATA_PRIVATE)MapViewOfFile(
                                    hMap,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );

    CloseHandle(hMap);
    if ( pwsData == NULL ) {
        IIS_PRINTF((buff,"Error %d in MapViewOfFile\n", GetLastError()));
        printf("error %d in mvff\n",GetLastError());
#ifndef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
        return(NULL);
    }

    if ( (pwsData->Signature != PWS_DATA_SIGNATURE) ||
         (pwsData->dwSize != sizeof(PWS_DATA_PRIVATE)) ) {

        IIS_PRINTF((buff,
            "Signature %x[%x] Size %d[%d] do not match\n",
            pwsData->Signature, PWS_DATA_SIGNATURE,
            pwsData->dwSize, sizeof(PWS_DATA_PRIVATE)));

        printf("signature dont match\n");
        ClosePwsData(pwsData);
        pwsData = NULL;
#ifndef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
    }

    return(pwsData);

} // OpenPwsData





BOOL
GetPwsData(
    IN OUT PPWS_DATA Data
    )
{

    HANDLE hMap;
    PPWS_DATA_PRIVATE pwsData;

    ZeroMemory(Data,sizeof(PWS_DATA));

    pwsData = (PPWS_DATA_PRIVATE)OpenPwsData( );

    if ( pwsData != NULL ) {
		// just block copy over all the data
		CopyMemory ( Data, &pwsData->PwsStats, sizeof( PWS_DATA ) );

		// check the data for a timing period roll-over
		CheckTimePeriod( Data );

		/*
        Data->nSessions = pwsData->PwsStats.nSessions;
        Data->nTotalSessions = pwsData->PwsStats.nTotalSessions;
        Data->nHits = pwsData->PwsStats.nHits;
        Data->nBytesSent = pwsData->PwsStats.nBytesSent;
		*/

        ClosePwsData(pwsData);
        return(TRUE);
    }

    return(FALSE);

} // GetPwsData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\binsrv\binsrv.cxx ===
/*++

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    binsrv.cxx

Abstract:

    Main module for binary object server ISAPI application.
    It uses Async TransmitFile for achieving the same.

Author:

    Murali R. Krishnan ( MuraliK )   30-Oct-1996

Revision History:
--*/

#include <windows.h>
#include <iisext.h>

# include "dbgutil.h"

/************************************************************
 *  Global Data
 ************************************************************/

CRITICAL_SECTION g_csWorkItems;

# define USE_WORK_QUEUE   (0)


DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb);

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb,
              IN HANDLE hFile, 
              IN LPCSTR pszFile);

DWORD
GenerateBinaryUrlName( IN EXTENSION_CONTROL_BLOCK * pecb,
                       OUT CHAR * pszNewUrl,
                       OUT LPCSTR * ppszError
                       );

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();


/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          
          OutputDebugString( " Initializing the global data\n");

          //
          // Initialize various data and modules.
          //
          InitializeCriticalSection(&g_csWorkItems);

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          if ( lpvContext != NULL) {

              DeleteCriticalSection(&g_csWorkItems);
          }

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return ( fReturn);
}  /* DllLibMain() */




DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
/*++

 Routine Description:

   This function performs the necessary action to send response for the 
    request received from the client. It picks up the name of a file from
    the pecb->lpszQueryString and transmits that file to the client.

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.

 Return Value:

    Returns HSE_* status codes
--*/
{
    char buff[2048];
    DWORD hseStatus;

    IF_DEBUG( API_ENTRY) {
        
        DBGPRINTF(( DBG_CONTEXT, "HttpExtensionProc( %08x) QS: %s. PI: %s\n",
                    pecb, 
                    (pecb->lpszQueryString) ? pecb->lpszQueryString : "null",
                    (pecb->lpszPathInfo) ? pecb->lpszPathInfo : "null"
                    ));
    }
    
    hseStatus = SendFileToClient( pecb);
    
    return ( hseStatus);
    
} // HttpExtensionProc()





BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    CREATE_DEBUG_PRINT_OBJECT( "binsrv");
    SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_API_ENTRY | DEBUG_API_EXIT);
    
    pver->dwExtensionVersion = MAKELONG( HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
    strcpy( pver->lpszExtensionDesc,
           "Binary Object Server ISAPI application" );
    
    return TRUE;
}



BOOL WINAPI
TerminateExtension( IN DWORD dwFlags)
{

    DELETE_DEBUG_PRINT_OBJECT();
    return ( TRUE);
} // TerminateExtension()



DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg)
{
    
    CHAR buff[600];
    
    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //
    
    wsprintf( buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Simple File Transfer</title></head>\n"
             "<body><h1>%s</h1>\n"
             ,
             pszErrorMsg );
    
    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                      HSE_REQ_SEND_RESPONSE_HEADER,
                                      "200 OK",
                                      NULL,
                                      (LPDWORD) buff )
        ) {
        
        return HSE_STATUS_ERROR;
    }
    
    return ( HSE_STATUS_SUCCESS);
} // SendHeaderToClient()
    


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb)
{
    CHAR    rgszNewUrl[1024];
    DWORD   hseStatus = HSE_STATUS_SUCCESS;
    LPCSTR  pszError = "File Not Found";
    
    // 1. Munge the incoming URL based no client CPU
    hseStatus = GenerateBinaryUrlName( pecb, rgszNewUrl, &pszError);

    if ( hseStatus != HSE_STATUS_SUCCESS) { 
        hseStatus = ( SendHeaderToClient( pecb, pszError));
    } else {

        DBGPRINTF(( DBG_CONTEXT, " New URL is: %s\n",
                    rgszNewUrl));

        // 2. Use SEND_URL to reprocess URL for transmission
        
        if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                           HSE_REQ_SEND_URL,
                                           rgszNewUrl,
                                           NULL,
                                           (LPDWORD) NULL )
             ) {
            
            IF_DEBUG( ERROR ) { 
                DBGPRINTF(( DBG_CONTEXT, "SendURL(%s) failed with Error = %d\n",
                            rgszNewUrl, GetLastError()));
            }
            
            hseStatus = ( HSE_STATUS_ERROR);
        }
    }

    return ( hseStatus);
} // SendFileToClient()



# define MAX_PROCESSOR_TYPE_LEN   (40)

const char * g_rgchProcTypes[] = {
 "x86",
 "alpha",
 "ppc",
 "mips"
};

const char * g_rgchUpcaseProcTypes[] = {
 "X86",
 "ALPHA",
 "PPC",
 "MIPS"
};

DWORD  g_rgLenProcTypes[] = {
 3, 5, 4, 3
};

# define NUM_PROC_TYPES ( sizeof(g_rgchProcTypes) / sizeof( g_rgchProcTypes[0]))

DWORD
GenerateBinaryUrlName( IN EXTENSION_CONTROL_BLOCK * pecb,
                       OUT CHAR * pszNewUrl,
                       OUT LPCSTR * ppszError
                       )
{

    LPCSTR pszOriginalUrl = pecb->lpszPathInfo;
    CHAR   rgchProcessorType[ MAX_PROCESSOR_TYPE_LEN];
    DWORD  cbProcessorType = MAX_PROCESSOR_TYPE_LEN;

    // 1. find the path for the file.
    //  Intelligently enough IIS does not send the path info for request in the
    //   lpszPathInfo. Let us choose Query String if lpszPathInfo is empty.
    if ( (pszOriginalUrl == NULL) || (*pszOriginalUrl == '\0')) {

        pszOriginalUrl = pecb->lpszQueryString;
    }


    // 2. find the UA_CPU value for client
    // 3. Encode file_path & UA_CPU to form the path for proper binary
    // 4. store the new name in pszNewUrl

    // TBD: Verify if such a file exists

    if ( !pecb->GetServerVariable( pecb->ConnID, 
                                   "HTTP_UA_CPU",
                                   rgchProcessorType, 
                                   &cbProcessorType
                                   )
         ) {

        DBGPRINTF(( DBG_CONTEXT, " GSV( HTTP_UA_CPU) failed with error = %d\n",
                    GetLastError()));
        *ppszError = " No CPU Type specified ";

        return ( HSE_STATUS_ERROR);
    }
    
    // now rgchProcessorType has the type -> form the proper binary path.
    for ( DWORD i = 0; i < NUM_PROC_TYPES; i++) { 

        if ( (rgchProcessorType[0] == g_rgchProcTypes[i][0]) && 
             !strcmp( rgchProcessorType + 1,  g_rgchProcTypes[i] + 1)
             ) {
            break;
        } else {
            if ((rgchProcessorType[0] == g_rgchUpcaseProcTypes[i][0]) && 
                !strcmp( rgchProcessorType + 1,  g_rgchUpcaseProcTypes[i] + 1)
                ) {
                break;
            }
        }
    } // for

    if ( i == NUM_PROC_TYPES) { 
        DBGPRINTF(( DBG_CONTEXT, " Unknown Processor Type %s\n",
                    rgchProcessorType));
        *ppszError = "Unknown Processor Type";
        return ( HSE_STATUS_ERROR); // avoid cascading errors
    }
    
    // form the new URL name
    // New URL =  <oldURL> + <processorType>
    DWORD  cbLen;
    cbLen = strlen(pszOriginalUrl);
    DBG_ASSERT( ( cbLen + g_rgLenProcTypes[i])
                < 1024);

    DBGPRINTF(( DBG_CONTEXT, " old = [%s] Proc = [%s] \n",
                pszOriginalUrl, rgchProcessorType));
    strcpy( pszNewUrl, pszOriginalUrl);
    strcat( pszNewUrl + cbLen, ".");
    strcat( pszNewUrl + cbLen + 1, g_rgchProcTypes[i]);

    return ( HSE_STATUS_SUCCESS);

} // GenerateBinaryUrlName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\binsrv\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\pwsdata\pwsdata.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsdata.cxx

Abstract:

    This module implements the PWS filter

Author:

    Johnson Apacible (JohnsonA)     1-15-97
    Boyd Multerer (BoydM)
    Boyd Multerer (BoydM)           4-30-97
    Boyd Multerer (BoydM)           4-7-97  // added unique IP tracking

Revision History:
--*/

#include <windows.h>
#include <time.h>
#include <iisfilt.h>
#include <stdlib.h>
#include <pwsdata.hxx>
#include <inetsvcs.h>

#include <winsock2.h>
#include <pudebug.h>

PPWS_DATA_PRIVATE   PwsData = NULL;
HANDLE              hFileMap = NULL;

#define             TRACK_IP_NUM    50
DWORD               g_rgbIPTrack[TRACK_IP_NUM];
time_t              g_rgbIPHourTrack[TRACK_IP_NUM];
time_t              g_rgbIPDayTrack[TRACK_IP_NUM];
CRITICAL_SECTION    g_ip_section;

BOOL
CreatePwsSharedMemory(
    VOID
    );

void CheckTimePeriod( PPWS_DATA pData );
BOOL FTrackIP( DWORD ip, time_t hour, time_t day );

//
//  Pseudo context for tracking individual request threads
//

DWORD ReqNumber = 1000;

//-----------------------------------------------------------------
BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    )
    {
    IIS_PRINTF(( buff, "Pws Filter TerminateExtension() called\n" ));

    DeleteCriticalSection( &g_ip_section );

    if ( PwsData != NULL )
        {
	    UnmapViewOfFile( PwsData );
	    CloseHandle(hFileMap);
	    PwsData = NULL;
	    hFileMap = NULL;
        }
    return TRUE;
    }

//-----------------------------------------------------------------
BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
//DebugBreak();

    IIS_PRINTF(( buff,
	    "[GetFilterVersion] PWS filter version is %d.%d\n",
	    HIWORD( pVer->dwServerFilterVersion ),
	    LOWORD( pVer->dwServerFilterVersion ) ));

    pVer->dwFilterVersion = MAKELONG( 0, 4 );   // Version 4.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
		     SF_NOTIFY_NONSECURE_PORT     |
		     SF_NOTIFY_LOG                |
		     SF_NOTIFY_END_OF_NET_SESSION |
		     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "PWS Admin Helper Filter, v1.0" );

    //
    // initialize
    //
    if ( !CreatePwsSharedMemory( ) )
        {
	    return(FALSE);
        }

    return TRUE;
}

//-----------------------------------------------------------------
DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
    {
	// see if the time period needs to roll over
	 CheckTimePeriod( &PwsData->PwsStats);

    //
    //  If we don't have a context already, create one now
    //
    if ( !pfc->pFilterContext )
        {
	    pfc->pFilterContext = (VOID *) UIntToPtr(ReqNumber);
        ReqNumber++;

#if 0
	    IIS_PRINTF(( buff,
		    "[HttpFilterProc] New request, ID = %d, fIsSecurePort = %s\n",
		    pfc->pFilterContext,
		    (pfc->fIsSecurePort ? "TRUE" : "FALSE") ));
#endif
        //
        // get the ip address of the remote client
        char   ip[80];
        DWORD   dwSize = sizeof(ip);
        if ( (pfc->GetServerVariable)(pfc, "REMOTE_ADDR", &ip, &dwSize) )
            {
            DWORD dwIP = inet_addr( ip );

            if ( FTrackIP(dwIP, 0, 0) )
	            // increment the global counters
	            PwsData->PwsStats.nTotalSessionsStart++;

            if ( FTrackIP(dwIP, PwsData->PwsStats.time_hour, 0) )
	            // increment the number of sessions in the current time period
	            PwsData->PwsStats.rgbHourData[0].nTotalSessions++;

            if ( FTrackIP(dwIP, 0, PwsData->PwsStats.time_day) )
	            // increment the number of sessions in the current time period
	            PwsData->PwsStats.rgbDayData[0].nTotalSessions++;
            }
        else
            {
            DWORD err;
            err = GetLastError();
            }

        // increment the number of currently active sessions
        //

	    PwsData->PwsStats.nSessions++;

        // increase max sessions, if necessary
	    if ( PwsData->PwsStats.nSessions > PwsData->PwsStats.nMaxSessionsStart )
	        PwsData->PwsStats.nMaxSessionsStart = PwsData->PwsStats.nSessions;
        }

    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
        {
        case SF_NOTIFY_END_OF_NET_SESSION:
	        PwsData->PwsStats.nSessions--;
	        pfc->pFilterContext = 0;
	        break;

        case SF_NOTIFY_LOG:
            {
	        PHTTP_FILTER_LOG logData = (PHTTP_FILTER_LOG)pvData;

	        if ( _stricmp(logData->pszOperation,"GET") == 0 )
                {
                // increment the number of sessions in the current time period
	            PwsData->PwsStats.rgbDayData[0].nHits++;
	            PwsData->PwsStats.rgbHourData[0].nHits++;

                // increment the number of hits since server startup
	            PwsData->PwsStats.nHitsStart++;
	            }

            // increment the number of bytes sent in the current time period
	        PwsData->PwsStats.rgbDayData[0].nBytesSent += logData->dwBytesSent;
	        PwsData->PwsStats.rgbHourData[0].nBytesSent += logData->dwBytesSent;

	        // increment the number of bytes sent since server startup
	        PwsData->PwsStats.nBytesSentStart += logData->dwBytesSent;
	        }
	        break;

        default:
	    IIS_PRINTF(( buff,
		    "[HttpFilterProc] Unknown notification type, %x\n",
		    NotificationType ));
	        break;
        }

    FlushViewOfFile((LPCVOID)PwsData,0);
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

//-----------------------------------------------------------------
BOOL
CreatePwsSharedMemory(
    VOID
    )
{
//DebugBreak();
    ZeroMemory( &g_rgbIPTrack, sizeof(g_rgbIPTrack) );
    ZeroMemory( &g_rgbIPHourTrack, sizeof(g_rgbIPHourTrack) );
    ZeroMemory( &g_rgbIPDayTrack, sizeof(g_rgbIPDayTrack) );
    INITIALIZE_CRITICAL_SECTION( &g_ip_section );

    hFileMap = CreateFileMapping(
		    INVALID_HANDLE_VALUE,
		    NULL,
		    PAGE_READWRITE,
		    0,
		    sizeof(PWS_DATA_PRIVATE),
		    PWS_DATA_SPACE_NAME
		    );

    if ( hFileMap == NULL ) {
	IIS_PRINTF((buff,
	    "Error %d in CreateFileMapping\n", GetLastError()));
	return(FALSE);
    }

    PwsData = (PPWS_DATA_PRIVATE)MapViewOfFile(
				    hFileMap,
				    FILE_MAP_ALL_ACCESS,
				    0,
				    0,
				    sizeof(PWS_DATA_PRIVATE)
				    );

    if ( PwsData == NULL ) {
	IIS_PRINTF((buff,"Error %d in MapViewOfFile\n", GetLastError()));
	CloseHandle(hFileMap);
	hFileMap = NULL;
	return(FALSE);
    }

    //
    // Initialize
    //
    ZeroMemory(PwsData,sizeof(PWS_DATA_PRIVATE));
    PwsData->dwSize = sizeof(PWS_DATA_PRIVATE);
    PwsData->Signature = PWS_DATA_SIGNATURE;

    // since this is our first opportunity to do something, record the start time
    GetLocalTime( &PwsData->PwsStats.timeStart );

    return(TRUE);

} // CreatePwsSharedMemory


//-----------------------------------------------------------------
// by Boyd Multerer
// the pwsData structure contains two arrays - rgbDayData[] and rgbHourData[]
// these arrays store the statics for the previous time periods, so we can show
// a continuing chart over time. Since these are maintained by the server, the
// data will be updated regardless of whether or not the pws ui app is running.
// in both cases [0] represents the current time period. Each position after
// that goes back one time period.
void CheckTimePeriod( PPWS_DATA pData )
	{
    // stop this reentrency stuff
    static BOOL    fCheckBusy = FALSE;
    if ( fCheckBusy ) return;
        fCheckBusy = TRUE;

	// milliseconds
#define ONE_HOUR                3600000
	// hours
#define ONE_DAY                 86400000

	SYSTEMTIME      timeCurrent;

	// get the current time & ticks
	GetLocalTime( &timeCurrent );

    // convert the time - to get the day of year and hour. Disregard minutes and seconds
    time_t  time_hour, time_day;
	struct tm atm;

	atm.tm_sec = 0;
	atm.tm_min = 0;
	atm.tm_hour = timeCurrent.wHour;
	atm.tm_mday = timeCurrent.wDay;
	atm.tm_mon = timeCurrent.wMonth - 1;        // tm_mon is 0 based
	atm.tm_year = timeCurrent.wYear - 1900;     // tm_year is 1900 based
	atm.tm_isdst = -1;

    // store times based on the break of the most recent hour and day
	time_hour = mktime(&atm);
    time_day = time_hour - (atm.tm_hour * 3600);

	// if the stored structure is zeroed out, then this is the first time
	// this routine is called. Just set the date and return
	if ( pData->time_day == 0 )
		{
		pData->time_hour = time_hour;
		pData->time_day = time_day;
        fCheckBusy = FALSE;
		return;
		}

    // we only have to worry if the time has changed to a different hour
    if ( time_hour == pData->time_hour )
        {
        fCheckBusy = FALSE;
        return;
        }

    // calculate the deltas
    time_t dHour = time_hour - pData->time_hour;
        dHour /= 3600;

    time_t dDay = time_day - pData->time_day;
        dDay /= 86400;

    // lets start by saying that if they just set their clock BACK by any time
    // and it is in a different hour (don't bother with minor adjustments) then
    // we advance everything one hour. This will be most useful during dayling-savings
    // time conversions. Where did that hour of data go? Ah. it is still there.
    if ( dHour < 0 )
        dHour = 1;
    if ( dDay < 0 )
        dDay = 1;

    // if the time period has changed we need to move all the values back one.
    // do the days first
    if ( dDay > 0 )
        {
	    if ( dDay >= 7 )
		    {
		    ZeroMemory( &pData->rgbDayData, sizeof(PWS_DATA_PERIOD) * 7 );
		    }
	    else
		    {
            // move everything back by the proper amount first
            MoveMemory( &pData->rgbDayData[dDay], &pData->rgbDayData[0],
                            sizeof(PWS_DATA_PERIOD) * (7 - dDay) );
            // clear out the newly exposed periods in the front
            ZeroMemory( &pData->rgbDayData[0], sizeof(PWS_DATA_PERIOD) * dDay );
		    }
        }

    // do the hours
    if ( dHour > 0 )
        {
	    if ( dHour >= 24 )
		    {
		    ZeroMemory( &pData->rgbHourData, sizeof(PWS_DATA_PERIOD) * 24 );
		    }
	    else
		    {
            // move everything back by the proper amount first
            MoveMemory( &pData->rgbHourData[dHour], &pData->rgbHourData[0],
                            sizeof(PWS_DATA_PERIOD) * (24 - dHour) );
            // clear out the newly exposed periods in the front
            ZeroMemory( &pData->rgbHourData[0], sizeof(PWS_DATA_PERIOD) * dHour );
		    }
        }

	// update the last time
    pData->time_hour = time_hour;
    pData->time_day = time_day;
    fCheckBusy = FALSE;
	}


//-------------------------------------------------------------------------
// returns TRUE if the ip should tracked. returns FALSE if it is already there
// and should not be tracked. Note that it only watches a fixed number of IP
// addresses that is dertermined by the constant TRACK_IP_NUM
// CopyMemory version
BOOL FTrackIP( DWORD ip, time_t hour, time_t day )
    {
    DWORD   testIndex;
    BOOL    fAnswer = TRUE;

    EnterCriticalSection( &g_ip_section );

    // loop throught the tracked addresses, looking for a space
    for (testIndex = 0; testIndex < TRACK_IP_NUM; testIndex++)
        {
        if ( g_rgbIPTrack[testIndex] == ip )
		    {
            // if requested, check the hour
            if ( hour )
                fAnswer = ( hour != g_rgbIPHourTrack[testIndex] );
            else if ( day )
                fAnswer = ( day != g_rgbIPDayTrack[testIndex] );
            else
                // It has already been counted
                fAnswer = FALSE;
            goto cleanup;
		    }

        // this block only matters
        if ( g_rgbIPTrack[testIndex] == NULL )
            {
            fAnswer = TRUE;
            goto cleanup;
            }
        }

    // if we get here, then it is not one of the last TRACK_IP_NUM address.
    // Shift the array down one space and put this one in the beginning
    MoveMemory( &g_rgbIPTrack[1], &g_rgbIPTrack, sizeof(DWORD) * (TRACK_IP_NUM-1) );
    testIndex = 0;
    g_rgbIPHourTrack[testIndex] = 0;
    g_rgbIPDayTrack[testIndex] = 0;

cleanup:
    // track the values
    if ( fAnswer )
        {
        g_rgbIPTrack[testIndex] = ip;
        if ( hour )
            g_rgbIPHourTrack[testIndex] = hour;
        if ( day )
            g_rgbIPDayTrack[testIndex] = day;
        }

    // leave the section
	LeaveCriticalSection( &g_ip_section );

    // return true because we are tracking it
    return fAnswer;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\pa\raidmap.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    raidmap.cxx

Abstract:

    This module map file requests for RAID UNC shares and generates appropriate MIME 
    content-type header

Author:

    Philippe Choquier ( phillich ) 27-mar-1998

--*/

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <iisfiltp.h>
#include <inetinfo.h>
#include <w3svc.h>
#include <iiscnfgp.h>

#include <dbgutil.h>
#include <buffer.hxx>
#include <multisz.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

#if DBG
#define PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define PRINTF( x )
#endif

#if 0 && DBG
#define NOISY_PRINTF( x )     { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define NOISY_PRINTF( x )
#endif

}

DECLARE_DEBUG_PRINTS_OBJECT();

//
//  This could be to a file or other output device
//

#define DEST               __buff
#define Write( x )         {                                    \
                                char __buff[1024];              \
                                wsprintf x;                     \
                                OutputDebugString( __buff );    \
                           }

#define LockGlobals()         EnterCriticalSection( &csGlobalLock )
#define UnlockGlobals()       LeaveCriticalSection( &csGlobalLock );

//
//  Private prototypes
//

DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    );

DWORD
OnAuthentication(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_AUTHENT *  pvData
    );

DWORD
OnUrlMap(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_URL_MAP *  pvData
    );

DWORD
OnSendResponse(
    HTTP_FILTER_CONTEXT *       pfc,
    HTTP_FILTER_SEND_RESPONSE * pvData
    );

DWORD
OnLog(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    );

DWORD
OnEndOfRequest(
    HTTP_FILTER_CONTEXT *  pfc
    );

DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    );

//
//  Globals
//

IMDCOM*             g_pMDObject = NULL;
BOOL                g_fGotMimeMap = FALSE;
MULTISZ             g_mszMimeMap;
CRITICAL_SECTION    csGlobalLock;

BOOL
GetStrVariable( 
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszVariable,
    STR*                    pstr
    )
/*++

Routine Description:

    Get a http server variable in a STR

Arguments:

    pfc - filter context
    pszVariable - server variable name to access
    pstr - string updated with server variable value

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   cb;

ag:
    cb = pstr->QuerySize();

    if ( !pfc->GetServerVariable( pfc,
                                  pszVariable,
                                  pstr->QueryStr(),
                                  &cb ))
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( !pstr->Resize( cb ) )
            {
                return FALSE;
            }
            goto ag;
        }
        else
        {
            return FALSE;
        }
    }

    pstr->SetLen( strlen( pstr->QueryStr() ) );

    return TRUE;
}


BOOL
GetStrHeader( 
    HTTP_FILTER_SEND_RESPONSE *  pvData,
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   pszHeader,
    STR*                    pstr
    )
/*++

Routine Description:

    Get a http header in a STR

Arguments:

    pfc - filter context
    pszHeader - header name to access
    pstr - string updated with header value

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   cb;

ag:
    cb = pstr->QuerySize();

    if ( !pvData->GetHeader( pfc,
                             pszHeader,
                             pstr->QueryStr(),
                             &cb ))
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( !pstr->Resize( cb ) )
            {
                return FALSE;
            }
            goto ag;
        }
        else
        {
            return FALSE;
        }
    }

    pstr->SetLen( strlen( pstr->QueryStr() ) );

    return TRUE;
}

BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    )
{
    Write(( DEST,
            "Sample Filter TerminateExtension() called\n" ));

    DeleteCriticalSection( &csGlobalLock );

    DELETE_DEBUG_PRINT_OBJECT( );

    return TRUE;
}

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
    Write(( DEST,
            "[GetFilterVersion] Server filter version is %d.%d\n",
            HIWORD( pVer->dwServerFilterVersion ),
            LOWORD( pVer->dwServerFilterVersion ) ));

    pVer->dwFilterVersion = MAKELONG( 0, 4 );   // Version 4.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
                     SF_NOTIFY_NONSECURE_PORT     |

                     SF_NOTIFY_SEND_RESPONSE      |
                     SF_NOTIFY_URL_MAP            |

                     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "Raid map filter version, v1.0" );

    InitializeCriticalSection( &csGlobalLock );

    CREATE_DEBUG_PRINT_OBJECT( "RaidMap" );

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
{
    DWORD dwRet;

    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_PREPROC_HEADERS:

        dwRet = OnPreprocHeaders( pfc,
                                  (PHTTP_FILTER_PREPROC_HEADERS) pvData );
        break;

    case SF_NOTIFY_AUTHENTICATION:

        dwRet = OnAuthentication( pfc,
                                  (PHTTP_FILTER_AUTHENT) pvData );
        break;

    case SF_NOTIFY_URL_MAP:

        dwRet = OnUrlMap( pfc,
                          (PHTTP_FILTER_URL_MAP) pvData );
        break;

    case SF_NOTIFY_SEND_RESPONSE:

        dwRet = OnSendResponse( pfc,
                                (PHTTP_FILTER_SEND_RESPONSE) pvData );
        break;

    case SF_NOTIFY_LOG:

        dwRet = OnLog( pfc,
                       (PHTTP_FILTER_LOG) pvData );
        break;

    case SF_NOTIFY_END_OF_REQUEST:

        dwRet = OnEndOfRequest( pfc );
        break;

    case SF_NOTIFY_END_OF_NET_SESSION:

        dwRet = OnEndOfNetSession( pfc,
                                   (PHTTP_FILTER_LOG) pvData );

        //
        //  We would delete any allocated memory here
        //

        pfc->pFilterContext = 0;

        break;

    default:
        Write(( DEST,
                "[HttpFilterProc] Unknown notification type, %d\n",
                NotificationType ));

        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwRet;
}


DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    )
{
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnAuthentication(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_AUTHENT *  pvData
    )
{
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

LPSTR
ScanForSlashBackward(
    LPSTR   pBase,
    INT     cChars,
    INT     cSlashes
    )
{
    CHAR*   p = pBase + cChars;
    int     ch;

    while ( cChars-- )
    {
        if ( (ch = *--p) == '/' || ch == '\\' )
        {
            if ( !--cSlashes )
            {
                break;
            }
        }
    }

    return cSlashes ? NULL : p;
}


DWORD
OnUrlMap(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_URL_MAP *  pvData
    )
{
    DWORD   cbText;
    CHAR    buff[1024];
    CHAR*   p;

    Write(( DEST,
            "%d [OnUrlMap] Server is mapping url %s to path %s\n",
            pfc->pFilterContext,
            pvData->pszURL,
            pvData->pszPhysicalPath ));

    //
    // Check for query /[path]?_RAID_NAME_=[filename]
    //

    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !memcmp( buff, "_RAID_NAME_=", sizeof("_RAID_NAME_=")-1 ))
    {
        //
        // replace filename in path by filename specified in query string
        // as IIS uses the extension in the physical path to generate MIME type
        // we will have to replace Content-type HTTP header when we send the response
        //

        if ( (p = ScanForSlashBackward(pvData->pszPhysicalPath, strlen(pvData->pszPhysicalPath), 1 )) != NULL )
        {
            strcpy( p + 1, buff + sizeof("_RAID_NAME_=") - 1 );

            pfc->pFilterContext = (LPVOID)TRUE;

            return SF_STATUS_REQ_HANDLED_NOTIFICATION;
        }
    }

    pfc->pFilterContext = (LPVOID)FALSE;

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


DWORD
OnSendResponse(
    HTTP_FILTER_CONTEXT *        pfc,
    HTTP_FILTER_SEND_RESPONSE *  pvData
    )
{
    DWORD       cbText;
    CHAR        buff[1024];
    DWORD       cb;
    STACK_STR(  strUrl, 256 );
    LPSTR       pExt;
    LPSTR       pUrlExt = NULL;
    int         l;
    int         cUrlExt;
    int         cExt;

    //
    // replace MIME type only if success
    //

    if ( (pvData->HttpStatus == 200 || pvData->HttpStatus == 304) &&
         pfc->pFilterContext == (LPVOID)TRUE )
    {
        Write(( DEST,
                "%d [OnSendReponse] Status code = %d\n",
                pfc->pFilterContext,
                pvData->HttpStatus ));

        //
        // as IIS uses the extension in the physical path to generate MIME type
        // we will have to replace Content-type HTTP header when we send the response
        // we must parse extension in URL to generate correct MIME type
        //

        if ( !GetStrVariable( pfc, "URL", &strUrl ) )
        {
            return SF_STATUS_REQ_ERROR;
        }

        Write(( DEST,
                "%d [OnSendReponse] url = \"%s\"\n",
                pfc->pFilterContext,
                strUrl.QueryStr() ));

        //
        // look for extension
        //

        for ( l = strUrl.QueryCCH() ; l ;)
        {
            if ( strUrl.QueryStr()[--l] == '.' )
            {
                pUrlExt = strUrl.QueryStr()+l;
                break;
            }
        }

        if ( pUrlExt == NULL )
        {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
        }

        LockGlobals();

        if ( !g_fGotMimeMap )
        {
            // get Metabase Interface

            if ( !pfc->ServerSupportFunction( pfc,
                                        SF_REQ_GET_PROPERTY,
                                        (IMDCOM*)&g_pMDObject,
                                        (UINT)SF_PROPERTY_MD_IF,
                                        NULL ) )
            {
                UnlockGlobals();
                return SF_STATUS_REQ_ERROR;
            }

            //
            // read mimemap from metabase. value will be static, i.e. we don't pick up
            // dynamic change to metabase while IIS is running.
            //

            MB                mb( g_pMDObject );

            if ( !mb.Open( "/LM/MimeMap" ) ||
                 !mb.GetMultisz( "",
                                 MD_MIME_MAP,
                                 IIS_MD_UT_FILE,
                                 &g_mszMimeMap ) )
            {
                UnlockGlobals();
                mb.Close();
                return SF_STATUS_REQ_ERROR;
            }

            mb.Close();
            g_fGotMimeMap = TRUE;
        }

        UnlockGlobals();

        //
        // look for know extension
        //

        cUrlExt = strlen( pUrlExt );
        for ( pExt = (LPSTR)g_mszMimeMap.First() ; pExt ; pExt = (LPSTR)g_mszMimeMap.Next( pExt ) )
        {
            if ( !_memicmp( pUrlExt, pExt, cUrlExt ) && 
                 pExt[cUrlExt]==',' )
            {
                pvData->SetHeader( pfc,
                                   "Content-Type:",
                                   pExt + cUrlExt + 1 );
                break;
            }
        }
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

}

DWORD
OnLog(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    )
{
    Write(( DEST,
            "%d [OnLog] About to log: Operation = %s, Target = %s\n",
            pfc->pFilterContext,
            pvData->pszOperation,
            pvData->pszTarget ));

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnEndOfRequest(
    HTTP_FILTER_CONTEXT *  pfc
    )
{
    DWORD cbText;

    Write(( DEST,
            "%d [OnEndOfRequest] Notification\n",
            pfc->pFilterContext ));

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    )
{
    Write(( DEST,
            "%d [OnEndOfNetSession] End of request indicated\n",
            pfc->pFilterContext ));

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\filters\sample\sampfilt.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sampfilt.c

Abstract:

    This module is an example of the Microsoft HTTP server filter interface

Author:

    John Ludeman (johnl)   13-Oct-1995

Revision History:
--*/

#include <windows.h>
//#include <httpfilt.h>
#include <iisfilt.h>
#include <stdlib.h>

//
//  This could be to a file or other output device
//

#define DEST               __buff
#define Write( x )         {                                    \
                                char __buff[1024];              \
                                wsprintf x;                     \
                                OutputDebugString( __buff );    \
                           }

#define EOR_TEXT "<b>This is a footer for an End Of Request</b>"

//
//  Private prototypes
//

DWORD
OnReadRaw(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA * pvData
    );

DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    );

DWORD
OnAuthentication(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_AUTHENT *  pvData
    );

DWORD
OnUrlMap(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_URL_MAP *  pvData
    );

DWORD
OnAccessDenied(
    HTTP_FILTER_CONTEXT * pfc,
    HTTP_FILTER_ACCESS_DENIED * pvData
    );

DWORD
OnSendResponse(
    HTTP_FILTER_CONTEXT *       pfc,
    HTTP_FILTER_SEND_RESPONSE * pvData
    );

DWORD
OnSendRawData(
    HTTP_FILTER_CONTEXT *   pfc,
    HTTP_FILTER_RAW_DATA *  pvData
    );

DWORD
OnLog(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    );

DWORD
OnEndOfRequest(
    HTTP_FILTER_CONTEXT *  pfc
    );

DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    );

DWORD
SendDenyMessage(
    HTTP_FILTER_CONTEXT * pfc
    );

//
//  Globals
//

//
//  Pseudo context for tracking individual request threads
//

DWORD ReqNumber = 1000;

BOOL
WINAPI
TerminateFilter(
    DWORD dwFlags
    )
{
    Write(( DEST,
            "Sample Filter TerminateExtension() called\n" ));

    return TRUE;
}

BOOL
WINAPI
GetFilterVersion(
    HTTP_FILTER_VERSION * pVer
    )
{
    Write(( DEST,
            "[GetFilterVersion] Server filter version is %d.%d\n",
            HIWORD( pVer->dwServerFilterVersion ),
            LOWORD( pVer->dwServerFilterVersion ) ));

    pVer->dwFilterVersion = MAKELONG( 0, 4 );   // Version 4.0

    //
    //  Specify the types and order of notification
    //

    pVer->dwFlags = (SF_NOTIFY_SECURE_PORT        |
                     SF_NOTIFY_NONSECURE_PORT     |

                     SF_NOTIFY_READ_RAW_DATA      |
                     SF_NOTIFY_PREPROC_HEADERS    |
                     SF_NOTIFY_AUTHENTICATION     |
                     SF_NOTIFY_URL_MAP            |
                     SF_NOTIFY_ACCESS_DENIED      |
                     SF_NOTIFY_SEND_RESPONSE      |
                     //SF_NOTIFY_SEND_RAW_DATA      |
                     SF_NOTIFY_END_OF_REQUEST     |
                     SF_NOTIFY_LOG                |
                     SF_NOTIFY_END_OF_NET_SESSION |

                     SF_NOTIFY_ORDER_DEFAULT);

    strcpy( pVer->lpszFilterDesc, "Sampler filter version, v1.0" );

    return TRUE;
}

DWORD
WINAPI
HttpFilterProc(
    HTTP_FILTER_CONTEXT *      pfc,
    DWORD                      NotificationType,
    VOID *                     pvData )
{
    DWORD dwRet;

    //
    //  If we don't have a context already, create one now
    //

    if ( !pfc->pFilterContext )
    {
        CHAR buff[512];
        DWORD cbText;

        pfc->pFilterContext = (VOID *) ReqNumber++;

        Write(( DEST,
                "[HttpFilterProc] New request, ID = %d, fIsSecurePort = %s\n",
                pfc->pFilterContext,
                (pfc->fIsSecurePort ? "TRUE" : "FALSE") ));

        //
        //  Get non-existent variable
        //

        cbText = sizeof( buff );
        if ( pfc->GetServerVariable( pfc,
                                     "Non-existent_variable",
                                     buff,
                                     &cbText ))
        {
            Write(( DEST,
                    "Hey! This should have returned FALSE!!\n" ));
        }
        else if ( GetLastError() != ERROR_INVALID_INDEX )
        {
            Write(( DEST,
                    "Hey! This should have returned ERROR_INVALID_INDEX!!\n" ));
        }
    }

    //
    //  Indicate this notification to the appropriate routine
    //

    switch ( NotificationType )
    {
    case SF_NOTIFY_READ_RAW_DATA:

        dwRet = OnReadRaw( pfc,
                           (PHTTP_FILTER_RAW_DATA) pvData );
        break;

    case SF_NOTIFY_PREPROC_HEADERS:

        dwRet = OnPreprocHeaders( pfc,
                                  (PHTTP_FILTER_PREPROC_HEADERS) pvData );
        break;

    case SF_NOTIFY_AUTHENTICATION:

        dwRet = OnAuthentication( pfc,
                                  (PHTTP_FILTER_AUTHENT) pvData );
        break;

    case SF_NOTIFY_URL_MAP:

        dwRet = OnUrlMap( pfc,
                          (PHTTP_FILTER_URL_MAP) pvData );
        break;

    case SF_NOTIFY_ACCESS_DENIED:
        dwRet = OnAccessDenied( pfc,
                                (PHTTP_FILTER_ACCESS_DENIED ) pvData );
        break;

    case SF_NOTIFY_SEND_RESPONSE:

        dwRet = OnSendResponse( pfc,
                                (PHTTP_FILTER_SEND_RESPONSE) pvData );
        break;

    case SF_NOTIFY_SEND_RAW_DATA:

        dwRet = OnSendRawData( pfc,
                               (PHTTP_FILTER_RAW_DATA) pvData );
        break;

    case SF_NOTIFY_LOG:

        dwRet = OnLog( pfc,
                       (PHTTP_FILTER_LOG) pvData );
        break;

    case SF_NOTIFY_END_OF_REQUEST:

        dwRet = OnEndOfRequest( pfc );
        break;

    case SF_NOTIFY_END_OF_NET_SESSION:

        dwRet = OnEndOfNetSession( pfc,
                                   (PHTTP_FILTER_LOG) pvData );

        //
        //  We would delete any allocated memory here
        //

        pfc->pFilterContext = 0;

        break;

    default:
        Write(( DEST,
                "[HttpFilterProc] Unknown notification type, %d\n",
                NotificationType ));

        dwRet = SF_STATUS_REQ_NEXT_NOTIFICATION;
        break;
    }

    return dwRet;
}


DWORD
OnReadRaw(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA * pvData
    )
{
    DWORD cbText;
    CHAR  buff[1024];

    //
    //  Show the first 3 bytes of raw data
    //

    Write(( DEST,

            "%d [OnReadRaw] %d bytes indicated, first 3 bytes: %c%c%c\n",
            pfc->pFilterContext,
            pvData->cbInData,
            ((BYTE *) pvData->pvInData)[0],
            ((BYTE *) pvData->pvInData)[1],
            ((BYTE *) pvData->pvInData)[2] ));

    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_READRAW" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnPreprocHeaders(
    HTTP_FILTER_CONTEXT *         pfc,
    HTTP_FILTER_PREPROC_HEADERS * pvData
    )
{
    CHAR  achUrl[512];
    CHAR  achUserAgent[512];
    DWORD cb;
    DWORD cbText;
    CHAR  buff[1024];

    //
    //  Get the url and user agent fields
    //

    cb = sizeof( achUrl );

    if ( !pvData->GetHeader( pfc,
                             "url",
                             achUrl,
                             &cb ))
    {
        return SF_STATUS_REQ_ERROR;
    }

    cb = sizeof( achUserAgent );

    if ( !pvData->GetHeader( pfc,
                             "User-Agent:",
                             achUserAgent,
                             &cb ))
    {
        strcpy( achUserAgent, "<None>" );
    }


    Write(( DEST,
            "%d [OnPreprocHeaders] url = %s, User-Agent = %s\n",
            pfc->pFilterContext,
            achUrl,
            achUserAgent ));

    //
    //  Add our special "Foobar:" header for the *server* to process
    //

    if ( !pvData->AddHeader( pfc,
                             "Foobar:",
                             "Special foobar header for server to process" ))
    {
        return SF_STATUS_REQ_ERROR;
    }

    //
    //  Add a header that will be sent back to the *client*.  This could be
    //  a special cookie header or something specific for the client
    //

    if ( !pfc->AddResponseHeaders( pfc,
                                   "Special-Cookie-Header: xyz\r\n",
                                   0 ))
    {
        return SF_STATUS_REQ_ERROR;
    }

    if ( strstr( achUrl, "DENY_PREPROC" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnAuthentication(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_AUTHENT *  pvData
    )
{
    DWORD cbText;
    CHAR  buff[1024];

    Write(( DEST,
            "%d [OnAuthentication] User %s is about to logon\n",
            pfc->pFilterContext,
            (*pvData->pszUser ? pvData->pszUser : "<Anonymous>" ) ));

    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_AUTH" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnUrlMap(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_URL_MAP *  pvData
    )
{
    DWORD cbText;
    CHAR  buff[1024];

    Write(( DEST,
            "%d [OnUrlMap] Server is mapping url %s to path %s\n",
            pfc->pFilterContext,
            pvData->pszURL,
            pvData->pszPhysicalPath ));


    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_URLMAP" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

}

DWORD
OnAccessDenied(
    HTTP_FILTER_CONTEXT       *  pfc,
    HTTP_FILTER_ACCESS_DENIED *  pvData
    )
{
    DWORD cbText;
    CHAR  buff[1024];

    Write(( DEST,
            "%d [OnAccessDenied] url = %s physical path = %s reason = 0x%lx\n",
            pfc->pFilterContext,
            pvData->pszURL,
            pvData->pszPhysicalPath,
            pvData->dwReason ));

    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_ACCESSDENIED" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

}

DWORD
OnSendResponse(
    HTTP_FILTER_CONTEXT *        pfc,
    HTTP_FILTER_SEND_RESPONSE *  pvData
    )
{
    DWORD cbText;
    CHAR  buff[1024];
    DWORD cb;

    Write(( DEST,
            "%d [OnSendReponse] Status code = %d\n",
            pfc->pFilterContext,
            pvData->HttpStatus ));

    cbText = sizeof( buff );
    *buff = '\0';
    pvData->GetHeader( pfc,
                       "status",
                       buff,
                       &cbText );

    Write(( DEST,
            "%d [OnSendReponse] Status line = \"%s\"\n",
            pfc->pFilterContext,
            buff ));

    cbText = sizeof( buff );
    *buff = '\0';
    pvData->GetHeader( pfc,
                       "Content-Length:",
                       buff,
                       &cbText );

    Write(( DEST,
            "%d [OnSendReponse] Content-Length = \"%s\"\n",
            pfc->pFilterContext,
            buff ));

#if 1
    cb = atoi( buff );
    cb += sizeof(EOR_TEXT) - sizeof(CHAR);

    wsprintf( buff, "%d", cb );

    pvData->SetHeader( pfc,
                       "Content-Length:",
                       buff );
#endif

    //
    //  Try and set a non-existant header
    //

    pvData->SetHeader( pfc,
                       "Foo-Header:",
                       NULL );

    cbText = sizeof( buff );
    *buff = '\0';
    pvData->GetHeader( pfc,
                       "Content-Type:",
                       buff,
                       &cbText );

    Write(( DEST,
            "%d [OnSendReponse] Content-Type = \"%s\"\n",
            pfc->pFilterContext,
            buff ));

    pvData->AddHeader( pfc,
                       "My-Funky-Header:",
                       "My funky header value" );

    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_ACCESSDENIED" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;

}

DWORD
OnSendRawData(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_RAW_DATA *  pvData
    )
{
    DWORD cbText;
    CHAR  buff[1024];
    DWORD cb;
    BYTE  ch;

    //
    //  Show the first 3 bytes of raw data
    //

#define PRINT_SIZE 150

    __try {
        if ( pvData->cbInData > PRINT_SIZE )
        {
            cb = PRINT_SIZE;
        }
        else
        {
            cb = pvData->cbInData - 1;
        }

        ch = ((BYTE *) pvData->pvInData)[cb];
        ((BYTE *) pvData->pvInData)[cb] = '\0';

        Write(( DEST,
                "%d [OnSendRaw] %d bytes to send, first %d bytes: \n===============================\n%s\n===============================\n",
                pfc->pFilterContext,
                pvData->cbInData,
                cb,
                ((BYTE *) pvData->pvInData) ));

        ((BYTE *) pvData->pvInData)[cb] = ch;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        Write(( DEST,
                "%d [OnSendRaw] Exception occurred modifying buffer",
                pfc->pFilterContext ));
    }


    cbText = sizeof( buff );
    pfc->GetServerVariable( pfc,
                            "QUERY_STRING",
                            buff,
                            &cbText );

    if ( !_stricmp( buff, "DENY_SENDRAW" ))
    {
        return SendDenyMessage( pfc );
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnLog(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    )
{
    Write(( DEST,
            "%d [OnLog] About to log: Operation = %s, Target = %s\n",
            pfc->pFilterContext,
            pvData->pszOperation,
            pvData->pszTarget ));

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnEndOfRequest(
    HTTP_FILTER_CONTEXT *  pfc
    )
{
    DWORD cbText;

    Write(( DEST,
            "%d [OnEndOfRequest] Notification\n",
            pfc->pFilterContext ));

    cbText = sizeof( EOR_TEXT ) - sizeof(CHAR);


    pfc->WriteClient( pfc,
                      EOR_TEXT,
                      &cbText,
                      0 );


    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

DWORD
OnEndOfNetSession(
    HTTP_FILTER_CONTEXT *  pfc,
    HTTP_FILTER_LOG *      pvData
    )
{
    Write(( DEST,
            "%d [OnEndOfNetSession] End of request indicated\n",
            pfc->pFilterContext ));

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}


DWORD
SendDenyMessage(
    HTTP_FILTER_CONTEXT * pfc
    )
{
    DWORD cbText;

#define MESSAGE_TEXT    "I'm Terribly sorry but you have been denied access"

    pfc->ServerSupportFunction( pfc,
                                SF_REQ_SEND_RESPONSE_HEADER,
                                "401 Access Denied",
                                (ULONG_PTR) "WWW-Authenticate: Basic\r\n"
                                MESSAGE_TEXT,
                                0 );

    cbText = sizeof(MESSAGE_TEXT) - sizeof(CHAR);

    pfc->WriteClient( pfc,
                      MESSAGE_TEXT,
                      &cbText,
                      0 );

    return SF_STATUS_REQ_FINISHED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\binsrv\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    30-Oct-1996

   Project:
       Binary object File ISAPI application

--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable
// begin_user_unmodifiable


# if DBG 

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>

/***********************************************************
 *    Macros
 ************************************************************/


extern   DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable


# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;


//                                      
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugString( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject 
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__ 



# define DBG_CODE(s)          s          /* echoes code in debugging mode */


# define DBG_ASSERT( exp)    if ( !(exp)) { \
                                 PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); \
                             } else {}

# define DBG_ASSERT_MSG( exp, pszMsg)    \
                             if ( !(exp)) { \
                                  PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                              } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list);
//
# define DBGPRINTF( args)     PuDbgPrint args

# define DBGDUMP( args)       PuDbgDump  args

# else // DBG


# define DECLARE_DEBUG_PRINTS_OBJECT()           /* Do Nothing */
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)    /* Do Nothing */
# define DELETE_DEBUG_PRINT_OBJECT( )            /* Do Nothing */
# define VALID_DEBUG_PRINT_OBJECT()              ( TRUE)

# define DBG_CODE(s)                             /* Do Nothing */

# define DBG_ASSERT(exp)                         /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGPRINTF( args)                        /* Do Nothing */

# define DBGDUMP( args)                          /* Do nothing */

# define DBG_LOG()                               /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    /* Do Nothing */

# endif // DBG


// end_user_modifiable
// begin_user_unmodifiable


#ifdef ASSERT 
# undef ASSERT
#endif


# define ASSERT( exp)           DBG_ASSERT( exp)


//
//  Define the debugging constants 
// 

# define DEBUG_API_ENTRY                    0x00000001
# define DEBUG_API_EXIT                     0x00000002
# define DEBUG_ERROR                        0x00000008


# if DBG 

extern     DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
               g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS()) 


# else   // DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
               g_dwDebugFlags = (dwDefault)

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0) 

# endif // DBG


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ftrans\ftrans.c ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    ftrans.c

Abstract:

    This module demonstrates a simple file transfer using ISAPI application
      using the Async TransmitFile support with callback.

Author:

    Murali R. Krishnan ( MuraliK )   26-Apr-1996

Revision History:
--*/

#include <windows.h>
#include <iisext.h>

# include <openf.h>

/************************************************************
 *  Global Data
 ************************************************************/

LIST_ENTRY g_lWorkItems;
CRITICAL_SECTION g_csWorkItems;

# define USE_WORK_QUEUE   (0)

DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile);

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb,
              IN HANDLE hFile, 
              IN LPCSTR pszFile);




/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( " Initializing the global data for ftrans.dll\n");

          //
          // Initialize various data and modules.
          //
          InitializeCriticalSection(&g_csWorkItems);
          InitializeListHead( &g_lWorkItems);
          InitFileHandleCache();

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          CleanupFileHandleCache();
          if ( lpvContext != NULL) {

              DeleteCriticalSection(&g_csWorkItems);
          }

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return ( fReturn);
}  /* DllLibMain() */




DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
/*++

 Routine Description:

   This function performs the necessary action to send response for the 
    request received from the client. It picks up the name of a file from
    the pecb->lpszQueryString and transmits that file to the client.

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.

 Return Value:

    Returns HSE_* status codes
--*/
{
    DWORD hseStatus;

    
    if ( pecb->lpszQueryString == NULL ||
        *pecb->lpszQueryString == '\0' 
        ) {
        
        hseStatus = SendHeaderToClient( pecb, "File Not Specified");
    } else {

        hseStatus = SendFileToClient( pecb, pecb->lpszQueryString);
    }
    
    return ( hseStatus);
    
} // HttpExtensionProc()





BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
           "File Transfer using TransmitFile" );
    
    return TRUE;
}



BOOL WINAPI
TerminateExtension(
    DWORD dwFlags
    )
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - specifies whether the DLL can refuse to unload or not
    
Returns:
    
    TRUE, if the DLL can be unloaded
    
--*/
{
    return TRUE;
}



DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg)
{
    
    CHAR buff[600];
    
    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //
    
    wsprintf( buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Simple File Transfer</title></head>\n"
             "<body><h1>%s</h1>\n"
             ,
             pszErrorMsg );
    
    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                      HSE_REQ_SEND_RESPONSE_HEADER,
                                      "200 OK",
                                      NULL,
                                      (LPDWORD) buff )
        ) {
        
        return HSE_STATUS_ERROR;
    }
    
    return ( HSE_STATUS_SUCCESS);
} // SendHeaderToClient()
    


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile)
{
    CHAR    pchBuffer[1024];
    HANDLE  hFile;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    hFile = FcOpenFile( pecb, pszFile);

    if ( hFile == INVALID_HANDLE_VALUE) {


        wsprintfA( pchBuffer, 
                  "OpenFailed: Error (%d) while opening the file %s.\n",
                  GetLastError(), pszFile);

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

    } else {

#if SEPARATE_HEADERS
        hseStatus = SendHeaderToClient( pecb, "File Transfer begins");
#else 
        hseStatus = HSE_STATUS_SUCCESS;
#endif

        if ( hseStatus == HSE_STATUS_SUCCESS) {

            hseStatus = SendFileOver( pecb, hFile, pszFile);
            
            if ( hseStatus != HSE_STATUS_PENDING) {

                //
                // assume that the data is transmitted.
                //
                
                if ( hseStatus != HSE_STATUS_SUCCESS) {
                    
                    //
                    // Error in transmitting the file. Send error message.
                    //
                    
                    wsprintfA( pchBuffer, 
                              "Send Failed: Error (%d) for file %s.\n",
                              GetLastError(), pszFile);
                    
                    SendHeaderToClient( pecb, pchBuffer);
                }
            }
        }

        if ( hseStatus != HSE_STATUS_PENDING) {
              
            //
            // file handle is closed for all non-pending cases
            // if the status is pending, file handle is cleaned up in callback
            //
            FcCloseFile( hFile);
        }
    }
    
    return (hseStatus);

} // SendFileToClient()




# define MAX_BUFFER_SIZE  (400)

typedef struct _AIO_WORK_ITEM {
    
    LIST_ENTRY    listEntry;
    EXTENSION_CONTROL_BLOCK * pecb;
    HSE_TF_INFO   hseTf;
    CHAR          pchBuffer[ MAX_BUFFER_SIZE ];

}  AIO_WORK_ITEM, * PAWI;




VOID
CleanupAW( IN PAWI paw, IN BOOL fDoneWithSession)
{

    DWORD err = GetLastError();

    if ( paw->hseTf.hFile != INVALID_HANDLE_VALUE) { 
     
        FcCloseFile( paw->hseTf.hFile);
    }
    
    if (fDoneWithSession) {

        paw->pecb->ServerSupportFunction( paw->pecb->ConnID,
                                         HSE_REQ_DONE_WITH_SESSION,
                                         NULL, NULL, NULL);
    }
    SetLastError( err);

    //
    // Remove from work items list
    // 
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    RemoveEntryList( &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
# endif 

    LocalFree( paw);
    return;

} // CleanupAW()




VOID WINAPI
HseIoCompletion(
                IN EXTENSION_CONTROL_BLOCK * pECB, 
                IN PVOID    pContext,
                IN DWORD    cbIO,
                IN DWORD    dwError
                )
/*++

 Routine Description:

   This is the callback function for handling completions of asynchronous IO.
   This function performs necessary cleanup and resubmits additional IO
    (if required). In this case, this function is called at the end of a 
    successful TransmitFile() operation. This function primarily cleans up
    the data and worker queue item and exits.

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.
   pContext      context information supplied with the asynchronous IO call.
   cbIO          count of bytes of IO in the last call.
   dwError       Error if any, for the last IO operation.

 Return Value:

   None.
--*/
{
    PAWI    paw = (PAWI ) pContext;
    EXTENSION_CONTROL_BLOCK   * pecb = paw->pecb;

    
    // assert( pecb == paw->pecb);

    //
    // 1. if no errors, we are done transmitting the file
    // 2. cleanup and exit
    //

    
    //
    // Do Cleanup
    //
    
    CleanupAW( paw, TRUE);


    return;

} // HseIoCompletion()




DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb,
              IN HANDLE hFile, 
              IN LPCSTR pszFile)
{

    PAWI   paw;
    DWORD  hseStatus = HSE_STATUS_PENDING;

    paw  = (PAWI ) LocalAlloc( LMEM_FIXED, sizeof(AIO_WORK_ITEM));
    if ( paw == NULL) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }

    //
    // Fill in all the data in AIO_WORK_ITEM
    //
    paw->pecb = pecb;
    InitializeListHead( &paw->listEntry);

    paw->hseTf.pfnHseIO = HseIoCompletion;
    paw->hseTf.pContext = paw;
#if SEPARATE_HEADERS

	//
	// Headers will be send synchronously by ServerSupportFunction
	//

    paw->hseTf.dwFlags  = (HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND);
#else

	//
	// Headers will be sent asynchronously with the TransmitFile data
	//

    paw->hseTf.dwFlags  = (HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND | HSE_IO_SEND_HEADERS);
#endif

    paw->hseTf.hFile    = hFile;
    paw->hseTf.BytesToWrite = GetFileSize(hFile, NULL);
    paw->hseTf.Offset   = 0;
    paw->hseTf.pTail    = NULL;
    paw->hseTf.TailLength = 0;


    //
    //  Set up the header to be sentout for the file
    //
#if SEPARATE_HEADERS

	//
	// Don't do anything here.  The SendHeaderToClient function will
	// take care of using ServerSupportFunction to send the headers.
	//

    paw->hseTf.HeadLength = 0;
    paw->hseTf.pHead    = NULL;

#else 

	//
	// Set up the necessary members of the HSE_TF_INFO structure to
	// have it send the necessary headers.
	//

	paw->hseTf.pszStatusCode = "200 OK";

	paw->hseTf.HeadLength =
		wsprintfA ( paw->pchBuffer,
			"Content-type: text/html\r\n\r\n"
			"<head><title>Simple File Transfer (TransmitFile) "
			"</title></head>\n"
			"<h1> Transferred file contains...</h1>\n");

	paw->hseTf.pHead = paw->pchBuffer;

# endif 
    
    // Add to the list
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    InsertTailList( &g_lWorkItems,  &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
#endif 

    //
    // Setup the Async TransmitFile
    //

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_TRANSMIT_FILE,
                                       &paw->hseTf,
                                       NULL,
                                       NULL)
        ) {

        //
        // Do cleanup and return error
        //

        // File handle will be freed by the caller for errors
        paw->hseTf.hFile = INVALID_HANDLE_VALUE;

        CleanupAW( paw, FALSE);
        hseStatus =  HSE_STATUS_ERROR;
    }

    return (hseStatus);

} // SendFileOver()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ftrans\openf.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
     
     openf.h

   Abstract:

     This module defines functions for opening and closing files
      and provides transparent caching for file handles

   Author:

       Murali R. Krishnan    ( MuraliK )    30-Apr-1996

   Environment:

   Project:
   
       Internet Server DLL

   Revision History:

--*/

# ifndef _OPENF_HXX_
# define _OPENF_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <iisext.h>

/************************************************************
 *   Type Definitions  
 ************************************************************/

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

// typedef struct _LIST_ENTRY {
//   struct _LIST_ENTRY * volatile Flink;
//   struct _LIST_ENTRY * volatile Blink;
// } LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
{RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
{RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
                            }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
                                    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
                                    }


/************************************************************
 *   Function Definitions  
 ************************************************************/


//
// Initialization and cleanup functions
//

DWORD  InitFileHandleCache(VOID);
DWORD  CleanupFileHandleCache(VOID);

HANDLE  FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile);
DWORD   FcCloseFile(IN HANDLE hFile);

BOOL
FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               );


# endif // _OPENF_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\fwrite\fwrite.c ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    fwrite.c

Abstract:

    This module demonstrates a simple file transfer using ISAPI application
      using the WriteClient() callback.

Author:

    Murali R. Krishnan ( MuraliK )   25-Apr-1996

Revision History:
--*/

#include <windows.h>
#include <iisext.h>
#include <dbgutil.h>
# include "openf.h"


DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile);

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile);





BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( " Initializing the global data for fwrite.dll\n");

          //
          // Initialize various data and modules.
          //
          fReturn = (InitFileHandleCache() == NO_ERROR);

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          CleanupFileHandleCache();

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return ( fReturn);
}  /* DllLibMain() */




DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    DWORD hseStatus;


    if ( pecb->lpszQueryString == NULL) {

        hseStatus = SendHeaderToClient( pecb, "File Not Found");
    } else {

        hseStatus = SendFileToClient( pecb, pecb->lpszQueryString);
    }

    return ( hseStatus);

} // HttpExtensionProc()





BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
           "File Transfer using WriteClient" );

    return TRUE;
}


BOOL
TerminateExtension(
    DWORD dwFlags
    )
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - specifies whether the DLL can refuse to unload or not
    
Returns:
    
    TRUE, if the DLL can be unloaded
    
--*/
{
    return TRUE;
}




DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg)
{

    CHAR buff[600];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Simple File Transfer (Write) </title></head>\n"
             "<body><h1>%s</h1>\n"
             ,
             pszErrorMsg );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                      HSE_REQ_SEND_RESPONSE_HEADER,
                                      "200 OK",
                                      NULL,
                                      (LPDWORD) buff )
        ) {

        return HSE_STATUS_ERROR;
    }

    return ( HSE_STATUS_SUCCESS);
} // SendHeaderToClient()



DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile)
{
    CHAR    pchBuffer[1024];
    HANDLE  hFile;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    hFile = FcOpenFile( pecb, pszFile);

    if ( hFile == INVALID_HANDLE_VALUE) {


        wsprintfA( pchBuffer,
                  "OpenFailed: Error (%d) while opening the file %s.\n",
                  GetLastError(), pszFile);

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

    } else {

        wsprintfA( pchBuffer, " Transferred file contains...");

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

        if ( hseStatus == HSE_STATUS_SUCCESS) {

            hseStatus = SendFileOver( pecb, hFile);

            if ( hseStatus != HSE_STATUS_PENDING) {

                if ( hseStatus != HSE_STATUS_SUCCESS) {

                    //
                    // Error in transmitting the file. Send error message.
                    //

                    wsprintfA( pchBuffer,
                              "Send Failed: Error (%d) for file %s.\n",
                              GetLastError(), pszFile);

                    SendHeaderToClient( pecb, pchBuffer);
                }
            }

            if ( hseStatus != HSE_STATUS_PENDING) {

                //
                // assume that the data is transmitted.
                //

                // close file handle
                FcCloseFile( hFile);
            }
        }
    }

    return (hseStatus);

} // SendFileToClient()




# define MAX_BUFFER_SIZE  (4096)

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile)
{
    CHAR  pchBuffer[MAX_BUFFER_SIZE];
    DWORD dwBytesInFile = GetFileSize(hFile, NULL);
    DWORD nRead = 0;
    DWORD hseStatus = HSE_STATUS_SUCCESS;
    OVERLAPPED  ov;

    //
    // Send the whole file.
    //

    //
    // Loop thru reading the file and transmitting it to client
    //


    memset(&ov, 0, sizeof(OVERLAPPED));

    ov.OffsetHigh = 0;
    ov.Offset = 0;
    ov.hEvent = IIS_CREATE_EVENT(
                    "OVERLAPPED::hEvent",
                    &ov,
                    TRUE,
                    FALSE
                    );

    if ( ov.hEvent == NULL) {

        return (HSE_STATUS_ERROR);
    }

    do {

        nRead = 0;

        // read data from the file
        if (!FcReadFromFile( hFile, pchBuffer, MAX_BUFFER_SIZE, &nRead,
                           &ov)
            ) {

            hseStatus = ((GetLastError() == ERROR_HANDLE_EOF) ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);
            break;
        }

        // write data to client

        if ( !pecb->WriteClient( pecb->ConnID,
                                 pchBuffer, &nRead,
                                0)
            ) {

            hseStatus = HSE_STATUS_ERROR;
            break;
        }

    } while (TRUE);

    if ( ov.hEvent != NULL) {

        DWORD err;
        err = GetLastError();
        CloseHandle( ov.hEvent);
        ov.hEvent = NULL;
        SetLastError( err);
    }

    return (hseStatus);

} // SendFileOver()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ftrans\openf.c ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      openf.c

   Abstract:

      This module implements a simple open file handle cache

   Author:

       Murali R. Krishnan    ( MuraliK )     30-Apr-1996 

   Environment:
    
       User Mode - Win32

   Project:

       Internet Server DLL

   Functions Exported:



   Note:
      THIS IS NOT ROBUST for REAL WORLD.
      I wrote this for testing the ISAPI Async IO processing.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "openf.h"

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "dbgutil.h"

#include <initguid.h>
DEFINE_GUID(IisFtransGuid, 
0x784d8935, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);


/************************************************************
 *     Type definitions and Globals
 ************************************************************/

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

//
// internal data structure for maintaining the list of open file handles.
//

typedef struct _OPEN_FILE {
    
    HANDLE  hFile;
    struct _OPEN_FILE * pNext;
    LONG    nHits;
    LONG    nRefs;
    CHAR    rgchFile[MAX_PATH+1];

} OPEN_FILE, * LPOPEN_FILE;


LPOPEN_FILE g_pOpenFiles = NULL;
CRITICAL_SECTION g_csOpenFiles;

//
// Set up global variables containing the flags for CreateFile
//  The flags can be masked for Windows 95 system
//

DWORD  g_dwCreateFileShareMode = 
         (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);

DWORD  g_dwCreateFileFlags = 
         (FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED);

/************************************************************
 *    Functions 
 ************************************************************/


DWORD
InitFileHandleCache(VOID)
/*++

  This function initializes the file handle cache.
  It should be called at the initialization time.

  Arguments:
    None
  
  Returns:
    Win32 error code. NO_ERROR indicates that the call succeeded.
--*/
{
    
#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "TEST_ISAPI-openf");
#else
    CREATE_DEBUG_PRINT_OBJECT( "TEST_ISAPI-openf", IisFtransGuid);
#endif
    if ( !VALID_DEBUG_PRINT_OBJECT()) {
        
        return ( GetLastError());
    }

    INITIALIZE_CRITICAL_SECTION( &g_csOpenFiles);

#ifdef _NO_TRACING_
    SET_DEBUG_FLAGS(DEBUG_ERROR);
#endif
    INITIALIZE_PLATFORM_TYPE();
    DBG_ASSERT( IISIsValidPlatform());

    if ( TsIsWindows95()) {

        //
        // Reset the flags appropriately so that Windows 95 will be happy
        //

        g_dwCreateFileShareMode = (FILE_SHARE_READ | FILE_SHARE_WRITE);
        g_dwCreateFileFlags     = (FILE_FLAG_SEQUENTIAL_SCAN);
    }

    return (NO_ERROR);

} // InitFileHandleCache()




DWORD
CleanupFileHandleCache(VOID)
{
    LPOPEN_FILE  pFileScan;

    while ( g_pOpenFiles != NULL) {

        pFileScan = g_pOpenFiles;
        g_pOpenFiles = g_pOpenFiles->pNext;

        if ( pFileScan->hFile != INVALID_HANDLE_VALUE) {

            CloseHandle( pFileScan->hFile);
        }

        LocalFree( pFileScan);
    }

    DeleteCriticalSection( &g_csOpenFiles);

    DELETE_DEBUG_PRINT_OBJECT();

    return (NO_ERROR);
} // CleanupFileHandleCache()




HANDLE
FcOpenFile(IN EXTENSION_CONTROL_BLOCK * pecb, IN LPCSTR pszFile)
/*++

 FcOpenFile()
 
 Description:
   This function opens the file specified in the 'pszFile'. 
   If the file name starts with a '/' we use the ECB to map 
   the given path into a physical file path.

 Arguments:
  pecb - pointer to the ECB block
  pszFile - pointer to file name

 Returns:
   valid File handle on success
--*/
{
    LPOPEN_FILE  pFileScan;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    EnterCriticalSection( &g_csOpenFiles);

    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( 0 == lstrcmpi( pFileScan->rgchFile, pszFile)) {

            //
            //  there is a file match. 
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {

        //
        // File was not found. Create a new file handle
        //

        CHAR   rgchFileName[ MAX_PATH]; // local copy
        LPCSTR pszInputPath = pszFile;
        
        lstrcpyn( rgchFileName, pszFile, MAX_PATH);
        if ( *pszFile == '/') { 

            DWORD cbSize = sizeof(rgchFileName);
            BOOL  fRet;

            // reset the file pointer, so subsequent use will fail
            pszFile = NULL;

            //
            // Using the ECB map the Virtual path to the Physical path
            //

            fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                                HSE_REQ_MAP_URL_TO_PATH,
                                                rgchFileName,
                                                &cbSize, NULL);
            
            if (fRet) {
                // we got the mapping. Use it.
                pszFile = rgchFileName;
            }
        }   

        if ( NULL != pszFile) {
            pFileScan = LocalAlloc( LPTR, sizeof( *pFileScan));

            if ( NULL != pFileScan) {
                
                SECURITY_ATTRIBUTES sa;
                
                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;
                
                pFileScan->hFile = 
                    CreateFile( pszFile,
                                GENERIC_READ,
                                g_dwCreateFileShareMode,
                                &sa,
                                OPEN_EXISTING,
                                g_dwCreateFileFlags,
                                NULL );
                
                if ( INVALID_HANDLE_VALUE == pFileScan->hFile) {
                    
                    LocalFree( pFileScan);
                    pFileScan = NULL;
                } else {
                    
                    // insert this into the list at the top
                    lstrcpyn( pFileScan->rgchFile, pszInputPath, MAX_PATH);
                    pFileScan->pNext = g_pOpenFiles;
                    g_pOpenFiles = pFileScan;
                    pFileScan->nRefs = 1;
                    pFileScan->nHits = 0;
                }
            }
        }
    }

    if ( NULL != pFileScan) {

        hFile = pFileScan->hFile;
        pFileScan->nHits++;
        pFileScan->nRefs++;
    }

    LeaveCriticalSection( &g_csOpenFiles);

    return (hFile);

} // FcOpenFile()



DWORD
FcCloseFile(IN HANDLE hFile)
{
    LPOPEN_FILE  pFileScan;
    DWORD dwError = NO_ERROR;

    EnterCriticalSection( &g_csOpenFiles);

    //
    // Look for the handle and decrement the ref count.
    // 
    for ( pFileScan =  g_pOpenFiles; 
         NULL != pFileScan; 
         pFileScan = pFileScan->pNext) {

        if ( hFile == pFileScan->hFile) {

            //
            //  there is a file match. 
            //

            pFileScan->nRefs--;

            //
            // NOTE: There is no freeing of the file when Ref hits '0' :(
            //

            break;
        }

    } // for


    if ( NULL == pFileScan) {
        //
        // file handle not found
        //
        dwError = ( ERROR_INVALID_HANDLE);
    }

    LeaveCriticalSection( &g_csOpenFiles);


    return ( dwError);

} // FcCloseFile()




BOOL
FcReadFromFile(
               IN  HANDLE hFile,
               OUT CHAR * pchBuffer,
               IN  DWORD  dwBufferSize,
               OUT LPDWORD  pcbRead,
               IN OUT LPOVERLAPPED  pov
               )
/*++
  Description:
    Reads contents of file [hFile] from the specified offset in the overlapped 
    structure. The contents are read into the buffer supplied.

  Arguments:
    hFile        - handle for the File from which to read data
    pchBuffer    - pointer to the buffer into which the data is to be read
    dwBufferSize - DWORD containing the max size of the buffer supplied
    pcbRead      - number of bytes read from the file
    pov          - pointer to an overlapped structure that contains the 
                     offset from where to read the contents. The
                     overlapped structure also is used for Overlapped
                     IO in NT.

  Notes:
   This function automatically handles both Windows 95 and NT
   

  Returns:
    TRUE on success and FALSE if there is a failure.
    Use GetLastError() to get the last error code on failure.
--*/
{
    BOOL fRet = TRUE;

    DBG_ASSERT( hFile != INVALID_HANDLE_VALUE);
    DBG_ASSERT( NULL != pchBuffer);
    DBG_ASSERT( NULL != pov);
    DBG_ASSERT( NULL != pcbRead);
    DBG_ASSERT( 0 < dwBufferSize);

    *pcbRead = 0;
    
    if ( TsIsWindows95()) {
        //
        // Windows95 does not support Overlapped IO.
        //  So we shall thunk it out and use Synchronous IO
        //

	DWORD dwError =   SetFilePointer( hFile, 
                                pov->Offset,
                                 NULL,
                                FILE_BEGIN);

	// Apparently SetFilePointer() returns -1 for failure.
	fRet = (dwError != 0xFFFFFFFF); 

        if ( fRet) { 
            fRet = ReadFile( hFile,
                             pchBuffer,
                             dwBufferSize,
                             pcbRead,
                             NULL
                            );
	    if ( fRet && (*pcbRead == 0)) {
                 // we are at end of file
                 fRet = FALSE;
                 SetLastError( ERROR_HANDLE_EOF);
            }
        }

    } else {
            
            ResetEvent( pov->hEvent);

            fRet = TRUE;

            // read data from file
            if (!ReadFile(hFile,
                          pchBuffer,
                          dwBufferSize,
                          pcbRead,
                          pov
                          )) {
                
                DWORD err = GetLastError();
                
                if ( (err != ERROR_IO_PENDING) ||
                     !GetOverlappedResult( hFile, pov,
                                           pcbRead, TRUE)) {
                    
                    fRet = FALSE;
                }
            }
    }

    if ( fRet) {
        pov->Offset += *pcbRead;
    }

    return ( fRet);
} // FcReadFromFile()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\minimal\cgi.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      cgi.h

   Abstract:
      This header declares constants used by CGI implementations.

   Author:

       Murali R. Krishnan    ( MuraliK )    19-June-1995

   Environment:
       Win32 -- User Mode

   Project:
   
       CGI Implementations for W3

   Revision History:

--*/

# ifndef _MSCGI_H_
# define _MSCGI_H_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Constants  
 ************************************************************/

//
// Define various environment strings that may be used by CGI interfaces
//

// ANSI values

# define PSZ_AUTH_TYPE_A                  "AUTH_TYPE"
# define PSZ_COM_SPEC_A                   "ComSpec"
# define PSZ_GATEWAY_INTERFACE_A          "GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_A             "CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_A               "CONTENT_TYPE"
# define PSZ_PATH_A                       "PATH"
# define PSZ_PATH_INFO_A                  "PATH_INFO"
# define PSZ_PATH_TRANSLATED_A            "PATH_TRANSLATED"
# define PSZ_QUERY_STRING_A               "QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_A             "REMOTE_ADDR"
# define PSZ_REMOTE_HOST_A                "REMOTE_HOST"
# define PSZ_REMOTE_USER_A                "REMOTE_USER"
# define PSZ_REQUEST_METHOD_A             "REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_A                "SCRIPT_NAME"
# define PSZ_SERVER_NAME_A                "SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_A            "SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_A                "SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_A            "SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_A                "SystemRoot"
# define PSZ_WINDIR_A                     "WINDIR"


// UNICODE values

# define PSZ_AUTH_TYPE_W                  L"AUTH_TYPE"
# define PSZ_COM_SPEC_W                   L"ComSpec"
# define PSZ_GATEWAY_INTERFACE_W          L"GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_W             L"CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_W               L"CONTENT_TYPE"
# define PSZ_PATH_W                       L"PATH"
# define PSZ_PATH_INFO_W                  L"PATH_INFO"
# define PSZ_PATH_TRANSLATED_W            L"PATH_TRANSLATED"
# define PSZ_QUERY_STRING_W               L"QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_W             L"REMOTE_ADDR"
# define PSZ_REMOTE_HOST_W                L"REMOTE_HOST"
# define PSZ_REMOTE_USER_W                L"REMOTE_USER"
# define PSZ_REQUEST_METHOD_W             L"REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_W                L"SCRIPT_NAME"
# define PSZ_SERVER_NAME_W                L"SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_W            L"SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_W                L"SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_W            L"SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_W                L"SystemRoot"
# define PSZ_WINDIR_W                     L"WINDIR"



# endif // _MSCGI_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\fwasync\fwasync.c ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    fwrite.c

Abstract:

    This module demonstrates a simple file transfer using ISAPI application
      using the Async WriteClient() with callback.

Author:

    Murali R. Krishnan ( MuraliK )   25-Apr-1996

Revision History:
--*/

# include <windows.h>
# include <iisext.h>
# include "openf.h"
# include "dbgutil.h"

/************************************************************
 *  Global Data
 ************************************************************/

LIST_ENTRY g_lWorkItems;
CRITICAL_SECTION g_csWorkItems;

# define USE_WORK_QUEUE   (0)


DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg);


DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile);

DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile);





/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH:
      {
          OutputDebugString( " Initializing the global data for fwasync.dll\n");

          //
          // Initialize various data and modules.
          //
          INITIALIZE_CRITICAL_SECTION(&g_csWorkItems);
          InitializeListHead( &g_lWorkItems);
          fReturn = (InitFileHandleCache() == NO_ERROR);

          break;
      } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH:
      {

          //
          // Only cleanup when we are called because of a FreeLibrary().
          //  i.e., when lpvContext == NULL
          // If we are called because of a process termination,
          //  dont free anything. System will free resources and memory for us.
          //

          CleanupFileHandleCache();
          if ( lpvContext != NULL) {

              DeleteCriticalSection(&g_csWorkItems);
          }

          break;
      } /* case DLL_PROCESS_DETACH */

    default:
      break;
  }   /* switch */

  return ( fReturn);
}  /* DllLibMain() */




DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
/*++

 Routine Description:

   This function performs the necessary action to send response for the
    request received from the client. It picks up the name of a file from
    the pecb->lpszQueryString and sends the file using Asynchronous WriteClient

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.

 Return Value:

    Returns HSE_* status codes
--*/
{
    DWORD hseStatus;


    if ( pecb->lpszQueryString == NULL) {

        hseStatus = SendHeaderToClient( pecb, "File Not Found");
    } else {

        hseStatus = SendFileToClient( pecb, pecb->lpszQueryString);
    }

    return ( hseStatus);

} // HttpExtensionProc()





BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
           "File Transfer using WriteClient" );

    return TRUE;
}



BOOL
TerminateExtension(
    DWORD dwFlags
    )
/*++

Purpose:

    This is optional ISAPI extension DLL entry point.
    If present, it will be called before unloading the DLL,
    giving it a chance to perform any shutdown procedures.
    
Arguments:
    
    dwFlags - specifies whether the DLL can refuse to unload or not
    
Returns:
    
    TRUE, if the DLL can be unloaded
    
--*/
{
    return TRUE;
}



DWORD
SendHeaderToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszErrorMsg)
{

    CHAR buff[600];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Simple File Transfer (Async Write) </title></head>\n"
             "<body><h1>%s</h1>\n"
             ,
             pszErrorMsg );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                      HSE_REQ_SEND_RESPONSE_HEADER,
                                      "200 OK",
                                      NULL,
                                      (LPDWORD) buff )
        ) {

        return HSE_STATUS_ERROR;
    }

    return ( HSE_STATUS_SUCCESS);
} // SendHeaderToClient()



DWORD
SendFileToClient( IN EXTENSION_CONTROL_BLOCK  * pecb, IN LPCSTR pszFile)
{
    CHAR    pchBuffer[1024];
    HANDLE  hFile;
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    hFile = FcOpenFile( pecb, pszFile);

    if ( hFile == INVALID_HANDLE_VALUE) {


        wsprintfA( pchBuffer,
                  "OpenFailed: Error (%d) while opening the file %s.\n",
                  GetLastError(), pszFile);

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

    } else {

        wsprintfA( pchBuffer, " Transferred file contains...");

        hseStatus = SendHeaderToClient( pecb, pchBuffer);

        if ( hseStatus == HSE_STATUS_SUCCESS) {

            hseStatus = SendFileOver( pecb, hFile);

            if ( hseStatus != HSE_STATUS_PENDING) {

                //
                // assume that the data is transmitted.
                //

                // close file handle
                FcCloseFile( hFile);

                if ( hseStatus != HSE_STATUS_SUCCESS) {

                    //
                    // Error in transmitting the file. Send error message.
                    //

                    wsprintfA( pchBuffer,
                              "Send Failed: Error (%d) for file %s.\n",
                              GetLastError(), pszFile);

                    SendHeaderToClient( pecb, pchBuffer);
                }
            }
        }
    }

    return (hseStatus);

} // SendFileToClient()




# define MAX_BUFFER_SIZE  (4096)

typedef struct _AIO_WORK_ITEM {

    LIST_ENTRY    listEntry;
    EXTENSION_CONTROL_BLOCK * pecb;
    HANDLE        hFile;
    OVERLAPPED    ov;
    DWORD         nRead;
    BOOL          fRecvData;
    BOOL          fDoneWithFile;
    CHAR          pchBuffer[ MAX_BUFFER_SIZE ];

}  AIO_WORK_ITEM, * PAWI;



DWORD
ReadDataForPaw(IN PAWI paw)
{
    DWORD hseStatus = HSE_STATUS_SUCCESS;

    // read data from the file
    if (!FcReadFromFile( paw->hFile, paw->pchBuffer, MAX_BUFFER_SIZE,
                         &paw->nRead,
                         &paw->ov)
        ) {

        hseStatus = HSE_STATUS_ERROR;
    }

    return (hseStatus);

} // ReadDataForPaw()




DWORD
SendDataForPaw(IN PAWI paw)
{
    DWORD hseStatus = HSE_STATUS_PENDING;

    // write data to client

    if ( !paw->pecb->WriteClient( paw->pecb->ConnID,
                                 paw->pchBuffer,
                                 &paw->nRead,
                                 HSE_IO_ASYNC)
        ) {

        hseStatus = HSE_STATUS_ERROR;
    }

    return (hseStatus);
} // SendDataForPaw()




VOID
CleanupAW( IN PAWI paw, IN BOOL fDoneWithSession)
{

    DWORD err = GetLastError();

    FcCloseFile( paw->hFile);
    CloseHandle( paw->ov.hEvent);

    if (fDoneWithSession) {
        paw->pecb->ServerSupportFunction( paw->pecb->ConnID,
                                         HSE_REQ_DONE_WITH_SESSION,
                                         NULL, NULL, NULL);
    }
    SetLastError( err);

    //
    // Remove from work items list
    //
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    RemoveEntryList( &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
# endif

    LocalFree( paw);
    return;

} // CleanupAW()




VOID
HseIoCompletion(
                IN EXTENSION_CONTROL_BLOCK * pECB,
                IN PVOID    pContext,
                IN DWORD    cbIO,
                IN DWORD    dwError
                )
/*++

 Routine Description:

   This is the callback function for handling completions of asynchronous IO.
   This function performs necessary cleanup and resubmits additional IO
    (if required). In this case, this function is called at the end of a
    successful Async WriteClient(). This function attempts to read the next
    chunk of data and sends it to client. If there is no next chunk this
    function cleans up the state and informs IIS about its intention to end
    the request.

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.
   pContext      context information supplied with the asynchronous IO call.
   cbIO          count of bytes of IO in the last call.
   dwError       Error if any, for the last IO operation.

 Return Value:

   None.
--*/
{
    PAWI    paw = (PAWI ) pContext;
    EXTENSION_CONTROL_BLOCK   * pecb = paw->pecb;
    DWORD   hseStatus;
    DWORD   cb;
    DWORD   dwFlags;
    BOOL    fRet;


    //
    // 1. if no errors, do another read of the file
    // 2. send the read contents to client
    // 3. if no data present, cleanup and exit
    //

    if ( dwError != NO_ERROR) {

        //
        // Do Cleanup
        //

        CleanupAW( paw, TRUE);
        return;
    }

//    assert( paw->nRead == cbIO);

    if ( !paw->fDoneWithFile ) {

        //
        // Read next chunk of data
        //

        paw->nRead = 0;
        hseStatus = ReadDataForPaw( paw);

        if ( hseStatus == HSE_STATUS_SUCCESS && paw->nRead > 0) {

            hseStatus = SendDataForPaw( paw);
        }

        if ( hseStatus != HSE_STATUS_PENDING) {

            paw->fDoneWithFile = TRUE;

            //
            //  Append any data that was sent from the client
            //

            if ( cb = pecb->cbAvailable )
            {
                if ( pecb->WriteClient( pecb->ConnID,
                                        pecb->lpbData,
                                        &cb,
                                        HSE_IO_ASYNC ))
                {
                    return;
                }
            }

            CleanupAW( paw, TRUE);
        }
    }
    else
    {
        if ( pecb->cbTotalBytes ) {
            if ( paw->fRecvData ) {

                //
                //  This is a ReadClient completion, send the data
                //

                if ( pecb->cbTotalBytes ) {

                    pecb->cbTotalBytes -= cbIO;

                    paw->fRecvData = FALSE;
                    fRet = pecb->WriteClient( pecb->ConnID,
                                              paw->pchBuffer,
                                              &cbIO,
                                              HSE_IO_ASYNC );
                }
            }
            else
            {
                //
                //  This was a write completion
                //

                paw->fRecvData = TRUE;
                dwFlags = HSE_IO_ASYNC;

                cb = min( sizeof( paw->pchBuffer ), pecb->cbTotalBytes );

                fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                                    HSE_REQ_ASYNC_READ_CLIENT,
                                                    paw->pchBuffer,
                                                    &cb,
                                                    &dwFlags );
            }

            if ( fRet )
                return;
        }

        CleanupAW( paw, TRUE );
    }

    return;

} // HseIoCompletion()



DWORD
SendFileOver( IN EXTENSION_CONTROL_BLOCK  * pecb, IN HANDLE hFile)
{

    PAWI   paw;
    DWORD  hseStatus = HSE_STATUS_SUCCESS;

    paw  = (PAWI ) LocalAlloc( LMEM_FIXED, sizeof(AIO_WORK_ITEM));
    if ( paw == NULL) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (HSE_STATUS_ERROR);
    }

    //
    // Fill in all the data in AIO_WORK_ITEM
    //
    paw->pecb = pecb;
    InitializeListHead( &paw->listEntry);
    paw->hFile = hFile;
    paw->nRead = 0;
    paw->fRecvData = FALSE;
    paw->fDoneWithFile = FALSE;
    memset( &paw->ov, 0, sizeof(OVERLAPPED));
    paw->ov.OffsetHigh = 0;
    paw->ov.Offset = 0;
    paw->ov.hEvent = IIS_CREATE_EVENT(
                         "AWI::ov::hEvent",
                         paw,
                         TRUE,
                         FALSE
                         );

    if ( paw->ov.hEvent == NULL) {

        LocalFree( paw);
        return (HSE_STATUS_ERROR);
    }

    //
    // Setup the callback context for the Async IO
    //

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_IO_COMPLETION,
                                       HseIoCompletion,
                                       0,
                                       (LPDWORD ) paw)
        ) {

        //
        // Do cleanup and return error
        //

        CloseHandle( paw->ov.hEvent);
        LocalFree( paw);
        return HSE_STATUS_ERROR;
    }

    // Add to the list
#if USE_WORK_QUEUE
    EnterCriticalSection( &g_csWorkItems);
    InsertTailList( &g_lWorkItems,  &paw->listEntry);
    LeaveCriticalSection( &g_csWorkItems);
#endif

    hseStatus = ReadDataForPaw( paw);

    if ( hseStatus == HSE_STATUS_SUCCESS && paw->nRead > 0 ) {


        hseStatus = SendDataForPaw( paw);
    }

    if ( hseStatus != HSE_STATUS_PENDING) {

        CleanupAW(paw, FALSE);
    }

    return (hseStatus);

} // SendFileOver()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\minimal\cgimin.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cgimin.c

Abstract:

    This module demonstrates a minimal CGI executable for HTTP server
    It mimics the action of BGI program w3min.dll

Author:

    Murali R. Krishnan  (MuraliK)  19-June-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
# include <cgi.h>



# define DEFAULT_LEN       ( 256)



int __cdecl
main( int argc, char * argv[])
{
    char rgchMethod[DEFAULT_LEN];
    char rgchQuery[DEFAULT_LEN];
    char rgchPathInfo[DEFAULT_LEN];
    char rgchXlatedPathInfo[DEFAULT_LEN];
    DWORD dwLen;

    rgchMethod[0] = rgchQuery[0] = 
      rgchPathInfo[0] = rgchXlatedPathInfo[0] = '\0';

    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_REQUEST_METHOD_A, rgchMethod, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_REQUEST_METHOD_A, dwLen);
    }

    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_PATH_INFO_A, rgchPathInfo, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_PATH_INFO_A, dwLen);
    }

      
    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_QUERY_STRING_A, rgchQuery, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_QUERY_STRING_A, dwLen);
    }

      
    dwLen = DEFAULT_LEN;
    dwLen = GetEnvironmentVariableA( PSZ_PATH_TRANSLATED_A, 
                                    rgchXlatedPathInfo, dwLen);
    if ( dwLen > DEFAULT_LEN) {

        fprintf( stderr, " Environment variable %s has value of length %d\n",
                PSZ_PATH_TRANSLATED_A, dwLen);
    }
      

    printf(
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Minimal Server Extension Example</title></head>\n"
             "<body><h1>Minimal Server Extension Example (CGI)</h1>\n"
             "<p>Method               = %s\n"
             "<p>Query String         = %s\n"
             "<p>Path Info            = %s\n"
             "<p>Translated Path Info = %s\n"
             "<p>"
             "<p>"
             "<form METHOD=\"POST\" ACTION=\"/scripts/w3min.dll/PathInfo/foo\">"
             "Enter your name: <input text name=\"Name\" size=36><br>"
             "<input type=\"submit\" value=\"Do Query\">"
             "</body>",
             rgchMethod,
             rgchQuery,
             rgchPathInfo,
             rgchXlatedPathInfo);

    return (1);
} // main()


/************************* End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc\decnotif.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    decnotif.cxx

Abstract:

    This file contains the code for decache notification

Author:

    John Ludeman (johnl)   27-Jun-1995

Revision History:

--*/

# include "dbgutil.h"

#include <tcpdll.hxx>
#include <tsunami.hxx>
#include <decnotif.hxx>

//
//  Prototypes
//

BOOL
FreeDNLCacheBlob(
    VOID * pvCacheBlob
    );

//
//  This is an individual notification event contained in the Decache
//  Notification List
//

class DECACHE_NOTIF_ITEM
{
public:
    DECACHE_NOTIF_ITEM( PFN_NOTIF pCallback,
                        VOID *    pContext )
    : _pfnNotif ( pCallback ),
      _pContext ( pContext ),
      _Signature( SIGNATURE_DNI )
        { _ListEntry.Flink = NULL; }

    ~DECACHE_NOTIF_ITEM()
    {
        TCP_ASSERT( _ListEntry.Flink == NULL );
        _Signature = SIGNATURE_DNI_FREE;
    }

    VOID Notify( VOID )
        { _pfnNotif( _pContext ); }

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_DNI; }

    DWORD       _Signature;
    LIST_ENTRY  _ListEntry;

private:
    PFN_NOTIF   _pfnNotif;
    VOID *      _pContext;
};

//
//  Maintains a list of DECACHE_NOTIF_ITEMs.  This item is contained in a
//  directory cache blob
//

class DECACHE_NOTIF_LIST : public BLOB_HEADER
{
public:

    DECACHE_NOTIF_LIST()
    : _Signature( SIGNATURE_DNL )
    {
        InitializeListHead( &_NotifListHead );
    }

    ~DECACHE_NOTIF_LIST();

    VOID * AddNotification( PFN_NOTIF pfnNotif,
                            VOID *    pContext );

    VOID RemoveNotification( DECACHE_NOTIF_ITEM * pDNI );

    VOID NotifyAll( VOID );

    //
    //  Memory for a DNL comes from Tsunami's cache manager
    //

    static void * operator new( size_t size,
                                void * pMem )
    {
        TCP_ASSERT( size == sizeof(DECACHE_NOTIF_LIST));

        return pMem;
    }

    static void operator delete( void * pMem )
    {
        //
        //  Tsunami frees this memory
        //

        ;
    }

    VOID LockList( VOID )
        { EnterCriticalSection( _pcsClientLock ); }

    VOID UnlockList( VOID )
        { LeaveCriticalSection( _pcsClientLock ); }

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_DNL; }


    DWORD              _Signature;
    LIST_ENTRY         _NotifListHead;
    CRITICAL_SECTION * _pcsClientLock;
};



BOOL
CheckOutDecacheNotification(
    IN  TSVC_CACHE *       pTsvcCache,
    IN  const CHAR *       pszFile,
    IN  PFN_NOTIF          pfnNotif,
    IN  VOID *             pContext,
    IN  DWORD              TsunamiDemultiplex,
    IN  CRITICAL_SECTION * pcsLock,
    OUT VOID * *           ppvNotifCookie,
    OUT VOID * *           ppvCheckinCookie
    )
/*++

Routine Description:

    Adds a notification event to the decache notification list.  The cache
    item is left checked out so the notification list doesn't get destroyed
    thus prematurely freeing the decache notification item.

    THE CLIENT SUPPLIED LOCK MUST BE TAKEN PRIOR TO CALLING THIS ROUTINE.

Arguments:

    pTsvcCache - Service specific cache item
    pszFile - Fully qualified file for which we want the decache notification
    pfnNotif - Notification routine to call when item gets decached
    pContext - Context to call notification with
    TsuanmiDemultiplex - Demultiplexor for finding the correct DNL
    pcsLock - Client lock to take while dealing with the DNL when item is
        decached
    ppvNotifCookie - Cookie to added DNI used for removing the notification
    ppvCheckinCookie - Cookie used for checking in the item just checked out

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DECACHE_NOTIF_LIST * pDNL;
    const ULONG cchFile = strlen(pszFile);

    //
    //  Get the DNL cache blob
    //

    if ( !TsCheckOutCachedBlob( *pTsvcCache,
                                pszFile,
                                cchFile,
                                TsunamiDemultiplex,
                                (VOID **) &pDNL ))
    {
        VOID * pvMem;

        //
        //  The Decache Notification List isn't in the Tsunami cache so
        //  create it and add it
        //

        if ( !TsAllocateEx( *pTsvcCache,
                            sizeof( DECACHE_NOTIF_LIST ),
                            &pvMem,
                            (PUSER_FREE_ROUTINE) FreeDNLCacheBlob ))
        {
            //
            //  Failed to create the DNL so bail
            //

            return FALSE;
        }

        pDNL = new(pvMem) DECACHE_NOTIF_LIST();

        TCP_ASSERT( pDNL );

        //
        //  Save the client lock for this list so we can take it when we get
        //  a decache notification
        //

        pDNL->_pcsClientLock = pcsLock;

        //
        //  Now attempt to add it as a cache blob and check it out at the
        //  same time
        //

        if ( !TsCacheDirectoryBlob( *pTsvcCache,
                                    pszFile,
                                    cchFile,
                                    TsunamiDemultiplex,
                                    pDNL,
                                    TRUE ))
        {
            //
            //  Failed to cache the List so bail, note the destructor
            //  gets called in the FreeDNLCacheBlob
            //

            TCP_REQUIRE( TsFree( *pTsvcCache,
                                 pvMem ));

            return FALSE;
        }
    }

    TCP_ASSERT( pDNL->CheckSignature() );
    TCP_ASSERT( pcsLock == pDNL->_pcsClientLock );

    //
    //  Now that we've successfully checked out the DNL,
    //  add this notification request to the list
    //

    *ppvNotifCookie = pDNL->AddNotification( pfnNotif,
                                             pContext );

    if ( !*ppvNotifCookie )
    {
        TCP_REQUIRE( TsCheckInCachedBlob( pDNL ));
        return FALSE;
    }

    *ppvCheckinCookie = pDNL;

    return TRUE;
}

VOID
CheckInDecacheNotification(
    IN  TSVC_CACHE *       pTsvcCache,
    IN  VOID *             pvNotifCookie,
    IN  VOID *             pvCheckinCookie,
    IN  BOOL               fAddNotification
    )
/*++

Routine Description:

    Checks in the notification list that was checked out in
    AddDecacheNotification.

    THE CLIENT SUPPLIED LOCK MUST BE TAKEN PRIOR TO CALLING THIS ROUTINE.

Arguments:

    pTsvcCache - Service specific cache item
    pvNotifCookie - Cookie to added DNI used for removing the notification
    pvCheckinCookie - Cookie used for checking in the item just checked out
    fAddNotification - TRUE if the notification should be left on the list,
        FALSE to remove the notification

--*/
{
    DECACHE_NOTIF_LIST * pDNL = (DECACHE_NOTIF_LIST *) pvCheckinCookie;

    TCP_ASSERT( pDNL->CheckSignature() );

    //
    //  If this item should not be on the list, get it off now
    //

    if ( !fAddNotification )
    {
        TCP_REQUIRE( RemoveDecacheNotification( pvNotifCookie ));
    }

    //
    // Check in the list
    //

    TCP_REQUIRE( TsCheckInCachedBlob( (VOID *) pDNL ));
}

BOOL
RemoveDecacheNotification(
    IN  VOID *     pvNotifCookie
    )
/*++

Routine Description:

    Removes the specified notification event

    THE CLIENT SUPPLIED LOCK MUST BE TAKEN PRIOR TO CALLING THIS ROUTINE.

Arguments:

    pvNotifCookie - Pointer to notification even to removed

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DECACHE_NOTIF_ITEM * pDNI = (DECACHE_NOTIF_ITEM *) pvNotifCookie;

    TCP_ASSERT( pDNI->CheckSignature() );
    TCP_ASSERT( pDNI->_ListEntry.Flink != NULL );

    RemoveEntryList( &pDNI->_ListEntry );

    pDNI->_ListEntry.Flink = NULL;

    delete pDNI;

    return TRUE;
}

VOID *
DECACHE_NOTIF_LIST::AddNotification(
    PFN_NOTIF pfnNotif,
    VOID *    pContext
    )
/*++

Routine Description:

    Adds a notification event to the decache notification list

Arguments:

    pfnNotif - Function to call on decache notification
    pContext - Context to pass to function on notification

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DECACHE_NOTIF_ITEM * pDNI;

    pDNI = new DECACHE_NOTIF_ITEM( pfnNotif,
                                   pContext );

    if ( pDNI )
    {
        InsertHeadList( &_NotifListHead,
                        &pDNI->_ListEntry );

        return pDNI;
    }

    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    return NULL;
}

VOID
DECACHE_NOTIF_LIST::RemoveNotification(
    DECACHE_NOTIF_ITEM * pDNI
    )
/*++

Routine Description:

    Removes the specified notification from the list

Arguments:

    pDNI - Notification item to remove and delete

--*/
{
    TCP_ASSERT( pDNI->_ListEntry.Flink != NULL );

    RemoveEntryList( &pDNI->_ListEntry );
    pDNI->_ListEntry.Flink = NULL;
    delete pDNI;
}

VOID
DECACHE_NOTIF_LIST::NotifyAll(
    VOID
    )
/*++

Routine Description:

    Notifies all items on this list that the file has been decached, removes
    the notification and deletes the notification item

--*/
{
    DECACHE_NOTIF_ITEM * pDNI;

    while ( !IsListEmpty( &_NotifListHead ))
    {
        pDNI = CONTAINING_RECORD( _NotifListHead.Flink,
                                  DECACHE_NOTIF_ITEM,
                                  _ListEntry );
        pDNI->Notify();

        RemoveNotification( pDNI );
    }

}

DECACHE_NOTIF_LIST::~DECACHE_NOTIF_LIST()
/*++

Routine Description:

    Destructs the notification list w/o notifying anybody in the list

--*/
{
    DECACHE_NOTIF_ITEM * pDNI;

    while ( !IsListEmpty( &_NotifListHead ))
    {
        pDNI = CONTAINING_RECORD( _NotifListHead.Flink,
                                  DECACHE_NOTIF_ITEM,
                                  _ListEntry );

        RemoveNotification( pDNI );
    }

    _Signature = SIGNATURE_DNL_FREE;
}

BOOL
FreeDNLCacheBlob(
    VOID * pvCacheBlob
    )
/*++

Routine Description:

    This is the routine called by the Tsunami cache manager when the file this
    notification list is waiting on gets a change notification

--*/
{
    DECACHE_NOTIF_LIST * pDNL = (DECACHE_NOTIF_LIST *) pvCacheBlob;

    TCP_ASSERT( pDNL->CheckSignature() );

    pDNL->LockList();

    pDNL->NotifyAll();

    //
    //  Deconstruct this object.  Note the memory is not freed
    //

    delete pDNL;

    pDNL->UnlockList();

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\dlp\main.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    This module provides the entry point for IISDLP

Author:

    George V. Reilly (GeorgeRe) July 1998

Revision History:
--*/

#include "dlp.hxx"
#include <time.h>


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

/************************************************************
 *   IISDLP - inline documentation

 Controls the DLPified bits of IIS.

 Install iisdlp.dll by just copying it to any directory marked with
  execute permission.
 For example:
   Copy it to the /scripts directory.
   Access it via the browser by typing
       http://<machine-name>/scripts/iisdlp.dll?
   and follow the instructions in menu presented.
 ************************************************************/


BOOL ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb);


DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    BOOL fReturn = TRUE;
    char buff[2048];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

	time_t tmNow;
	time(&tmNow);

    wsprintf( buff,
              "Content-Type: text/html\r\n"
              "\r\n"
              "<html>\n"
              "<head><title>IIS DLP Page</title></head>\n"
              "<body>\n"
              "<p>This page controls the data gathering of DLP.\n"
              "<p>%s\n"
              "<p>\n",
              ctime(&tmNow)
              );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       NULL,
                                       (LPDWORD) buff )
         ) {
        return HSE_STATUS_ERROR;
    }

    fReturn = ParseAndDispatch( pecb);

    return (fReturn ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);

} // HttpExtensionProc()


BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( HSE_VERSION_MAJOR,
                                         HSE_VERSION_MINOR);
    strcpy( pver->lpszExtensionDesc,
            "IIS DLP Application" );

    return TRUE;
}


BOOL WINAPI
TerminateExtension(
    DWORD dwFlags
    )
{
    return TRUE;
}




const char * g_pszUsage =
"<h2> List of Options </h2>\n"
"<UL> \n"
"  <LI> <A HREF=iisdlp.dll?Usage> Usage Information</A> - this menu\n"
"</UL>\n"
"<br>\n"
"<UL>\n"
"  <LI> <A HREF=iisdlp.dll?start>   Start DLP </A>\n"
"  <LI> <A HREF=iisdlp.dll?stop>    Stop DLP </A>\n"
"  <LI> <A HREF=iisdlp.dll?suspend> Suspend DLP </A>\n"
"  <LI> <A HREF=iisdlp.dll?resume>  Resume DLP </A>\n"
"</UL>\n"
;

BOOL
SendUsage( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    DWORD cbBuff = strlen( g_pszUsage);

    return ( pecb->WriteClient( pecb->ConnID, (PVOID) g_pszUsage, &cbBuff, 0));
} // SendUsage()


const char* g_pszTail =
"</BODY>\n"
"</HTML>\n"
;

BOOL
SendTail( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    DWORD cbBuff = strlen( g_pszTail);

    return ( pecb->WriteClient( pecb->ConnID, (PVOID ) g_pszTail, &cbBuff, 0));
} // SendTail()


BOOL
SendDLPStatus( IN EXTENSION_CONTROL_BLOCK * pecb,
               const char* pszStatus,
		int n)
{
    const char szDLP[] = "<h2>DLP %s, %d</h2>\n";
    char szTemp[sizeof(szDLP) + 20];
    wsprintf(szTemp, szDLP, pszStatus, n);
    DWORD cbBuff = strlen(szTemp);

    return ( pecb->WriteClient( pecb->ConnID, (PVOID) szTemp, &cbBuff, 0));
} // SendDLPStatus()


BOOL
ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    BOOL fReturn = FALSE;
    int n = 0;

    if ( pecb == NULL) {
        return ( FALSE);
    }

    if ( (pecb->lpszQueryString == NULL) || (*pecb->lpszQueryString == '\0')) {

        return ( SendUsage( pecb)  &&  SendTail(pecb));
    }

    switch ( *pecb->lpszQueryString ) {

    case 'r': case 'R':
        if ( _stricmp( pecb->lpszQueryString, "resume") == 0) {
            n = ResumeCAPAll();
            fReturn = SendDLPStatus(pecb, "resumed", n);
        }

        break;

    case 's': case 'S':
        if ( _stricmp( pecb->lpszQueryString, "start") == 0) {
            n = StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);
            fReturn = SendDLPStatus(pecb, "started", n);
        } else if ( _stricmp( pecb->lpszQueryString, "stop") == 0) {
            n = StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);
            fReturn = SendDLPStatus(pecb, "stopped", n);
        } else if ( _stricmp( pecb->lpszQueryString, "suspend") == 0) {
            n = SuspendProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID);
            fReturn = SendDLPStatus(pecb, "suspended", n);
        }

        break;

    case 'u': case 'U':
    default:
        if ( _stricmp( pecb->lpszQueryString, "Usage") == 0) {
            fReturn = SendUsage(pecb);
        }

        break;
    } // switch()

    if (fReturn) {
        fReturn = SendTail(pecb);
    }
    
    return ( fReturn);
} // ParseAndDispatch()



extern "C" BOOL WINAPI 
DllMain( 
    HANDLE hModule, 
    DWORD dwReason, 
    LPVOID 
    )
/*++

Routine Description:

    DLL init/terminate notification function

Arguments:

    hModule  - DLL handle
    dwReason - notification type
    LPVOID   - not used

Returns:

    TRUE if success, FALSE if failure

--*/
{
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            SET_DEBUG_FLAGS(DEBUG_ERROR);
            CREATE_DEBUG_PRINT_OBJECT("iisdlp");
            if (!VALID_DEBUG_PRINT_OBJECT()) {
                return (FALSE);
            }
            break;

        case DLL_PROCESS_DETACH:
            DELETE_DEBUG_PRINT_OBJECT();
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\minimal\w3min.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3min.c

Abstract:

    This module demonstrates a minimal HTTP Server Extension gateway

Author:

    John Ludeman (johnl)   13-Oct-1994

Revision History:
--*/

#include <windows.h>
#include <httpext.h>


#define END_OF_DOC   "End of document"

DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    char buff[2048];
    int  cb = sizeof(END_OF_DOC) - 1;

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Minimal Server Extension Example</title></head>\n"
             "<body><h1>Minimal Server Extension Example (BGI)</h1>\n"
             "<p>Method               = %s\n"
             "<p>Query String         = %s\n"
             "<p>Path Info            = %s\n"
             "<p>Translated Path Info = %s\n"
             "<p>"
             "<p>"
             "<form METHOD=\"POST\" ACTION=\"/scripts/w3min.dll/PathInfo/foo\">"
             "Enter your name: <input text name=\"Name\" size=36><br>"
             "<input type=\"submit\" value=\"Do Query\">"
             "</body>",
             pecb->lpszMethod,
             pecb->lpszQueryString,
             pecb->lpszPathInfo,
             pecb->lpszPathTranslated );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       NULL,
                                       (LPDWORD) buff ) ||
         !pecb->WriteClient( pecb->ConnID,
                             END_OF_DOC,
                             &cb,
                             0 ))
    {
        return HSE_STATUS_ERROR;
    }

    return HSE_STATUS_SUCCESS;
}

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
            "Minimal Extension example" );

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\dynodbc.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    dynodbc.c

Abstract:

    This module provides functions for dynamically loading the ODBC
       functions.

Author:

    Murali R. Krishnan  (MuraliK)  3-Nov-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
# include "dynodbc.h"


//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

pfnSQLAllocConnect        pSQLAllocConnect   ;
pfnSQLAllocEnv            pSQLAllocEnv       ;
pfnSQLAllocStmt           pSQLAllocStmt      ;
pfnSQLBindCol             pSQLBindCol        ;
pfnSQLCancel              pSQLCancel         ;
pfnSQLColAttributes       pSQLColAttributes  ;
pfnSQLConnect             pSQLConnect        ;
pfnSQLDescribeCol         pSQLDescribeCol    ;
pfnSQLDisconnect          pSQLDisconnect     ;
pfnSQLError               pSQLError          ;
pfnSQLExecDirect          pSQLExecDirect     ;
pfnSQLExecute             pSQLExecute        ;
pfnSQLFetch               pSQLFetch          ;
pfnSQLFreeConnect         pSQLFreeConnect    ;
pfnSQLFreeEnv             pSQLFreeEnv        ;
pfnSQLFreeStmt            pSQLFreeStmt       ;
pfnSQLGetCursorName       pSQLGetCursorName  ;
pfnSQLNumResultCols       pSQLNumResultCols  ;
pfnSQLPrepare             pSQLPrepare        ;
pfnSQLRowCount            pSQLRowCount       ;
pfnSQLSetCursorName       pSQLSetCursorName  ;
pfnSQLTransact            pSQLTransact       ;

pfnSQLSetConnectOption    pSQLSetConnectOption;
pfnSQLDrivers             pSQLDrivers         ;
pfnSQLDataSources         pSQLDataSources     ;
pfnSQLBindParameter       pSQLBindParameter   ;
pfnSQLGetInfo             pSQLGetInfo        ;
pfnSQLMoreResults         pSQLMoreResults    ;



# define ODBC_MODULE_NAME             "odbc32.dll"

#define LOAD_ENTRY( hMod, Name )  \
   (p##Name = (pfn##Name) GetProcAddress( (hMod), #Name ))


static BOOL  s_fODBCLoaded = FALSE;



BOOL
DynLoadODBC(
    VOID
    )
{
    HMODULE hMod;

    if ( s_fODBCLoaded )
      return TRUE;

    if ( (hMod = (HMODULE) LoadLibrary( ODBC_MODULE_NAME ))) {

        if (LOAD_ENTRY( hMod, SQLAllocConnect   )  &&
            LOAD_ENTRY( hMod, SQLAllocEnv       )  &&
            LOAD_ENTRY( hMod, SQLAllocStmt      )  &&
            LOAD_ENTRY( hMod, SQLBindCol        )  &&
            LOAD_ENTRY( hMod, SQLCancel         )  &&
            LOAD_ENTRY( hMod, SQLColAttributes  )  &&
            LOAD_ENTRY( hMod, SQLConnect        )  &&
            LOAD_ENTRY( hMod, SQLDescribeCol    )  &&
            LOAD_ENTRY( hMod, SQLDisconnect     )  &&
            LOAD_ENTRY( hMod, SQLError          )  &&
            LOAD_ENTRY( hMod, SQLExecDirect     )  &&
            LOAD_ENTRY( hMod, SQLExecute        )  &&
            LOAD_ENTRY( hMod, SQLFetch          )  &&
            LOAD_ENTRY( hMod, SQLFreeConnect    )  &&
            LOAD_ENTRY( hMod, SQLFreeEnv        )  &&
            LOAD_ENTRY( hMod, SQLFreeStmt       )  &&
            LOAD_ENTRY( hMod, SQLNumResultCols  )  &&
            LOAD_ENTRY( hMod, SQLPrepare        )  &&
            LOAD_ENTRY( hMod, SQLRowCount       )  &&
            LOAD_ENTRY( hMod, SQLTransact       )  &&
            LOAD_ENTRY( hMod, SQLSetConnectOption )  &&
            LOAD_ENTRY( hMod, SQLDrivers        )  &&
            LOAD_ENTRY( hMod, SQLDataSources    )  &&
            LOAD_ENTRY( hMod, SQLGetInfo        )  &&
            LOAD_ENTRY( hMod, SQLBindParameter  )  &&
            LOAD_ENTRY( hMod, SQLMoreResults    )
            ) {

            s_fODBCLoaded = TRUE;
        }
    }

    return (s_fODBCLoaded);

} // DynLoadODBC()


/****************************** End Of File ******************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc\odbcpool.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    odbcpool.cxx

Abstract:

    Provides simple ODBC connection pooling for IDC.  The only keys used for
    the connection pooling is the datasource name, the username and
    password.  ODBC options and other connection state are not taken
    into consideration.

Author:

    John Ludeman (johnl)   01-Apr-1996

Revision History:
--*/

#include <w3p.hxx>
#include "issched.hxx"
#include <tcpdll.hxx>
#include <odbcconn.hxx>
#include <parmlist.hxx>

#include <odbcmsg.h>
#include <odbcreq.hxx>

#include "dbgutil.h"

extern "C"
{
#include <string.h>
}

#ifndef _NO_TRACING_

#define IDC_PRINTF( x )        { char buff[256]; wsprintf x; DBGPRINTF((DBG_CONTEXT, buff )); }

#else

#if DBG
#define IDC_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IDC_PRINTF( x )
#endif

#endif

//
//  Default connection pool timeout
//

#define IDC_POOL_TIMEOUT                30

//
//  Globals
//

CRITICAL_SECTION g_csPoolLock;

LIST_ENTRY       g_PoolList;

DWORD            g_dwTimeoutID = 0;

//
// Various counters
//

DWORD g_cFree;
DWORD g_cUsed;

//
//  ODBC Connection pool item
//

class ODBC_CONN_POOL
{
public:

    ODBC_CONN_POOL( const CHAR * pszDataSource,
                    const CHAR * pszUsername,
                    const CHAR * pszPassword,
                    const CHAR * pszLoggedOnUser )
        : m_strDataSource( pszDataSource ),
          m_strUsername  ( pszUsername ),
          m_strPassword  ( pszPassword ),
          m_strLogon     ( pszLoggedOnUser ),
          m_fFree        ( TRUE ),
          m_TTL          ( 2 )
    {
    }

    ~ODBC_CONN_POOL()
    {
        m_odbcconn.Close();
    }

    BOOL Open( VOID )
    {
        return m_odbcconn.Open( m_strDataSource.QueryStr(),
                                m_strUsername.QueryStr(),
                                m_strPassword.QueryStr() );
    }

    BOOL IsValid( VOID ) const
        { return m_strDataSource.IsValid() &&
                 m_strUsername.IsValid()   &&
                 m_strPassword.IsValid()   &&
                 m_strLogon.IsValid(); }

    BOOL IsFree( VOID ) const
        { return m_fFree; }

    VOID MarkAsUsed( VOID )
        { m_fFree = FALSE; g_cFree--; g_cUsed++; }

    VOID MarkAsFree( VOID )
        { m_fFree = TRUE; g_cUsed--; g_cFree++; }

    const CHAR * QueryDataSource( VOID ) const
        { return m_strDataSource.QueryStr(); }

    const CHAR * QueryUsername( VOID ) const
        { return m_strUsername.QueryStr(); }

    const CHAR * QueryPassword( VOID ) const
        { return m_strPassword.QueryStr(); }

    const CHAR * QueryLoggedOnUser( VOID ) const
        { return m_strLogon.QueryStr(); }

    ODBC_CONNECTION * QueryOdbcConnection( VOID )
        { return &m_odbcconn; }

    DWORD DecrementTTL( VOID )
        { if ( m_TTL < IDC_POOL_TIMEOUT )
              return 0;

          m_TTL -= IDC_POOL_TIMEOUT;
          return m_TTL;
        }

    VOID SetTTL( DWORD csecTimeout )
        { m_TTL = csecTimeout; }

    LIST_ENTRY m_ListEntry;

private:

    ODBC_CONNECTION m_odbcconn;
    STR             m_strDataSource;
    STR             m_strUsername;
    STR             m_strPassword;
    STR             m_strLogon;         // The NT account this request is using
    BOOL            m_fFree;
    DWORD           m_TTL;

};

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    );

BOOL
InitializeOdbcPool(
    VOID
    )
{
    DWORD  err;
    HKEY   hkey;

    InitializeListHead( &g_PoolList );
    INITIALIZE_CRITICAL_SECTION( &g_csPoolLock );

    //
    //  Kick off the pool scavenger
    //

    g_dwTimeoutID = ScheduleWorkItem( IDCPoolScavenger,
                                      NULL,
                                      IDC_POOL_TIMEOUT * 1000,
                                      TRUE );

    return TRUE;
}

VOID
TerminateOdbcPool(
    VOID
    )
{
    ODBC_CONN_POOL * pOCPool;

    if ( g_dwTimeoutID )
    {
        RemoveWorkItem( g_dwTimeoutID );
        g_dwTimeoutID = 0;
    }

    EnterCriticalSection( &g_csPoolLock );

    while ( !IsListEmpty( &g_PoolList ))
    {
        LIST_ENTRY * pEntry = g_PoolList.Flink;

        RemoveEntryList( pEntry );

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        delete pOCPool;
    }

    LeaveCriticalSection( &g_csPoolLock );
    DeleteCriticalSection( &g_csPoolLock );
}

BOOL
OpenConnection(
    IN  ODBC_CONNECTION *   podbcconnNonPooled,
    OUT ODBC_CONNECTION * * ppodbcconnToUse,
    IN  DWORD               csecPoolTimeout,
    IN  const CHAR *        pszDataSource,
    IN  const CHAR *        pszUsername,
    IN  const CHAR *        pszPassword,
    IN  const CHAR *        pszLoggedOnUser
    )
/*++

Routine Description:

    This function opens an odbc connection, optionally from a pool of
    ODBC connections.



Arguments:

    podbcconnNonPooled - If pooling wasn't requested or the open failed, we
        use this odbc connection object
    ppodbcconnToUse - Receives pointer to either a pooled ODBC connection object
        or podbcconnNonPooled if a pooled object couldn't be used
    csecPoolTimeout - Amount of time to pool a connection, 0 to not pool
    pszDataSource - ODBC Datasource
    pszUsername - Username for datasource access
    pszPassword - Password for use with this username
    pszLoggedOnUser - The NT account this user is running under

Return Value:

    TRUE if successful, FALSE on error

    ppodbcconnToUse will be set to the ODBC connection to use for the
        request

--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;

    //
    //  Don't pool this connection if it wasn't requested
    //

    if ( !csecPoolTimeout )
    {
        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    //
    //  Look in the pool cache for an existing connection
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree() &&
             !lstrcmpi( pOCPool->QueryDataSource(), pszDataSource ) &&
             !lstrcmpi( pOCPool->QueryUsername(), pszUsername ) &&
             !lstrcmpi( pOCPool->QueryLoggedOnUser(), pszLoggedOnUser ) &&
             !strcmp( pOCPool->QueryPassword(),
                      pszPassword ))

        {
            //
            //  We have a match
            //

            pOCPool->MarkAsUsed();
            *ppodbcconnToUse = pOCPool->QueryOdbcConnection();
            pOCPool->SetTTL( csecPoolTimeout );
            LeaveCriticalSection( &g_csPoolLock );

            return TRUE;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );

    //
    //  Allocate a new connection pool and if we connect successfully, put
    //  it in the pool list
    //

    pOCPool = new ODBC_CONN_POOL( pszDataSource,
                                  pszUsername,
                                  pszPassword,
                                  pszLoggedOnUser );

    if (pOCPool == NULL) {
        return FALSE;
    }

    if ( !pOCPool->Open() )
    {
        delete pOCPool;

        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    *ppodbcconnToUse = pOCPool->QueryOdbcConnection();

    EnterCriticalSection( &g_csPoolLock );

    //
    //  Account for the new pool item but we have to do it with in
    //  the critical section
    //

    g_cFree++;

    pOCPool->MarkAsUsed();
    pOCPool->SetTTL( csecPoolTimeout );
    InsertHeadList( &g_PoolList, &pOCPool->m_ListEntry );

    LeaveCriticalSection( &g_csPoolLock );

    return TRUE;
}

VOID
CloseConnection(
    IN  ODBC_CONNECTION *   podbcconnPooled,
    IN  BOOL                fDelete
    )
/*++

Routine Description:

    This routine frees an ODBC connection back to the pool, optionally
    deleting it

Arguments:

    podbcconnPooled - ODBC connection that is pooled, can be NULL
    fDelete - TRUE if the item should be delete rather then returned to the
        pool
--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;

    if ( !podbcconnPooled )
    {
        return;
    }

    //
    //  Look in the pool list to mark it as free
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( podbcconnPooled == pOCPool->QueryOdbcConnection() )
        {
            pOCPool->MarkAsFree();

            if ( fDelete )
            {
                RemoveEntryList( pEntry );
                g_cFree--;
                delete pOCPool;
            }

            break;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );
}

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    )
/*++

Routine Description:

    Walks the list of pooled connections and removes any that have timed out

--*/
{
    LIST_ENTRY *     pEntry;
    LIST_ENTRY *     pNext;
    ODBC_CONN_POOL * pOCPool;

    //
    //  Look through the list and remove any old items
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pNext )
    {
        pNext = pEntry->Flink;

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree() && !pOCPool->DecrementTTL() )
        {
            IDC_PRINTF(( buff,
                         "[IDCPoolScavenger] Removing %s, %s, %s\n",
                         pOCPool->QueryDataSource(),
                         pOCPool->QueryUsername(),
                         pOCPool->QueryLoggedOnUser() ));

            RemoveEntryList( pEntry );
            g_cFree--;
            delete pOCPool;
        }
    }

#if 0
    IDC_PRINTF(( buff,
                 "[IDCPoolScavenger] Free items in pool %d, used %d\n",
                 g_cFree,
                 g_cUsed ));
#endif

    LeaveCriticalSection( &g_csPoolLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc\odbcreq.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    odbcreq.cxx

Abstract:

    ODBC Request class used for ODBC requests from a query file

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

    MuraliK    25-Aug-1995     Fixed a heap corruption problem
    Phillich   24-Jan-1996     Fixed nested Ifs problem

--*/

#include <iis64.h>
#include <tsunami.hxx>
#include <mbstring.h>
# include "dbgutil.h"
#include <tcpdll.hxx>
#include <odbcconn.hxx>
#include <parmlist.hxx>

#include <odbcmsg.h>
#include <odbcreq.hxx>

#include <festrcnv.h>


//
//  Globals
//

extern BOOL        g_fIsSystemDBCS;        // Is this system DBCS?

//
//  Accumulate and output data in chunks of this size
//

#define OUTPUT_BUFFER_SIZE         8192

//
//  This is the maximum value for the expires time.  It's 10 years in seconds
//

#define MAX_EXPIRES_TIME           0x12cc0300

//
//  The special tag names for marking the beginning and ending of the
//  special tag sections
//

#define BEGIN_DETAIL_TEXT       "begindetail"
#define END_DETAIL_TEXT         "enddetail"
#define IF_TEXT                 "if"
#define ELSE_TEXT               "else"
#define END_IF_TEXT             "endif"

//
//  Does a case insensitive compare of a .wdg field name
//

#define COMP_FIELD( pchName, pchField, cch )  ((toupper(*(pchName)) ==     \
                                                toupper(*(pchField))) &&   \
                                               !_strnicmp( (pchName), (pchField), (cch)))

//
//  Given a pointer to a token, skips to the next white space delimited token
//

#define NEXT_TOKEN( pchToken )                 SkipWhite( SkipNonWhite( pchToken ) )

BOOL
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STR *             pStrOptions
    );

BOOL
BuildMultiValue(
    const CHAR * pchValue,
    STR *        pstrMulti,
    BOOL         fQuoteElements
    );

const CHAR *
SkipNonWhite(
    const CHAR * pch
    );

const CHAR *
SkipTo(
    const CHAR * pch,
    CHAR ch
    );

const CHAR *
SkipWhite(
    const CHAR * pch
    );

ODBC_REQ::ODBC_REQ(
    TSVC_CACHE *         pCache,
    CONST CHAR *         pszQueryFile,
    CONST CHAR *         pszPathInfo,
    CONST CHAR *         pszParameters,
    BOOL                 fAnonymous,
    HANDLE               hUserToken,
    DWORD                csecConnPool,
    ODBC_REQ_FIND_SYMBOL pfnClientFindSymbol,
    VOID *               pFindSymbolContext,
    int                  nCharset
    )
    : _pCache             ( pCache ),
      _cchMaxFieldSize    ( 0 ),
      _cMaxRecords        ( 0xffffffff ),
      _cCurrentRecordNum  ( 0 ),
      _cClientParams      ( 0 ),
      _podbcstmt          ( NULL ),
      _podbcconnPool      ( NULL ),
      _hToken             ( hUserToken ),
      _pfnClientFindSymbol( pfnClientFindSymbol ),
      _pFindSymbolContext ( pFindSymbolContext ),
      _cbQueryFile        ( 0 ),
      _cNestedIfs         ( 0 ),
      _strQueryFile       ( pszQueryFile ),
      _strPathInfo        ( pszPathInfo ),
      _fDirect            ( FALSE ),
      _fValid             ( FALSE ),
      _pbufOut            ( NULL ),
      _csecExpires        ( 0 ),
      _csecExpiresAt      ( 0 ),
      _pstrValues         ( NULL ),
      _pcbValues          ( NULL ),
      _cQueries           ( 0 ),
      _fAnonymous         ( fAnonymous ),
      _csecConnPool       ( csecConnPool ),
      _pSecDesc           ( NULL ),
      _pstrCols           ( NULL ),
      _nCharset           ( nCharset )
{
    if ( _strQueryFile.IsValid()  &&
         _plParams.ParsePairs( pszParameters, FALSE, FALSE, FALSE ))
    {
        _fValid = TRUE;
    }

    _cClientParams = _plParams.GetCount();

}

ODBC_REQ::~ODBC_REQ()
{
    Close();

    if ( _podbcstmt )
    {
        delete _podbcstmt;
    }

    if ( _cfiTemplateFile.pbData )
    {
        TCP_REQUIRE( CheckInCachedFile( _pCache,
                                        &_cfiTemplateFile ));
    }

    if ( _pbufOut )
    {
        delete _pbufOut;
    }

    if ( _pSecDesc )
    {
        LocalFree( _pSecDesc );
    }
}

BOOL
ODBC_REQ::OpenQueryFile(
    BOOL *                  pfAccessDenied,
    BOOL *                  pfFileNotFound
    )
{
    CHAR *            pchQueryFile;
    CACHE_FILE_INFO   CacheFileInfo;

    if ( !CheckOutCachedFile( _strQueryFile.QueryStr(),
                              _pCache,
                              _hToken,
                              (BYTE **) &pchQueryFile,
                              &_cbQueryFile,
                              _fAnonymous,
                              &CacheFileInfo,
                              _nCharset,
                              &_pSecDesc ))
    {
        DWORD dwE = GetLastError();

        // exclude URL/filename in error message 
        
        if ( dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE )
        {
            *pfAccessDenied = TRUE;
        }
        else
        {
            *pfFileNotFound = TRUE;     // all others are treated as not found 
        }

        return FALSE;
    }

    //
    //  CODEWORK - It is possible to avoid this copy by not modifying the
    //  contents of the query file.  Would save a buffer copy
    //

    if ( !_bufQueryFile.Resize( _cbQueryFile ))
    {
        return FALSE;
    }

    memcpy( _bufQueryFile.QueryPtr(),
            pchQueryFile,
            _cbQueryFile );

    TCP_REQUIRE( CheckInCachedFile( _pCache,
                                    &CacheFileInfo ));

    return TRUE;
}


BOOL
ODBC_REQ::ParseAndQuery(
    CHAR *  pszLoggedOnUser
    )
/*++

Routine Description:

    This method parses the query file and executes the SQL statement

Arguments:

    pchLoggedOnUser - The NT user account this user is running under

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    STACK_STR( strDatasource, 64 );
    STACK_STR( strUsername, 64 );
    STACK_STR( strPassword, 64 );
    CHAR *     pch;
    CHAR *     pchEnd;
    CHAR *     pszField;
    CHAR *     pszValue;
    BOOL       fRet;
    VOID *     pCookie = NULL;
    DWORD      csecPoolConnection = _csecConnPool;
    BOOL       fRetried;

    //
    //  We don't allow some security related parameters to be specified from
    //  the client so remove those now
    //

    _plParams.RemoveEntry( "REMOTE_USER" );
    _plParams.RemoveEntry( "LOGON_USER" );
    _plParams.RemoveEntry( "AUTH_USER" );

    //
    //  Do a quick Scan for the DefaultParameters value to fill in the blanks
    //  in the parameter list from the web browser
    //

    {
        pch = (CHAR *) _bufQueryFile.QueryPtr();
        pchEnd = pch + strlen(pch);

        INET_PARSER Parser( (CHAR *) _bufQueryFile.QueryPtr() );

        while ( (pszField = Parser.QueryToken()) < pchEnd )
        {
            if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                Parser.SkipTo( ':' );
                Parser += 1;
                Parser.EatWhite();

                if ( !_plParams.ParsePairs( Parser.QueryLine(), TRUE ))
                    return FALSE;

                break;
            }

            Parser.NextLine();
        }
    }

    //
    //  Replace any %XXX% fields with the corresponding parameter.  Note
    //  we reassign pch in case of a pointer shift during ReplaceParams
    //

    if ( !ReplaceParams( &_bufQueryFile,
                         &_plParams ))
    {
        return FALSE;
    }

    pch = (CHAR *) _bufQueryFile.QueryPtr();
    pchEnd = pch + strlen(pch);

    //
    //  Loop through the fields looking for values we recognize
    //

    {
        INET_PARSER Parser( pch );

        while ( (pszField = Parser.QueryToken()) < pchEnd )
        {
            //
            //  Ignore blank lines and Ctrl-Zs
            //

            if ( !*pszField || *pszField == 0x1a)
            {
                Parser.NextLine();
                continue;
            }

            Parser.SkipTo( ':' );
            Parser += 1;
            Parser.EatWhite();

            //
            //  Ignore comment fields
            //

            if ( *pszField == '#' || *pszField == ';' )
            {
                Parser.NextLine();
                continue;
            }

            if ( COMP_FIELD( "Datasource:", pszField, 11 ))
            {
                fRet = Parser.CopyToEOL( &strDatasource );
            }
            else if ( COMP_FIELD( "Username:", pszField, 9 ))
            {
                fRet = Parser.CopyToEOL( &strUsername );
            }
            else if ( COMP_FIELD( "Password:", pszField, 9 ))
            {
                fRet = Parser.CopyToEOL( &strPassword );
            }
            else if ( COMP_FIELD( "Template:", pszField, 9 ))
            {
                fRet = Parser.CopyToEOL( &_strTemplateFile );

                //
                //  Specifying a template of "Direct" means return the
                //  first column of data as raw data to the client
                //

                if ( !_stricmp( _strTemplateFile.QueryStr(), "Direct" ))
                {
                    _fDirect = TRUE;
                }
            }
            else if ( COMP_FIELD( "MaxFieldSize:", pszField, 13 ))
            {
                _cchMaxFieldSize = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "MaxRecords:", pszField, 11 ))
            {
                _cMaxRecords = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "RequiredParameters:", pszField, 12 ))
            {
                fRet = _plReqParams.ParseSimpleList( Parser.QueryLine() );
            }
            else if ( COMP_FIELD( "Content-Type:", pszField, 13 ))
            {
                fRet = Parser.CopyToEOL( &_strContentType );
            }
            else if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                //
                //  Ignore, already processed
                //
            }
            else if ( COMP_FIELD( "Expires:", pszField, 8 ))
            {
                _csecExpires = min( (DWORD) atoi( Parser.QueryPos() ),
                                    MAX_EXPIRES_TIME );
            }
            else if ( COMP_FIELD( "ODBCOptions:", pszField, 12 ))
            {
                fRet = Parser.CopyToEOL( &_strOdbcOptions );
            }
            else if ( COMP_FIELD( "ODBCConnection:", pszField, 15 ))
            {
                //
                //  Is there an override to the default?
                //

                if ( !_strnicmp( Parser.QueryToken(), "Pool", 4 ))
                {
                    if ( !csecPoolConnection )
                    {
                        // This is bogus - if somebody has turned off connection
                        // pooling on the vroot and enabled it in the idc,
                        // there's no defined way to set the timeout
                        // need to add a timeout here

                        csecPoolConnection = 30;
                    }
                }
                else if ( !_strnicmp( Parser.QueryToken(), "NoPool", 6 ))
                {
                    csecPoolConnection = 0;
                }
            }
            else if ( COMP_FIELD( "SQLStatement:", pszField, 13 ))
            {
                if ( _cQueries >= MAX_QUERIES )
                {
                    STR strError;
                    strError.FormatString( ODBCMSG_TOO_MANY_SQL_STATEMENTS,
                                           NULL,
                                           HTTP_ODBC_DLL );

                    SetErrorText( strError.QueryStr() );

                    return FALSE;
                }

                while ( TRUE )
                {
                    if ( !_strQueries[_cQueries].Append( Parser.QueryLine() ) )
                        return FALSE;

                    Parser.NextLine();

                    //
                    //  Line continuation is signified by putting a '+' at
                    //  the beginning of the line
                    //

                    if ( *Parser.QueryLine() == '+' )
                    {
                        if ( !_strQueries[_cQueries].Append( " " ))
                            return FALSE;

                        Parser += 1;
                    }
                    else
                    {
                        //
                        //  Ignore blank line
                        //

                        if ( !*Parser.QueryLine() &&
                             Parser.QueryLine() < pchEnd )
                        {
                            continue;
                        }
                        break;
                    }

                }

                _cQueries++;
                continue;
            }
            else if ( COMP_FIELD( IDC_FIELDNAME_CHARSET, pszField, sizeof(IDC_FIELDNAME_CHARSET)-1 ))
            {
                //
                // Ignore "Charset:" field
                //

                Parser.NextLine();
                continue;
            }
            else if ( COMP_FIELD( "TranslationFile:", pszField, 16 ))
            {
                fRet = Parser.CopyToEOL( &_strTranslationFile );
            }
            else
            {
                //
                //  Unrecognized field, generate an error
                //

                STR strError;
                LPCSTR apsz[1];

                apsz[0] = pszField;

                strError.FormatString( ODBCMSG_UNREC_FIELD,
                                       apsz,
                                       HTTP_ODBC_DLL );

                SetErrorText( strError.QueryStr() );

                fRet = FALSE;
            }

            if ( !fRet )
                return FALSE;

            Parser.NextLine();
        }
    }

    //
    //  Make sure the Datasource and SQLStatement fields are non-empty
    //

    if ( strDatasource.IsEmpty() || !_cQueries || _strQueries[0].IsEmpty() )
    {
        STR strError;
        strError.FormatString( ODBCMSG_DSN_AND_SQLSTATEMENT_REQ,
                               NULL,
                               HTTP_ODBC_DLL );

        SetErrorText( strError.QueryStr() );

        return FALSE;
    }

    //
    //  Make sure all of the required parameters have been supplied
    //

    while ( pCookie = _plReqParams.NextPair( pCookie,
                                             &pszField,
                                             &pszValue ))
    {
        if ( !_plParams.FindValue( pszField ))
        {
            STR strError;
            LPCSTR apsz[1];

            apsz[0] = pszField;

            if ( !strError.FormatString( ODBCMSG_MISSING_REQ_PARAM,
                                         apsz,
                                         HTTP_ODBC_DLL ))
            {
                return FALSE;
            }

            //
            //  Set the error text to return the user and indicate we couldn't
            //  continue the operation
            //

            SetErrorText( strError.QueryStr() );

            return FALSE;
        }
    }

    //
    //  Don't retry the connection/query if not pooling.  The reason
    //  we do the retry is to report the error that occurred (this
    //  requires the ODBC connection object).
    //

    fRetried = csecPoolConnection == 0;

RetryConnection:

    //
    //  Open the database
    //

    if ( !OpenConnection( &_odbcconn,
                          &_podbcconnPool,
                          csecPoolConnection,
                          strDatasource.QueryStr(),
                          strUsername.QueryStr(),
                          strPassword.QueryStr(),
                          pszLoggedOnUser )  ||
         !SetOdbcOptions( QueryOdbcConnection(), &_strOdbcOptions ) ||
         !(_podbcstmt = QueryOdbcConnection()->AllocStatement()) ||
         !_podbcstmt->ExecDirect( _strQueries[0].QueryStr(),
                                  _strQueries[0].QueryCCH() ))
    {

        //
        //  Delete the pooled connection and retry the open
        //

        if ( csecPoolConnection )
        {
            delete _podbcstmt;
            _podbcstmt = NULL;

            CloseConnection( _podbcconnPool,
                             TRUE );

            _podbcconnPool = NULL;
            csecPoolConnection = 0;
        }

        if ( !fRetried )
        {
            fRetried = TRUE;
            goto RetryConnection;
        }

        return FALSE;
    }

    return TRUE;
}


BOOL
ODBC_REQ::OutputResults(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    STR *             pstrHeaders,
    ODBC_REQ_HEADER   pfnSendHeader,
    BOOL              fIsAuth,
    BOOL *            pfAccessDenied,
    BOOL *            pfFileNotFound
    )
/*++

Routine Description:

    This method reads the template file and does the necessary
    result set column substitution

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD               cbOut;
    DWORD               cbFile, cbHigh;
    DWORD               BytesRead;
    TS_OPEN_FILE_INFO * pFile;
    DWORD               cbToSend;
    BOOL                fLastRow = FALSE;
    const CHAR *        pchStartDetail;
    const CHAR *        pchIn;
    const CHAR *        pchEOF;
    const CHAR *        pchBOF;
    CHAR *              pchTag;
    const CHAR *        pchValue;
    DWORD               cbValue;
    enum TAG_TYPE       TagType;
    DWORD               err;
    BOOL                fTriedRelative = FALSE;
    BOOL                fExpr;
    STR                 strError;
    const CHAR *        CharacterMap[256];
    BOOL                fIsSelect;
    BOOL                fMoreResults;
    BOOL                fHaveResultSet = FALSE;
    DWORD               iQuery = 1;

    //
    //  Set up the first buffer in the output chain
    //

    if ( !_pbufOut )
    {
        _pbufOut = new BUFFER_CHAIN_ITEM( OUTPUT_BUFFER_SIZE );

        if ( !_pbufOut ||
             !_pbufOut->QueryPtr() )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
    }

    if ( !_fDirect )
    {
        CHAR * pchLastSlash;
        STACK_STR( str, MAX_PATH);

TryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        if ( !CheckOutCachedFile( (fTriedRelative ? str.QueryStr() :
                                                   _strTemplateFile.QueryStr()),
                                  _pCache,
                                  _hToken,
                                  (BYTE **)&pchBOF,
                                  &BytesRead,
                                  _fAnonymous,
                                  &_cfiTemplateFile,
                                  _nCharset,
                                  NULL,
                                  TRUE ))
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                         ||
                 ((GetLastError() != ERROR_FILE_NOT_FOUND) &&
                  (GetLastError() != ERROR_PATH_NOT_FOUND)) ||
                 !str.Copy( _strQueryFile ) )
            {
                //STR strError;
                //LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                //  exclude URL/filename in error message 

                if ( (dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE) )
                {
                    *pfAccessDenied = TRUE;
                }
                else
                {
                    *pfFileNotFound = TRUE;  // return 404 not found 
                }

                return FALSE;
            }

            pchLastSlash = (PCHAR)_mbsrchr( (PUCHAR)str.QueryStr(), '\\' );

            if ( !pchLastSlash )
            {
                *pfFileNotFound = TRUE;  // return 404 not found 
                return FALSE;
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            if ( !str.Append( _strTemplateFile ))
            {
                *pfFileNotFound = TRUE;  // return 404 not found 
                return FALSE;
            }

            fTriedRelative = TRUE;
            goto TryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                if ( !_strTemplateFile.Copy( str ))
                    return FALSE;
            }
        }
    }

    //
    //  Open the translation file if one was specified
    //

    if ( !_strTranslationFile.IsEmpty() )
    {
        CACHE_FILE_INFO cfiTranslationFile;
        CHAR * pchLastSlash;
        CHAR * pchTranslationFile;
        STACK_STR( str, MAX_PATH);
        BOOL   fRet;
        VOID * pvCookie = NULL;
        CHAR * pchField;
        CHAR * pchValue;
        DWORD  cbRead;

        fTriedRelative = FALSE;

TranslationTryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        if ( !CheckOutCachedFile( (fTriedRelative ? str.QueryStr() :
                                                   _strTranslationFile.QueryStr()),
                                  _pCache,
                                  _hToken,
                                  (BYTE **)&pchTranslationFile,
                                  &cbRead,
                                  _fAnonymous,
                                  &cfiTranslationFile,
                                  _nCharset,
                                  NULL,
                                  TRUE))
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                         ||
                 (GetLastError() != ERROR_FILE_NOT_FOUND &&
                 GetLastError() != ERROR_PATH_NOT_FOUND) ||
                 !str.Copy( _strQueryFile ) )
            {
                STR strError;
                LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                //  exclude URL/filename in error message - WinSE 16872

                if ( (dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE) )
                {
                    *pfAccessDenied = TRUE;
                }
                else
                {
                    *pfFileNotFound = TRUE;
                }
                
                return FALSE;
            }

            pchLastSlash = (PCHAR)_mbsrchr( (PUCHAR)str.QueryStr(), '\\' );

            if ( !pchLastSlash )
            {
                *pfFileNotFound = TRUE;  // return 404 not found
                return FALSE;
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            if ( !str.Append( _strTranslationFile ))
            {
                *pfFileNotFound = TRUE;  // return 404 not found 
                return FALSE;
            }

            fTriedRelative = TRUE;
            goto TranslationTryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                if ( !_strTranslationFile.Copy( str ))
                    return FALSE;
            }
        }

        fRet = _plTransList.ParsePairs( pchTranslationFile,
                                        FALSE,
                                        TRUE,
                                        FALSE );

        TCP_REQUIRE( CheckInCachedFile( _pCache,
                                        &cfiTranslationFile ));

        if ( !fRet )
            return FALSE;

        //
        //  Build the character map
        //

        memset( CharacterMap, 0, sizeof(CharacterMap) );

        while ( pvCookie = _plTransList.NextPair( pvCookie,
                                                  &pchField,
                                                  &pchValue ))
        {
            CharacterMap[ (BYTE) *pchField] = pchValue;
        }
    }

    //
    //  We've already performed the first query at this point
    //

NextResultSet:

    //
    //  Get the list of column names in the initial result set.  The initial
    //  set must be initialized for compatibility with previous versions of
    //  IDC (i.e., column variables can be referenced outside the detail
    //  section).
    //

    if ( !_podbcstmt->QueryColNames( &_pstrCols,
                                     &_cCols,
                                     _cchMaxFieldSize,
                                     &fHaveResultSet ))
    {
        return FALSE;
    }

    if ( !fHaveResultSet )
    {
        //
        //  Check to see if there are anymore result sets for this query
        //

        if ( !_podbcstmt->MoreResults( &fMoreResults ) )
        {
            return FALSE;
        }

        if ( fMoreResults )
        {
            goto NextResultSet;
        }
        else if ( iQuery < _cQueries )
        {
            //
            //  If there are no more result sets, see if there
            //  are more queries.  Note calling SQLMoreResults
            //  will discard this result set
            //

            if ( !_podbcstmt->ExecDirect(
                               _strQueries[iQuery].QueryStr(),
                               _strQueries[iQuery].QueryCCH() ))
            {
                return FALSE;
            }

            iQuery++;

            goto NextResultSet;
        }
    }


    //
    //  Get the first row of values
    //

    if ( fHaveResultSet && !NextRow( &fLastRow ))
    {
        //
        //  Some SQL statements don't generate any rows (i.e.,
        //  insert, delete etc.).  So don't bail if there's a column in
        //  the result set
        //

        if ( !_cCols )
            return FALSE;
    }

    // Send reply header

    if ( !pfnSendHeader( pvContext, "200 OK", pstrHeaders->QueryStr() ) )
        return FALSE;

    //
    //  Copy the template to the output buffer while scanning for column
    //  fields that need to be replaced
    //

    #define SEND_DATA( pchData, cbData )  SendData( pfnCallback,   \
                                                    pvContext,     \
                                                    (pchData),     \
                                                    (DWORD)(cbData), \
                                                    &_pbufOut,     \
                                                    &cbOut )

    #define SEND_DATA_CHECK_ESC( pchData, cbData )  \
            ((TagType == TAG_TYPE_VALUE_TO_ESCAPE)  \
            ? SendEscapedData( pfnCallback,         \
                    pvContext,                      \
                    pchData,                        \
                    (DWORD)(cbData),                \
                    &cbOut )                        \
            : SEND_DATA( pchData,                   \
                    (DWORD)(cbData) ) )

    cbOut  = 0;
    pchStartDetail = NULL;
    pchIn  = pchBOF;
    pchEOF = pchBOF + BytesRead;

    while ( pchIn < pchEOF )
    {
        //
        //  Look for the start of a "<!--%" or <%" tag
        //

        pchTag = strchr( pchIn, '<' );

        if ( pchTag )
        {
            //
            //  Send any data preceding the tag
            //

            cbToSend = DIFF(pchTag - pchIn);

            if ( !SEND_DATA( pchIn, cbToSend) )
                return FALSE;

            pchIn += cbToSend;


            if ( !memcmp( pchTag, "<!--%", 5 ) ||
                 !memcmp( pchTag, "<%", 2 ))
            {
                //
                //  Is this a tag we care about?  pchIn is advanced except
                //  in the unknown case
                //

                LookupTag( pchTag,
                           &pchIn,
                           &pchValue,
                           &cbValue,
                           &TagType );

                switch( TagType )
                {
                case TAG_TYPE_VALUE:
                case TAG_TYPE_VALUE_TO_ESCAPE:

                    //
                    //  Map any characters if there was a translation file
                    //

                    if ( _strTranslationFile.IsEmpty() )
                    {
                        if ( !SEND_DATA_CHECK_ESC( pchValue, (DWORD) -1 ))
                            return FALSE;
                    }
                    else
                    {
                        const CHAR * pchStart = pchValue;

                        while ( *pchValue )
                        {
                            if ( CharacterMap[ (BYTE) *pchValue ] )
                            {
                                SEND_DATA_CHECK_ESC( pchStart,
                                        pchValue - pchStart );
                                SEND_DATA_CHECK_ESC(
                                        CharacterMap[ (BYTE) *pchValue],
                                        (DWORD) -1 );

                                pchStart = pchValue = pchValue + 1;
                            }
                            else
                            {
                                pchValue++;
                            }
                        }

                        SEND_DATA_CHECK_ESC( pchStart, pchValue - pchStart );
                    }

                    break;

                case TAG_TYPE_BEGIN_DETAIL:

                    //
                    //  If we don't have a result set, get one now
                    //

                    if ( !fHaveResultSet )
                    {
                        fLastRow = TRUE;
                        _podbcstmt->FreeColumnMemory();
                        _cCurrentRecordNum = 0;
                        _pstrCols = _pstrValues = NULL;

NextResultSet2:
                        if ( !_podbcstmt->MoreResults( &fMoreResults ) )
                        {
                            return FALSE;
                        }

                        if ( fMoreResults )
                        {
NewQuery:
                            if ( !_podbcstmt->QueryColNames( &_pstrCols,
                                                             &_cCols,
                                                             _cchMaxFieldSize,
                                                             &fHaveResultSet ))
                            {
                                return FALSE;
                            }

                            if ( !fHaveResultSet )
                                goto NextResultSet2;

                            if ( !NextRow( &fLastRow ))
                            {
                                //
                                //  Some SQL statements don't generate any rows (i.e.,
                                //  insert, delete etc.).  So don't bail if
                                //  there's a column in the result set
                                //

                                if ( !_cCols )
                                    return FALSE;
                            }
                        }
                        else if ( iQuery < _cQueries )
                        {
                            //
                            //  If there are no more result sets, see if there
                            //  are more queries.  Note calling SQLMoreResults
                            //  will discard this result set
                            //

                            if ( !_podbcstmt->ExecDirect(
                                               _strQueries[iQuery].QueryStr(),
                                               _strQueries[iQuery].QueryCCH() ))
                            {
                                return FALSE;
                            }

                            iQuery++;

                            goto NewQuery;
                        }
                    }

                    if ( !fLastRow )
                    {
                        pchStartDetail = pchIn;
                    }
                    else
                    {
                        //
                        //  If no more data, then skip the detail section
                        //

                        SkipToTag( &pchIn, END_DETAIL_TEXT );

                        fHaveResultSet = FALSE;
                    }

                    break;

                case TAG_TYPE_END_DETAIL:

                    if ( !NextRow( &fLastRow ))
                        return FALSE;

                    _cCurrentRecordNum++;

                    if ( !fLastRow && _cCurrentRecordNum < _cMaxRecords )
                        pchIn = pchStartDetail;
                    else
                        fHaveResultSet = FALSE;

                    break;

                case TAG_TYPE_IF:

                    //
                    //  pchIn points to the first character of the expression
                    //  on the way in, the first character after the tag on the
                    //  way out
                    //

                    if ( !EvaluateExpression( (const CHAR * *) &pchIn, &fExpr ))
                        return FALSE;

                    //
                    //  If the expression is FALSE, then skip the intervening
                    //  data till the endif tag
                    //

                    if ( !fExpr )
                    {
                        //
                        //  Look for a closing else or endif
                        //

                        if ( SkipConditionalBlock( &pchIn, pchEOF, ELSE_TEXT ) )
                            _cNestedIfs++;
                    }
                    else
                    {
                        _cNestedIfs++;
                    }
                    break;

                case TAG_TYPE_ELSE:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  else w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ELSES,
                                               NULL,
                                               HTTP_ODBC_DLL );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    //
                    //  We got here because we just finished processing a
                    //  TRUE expression, so skip the else portion of the if
                    //

                    SkipConditionalBlock( &pchIn, pchEOF, NULL );

                    _cNestedIfs--;
                    break;

                case TAG_TYPE_END_IF:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  endif w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ENDIFS,
                                               NULL,
                                               HTTP_ODBC_DLL );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    _cNestedIfs--;
                    break;

                default:
                case TAG_TYPE_UNKNOWN:
                    goto UnknownTag;

                }
            }
            else
            {
UnknownTag:
                //
                //  Move past the beginning of the tag so the next
                //  search skips this tag
                //

                if ( !SEND_DATA( pchIn, 1 ))
                    return FALSE;

                pchIn += 1;
            }
        }
        else
        {
            //
            //  No more tags, copy the rest of the data to the output
            //  buffer.
            //

            if ( !SEND_DATA( pchIn, (DWORD) -1 ))
                return FALSE;

            break;
        }
    }

    //
    //  Send the last of the data and append the last buffer chain if we're
    //  caching
    //

    err = pfnCallback( pvContext,
                       (CHAR *) _pbufOut->QueryPtr(),
                       cbOut );

    if ( err )
    {
        SetLastError( err );
        goto ErrorExit;
    }

    if ( IsCacheable() )
    {
        if ( !_buffchain.AppendBuffer( _pbufOut ))
            goto ErrorExit;

        _pbufOut->SetUsed( cbOut );

        _pbufOut = NULL;
    }


    return TRUE;

ErrorExit:

    //
    //  We've already sent the HTTP headers at this point, so just append the
    //  error text to the end of this document.
    //

    {
        STR str;
        STR strError;

        if ( !GetLastErrorText( &strError )                      ||
             !str.Append( "<h1>Error performing operation</h1>") ||
             !str.Append( strError ) ||
             !str.Append( "</body>"))
        {
            return FALSE;
        }

        err = pfnCallback( pvContext,
                           str.QueryStr(),
                           str.QueryCB() );

        if ( err )
        {
            return FALSE;
        }
    }

    return TRUE;

}

BOOL
ODBC_REQ::OutputCachedResults(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext
    )
/*++

Routine Description:

    This method outputs the saved results of a query from a previous request

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BUFFER_CHAIN_ITEM * pBCI = NULL;
    DWORD               err;

    while ( pBCI = _buffchain.NextBuffer( pBCI ))
    {
        err = pfnCallback( pvContext,
                           (CHAR *) pBCI->QueryPtr(),
                           pBCI->QueryUsed() );

        if ( err )
        {
            SetLastError( err );
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
ODBC_REQ::NextRow(
    BOOL * pfLast
    )
/*++

Routine Description:

    Advances the result set to the next row

Arguments:

    pfLast - Set to TRUE if there is no more data

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return _podbcstmt->QueryValuesAsStr( &_pstrValues,
                                         &_pcbValues,
                                         pfLast );
}

BOOL
ODBC_REQ::ReplaceParams(
    BUFFER * pbufFile,
    PARAM_LIST* pParamList
    )
/*++

Routine Description:

    This method looks at the query file and replaces any occurrences
    of %xxx% with the specified replacement value from pszParams

Arguments:

    pbufFile - Contents of file buffer
    ParamList - List of parameters to replace in the query file

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD      cParams = 0;
    CHAR *     pch;
    BOOL       fRet = FALSE;
    BOOL       fIsMultiValue;
    CHAR *     pchValue;
    CHAR *     pchTag;
    CHAR *     pchTerm;
    CHAR *     pchOldPointer;
    CHAR *     pchTmp;
    STACK_STR( strMultiValue, MAX_PATH);
    DWORD      cbFile;
    DWORD      cbTag;
    DWORD      cbValue;

    //
    //  Scan the query file looking for %xxx% replacements
    //

    pch = pchOldPointer = (CHAR *) pbufFile->QueryPtr();
    cbFile = strlen( pch ) + sizeof(TCHAR);

    while ( *pch )
    {
        if ( (pchTag = strchr( pch, '%' )) &&
             (pchTerm = strchr( pchTag + 1, '%' )) )
        {
            *pchTerm = '\0';

            //
            //  Was this a '%' escape (i.e., '%%')?
            //

            if ( (pchTag + 1) == pchTerm )
            {
                pchValue = "%";
                goto Found;
            }

            //
            //  Look through the replacement list for a matching param
            //

            pchValue = pParamList->FindValue( pchTag + 1, &fIsMultiValue );

            if ( !pchValue )
            {
                //
                //  Check to see if it's something the client has defined
                //

                if ( _pfnClientFindSymbol != NULL &&
                     _pfnClientFindSymbol( _pFindSymbolContext,
                                           pchTag + 1,
                                           &_strSymbolValue ))
                {
                    if ( !_strSymbolValue.IsEmpty() )
                    {
                        pchValue = _strSymbolValue.QueryStr();
                        fIsMultiValue = FALSE;
                        goto Found;
                    }
                }

                //
                //  We didn't find a match, nuke the tag
                //

                memmove( pchTag,
                         pchTerm + 1,
                         strlen( pchTerm + 1 ) + sizeof(TCHAR));

                pch = pchTag;
                continue;
            }

Found:

            if ( fIsMultiValue )
            {
                //
                //  Determine whether this is a quoted multi-value or not
                //

                pchTmp = pchTag;

                while ( --pchTmp >= pchOldPointer && ISWHITE( *pchTmp ))
                {
                    ;
                }

                if ( !BuildMultiValue( pchValue,
                                       &strMultiValue,
                                       *pchTmp == '\'' ))
                {
                    return FALSE;
                }

                pchValue = strMultiValue.QueryStr();
            }

            //
            //  We have a match, replace the tag with the value.
            //  Note we count the surrounding '%'s with cbTag.
            //

            cbTag    = DIFF(pchTerm - pchTag) + sizeof(TCHAR);
            cbValue  = strlen( pchValue );

            if ( cbValue > cbTag )
            {
                //
                //  Resize if needed but watch for pointer shift
                //

                if ( pbufFile->QuerySize() < (cbFile + cbValue - cbTag))
                {
                    if ( !pbufFile->Resize( cbFile + cbValue - cbTag, 512 ))
                        goto Exit;

                    if ( pbufFile->QueryPtr() != pchOldPointer )
                    {
                        CHAR * pchNewPointer = (TCHAR *) pbufFile->QueryPtr();
                        DWORD  cchLen = strlen( pchNewPointer);

                        pch     = pchNewPointer + (pch - pchOldPointer);
                        pchTag  = pchNewPointer + (pchTag - pchOldPointer);
                        pchTerm = pchNewPointer + (pchTerm - pchOldPointer);
                        pchOldPointer = pchNewPointer;

                        TCP_ASSERT( pch >= pchNewPointer &&
                                   pch < pchNewPointer + cchLen);
                        TCP_ASSERT( pchTag >= pchNewPointer &&
                                   pchTag < pchNewPointer + cchLen);
                        TCP_ASSERT( pchTerm >= pchNewPointer &&
                                   pchTerm <= pchNewPointer + cchLen);
                    }
                }

                //
                //  Expand the space for the value
                //

                memmove( pchTerm + 1 + cbValue - cbTag,
                         pchTerm + 1,
                         strlen( pchTerm + 1 ) + sizeof(TCHAR) );

                cbFile += cbValue - cbTag;
            }
            else
            {
                //
                //  Collapse the space since tag is longer then the value
                //

                memmove( pchTag + cbValue,
                         pchTerm + 1,
                         strlen(pchTerm + 1) + sizeof(TCHAR) );

                cbFile -= cbTag - cbValue;
            }

            //
            //  Replace the tag value with the replacement value
            //

            memcpy( pchTag,
                    pchValue,
                    cbValue );
            pch = pchTag + cbValue;
        }
        else
        {
            //
            //  No more tags to replace so get out
            //

            break;
        }
    }

    fRet = TRUE;

Exit:

    return fRet;
}

VOID
ODBC_REQ::LookupTag(
    CHAR *          pchBeginTag,
    const CHAR * *  ppchAfterTag,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue,
    enum TAG_TYPE * pTagType
    )
/*++

Routine Description:

    This method looks at the tag, determines the tag type and
    returns the associated value.  This is used only for the .htx file.

Arguments:

    pchBeginTag - Points to first character of tag (i.e., '<')
    ppchAfterTag - Receives the first character after the tag if
        the tag
    ppchValue - If the tag is a value, returns the database value
    pcbValue - Receives number of bytes in the value being returned
    pTagType - Returns the tag type

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR * pchTerm;
    BOOL   fLongTagMarker;
    STACK_STR( strTagName, 128);
    DWORD  cchToCopy;
    BOOL   fDoEsc = FALSE;

    *pTagType = TAG_TYPE_UNKNOWN;
    *ppchAfterTag = pchBeginTag;
    *pcbValue = (DWORD) -1;

    TCP_ASSERT( !memcmp( pchBeginTag, "<!--%", 5 ) ||
                !memcmp( pchBeginTag, "<%", 2 ));

    fLongTagMarker = pchBeginTag[1] == '!';

    //
    //  Move past the tag marker
    //

    pchBeginTag += (fLongTagMarker ? 5 : 2);

    if ( *pchBeginTag == '"' )
    {
        if ( !memcmp( pchBeginTag, "\"%z\",", sizeof("\"%z\",") - 1 ) )
        {
            fDoEsc = TRUE;
            pchBeginTag += sizeof("\"%z\",") - 1;
        }
        else
        {
            return;
        }
    }

    //
    //  Find the end of the tag and make a copy.
    //

    pchTerm = strchr( pchBeginTag, '%' );

    if ( !pchTerm )
        return;

    cchToCopy = DIFF(pchTerm - pchBeginTag);

    if ( !strTagName.Copy( pchBeginTag, cchToCopy * sizeof( TCHAR )))
        return;

    LookupSymbol( strTagName.QueryStr(),
                  pTagType,
                  ppchValue,
                  pcbValue );

    if ( fDoEsc && *pTagType == TAG_TYPE_VALUE )
    {
        *pTagType = TAG_TYPE_VALUE_TO_ESCAPE;
    }

    if ( *pTagType != TAG_TYPE_IF )
    {
        *ppchAfterTag = pchTerm + (fLongTagMarker ? 4 : 2);
    }
    else
    {
        //
        //  We leave the pointer on the expression if this was an if
        //

        *ppchAfterTag = NEXT_TOKEN(pchBeginTag);
    }

    *pchTerm = '%';
}

BOOL
ODBC_REQ::LookupSymbol(
    const CHAR *    pchSymbolName,
    enum TAG_TYPE * pTagType,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue
    )
/*++

Routine Description:

    Looks to see if the specified symbol name is defined and what the type
    value of the symbol is.

    The "if" symbols is special cased to allow the expression to follow it

    If the symbol is a multi-value field (from command line) then the tabs
    in the value in will be replaced by commas.

Arguments:

    pchSymbolName - Name of zero terminated symbol to find
    pTagType - Returns the tag type of the symbol
    ppchValue - Returns a pointer to the string value of the symbol
        if it has one
    pcbValue - Returns length of value

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL fIsMultiValue;

    //
    //  Does the symbol match one of the column names?
    //

    if ( _pstrCols && _pstrValues )
    {
        for ( DWORD i = 0; i < _cCols; i++ )
        {
            if ( !lstrcmpi( _pstrCols[i].QueryStr(),
                           pchSymbolName ))
            {
                *pTagType = TAG_TYPE_VALUE;
                *ppchValue = _pstrValues[i].QueryStr();
                *pcbValue  = _pcbValues[i];

                //
                //  BugID 33406 - Don't return half DBCS char at end of data
                //

                if ( g_fIsSystemDBCS )
                {
                    CHAR * pch;
                    for ( pch = (CHAR *)*ppchValue; *pch; pch++ )
                    {
                        if ( IsDBCSLeadByte( *pch ) )
                        {
                            if ( !*(pch+1) )
                            {
                                *pch = '\0';
                                (*pcbValue)--;
                                break;
                            }
                            pch++;
                        }
                    }
                }
                goto Found;
            }
        }
    }

    //
    //  Does it match any of the special values?
    //

    if ( !_stricmp( pchSymbolName, BEGIN_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_BEGIN_DETAIL;
        goto Found;
    }
    else if ( !_stricmp( pchSymbolName, END_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_END_DETAIL;
        goto Found;
    }
    else if ( !_strnicmp( pchSymbolName, IF_TEXT, sizeof(IF_TEXT) - 1 ))
    {
        //
        //  The IF tag is treated a little bit differently cause we expect
        //  the expression to be included as part of the symbol
        //

        *pTagType = TAG_TYPE_IF;
        goto Found;
    }
    else if ( !_stricmp( pchSymbolName, END_IF_TEXT ))
    {
        *pTagType = TAG_TYPE_END_IF;
        goto Found;
    }
    else if ( !_stricmp( pchSymbolName, ELSE_TEXT ))
    {
        *pTagType = TAG_TYPE_ELSE;
        goto Found;
    }

    //
    //  Is it one of the parameters from the query (either one of the form
    //  fields or from the DefaultParameters field in the wdg file)?  These
    //  must be prefixed by "idc.", that is "<%idc.Assign%>"
    //

    if ( !_strnicmp( pchSymbolName, "idc.", 4 )    &&
         (*ppchValue = _plParams.FindValue( pchSymbolName + 4,
                                            &fIsMultiValue,
                                            pcbValue )))
    {
        *pTagType = TAG_TYPE_VALUE;

        //
        //  If this is a multi-value field, replace all the tabs with commas.
        //  This is somewhat of a hack as it breaks the use of this field when
        //  multiple queries are supported
        //

        if ( fIsMultiValue )
        {
            CHAR * pchtmp = (CHAR *) *ppchValue;

            while ( pchtmp = strchr( pchtmp, '\t' ))
            {
                *pchtmp = ',';
            }
        }

        goto Found;
    }

    //
    //  Lastly, check to see if it's something the client has defined
    //

    if ( _pfnClientFindSymbol != NULL &&
         _pfnClientFindSymbol( _pFindSymbolContext,
                               pchSymbolName,
                               &_strSymbolValue ))
    {
        if ( !_strSymbolValue.IsEmpty() )
        {
            *pTagType  = TAG_TYPE_VALUE;
            *ppchValue = _strSymbolValue.QueryStr();
            *pcbValue  = _strSymbolValue.QueryCB();
            goto Found;
        }
    }

Found:
    return TRUE;
}

BOOL
ODBC_REQ::EvaluateExpression(
    const CHAR * * ppchExpression,
    BOOL *         pfExprValue
    )
/*++

Routine Description:

    Performs simple expression evaluation for an 'if' tag in the
    template file.  Valid expressions are:

    <%if <V1> <OP> <V2>%>

    where V1, V2 can be one of:
        Positive integer
        TotalRecords - Total records contained in result set
        MaxRecords - The maximum records specified in the query file

    OP can be one of:
        EQ - Equal
        LT - Less then
        GT - Greater then

Arguments:

    ppchExpression - Points to V1 on entry, set to the first character
        after the end tag on exit
    pfExprValue - TRUE if the expression is TRUE, FALSE otherwise

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    EXPR_VALUE v1( this );
    EXPR_VALUE v2( this );
    TAG_TYPE   OpType;
    STR        strError;
    CHAR *     pch;

    if ( !v1.Evaluate( ppchExpression )               ||
         !EvaluateOperator( ppchExpression, &OpType ) ||
         !v2.Evaluate( ppchExpression ))
    {
        return FALSE;
    }

    //
    //  If the symbols weren't found, default them to empty
    //  strings
    //

    if ( v1.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v1.SetType( TAG_TYPE_STRING );
    }

    if ( v2.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v2.SetType( TAG_TYPE_STRING );
    }

    //
    //  The value types must match
    //

    if ( v1.QueryType() != v2.QueryType() )
    {
        BOOL fSt = FALSE;

        if ( v1.QueryType() == TAG_TYPE_STRING && v2.QueryType() == TAG_TYPE_INTEGER )
            fSt = v1.ConvertToInteger();
        else if ( v1.QueryType() == TAG_TYPE_INTEGER && v2.QueryType() == TAG_TYPE_STRING )
            fSt = v2.ConvertToInteger();

        if ( !fSt )
        {
            strError.FormatString( ODBCMSG_MISMATCHED_VALUES,
                                   NULL,
                                   HTTP_ODBC_DLL );
            SetErrorText( strError.QueryStr());

            return FALSE;
        }
    }

    //
    //  Move the current position to the end of this tag
    //

    if ( pch = strchr( *ppchExpression, '>' ))
    {
        *ppchExpression = pch + 1;
    }

    switch ( OpType )
    {
    case TAG_TYPE_OP_LT:

        *pfExprValue = v1.LT( v2 );
        break;

    case TAG_TYPE_OP_GT:

        *pfExprValue = v1.GT( v2 );
        break;

    case TAG_TYPE_OP_EQ:

        *pfExprValue = v1.EQ( v2 );
        break;

    case TAG_TYPE_OP_CONTAINS:

        //
        //  Contains is only valid for string values
        //

        if ( v1.QueryType() != TAG_TYPE_STRING )
        {
            strError.FormatString( ODBCMSG_CONTAINS_ONLY_VALID_ON_STRINGS,
                                   NULL,
                                   HTTP_ODBC_DLL );
            SetErrorText( strError.QueryStr());

            return FALSE;
        }

        *pfExprValue = v1.CONTAINS( v2 );
        break;

    default:

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    return TRUE;
}

BOOL
ODBC_REQ::EvaluateOperator(
    const CHAR * * ppchExpression,
    TAG_TYPE *     pTagType
    )
/*++

Routine Description:

    Determines which operator is being used in this expression

Arguments:

    ppchExpression - Points to the operator on entry, set to the
        next token on exit
    pTagType - Receives operator type

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( COMP_FIELD( *ppchExpression, "GT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_GT;
    }
    else if ( COMP_FIELD( *ppchExpression, "LT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_LT;
    }
    else if ( COMP_FIELD( *ppchExpression, "EQ", 2 ))
    {
        *pTagType = TAG_TYPE_OP_EQ;
    }
    else if ( COMP_FIELD( *ppchExpression, "CONTAINS", 8 ))
    {
        *pTagType = TAG_TYPE_OP_CONTAINS;
    }
    else
    {
        //
        //  Unknown operator specified
        //

        STR strError;

        strError.FormatString( ODBCMSG_UNRECOGNIZED_OPERATOR,
                               NULL,
                               HTTP_ODBC_DLL );
        SetErrorText( strError.QueryStr());
        return FALSE;
    }

    *ppchExpression = NEXT_TOKEN( *ppchExpression );

    return TRUE;
}

BOOL
ODBC_REQ::SendData(
    ODBC_REQ_CALLBACK        pfnCallback,
    PVOID                    pvContext,
    const CHAR *             pbData,
    DWORD                    cbData,
    BUFFER_CHAIN_ITEM  * *   ppbufOut,
    DWORD *                  pcbOut
    )
/*++

Routine Description:

    This method buffers the outgoing data and sends it when the
    output buffer is full

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pbData - Pointer to data to send
    cbData - Number of bytes to send
    ppbufOut - Output buffer to buffer nonsent and cached data in
    pcbOut - Number of valid bytes in output buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD               cbToCopy;
    DWORD               err;
    BUFFER_CHAIN_ITEM * pbufOut = *ppbufOut;
    STACK_STR(          strTemp, MAX_PATH);

    //
    //  if cbData is -1 then assume the data is zero terminated
    //

    if ( cbData == -1 )
        cbData = strlen( pbData );

    //
    //  Convert the string from shift_jis to iso-2022-jp or euc-jp
    //

    if ( CODE_ONLY_SBCS != _nCharset )
    {
        int cbUNIXSize;
        int nResult;

        //
        //  Get the size after Conversion
        //

        cbUNIXSize = PC_to_UNIX(
                            GetACP(),
                            _nCharset,
                            (UCHAR *)pbData,
                            (int)cbData,
                            NULL,
                            0 );

        if ( !strTemp.Resize( cbUNIXSize + sizeof(TCHAR) ))
            return FALSE;

        //
        //  Do conversion
        //

        nResult = PC_to_UNIX(
                            GetACP(),
                            _nCharset,
                            (UCHAR *)pbData,
                            (int)cbData,
                            (UCHAR *)strTemp.QueryStr(),
                            cbUNIXSize );
        if ( -1 == nResult || nResult != cbUNIXSize )
            return FALSE;

        //
        //  update the string pointer and count
        //

        pbData = strTemp.QueryStr();
        cbData = cbUNIXSize;

        *(strTemp.QueryStr() + cbUNIXSize) = '\0';
    }

    //
    //  Append the new data onto the old data
    //

    cbToCopy = min( cbData, OUTPUT_BUFFER_SIZE - *pcbOut );

    memcpy( (BYTE *) pbufOut->QueryPtr() + *pcbOut,
            pbData,
            cbToCopy );

    *pcbOut += cbToCopy;
    cbData  -= cbToCopy;
    pbData  += cbToCopy;

    //
    //  If we filled up the buffer, send the data
    //

    if ( cbData )
    {
        err = pfnCallback( pvContext,
                           (CHAR *) pbufOut->QueryPtr(),
                           *pcbOut );

        if ( err )
        {
            SetLastError( err );
            return FALSE;
        }

        //
        //  If we're caching, add this buffer chain and create a new one
        //

        if ( IsCacheable() )
        {
            if ( !_buffchain.AppendBuffer( pbufOut ))
            {
                return FALSE;
            }

            pbufOut->SetUsed( *pcbOut );

            pbufOut = *ppbufOut = new BUFFER_CHAIN_ITEM( OUTPUT_BUFFER_SIZE );

            if ( !pbufOut ||
                 !pbufOut->QueryPtr() )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return FALSE;
            }
        }

        *pcbOut = 0;
    }
    else
    {
        return TRUE;
    }

    //
    //  We know at this point the output buffer is empty
    //

    while ( cbData )
    {
        //
        //  If the input data will fill the output buffer, send the
        //  data directly from the input buffer
        //

        if ( cbData > OUTPUT_BUFFER_SIZE  )
        {
            err = pfnCallback( pvContext,
                               pbData,
                               OUTPUT_BUFFER_SIZE );

            if ( err )
            {
                SetLastError( err );
                return FALSE;
            }

            //
            //  If we're caching, add this buffer chain and create a new one
            //

            if ( IsCacheable() )
            {
                memcpy( pbufOut->QueryPtr(),
                        pbData,
                        OUTPUT_BUFFER_SIZE );

                if ( !_buffchain.AppendBuffer( pbufOut ))
                {
                    return FALSE;
                }

                pbufOut->SetUsed( OUTPUT_BUFFER_SIZE );

                pbufOut = *ppbufOut = new BUFFER_CHAIN_ITEM( OUTPUT_BUFFER_SIZE );

                if ( !pbufOut ||
                     !pbufOut->QueryPtr() )
                {
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    return FALSE;
                }
            }

            cbData -= OUTPUT_BUFFER_SIZE;
            pbData += OUTPUT_BUFFER_SIZE;
        }
        else
        {
            //
            //  We don't have enough to send so put it in the output buffer
            //

            memcpy( pbufOut->QueryPtr(),
                    pbData,
                    cbData );

            *pcbOut = cbData;
            break;
        }
    }

    return TRUE;
}


BOOL
ODBC_REQ::SkipConditionalBlock(
    const CHAR * *  ppchIn,
    const CHAR *    pchEOF,
    const CHAR *    pchSearchTag
    )
/*++

Routine Description:

    Skip a conditional block delimited by ENDIF or specified Tag
    returns TRUE if specified Tag found instead of ENDIF or end of text

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchIf;
    const CHAR * pchEndif;
    const CHAR * pchTag;
    int cLev = 0;

    for ( ; pchIn < pchEOF ; )
    {
        pchEndif = pchIf = pchIn;
        SkipToTag( &pchIf, IF_TEXT );
        SkipToTag( &pchEndif, END_IF_TEXT );
        if ( pchSearchTag == NULL )
            pchTag = pchEOF;
        else
        {
            pchTag = pchIn;
            SkipToTag( &pchTag,  pchSearchTag );
        }
        if ( pchIf < pchTag && pchIf < pchEndif )
        {
            ++cLev;
            pchIn = pchIf;
        }
        else if ( pchTag < pchIf && pchTag < pchEndif )
        {
            if ( !cLev )
            {
                *ppchIn = pchTag;
                return TRUE;
            }
            pchIn = pchTag;
        }
        else    // END_IF_TEXT or nothing found
        {
            if ( !cLev )
            {
                *ppchIn = pchEndif;
                return FALSE;
            }
            --cLev;
            pchIn = pchEndif;
        }
    }

    // else/endif not found

    *ppchIn = pchEOF;

    return FALSE;
}


VOID
ODBC_REQ::SkipToTag(
    const CHAR * *  ppchIn,
    const CHAR *    pchTag
    )
/*++

Routine Description:

    Given the name of a tag, skips to the first character after the tag

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    DWORD  cchTag;

    cchTag = strlen( pchTag );

    while ( pchIn = strchr( pchIn, '<' ))
    {
        if ( (!memcmp( pchIn, "<!--%", 5 ) ||
              !memcmp( pchIn, "<%", 2 ))   &&
              !_strnicmp( pchIn + (pchIn[1] == '!' ? 5 : 2),
                         pchTag,
                         cchTag ))
        {
            goto Found;
        }
        else
            pchIn++;
    }

    //
    //  Not found, return the end of file
    //

    *ppchIn += strlen( *ppchIn );

    return;

Found:

    pchIn = strchr( pchIn + cchTag, '>' );
    if ( !pchIn )
    {
        *ppchIn += strlen( *ppchIn );
    }
    else
    {
        *ppchIn = pchIn + 1;
    }

    return;
}

BOOL
ODBC_REQ::IsEqual(
    ODBC_REQ * podbcreq
    )
/*++

Routine Description:

    Determines if the passed query's parameter would make it equivalent
    to this query

    A query is deemed equal if:

        1) The query has the same number of parameters passed from the client
        2) The query's parameters match

    Note parameter comparison is case insensitive for both the field and the
    value

    The template can be different if it's parameterized, but we'll pick up the
    difference in the parameter list in this case.

    Since podbcreq is a query that has already been processed, it may contain
    additional values from the .wdg default list.

Arguments:

    podbcreq - Query to check for equality

--*/
{
    VOID * pCookie = NULL;
    CHAR * pszField;
    CHAR * pszValue1, * pszValue2;

    //
    //  First compare the number of parameters passed from the client
    //

    if ( QueryClientParamCount() != podbcreq->QueryClientParamCount() )
    {
        return FALSE;
    }

    //
    //  Walk the list of parameters making sure they all match
    //

    while ( pCookie = podbcreq->_plParams.NextPair( pCookie,
                                                    &pszField,
                                                    &pszValue1 ))
    {
        if ( !(pszValue2 = _plParams.FindValue( pszField )) ||
              lstrcmpi( pszValue1, pszValue2 ))
        {
            //
            //  Either the value wasn't found or it doesn't match,
            //  the queries are not equal
            //

            return FALSE;
        }
    }

    //
    //  The queries are equal
    //

    return TRUE;
}

BOOL
ODBC_REQ::AppendHeaders(
    STR * pstrHeaders
    )
/*++

Routine Description:

    Adds any headers required for this query, this will generally be
    the content type and an Expires header if this query is cached

Arguments:

    pstrHeaders - String to append headers to

--*/
{
    CHAR *     pszTail;

    if ( !pstrHeaders->Resize( 255 ))
    {
        return FALSE;
    }

    pszTail = pstrHeaders->QueryStr();

    //
    //  If we're caching this query, indicate when the data will expire
    //

    if ( IsCacheable() )
    {
        CHAR achTime[64];

        //
        //  If we haven't filled in the expires member yet, do it now
        //

        if ( _strExpiresTime.IsEmpty() )
        {
            SYSTEMTIME SysTime;
            DWORD      dwTickCount;

            //
            //  Get the current time and add the offset
            //

            GetSystemTime( &SysTime );

            if ( !SystemTimeToGMTEx( SysTime,
                                     achTime,
                                     sizeof(achTime),
                                     _csecExpires ))
            {
                return FALSE;
            }

            _csecExpiresAt = (GetTickCount()/1000) + _csecExpires;

            if ( !_strExpiresTime.Resize( sizeof(achTime) + 20 ))
                return FALSE;

            wsprintf( _strExpiresTime.QueryStr(),
                      "Expires: %s\r\n",
                      achTime );
        }

        strcat( pszTail, _strExpiresTime.QueryStr() );
        pszTail += strlen( pszTail );
    }

    pszTail += wsprintf( pszTail,
                         "Content-Type: %s\r\n\r\n",
                         QueryContentType() );

    return TRUE;
}

BOOL
ODBC_REQ::GetLastErrorText(
    STR * pstrError
    )
{
    //
    //  If we stored an error explanation return that, otherwise fall back
    //  to an ODBC error
    //

    if ( !_strErrorText.IsEmpty() )
    {
        return pstrError->Copy( _strErrorText );
    }
    else if ( _podbcstmt )
        return _podbcstmt->GetLastErrorTextAsHtml( pstrError );
    else
        return QueryOdbcConnection()->GetLastErrorTextAsHtml( pstrError,
                                       SQL_NULL_HSTMT,
                                       QueryOdbcConnection()->QueryErrorCode() );
}

BOOL
EXPR_VALUE::ConvertToInteger(
    VOID )
{
    if ( _tagType == TAG_TYPE_STRING )
    {
        PSTR pS =_strValue.QueryStr();
        if ( *pS == '-' || isdigit(*(UCHAR *)pS) )
        {
            _dwValue = atoi( pS );
            _tagType = TAG_TYPE_INTEGER;

            return TRUE;
        }
    }

    return FALSE;
}

BOOL
EXPR_VALUE::Evaluate(
    const CHAR * * ppchIn
    )
/*++

Routine Description:

    Determines the type of value and retrieves the value appropriately

Arguments:

    ppchIn - Pointer to first character of value on way in, next token
        on they way out

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchEnd;
    const CHAR * pchValue;
    DWORD        cbValue;
    STR          strError;
    DWORD        cchToCopy;

    if ( isdigit( *(UCHAR *)pchIn ) )
    {
        //
        //  Simple number
        //

        _tagType = TAG_TYPE_INTEGER;
        _dwValue = atoi( pchIn );
        while ( isdigit( *(UCHAR *)pchIn ) )
        {
            pchIn++;
        }

        *ppchIn  = SkipWhite( pchIn );
    }
    else if ( *pchIn == '"' )
    {
        //
        //  Simple string, find the closing quote
        //

        pchEnd = strchr( ++pchIn, '\"' );

        if ( !pchEnd )
        {
            strError.FormatString( ODBCMSG_UNBALANCED_STRING,
                                   NULL,
                                   HTTP_ODBC_DLL );
            _podbcreq->SetErrorText( strError.QueryStr());

            return FALSE;
        }

        cchToCopy = DIFF(pchEnd - pchIn);

        if ( !_strValue.Copy( pchIn, cchToCopy * sizeof(CHAR) ))
        {
            return FALSE;
        }

        _tagType = TAG_TYPE_STRING;
        *ppchIn = SkipWhite( pchEnd + 1 );
    }
    else
    {
        STACK_STR( strSymbol, 64 );
        DWORD cchToCopy;

        //
        //  This is a keyword we need to interpret
        //

        //
        //  These fields are delimited with either white space
        //  or '\'' or the closing %>
        //

        pchEnd = pchIn;

        if ( *pchEnd == '\'' )
        {
            ++pchIn;
            ++pchEnd;
            while ( *pchEnd && *pchEnd != '\'' && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }
        else
        {
            while ( *pchEnd && !ISWHITE( *pchEnd ) && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }

        if ( COMP_FIELD( "MaxRecords", pchIn, 10 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryMaxRecords();
        }
        else if ( COMP_FIELD( "CurrentRecord", pchIn, 12 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryCurrentRecordNum();
        }
        else
        {
            //
            //  Isolate the symbol name
            //

            cchToCopy = DIFF(pchEnd - pchIn);

            if ( !strSymbol.Copy( pchIn, cchToCopy * sizeof(CHAR)))
                return FALSE;

            //
            //  Look up the symbol
            //

            if ( !_podbcreq->LookupSymbol( strSymbol.QueryStr(),
                                           &_tagType,
                                           &pchValue,
                                           &cbValue ))
            {
                return FALSE;
            }

            if ( _tagType == TAG_TYPE_VALUE ||
                 _tagType == TAG_TYPE_STRING )
            {
                if ( !_strValue.Copy( pchValue ))
                    return FALSE;

                _tagType = TAG_TYPE_STRING;
            }
        }

        if ( *pchEnd == '\'' )
        {
            ++pchEnd;
        }

        *ppchIn = SkipWhite( pchEnd );
    }

    return TRUE;
}

BOOL
EXPR_VALUE::GT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Greater Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() > v1.QueryInteger();
    }
    else
    {
        return lstrcmpi( QueryStr(), v1.QueryStr() ) > 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::LT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Less Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() < v1.QueryInteger();
    }
    else
    {
        return lstrcmpi( QueryStr(), v1.QueryStr() ) < 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::EQ(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Equal to v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() == v1.QueryInteger();
    }
    else
    {
        return lstrcmpi( QueryStr(), v1.QueryStr() ) == 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::CONTAINS(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this contains the string in v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() != TAG_TYPE_STRING     ||
         v1.QueryType() != TAG_TYPE_STRING )
    {
        return FALSE;
    }

    //
    //  Upper case the strings then do a search
    //

    UpperCase();
    v1.UpperCase();

    return strstr( QueryStr(), v1.QueryStr() ) != NULL;
}


const CHAR * SkipNonWhite( const CHAR * pch )
{
    while ( *pch && !ISWHITE( *pch ) && *pch != '\n' )
        pch++;

    return pch;
}

const CHAR * SkipTo( const CHAR * pch, CHAR ch )
{
    while ( *pch && *pch != '\n' && *pch != ch )
        pch++;

    return pch;
}

const CHAR * SkipWhite( const CHAR * pch )
{
    while ( ISWHITE( *pch ) )
    {
        pch++;
    }

    return pch;
}

struct _ODBC_OPTIONS
{
    CHAR *   pszOptionName;
    DWORD    dwOption;
    BOOL     fNumeric;
}

OdbcOptions[] =
{
    //
    //  Order roughly in order of likelihood of being used
    //

    "SQL_OPT_TRACEFILE",       SQL_OPT_TRACEFILE,     FALSE,
    "SQL_QUERY_TIMEOUT",       SQL_QUERY_TIMEOUT,     TRUE,
    "SQL_MAX_ROWS",            SQL_MAX_ROWS,          TRUE,
    "SQL_LOGIN_TIMEOUT",       SQL_LOGIN_TIMEOUT,     TRUE,
    "SQL_PACKET_SIZE",         SQL_PACKET_SIZE,       TRUE,

    "SQL_NOSCAN",              SQL_NOSCAN,            TRUE,
    "SQL_MAX_LENGTH",          SQL_MAX_LENGTH,        TRUE,
    "SQL_ASYNC_ENABLE",        SQL_ASYNC_ENABLE,      TRUE,
    "SQL_ACCESS_MODE",         SQL_ACCESS_MODE,       TRUE,
    "SQL_OPT_TRACE",           SQL_OPT_TRACE,         TRUE,
    "SQL_TRANSLATE_OPTION",    SQL_TRANSLATE_OPTION,  TRUE,
    "SQL_TXN_ISOLATION",       SQL_TXN_ISOLATION,     TRUE,
    "SQL_TRANSLATE_DLL",       SQL_TRANSLATE_DLL,     FALSE,
    "SQL_CURRENT_QUALIFIER",   SQL_CURRENT_QUALIFIER, FALSE,
    NULL,                      0,                     0
};

BOOL
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STR *             pStrOptions
    )
/*++

Routine Description:

    Sets the options specified in the OdbcOptions: keyword of the .wdg file

Arguments:

    pOdbcConn - ODBC connection to set options on
    pStrOptions - List of options in "v=f,y=z" format.  Note that if the


--*/
{
    PARAM_LIST OptionList;
    VOID *     pvCookie = NULL;
    CHAR *     pszField;
    CHAR *     pszValue;
    DWORD      dwOption = 0;
    SQLPOINTER pSQLValue;
    DWORD      i;

    if ( !OptionList.ParsePairs( pStrOptions->QueryStr(),
                                 FALSE,
                                 FALSE ))
    {
        return FALSE;
    }

    while ( pvCookie = OptionList.NextPair( pvCookie,
                                            &pszField,
                                            &pszValue ))
    {
        //
        //  If the field is a digit, then this is a driver specific option.
        //  convert the value and field as appropriate,
        //  otherwise look it up in our option table
        //

        if ( isdigit( *(UCHAR *)pszField ))
        {
            pSQLValue = (SQLPOINTER)UIntToPtr(atoi( pszField ));

            if ( isdigit( *(UCHAR *)pszValue ))
            {
                pSQLValue = (SQLPOINTER)UIntToPtr(atoi( pszValue ));
            }
            else
            {
                pSQLValue = (SQLPOINTER)pszValue;
            }
        }
        else
        {
            i = 0;

            while ( OdbcOptions[i].pszOptionName )
            {
                if ( !_stricmp( OdbcOptions[i].pszOptionName,
                               pszField ))
                {
                    goto Found;
                }

                i++;
            }

            //
            //  Not found, skip this value
            //

            continue;

Found:
            dwOption = OdbcOptions[i].dwOption;

            if ( OdbcOptions[i].fNumeric )
            {
                //
                //  Numeric option, convert the value
                //

                pSQLValue = (SQLPOINTER)UIntToPtr(atoi( pszValue ));
            }
            else
            {
                pSQLValue = (SQLPOINTER) pszValue;
            }
        }

        pOdbcConn->SetConnectOption( (UWORD) dwOption, pSQLValue );
    }

    return TRUE;
}

BOOL
BuildMultiValue(
    const CHAR * pchValue,
    STR *        pstrMulti,
    BOOL         fQuoteElements
    )
{
    CHAR * pchtmp = (CHAR *) pchValue;
    DWORD  cElements = 0;

    //
    //  If we're going to have to expand the size of the string, figure out
    //  the total size we'll need now
    //

    if ( fQuoteElements )
    {
        while ( pchtmp = strchr( pchtmp, '\t' ))
        {
            cElements++;
            pchtmp++;
        }

        if ( !pstrMulti->Resize( strlen( pchValue ) + 1 + 2 * cElements ))
            return FALSE;
    }

    if ( !pstrMulti->Copy( pchValue ))
        return FALSE;

    //
    //  Replace tabs with "','" if fQuoteElements is TRUE, otherwise just ','
    //

    pchtmp = pstrMulti->QueryStr();

    while ( pchtmp = strchr( pchtmp, '\t' ))
    {
        if ( fQuoteElements )
        {
            memmove( pchtmp + 3,
                     pchtmp + 1,
                     strlen( pchtmp + 1 ) + sizeof(CHAR));

            memcpy( pchtmp, "','", 3 );
        }
        else
        {
            *pchtmp = ',';
        }
    }

    return TRUE;
}


//
//  Converts a value between zero and fifteen to the appropriate hex digit
//

#define HEXDIGIT( nDigit )                              \
    (TCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')


BOOL ODBC_REQ::SendEscapedData(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    PCSTR pch,
    DWORD cbIn,
    LPDWORD pcbOut )
/*++

Routine Description:

    This method escape the outgoing data and then send it to the
    SendData() function

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pch - Pointer to data to send
    cbIn - Number of bytes to send
    pcbOut - Number of valid bytes in output buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR    ch;
    int     cNonEscaped = 0;
    DWORD   cbOut;


    #define SEND_DATA2( pchData, cbData )  SendData( pfnCallback,  \
                                                    pvContext,     \
                                                    (pchData),     \
                                                    (cbData),      \
                                                    &_pbufOut,     \
                                                    pcbOut )

    if ( cbIn == (DWORD)-1 )
    {
        cbIn = strlen( pch );
    }

    while ( cbIn-- )
    {
        ch = *pch;

        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&')) &&
             !(ch == TEXT('\n') || ch == TEXT('\r'))  )
        {
            TCHAR achTmp[3];

            //
            //  Insert the escape character
            //

            achTmp[0] = TEXT('%');

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            achTmp[2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            achTmp[1] = HEXDIGIT( nDigit );

            if ( cNonEscaped && !SEND_DATA2( pch-cNonEscaped, cNonEscaped ) )
            {
                return FALSE;
            }

            if ( !SEND_DATA2( achTmp, sizeof(achTmp) ) )
            {
                return FALSE;
            }

            cNonEscaped = 0;
        }
        else
        {
            ++cNonEscaped;
        }

        ++pch;
    }

    if ( cNonEscaped && !SEND_DATA2( pch-cNonEscaped, cNonEscaped ) )
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc\main.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    This is the HTTP ODBC gateway

Author:

    John Ludeman (johnl)   20-Feb-1995

Revision History:
--*/

#include <iis64.h>
#include <w3p.hxx>
#include <tsunami.hxx>
#include <odbcconn.hxx>
#include <festrcnv.h>

# include "dbgutil.h"

DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisOdbcGuid, 
0x784d8936, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif


extern "C" {
#include <httpext.h>

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}
#include <qrycache.hxx>
#include <odbcmsg.h>
#include <odbcreq.hxx>

//
//  Globals
//

BOOL           g_fIsSystemDBCS;        // Is this system DBCS?

//
//  Prototypes
//

BOOL
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,
    PW3_SERVER_INSTANCE       pInstance,
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    HTTP_REQUEST *            pReq,
    STR *                     pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied,
    BOOL *                    pfFileNotFound
    );

DWORD
OdbcExtensionOutput(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchOutput,
    DWORD                     cbOutput
    );

BOOL
OdbcExtensionHeader(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchStatus,
    const CHAR *              pchHeaders
    );

BOOL LookupHttpSymbols(
    HTTP_REQUEST * pRequest,
    const CHAR *   pszSymbolName,
    STR *          pstrSymbolValue
    );

BOOL
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STR *          pstrError
    );

BOOL
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STR *          pstrParams
    );

BOOL
IsSystemDBCS(
    VOID
    );

DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    STACK_STR(     strPath, MAX_PATH);
    STACK_STR(     strParams, MAX_PATH);
    STR            strError;
    CHAR *         pch;
    DWORD          cch;
    HTTP_REQUEST * pReq;
    PW3_SERVER_INSTANCE pInstance;
    int            nCharset;

    TCP_REQUIRE(( pecb->ServerSupportFunction( pecb->ConnID,
                                               HSE_PRIV_REQ_HTTP_REQUEST,
                                               &pReq,
                                               NULL,
                                               NULL )));

    //
    //  Make sure ODBC is loaded
    //

    if ( !LoadODBC() )
    {
        STR str;

        str.FormatString( ODBCMSG_CANT_LOAD_ODBC,
                          NULL,
                          HTTP_ODBC_DLL );

        pecb->ServerSupportFunction( pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER,
                            "500 Unable to load ODBC",
                            NULL,
                            (LPDWORD) str.QueryStr() );

        pecb->dwHttpStatusCode = 500;

        return HSE_STATUS_ERROR;
    }

    //
    //  We currently only support the GET and POST methods
    //

    if ( !strcmp( pecb->lpszMethod, "POST" ))
    {
        if ( _stricmp( pecb->lpszContentType,
                      "application/x-www-form-urlencoded" ))
        {
            goto BadRequest;
        }

        //
        //  The query params are in the extra data, add a few bytes in case
        //  we need to double "'"
        //

        if ( !strParams.Resize( pecb->cbAvailable + sizeof(TCHAR) + 3))
            return HSE_STATUS_ERROR;

        strParams.Copy( (const char * ) pecb->lpbData, pecb->cbAvailable);
    }
    else if ( !strcmp( pecb->lpszMethod, "GET" ))
    {
        if ( !strParams.Copy( pecb->lpszQueryString  ))
            return HSE_STATUS_ERROR;
    }
    else
    {
BadRequest:

        STR str;

        str.FormatString( ODBCMSG_UNSUPPORTED_METHOD,
                          NULL,
                          HTTP_ODBC_DLL );

        pecb->ServerSupportFunction(
                            pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER,
                            "400 Unsupported method",
                            NULL,
                            (LPDWORD) str.QueryStr() );

        pecb->dwHttpStatusCode = 400;

        return HSE_STATUS_ERROR;
    }

    //
    //  "Charset" field is enabled for CP932 (Japanese) only in this version.
    //

    if ( 932 != GetACP() )
    {
        nCharset = CODE_ONLY_SBCS;
    }
    else
    {
        //
        //  Get the charset from .idc file
        //

        if ( !GetIDCCharset( pecb->lpszPathTranslated, &nCharset, &strError ) )
        {
            if (strError.IsEmpty())
            {
                // WinSE 27595  DoS when requesting non-existant .idc file on JPN version 
                pecb->ServerSupportFunction( pecb->ConnID,
                         HSE_REQ_SEND_RESPONSE_HEADER,
                         (LPDWORD) "404 File Not Found",
                         NULL,
                         NULL );

                pecb->dwHttpStatusCode = 404;

                return HSE_STATUS_ERROR;
            }

            STR str;
            LPCSTR apsz[1];

            apsz[0] = strError.QueryStr();

            str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                              apsz,
                              HTTP_ODBC_DLL,
                              1024 + strError.QueryCB() );

            pecb->ServerSupportFunction( pecb->ConnID,
                                         HSE_REQ_SEND_RESPONSE_HEADER,
                                         (LPDWORD) "500 Error performing query",
                                         NULL,
                                         (LPDWORD) str.QueryStr() );

            pecb->dwHttpStatusCode = 500;

            return HSE_STATUS_ERROR;
        }

        if ( strParams.QueryCB() )
        {
            if ( CODE_ONLY_SBCS != nCharset )
            {
                //
                //  Convert the charset of Parameters to SJIS
                //

                if ( !ConvertUrlEncodedStringToSJIS( nCharset, &strParams ) )
                {
                    STR strError;
                    STR str;

                    strError.LoadString( GetLastError(), (LPCTSTR) NULL );

                    str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                                      NULL,
                                      HTTP_ODBC_DLL );

                    pecb->ServerSupportFunction( pecb->ConnID,
                                                 HSE_REQ_SEND_RESPONSE_HEADER,
                                                 (LPDWORD) "500 Error performing Query",
                                                 NULL,
                                                 (LPDWORD) str.QueryStr() );

                    pecb->dwHttpStatusCode = 500;

                    return HSE_STATUS_ERROR;
                }
            }
        }
    }

    //
    //  Walk the parameter string to do three things:
    //
    //    1) Double all single quotes to prevent SQL quoting problem
    //    2) Remove escaped '\n's so we don't break parameter parsing later on
    //    3) Replace all '&' parameter delimiters with real '\n' so escaped
    //       '&'s won't get confused later on
    //

    pch = strParams.QueryStr();
    cch = strParams.QueryCCH();

    while ( *pch )
    {
        switch ( *pch )
        {
        case '%':
            if ( pch[1] == '0' && toupper(pch[2]) == 'A' )
            {
                pch[1] = '2';
                pch[2] = '0';
                pch += 3;
            }
            else if ( pch[1] == '2' && pch[2] == '7' )
            {
                //
                //  This is an escaped single quote
                //

                if ( strParams.QuerySize() < (cch + 4) )  // Include null
                {
                    DWORD Pos = DIFF(pch - strParams.QueryStr());

                    if ( !strParams.Resize( cch + 4 ) )
                        return HSE_STATUS_ERROR;

                    //
                    //  Adjust for possible pointer shift
                    //

                    pch = strParams.QueryStr() + Pos;
                }

                //
                //  Note the memory copy just doubles the existing quote
                //

                memmove( pch+3,
                         pch,
                         (cch + 1) - DIFF(pch - strParams.QueryStr()) );

                cch += 3;          // Adjust for the additional '%27'
                pch += 6;          // skip old and new %27
            }
            else
            {
                pch +=1;
            }

            break;

        case '\'':
            if ( strParams.QuerySize() < (cch + 2) )
            {
                DWORD Pos = DIFF(pch - strParams.QueryStr());

                if ( !strParams.Resize( cch + 2 ) )
                    return HSE_STATUS_ERROR;

                //
                //  Adjust for possible pointer shift
                //

                pch = strParams.QueryStr() + Pos;
            }

            //
            //  Note the memory copy just doubles the existing quote
            //

            memmove( pch+1,
                     pch,
                     (cch + 1) - DIFF(pch - strParams.QueryStr()) );

            pch += 2;
            cch++;          // Adjust for the additional '''
            break;

        case '&':
            *pch = '\n';
            pch++;
            break;

        default:
            pch++;
        }
    }

    //
    //  Get the TSVC_INFO object from the HTTP server
    //

#if 0
    TCP_REQUIRE(( pecb->ServerSupportFunction( pecb->ConnID,
                                               HSE_PRIV_REQ_TSVCINFO,
                                               &pInetSvc,
                                               NULL,
                                               NULL )));
#else

    pInstance = pReq->QueryClientConn()->QueryW3Instance();

#endif

    //
    //  The path info contains the location of the query file
    //

    if ( !strPath.Copy( pecb->lpszPathTranslated ))
        return HSE_STATUS_ERROR;

    FlipSlashes( strPath.QueryStr() );

    //
    //  Attempt the query
    //

    BOOL fFileNotFound = FALSE;	
    BOOL fAccessDenied = FALSE;

    if ( !DoQuery( pecb,
                   pInstance,
                   strPath.QueryStr(),
                   strParams.QueryStr(),
                   pReq,
                   &strError,
                   nCharset,
                   &fAccessDenied,
                   &fFileNotFound ))
    {
        if ( fAccessDenied )
        {
            pecb->ServerSupportFunction( pecb->ConnID,
                     HSE_REQ_SEND_RESPONSE_HEADER,
                     (LPDWORD) "401 Authentication Required",
                     NULL,
                     NULL );

            pecb->dwHttpStatusCode = 401;

            return HSE_STATUS_ERROR;
        }
        else if (fFileNotFound)		
        {
            pecb->ServerSupportFunction( pecb->ConnID,
                     HSE_REQ_SEND_RESPONSE_HEADER,
                     (LPDWORD) "404 File Not Found",
                     NULL,
                     NULL );

            pecb->dwHttpStatusCode = 404;

            return HSE_STATUS_ERROR;
        }
        else
        {
            STR str;
            LPCSTR apsz[1];

            apsz[0] = strError.QueryStr();

            //
            //  Note we terminate the error message (ODBC sometimes generates
            //  22k errors) *and* we double the buffer size we pass to FormatString()
            //  because the win32 API FormatMessage() has a bug that doesn't
            //  account for Unicode conversion
            //

            if ( strlen( apsz[0] ) > 1024 ) {
                ((LPSTR)apsz[0])[1024] = '\0';
            }

            str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                              apsz,
                              HTTP_ODBC_DLL,
                              1024 + strError.QueryCB() );

            pecb->ServerSupportFunction( pecb->ConnID,
                     HSE_REQ_SEND_RESPONSE_HEADER,
                     (LPDWORD) "500 Error performing query",
                     NULL,
                     (LPDWORD) str.QueryStr() );

            pecb->dwHttpStatusCode = 500;

            return HSE_STATUS_ERROR;
        }
    }

    return HSE_STATUS_SUCCESS;
}

BOOL
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,
    PW3_SERVER_INSTANCE       pInstance,
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    HTTP_REQUEST *            pReq,
    STR *                     pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied,
    BOOL *                    pfFileNotFound
    )
/*++

Routine Description:

    Performs the actual query or retrieves the same query from the query
    cache

Arguments:

    pecb - Extension context
    pTsvcInfo - Server info class
    pszQueryFile - .wdg file to use for query
    pszParamList - Client supplied param list
    pReq - Http request this query is for
    pstrError - Error text to return errors in
    pfAccessDenied - Set to TRUE if the user was denied access

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    ODBC_REQ *              podbcreq;
    ODBC_REQ *              podbcreqCached;
    VOID *                  pvCacheCookie = NULL;
    BOOL                    fRet = TRUE;
    STACK_STR(              strHeaders, MAX_PATH);
    CHAR                    achPragmas[250];
    DWORD                   cbPragmas = sizeof(achPragmas);
    BOOL                    fRetrieveFromCache = TRUE;
    HANDLE                  hToken;
    PSECURITY_DESCRIPTOR    pSecDesc = NULL;

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_GET_IMPERSONATION_TOKEN,
                                       &hToken,
                                       NULL,
                                       NULL ) )
    {
        return FALSE;;
    }

    //
    //  Create an odbc request as we will either use it for the query or
    //  as the key for the cache lookup
    //

    podbcreq = new ODBC_REQ( &pInstance->GetTsvcCache(),
                             pszQueryFile,
                             pecb->lpszPathInfo,
                             pszParamList,
                             pReq->IsAnonymous(),
                             hToken,
                             pReq->QueryMetaData()->QueryPoolIDCTimeout(),
                             (ODBC_REQ_FIND_SYMBOL) LookupHttpSymbols,
                             (VOID *) pReq,
                             nCharset );

    if ( !podbcreq ||
         !podbcreq->IsValid() )
    {
        pstrError->LoadString( GetLastError() );

        delete podbcreq;
        return FALSE;
    }

    //
    //  Check to see if user already authentified
    //

    CHAR  achLoggedOnUser[UNLEN + 1];
    DWORD dwLoggedOnUser = sizeof( achLoggedOnUser );
    BOOL  fIsAuth = pecb->GetServerVariable( (HCONN)pecb->ConnID,
                                             "LOGON_USER",
                                             achLoggedOnUser,
                                             &dwLoggedOnUser ) &&
                                             achLoggedOnUser[0] != '\0';

    //
    //  Check to see if the client specified "Pragma: no-cache"
    //

    if ( pecb->GetServerVariable( pecb->ConnID,
                                  "HTTP_PRAGMA",
                                  achPragmas,
                                  &cbPragmas ))
    {
        CHAR * pch;

        //
        //  Look for "no-cache"
        //

        pch = _strupr( achPragmas );

        while ( pch = strchr( pch, 'N' ))
        {
            if ( !memcmp( pch, "NO-CACHE", 8 ))
            {
                fRetrieveFromCache = FALSE;
                goto Found;
            }

            pch++;
        }
    }

Found:

    //
    //  Is this query in the cache?
    //

    if ( !fRetrieveFromCache         ||
         !CheckOutQuery( podbcreq,
                         &pvCacheCookie,
                         &podbcreqCached ))
    {
        if ( fRetrieveFromCache && GetLastError() == ERROR_ACCESS_DENIED )
        {
            *pfAccessDenied = TRUE;
            fRet = FALSE;
            goto Exit;
        }

        DWORD CurChangeCounter;

        //
        //  This query isn't cached, do the query
        //

        //
        //  Get the current change counter.  If it's different after doing
        //  the query then an .htx or .idc file has changed so don't cache it
        //

        CurChangeCounter = GetChangeCounter();

        //
        //  Open the query file and do the query
        //

        if ( !podbcreq->OpenQueryFile( pfAccessDenied, pfFileNotFound )  ||
             !podbcreq->ParseAndQuery( achLoggedOnUser )                 ||
             !podbcreq->AppendHeaders( &strHeaders )                     ||
             !podbcreq->OutputResults( (ODBC_REQ_CALLBACK) OdbcExtensionOutput,
                                       pecb, &strHeaders,
                                       (ODBC_REQ_HEADER) OdbcExtensionHeader,
                                       fIsAuth,
                                       pfAccessDenied,
                                       pfFileNotFound) )
        {
            fRet = FALSE;
            goto Exit;
        }

        //
        //  If the query can't be cached (no "Expires:" field for example) then
        //  delete it now and get out
        //

        if ( !podbcreq->IsCacheable() )
        {
            delete podbcreq;
            goto Exit;
        }
        else
        {
            //
            //  Close the odbc handles now that we have all of the data
            //

            podbcreq->Close();
        }

        //
        //  Now attempt to add the query to the cache.
        //

        if ( !AddQuery( podbcreq,
                        CurChangeCounter ))
        {
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                *pfAccessDenied = TRUE;
            }
            delete podbcreq;
            goto Exit;
        }
    }
    else
    {
        //
        //  We already have an equivalent query in our cache, use it instead
        //

        delete podbcreq;

        podbcreq = podbcreqCached;

        if ( !podbcreq->AppendHeaders( &strHeaders )        ||
             !pecb->ServerSupportFunction( pecb->ConnID,
                                           HSE_REQ_SEND_RESPONSE_HEADER,
                                           (LPDWORD) "200 OK",
                                           NULL,
                                           (LPDWORD) strHeaders.QueryStr()) ||
             !podbcreq->OutputCachedResults( (ODBC_REQ_CALLBACK) OdbcExtensionOutput,
                                             pecb ) )
        {
            fRet = FALSE;
            goto Exit;
        }
    }

Exit:

    if ( !fRet )
    {
        podbcreq->GetLastErrorText( pstrError );

        //
        //  If we didn't cache this request, then delete it
        //

        if ( !pvCacheCookie )
        {
            delete podbcreq;
        }
    }

    if ( pvCacheCookie )
    {
        TCP_REQUIRE( CheckInQuery( pvCacheCookie ) );
    }

    if ( pSecDesc )
    {
        LocalFree( pSecDesc );
    }

    return fRet;
}


DWORD OdbcExtensionOutput( EXTENSION_CONTROL_BLOCK * pecb,
                           const CHAR *              pchOutput,
                           DWORD                     cbOutput )
{
    if ( !pecb->WriteClient( pecb->ConnID,
                             (VOID *) pchOutput,
                             &cbOutput,
                             0 ))

    {
        return GetLastError();
    }

    return NO_ERROR;
}


BOOL OdbcExtensionHeader( EXTENSION_CONTROL_BLOCK * pecb,
                           const CHAR *              pchStatus,
                           const CHAR *              pchHeaders )
{
    return pecb->ServerSupportFunction(
                pecb->ConnID,
                HSE_REQ_SEND_RESPONSE_HEADER,
                (LPDWORD) "200 OK",
                NULL,
                (LPDWORD) pchHeaders );
}


BOOL LookupHttpSymbols(
    HTTP_REQUEST * pRequest,
    const CHAR *   pszSymbolName,
    STR *          pstrSymbolValue
    )
{
    //
    //  Terminate the string if necessary
    //

    if ( !pstrSymbolValue->IsEmpty() )
    {
        *pstrSymbolValue->QueryStr() = '\0';
    }

    //
    //  Get any defined variables from this request
    //

    return pRequest->GetInfo( pszSymbolName,
                              pstrSymbolValue );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    DWORD  err;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( "httpodbc.dll");
        SET_DEBUG_FLAGS( 0);
#else
        CREATE_DEBUG_PRINT_OBJECT( "httpodbc.dll", IisOdbcGuid);
#endif

        if ( !InitializeQueryCache() ||
             !InitializeOdbcPool() )
        {
            return FALSE;
        }

        DisableThreadLibraryCalls( hDll );
        g_fIsSystemDBCS = IsSystemDBCS();
        break;

    case DLL_PROCESS_DETACH:

        TerminateQueryCache();
        TerminateOdbcPool();
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }

    return TRUE;
}

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 0, 2 );
    strcpy( pver->lpszExtensionDesc,
            "Microsoft HTTP ODBC Gateway, v2.0" );

    return TRUE;
}


CHAR * skipwhite( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        if ( ' ' != ch && '\t' != ch )
            break;
        ++pch;
    }

    return pch;
}


CHAR * nextline( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        ++pch;

        if ( '\n' == ch )
        {
            break;
        }
    }

    return pch;
}


BOOL
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STR *          pstrError
    )
{
    BUFFER           buff;
    HANDLE           hFile;
    DWORD            dwSize;
    CACHE_FILE_INFO  CacheFileInfo;

#define QUERYFILE_READSIZE  4096

    if ( !pnCharset )
        return FALSE;
    *pnCharset = CODE_ONLY_SBCS;

    if ( !buff.Resize( QUERYFILE_READSIZE + sizeof(TCHAR) ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        pstrError->LoadString( GetLastError() );
        return FALSE;
    }

    hFile = CreateFile(
                    pszPath,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        pstrError->Reset();    //WinSE 27595

        return FALSE;
    }

    if ( !ReadFile( hFile, buff.QueryPtr(), QUERYFILE_READSIZE, &dwSize, NULL ) )
    {
        pstrError->LoadString( GetLastError() );
        CloseHandle( hFile );
        return FALSE;
    }

    CloseHandle( hFile );

    *((CHAR *) buff.QueryPtr() + dwSize) = '\0';

    CHAR * pch = (CHAR *)buff.QueryPtr();  // we know that this is null terminated!

    while ( *pch )
    {
        pch = skipwhite( pch );

        if ( 'C' == toupper( *pch ) && !_strnicmp( IDC_FIELDNAME_CHARSET, pch, sizeof(IDC_FIELDNAME_CHARSET)-1 ) )
        {
            pch += sizeof(IDC_FIELDNAME_CHARSET) - 1;
            pch = skipwhite( pch );
            if ( 932 == GetACP() )
            {
                if ( !_strnicmp( IDC_CHARSET_JIS1, pch, sizeof(IDC_CHARSET_JIS1)-1 ) ||
                     !_strnicmp( IDC_CHARSET_JIS2, pch, sizeof(IDC_CHARSET_JIS2)-1 ) )
                {
                    *pnCharset = CODE_JPN_JIS;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_EUCJP, pch, sizeof(IDC_CHARSET_EUCJP)-1 ))
                {
                    *pnCharset = CODE_JPN_EUC;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_SJIS, pch, sizeof(IDC_CHARSET_SJIS)-1 ))
                {
                    *pnCharset = CODE_ONLY_SBCS;
                    break;
                }
                else
                {
                    LPCSTR apsz[1];
                    //
                    //  illegal value for Charset: field
                    //
                    apsz[0] = pszPath;
                    pstrError->FormatString( ODBCMSG_UNREC_FIELD,
                                           apsz,
                                           HTTP_ODBC_DLL );
                    return FALSE;
                }
            }

//
//          please add code here to support other FE character encoding(FEFEFE)
//
//          else if ( 949 == GetACP() )
//          ...

        }
        pch = nextline( pch );
    }

    return TRUE;
}


BOOL
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STR *          pstrParams
    )
{
    STACK_STR( strTemp, MAX_PATH);
    int cbSJISSize;
    int nResult;

    //
    //  Pre-process the URL encoded parameters
    //

    for ( char * pch = pstrParams->QueryStr(); *pch; ++pch )
    {
        if ( *pch == '&' )
            *pch = '\n';
        else if ( *pch == '+' )
            *pch = ' ';
    }

    //
    //  URL decoding (decode %nn only)
    //

    pstrParams->Unescape();

    //
    //  charset conversion
    //

//    if ( !pstrParams->Clone( &strTemp ) )
    if ( !strTemp.Copy( pstrParams->QueryStr() ) )
        return FALSE;

    cbSJISSize = UNIX_to_PC(
                            GetACP(),
                            nCharset,
                            (UCHAR *)strTemp.QueryStr(),
                            strTemp.QueryCB(),
                            NULL,
                            0 );

    if ( !pstrParams->Resize( cbSJISSize + sizeof(TCHAR) ) )
        return FALSE;

    nResult = UNIX_to_PC(
                            GetACP(),
                            nCharset,
                            (UCHAR *)strTemp.QueryStr(),
                            strTemp.QueryCB(),
                            (UCHAR *)pstrParams->QueryStr(),
                            cbSJISSize );
    if ( -1 == nResult || nResult != cbSJISSize )
        return FALSE;

    DBG_REQUIRE ( pstrParams->SetLen( cbSJISSize));

    //
    //  URL encoding
    //

    if ( !pstrParams->Escape() )
        return FALSE;

    return TRUE;
}


BOOL
IsSystemDBCS(
    VOID )
{
    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    return ( wPrimaryLangID == LANG_JAPANESE ||
             wPrimaryLangID == LANG_CHINESE ||
             wPrimaryLangID == LANG_KOREAN );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc\qrycache.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qrycache.cxx

Abstract:

    This file contains the code for caching ODBC queries

Author:

    John Ludeman (johnl)   27-Jun-1995

Revision History:

--*/

# include "dbgutil.h"

#include <tcpdll.hxx>
#include <tsunami.hxx>
#include <odbcconn.hxx>
#include <parmlist.hxx>

#include <odbcmsg.h>
#include <odbcreq.hxx>
#include <qrycache.hxx>
#include <decnotif.hxx>

//
//  Manifests
//

//
//  Query Cache lock.  Controls access to all items
//

#define LockQueryCache()        EnterCriticalSection( &csQueryCacheLock )
#define UnlockQueryCache()      LeaveCriticalSection( &csQueryCacheLock )


//
//  Global data
//

//
//  Gets incremented everytime any cached .wdg file or .htx file changes.  Acts
//  as a serial number so we can avoid holding the critical section across
//  queries
//

DWORD            cCacheChangeCounter;

//
//  Locks the Query Cache List and Decache Notification List
//

CRITICAL_SECTION csQueryCacheLock;

//
//  Private prototypes
//

BOOL
FreeQCLCacheBlob(
    VOID * pvCacheBlob
    );

//
//  An instance of a particular query with unique parameters.  Note this
//  object does not deal with its _ListEntry, it relies on the container
//  object.
//

class QUERY_CACHE_ITEM
{
public:

    QUERY_CACHE_ITEM( ODBC_REQ * podbcreq );
    ~QUERY_CACHE_ITEM();

    ODBC_REQ * QueryQuery( VOID ) const
        { return _podbcreq; }

    BOOL IsQueryEqual( ODBC_REQ * podbcreq ) const
        { return _podbcreq->IsEqual( podbcreq ); }

    DWORD QueryAllocatedBytes( VOID ) const
        { return _podbcreq->QueryAllocatedBytes(); }

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_QCI; }

    BOOL IsExpired( DWORD csecSysUpTime )
        { return _podbcreq->IsExpired( csecSysUpTime ); }

    VOID RemoveFromList( BOOL fRemoveNotif )
    {
        TCP_ASSERT( CheckSignature() );

        //
        //  Remove this cache item from the list and set its flink to NULL.
        //  This indicates the item should not be removed from the cache
        //  list again
        //

        RemoveEntryList( &_ListEntry );
        _ListEntry.Flink = NULL;

        //
        //  Remove and free the notification for this query
        //

        if ( fRemoveNotif && _pHTXNotification )
        {
            TCP_REQUIRE( RemoveDecacheNotification( _pHTXNotification ));
            _pHTXNotification = NULL;
        }

        //
        //  Dereference this cache item.  If nobody has it checked out, this
        //  will delete the item, otherwise it will be deleted when all
        //  clients of this query check it back in
        //

        QUERY_CACHE_ITEM::Dereference( this );
    }

    static VOID Reference( QUERY_CACHE_ITEM * pQCI )
    {
        TCP_ASSERT( pQCI->CheckSignature() );
        TCP_ASSERT( pQCI->_cRef > 0 );

        pQCI->_cRef++;
    }

    static VOID Dereference( QUERY_CACHE_ITEM * pQCI )
    {
        TCP_ASSERT( pQCI->CheckSignature() );
        TCP_ASSERT( pQCI->_cRef > 0 );

        if ( !(--pQCI->_cRef) )
        {
            delete pQCI;
        }
    }

    DWORD                 _Signature;
    ODBC_REQ *            _podbcreq;
    LIST_ENTRY            _ListEntry;   // If Flink == NULL, not on cache list
    DWORD                 _cRef;        // When _cRef == 0, delete this item
    VOID *                _pHTXNotification;
};

//
//  This is the contents of the cache blob for the .wdg file.  It contains the
//  list of queries
//

class QUERY_CACHE_LIST : public BLOB_HEADER
{
public:

    QUERY_CACHE_LIST()
      : _Signature( SIGNATURE_QCL )
        { InitializeListHead( &_QueryListHead ); }

    ~QUERY_CACHE_LIST()
    {
        DeleteAllItems();
        _Signature = SIGNATURE_QCL_FREE;
    }


    BOOL FindQuery( IN  ODBC_REQ * podbcreq,
                    OUT QUERY_CACHE_ITEM * * ppQCI );

    BOOL AddQuery( IN QUERY_CACHE_ITEM * pQCI );


    VOID DeleteAllItems( VOID );

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_QCL; }

    //
    //  Memory for a QCL comes from Tsunami's cache manager
    //

    static void * operator new( size_t size,
                                 void * pMem )
    {
        TCP_ASSERT( size == sizeof(QUERY_CACHE_LIST));

        return pMem;
    }

    static void operator delete( void * pMem )
    {
        //
        //  Tsunami frees this memory
        //

        ;
    }

private:

    LIST_ENTRY _QueryListHead;
    DWORD      _Signature;

};

BOOL
AddQuery(
    IN ODBC_REQ * podbcreq,
    IN DWORD      CurChangeCounter
    )
/*++

Routine Description:

    Adds a complete ODBC query to the query cache list that is hanging off
    the directory cache blob for this query file.  If a query cache list
    doesn't exist, then we add it.

Arguments:

    podbcreq - Query to cache
    CurChangeCounter - The change counter value before the query file,
        template file were openned and the query was performed.  If any
        files have changed since then, we do not cache this particular
        request.

Return Value:

    TRUE if this query was cached, FALSE if the query was not cached

--*/
{
    QUERY_CACHE_LIST * pQCL;
    QUERY_CACHE_ITEM * pQCI = NULL;
    VOID *             pvNotifCookie = NULL;
    VOID *             pvCheckinCookie = NULL;
    TSVC_CACHE         CacheID = *podbcreq->QueryTsvcCache();
    const ULONG        cchQueryFile = strlen(podbcreq->QueryQueryFile());

    LockQueryCache();

    //
    //  If we detected any changes in .htx or .wdg files since we openned up
    //  the component files and performed the query then don't cache
    //  this query
    //

    if ( CurChangeCounter != GetChangeCounter() )
    {
        UnlockQueryCache();
        return FALSE;
    }

    UnlockQueryCache();

    //
    //  Get the QCL cache blob
    //

    if ( !TsCheckOutCachedBlob( CacheID,
                                podbcreq->QueryQueryFile(),
                                cchQueryFile,
                                RESERVED_DEMUX_QUERY_CACHE,
                                (VOID **) &pQCL,
                                podbcreq->QueryUserToken(),
                                podbcreq->IsAnonymous() ))
    {
        if ( GetLastError() == ERROR_ACCESS_DENIED )
        {
            return FALSE;
        }

        VOID * pvMem;

        //
        //  The Query Cache List isn't in the Tsunami cache so create it
        //  and add it
        //

        if ( !TsAllocateEx( CacheID,
                            sizeof( QUERY_CACHE_LIST ),
                            &pvMem,
                            (PUSER_FREE_ROUTINE) FreeQCLCacheBlob ))
        {
            //
            //  Failed to cache Query Cache List so bail
            //

            return FALSE;
        }

        pQCL = new(pvMem) QUERY_CACHE_LIST();

        TCP_ASSERT( pQCL );

        //
        //  Now attempt to add it as a cache blob and check it out at the
        //  same time
        //

        if ( !TsCacheDirectoryBlob( CacheID,
                                    podbcreq->QueryQueryFile(),
                                    cchQueryFile,
                                    RESERVED_DEMUX_QUERY_CACHE,
                                    pQCL,
                                    TRUE,
                                    podbcreq->GetSecDesc() ))
        {
            //
            //  Failed to cache Query Cache List so bail
            //

            //
            //  This will end up calling FreeQCLCacheBlob where the
            //  object gets deconstructed
            //

            TCP_REQUIRE( TsFree( CacheID,
                                 pvMem ));

            return FALSE;
        }
        else
        {
            //
            // ownership of security descriptor has been transferred to the
            // directory blob cache.
            //

            podbcreq->InvalidateSecDesc();
        }
    }

    TCP_ASSERT( pQCL->CheckSignature() );

    //
    //  Now that we've successfully checked out the QCL,
    //  add this particular query to the list
    //

    LockQueryCache();

    //
    //  Make sure this query isn't already in the list.
    //

    if ( pQCL->FindQuery( podbcreq,
                          &pQCI ))
    {
        //
        //  This query is already in the list.
        //

        TCP_REQUIRE( TsCheckInCachedBlob( pQCL ));
        UnlockQueryCache();
        return FALSE;
    }

    //
    //  Create the query cache item but don't put it on the list till we're
    //  done with everything else as the list contents can get destroyed by
    //  adding the decache notification (i.e., things get thrown out of cache
    //  due to new item being added).
    //

    pQCI = new QUERY_CACHE_ITEM( podbcreq );

    if ( !pQCI )
    {
        TCP_REQUIRE( TsCheckInCachedBlob( pQCL ));
        UnlockQueryCache();

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    //  We now own the podbcreq object as it's on our list.  We can't return
    //  FALSE after this point otherwise podbcreq will get deleted twice
    //  (once by caller, once because it's in our list)
    //

    if ( !CheckOutDecacheNotification( &CacheID,
                                       podbcreq->QueryTemplateFile(),
                                       DecacheTemplateNotification,
                                       pQCI,
                                       RESERVED_DEMUX_QUERY_CACHE,
                                       &csQueryCacheLock,
                                       &pQCI->_pHTXNotification,
                                       &pvCheckinCookie ))
    {
        TCP_ASSERT( pQCL->CheckSignature());
        TCP_ASSERT( pQCI->CheckSignature());

        //
        //  We couldn't add this query, clean things up
        //

        if ( pQCI->_pHTXNotification )
        {
            CheckInDecacheNotification( &CacheID,
                                        pQCI->_pHTXNotification,
                                        pvCheckinCookie,
                                        FALSE );

            pQCI->_pHTXNotification = NULL;
        }

        TCP_ASSERT( pQCI->_cRef == 1 );
        QUERY_CACHE_ITEM::Dereference( pQCI );

        TCP_REQUIRE( TsCheckInCachedBlob( pQCL ));
        UnlockQueryCache();
        return TRUE;
    }

    //
    //  Finally, add the item to the lists and check them in
    //

    pQCL->AddQuery( pQCI );

    CheckInDecacheNotification( &CacheID,
                                pQCI->_pHTXNotification,
                                pvCheckinCookie,
                                TRUE );

    UnlockQueryCache();

    //
    // Check in the list
    //

    TCP_REQUIRE( TsCheckInCachedBlob( (VOID *) pQCL ));

    return TRUE;
}

BOOL
CheckOutQuery(
    IN  ODBC_REQ *   podbcreq,
    OUT VOID * *     ppvCacheCookie,
    OUT ODBC_REQ * * ppodbcreqCached
    )
/*++

Routine Description:

    Checks to see if the specified query is in our cache.  If it is,
    we return the equivalent cached query.

Arguments:

    podbcreq - Query to check to see if it's in the cache
    ppvCacheCookie - Receives pointer to Item cookie (pointer to Query Cache
        Item)
    ppodbcreqCached - If the query was previously cached, this receives the
        cached query

Return Value:

    TRUE if the query was found and checked out, FALSE if the query could
        not be checked (not found, error occurred etc)

--*/
{
    QUERY_CACHE_LIST * pQCL;
    QUERY_CACHE_ITEM * pQCI;
    BOOL               fRet = FALSE;

    //
    //  Get the QCL cache blob
    //

    if ( TsCheckOutCachedBlob( *podbcreq->QueryTsvcCache(),
                               podbcreq->QueryQueryFile(),
                               strlen(podbcreq->QueryQueryFile()),
                               RESERVED_DEMUX_QUERY_CACHE,
                               (VOID **) &pQCL,
                               podbcreq->QueryUserToken(),
                               podbcreq->IsAnonymous() ))
    {
        TCP_ASSERT( pQCL->CheckSignature() );

        //
        //  See if the query already exists
        //

        LockQueryCache();

        fRet = pQCL->FindQuery( podbcreq,
                                (QUERY_CACHE_ITEM **) ppvCacheCookie );

        if ( fRet )
        {
            //
            //  Bump the ref count until the client checks this query back in
            //

            QUERY_CACHE_ITEM::Reference( (QUERY_CACHE_ITEM *) *ppvCacheCookie );
            *ppodbcreqCached = ((QUERY_CACHE_ITEM *) *ppvCacheCookie)->QueryQuery();
        }

        UnlockQueryCache();

        //
        //  Check in the query list
        //

        TCP_REQUIRE( TsCheckInCachedBlob( pQCL ));
    }

    return fRet;
}

BOOL
CheckInQuery(
    IN VOID * pvCacheCookie
    )
/*++

Routine Description:

    Checks in a query cache item as the client no longer needs it

Arguments:

    pQCI - Previously checked out query

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    TCP_ASSERT( ((QUERY_CACHE_ITEM *) pvCacheCookie)->CheckSignature() );

    QUERY_CACHE_ITEM::Dereference( (QUERY_CACHE_ITEM *) pvCacheCookie );

    return TRUE;
}

BOOL
InitializeQueryCache(
    VOID
    )
{
    INITIALIZE_CRITICAL_SECTION( &csQueryCacheLock );
    return TRUE;
}

VOID
TerminateQueryCache(
    VOID
    )
{
    //
    // Flush Tsunami blobs associated with this extension
    //

    TsCacheFlushDemux( RESERVED_DEMUX_QUERY_CACHE );
    DeleteCriticalSection( &csQueryCacheLock );
}


BOOL
QUERY_CACHE_LIST::FindQuery(
    IN  ODBC_REQ *           podbcreq,
    OUT QUERY_CACHE_ITEM * * ppQCI
    )
/*++

Routine Description:

    Looks in the this cache list for the specified query

    The Query cache lock must be taken before calling this method

Arguments:

    podbcreq - Query template, used for checking if two queries are equal
    ppQCI - Receives pointer to the cached query item if found

Return Value:

    TRUE if the query was found, FALSE if the query was not found

--*/
{
    LIST_ENTRY *       pEntry;
    QUERY_CACHE_ITEM * pQCI;
    DWORD              TickCount = GetTickCount() / 1000;

    TCP_ASSERT( CheckSignature() );

    for ( pEntry  = _QueryListHead.Flink;
          pEntry != &_QueryListHead;
        )
    {
        pQCI = CONTAINING_RECORD( pEntry, QUERY_CACHE_ITEM, _ListEntry );

        TCP_ASSERT( pQCI->CheckSignature() );

        //
        //  Make sure we don't deliver expired queries
        //

        if ( pQCI->IsExpired( TickCount ) )
        {
            pEntry = pEntry->Flink;

            pQCI->RemoveFromList( TRUE );
            continue;
        }

        if ( pQCI->IsQueryEqual( podbcreq ) )
        {
            *ppQCI = pQCI;

            //
            //  Move this query to the front of the list if it's not already
            //

            if ( _QueryListHead.Flink != pEntry )
            {
                RemoveEntryList( pEntry );
                InsertHeadList( &_QueryListHead,
                                pEntry );
            }

            return TRUE;
        }

        pEntry  = pEntry->Flink;
    }

    return FALSE;
}

BOOL
QUERY_CACHE_LIST::AddQuery(
    IN  QUERY_CACHE_ITEM *   pQCI
    )
/*++

Routine Description:

    Adds the specified query to the cache list

    The Query cache lock must be taken before calling this method

Arguments:

    podbcreq - Query template

Return Value:

    TRUE if the query was found, FALSE if the query was not found

--*/
{
    InsertHeadList( &_QueryListHead,
                    &pQCI->_ListEntry );

    return TRUE;
}

VOID
QUERY_CACHE_LIST::DeleteAllItems(
    VOID
    )
/*++

Routine Description:

    Removes all items from this query cache list

Arguments:

--*/
{
    LIST_ENTRY *       pEntry;
    QUERY_CACHE_ITEM * pQCI;

    TCP_ASSERT( CheckSignature() );

    while ( !IsListEmpty( &_QueryListHead ))
    {
        pQCI = CONTAINING_RECORD( _QueryListHead.Flink,
                                  QUERY_CACHE_ITEM,
                                  _ListEntry );
        pQCI->RemoveFromList( TRUE );
    }

}


QUERY_CACHE_ITEM::QUERY_CACHE_ITEM(
    ODBC_REQ * podbcreq
    )
    : _Signature       ( SIGNATURE_QCI ),
      _cRef            ( 1 ),
      _podbcreq        ( podbcreq ),
      _pHTXNotification( NULL )
{
    _ListEntry.Flink = NULL;
}

QUERY_CACHE_ITEM::~QUERY_CACHE_ITEM()
{
    TCP_ASSERT( _ListEntry.Flink == NULL );
    TCP_ASSERT( _cRef == 0 );

    delete _podbcreq;
    _Signature = SIGNATURE_QCI_FREE;
}

BOOL
FreeQCLCacheBlob(
    VOID * pvCacheBlob
    )
/*++

Routine Description:

    This is the routine that is called by the Tsunami cache manager when
    the query file (i.e., .wdg) has been changed.  We're being notified
    that this cache blob is about to be removed from the cache and deleted

Arguments:

    pvCacheBlob - Cache blob about to be deleted

--*/
{
    QUERY_CACHE_LIST * pQCL = (QUERY_CACHE_LIST *) pvCacheBlob;

    TCP_ASSERT( pQCL->CheckSignature() );

    LockQueryCache();

    pQCL->DeleteAllItems();

    //
    //  Deconstruct the list object, this doesn't free the memory
    //

    delete pQCL;

    //
    //  Bump the change counter cause a .wdg file has changed
    //

    cCacheChangeCounter++;

    //
    //  We don't need to free pQCL because it's the cache that's about to
    //  be deleted
    //

    UnlockQueryCache();

    return TRUE;
}

VOID
DecacheTemplateNotification(
    VOID * pvContext
    )
/*++

Routine Description:

    This is the routine that is called by the notification package when the
    template file this query is using has changed.  Note the query cache lock
    has already been taken by the notification code

Arguments:

    pvContext - Notification context

--*/
{
    QUERY_CACHE_ITEM * pQCI = (QUERY_CACHE_ITEM *) pvContext;

    TCP_ASSERT( pQCI->CheckSignature() );

    //
    //  Take this item off the query cache list
    //

    TCP_ASSERT( pQCI->_ListEntry.Flink != NULL );

    //
    //  Note we do not remove the notification because it's the
    //  notification that's called us.  It will remove itself
    //

    pQCI->RemoveFromList( FALSE );

    //
    //  Bump the change counter cause an .htx file has changed
    //

    cCacheChangeCounter++;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\makefile.inc ===
#
# Supplemental rules for generating message file.
#

odbcmsg.h odbcmsg.rc msg00001.bin: odbcmsg.mc
    mc -v odbcmsg.mc

clean::
    -del odbcmsg.h odbcmsg.rc msg00001.bin


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\dynodbc.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      dynodbc.h

   Abstract:
      This header declares functions for dynamically loading ODBC.

   Author:

       Murali R. Krishnan    ( MuraliK )    3-Nov-1995

   Environment:
       Win32 -- User Mode

   Project:

      Internet Services Common Code.

   Revision History:

--*/

# ifndef _DYNODBC_H_
# define _DYNODBC_H_

/************************************************************
 *     Include Headers
 ************************************************************/


//
// SQL-ODBC interface headers
//
# include "sql.h"
# include "sqlext.h"




/************************************************************
 *   Dynamic Load support
 ************************************************************/

BOOL
DynLoadODBC(
    VOID
    );

//
//  Prototypes form sql.h
//

typedef RETCODE (SQL_API * pfnSQLAllocConnect)(
    HENV        henv,
    HDBC   FAR *phdbc);

typedef RETCODE (SQL_API * pfnSQLAllocEnv)(
    HENV   FAR *phenv);

typedef RETCODE (SQL_API * pfnSQLAllocStmt)(
    HDBC        hdbc,
    HSTMT  FAR *phstmt);

typedef RETCODE (SQL_API * pfnSQLBindCol)(
    HSTMT       hstmt,
    UWORD       icol,
    SWORD       fCType,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLCancel)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLColAttributes)(
    HSTMT       hstmt,
    UWORD       icol,
    UWORD       fDescType,
    PTR         rgbDesc,
        SWORD       cbDescMax,
    SWORD  FAR *pcbDesc,
    SDWORD FAR *pfDesc);

typedef RETCODE (SQL_API * pfnSQLConnect)(
    HDBC        hdbc,
    UCHAR  FAR *szDSN,
    SWORD       cbDSN,
    UCHAR  FAR *szUID,
    SWORD       cbUID,
    UCHAR  FAR *szAuthStr,
    SWORD       cbAuthStr);

typedef RETCODE (SQL_API * pfnSQLDescribeCol)(
    HSTMT       hstmt,
    UWORD       icol,
    UCHAR  FAR *szColName,
    SWORD       cbColNameMax,
    SWORD  FAR *pcbColName,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable);

typedef RETCODE (SQL_API * pfnSQLDisconnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLError)(
    HENV        henv,
    HDBC        hdbc,
    HSTMT       hstmt,
    UCHAR  FAR *szSqlState,
    SDWORD FAR *pfNativeError,
    UCHAR  FAR *szErrorMsg,
    SWORD       cbErrorMsgMax,
    SWORD  FAR *pcbErrorMsg);

typedef RETCODE (SQL_API * pfnSQLExecDirect)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLExecute)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFetch)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFreeConnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLFreeEnv)(
    HENV        henv);

typedef RETCODE (SQL_API * pfnSQLFreeStmt)(
    HSTMT       hstmt,
    UWORD       fOption);

typedef RETCODE (SQL_API * pfnSQLGetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursorMax,
    SWORD  FAR *pcbCursor);

typedef RETCODE (SQL_API * pfnSQLNumResultCols)(
    HSTMT       hstmt,
    SWORD  FAR *pccol);

typedef RETCODE (SQL_API * pfnSQLPrepare)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLRowCount)(
    HSTMT       hstmt,
    SDWORD FAR *pcrow);

typedef RETCODE (SQL_API * pfnSQLSetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursor);

typedef RETCODE (SQL_API * pfnSQLTransact)(
    HENV        henv,
    HDBC        hdbc,
    UWORD       fType);

//
//  Prototypes form sqlext.h
//

typedef RETCODE (SQL_API * pfnSQLSetConnectOption)(
    HDBC        hdbc,
    UWORD       fOption,
    UDWORD      vParam);

typedef RETCODE (SQL_API * pfnSQLDrivers)(
    HENV        henv,
    UWORD       fDirection,
    UCHAR FAR  *szDriverDesc,
    SWORD       cbDriverDescMax,
    SWORD FAR  *pcbDriverDesc,
    UCHAR FAR  *szDriverAttributes,
    SWORD       cbDrvrAttrMax,
    SWORD  FAR *pcbDrvrAttr);

typedef RETCODE (SQL_API * pfnSQLBindParameter)(
    HSTMT       hstmt,
    UWORD       ipar,
    SWORD       fParamType,
    SWORD       fCType,
    SWORD       fSqlType,
    UDWORD      cbColDef,
    SWORD       ibScale,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLDataSources)(
    HENV        henv,
    UWORD       fDirection,
    UCHAR  FAR *szDSN,
    SWORD       cbDSNMax,
    SWORD  FAR *pcbDSN,
    UCHAR  FAR *szDescription,
    SWORD       cbDescriptionMax,
    SWORD  FAR *pcbDescription);

typedef RETCODE (SQL_API * pfnSQLGetInfo)(
    HDBC        hdbc,
    UWORD       fInfoType,
    PTR         rgbInfoValue,
    SWORD       cbInfoValueMax,
    SWORD  FAR *pcbInfoValue);

typedef RETCODE (SQL_API * pfnSQLMoreResults)(
    HSTMT       hstmt );

/************************************************************
 *   Variables
 ************************************************************/

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

extern pfnSQLAllocConnect        pSQLAllocConnect   ;
extern pfnSQLAllocEnv            pSQLAllocEnv       ;
extern pfnSQLAllocStmt           pSQLAllocStmt      ;
extern pfnSQLBindCol             pSQLBindCol        ;
extern pfnSQLCancel              pSQLCancel         ;
extern pfnSQLColAttributes       pSQLColAttributes  ;
extern pfnSQLConnect             pSQLConnect        ;
extern pfnSQLDescribeCol         pSQLDescribeCol    ;
extern pfnSQLDisconnect          pSQLDisconnect     ;
extern pfnSQLError               pSQLError          ;
extern pfnSQLExecDirect          pSQLExecDirect     ;
extern pfnSQLExecute             pSQLExecute        ;
extern pfnSQLFetch               pSQLFetch          ;
extern pfnSQLFreeConnect         pSQLFreeConnect    ;
extern pfnSQLFreeEnv             pSQLFreeEnv        ;
extern pfnSQLFreeStmt            pSQLFreeStmt       ;
extern pfnSQLGetCursorName       pSQLGetCursorName  ;
extern pfnSQLNumResultCols       pSQLNumResultCols  ;
extern pfnSQLPrepare             pSQLPrepare        ;
extern pfnSQLRowCount            pSQLRowCount       ;
extern pfnSQLSetCursorName       pSQLSetCursorName  ;
extern pfnSQLTransact            pSQLTransact       ;

extern pfnSQLSetConnectOption    pSQLSetConnectOption;
extern pfnSQLDrivers             pSQLDrivers         ;
extern pfnSQLDataSources         pSQLDataSources     ;
extern pfnSQLBindParameter       pSQLBindParameter   ;

extern pfnSQLGetInfo             pSQLGetInfo        ;
extern pfnSQLMoreResults         pSQLMoreResults    ;


# endif // _DYNODBC_H_

/************************ End of File ***********************/





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\odbcreq.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    odbcreq.cxx

Abstract:

    ODBC Request class used for ODBC requests from a query file

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

    MuraliK    25-Aug-1995     Fixed a heap corruption problem
    Phillich   24-Jan-1996     Fixed nested Ifs problem

--*/
#include <iis64.h>
#include <mbstring.h>
#include "dbgutil.h"

//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>


#ifdef __cplusplus
} // extern "C"

#include <buffer.hxx>
#include <string.hxx>
#include <refb.hxx>
#include <tsres.hxx>
#include <parse.hxx>


#endif // __cplusplus


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <odbcconn.hxx>
#include <parmlist.hxx>

#include <odbcmsg.h>
#include <odbcreq.hxx>

#include <festrcnv.h>

//
//  Globals
//

extern BOOL  g_fIsSystemDBCS;        // Is this system DBCS?

//
//  Local Function Prototypes
//

BOOL
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    );


BOOL
GetFileData(IN     const CHAR *             pchFile,
			OUT    BYTE * *                 ppbData,
			OUT    DWORD *                  pcbData,
			IN     int                      nCharset,
			IN     BOOL                     fUseWin32Canon);

//
//  Accumulate and output data in chunks of this size
//

#define OUTPUT_BUFFER_SIZE         8192

//
//  This is the maximum value for the expires time.  It's 10 years in seconds
//

#define MAX_EXPIRES_TIME           0x12cc0300

//
//  The special tag names for marking the beginning and ending of the
//  special tag sections
//

#define BEGIN_DETAIL_TEXT       "begindetail"
#define END_DETAIL_TEXT         "enddetail"
#define IF_TEXT                 "if"
#define ELSE_TEXT               "else"
#define END_IF_TEXT             "endif"

//
//  Does a case insensitive compare of a .wdg field name
//

#define COMP_FIELD( pchName, pchField, cch )  ((toupper(*(pchName)) ==     \
                                                toupper(*(pchField))) &&   \
                                               !_strnicmp( (pchName), (pchField), (cch)))

//
//  Given a pointer to a token, skips to the next white space delimited token
//

#define NEXT_TOKEN( pchToken )                 SkipWhite( SkipNonWhite( pchToken ) )

BOOL
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STR *             pStrOptions
    );

BOOL
BuildMultiValue(
    const CHAR * pchValue,
    STR *        pstrMulti,
    BOOL         fQuoteElements
    );

const CHAR *
SkipNonWhite(
    const CHAR * pch
    );

const CHAR *
SkipTo(
    const CHAR * pch,
    CHAR ch
    );

const CHAR *
SkipWhite(
    const CHAR * pch
    );

ODBC_REQ::ODBC_REQ(
    CONST CHAR *         pszQueryFile,
    CONST CHAR *         pszParameters,
    DWORD                csecConnPool,
    ODBC_REQ_FIND_SYMBOL pfnClientFindSymbol,
    VOID *               pFindSymbolContext,
    int                  nCharset
    )
    : _cchMaxFieldSize    ( 0 ),
      _cMaxRecords        ( 0xffffffff ),
      _cCurrentRecordNum  ( 0 ),
      _cClientParams      ( 0 ),
      _podbcstmt          ( NULL ),
      _podbcconnPool      ( NULL ),
      _pfnClientFindSymbol( pfnClientFindSymbol ),
      _pFindSymbolContext ( pFindSymbolContext ),
      _cbQueryFile        ( 0 ),
      _cNestedIfs         ( 0 ),
      _strQueryFile       ( pszQueryFile ),
      _fDirect            ( FALSE ),
      _fValid             ( FALSE ),
      _pbufOut            ( NULL ),
      _csecExpires        ( 0 ),
      _csecExpiresAt      ( 0 ),
      _pstrValues         ( NULL ),
      _pcbValues          ( NULL ),
      _cQueries           ( 0 ),
      _csecConnPool       ( csecConnPool ),
      _pSecDesc           ( NULL ),
      _pstrCols           ( NULL ),
      _nCharset           ( nCharset )
{
    if ( _strQueryFile.IsValid()   &&
         _plParams.ParsePairs( pszParameters, FALSE, FALSE, FALSE ))
    {
        _fValid = TRUE;
    }

    _cClientParams = _plParams.GetCount();

}

ODBC_REQ::~ODBC_REQ()
{
    Close();

    if ( _podbcstmt )
    {
        delete _podbcstmt;
    }

    if ( _pbufOut )
    {
        delete _pbufOut;
    }

    if ( _pSecDesc )
    {
        LocalFree( _pSecDesc );
    }
}

BOOL
ODBC_REQ::OpenQueryFile(
    BOOL * pfAccessDenied
    )
{
    CHAR *            pchQueryFile;

    if ( !GetFileData( _strQueryFile.QueryStr(),
                              (BYTE **) &pchQueryFile,
                              &_cbQueryFile,
                              _nCharset,
							  TRUE))
    {
        STR strError;
        LPCSTR apsz[1];

        apsz[0] = _strQueryFile.QueryStr();

        strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                               apsz,
                               HTTP_ODBC_DLL );
        SetErrorText( strError.QueryStr() );

        DWORD dwE = GetLastError();
        if ( dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE )
            *pfAccessDenied = TRUE;

        return FALSE;
    }

    //
    //  CODEWORK - It is possible to avoid this copy by not modifying the
    //  contents of the query file.  Would save a buffer copy
    //

    if ( !_bufQueryFile.Resize( _cbQueryFile ))
    {
        return FALSE;
    }

    memcpy( _bufQueryFile.QueryPtr(),
            pchQueryFile,
            _cbQueryFile );

    return TRUE;
}


BOOL
ODBC_REQ::ParseAndQuery(
    CHAR *  pszLoggedOnUser
    )
/*++

Routine Description:

    This method parses the query file and executes the SQL statement

Arguments:

    pchLoggedOnUser - The NT user account this user is running under

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    STACK_STR( strDatasource, 64 );
    STACK_STR( strUsername, 64 );
    STACK_STR( strPassword, 64 );
    CHAR *     pch;
    CHAR *     pchEnd;
    CHAR *     pszField;
    CHAR *     pszValue;
    BOOL       fRet;
    VOID *     pCookie = NULL;
    DWORD      csecPoolConnection = _csecConnPool;
    BOOL       fRetried;

    //
    //  We don't allow some security related parameters to be specified from
    //  the client so remove those now
    //

    _plParams.RemoveEntry( "REMOTE_USER" );
    _plParams.RemoveEntry( "LOGON_USER" );
    _plParams.RemoveEntry( "AUTH_USER" );

    //
    //  Do a quick Scan for the DefaultParameters value to fill in the blanks
    //  in the parameter list from the web browser
    //

    {
        pch = (CHAR *) _bufQueryFile.QueryPtr();
        pchEnd = pch + strlen(pch);

        INET_PARSER Parser( (CHAR *) _bufQueryFile.QueryPtr() );

        while ( (pszField = Parser.QueryToken()) < pchEnd )
        {
            if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                Parser.SkipTo( ':' );
                Parser += 1;
                Parser.EatWhite();

                if ( !_plParams.ParsePairs( Parser.QueryLine(), TRUE))
                    return FALSE;

                break;
            }

            Parser.NextLine();
        }
    }

    //
    //  Replace any %XXX% fields with the corresponding parameter.  Note
    //  we reassign pch in case of a pointer shift during ReplaceParams
    //

    if ( !ReplaceParams( &_bufQueryFile,
                         &_plParams ))
    {
        return FALSE;
    }

    pch = (CHAR *) _bufQueryFile.QueryPtr();
    pchEnd = pch + strlen(pch);

    //
    //  Loop through the fields looking for values we recognize
    //

    {
        INET_PARSER Parser( pch );

        while ( (pszField = Parser.QueryToken()) < pchEnd )
        {
            //
            //  Ignore blank lines and Ctrl-Zs
            //

            if ( !*pszField || *pszField == 0x1a)
            {
                Parser.NextLine();
                continue;
            }

            Parser.SkipTo( ':' );
            Parser += 1;
            Parser.EatWhite();

            //
            //  Ignore comment fields
            //

            if ( *pszField == '#' || *pszField == ';' )
            {
                Parser.NextLine();
                continue;
            }

            if ( COMP_FIELD( "Datasource:", pszField, 11 ))
            {
                fRet = Parser.CopyToEOL( &strDatasource );
            }
            else if ( COMP_FIELD( "Username:", pszField, 9 ))
            {
                fRet = Parser.CopyToEOL( &strUsername );
            }
            else if ( COMP_FIELD( "Password:", pszField, 9 ))
            {
                fRet = Parser.CopyToEOL( &strPassword );
            }
            else if ( COMP_FIELD( "Template:", pszField, 9 ))
            {
                fRet = Parser.CopyToEOL( &_strTemplateFile );

                //
                //  Specifying a template of "Direct" means return the
                //  first column of data as raw data to the client
                //

                if ( !_stricmp( _strTemplateFile.QueryStr(), "Direct" ))
                {
                    _fDirect = TRUE;
                }
            }
            else if ( COMP_FIELD( "MaxFieldSize:", pszField, 13 ))
            {
                _cchMaxFieldSize = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "MaxRecords:", pszField, 11 ))
            {
                _cMaxRecords = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "RequiredParameters:", pszField, 12 ))
            {
                fRet = _plReqParams.ParseSimpleList( Parser.QueryLine() );
            }
            else if ( COMP_FIELD( "Content-Type:", pszField, 13 ))
            {
                fRet = Parser.CopyToEOL( &_strContentType );
            }
            else if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                //
                //  Ignore, already processed
                //
            }
            else if ( COMP_FIELD( "Expires:", pszField, 8 ))
            {
//                _csecExpires = min( (DWORD) atoi( Parser.QueryPos() ),
//                                    MAX_EXPIRES_TIME );
			}
            else if ( COMP_FIELD( "ODBCOptions:", pszField, 12 ))
            {
                fRet = Parser.CopyToEOL( &_strOdbcOptions );
            }
            else if ( COMP_FIELD( "ODBCConnection:", pszField, 15 ))
            {
                //
                //  Is there an override to the default?
                //

                if ( !_strnicmp( Parser.QueryToken(), "Pool", 4 ))
                {
                    if ( !csecPoolConnection )
                    {
                        // This is bogus - if somebody has turned off connection
                        // pooling on the vroot and enabled it in the idc,
                        // there's no defined way to set the timeout
                        // need to add a timeout here

                        csecPoolConnection = 30;
                    }
                }
                else if ( !_strnicmp( Parser.QueryToken(), "NoPool", 6 ))
                {
                    csecPoolConnection = 0;
                }
            }
            else if ( COMP_FIELD( "SQLStatement:", pszField, 13 ))
            {
                if ( _cQueries >= MAX_QUERIES )
                {
                    STR strError;
                    strError.FormatString( ODBCMSG_TOO_MANY_SQL_STATEMENTS,
                                           NULL,
                                           HTTP_ODBC_DLL );

                    SetErrorText( strError.QueryStr() );

                    return FALSE;
                }

                while ( TRUE )
                {
                    if ( !_strQueries[_cQueries].Append( Parser.QueryLine() ) )
                        return FALSE;

                    Parser.NextLine();

                    //
                    //  Line continuation is signified by putting a '+' at
                    //  the beginning of the line
                    //

                    if ( *Parser.QueryLine() == '+' )
                    {
                        if ( !_strQueries[_cQueries].Append( " " ))
                            return FALSE;

                        Parser += 1;
                    }
                    else
                    {
                        //
                        //  Ignore blank line
                        //

                        if ( !*Parser.QueryLine() &&
                             Parser.QueryLine() < pchEnd )
                        {
                            continue;
                        }
                        break;
                    }

                }

                _cQueries++;
                continue;
            }
            else if ( COMP_FIELD( IDC_FIELDNAME_CHARSET, pszField, sizeof(IDC_FIELDNAME_CHARSET)-1 ))
            {
                //
                // Ignore "Charset:" field
                //

                Parser.NextLine();
                continue;
            }
            else if ( COMP_FIELD( "TranslationFile:", pszField, 16 ))
            {
                fRet = Parser.CopyToEOL( &_strTranslationFile );
            }
            else
            {
                //
                //  Unrecognized field, generate an error
                //

                STR strError;
                LPCSTR apsz[1];

                apsz[0] = pszField;

                strError.FormatString( ODBCMSG_UNREC_FIELD,
                                       apsz,
                                       HTTP_ODBC_DLL );

                SetErrorText( strError.QueryStr() );

                fRet = FALSE;
            }

            if ( !fRet )
                return FALSE;

            Parser.NextLine();
        }
    }

    //
    //  Make sure the Datasource and SQLStatement fields are non-empty
    //

    if ( strDatasource.IsEmpty() || !_cQueries || _strQueries[0].IsEmpty() )
    {
        STR strError;
        strError.FormatString( ODBCMSG_DSN_AND_SQLSTATEMENT_REQ,
                               NULL,
                               HTTP_ODBC_DLL );

        SetErrorText( strError.QueryStr() );

        return FALSE;
    }

    //
    //  Make sure all of the required parameters have been supplied
    //

    while ( pCookie = _plReqParams.NextPair( pCookie,
                                             &pszField,
                                             &pszValue ))
    {
        if ( !_plParams.FindValue( pszField ))
        {
            STR strError;
            LPCSTR apsz[1];

            apsz[0] = pszField;

            if ( !strError.FormatString( ODBCMSG_MISSING_REQ_PARAM,
                                         apsz,
                                         HTTP_ODBC_DLL ))
            {
                return FALSE;
            }

            //
            //  Set the error text to return the user and indicate we couldn't
            //  continue the operation
            //

            SetErrorText( strError.QueryStr() );

            return FALSE;
        }
    }

    //
    //  Don't retry the connection/query if not pooling.  The reason
    //  we do the retry is to report the error that occurred (this
    //  requires the ODBC connection object).
    //

    fRetried = csecPoolConnection == 0;

RetryConnection:

    //
    //  Open the database
    //

			if ( !OpenConnection( &_odbcconn,
                          &_podbcconnPool,
                          csecPoolConnection,
                          strDatasource.QueryStr(),
                          strUsername.QueryStr(),
                          strPassword.QueryStr(),
                          pszLoggedOnUser )  ||
        !SetOdbcOptions( QueryOdbcConnection(), &_strOdbcOptions ) ||
         !(_podbcstmt = QueryOdbcConnection()->AllocStatement()) ||
         !_podbcstmt->ExecDirect( _strQueries[0].QueryStr(),
                                  _strQueries[0].QueryCCH() ))
    {

        //
        //  Delete the pooled connection and retry the open
        //

        if ( csecPoolConnection )
        {
            delete _podbcstmt;
            _podbcstmt = NULL;

            CloseConnection( _podbcconnPool,
                             TRUE );

            _podbcconnPool = NULL;
            csecPoolConnection = 0;
        }

        if ( !fRetried )
        {
            fRetried = TRUE;
            goto RetryConnection;
        }

        return FALSE;
    }
	
    CloseConnection( _podbcconnPool,
                     TRUE );

    return TRUE;
}


BOOL
ODBC_REQ::OutputResults(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    STR *             pstrHeaders,
    ODBC_REQ_HEADER   pfnSendHeader,
    BOOL              fIsAuth,
    BOOL *            pfAccessDenied
    )
/*++

Routine Description:

    This method reads the template file and does the necessary
    result set column substitution

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD               cbOut;
    DWORD               cbFile, cbHigh;
    DWORD               BytesRead;
    DWORD               cbToSend;
    BOOL                fLastRow = FALSE;
    const CHAR *        pchStartDetail;
    const CHAR *        pchIn;
    const CHAR *        pchEOF;
    const CHAR *        pchBOF;
    CHAR *              pchTag;
    const CHAR *        pchValue;
    DWORD               cbValue;
    enum TAG_TYPE       TagType;
    DWORD               err;
    BOOL                fTriedRelative = FALSE;
    BOOL                fExpr;
    STR                 strError;
    const CHAR *        CharacterMap[256];
    BOOL                fIsSelect;
    BOOL                fMoreResults;
    BOOL                fHaveResultSet = FALSE;
    DWORD               iQuery = 1;

    //
    //  Set up the first buffer in the output chain
    //

    if ( !_pbufOut )
    {
        _pbufOut = new BUFFER_CHAIN_ITEM( OUTPUT_BUFFER_SIZE );

        if ( !_pbufOut ||
             !_pbufOut->QueryPtr() )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
    }

    if ( !_fDirect )
    {
        CHAR * pchLastSlash;
        STACK_STR( str, MAX_PATH);

TryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        if ( !GetFileData( (fTriedRelative ? str.QueryStr() :
                                                   _strTemplateFile.QueryStr()),
//                                  _hToken,
                                  (BYTE **)&pchBOF,
                                  &BytesRead,
                                  _nCharset,
                                  TRUE ))
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                         ||
                 ((GetLastError() != ERROR_FILE_NOT_FOUND) &&
                  (GetLastError() != ERROR_PATH_NOT_FOUND)) ||
                 !str.Copy( _strQueryFile ) )
            {
                STR strError;
                LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                apsz[0] = _strTemplateFile.QueryStr();

                strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                                       apsz,
                                       HTTP_ODBC_DLL );
                SetErrorText( strError.QueryStr());

                if ( (dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE) )
                {
                    *pfAccessDenied = TRUE;
                    return FALSE;
                }

                if ( !pfnSendHeader( pvContext, "500 IDC Query Error", pstrHeaders->QueryStr() ) )
                    return FALSE;

                goto ErrorExit;
            }

            pchLastSlash = (PCHAR)_mbsrchr( (PUCHAR)str.QueryStr(), '\\' );

            if ( !pchLastSlash )
            {
                SetLastError( ERROR_FILE_NOT_FOUND );
                return FALSE;
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            if ( !str.Append( _strTemplateFile ))
            {
                return FALSE;
            }

            fTriedRelative = TRUE;
            goto TryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                if ( !_strTemplateFile.Copy( str ))
                    return FALSE;
            }
        }
    }

    //
    //  Open the translation file if one was specified
    //

    if ( !_strTranslationFile.IsEmpty() )
    {
//        CACHE_FILE_INFO cfiTranslationFile;
        CHAR * pchLastSlash;
        CHAR * pchTranslationFile;
        STACK_STR( str, MAX_PATH);
        BOOL   fRet;
        VOID * pvCookie = NULL;
        CHAR * pchField;
        CHAR * pchValue;
        DWORD  cbRead;

        fTriedRelative = FALSE;

TranslationTryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        if ( !GetFileData( (fTriedRelative ? str.QueryStr() :
                                                   _strTranslationFile.QueryStr()),
//                                  _hToken,
                                  (BYTE **)&pchTranslationFile,
                                  &cbRead,
                                  _nCharset,
                                  TRUE))
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                         ||
                 (GetLastError() != ERROR_FILE_NOT_FOUND &&
                 GetLastError() != ERROR_PATH_NOT_FOUND) ||
                 !str.Copy( _strQueryFile ) )
            {
                STR strError;
                LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                apsz[0] = _strTranslationFile.QueryStr();

                strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                                       apsz,
                                       HTTP_ODBC_DLL );
                SetErrorText( strError.QueryStr());

                if ( (dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE) )
                {
                    *pfAccessDenied = TRUE;
                    return FALSE;
                }

                goto ErrorExit;
            }

            pchLastSlash = (PCHAR)_mbsrchr( (PUCHAR)str.QueryStr(), '\\' );

            if ( !pchLastSlash )
            {
                SetLastError( ERROR_FILE_NOT_FOUND );
                return FALSE;
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            if ( !str.Append( _strTranslationFile ))
            {
                return FALSE;
            }

            fTriedRelative = TRUE;
            goto TranslationTryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                if ( !_strTranslationFile.Copy( str ))
                    return FALSE;
            }
        }

        fRet = _plTransList.ParsePairs( pchTranslationFile,
                                        FALSE,
                                        TRUE,
                                        FALSE );  

/*       TCP_REQUIRE( CheckInCachedFile( _pCache,
                                        &cfiTranslationFile ));
*/
        if ( !fRet )
            return FALSE;

        //
        //  Build the character map
        //

        memset( CharacterMap, 0, sizeof(CharacterMap) );

        while ( pvCookie = _plTransList.NextPair( pvCookie,
                                                  &pchField,
                                                  &pchValue ))
        {
            CharacterMap[ (BYTE) *pchField] = pchValue;
        }
    }

    //
    //  We've already performed the first query at this point
    //

NextResultSet:

    //
    //  Get the list of column names in the initial result set.  The initial
    //  set must be initialized for compatibility with previous versions of
    //  IDC (i.e., column variables can be referenced outside the detail
    //  section).
    //

    if ( !_podbcstmt->QueryColNames( &_pstrCols,
                                     &_cCols,
                                     _cchMaxFieldSize,
                                     &fHaveResultSet ))
    {
        return FALSE;
    }

    if ( !fHaveResultSet )
    {
        //
        //  Check to see if there are anymore result sets for this query
        //

        if ( !_podbcstmt->MoreResults( &fMoreResults ) )
        {
            return FALSE;
        }

        if ( fMoreResults )
        {
            goto NextResultSet;
        }
        else if ( iQuery < _cQueries )
        {
            //
            //  If there are no more result sets, see if there
            //  are more queries.  Note calling SQLMoreResults
            //  will discard this result set
            //

            if ( !_podbcstmt->ExecDirect(
                               _strQueries[iQuery].QueryStr(),
                               _strQueries[iQuery].QueryCCH() ))
            {
                return FALSE;
            }

            iQuery++;

            goto NextResultSet;
        }
    }


    //
    //  Get the first row of values
    //

    if ( fHaveResultSet && !NextRow( &fLastRow ))
    {
        //
        //  Some SQL statements don't generate any rows (i.e.,
        //  insert, delete etc.).  So don't bail if there's a column in
        //  the result set
        //

        if ( !_cCols )
            return FALSE;
    }

    // Send reply header

    if ( !pfnSendHeader( pvContext, "200 OK", pstrHeaders->QueryStr() ) )
        return FALSE;

    //
    //  Copy the template to the output buffer while scanning for column
    //  fields that need to be replaced
    //

    #define SEND_DATA( pchData, cbData )  SendData( pfnCallback,   \
                                                    pvContext,     \
                                                    (pchData),     \
                                                    (DWORD)(cbData), \
                                                    &_pbufOut,     \
                                                    &cbOut )

    #define SEND_DATA_CHECK_ESC( pchData, cbData )  \
            ((TagType == TAG_TYPE_VALUE_TO_ESCAPE)  \
            ? SendEscapedData( pfnCallback,         \
                    pvContext,                      \
                    pchData,                        \
                    (DWORD)(cbData),                \
                    &cbOut )                        \
            : SEND_DATA( pchData,                   \
                    (DWORD)(cbData) ) )

    cbOut  = 0;
    pchStartDetail = NULL;
    pchIn  = pchBOF;
    pchEOF = pchBOF + BytesRead;

    while ( pchIn < pchEOF )
    {
        //
        //  Look for the start of a "<!--%" or <%" tag
        //

        pchTag = strchr( pchIn, '<' );

        if ( pchTag )
        {
            //
            //  Send any data preceding the tag
            //

            cbToSend = DIFF(pchTag - pchIn);

            if ( !SEND_DATA( pchIn, cbToSend) )
                return FALSE;

            pchIn += cbToSend;


            if ( !memcmp( pchTag, "<!--%", 5 ) ||
                 !memcmp( pchTag, "<%", 2 ))
            {
                //
                //  Is this a tag we care about?  pchIn is advanced except
                //  in the unknown case
                //

                LookupTag( pchTag,
                           &pchIn,
                           &pchValue,
                           &cbValue,
                           &TagType );

                switch( TagType )
                {
                case TAG_TYPE_VALUE:
                case TAG_TYPE_VALUE_TO_ESCAPE:

                    //
                    //  Map any characters if there was a translation file
                    //

                    if ( _strTranslationFile.IsEmpty() )
                    {
                        if ( !SEND_DATA_CHECK_ESC( pchValue, (DWORD) -1 ))
                            return FALSE;
                    }
                    else
                    {
                        const CHAR * pchStart = pchValue;

                        while ( *pchValue )
                        {
                            if ( CharacterMap[ (BYTE) *pchValue ] )
                            {
                                SEND_DATA_CHECK_ESC( pchStart,
                                        pchValue - pchStart );
                                SEND_DATA_CHECK_ESC(
                                        CharacterMap[ (BYTE) *pchValue],
                                        (DWORD) -1 );

                                pchStart = pchValue = pchValue + 1;
                            }
                            else
                            {
                                pchValue++;
                            }
                        }

                        SEND_DATA_CHECK_ESC( pchStart, pchValue - pchStart );
                    }

                    break;

                case TAG_TYPE_BEGIN_DETAIL:

                    //
                    //  If we don't have a result set, get one now
                    //

                    if ( !fHaveResultSet )
                    {
                        fLastRow = TRUE;
                        _podbcstmt->FreeColumnMemory();
                        _cCurrentRecordNum = 0;
                        _pstrCols = _pstrValues = NULL;

NextResultSet2:
                        if ( !_podbcstmt->MoreResults( &fMoreResults ) )
                        {
                            return FALSE;
                        }

                        if ( fMoreResults )
                        {
NewQuery:
                            if ( !_podbcstmt->QueryColNames( &_pstrCols,
                                                             &_cCols,
                                                             _cchMaxFieldSize,
                                                             &fHaveResultSet ))
                            {
                                return FALSE;
                            }

                            if ( !fHaveResultSet )
                                goto NextResultSet2;

                            if ( !NextRow( &fLastRow ))
                            {
                                //
                                //  Some SQL statements don't generate any rows (i.e.,
                                //  insert, delete etc.).  So don't bail if
                                //  there's a column in the result set
                                //

                                if ( !_cCols )
                                    return FALSE;
                            }
                        }
                        else if ( iQuery < _cQueries )
                        {
                            //
                            //  If there are no more result sets, see if there
                            //  are more queries.  Note calling SQLMoreResults
                            //  will discard this result set
                            //

                            if ( !_podbcstmt->ExecDirect(
                                               _strQueries[iQuery].QueryStr(),
                                               _strQueries[iQuery].QueryCCH() ))
                            {
                                return FALSE;
                            }

                            iQuery++;

                            goto NewQuery;
                        }
                    }

                    if ( !fLastRow )
                    {
                        pchStartDetail = pchIn;
                    }
                    else
                    {
                        //
                        //  If no more data, then skip the detail section
                        //

                        SkipToTag( &pchIn, END_DETAIL_TEXT );

                        fHaveResultSet = FALSE;
                    }

                    break;

                case TAG_TYPE_END_DETAIL:

                    if ( !NextRow( &fLastRow ))
                        return FALSE;

                    _cCurrentRecordNum++;

                    if ( !fLastRow && _cCurrentRecordNum < _cMaxRecords )
                        pchIn = pchStartDetail;
                    else
                        fHaveResultSet = FALSE;

                    break;

                case TAG_TYPE_IF:

                    //
                    //  pchIn points to the first character of the expression
                    //  on the way in, the first character after the tag on the
                    //  way out
                    //

                    if ( !EvaluateExpression( (const CHAR * *) &pchIn, &fExpr ))
                        return FALSE;

                    //
                    //  If the expression is FALSE, then skip the intervening
                    //  data till the endif tag
                    //

                    if ( !fExpr )
                    {
                        //
                        //  Look for a closing else or endif
                        //

                        if ( SkipConditionalBlock( &pchIn, pchEOF, ELSE_TEXT ) )
                            _cNestedIfs++;
                    }
                    else
                    {
                        _cNestedIfs++;
                    }
                    break;

                case TAG_TYPE_ELSE:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  else w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ELSES,
                                               NULL,
                                               HTTP_ODBC_DLL );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    //
                    //  We got here because we just finished processing a
                    //  TRUE expression, so skip the else portion of the if
                    //

                    SkipConditionalBlock( &pchIn, pchEOF, NULL );

                    _cNestedIfs--;
                    break;

                case TAG_TYPE_END_IF:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  endif w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ENDIFS,
                                               NULL,
                                               HTTP_ODBC_DLL );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    _cNestedIfs--;
                    break;

                default:
                case TAG_TYPE_UNKNOWN:
                    goto UnknownTag;

                }
            }
            else
            {
UnknownTag:
                //
                //  Move past the beginning of the tag so the next
                //  search skips this tag
                //

                if ( !SEND_DATA( pchIn, 1 ))
                    return FALSE;

                pchIn += 1;
            }
        }
        else
        {
            //
            //  No more tags, copy the rest of the data to the output
            //  buffer.
            //

            if ( !SEND_DATA( pchIn, (DWORD) -1 ))
                return FALSE;

            break;
        }
    }

    //
    //  Send the last of the data and append the last buffer chain if we're
    //  caching
    //

    err = pfnCallback( pvContext,
                       (CHAR *) _pbufOut->QueryPtr(),
                       cbOut );

    if ( err )
    {
        SetLastError( err );
        goto ErrorExit;
    }


    return TRUE;

ErrorExit:

    //
    //  We've already sent the HTTP headers at this point, so just append the
    //  error text to the end of this document.
    //

    {
        STR str;
        STR strError;

        if ( !GetLastErrorText( &strError )                      ||
             !str.Append( "<h1>Error performing operation</h1>") ||
             !str.Append( strError ) ||
             !str.Append( "</body>"))
        {
            return FALSE;
        }

        err = pfnCallback( pvContext,
                           str.QueryStr(),
                           str.QueryCB() );

        if ( err )
        {
            return FALSE;
        }
    }

    return TRUE;

}
BOOL
ODBC_REQ::NextRow(
    BOOL * pfLast
    )
/*++

Routine Description:

    Advances the result set to the next row

Arguments:

    pfLast - Set to TRUE if there is no more data

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return _podbcstmt->QueryValuesAsStr( &_pstrValues,
                                         &_pcbValues,
                                         pfLast );
}

BOOL
ODBC_REQ::ReplaceParams(
    BUFFER * pbufFile,
    PARAM_LIST* pParamList
    )
/*++

Routine Description:

    This method looks at the query file and replaces any occurrences
    of %xxx% with the specified replacement value from pszParams

Arguments:

    pbufFile - Contents of file buffer
    ParamList - List of parameters to replace in the query file

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD      cParams = 0;
    CHAR *     pch;
    BOOL       fRet = FALSE;
    BOOL       fIsMultiValue;
    CHAR *     pchValue;
    CHAR *     pchTag;
    CHAR *     pchTerm;
    CHAR *     pchOldPointer;
    CHAR *     pchTmp;
    STACK_STR( strMultiValue, MAX_PATH);
    DWORD      cbFile;
    DWORD      cbTag;
    DWORD      cbValue;

    //
    //  Scan the query file looking for %xxx% replacements
    //

    pch = pchOldPointer = (CHAR *) pbufFile->QueryPtr();
    cbFile = strlen( pch ) + sizeof(TCHAR);

    while ( *pch )
    {
        if ( (pchTag = strchr( pch, '%' )) &&
             (pchTerm = strchr( pchTag + 1, '%' )) )
        {
            *pchTerm = '\0';

            //
            //  Was this a '%' escape (i.e., '%%')?
            //

            if ( (pchTag + 1) == pchTerm )
            {
                pchValue = "%";
                goto Found;
            }

            //
            //  Look through the replacement list for a matching param
            //

            pchValue = pParamList->FindValue( pchTag + 1, &fIsMultiValue );

            if ( !pchValue )
            {
                //
                //  Check to see if it's something the client has defined
                //

                if ( _pfnClientFindSymbol != NULL &&
                     _pfnClientFindSymbol( _pFindSymbolContext,
                                           pchTag + 1,
                                           &_strSymbolValue ))
                {
                    if ( !_strSymbolValue.IsEmpty() )
                    {
                        pchValue = _strSymbolValue.QueryStr();
                        fIsMultiValue = FALSE;
                        goto Found;
                    }
                }

                //
                //  We didn't find a match, nuke the tag
                //

                memmove( pchTag,
                         pchTerm + 1,
                         strlen( pchTerm + 1 ) + sizeof(TCHAR));

                pch = pchTag;
                continue;
            }

Found:

            if ( fIsMultiValue )
            {
                //
                //  Determine whether this is a quoted multi-value or not
                //

                pchTmp = pchTag;

                while ( --pchTmp >= pchOldPointer && ISWHITE( *pchTmp ))
                {
                    ;
                }

                if ( !BuildMultiValue( pchValue,
                                       &strMultiValue,
                                       *pchTmp == '\'' ))
                {
                    return FALSE;
                }

                pchValue = strMultiValue.QueryStr();
            }

            //
            //  We have a match, replace the tag with the value.
            //  Note we count the surrounding '%'s with cbTag.
            //

            cbTag    = DIFF(pchTerm - pchTag) + sizeof(TCHAR);
            cbValue  = strlen( pchValue );

            if ( cbValue > cbTag )
            {
                //
                //  Resize if needed but watch for pointer shift
                //

                if ( pbufFile->QuerySize() < (cbFile + cbValue - cbTag))
                {
                    if ( !pbufFile->Resize( cbFile + cbValue - cbTag, 512 ))
                        goto Exit;

                    if ( pbufFile->QueryPtr() != pchOldPointer )
                    {
                        CHAR * pchNewPointer = (TCHAR *) pbufFile->QueryPtr();
                        DWORD  cchLen = strlen( pchNewPointer);

                        pch     = pchNewPointer + (pch - pchOldPointer);
                        pchTag  = pchNewPointer + (pchTag - pchOldPointer);
                        pchTerm = pchNewPointer + (pchTerm - pchOldPointer);
                        pchOldPointer = pchNewPointer;

                        TCP_ASSERT( pch >= pchNewPointer &&
                                   pch < pchNewPointer + cchLen);
                        TCP_ASSERT( pchTag >= pchNewPointer &&
                                   pchTag < pchNewPointer + cchLen);
                        TCP_ASSERT( pchTerm >= pchNewPointer &&
                                   pchTerm <= pchNewPointer + cchLen);
                    }
                }

                //
                //  Expand the space for the value
                //

                memmove( pchTerm + 1 + cbValue - cbTag,
                         pchTerm + 1,
                         strlen( pchTerm + 1 ) + sizeof(TCHAR) );

                cbFile += cbValue - cbTag;
            }
            else
            {
                //
                //  Collapse the space since tag is longer then the value
                //

                memmove( pchTag + cbValue,
                         pchTerm + 1,
                         strlen(pchTerm + 1) + sizeof(TCHAR) );

                cbFile -= cbTag - cbValue;
            }

            //
            //  Replace the tag value with the replacement value
            //

            memcpy( pchTag,
                    pchValue,
                    cbValue );
            pch = pchTag + cbValue;
        }
        else
        {
            //
            //  No more tags to replace so get out
            //

            break;
        }
    }

    fRet = TRUE;

Exit:

    return fRet;
}

VOID
ODBC_REQ::LookupTag(
    CHAR *          pchBeginTag,
    const CHAR * *  ppchAfterTag,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue,
    enum TAG_TYPE * pTagType
    )
/*++

Routine Description:

    This method looks at the tag, determines the tag type and
    returns the associated value.  This is used only for the .htx file.

Arguments:

    pchBeginTag - Points to first character of tag (i.e., '<')
    ppchAfterTag - Receives the first character after the tag if
        the tag
    ppchValue - If the tag is a value, returns the database value
    pcbValue - Receives number of bytes in the value being returned
    pTagType - Returns the tag type

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR * pchTerm;
    BOOL   fLongTagMarker;
    STACK_STR( strTagName, 128);
    DWORD  cchToCopy;
    BOOL   fDoEsc = FALSE;

    *pTagType = TAG_TYPE_UNKNOWN;
    *ppchAfterTag = pchBeginTag;
    *pcbValue = (DWORD) -1;

    TCP_ASSERT( !memcmp( pchBeginTag, "<!--%", 5 ) ||
                !memcmp( pchBeginTag, "<%", 2 ));

    fLongTagMarker = pchBeginTag[1] == '!';

    //
    //  Move past the tag marker
    //

    pchBeginTag += (fLongTagMarker ? 5 : 2);

    if ( *pchBeginTag == '"' )
    {
        if ( !memcmp( pchBeginTag, "\"%z\",", sizeof("\"%z\",") - 1 ) )
        {
            fDoEsc = TRUE;
            pchBeginTag += sizeof("\"%z\",") - 1;
        }
        else
        {
            return;
        }
    }

    //
    //  Find the end of the tag and make a copy.
    //

    pchTerm = strchr( pchBeginTag, '%' );

    if ( !pchTerm )
        return;

    cchToCopy = DIFF(pchTerm - pchBeginTag);

    if ( !strTagName.Copy( pchBeginTag, cchToCopy * sizeof( TCHAR )))
        return;

    LookupSymbol( strTagName.QueryStr(),
                  pTagType,
                  ppchValue,
                  pcbValue );

    if ( fDoEsc && *pTagType == TAG_TYPE_VALUE )
    {
        *pTagType = TAG_TYPE_VALUE_TO_ESCAPE;
    }

    if ( *pTagType != TAG_TYPE_IF )
    {
        *ppchAfterTag = pchTerm + (fLongTagMarker ? 4 : 2);
    }
    else
    {
        //
        //  We leave the pointer on the expression if this was an if
        //

        *ppchAfterTag = NEXT_TOKEN(pchBeginTag);
    }

    *pchTerm = '%';
}

BOOL
ODBC_REQ::LookupSymbol(
    const CHAR *    pchSymbolName,
    enum TAG_TYPE * pTagType,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue
    )
/*++

Routine Description:

    Looks to see if the specified symbol name is defined and what the type
    value of the symbol is.

    The "if" symbols is special cased to allow the expression to follow it

    If the symbol is a multi-value field (from command line) then the tabs
    in the value in will be replaced by commas.

Arguments:

    pchSymbolName - Name of zero terminated symbol to find
    pTagType - Returns the tag type of the symbol
    ppchValue - Returns a pointer to the string value of the symbol
        if it has one
    pcbValue - Returns length of value

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL fIsMultiValue;

    //
    //  Does the symbol match one of the column names?
    //

    if ( _pstrCols && _pstrValues )
    {
        for ( DWORD i = 0; i < _cCols; i++ )
        {
            if ( !lstrcmpi( _pstrCols[i].QueryStr(),
                           pchSymbolName ))
            {
                *pTagType = TAG_TYPE_VALUE;
                *ppchValue = _pstrValues[i].QueryStr();
                *pcbValue  = _pcbValues[i];

                //
                //  BugID 33406 - Don't return half DBCS char at end of data
                //

                if ( g_fIsSystemDBCS )
                {
                    CHAR * pch;
                    for ( pch = (CHAR *)*ppchValue; *pch; pch++ )
                    {
                        if ( IsDBCSLeadByte( *pch ) )
                        {
                            if ( !*(pch+1) )
                            {
                                *pch = '\0';
                                (*pcbValue)--;
                                break;
                            }
                            pch++;
                        }
                    }
                }
                goto Found;
            }
        }
    }

    //
    //  Does it match any of the special values?
    //

    if ( !_stricmp( pchSymbolName, BEGIN_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_BEGIN_DETAIL;
        goto Found;
    }
    else if ( !_stricmp( pchSymbolName, END_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_END_DETAIL;
        goto Found;
    }
    else if ( !_strnicmp( pchSymbolName, IF_TEXT, sizeof(IF_TEXT) - 1 ))
    {
        //
        //  The IF tag is treated a little bit differently cause we expect
        //  the expression to be included as part of the symbol
        //

        *pTagType = TAG_TYPE_IF;
        goto Found;
    }
    else if ( !_stricmp( pchSymbolName, END_IF_TEXT ))
    {
        *pTagType = TAG_TYPE_END_IF;
        goto Found;
    }
    else if ( !_stricmp( pchSymbolName, ELSE_TEXT ))
    {
        *pTagType = TAG_TYPE_ELSE;
        goto Found;
    }

    //
    //  Is it one of the parameters from the query (either one of the form
    //  fields or from the DefaultParameters field in the wdg file)?  These
    //  must be prefixed by "idc.", that is "<%idc.Assign%>"
    //

    if ( !_strnicmp( pchSymbolName, "idc.", 4 )    &&
         (*ppchValue = _plParams.FindValue( pchSymbolName + 4,
                                            &fIsMultiValue,
                                            pcbValue )) ) 
    {
        *pTagType = TAG_TYPE_VALUE;

        //
        //  If this is a multi-value field, replace all the tabs with commas.
        //  This is somewhat of a hack as it breaks the use of this field when
        //  multiple queries are supported
        //

        if ( fIsMultiValue )
        {
            CHAR * pchtmp = (CHAR *) *ppchValue;

            while ( pchtmp = strchr( pchtmp, '\t' ))
            {
                *pchtmp = ',';
            }
        }

        goto Found;
    }

    //
    //  Lastly, check to see if it's something the client has defined
    //

    if ( _pfnClientFindSymbol != NULL &&
         _pfnClientFindSymbol( _pFindSymbolContext,
                               pchSymbolName,
                               &_strSymbolValue ))
    {
        if ( !_strSymbolValue.IsEmpty() )
        {
            *pTagType  = TAG_TYPE_VALUE;
            *ppchValue = _strSymbolValue.QueryStr();
            *pcbValue  = _strSymbolValue.QueryCB();
            goto Found;
        }
    }

Found:
    return TRUE;
}

BOOL
ODBC_REQ::EvaluateExpression(
    const CHAR * * ppchExpression,
    BOOL *         pfExprValue
    )
/*++

Routine Description:

    Performs simple expression evaluation for an 'if' tag in the
    template file.  Valid expressions are:

    <%if <V1> <OP> <V2>%>

    where V1, V2 can be one of:
        Positive integer
        TotalRecords - Total records contained in result set
        MaxRecords - The maximum records specified in the query file

    OP can be one of:
        EQ - Equal
        LT - Less then
        GT - Greater then

Arguments:

    ppchExpression - Points to V1 on entry, set to the first character
        after the end tag on exit
    pfExprValue - TRUE if the expression is TRUE, FALSE otherwise

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    EXPR_VALUE v1( this );
    EXPR_VALUE v2( this );
    TAG_TYPE   OpType;
    STR        strError;
    CHAR *     pch;

    if ( !v1.Evaluate( ppchExpression )               ||
         !EvaluateOperator( ppchExpression, &OpType ) ||
         !v2.Evaluate( ppchExpression ))
    {
        return FALSE;
    }

    //
    //  If the symbols weren't found, default them to empty
    //  strings
    //

    if ( v1.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v1.SetType( TAG_TYPE_STRING );
    }

    if ( v2.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v2.SetType( TAG_TYPE_STRING );
    }

    //
    //  The value types must match
    //

    if ( v1.QueryType() != v2.QueryType() )
    {
        BOOL fSt = FALSE;

        if ( v1.QueryType() == TAG_TYPE_STRING && v2.QueryType() == TAG_TYPE_INTEGER )
            fSt = v1.ConvertToInteger();
        else if ( v1.QueryType() == TAG_TYPE_INTEGER && v2.QueryType() == TAG_TYPE_STRING )
            fSt = v2.ConvertToInteger();

        if ( !fSt )
        {
            strError.FormatString( ODBCMSG_MISMATCHED_VALUES,
                                   NULL,
                                   HTTP_ODBC_DLL );
            SetErrorText( strError.QueryStr());

            return FALSE;
        }
    }

    //
    //  Move the current position to the end of this tag
    //

    if ( pch = strchr( *ppchExpression, '>' ))
    {
        *ppchExpression = pch + 1;
    }

    switch ( OpType )
    {
    case TAG_TYPE_OP_LT:

        *pfExprValue = v1.LT( v2 );
        break;

    case TAG_TYPE_OP_GT:

        *pfExprValue = v1.GT( v2 );
        break;

    case TAG_TYPE_OP_EQ:

        *pfExprValue = v1.EQ( v2 );
        break;

    case TAG_TYPE_OP_CONTAINS:

        //
        //  Contains is only valid for string values
        //

        if ( v1.QueryType() != TAG_TYPE_STRING )
        {
            strError.FormatString( ODBCMSG_CONTAINS_ONLY_VALID_ON_STRINGS,
                                   NULL,
                                   HTTP_ODBC_DLL );
            SetErrorText( strError.QueryStr());

            return FALSE;
        }

        *pfExprValue = v1.CONTAINS( v2 );
        break;

    default:

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    return TRUE;
}

BOOL
ODBC_REQ::EvaluateOperator(
    const CHAR * * ppchExpression,
    TAG_TYPE *     pTagType
    )
/*++

Routine Description:

    Determines which operator is being used in this expression

Arguments:

    ppchExpression - Points to the operator on entry, set to the
        next token on exit
    pTagType - Receives operator type

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( COMP_FIELD( *ppchExpression, "GT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_GT;
    }
    else if ( COMP_FIELD( *ppchExpression, "LT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_LT;
    }
    else if ( COMP_FIELD( *ppchExpression, "EQ", 2 ))
    {
        *pTagType = TAG_TYPE_OP_EQ;
    }
    else if ( COMP_FIELD( *ppchExpression, "CONTAINS", 8 ))
    {
        *pTagType = TAG_TYPE_OP_CONTAINS;
    }
    else
    {
        //
        //  Unknown operator specified
        //

        STR strError;

        strError.FormatString( ODBCMSG_UNRECOGNIZED_OPERATOR,
                               NULL,
                               HTTP_ODBC_DLL );
        SetErrorText( strError.QueryStr());
        return FALSE;
    }

    *ppchExpression = NEXT_TOKEN( *ppchExpression );

    return TRUE;
}

BOOL
ODBC_REQ::SendData(
    ODBC_REQ_CALLBACK        pfnCallback,
    PVOID                    pvContext,
    const CHAR *             pbData,
    DWORD                    cbData,
    BUFFER_CHAIN_ITEM  * *   ppbufOut,
    DWORD *                  pcbOut
    )
/*++

Routine Description:

    This method buffers the outgoing data and sends it when the
    output buffer is full

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pbData - Pointer to data to send
    cbData - Number of bytes to send
    ppbufOut - Output buffer to buffer nonsent and cached data in
    pcbOut - Number of valid bytes in output buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD               cbToCopy;
    DWORD               err;
    BUFFER_CHAIN_ITEM * pbufOut = *ppbufOut;
    STACK_STR(          strTemp, MAX_PATH);

    //
    //  if cbData is -1 then assume the data is zero terminated
    //

    if ( cbData == -1 )
        cbData = strlen( pbData );

    //
    //  Convert the string from shift_jis to iso-2022-jp or euc-jp
    //

    if ( CODE_ONLY_SBCS != _nCharset )
    {
        int cbUNIXSize;
        int nResult;

        //
        //  Get the size after Conversion
        //

        cbUNIXSize = PC_to_UNIX(
                            GetACP(),
                            _nCharset,
                            (UCHAR *)pbData,
                            (int)cbData,
                            NULL,
                            0 );

        if ( !strTemp.Resize( cbUNIXSize + sizeof(TCHAR) ))
            return FALSE;

        //
        //  Do conversion
        //

        nResult = PC_to_UNIX(
                            GetACP(),
                            _nCharset,
                            (UCHAR *)pbData,
                            (int)cbData,
                            (UCHAR *)strTemp.QueryStr(),
                            cbUNIXSize );
        if ( -1 == nResult || nResult != cbUNIXSize )
            return FALSE;

        //
        //  update the string pointer and count
        //

        pbData = strTemp.QueryStr();
        cbData = cbUNIXSize;

        *(strTemp.QueryStr() + cbUNIXSize) = '\0';
    }

    //
    //  Append the new data onto the old data
    //

    cbToCopy = min( cbData, OUTPUT_BUFFER_SIZE - *pcbOut );

    memcpy( (BYTE *) pbufOut->QueryPtr() + *pcbOut,
            pbData,
            cbToCopy );

    *pcbOut += cbToCopy;
    cbData  -= cbToCopy;
    pbData  += cbToCopy;

    //
    //  If we filled up the buffer, send the data
    //

    if ( cbData )
    {
        err = pfnCallback( pvContext,
                           (CHAR *) pbufOut->QueryPtr(),
                           *pcbOut );

        if ( err )
        {
            SetLastError( err );
            return FALSE;
        }

        *pcbOut = 0;
    }
    else
    {
        return TRUE;
    }

    //
    //  We know at this point the output buffer is empty
    //

    while ( cbData )
    {
        //
        //  If the input data will fill the output buffer, send the
        //  data directly from the input buffer
        //

        if ( cbData > OUTPUT_BUFFER_SIZE  )
        {
            err = pfnCallback( pvContext,
                               pbData,
                               OUTPUT_BUFFER_SIZE );

            if ( err )
            {
                SetLastError( err );
                return FALSE;
            }

            cbData -= OUTPUT_BUFFER_SIZE;
            pbData += OUTPUT_BUFFER_SIZE;
        }
        else
        {
            //
            //  We don't have enough to send so put it in the output buffer
            //

            memcpy( pbufOut->QueryPtr(),
                    pbData,
                    cbData );

            *pcbOut = cbData;
            break;
        }
    }

    return TRUE;
}


BOOL
ODBC_REQ::SkipConditionalBlock(
    const CHAR * *  ppchIn,
    const CHAR *    pchEOF,
    const CHAR *    pchSearchTag
    )
/*++

Routine Description:

    Skip a conditional block delimited by ENDIF or specified Tag
    returns TRUE if specified Tag found instead of ENDIF or end of text

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchIf;
    const CHAR * pchEndif;
    const CHAR * pchTag;
    int cLev = 0;

    for ( ; pchIn < pchEOF ; )
    {
        pchEndif = pchIf = pchIn;
        SkipToTag( &pchIf, IF_TEXT );
        SkipToTag( &pchEndif, END_IF_TEXT );
        if ( pchSearchTag == NULL )
            pchTag = pchEOF;
        else
        {
            pchTag = pchIn;
            SkipToTag( &pchTag,  pchSearchTag );
        }
        if ( pchIf < pchTag && pchIf < pchEndif )
        {
            ++cLev;
            pchIn = pchIf;
        }
        else if ( pchTag < pchIf && pchTag < pchEndif )
        {
            if ( !cLev )
            {
                *ppchIn = pchTag;
                return TRUE;
            }
            pchIn = pchTag;
        }
        else    // END_IF_TEXT or nothing found
        {
            if ( !cLev )
            {
                *ppchIn = pchEndif;
                return FALSE;
            }
            --cLev;
            pchIn = pchEndif;
        }
    }

    // else/endif not found

    *ppchIn = pchEOF;

    return FALSE;
}


VOID
ODBC_REQ::SkipToTag(
    const CHAR * *  ppchIn,
    const CHAR *    pchTag
    )
/*++

Routine Description:

    Given the name of a tag, skips to the first character after the tag

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    DWORD  cchTag;

    cchTag = strlen( pchTag );

    while ( pchIn = strchr( pchIn, '<' ))
    {
        if ( (!memcmp( pchIn, "<!--%", 5 ) ||
              !memcmp( pchIn, "<%", 2 ))   &&
              !_strnicmp( pchIn + (pchIn[1] == '!' ? 5 : 2),
                         pchTag,
                         cchTag ))
        {
            goto Found;
        }
        else
            pchIn++;
    }

    //
    //  Not found, return the end of file
    //

    *ppchIn += strlen( *ppchIn );

    return;

Found:

    pchIn = strchr( pchIn + cchTag, '>' );
    if ( !pchIn )
    {
        *ppchIn += strlen( *ppchIn );
    }
    else
    {
        *ppchIn = pchIn + 1;
    }

    return;
}

BOOL
ODBC_REQ::IsEqual(
    ODBC_REQ * podbcreq
    )
/*++

Routine Description:

    Determines if the passed query's parameter would make it equivalent
    to this query

    A query is deemed equal if:

        1) The query has the same number of parameters passed from the client
        2) The query's parameters match

    Note parameter comparison is case insensitive for both the field and the
    value

    The template can be different if it's parameterized, but we'll pick up the
    difference in the parameter list in this case.

    Since podbcreq is a query that has already been processed, it may contain
    additional values from the .wdg default list.

Arguments:

    podbcreq - Query to check for equality

--*/
{
    VOID * pCookie = NULL;
    CHAR * pszField;
    CHAR * pszValue1, * pszValue2;

    //
    //  First compare the number of parameters passed from the client
    //

    if ( QueryClientParamCount() != podbcreq->QueryClientParamCount() )
    {
        return FALSE;
    }

    //
    //  Walk the list of parameters making sure they all match
    //

    while ( pCookie = podbcreq->_plParams.NextPair( pCookie,
                                                    &pszField,
                                                    &pszValue1 ))
    {
        if ( !(pszValue2 = _plParams.FindValue( pszField )) ||
              lstrcmpi( pszValue1, pszValue2 ))
        {
            //
            //  Either the value wasn't found or it doesn't match,
            //  the queries are not equal
            //

            return FALSE;
        }
    }

    //
    //  The queries are equal
    //

    return TRUE;
}

BOOL
ODBC_REQ::AppendHeaders(
    STR * pstrHeaders
    )
/*++

Routine Description:

    Adds any headers required for this query, this will generally be
    the content type and an Expires header if this query is cached

Arguments:

    pstrHeaders - String to append headers to

--*/
{
    CHAR *     pszTail;

    if ( !pstrHeaders->Resize( 255 ))
    {
        return FALSE;
    }

    pszTail = pstrHeaders->QueryStr();


    pszTail += wsprintf( pszTail,
                         "Content-Type: %s\r\n\r\n",
                         QueryContentType() );

    return TRUE;
}

BOOL
ODBC_REQ::GetLastErrorText(
    STR * pstrError
    )
{
    //
    //  If we stored an error explanation return that, otherwise fall back
    //  to an ODBC error
    //

    if ( !_strErrorText.IsEmpty() )
    {
        return pstrError->Copy( _strErrorText );
    }
    else if ( _podbcstmt )
        return _podbcstmt->GetLastErrorTextAsHtml( pstrError );
    else
        return QueryOdbcConnection()->GetLastErrorTextAsHtml( pstrError,
                                       SQL_NULL_HSTMT,
                                       QueryOdbcConnection()->QueryErrorCode() );
}

BOOL
EXPR_VALUE::ConvertToInteger(
    VOID )
{
    if ( _tagType == TAG_TYPE_STRING )
    {
        PSTR pS =_strValue.QueryStr();
        if ( *pS == '-' || isdigit(*(UCHAR *)pS) )
        {
            _dwValue = atoi( pS );
            _tagType = TAG_TYPE_INTEGER;

            return TRUE;
        }
    }

    return FALSE;
}

BOOL
EXPR_VALUE::Evaluate(
    const CHAR * * ppchIn
    )
/*++

Routine Description:

    Determines the type of value and retrieves the value appropriately

Arguments:

    ppchIn - Pointer to first character of value on way in, next token
        on they way out

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchEnd;
    const CHAR * pchValue;
    DWORD        cbValue;
    STR          strError;
    DWORD        cchToCopy;

    if ( isdigit( *(UCHAR *)pchIn ) )
    {
        //
        //  Simple number
        //

        _tagType = TAG_TYPE_INTEGER;
        _dwValue = atoi( pchIn );
        while ( isdigit( *(UCHAR *)pchIn ) )
        {
            pchIn++;
        }

        *ppchIn  = SkipWhite( pchIn );
    }
    else if ( *pchIn == '"' )
    {
        //
        //  Simple string, find the closing quote
        //

        pchEnd = strchr( ++pchIn, '\"' );

        if ( !pchEnd )
        {
            strError.FormatString( ODBCMSG_UNBALANCED_STRING,
                                   NULL,
                                   HTTP_ODBC_DLL );
            _podbcreq->SetErrorText( strError.QueryStr());

            return FALSE;
        }

        cchToCopy = DIFF(pchEnd - pchIn);

        if ( !_strValue.Copy( pchIn, cchToCopy * sizeof(CHAR) ))
        {
            return FALSE;
        }

        _tagType = TAG_TYPE_STRING;
        *ppchIn = SkipWhite( pchEnd + 1 );
    }
    else
    {
        STACK_STR( strSymbol, 64 );
        DWORD cchToCopy;

        //
        //  This is a keyword we need to interpret
        //

        //
        //  These fields are delimited with either white space
        //  or '\'' or the closing %>
        //

        pchEnd = pchIn;

        if ( *pchEnd == '\'' )
        {
            ++pchIn;
            ++pchEnd;
            while ( *pchEnd && *pchEnd != '\'' && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }
        else
        {
            while ( *pchEnd && !ISWHITE( *pchEnd ) && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }

        if ( COMP_FIELD( "MaxRecords", pchIn, 10 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryMaxRecords();
        }
        else if ( COMP_FIELD( "CurrentRecord", pchIn, 12 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryCurrentRecordNum();
        }
        else
        {
            //
            //  Isolate the symbol name
            //

            cchToCopy = DIFF(pchEnd - pchIn);

            if ( !strSymbol.Copy( pchIn, cchToCopy * sizeof(CHAR)))
                return FALSE;

            //
            //  Look up the symbol
            //

            if ( !_podbcreq->LookupSymbol( strSymbol.QueryStr(),
                                           &_tagType,
                                           &pchValue,
                                           &cbValue ))
            {
                return FALSE;
            }

            if ( _tagType == TAG_TYPE_VALUE ||
                 _tagType == TAG_TYPE_STRING )
            {
                if ( !_strValue.Copy( pchValue ))
                    return FALSE;

                _tagType = TAG_TYPE_STRING;
            }
        }

        if ( *pchEnd == '\'' )
        {
            ++pchEnd;
        }

        *ppchIn = SkipWhite( pchEnd );
    }

    return TRUE;
}

BOOL
EXPR_VALUE::GT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Greater Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() > v1.QueryInteger();
    }
    else
    {
        return lstrcmpi( QueryStr(), v1.QueryStr() ) > 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::LT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Less Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() < v1.QueryInteger();
    }
    else
    {
        return lstrcmpi( QueryStr(), v1.QueryStr() ) < 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::EQ(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Equal to v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() == v1.QueryInteger();
    }
    else
    {
        return lstrcmpi( QueryStr(), v1.QueryStr() ) == 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::CONTAINS(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this contains the string in v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() != TAG_TYPE_STRING     ||
         v1.QueryType() != TAG_TYPE_STRING )
    {
        return FALSE;
    }

    //
    //  Upper case the strings then do a search
    //

    UpperCase();
    v1.UpperCase();

    return strstr( QueryStr(), v1.QueryStr() ) != NULL;
}


const CHAR * SkipNonWhite( const CHAR * pch )
{
    while ( *pch && !ISWHITE( *pch ) && *pch != '\n' )
        pch++;

    return pch;
}

const CHAR * SkipTo( const CHAR * pch, CHAR ch )
{
    while ( *pch && *pch != '\n' && *pch != ch )
        pch++;

    return pch;
}

const CHAR * SkipWhite( const CHAR * pch )
{
    while ( ISWHITE( *pch ) )
    {
        pch++;
    }

    return pch;
}

struct _ODBC_OPTIONS
{
    CHAR *   pszOptionName;
    DWORD    dwOption;
    BOOL     fNumeric;
}
OdbcOptions[] =
{
    //
    //  Order roughly in order of likelihood of being used
    //

    "SQL_OPT_TRACEFILE",       SQL_OPT_TRACEFILE,     FALSE,
    "SQL_QUERY_TIMEOUT",       SQL_QUERY_TIMEOUT,     TRUE,
    "SQL_MAX_ROWS",            SQL_MAX_ROWS,          TRUE,
    "SQL_LOGIN_TIMEOUT",       SQL_LOGIN_TIMEOUT,     TRUE,
    "SQL_PACKET_SIZE",         SQL_PACKET_SIZE,       TRUE,

    "SQL_NOSCAN",              SQL_NOSCAN,            TRUE,
    "SQL_MAX_LENGTH",          SQL_MAX_LENGTH,        TRUE,
    "SQL_ASYNC_ENABLE",        SQL_ASYNC_ENABLE,      TRUE,
    "SQL_ACCESS_MODE",         SQL_ACCESS_MODE,       TRUE,
    "SQL_OPT_TRACE",           SQL_OPT_TRACE,         TRUE,
    "SQL_TRANSLATE_OPTION",    SQL_TRANSLATE_OPTION,  TRUE,
    "SQL_TXN_ISOLATION",       SQL_TXN_ISOLATION,     TRUE,
    "SQL_TRANSLATE_DLL",       SQL_TRANSLATE_DLL,     FALSE,
    "SQL_CURRENT_QUALIFIER",   SQL_CURRENT_QUALIFIER, FALSE,
    NULL,                      0,                     0
};

BOOL
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STR *             pStrOptions
    )
/*++

Routine Description:

    Sets the options specified in the OdbcOptions: keyword of the .wdg file

Arguments:

    pOdbcConn - ODBC connection to set options on
    pStrOptions - List of options in "v=f,y=z" format.  Note that if the


--*/
{
    PARAM_LIST OptionList;
    VOID *     pvCookie = NULL;
    CHAR *     pszField;
    CHAR *     pszValue;
    DWORD      dwOption;
    DWORD      dwValue;
    DWORD      i;

    if ( !OptionList.ParsePairs( pStrOptions->QueryStr(),
                                 FALSE,
                                 FALSE))
    {
        return FALSE;
    }

    while ( pvCookie = OptionList.NextPair( pvCookie,
                                            &pszField,
                                            &pszValue ))
    {
        //
        //  If the field is a digit, then this is a driver specific option.
        //  convert the value and field as appropriate,
        //  otherwise look it up in our option table
        //

        if ( isdigit( *(UCHAR *)pszField ))
        {
            dwOption = atoi( pszField );

            if ( isdigit( *(UCHAR *)pszValue ))
            {
                dwValue = atoi( pszValue );
            }
            else
            {
                dwValue = (DWORD) pszValue;     // BUGBUG64
            }
        }
        else
        {
            i = 0;

            while ( OdbcOptions[i].pszOptionName )
            {
                if ( !_stricmp( OdbcOptions[i].pszOptionName,
                               pszField ))
                {
                    goto Found;
                }

                i++;
            }

            //
            //  Not found, skip this value
            //

            continue;

Found:
            dwOption = OdbcOptions[i].dwOption;

            if ( OdbcOptions[i].fNumeric )
            {
                //
                //  Numeric option, convert the value
                //

                dwValue = atoi( pszValue );
            }
            else
            {
                dwValue = (DWORD) pszValue;     // BUGBUG64
            }
        }

        pOdbcConn->SetConnectOption( (UWORD) dwOption, (UDWORD) dwValue );
    }

    return TRUE;
}

BOOL
BuildMultiValue(
    const CHAR * pchValue,
    STR *        pstrMulti,
    BOOL         fQuoteElements
    )
{
    CHAR * pchtmp = (CHAR *) pchValue;
    DWORD  cElements = 0;

    //
    //  If we're going to have to expand the size of the string, figure out
    //  the total size we'll need now
    //

    if ( fQuoteElements )
    {
        while ( pchtmp = strchr( pchtmp, '\t' ))
        {
            cElements++;
            pchtmp++;
        }

        if ( !pstrMulti->Resize( strlen( pchValue ) + 1 + 2 * cElements ))
            return FALSE;
    }

    if ( !pstrMulti->Copy( pchValue ))
        return FALSE;

    //
    //  Replace tabs with "','" if fQuoteElements is TRUE, otherwise just ','
    //

    pchtmp = pstrMulti->QueryStr();

    while ( pchtmp = strchr( pchtmp, '\t' ))
    {
        if ( fQuoteElements )
        {
            memmove( pchtmp + 3,
                     pchtmp + 1,
                     strlen( pchtmp + 1 ) + sizeof(CHAR));

            memcpy( pchtmp, "','", 3 );
        }
        else
        {
            *pchtmp = ',';
        }
    }

    return TRUE;
}


//
//  Converts a value between zero and fifteen to the appropriate hex digit
//

#define HEXDIGIT( nDigit )                              \
    (TCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')


BOOL ODBC_REQ::SendEscapedData(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    PCSTR pch,
    DWORD cbIn,
    LPDWORD pcbOut )
/*++

Routine Description:

    This method escape the outgoing data and then send it to the
    SendData() function

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pch - Pointer to data to send
    cbIn - Number of bytes to send
    pcbOut - Number of valid bytes in output buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR    ch;
    int     cNonEscaped = 0;
    DWORD   cbOut;


    #define SEND_DATA2( pchData, cbData )  SendData( pfnCallback,  \
                                                    pvContext,     \
                                                    (pchData),     \
                                                    (cbData),      \
                                                    &_pbufOut,     \
                                                    pcbOut )

    if ( cbIn == (DWORD)-1 )
    {
        cbIn = strlen( pch );
    }

    while ( cbIn-- )
    {
        ch = *pch;

        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&')) &&
             !(ch == TEXT('\n') || ch == TEXT('\r'))  )
        {
            TCHAR achTmp[3];

            //
            //  Insert the escape character
            //

            achTmp[0] = TEXT('%');

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            achTmp[2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            achTmp[1] = HEXDIGIT( nDigit );

            if ( cNonEscaped && !SEND_DATA2( pch-cNonEscaped, cNonEscaped ) )
            {
                return FALSE;
            }

            if ( !SEND_DATA2( achTmp, sizeof(achTmp) ) )
            {
                return FALSE;
            }

            cNonEscaped = 0;
        }
        else
        {
            ++cNonEscaped;
        }

        ++pch;
    }

    if ( cNonEscaped && !SEND_DATA2( pch-cNonEscaped, cNonEscaped ) )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
GetFileData(
    IN     const CHAR *             pchFile,
//    IN     HANDLE                   hToken,
    OUT    BYTE * *                 ppbData,
    OUT    DWORD *                  pcbData,
    IN     int                      nCharset,
    IN     BOOL                     fUseWin32Canon
    )
/*++
    Description:

        Attempts to retrieve the passed file from the cache.  If it's not
        cached, then we read the file and add it to the cache.

    Arguments:

        pchFile - Fully qualified file to retrieve
        pTsvcCache - Cache object to charge memory against
        hToken - Impersonation token to open the file with
        pcbData - Receives pointer to first byte of data, used as handle to
            free data
        pcbSize - Size of output buffer
        pCacheFileInfo - File cache information
        nCharset - Charset (if this isn't SJIS, we convert it to SJIS
            before Check-In)
        ppSecDesc - Returns security descriptor if not null
        fUseWin32Canon - The resource has not been canonicalized and it's ok
            to use the win32 canonicalization code

    Returns:
        TRUE if successful, FALSE otherwise

    Notes:

        The file is extended by two bytes and is appended with two zero bytes,
        thus callers are guaranteed of a zero terminated text file.

--*/
{
    DWORD                   cbLow, cbHigh;
    BYTE *                  pbData = NULL;
    BYTE *                  pbBuff = NULL;
    int                     cbSJISSize;

        HANDLE hFile = CreateFile(pchFile,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 NULL,//&sa,
                                 OPEN_EXISTING,
                   FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS,
                                 NULL );

		if ( hFile == INVALID_HANDLE_VALUE)
		{
			DWORD ErrorFlag1 = GetLastError();
			goto ErrorExit;
		}
		else
		{
			WIN32_FILE_ATTRIBUTE_DATA    FileAttributes; 		
			
			if ( !GetFileAttributesEx( pchFile,
								GetFileExInfoStandard, 
										&FileAttributes))
			{
				DWORD ErrorFlag2 = GetLastError();
				goto ErrorExit;
			}
		
			cbHigh = FileAttributes.nFileSizeHigh;
			cbLow = FileAttributes.nFileSizeLow;
		}
        //
        //  Limit the file size to 128k
        //

        if ( cbHigh || cbLow > 131072L )
        {
            SetLastError( ERROR_NOT_SUPPORTED );
            goto ErrorExit;
        }

        if ( CODE_ONLY_SBCS != nCharset )
        {
            if ( !( pbBuff = pbData = (BYTE *) LocalAlloc( LPTR, cbLow ) ) )
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY);
                goto ErrorExit;
            }
        }
        else 
		{
            if ( ! (pbData = (BYTE *) LocalAlloc(LPTR, cbLow + sizeof(WCHAR)) ))
                goto ErrorExit;
        }        

        //
        //  Read the file data
        //

        if ( !DoSynchronousReadFile( hFile,
                        (PCHAR) pbData,
                        cbLow,
                        pcbData,
                        NULL )) 
		{
            goto ErrorExit;
        }

        
		
		if ( CODE_ONLY_SBCS != nCharset )
        {
            pbData = NULL;

            //
            //  get the length after conversion
            //

            cbSJISSize = UNIX_to_PC( GetACP(),
                                     nCharset,
                                     pbBuff,
                                     *pcbData,
                                     NULL,
                                     0 );
            DBG_ASSERT( cbSJISSize <= (int)cbLow );
			
            if ( ! (pbData = (BYTE *) LocalAlloc(LPTR, cbSJISSize + sizeof(WCHAR)) ))
                goto ErrorExit;
            
            //
            //  conversion
            //

            UNIX_to_PC( GetACP(),
                        nCharset,
                        pbBuff,
                        *pcbData,
                        pbData,
                        cbSJISSize );
            *pcbData = cbLow = cbSJISSize;
        }

        DBG_ASSERT( *pcbData <= cbLow );

        //
        //  Zero terminate the file for both ANSI and Unicode files
        //

        *((WCHAR UNALIGNED *)(pbData + cbLow)) = L'\0';

        *pcbData += sizeof(WCHAR);

		*ppbData = pbData;

		DBG_REQUIRE( CloseHandle(hFile) );

    if ( pbBuff )
    {
        LocalFree( pbBuff );
    }


    return TRUE;

ErrorExit:
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        DBG_REQUIRE( CloseHandle(hFile) );
    }

    if ( pbBuff )
    {
        if ( pbBuff == pbData )
        {
             pbData = NULL;
        }
        LocalFree( pbBuff );
    }

    if ( pbData )
    {
       DBG_REQUIRE( LocalFree(pbData));
    }

    return FALSE;
}


BOOL
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    )
/*++

    Description:
        Does Asynchronous file reads.  Assumes that NT handles are
        opened for OVERLAPPED I/O, win95 handles are not.

    Arguments:
        hFile - Handle to use for the read
        Buffer - Buffer to read with
        nBuffer - size of buffer
        nRead - returns the number of bytes read
        Overlapped - user supplied overlapped structure

    Returns:
        TRUE/FALSE
--*/
{
    BOOL        fNewEvent = FALSE;
    OVERLAPPED  ov;
    BOOL        fRet = FALSE;
    DWORD err = NO_ERROR;
    
	if ( Overlapped == NULL ) 
	{

        Overlapped = &ov;
        ov.Offset = 0;
        ov.OffsetHigh = 0;
        ov.hEvent = IIS_CREATE_EVENT(
                        "OVERLAPPED::hEvent",
                        &ov,
                        TRUE,
                        FALSE
                        );

        if ( ov.hEvent == NULL ) {
            DBGPRINTF((DBG_CONTEXT,"CreateEvent failed with %d\n",
                GetLastError()));
            goto ErrorExit;
        }

        fNewEvent = TRUE;
    }

//  if ( !TsIsWindows95() ) 
//	{


        if ( !ReadFile( hFile,
                        Buffer,
                        nBuffer,
                        nRead,
                        Overlapped )) 
		{

            err = GetLastError();

            if ( (err != ERROR_IO_PENDING) &&
                 (err != ERROR_HANDLE_EOF) ) 
			{

                DBGPRINTF((DBG_CONTEXT,"Error %d in ReadFile\n",
                    err));

                goto ErrorExit;
            }
        }

        if ( err == ERROR_IO_PENDING ) 
		{

            if ( !GetOverlappedResult( hFile,
                                       Overlapped,
                                       nRead,
                                       TRUE )) 
			{

                err = GetLastError();

                DBGPRINTF((DBG_CONTEXT,"Error %d in GetOverlappedResult\n",
                    err));

                if ( err != ERROR_HANDLE_EOF ) 
				{
                    goto ErrorExit;
                }
            }
        }

//    } 
/*	else 
	{

        //
        // No async file i/o for win95
        //

        if ( !ReadFile( hFile,
                        Buffer,
                        nBuffer,
                        nRead,
                        NULL )) {

            DBGPRINTF((DBG_CONTEXT,"Error %d in ReadFile\n",
                GetLastError()));

            goto ErrorExit;
        }
    }
*/
    fRet = TRUE;

ErrorExit:

    if ( fNewEvent ) {
        DBG_REQUIRE(CloseHandle( ov.hEvent ));
    }

    return(fRet);

} // DoSynchronousReadFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\main.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    This is the HTTP ODBC gateway

Author:

    John Ludeman (johnl)   20-Feb-1995

Revision History:
	Tamas Nemeth (t-tamasn)  12-Jun-1998

--*/


#include "dbgutil.h"

#include <iis64.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
};
#endif

//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>


#ifdef __cplusplus
} // extern "C"

#include <buffer.hxx>
#include <string.hxx>
#include <refb.hxx>

#include <lmcons.h>
//#include <datetime.hxx>
#include <parse.hxx>


#endif // __cplusplus


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus


extern "C" {

#include <tchar.h>

} // extern "C"


//
//  Local include files.
//

#include "parmlist.hxx"

#include <odbcconn.hxx>
#include <festrcnv.h>


DECLARE_DEBUG_PRINTS_OBJECT();

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisOdbcPoolGuid, 
0x784d8937, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif


extern "C" {
#include <httpext.h>


BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}
#include <odbcmsg.h>
#include <odbcreq.hxx>

//
//  Globals
//

BOOL           g_fIsSystemDBCS;        // Is this system DBCS?

//
//  Prototypes
//


BOOL
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    STR *                     pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied
    );


DWORD
OdbcExtensionOutput(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchOutput,
    DWORD                     cbOutput
    );

BOOL
OdbcExtensionHeader(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchStatus,
    const CHAR *              pchHeaders
    );

BOOL LookupHttpSymbols(  // eliminated, check its functionality
    const CHAR *   pszSymbolName,
    STR *          pstrSymbolValue
    );


BOOL
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STR *          pstrError
    );

BOOL
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STR *          pstrParams
    );

BOOL
IsSystemDBCS(
    VOID
    );

TCHAR * 
FlipSlashes( 
	TCHAR * pszPath 
	);

DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    STACK_STR(     strPath, MAX_PATH);
    STACK_STR(     strParams, MAX_PATH);
    STR            strError;
    CHAR *         pch;
    DWORD          cch;
    int            nCharset;

	
	//
    //  Make sure ODBC is loaded
    //

    if ( !LoadODBC() )
    {
        STR str;

        str.FormatString( ODBCMSG_CANT_LOAD_ODBC,
                          NULL,
                          HTTP_ODBC_DLL );

        pecb->ServerSupportFunction( pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER,
                            "500 Unable to load ODBC",
                            NULL,
                            (LPDWORD) str.QueryStr() );

        return HSE_STATUS_ERROR;
    }

    //
    //  We currently only support the GET and POST methods
    //

    if ( !strcmp( pecb->lpszMethod, "POST" ))
    {
        if ( _stricmp( pecb->lpszContentType,
                      "application/x-www-form-urlencoded" ))
        {
            goto BadRequest;
        }

        //
        //  The query params are in the extra data, add a few bytes in case
        //  we need to double "'"
        //

        if ( !strParams.Resize( pecb->cbAvailable + sizeof(TCHAR) + 3))
            return HSE_STATUS_ERROR;

        strParams.Copy( (const char * ) pecb->lpbData, pecb->cbAvailable);
    }
    else if ( !strcmp( pecb->lpszMethod, "GET" ))
    {
        if ( !strParams.Copy( pecb->lpszQueryString  ))
            return HSE_STATUS_ERROR;
    }
    else
    {
BadRequest:

        STR str;

        str.FormatString( ODBCMSG_UNSUPPORTED_METHOD,
                          NULL,
                          HTTP_ODBC_DLL );

        pecb->ServerSupportFunction(
                            pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER,
                            "400 Unsupported method",
                            NULL,
                            (LPDWORD) str.QueryStr() );

        return HSE_STATUS_ERROR;
    }

    //
    //  "Charset" field is enabled for CP932 (Japanese) only in this version.
    //

    if ( 932 != GetACP() )
    {
        nCharset = CODE_ONLY_SBCS;
    }
    else
    {
        //
        //  Get the charset from .idc file
        //

        if ( !GetIDCCharset( pecb->lpszPathTranslated, &nCharset, &strError ) )
        {
            STR str;
            LPCSTR apsz[1];

            apsz[0] = strError.QueryStr();

            str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                              apsz,
                              HTTP_ODBC_DLL,
                              1024 + strError.QueryCB() );

            pecb->ServerSupportFunction( pecb->ConnID,
                                         HSE_REQ_SEND_RESPONSE_HEADER,
                                         (LPDWORD) "500 Error performing query",
                                         NULL,
                                         (LPDWORD) str.QueryStr() );

            return HSE_STATUS_ERROR;
        }

        if ( strParams.QueryCB() )
        {
            if ( CODE_ONLY_SBCS != nCharset )
            {
                //
                //  Convert the charset of Parameters to SJIS
                //

                if ( !ConvertUrlEncodedStringToSJIS( nCharset, &strParams ) )
                {
                    STR strError;
                    STR str;

                    strError.LoadString( GetLastError(), (LPCTSTR) NULL );

                    str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                                      NULL,
                                      HTTP_ODBC_DLL );

                    pecb->ServerSupportFunction( pecb->ConnID,
                                                 HSE_REQ_SEND_RESPONSE_HEADER,
                                                 (LPDWORD) "500 Error performing Query",
                                                 NULL,
                                                 (LPDWORD) str.QueryStr() );

                    return HSE_STATUS_ERROR;
                }
            }
        }
    }

    //
    //  Walk the parameter string to do three things:
    //
    //    1) Double all single quotes to prevent SQL quoting problem
    //    2) Remove escaped '\n's so we don't break parameter parsing later on
    //    3) Replace all '&' parameter delimiters with real '\n' so escaped
    //       '&'s won't get confused later on
    //

    pch = strParams.QueryStr();
    cch = strParams.QueryCCH();

    while ( *pch )
    {
        switch ( *pch )
        {
        case '%':
            if ( pch[1] == '0' && toupper(pch[2]) == 'A' )
            {
                pch[1] = '2';
                pch[2] = '0';
            }
            else if ( pch[1] == '2' && pch[2] == '7' )
            {
                //
                //  This is an escaped single quote
                //

                if ( strParams.QuerySize() < (cch + 4) )  // Include null
                {
                    DWORD Pos = DIFF(pch - strParams.QueryStr());

                    if ( !strParams.Resize( cch + 4 ) )
                        return HSE_STATUS_ERROR;

                    //
                    //  Adjust for possible pointer shift
                    //

                    pch = strParams.QueryStr() + Pos;
                }

                //
                //  Note the memory copy just doubles the existing quote
                //

                memmove( pch+3,
                         pch,
                         (cch + 1) - DIFF(pch - strParams.QueryStr()) );

                cch += 3;          // Adjust for the additional '%27'
                pch += 3;
            }

            pch += 3;
            break;

        case '\'':
            if ( strParams.QuerySize() < (cch + 2) )
            {
                DWORD Pos = DIFF(pch - strParams.QueryStr());

                if ( !strParams.Resize( cch + 2 ) )
                    return HSE_STATUS_ERROR;

                //
                //  Adjust for possible pointer shift
                //

                pch = strParams.QueryStr() + Pos;
            }

            //
            //  Note the memory copy just doubles the existing quote
            //

            memmove( pch+1,
                     pch,
                     (cch + 1) - DIFF(pch - strParams.QueryStr()) );

            pch += 2;
            cch++;          // Adjust for the additional '''
            break;

        case '&':
            *pch = '\n';
            pch++;
            break;

        default:
            pch++;
        }
    }

    //
    //  The path info contains the location of the query file
    //

    if ( !strPath.Copy( pecb->lpszPathTranslated ))
        return HSE_STATUS_ERROR;

    FlipSlashes( strPath.QueryStr() );

    //
    //  Attempt the query
    //

    BOOL fAccessDenied = FALSE;

    if ( !DoQuery( pecb,
                   strPath.QueryStr(),
                   strParams.QueryStr(),
                   &strError,
                   nCharset,
                   &fAccessDenied ))
    {
        if ( fAccessDenied )
        {
            pecb->ServerSupportFunction( pecb->ConnID,
                     HSE_REQ_SEND_RESPONSE_HEADER,
                     (LPDWORD) "401 Authentication Required",
                     NULL,
                     NULL );

            return HSE_STATUS_ERROR;
        }
        else
        {
            STR str;
            LPCSTR apsz[1];

            apsz[0] = strError.QueryStr();

            //
            //  Note we terminate the error message (ODBC sometimes generates
            //  22k errors) *and* we double the buffer size we pass to FormatString()
            //  because the win32 API FormatMessage() has a bug that doesn't
            //  account for Unicode conversion
            //

            if ( strlen( apsz[0] ) > 1024 ) {
                apsz[1024] = '\0';
            }

            str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                              apsz,
                              HTTP_ODBC_DLL,
                              1024 + strError.QueryCB() );

            pecb->ServerSupportFunction( pecb->ConnID,
                     HSE_REQ_SEND_RESPONSE_HEADER,
                     (LPDWORD) "500 Error performing query",
                     NULL,
                     (LPDWORD) str.QueryStr() );

            return HSE_STATUS_ERROR;
        }
    }

    return HSE_STATUS_SUCCESS;
}

BOOL
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,    
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    STR *                     pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied
    )
/*++

Routine Description:

    Performs the actual query or retrieves the same query from the query
    cache

Arguments:

    pecb - Extension context
    pTsvcInfo - Server info class
    pszQueryFile - .wdg file to use for query
    pszParamList - Client supplied param list
//    pReq - Http request this query is for
    pstrError - Error text to return errors in
    pfAccessDenied - Set to TRUE if the user was denied access

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    ODBC_REQ *              podbcreq;
    ODBC_REQ *              podbcreqCached;
    VOID *                  pvCacheCookie = NULL;
    BOOL                    fRet = TRUE;
    STACK_STR(              strHeaders, MAX_PATH);
    CHAR                    achPragmas[250];
    DWORD                   cbPragmas = sizeof(achPragmas);
    BOOL                    fRetrieveFromCache = TRUE;
    PSECURITY_DESCRIPTOR    pSecDesc = NULL;

    //
    //  Create an odbc request as we will either use it for the query or
    //  as the key for the cache lookup
    //	
	
	podbcreq = new ODBC_REQ(  pszQueryFile,
                             pszParamList,
//                             hToken,
                             0, // hard-coded - pReq->QueryMetaData()->QueryPoolIDCTimeout(),
                             (ODBC_REQ_FIND_SYMBOL) NULL, // (ODBC_REQ_FIND_SYMBOL) LookupHttpSymbols,
                             (VOID *) NULL, // pReq,
                             nCharset );

    if ( !podbcreq ||
         !podbcreq->IsValid() )
    {
        pstrError->LoadString( GetLastError() );

        delete podbcreq;
        return FALSE;
    }

    //
    //  Check to see if user already authentified
    //

    CHAR  achLoggedOnUser[UNLEN + 1];
    DWORD dwLoggedOnUser = sizeof( achLoggedOnUser );
    BOOL  fIsAuth = pecb->GetServerVariable( (HCONN)pecb->ConnID,
                                             "LOGON_USER",
                                             achLoggedOnUser,
                                             &dwLoggedOnUser ) &&
                                             achLoggedOnUser[0] != '\0';


    //
    //  Check to see if the client specified "Pragma: no-cache"
    //

    if ( pecb->GetServerVariable( pecb->ConnID,
                                  "HTTP_PRAGMA",
                                  achPragmas,
                                  &cbPragmas ))
    {
        CHAR * pch;

        //
        //  Look for "no-cache"
        //

        pch = _strupr( achPragmas );

        while ( pch = strchr( pch, 'N' ))
        {
            if ( !memcmp( pch, "NO-CACHE", 8 ))
            {
                fRetrieveFromCache = FALSE;
                goto Found;
            }

            pch++;
        }
    }

Found:



        //
        //  Open the query file and do the query
        //

        if ( !podbcreq->OpenQueryFile( pfAccessDenied )       ||
             !podbcreq->ParseAndQuery( achLoggedOnUser )      ||
             !podbcreq->AppendHeaders( &strHeaders )          ||
             !podbcreq->OutputResults( (ODBC_REQ_CALLBACK) OdbcExtensionOutput,
                                       pecb, &strHeaders,
                                       (ODBC_REQ_HEADER) OdbcExtensionHeader,
                                       fIsAuth,
                                       pfAccessDenied ) )
        {
            fRet = FALSE;
            goto Exit;
        }


Exit:

    if ( !fRet )
    {
        podbcreq->GetLastErrorText( pstrError );
	}
            delete podbcreq;
    



    if ( pSecDesc )
    {
        LocalFree( pSecDesc );
    }

    return fRet;
}


DWORD OdbcExtensionOutput( EXTENSION_CONTROL_BLOCK * pecb,
                           const CHAR *              pchOutput,
                           DWORD                     cbOutput )
{
    if ( !pecb->WriteClient( pecb->ConnID,
                             (VOID *) pchOutput,
                             &cbOutput,
                             0 ))

    {
        return GetLastError();
    }

    return NO_ERROR;
}


BOOL OdbcExtensionHeader( EXTENSION_CONTROL_BLOCK * pecb,
                           const CHAR *              pchStatus,
                           const CHAR *              pchHeaders )
{
    return pecb->ServerSupportFunction(
                pecb->ConnID,
                HSE_REQ_SEND_RESPONSE_HEADER,
                (LPDWORD) "200 OK",
                NULL,
                (LPDWORD) pchHeaders );
}


BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    DWORD  err;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( "httpodbc.dll");
        SET_DEBUG_FLAGS( 0);
#else
        CREATE_DEBUG_PRINT_OBJECT( "httpodbc.dll", IisOdbcPoolGuid);
#endif

        if ( !InitializeOdbcPool() )
        {
            return FALSE;
        }

        DisableThreadLibraryCalls( hDll );

        g_fIsSystemDBCS = IsSystemDBCS();
        break;

    case DLL_PROCESS_DETACH:

        TerminateOdbcPool();
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }

    return TRUE;
}

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 0, 2 );
    strcpy( pver->lpszExtensionDesc,
            "Microsoft HTTP ODBC Gateway, v2.0" );

    return TRUE;
}


CHAR * skipwhite( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        if ( ' ' != ch && '\t' != ch )
            break;
        ++pch;
    }

    return pch;
}


CHAR * nextline( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        ++pch;

        if ( '\n' == ch )
        {
            break;
        }
    }

    return pch;
}


BOOL
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STR *          pstrError
    )
{
    BUFFER           buff;
    HANDLE           hFile;
    DWORD            dwSize;

#define QUERYFILE_READSIZE  4096

    if ( !pnCharset )
        return FALSE;
    *pnCharset = CODE_ONLY_SBCS;

    if ( !buff.Resize( QUERYFILE_READSIZE + sizeof(TCHAR) ) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        pstrError->LoadString( GetLastError() );
        return FALSE;
    }

    hFile = CreateFile(
                    pszPath,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        LPCSTR apsz[1];

        apsz[0] = pszPath;
        pstrError->FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                               apsz,
                               HTTP_ODBC_DLL );
        return FALSE;
    }

    if ( !ReadFile( hFile, buff.QueryPtr(), QUERYFILE_READSIZE, &dwSize, NULL ) )
    {
        pstrError->LoadString( GetLastError() );
        return FALSE;
    }

    CloseHandle( hFile );

    *((CHAR *) buff.QueryPtr() + dwSize) = '\0';

    CHAR * pch = (CHAR *)buff.QueryPtr();  // we know that this is null terminated!

    while ( *pch )
    {
        pch = skipwhite( pch );

        if ( 'C' == toupper( *pch ) && !_strnicmp( IDC_FIELDNAME_CHARSET, pch, sizeof(IDC_FIELDNAME_CHARSET)-1 ) )
        {
            pch += sizeof(IDC_FIELDNAME_CHARSET) - 1;
            pch = skipwhite( pch );
            if ( 932 == GetACP() )
            {
                if ( !_strnicmp( IDC_CHARSET_JIS1, pch, sizeof(IDC_CHARSET_JIS1)-1 ) ||
                     !_strnicmp( IDC_CHARSET_JIS2, pch, sizeof(IDC_CHARSET_JIS2)-1 ) )
                {
                    *pnCharset = CODE_JPN_JIS;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_EUCJP, pch, sizeof(IDC_CHARSET_EUCJP)-1 ))
                {
                    *pnCharset = CODE_JPN_EUC;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_SJIS, pch, sizeof(IDC_CHARSET_SJIS)-1 ))
                {
                    *pnCharset = CODE_ONLY_SBCS;
                    break;
                }
                else
                {
                    LPCSTR apsz[1];
                    //
                    //  illegal value for Charset: field
                    //
                    apsz[0] = pszPath;
                    pstrError->FormatString( ODBCMSG_UNREC_FIELD,
                                           apsz,
                                           HTTP_ODBC_DLL );
                    return FALSE;
                }
            }

//
//          please add code here to support other FE character encoding(FEFEFE)
//
//          else if ( 949 == GetACP() )
//          ...

        }
        pch = nextline( pch );
    }

    return TRUE;
}


BOOL
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STR *          pstrParams
    )
{
    STACK_STR( strTemp, MAX_PATH);
    int cbSJISSize;
    int nResult;

    //
    //  Pre-process the URL encoded parameters
    //

    for ( char * pch = pstrParams->QueryStr(); *pch; ++pch )
    {
        if ( *pch == '&' )
            *pch = '\n';
        else if ( *pch == '+' )
            *pch = ' ';
    }

    //
    //  URL decoding (decode %nn only)
    //

    pstrParams->Unescape();

    //
    //  charset conversion
    //

    if ( !pstrParams->Clone( &strTemp ) )
    if ( !strTemp.Copy( pstrParams->QueryStr() ) )
        return FALSE;

    cbSJISSize = UNIX_to_PC(
                            GetACP(),
                            nCharset,
                            (UCHAR *)strTemp.QueryStr(),
                            strTemp.QueryCB(),
                            NULL,
                            0 );

    if ( !pstrParams->Resize( cbSJISSize + sizeof(TCHAR) ) )
        return FALSE;

    nResult = UNIX_to_PC(
                            GetACP(),
                            nCharset,
                            (UCHAR *)strTemp.QueryStr(),
                            strTemp.QueryCB(),
                            (UCHAR *)pstrParams->QueryStr(),
                            cbSJISSize );
    if ( -1 == nResult || nResult != cbSJISSize )
        return FALSE;

    DBG_REQUIRE ( pstrParams->SetLen( cbSJISSize));

    //
    //  URL encoding
    //

    if ( !pstrParams->Escape() )
        return FALSE;

    return TRUE;
}

BOOL
IsSystemDBCS(
    VOID )
{
    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    return ( wPrimaryLangID == LANG_JAPANESE ||
             wPrimaryLangID == LANG_CHINESE ||
             wPrimaryLangID == LANG_KOREAN );
}

TCHAR * FlipSlashes( TCHAR * pszPath )
{
    TCHAR   ch;
    TCHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != TEXT('\0') )
    {
        if( ch == TEXT('/') )
        {
            *pszScan = TEXT('\\');
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\odbcpool.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    odbcpool.cxx

Abstract:

    Provides simple ODBC connection pooling for IDC.  The only keys used for
    the connection pooling is the datasource name, the username and
    password.  ODBC options and other connection state are not taken
    into consideration.

Author:

    John Ludeman (johnl)   01-Apr-1996

Revision History:
--*/

# include "dbgutil.h"

# include "issched.hxx"
//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>


#ifdef __cplusplus
} // extern "C"

#include <buffer.hxx>
#include <string.hxx>

#include <parse.hxx>


#endif // __cplusplus


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

//#endif  // _TCPDLL_H_


#include <odbcconn.hxx>
#include <parmlist.hxx>

#include <odbcmsg.h>
#include <odbcreq.hxx>

#ifndef _NO_TRACING_

#define IDC_PRINTF( x )        { char buff[256]; wsprintf x; DBGPRINTF((DBG_CONTEXT, buff )); }

#else

#if DBG
#define IDC_PRINTF( x )        { char buff[256]; wsprintf x; OutputDebugString( buff ); }
#else
#define IDC_PRINTF( x )
#endif

#endif

//
//  Default connection pool timeout
//

#define IDC_POOL_TIMEOUT                30

//
//  Globals
//

CRITICAL_SECTION g_csPoolLock;

LIST_ENTRY       g_PoolList;

DWORD            g_dwTimeoutID = 0;

//
// Various counters
//

DWORD g_cFree;
DWORD g_cUsed;

//
//  ODBC Connection pool item
//

class ODBC_CONN_POOL
{
public:

    ODBC_CONN_POOL( const CHAR * pszDataSource,
                    const CHAR * pszUsername,
                    const CHAR * pszPassword,
                    const CHAR * pszLoggedOnUser )
        : m_strDataSource( pszDataSource ),
          m_strUsername  ( pszUsername ),
          m_strPassword  ( pszPassword ),
          m_strLogon     ( pszLoggedOnUser ),
          m_fFree        ( TRUE ),
          m_TTL          ( 2 )
    {
    }

    ~ODBC_CONN_POOL()
    {
        m_odbcconn.Close();
    }

    BOOL Open( VOID )
    {
        return m_odbcconn.Open( m_strDataSource.QueryStr(),
                                m_strUsername.QueryStr(),
                                m_strPassword.QueryStr() );
    }

    BOOL IsValid( VOID ) const
        { return m_strDataSource.IsValid() &&
                 m_strUsername.IsValid()   &&
                 m_strPassword.IsValid()   &&
                 m_strLogon.IsValid(); }

    BOOL IsFree( VOID ) const
        { return m_fFree; }

    VOID MarkAsUsed( VOID )
        { m_fFree = FALSE; g_cFree--; g_cUsed++; }

    VOID MarkAsFree( VOID )
        { m_fFree = TRUE; g_cUsed--; g_cFree++; }

    const CHAR * QueryDataSource( VOID ) const
        { return m_strDataSource.QueryStr(); }

    const CHAR * QueryUsername( VOID ) const
        { return m_strUsername.QueryStr(); }

    const CHAR * QueryPassword( VOID ) const
        { return m_strPassword.QueryStr(); }

    const CHAR * QueryLoggedOnUser( VOID ) const
        { return m_strLogon.QueryStr(); }

    ODBC_CONNECTION * QueryOdbcConnection( VOID )
        { return &m_odbcconn; }

    DWORD DecrementTTL( VOID )
        { if ( m_TTL < IDC_POOL_TIMEOUT )
              return 0;

          m_TTL -= IDC_POOL_TIMEOUT;
          return m_TTL;
        }

    VOID SetTTL( DWORD csecTimeout )
        { m_TTL = csecTimeout; }

    LIST_ENTRY m_ListEntry;

private:

    ODBC_CONNECTION m_odbcconn;
    STR             m_strDataSource;
    STR             m_strUsername;
    STR             m_strPassword;
    STR             m_strLogon;         // The NT account this request is using
    BOOL            m_fFree;
    DWORD           m_TTL;

};

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    );

BOOL
InitializeOdbcPool(
    VOID
    )
{
    DWORD  err;
    HKEY   hkey;

    InitializeListHead( &g_PoolList );
    INITIALIZE_CRITICAL_SECTION( &g_csPoolLock );

    //
    //  Kick off the pool scavenger
    //

    g_dwTimeoutID = ScheduleWorkItem( IDCPoolScavenger,
                                      NULL,
                                      IDC_POOL_TIMEOUT * 1000,
                                      TRUE );

    return TRUE;
}

VOID
TerminateOdbcPool(
    VOID
    )
{
    ODBC_CONN_POOL * pOCPool;

    if ( g_dwTimeoutID )
    {
        RemoveWorkItem( g_dwTimeoutID );
        g_dwTimeoutID = 0;
    }

    EnterCriticalSection( &g_csPoolLock );

    while ( !IsListEmpty( &g_PoolList ))
    {
        LIST_ENTRY * pEntry = g_PoolList.Flink;

        RemoveEntryList( pEntry );

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        delete pOCPool;
    }

    LeaveCriticalSection( &g_csPoolLock );
    DeleteCriticalSection( &g_csPoolLock );
}

BOOL
OpenConnection(
    IN  ODBC_CONNECTION *   podbcconnNonPooled,
    OUT ODBC_CONNECTION * * ppodbcconnToUse,
    IN  DWORD               csecPoolTimeout,
    IN  const CHAR *        pszDataSource,
    IN  const CHAR *        pszUsername,
    IN  const CHAR *        pszPassword,
    IN  const CHAR *        pszLoggedOnUser
    )
/*++

Routine Description:

    This function opens an odbc connection, optionally from a pool of
    ODBC connections.



Arguments:

    podbcconnNonPooled - If pooling wasn't requested or the open failed, we
        use this odbc connection object
    ppodbcconnToUse - Receives pointer to either a pooled ODBC connection object
        or podbcconnNonPooled if a pooled object couldn't be used
    csecPoolTimeout - Amount of time to pool a connection, 0 to not pool
    pszDataSource - ODBC Datasource
    pszUsername - Username for datasource access
    pszPassword - Password for use with this username
    pszLoggedOnUser - The NT account this user is running under

Return Value:

    TRUE if successful, FALSE on error

    ppodbcconnToUse will be set to the ODBC connection to use for the
        request

--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;

    //
    //  Don't pool this connection if it wasn't requested
    //

    if ( !csecPoolTimeout )
    {
        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    //
    //  Look in the pool cache for an existing connection
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree() &&
             !lstrcmpi( pOCPool->QueryDataSource(), pszDataSource ) &&
             !lstrcmpi( pOCPool->QueryUsername(), pszUsername ) &&
             !lstrcmpi( pOCPool->QueryLoggedOnUser(), pszLoggedOnUser ) &&
             !strcmp( pOCPool->QueryPassword(),
                      pszPassword ))

        {
            //
            //  We have a match
            //

            pOCPool->MarkAsUsed();
            *ppodbcconnToUse = pOCPool->QueryOdbcConnection();
            pOCPool->SetTTL( csecPoolTimeout );
            LeaveCriticalSection( &g_csPoolLock );

            return TRUE;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );

    //
    //  Allocate a new connection pool and if we connect successfully, put
    //  it in the pool list
    //

    pOCPool = new ODBC_CONN_POOL( pszDataSource,
                                  pszUsername,
                                  pszPassword,
                                  pszLoggedOnUser );


    if ( !pOCPool->Open() )
    {
        delete pOCPool;

        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    *ppodbcconnToUse = pOCPool->QueryOdbcConnection();

    EnterCriticalSection( &g_csPoolLock );

    //
    //  Account for the new pool item but we have to do it with in
    //  the critical section
    //

    g_cFree++;

    pOCPool->MarkAsUsed();
    pOCPool->SetTTL( csecPoolTimeout );
    InsertHeadList( &g_PoolList, &pOCPool->m_ListEntry );

    LeaveCriticalSection( &g_csPoolLock );

    return TRUE;
}

VOID
CloseConnection(
    IN  ODBC_CONNECTION *   podbcconnPooled,
    IN  BOOL                fDelete
    )
/*++

Routine Description:

    This routine frees an ODBC connection back to the pool, optionally
    deleting it

Arguments:

    podbcconnPooled - ODBC connection that is pooled, can be NULL
    fDelete - TRUE if the item should be delete rather then returned to the
        pool
--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;

    if ( !podbcconnPooled )
    {
        return;
    }

    //
    //  Look in the pool list to mark it as free
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( podbcconnPooled == pOCPool->QueryOdbcConnection() )
        {
            pOCPool->MarkAsFree();

            if ( fDelete )
            {
                RemoveEntryList( pEntry );
                g_cFree--;
                delete pOCPool;
            }

            break;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );
}

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    )
/*++

Routine Description:

    Walks the list of pooled connections and removes any that have timed out

--*/
{
    LIST_ENTRY *     pEntry;
    LIST_ENTRY *     pNext;
    ODBC_CONN_POOL * pOCPool;

    //
    //  Look through the list and remove any old items
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pNext )
    {
        pNext = pEntry->Flink;

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree() && !pOCPool->DecrementTTL() )
        {
            IDC_PRINTF(( buff,
                         "[IDCPoolScavenger] Removing %s, %s, %s\n",
                         pOCPool->QueryDataSource(),
                         pOCPool->QueryUsername(),
                         pOCPool->QueryLoggedOnUser() ));

            RemoveEntryList( pEntry );
            g_cFree--;
            delete pOCPool;
        }
    }

#if 0
    IDC_PRINTF(( buff,
                 "[IDCPoolScavenger] Free items in pool %d, used %d\n",
                 g_cFree,
                 g_cUsed ));
#endif

    LeaveCriticalSection( &g_csPoolLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\odbcconn.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       odbcconn.cxx

   Abstract:

       This module defines member functions for ODBC_CONNECTION object.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Feb-1995

   Environment:

       User Mode - Win32.

   Project:

       Internet Services Common DLL

   Functions Exported:

       ODBC_PARAMETER::CopyValue( IN LPCWSTR pwszValue);
       ODBC_PARAMETER::Bind( IN HSTMT hstmt);

       ODBC_STATEMENT::~ODBC_STATEMENT()
       ODBC_STATEMENT::PrepareStatement( IN LPCSTR  pszStatement)
       ODBC_STATEMENT::PrepareStatement( IN LPCWSTR pwszStatement)
       ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParam)
       ODBC_STATEMENT::ExecuteStatement( VOID)
       ODBC_STATEMENT::ExecDirect( IN LPCSTR pwszSqlCommand,  IN DWORD cch)
       ODBC_STATEMENT::ExecDirect( IN LPCWSTR pwszSqlCommand, IN DWORD cch)
       ODBC_STATEMENT::QueryColNames( OUT STR * *  apstrCols,
                                      OUT DWORD *  cCols,
                                      IN  DWORD    cchMaxFieldSize = 0 );
       ODBC_STATEMENT::QueryValuesAsStr( OUT STR * *   apstrValues,
                                         OUT DWORD * * apcbValues,
                                         OUT BOOL *    pfLast );


       ODBC_CONNECTION::~ODBC_CONNECTION();
       ODBC_CONNECTION::Open();
       ODBC_CONNECTION::Close();
       ODBC_CONNECTION::GetLastErrorCode();
       ODBC_CONNECTION::AllocStatement();


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "dbgutil.h"
# include "odbcconn.hxx"

#define TCP_ALLOC(cb)          (VOID *)LocalAlloc( LPTR, cb ) 
#define TCP_FREE(p)            LocalFree( (HLOCAL) p )
//
// Since the ODBC does not support UNICODE APIs, we convert unicode to ANSI
//   to call the APIs. This will have to go away once we find some other
//   better way to do manage the same.
//


//
//  Constants for display widths
//

#define MAX_NUM_PRECISION 15

//
//  Constant for all non string and non binary data.  40 is chosen to account
//  for things such as Oracle's numeric types, which can have up to 38 digits
//  of precision
//

#define MAX_NONCHAR_DATA_LEN        40

//
//  If no default maximum field size is specified, then use this value
//  as the maximum
//

#define DEFAULT_MAX_FIELD_SIZE      8192



/************************************************************
 *  Local Functions
 ************************************************************/

static inline VOID
CheckAndPrintErrorMessage( IN ODBC_CONNECTION * poc,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        poc->GetLastErrorText( &str, NULL, rc );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


static inline VOID
CheckAndPrintErrorMessage( IN ODBC_STATEMENT * pos,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        pos->GetLastErrorText( &str );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()



# if DBG


static VOID
PrintMultiString( IN char * pszMsg, IN DWORD cbLen, IN char * pmsz)
{

    DBGPRINTF( ( DBG_CONTEXT,
                "Values of %s. %d bytes.\n", pszMsg, cbLen));
    for( char * psz = pmsz; *psz != '\0'; psz += (strlen( psz) + 1)) {

        DBGPRINTF( ( DBG_CONTEXT, "%s\n", psz));
    }

    return;
} // PrintMultiString()



static VOID
AuxOdbcFunctions( IN HENV henv, IN HDBC hdbc)
/*++

  Function useful in walking throug a few additional ODBC functions
    to find out the ODBC setup information.
  Not to be part of the shipped code. Useful for development purposes.
  - MuraliK
--*/
{
    RETCODE rc;

    //
    // Set the trace file to a standard file.
    //
    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACE, SQL_OPT_TRACE_ON);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACEFILE,
                             (unsigned long )       // BUGBUG64
                             "%systemroot%\\system32\\gophsql.log");
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    UCHAR szDriverDesc[ 300];
    UCHAR szDriverAttrib[ 300];
    SWORD cbDD = 300;
    SWORD cbDA = 300;
    SWORD cbDDCur = 0;
    SWORD cbDACur = 0;

    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    rc = pSQLDrivers( henv, SQL_FETCH_FIRST,
                    szDriverDesc, cbDD, &cbDDCur,
                    szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDrivers( %08x) ==> RetCode = %d."
                " Driver Desc. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Driver Attributes", cbDACur, (char *) szDriverAttrib);


    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    cbDDCur = cbDACur = 0;
    rc = pSQLDataSources( henv, SQL_FETCH_FIRST,
                        szDriverDesc, cbDD, &cbDDCur,
                        szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDataSources( %08x) ==> RetCode = %d."
                " Data Sources. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Data Source Description", cbDACur,
                     (char *) szDriverAttrib);

    return;
} // AuxOdbcFunctions()


# endif // DBG

LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode,
    IN LPSTR    lpszAnsi,
    IN DWORD    cbAnsi
    )
/*++
    Description:
        Converts given null-terminated string into ANSI in the buffer supplied.

    Arguments:
        lpszUnicode         null-terminated string in Unicode
        lpszAnsi            buffer supplied to copy  string after conversion.
                    if ( lpszAnsi == NULL), then this module allocates space
                      using TCP_ALLOC, which should be freed calling TCP_FREE
                      by user.
        cbAnsi              number of bytes in lpszAnsi if specified

    Returns:
        pointer to converted ANSI string. NULL on errors.

    History:
        MuraliK     12-01-1994      Created.
--*/
{

    DWORD cchLen;
    DWORD nBytes;
    LPSTR lpszAlloc = NULL;

    if ( lpszUnicode == NULL) {
        return (NULL);
    }

    if ( lpszAnsi == NULL) {

        //
        // multiply by 2 to accomodate DBCS
        //

        cchLen = wcslen( lpszUnicode);
        nBytes = (cchLen+1) * sizeof(CHAR) * 2;
        lpszAlloc = (LPSTR ) TCP_ALLOC( nBytes );

    } else {

        lpszAlloc = lpszAnsi;
        nBytes = cbAnsi;
        DBG_ASSERT(nBytes > 0);
    }

    if ( lpszAlloc != NULL) {

        cchLen = WideCharToMultiByte( CP_ACP,
                                      WC_COMPOSITECHECK,
                                      lpszUnicode,
                                      -1,
                                      lpszAlloc,
                                      nBytes,
                                      NULL,  // lpszDefaultChar
                                      NULL   // lpfDefaultUsed
                                     );

        DBG_ASSERT(cchLen == (strlen(lpszAlloc)+1) );

        if ( cchLen == 0 ) {

            //
            // There was a failure. Free up buffer if need be.
            //

            DBGPRINTF((DBG_CONTEXT,"WideCharToMultiByte failed with %d\n",
                GetLastError()));

            if ( lpszAnsi == NULL) {
                TCP_FREE( lpszAlloc);
                lpszAlloc = NULL;
            } else {
                lpszAlloc[cchLen] = '\0';
            }

        } else {

            DBG_ASSERT( cchLen <= nBytes );
            DBG_ASSERT(lpszAlloc[cchLen-1] == '\0');

            lpszAlloc[cchLen-1] = '\0';
        }
    }

    return ( lpszAlloc);

} // ConvertUnicodeToAnsi



/************************************************************
 *    Member Functions of ODBC_PARAMETER
 ************************************************************/


BOOL
ODBC_PARAMETER::CopyValue( IN LPCWSTR  pwszValue)
/*++
  Description:
    This function copies the given Unicode string as the value into
      current parameter marker to be used for future insertion.

  Arguments:
    pwszValue   pointer to null-terminated string containing Unicode value to
                    be copied into the parameter marker.

  Returns:
    TRUE on success and FALSE if there is any error.

  Note:
    Since ODBC does not support Unicode directly right now, we convert
      string value to be ANSI before copying the value over.
--*/
{
    BOOL fReturn = FALSE;

    CHAR * pszValue = ConvertUnicodeToAnsi( pwszValue, NULL, 0 );

    //
    // If successful then Copy ASCII value to buffer in the parameter block.
    //

    if ( pszValue != NULL) {

        fReturn = this->CopyValue( pszValue);

        TCP_FREE( pszValue);
    }

    return ( fReturn);
} // ODBC_PARAMETER::CopyValue()



BOOL
ODBC_PARAMETER::CopyValue( IN LPSYSTEMTIME lpst)
/*++
  Description:
    This function copies the given system time into the ODBC timestamp
     structure for the current parameter marker to be used for
     future insertion.

  Arguments:
   lpSystemTime   pointer to System Time structure containing current time.

  Returns:
    TRUE on success and FALSE if there is any error.

--*/
{
    TIMESTAMP_STRUCT * ptsOdbc;

    DBG_ASSERT( lpst != NULL);
    DBG_ASSERT( m_CType == SQL_C_TIMESTAMP);
    DBG_ASSERT( m_SqlType == SQL_TIMESTAMP);
    DBG_ASSERT( m_cbValueMax >= sizeof(TIMESTAMP_STRUCT));

    ptsOdbc = (TIMESTAMP_STRUCT * ) m_pValue;

    DBG_ASSERT( m_pValue != NULL);

    //
    // Copy the individual fields over properly
    // The types used in ODBC/Win32 are different
    //  So do a type specific copy of the values.
    //

    ptsOdbc->year   = (SWORD ) lpst->wYear;
    ptsOdbc->month  = (UWORD ) lpst->wMonth;
    ptsOdbc->day    = (UWORD ) lpst->wDay;
    ptsOdbc->hour   = (UWORD ) lpst->wHour;
    ptsOdbc->minute = (UWORD ) lpst->wMinute;
    ptsOdbc->second = (UWORD ) lpst->wSecond;
    ptsOdbc->fraction = (UDWORD ) lpst->wMilliseconds;

    return ( TRUE);
} // ODBC_PARAMETER::CopyValue()





RETCODE
ODBC_PARAMETER::Bind( IN HSTMT hStmt)
/*++
  Description:

    This functions binds the data about the parameter marker 'this'
     ( this object) represents to the statement provided.

  Arguments:
    hStmt        HANDLE for the statement to which this parameter
                  is to be bound.

  Returns:
    RETCODE value returned by SQLBindParamater().
--*/
{
    RETCODE  rc;
    DBG_ASSERT( hStmt != SQL_NULL_HSTMT);

    rc = pSQLBindParameter( hStmt,              // statement
                            QueryParamNumber(),
                            QueryParamType(),
                            QueryCType(),
                            QuerySqlType(),
                            QueryPrecision(),
                            QueryScale(),
                            QueryValue(),
                            QueryMaxCbValue(),
                            &(QueryCbValueRef())
                            );

    return ( rc);
} // ODBC_STATEMENT::BindParameter()





# if DBG

VOID
ODBC_PARAMETER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_PARAMETER ( %08x).\n"
                " Num=%u; Type=%d; CType=%d; SqlType=%d; Prec=%u; Scale=%d;"
                " CbMax=%d; Cb=%d.\n",
                this,
                QueryParamNumber(),
                QueryParamType(),
                QueryCType(),
                QuerySqlType(),
                QueryPrecision(),
                QueryScale(),
                QueryMaxCbValue(),
                QueryCbValue()));

    switch ( QuerySqlType()) {

      case SQL_INTEGER:
        {
            DWORD  dwValue = *(DWORD *) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " Integer Value = %u\n", dwValue));
            break;
        }

      case SQL_CHAR:
        {
            LPCSTR pszValue = (LPCSTR ) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " String Value( %08x) = %s\n",
                         pszValue, pszValue));
            break;
        }

      default:
        {
            DBGPRINTF( ( DBG_CONTEXT, " Type=%d. Unknown value at %08x\n",
                        QuerySqlType(), QueryValue()));
            break;
        }

    } // switch

    return;
} // ODBC_PARAMETER::Print()


# endif // DBG



/************************************************************
 * ODBC_STATEMENT  member functions
 ************************************************************/


ODBC_STATEMENT::~ODBC_STATEMENT( VOID)
{
    //
    // Free the statement handle
    //
    if ( m_hStmt != SQL_NULL_HSTMT) {

        m_rc = pSQLFreeStmt( m_hStmt, SQL_DROP);
        m_hStmt = SQL_NULL_HSTMT;

        // Ignore the error code here.
        DBG_ASSERT( ODBC_CONNECTION::Success( m_rc));


        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SqlFreeStmt() return code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    FreeColumnMemory();

} // ODBC_STATEMENT::~ODBC_STATEMENT()





BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn;

    IF_DEBUG( ODBC) {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Executing the SQL command (%d bytes) %s.\n",
                    cchSqlCommand * sizeof( CHAR),
                    pszSqlCommand));
    }

    //
    //  SQLExecDirect only likes Unsigned chars !
    //
    m_rc = pSQLExecDirect( m_hStmt, (UCHAR FAR *) pszSqlCommand, cchSqlCommand);
    fReturn = ODBC_CONNECTION::Success( m_rc);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLExecDirect() returns code %d\n",
                    m_rc));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()



BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCWSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn = FALSE;
    char * pszCommand;

    if ( ( pszCommand = ConvertUnicodeToAnsi( pszSqlCommand, NULL, 0))
        != NULL ) {

        fReturn = ExecDirect( pszCommand, strlen( pszCommand));

        TCP_FREE( pszCommand);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()






BOOL
ODBC_STATEMENT::PrepareStatement(IN LPCSTR    pszStatement)
/*++

  This function prepares the SQL statement for future execution.

  Arguments:
     pszStatement    pointer to null terminated string containing the
                        statement.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn;

    DBG_ASSERT( QueryErrorCode() == SQL_SUCCESS && pszStatement != NULL);

    m_rc = pSQLPrepare( m_hStmt, (UCHAR FAR *) pszStatement, SQL_NTS);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLPrepare( %s) returns ErrorCode = %d.\n",
                     pszStatement, m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( m_fPreparedStmt = ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::PrepareStatment()




BOOL
ODBC_STATEMENT::PrepareStatement( IN LPCWSTR   pwszCommand)
/*++
  This function prepares an ODBC statement for execution.
  Since ODBC does not support UNICODE, we convert the statement into ANSI
   before calling the APIs.

  Arguments:
     pwszCommand      pointer to null-terminated string containing the
                       statement to be prepared.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    CHAR * pszCommand = NULL;

    DBG_ASSERT( pwszCommand != NULL);

    pszCommand = ConvertUnicodeToAnsi( pwszCommand, NULL, 0);

    if ( pszCommand != NULL) {

        fReturn = PrepareStatement( pszCommand);

        TCP_FREE( pszCommand);

    } // pszCommand != NULL

    return ( fReturn);
} // ODBC_STATEMENT::PrepareStatement()





BOOL
ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParameter)
{

    DBG_ASSERT( ODBC_CONNECTION::Success( m_rc) && pOdbcParameter != NULL);

    m_rc = pOdbcParameter->Bind( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::BindParameter()





BOOL
ODBC_STATEMENT::ExecuteStatement( VOID)
/*++

  This function executes a prepared ODBC statement. At the end of execution,
   the transaction is also committed to ensure that the record is automatically
   written to the database.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DBG_ASSERT( m_fPreparedStmt != FALSE);

    if ( !ODBC_CONNECTION::Success( QueryErrorCode()) ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "!!WARNING!! - Attempting to use Invalid ODBC Connection!\n" ));
    }

    m_rc = pSQLExecute( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::ExecuteStatement()

BOOL
ODBC_STATEMENT::QueryRowCount(
    OUT DWORD * pcRows
    )
/*++

  Calls SQLRowCount on the current result set.

  NOTE: Not all database implementations support this!!

  Arguments:

    pcRows - Receives count of rows

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    m_rc = pSQLRowCount( m_hStmt,
                         (SDWORD *) pcRows );

    return ( ODBC_CONNECTION::Success( m_rc));
}


BOOL
ODBC_STATEMENT::QueryColNames(
    STR * *  pastrCols,
    DWORD  * cCols,
    DWORD    cchMaxFieldSize,
    BOOL *   pfHaveResultSet
    )
/*++

  This method returns the list of column names from the result table

  Arguments:

    pastrCols - Receives an array of STRs containing the column names
    cCols - Count of columns returned (zero for no result set)
    cchMaxFieldSize - Maximum buffer size to allocate for any data fields,
        zero means use the default value.
    pfHaveResultSet - Set to TRUE if the current query was a SELECT and thus has
        rows that can be enumerated

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    SWORD   nresultcols;
    SWORD   i;
    CHAR    achColName[64];
    SWORD   cchColName;
    SWORD   ColType;
    DWORD   cchColLength;
    SWORD   scale;
    SWORD   nullable;

    *pastrCols       = NULL;
    *cCols           = 0;
    *pfHaveResultSet = TRUE;

    //
    //  Return the old binding info if we already have it
    //

    if ( m_astrColNames )
    {
        *pastrCols = m_astrColNames;
        *cCols = m_cCols;

        return TRUE;
    }

    //
    //  Provide a default maximum field size if none was specified
    //

    if ( !cchMaxFieldSize )
        cchMaxFieldSize = DEFAULT_MAX_FIELD_SIZE;

    //
    //  See what kind of statement it was.  If there are no result
    //  columns, the statement is not a SELECT statement.
    //

    m_rc = pSQLNumResultCols( m_hStmt,
                              &nresultcols);

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    if ( nresultcols > 0 )
    {
        //
        //  Allocate an array of strings for the column names and the column
        //  values
        //

        m_cCols = nresultcols;
        *cCols  = m_cCols;

        m_astrColNames = new STR[m_cCols];
        m_astrValues   = new STR[m_cCols];
        m_acbValue     = new LONG[m_cCols];

        //
        //  Otherwise, get the column names of the result set and use the
        //  display_size() function to compute the length needed by each data
        //  type.  Next, bind the columns and specify all data will be
        //  converted to char.
        //

        for (i = 0; i < m_cCols; i++)
        {
            m_rc = pSQLDescribeCol( m_hStmt,
                                    i + 1,
                                    (UCHAR *) achColName,
                                    (SWORD)sizeof(achColName),
                                    &cchColName,
                                    &ColType,
                                    &cchColLength,
                                    &scale,
                                    &nullable);

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            //
            //  Select the buffer size for the retrieved data for this column
            //

            cchColLength = ODBC_CONNECTION::DisplaySize( ColType,
                                        min( cchColLength, cchMaxFieldSize) );

            //
            //  Copy the column name and set the column data size
            //

            if ( !m_astrColNames[i].Copy( achColName ) ||
                 !m_astrValues[i].Resize( cchColLength + 1 ))
            {
                return FALSE;
            }

            m_rc = pSQLBindCol( m_hStmt,
                                i + 1,
                                SQL_C_CHAR,
                                m_astrValues[i].QueryPtr(),
                                cchColLength,
                                &m_acbValue[i] );

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;
        }

        *pastrCols = m_astrColNames;
        *cCols     = m_cCols;
    }
    else
    {
        *pfHaveResultSet = FALSE;
    }

    return TRUE;
}


BOOL
ODBC_STATEMENT::QueryValuesAsStr(
    STR * *       pastrValues,
    OUT DWORD * * pacbValues,
    BOOL *  pfLast
    )
/*++

  This method gets the data at the current position.

  Arguments:

    pastrValues - Receives a pointer to an array of strings that contains
        the alphanumeric representation of that field
    pacbValues - Receives pointer to array of DWORDs that contain the length
        of the field
    pfLast - Set to TRUE if there are no more values to retrieve

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    *pastrValues = NULL;

    //
    //  Build the bindings if we haven't already
    //

    if ( !m_astrColNames )
    {
        STR * astrCols;
        DWORD cCols;
        BOOL  fHaveResultSet;

        if ( !QueryColNames( &astrCols,
                             &cCols,
                             0,
                             &fHaveResultSet ))
        {
            return FALSE;
        }
    }

    //
    //  If there are columns to enumerate, get them now
    //

    if ( m_astrColNames )
    {
        DWORD i;

        //
        //  Zero terminate the columns as some drivers don't write anything
        //  for NULL fields
        //

        for ( i = 0; i < m_cCols; i++ )
        {
            *((CHAR *) m_astrValues[i].QueryPtr()) = '\0';
            m_acbValue[i] = 0;
        }

        //
        //  Fill in the binding values
        //

        m_rc = pSQLFetch( m_hStmt );

        if ( m_rc == SQL_NO_DATA_FOUND )
        {
            *pfLast = TRUE;
        }
        else
        {
            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            *pfLast = FALSE;
        }

        *pastrValues = m_astrValues;
        *pacbValues  = (DWORD *) m_acbValue;
    }
    else
    {
        *pfLast = TRUE;
    }

    return TRUE;
}

BOOL
ODBC_STATEMENT::MoreResults(
    BOOL * pfMoreResults
    )
/*++

    Determines if there are any more results sets to return to the user

    pfMoreResults - Set to TRUE if there are more results in the result set

--*/
{
    *pfMoreResults = TRUE;

    m_rc = pSQLMoreResults( m_hStmt );

    if ( m_rc == SQL_NO_DATA_FOUND )
    {
        *pfMoreResults = FALSE;
        return TRUE;
    }

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    return TRUE;
}


VOID
ODBC_STATEMENT::FreeColumnMemory(
    VOID
    )
/*++
    This method frees memory allocated by the QueryColNames and
    QueryValuesAsStr methods.

--*/
{
    if ( m_astrColNames ) delete [] m_astrColNames;
    if ( m_astrValues )   delete [] m_astrValues;
    if ( m_acbValue )     delete [] m_acbValue;

    m_astrColNames = NULL;
    m_astrValues = NULL;
    m_acbValue = NULL;

}

# if DBG


VOID
ODBC_STATEMENT::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ODBC_STATEMENT( %08x)."
                " HStmt = %08x. OdbcConn=%08x. RetCode = %d\n",
                m_hStmt, m_pOdbcConnection, m_rc));

} // ODBC_STATEMENT::Print()

# endif // DBG


/**************************************************
 *  Member Functions of class ODBC_CONNECTION
 **************************************************/


ODBC_CONNECTION::~ODBC_CONNECTION( VOID)
/*++
   This function closes the odbc connection ( if open) and cleans up.

--*/
{
    DBG_REQUIRE( Close());
    return;
} // ODBC_CONNECTION::~ODBC_CONNECTION()





BOOL
ODBC_CONNECTION::Open(
    IN LPCSTR   pszDataSource,
    IN LPCSTR   pszUserName,
    IN LPCSTR   pszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pszUserName      pointer to null-terminated string containing UserName
    pszPassword      pointer to null-terminated string containing Password

  Returns:

    TRUE on success and FALSE if there is an error.
--*/
{
    BOOL fReturn = FALSE;

    DBG_ASSERT( pszDataSource != NULL &&
                pszUserName != NULL &&
                pszPassword != NULL);

    //
    //  Allocate an ODBC environment
    //

    m_rc = pSQLAllocEnv( &m_henv);
    fReturn = Success( m_rc);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SQLAllocEnv() returned ErrorCode %d. henv = %08x\n",
                    m_rc, m_henv));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( fReturn) {

        //
        // Establish memory for connection handle within the environment
        //

        m_rc = pSQLAllocConnect( m_henv, &m_hdbc);
        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLAllocConnect() returns code %d. hdbc = %08x\n",
                        m_rc, m_hdbc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    if ( fReturn) {

        //
        // Use Following call to just printout the dynamic values for ODBC
        //
        // AuxOdbcFunctions( m_henv, m_hdbc);

#if 0
        {
            STR str;
            STR strOut;
            SWORD swStrOut;

            if ( !str.Append( pszDataSource )   ||
                 !str.Append( ";UID=" )         ||
                 !str.Append( pszUserName )     ||
                 !str.Append( ";PWD=" )         ||
                 !str.Append( pszPassword )     ||
                 !str.Append( ";APP=Internet Services") ||
                 !strOut.Resize( 255 ))
            {
                return FALSE;
            }

            m_rc = pSQLDriverConnect( m_hdbc,
                                      NULL,
                                      (UCHAR *) str.QueryStr(),
                                      SQL_NTS,
                                      (UCHAR *) strOut.QueryStr(),
                                      strOut.QuerySize(),
                                      &swStrOut,
                                      SQL_DRIVER_NOPROMPT );
        }
#else
        {
            m_rc = pSQLConnect( m_hdbc,
                               (UCHAR FAR *) pszDataSource, SQL_NTS,
                               (UCHAR FAR *) pszUserName,   SQL_NTS,
                               (UCHAR FAR *) pszPassword,   SQL_NTS);
        }
#endif

        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLConnect( %s, %s, %s) returns code %d.\n",
                        pszDataSource,
                        pszUserName,
                        pszPassword,
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    m_fValid = fReturn;

    if ( !fReturn) {
        SetLastError( ERROR_GEN_FAILURE );
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()





BOOL
ODBC_CONNECTION::Open(
    IN LPCWSTR  pwszDataSource,
    IN LPCWSTR  pwszUserName,
    IN LPCWSTR  pwszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pwszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pwszUserName      pointer to null-terminated string containing UserName
    pwszPassword      pointer to null-terminated string containing Password

  Returns:
    TRUE on success and FALSE if there is an error.

  Note:
     Poor me.  ODBC Does not take UNICODE strings :(. 2/15/95
     So we will explicitly convert parameters to ANSI on stack.
--*/
{
    BOOL   fReturn;
    DWORD  dwError = NO_ERROR;
    CHAR * pszDataSource;
    CHAR * pszUserName;
    CHAR * pszPassword;

    //
    // Convert all parameters from UNICODE to ANSI
    //
    pszDataSource = ConvertUnicodeToAnsi( pwszDataSource, NULL, 0);
    pszUserName   = ConvertUnicodeToAnsi( pwszUserName, NULL, 0);
    pszPassword   = ConvertUnicodeToAnsi( pwszPassword, NULL, 0);

    //
    // Make an ANSI open call.
    //
    fReturn = Open( pszDataSource, pszUserName, pszPassword);

    if ( !fReturn)  {

        dwError = GetLastError();
    }

    //
    //  Freeup the space allocated.
    //
    if ( pszDataSource != NULL) {

        TCP_FREE( pszDataSource);
        pszDataSource = NULL;
    }

    if ( pszUserName != NULL) {

        TCP_FREE( pszUserName);
        pszUserName = NULL;
    }

    if ( pszPassword != NULL) {

        //
        // Zero the password for security reasons.
        //
        memset( pszPassword, 0, strlen( pszPassword));

        TCP_FREE( pszPassword);
        pszPassword = NULL;
    }

    if ( !fReturn) {

        SetLastError( dwError);
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()




BOOL
ODBC_CONNECTION::Close( VOID)
/*++
  This function closes the connection established with the ODBC
   and frees up and dynamic memory used.

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:
    Intermediate failures are ignored. Normally they should not occur.

--*/
{
    BOOL fReturn = TRUE;


    //
    // Disconnect and free the connection.
    //
    if ( m_hdbc != SQL_NULL_HDBC) {

        m_rc = pSQLDisconnect( m_hdbc );

        //
        //  Disconnect is allowed to fail w/o being fatal so don't set
        //  fReturn
        //

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Warning: SQLDisconnect() returns code %d.\n",
                        m_rc));
            CheckAndPrintErrorMessage( this, m_rc);
        }

        m_rc = pSQLFreeConnect( m_hdbc);

        m_hdbc = SQL_NULL_HDBC;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeConnect() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    //
    //  Free the ODBC environment handle.
    //
    if ( m_henv != SQL_NULL_HENV) {

        m_rc = pSQLFreeEnv( m_henv);
        m_henv = SQL_NULL_HENV;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeEnv() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    return ( fReturn);
} // ODBC_CONNECTION::Close()





PODBC_STATEMENT
ODBC_CONNECTION::AllocStatement( VOID)
/*++
  Description:
    This function allocates a new ODBC statement object and also calls
     SQLAllocStatement to create the state required for establishing the
     statement in the ODBC Manager.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    PODBC_STATEMENT pOdbcStmt = NULL;
    HSTMT   hstmt = SQL_NULL_HSTMT;

    DBG_ASSERT( Success( m_rc));

    //
    // Allocate a statement handle and associate it with the connection.
    //
    m_rc = pSQLAllocStmt( m_hdbc, &hstmt);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SqlAllocStmt() returns code %d."
                    " New Hstmt is : %08x\n",
                    m_rc, hstmt));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( ODBC_CONNECTION::Success( m_rc)) {

        pOdbcStmt = new ODBC_STATEMENT( this, hstmt);
    }

    return ( pOdbcStmt);
} // ODBC_CONNECTION::AllocStatement()


BOOL
ODBC_CONNECTION::SetConnectOption(
    IN UWORD Option,
    IN UDWORD Param
    )
/*++

  Sets various options on this connection

  Arguments:

    Option - Option to set
    Param - Option value (32 bit dword or pointer to null terminated string)

  Returns:
    TRUE on success and FALSE if there are any failures.  Failures are
    considered to be soft errors as the problem may be the driver doesn't
    support the option etc.

  Note:

--*/
{
    BOOL    fReturn = TRUE;
    RETCODE rc;

    if ( m_hdbc != SQL_NULL_HDBC)
    {
        rc = pSQLSetConnectOption( m_hdbc, Option, Param );

        fReturn = Success( rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLSetConnectOption( %d, %d ) returns code %d.\n",
                        Option,
                        Param,
                        rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT,
                     "[SetConnectOption] Warning: Setting option on closed connection\n" ));
    }

    return fReturn;
}



BOOL
ODBC_CONNECTION::GetLastErrorText(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        pstrError->Reset();

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                             "[State=%s][Error=%d]%s\n",
                             achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorText()



BOOL
ODBC_CONNECTION::GetLastErrorTextAsHtml(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( !pstrError->Copy( "<UL>" ))
        {
            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                          "<LI>[State=%s][Error=%d]%s\n",
                          achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    if ( !pstrError->Append( "</UL>" )) {
                        return FALSE;
                    }

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorTextAsHtml()



BOOL
ODBC_CONNECTION::GetInfo(IN DWORD fInfoType,
                         IN PVOID rgbInfoValue,
                         IN DWORD cbInfoValueMax,
                         IN OUT DWORD * pcbInfoValue)
/*++
  This function obtains the value of the fInfoType for a specific
   ODBC Connection. It mimicks the SQLGetInfo() and uses it to obtain
   this value. On successful return the pointer rgbInfoValue contains
   the requested value and pcbInfoValue contains the size in bytes of
   data.

  Arguments:
    fInfoType - flag containing the Information Type (name) to be fetched.
    rgbInfoValue - pointer to buffer which will contain the return data.
    cbInfoValue  - size of rgbInfoValue in bytes.
    pcbInfoValue - pointer to location that will contain the size of
                    information stored in rgbInfoValue, on successful return.
                   If buffer is insufficient, this location will contain the
                    required number of bytes.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fReturn = FALSE;

    if ( m_hdbc != SQL_NULL_HDBC) {

        RETCODE rc;

        rc = pSQLGetInfo( m_hdbc, (UWORD ) fInfoType,
                         (PTR)   rgbInfoValue,
                         (SWORD) cbInfoValueMax,
                         (SWORD FAR *) pcbInfoValue);

        fReturn = Success( rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLGetInfo( %08x, %d, %08x, %d, %08x) returns %d.\n",
                        m_hdbc, fInfoType, rgbInfoValue, cbInfoValueMax,
                        pcbInfoValue, rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    } else {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[SQLGetInfo] Invalid Connection to ODBC\n"));
    }

    return (fReturn);
} // ODBC_CONNECTION::GetInfo()



DWORD
ODBC_CONNECTION::DisplaySize(
    SWORD coltype,
    DWORD collen
    )
{
    DWORD cbSize = MAX_NONCHAR_DATA_LEN;

    //
    //  Note that we always set the size to at least four bytes.  This prevents
    //  any possible problems if the column to be bound is NULLable, which can
    //  cause a NULL to be written for the data during a fetch
    //

    switch (coltype)
    {
      case SQL_CHAR:
      case SQL_VARCHAR:
      case SQL_LONGVARCHAR:
      case SQL_BINARY:
      case SQL_VARBINARY:
      case SQL_LONGVARBINARY:
        cbSize = max(collen + sizeof(CHAR), sizeof(PVOID));
        break;

      default:
        break;
    }

    return ( cbSize);
} // ODBC_CONNECTION::DisplaySize()




# if DBG
VOID
ODBC_CONNECTION::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_CONNECTION ( %08x). fValid = %d\n"
                " HENV = %08x. HDBC = %08x. ReturnCode =%d\n",
                this, m_fValid,
                m_henv, m_hdbc, m_rc));
    return;
} // ODBC_CONNECTION::Print()


# endif // DBG

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\parse.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        parse.hxx

   Abstract:

        Simple parser class for extrapolating HTTP headers information

   Author:
           John Ludeman     (JohnL)    18-Jan-1995

   Project:
           HTTP server

   Revision History:

--*/
#include <tcpdllp.hxx>
#include <parse.hxx>


INET_PARSER::INET_PARSER(
    CHAR * pszStart
    )
/*++

Routine Description:

    Sets the initial position of the buffer for parsing

Arguments:

    pszStart - start of character buffer
    pszEnd - End of buffer

Return Value:

--*/
    : m_fListMode   ( FALSE ),
      m_pszPos      ( pszStart ),
      m_pszTokenTerm( NULL ),
      m_pszLineTerm ( NULL )
{
    DBG_ASSERT( pszStart );

    //
    //  Chew up any initial white space at the beginning of the buffer
    //  and terminate the first token in the string.
    //

    EatWhite();

    TerminateToken();
}


INET_PARSER::~INET_PARSER(
    VOID
    )
/*++

Routine Description:

    Restores any changes we made to the string while parsing

Arguments:

--*/
{
    RestoreBuffer();
}


CHAR *
INET_PARSER::QueryPos(
    VOID
    )
/*++

Routine Description:

    Removes the terminators and returns the current parser position

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();
    RestoreLine();

    return m_pszPos;
}

VOID
INET_PARSER::SetPtr(
    CHAR * pch
    )
/*++

Routine Description:

    Sets the parser to point at a new location

Arguments:

    pch - New position for parser to start parsing from

Return Value:

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = pch;
}


CHAR *
INET_PARSER::QueryToken(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated token

    If list mode is on, then a comma is considered a delimiter.

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    if ( !m_pszTokenTerm )
        TerminateToken( m_fListMode ? ',' : '\0' );

    return m_pszPos;
}


CHAR *
INET_PARSER::QueryLine(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated line

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    return m_pszPos;
}


BOOL
INET_PARSER::CopyToken(
    STR * pStr,
    BOOL  fAdvanceToken
    )
/*++

Routine Description:

    Copies the token at the current position to *pStr

Arguments:

    pStr - Receives token
    fAdvanceToken - True if we should advance to the next token

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL fRet;

    DBG_ASSERT( pStr );

    if ( !m_pszTokenTerm )
        TerminateToken();

    fRet = pStr->Copy( m_pszPos );

    if ( fAdvanceToken )
        NextToken();

    return fRet;
}


BOOL
INET_PARSER::CopyToEOL(
    STR   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Copies the token at the current character position

Arguments:

--*/
{
    BOOL fRet;

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    fRet = pstr->Copy( m_pszPos );

    if ( fAdvance )
        NextLine();

    return fRet;
}

BOOL
INET_PARSER::AppendToEOL(
    STR   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Same as CopyToEOL except the text from the current line is appended to
    pstr

Arguments:

--*/
{
    BOOL fRet;

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    fRet = pstr->Append( m_pszPos );

    if ( fAdvance )
        NextLine();

    return fRet;
}


CHAR *
INET_PARSER::NextLine(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the first non-white character after the
    next '\n' (or terminating '\0').

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = AuxSkipTo( '\n' );

    if ( *m_pszPos )
        m_pszPos++;

    return EatWhite();
}

CHAR *
INET_PARSER::NextToken(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the next non-white character after the
    current token

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    //
    //  Skip the current token
    //

    EatNonWhite();

    EatWhite();

    TerminateToken();

    return m_pszPos;
}


CHAR *
INET_PARSER::NextToken(
    CHAR ch
    )
/*++

Routine Description:

    Advances the position to the next token after ch (stopping
    at the end of the line)

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    //
    //  Look for the specified character (generally ',' or ';')
    //

    SkipTo( ch );

    if ( *m_pszPos )
        m_pszPos++;

    EatWhite();

    TerminateToken( ch );

    return m_pszPos;
}


CHAR *
INET_PARSER::SkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    m_pszPos = AuxSkipTo( ch );

    return m_pszPos;
}


VOID
INET_PARSER::SetListMode(
    BOOL fListMode
    )
/*++

Routine Description:

    Resets the parser mode to list mode or non-list mode

Arguments:

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
        TerminateLine();

    m_fListMode = fListMode;
}

VOID
INET_PARSER::TerminateToken(
    CHAR ch
    )
/*++

Routine Description:

    Zero terminates after the white space of the current token

Arguments:

--*/
{
    DBG_ASSERT( !m_pszTokenTerm );

    m_pszTokenTerm = AuxEatNonWhite( ch );

    m_chTokenTerm = *m_pszTokenTerm;

    *m_pszTokenTerm = '\0';
}

VOID
INET_PARSER::RestoreToken(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszTokenTerm )
    {
        *m_pszTokenTerm = m_chTokenTerm;
        m_pszTokenTerm = NULL;
    }
}

VOID
INET_PARSER::TerminateLine(
    VOID
    )
/*++

Routine Description:

    Zero terminates at the end of this line

Arguments:

--*/
{
    DBG_ASSERT( !m_pszLineTerm );

    m_pszLineTerm = AuxSkipTo( '\n' );

    //
    //  Now trim any trailing white space on the line
    //

    if ( m_pszLineTerm > m_pszPos )
    {
        m_pszLineTerm--;

        while ( m_pszLineTerm >= m_pszPos &&
                ISWHITEA( *m_pszLineTerm ))
        {
            m_pszLineTerm--;
        }
    }

    //
    //  Go forward one (trimming found the last non-white
    //  character)
    //

    if ( *m_pszLineTerm &&
         *m_pszLineTerm != '\n' &&
         !ISWHITEA( *m_pszLineTerm ))
    {
        m_pszLineTerm++;
    }

    m_chLineTerm = *m_pszLineTerm;

    *m_pszLineTerm = '\0';
}

VOID
INET_PARSER::RestoreLine(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszLineTerm )
    {
        *m_pszLineTerm = m_chLineTerm;
        m_pszLineTerm = NULL;
    }
}




CHAR *
INET_PARSER::AuxEatNonWhite(
    CHAR ch
    )
/*++

Routine Description:

    In non list mode returns the first white space character after 
    the current parse position
    In list mode returns the first delimiter ( "';\n" ) character after 
    the current parse position

Arguments:

    ch - Optional character that is considered white space (such as ',' or ';'
        when doing list processing).

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'.  In list mode, comma and semi-colon
    //  are considered delimiters
    //

    if ( !m_fListMode )
    {
        while ( *psz           &&
                *psz != '\n'   &&
                !ISWHITEA(*psz)&&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
    else
    {
        while ( *psz           &&
                *psz != '\n'   &&
#if 0
                // fix #20931
                !ISWHITEA(*psz)&&
#endif
                *psz != ','    &&
                *psz != ';'    &&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
}


CHAR *
INET_PARSER::AuxEatWhite(
    VOID
    )
/*++

Routine Description:

    Returns the first non-white space character after the current parse
    position

Arguments:

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'
    //

    while ( *psz           &&
            *psz != '\n'   &&
            ISWHITEA(*psz))
    {
        psz++;
    }

    return psz;
}


CHAR *
INET_PARSER::AuxSkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    CHAR * psz = m_pszPos;

    while ( *psz           &&
            *psz != '\n'   &&
            *psz != ch )
    {
        psz++;
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\pa\pacopy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pacopy.c

Abstract:

    This module demonstrates a minimal HTTP Server Extension gateway

Author:

    Philippe Choquier ( phillich ) 27-mar-1998

--*/

#include <windows.h>
#include <iisextp.h>

LPSTR
ScanForSlashBackward(
    LPSTR   pBase,
    INT     cChars,
    INT     cSlashes
    )
{
    CHAR*   p = pBase + cChars;
    int     ch;

    while ( cChars-- )
    {
        if ( (ch = *--p) == '/' || ch == '\\' )
        {
            if ( !--cSlashes )
            {
                break;
            }
        }
    }

    return cSlashes ? NULL : p;
}

BOOL
RemoveExt(
    LPSTR   pWhere,
    LPSTR   pExt
    )
{
    int     cWhere = strlen(pWhere);
    int     cExt = strlen(pExt);

    if ( cWhere < cExt ||
         memcmp( pWhere + cWhere - cExt, pExt, cExt ) )
    {
        return FALSE;
    }

    pWhere[cWhere - cExt] = '\0';

    return TRUE;
}

/*
 *  The string starts with two hex characters.  Return an integer formed from them.
 */
int TwoHex2Int(char *pC) 
{
int Hi;
int Lo;
int Result;

    Hi = pC[0];
    if ('0'<=Hi && Hi<='9') {
        Hi -= '0';
    } else
    if ('a'<=Hi && Hi<='f') {
        Hi -= ('a'-10);
    } else
    if ('A'<=Hi && Hi<='F') {
        Hi -= ('A'-10);
    }
    Lo = pC[1];
    if ('0'<=Lo && Lo<='9') {
        Lo -= '0';
    } else
    if ('a'<=Lo && Lo<='f') {
        Lo -= ('a'-10);
    } else
    if ('A'<=Lo && Lo<='F') {
        Lo -= ('A'-10);
    }
    Result = Lo + 16*Hi;
    return Result;
}

/*
 *  Decode the given string in-place by expanding %XX escapes
 */
void 
urlDecode(
    char *p
    )
{
    char *pD;

    pD = p;
    while (*p) 
    {
        if (*p=='%') 
        {
            /* Escape: next 2 chars are hex representation of the actual character */
            p++;
            if (isxdigit(p[0]) && isxdigit(p[1])) 
            {
                *pD++ = (char) TwoHex2Int(p);
                p += 2;
            }
        } 
        else if ( *p == '+' )
        {
            *pD++ = ' ';
            ++p;
        }
        else
        {
            *pD++ = *p++;
        }
    }

    *pD = '\0';
}

#define END_OF_DOC   "End of document"

DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    char                buff[2048];
    int                 cb = sizeof(END_OF_DOC) - 1;
    CHAR                achDest[MAX_PATH];
    CHAR                achSourceUrl[MAX_PATH];
    CHAR*               p;
    CHAR*               f;
    CHAR*               t;
    int                 c;
    HSE_URL_MAPEX_INFO  mapex;
    DWORD               dwOut;
    DWORD               dwIn;
    DWORD               dwErr = 0;
    LPSTR               pFileName = "";
    LPSTR               pFileExtension = "";
    LPSTR               pFileSize = "";

    if ( pecb->lpbData )
    {
        // delimit buffer
        pecb->lpbData[pecb->cbTotalBytes] = '\0';
        urlDecode(pecb->lpbData);

        // first parse off the data
        for ( p = strtok( pecb->lpbData, "&") ; p ; p = strtok(NULL, "&") )
        {
            if ( !_memicmp( p, "FileName=", sizeof("FileName=")-1) )
            {
                pFileName = p + sizeof("FileName=")-1;
            }
            else if ( !_memicmp( p, "FileExtention=", sizeof("FileExtention=")-1) )
            {
                pFileExtension = p + sizeof("FileExtention=")-1;
            }
            else if ( !_memicmp( p, "FileSize=", sizeof("FileSize=")-1) )
            {
                pFileSize = p + sizeof("FileSize=")-1;
            }
        }
    }

    //
    // request is /upload_vdir/ntraid_UNC_vdir.pac
    // we need to copy /upload_vdir/"uploadd"/raid_filename/original_filename.original_ext
    //              to /upload_vdir/ntraid_UNC_vdir/raid_filename
    //
    // ex; http://localhost/scripts/raid/ntguest2/3812420.pac
    //

    if ( strlen(pecb->lpszPathTranslated) >= MAX_PATH ||
         strlen(pecb->lpszPathInfo) >= MAX_PATH )
    {
        SetLastError( ERROR_INVALID_PARAMETER );

        return HSE_STATUS_ERROR;
    }

    strcpy( achDest, pecb->lpszPathTranslated );
    if ( !RemoveExt( achDest, ".pac") )
    {
        return HSE_STATUS_ERROR;
    }

    if ( !RemoveExt( pecb->lpszPathInfo, ".pac") )
    {
        return HSE_STATUS_ERROR;
    }
    strcpy( achSourceUrl, pecb->lpszPathInfo );
    if ( (p = ScanForSlashBackward( achSourceUrl, strlen(achSourceUrl), 2 )) != NULL )
    {
        strcpy( p, "/uploadd" );
        p += strlen(p);
        if ( (f = ScanForSlashBackward( pecb->lpszPathInfo, strlen(pecb->lpszPathInfo), 1 )) != NULL )
        {
            strcpy( p, f );
            strcat( p, "/" );
            strcat( p, pFileName );
            if ( *pFileExtension )
            {
                strcat( p, pFileExtension );
            }
        }
        else 
        {
            return HSE_STATUS_ERROR;
        }
        if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                           HSE_REQ_MAP_URL_TO_PATH_EX,
                                           achSourceUrl,
                                           &dwOut,
                                           (LPDWORD) &mapex ) )
        {
            return HSE_STATUS_ERROR;
        }

        //
        // check that virtual dir has 'read' attribute
        //

        if ( !(mapex.dwFlags & HSE_URL_FLAGS_READ) )
        {
            return HSE_STATUS_ERROR;
        }
    }
    else
    {
        return HSE_STATUS_ERROR;
    }

    //
    // This DLL can be invoked to either delete attachment ( query string = "del=" )
    // or to copy file from temporary directory to UNC share
    //

    if ( !strcmp(pecb->lpszQueryString,"del=") )
    {
        DeleteFile( achDest );
    }
    else
    {
        // copy mapex.lpszPath to achDest

        if ( !CopyFile( mapex.lpszPath, achDest, FALSE ) )
        {
            dwErr = GetLastError();

            return HSE_STATUS_ERROR;
        }

        // remove file, dir

        DeleteFile( mapex.lpszPath );
        if ( (p = ScanForSlashBackward( mapex.lpszPath, strlen(mapex.lpszPath), 1 )) != NULL )
        {
            *p = '\0';
            RemoveDirectory( mapex.lpszPath );
        }
    }

#if 0

    // Posting Acceptor does not handle redirect, so we have to send back 200

    wsprintf( buff, "%s?raid=%s&org=%s%s&st=%s", 
              pecb->lpszQueryString,
              f+1,
              pFileName,
              pFileExtension,
              pFileSize );

    dwIn = strlen(buff);

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_URL_REDIRECT_RESP,
                                       buff,
                                       &dwIn,
                                       (LPDWORD) NULL ) )
    {
        return HSE_STATUS_ERROR;
    }

#else

    //
    // The output of this DLL is for debugging use only : when invoked through
    // posting acceptor the posting acceptor DLL will only check for status=200
    // and discard output
    //

    wsprintf( buff,
             "Content-Type: text/html\r\n"
             "\r\n"
             "<head><title>Minimal Server Extension Example</title></head>\n"
             "<body><h1>Minimal Server Extension Example (BGI)</h1>\n"
             "<p>Method               = %s\n"
             "<p>Query String         = %s\n"
             "<p>Path Info            = %s\n"
             "<p>Translated Path Info = %s\n"
             "<p>Copy Source          = %s\n"
             "<p>Copy Destination     = %s\n"
             "<p>File copy status     = %u\n"
             "<p>"
             "<p>"
             "</body>",
             pecb->lpszMethod,
             pecb->lpszQueryString,
             pecb->lpszPathInfo,
             pecb->lpszPathTranslated,
             mapex.lpszPath,
             achDest,
             dwErr );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       NULL,
                                       (LPDWORD) buff ) )
    {
        return HSE_STATUS_ERROR;
    }

#endif

    return HSE_STATUS_SUCCESS;
}

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 1, 0 );
    strcpy( pver->lpszExtensionDesc,
            "Posting acceptor copy extension" );

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\odbc_oop\parmlist.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parmlist.cxx

Abstract:

    Simple class for parsing and storing parameter list pairs

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

--*/

# include "dbgutil.h"
#ifndef _TCPDLL_H_
#define _TCPDLL_H_

# if !defined( dllexp)
#define dllexp __declspec( dllexport )
# endif // dllexp

//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

//#define SECURITY_WIN32
//#include <sspi.h>           // Security Support Provider APIs

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>


#ifdef __cplusplus
} // extern "C"

#include <buffer.hxx>
#include <string.hxx>
#include <refb.hxx>

#include <parse.hxx>


#endif // __cplusplus

//#include <tcpcons.h>

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
//  Project include files.
//


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif  // _TCPDLL_H_

#include "parmlist.hxx"


inline
BOOL
UnescapeStr( STR * pstr )
{
    CHAR * pch;

    pch = pstr->QueryStr();
    while ( pch = strchr( pch, '+' ))
        *pch = ' ';

    return pstr->Unescape();
}



PARAM_LIST::~PARAM_LIST(
    VOID
    )
/*++

Routine Description:

    Param list destructor

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ))
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
    }

    while ( !IsListEmpty( &_FreeHead ))
    {
        pFVP = CONTAINING_RECORD( _FreeHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
    }

}

VOID
PARAM_LIST::Reset(
    VOID
    )
/*++

Routine Description:

    Resets the parameter list back to its initially constructed state

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ))
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        RemoveEntryList( &pFVP->ListEntry );

        //
        //  Put the removed item on the end so the same entry will tend to
        //  be used for the same purpose on the next use
        //

        InsertTailList( &_FreeHead, &pFVP->ListEntry );
    }

    m_fCanonicalized = FALSE;
}

BOOL
PARAM_LIST::ParsePairs(
    const CHAR * pszList,
    BOOL         fDefaultParams,
    BOOL         fAddBlankValues,
    BOOL         fCommaIsDelim
    )
/*++

Routine Description:

    Puts the text list into a linked list of field/value pairs

    This can be used to parse lists in the form of:

    "a=b,c=d,e=f" (with fCommaIsDelim = TRUE)
    "name=Joe, Billy\nSearch=tom, sue, avery"  (with fCommaIsDelim = FALSE)

    Duplicates will be appended and tab separated

Arguments:

    pszList - list of comma separated field/value pairs
    fDefaultParams - If TRUE, means these parameters are only defaults and
        shouldn't be added to the list if the field name is already in the
        list and the value is non-empty.
    fAddBlankValues - if TRUE, allow fields with empty values to be added
        to the list, else ignore empty values.
    fCommaIsDelim - if TRUE, a comma acts as a separator between two sets of
        fields values, otherwise the comma is ignored

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    DWORD              cParams = 0;
    DWORD              i;
    BOOL               fRet;
    STR                strParams;
    STR                strField;

    //
    //  Make a copy we can muck with
    //

    if ( !strParams.Copy( pszList ))
        return FALSE;

    //
    //  Replace all of the equal signs and commas with '\n's for easier parsing
    //

    pch = strParams.QueryStr();
    while ( pch = strchr( pch, '=' ))
    {
        *pch = '\n';
        cParams++;
    }

    if ( fCommaIsDelim )
    {
        pch = strParams.QueryStr();
        while ( pch = strchr( pch, ',' ))
        {
            *pch = '\n';
            cParams++;
        }
    }

    //
    //  Pick out the fields and values and build the associative list
    //

    {
        INET_PARSER Parser( strParams.QueryStr() );

        for ( i = 0; i < cParams; i++ )
        {
            if ( !strField.Copy( Parser.QueryToken() ))
                return FALSE;

            Parser.NextLine();

            pch = Parser.QueryToken();

            //
            //  If we aren't supposed to add blanks, then just go to the next
            //  line
            //

            if ( !fAddBlankValues && !*pch )
            {
                Parser.NextLine();
                continue;
            }

            if ( !fDefaultParams )
            {
                FIELD_VALUE_PAIR * pFVP;
                LIST_ENTRY *       ple;

                //
                //  Look for an existing field with this name and append
                //  the value there if we find it, otherwise add a new entry
                //

                for ( ple  = _FieldListHead.Flink;
                      ple != &_FieldListHead;
                      ple  = ple->Flink )
                {
                    pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

                    if ( !_stricmp( pFVP->QueryField(),
                                   strField.QueryStr() ))
                    {
                        //
                        //  CODEWORK - Remove this allocation
                        //

                        STR strtmp( pch );

                        //
                        //  Found this header, append the new value
                        //

                        pFVP->_cValues++;

                        fRet = UnescapeStr( &strtmp )         &&
                               pFVP->_strValue.Append( "\t" ) &&
                               pFVP->_strValue.Append( strtmp );

                        goto Found;
                    }
                }

                fRet = AddEntry( strField.QueryStr(),
                                 pch,
                                 TRUE );
Found:
                ;
            }
            else
            {
                //
                //  Don't add if already in list
                //

                fRet = AddParam( strField.QueryStr(),
                                 pch );
            }

            if ( !fRet )
                return FALSE;

            Parser.NextLine();
        }
    }

    return TRUE;
}


BOOL
PARAM_LIST::AddEntryUsingConcat(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL  fPossibleFastMap
)
/*++

Routine Description:

    Concatenate value with existing entry of same name
    or call AddEntry if none exists

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                       in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    //
    //  Look for an existing field with this name
    //  and add the value there
    //

    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    BOOL               fRet;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            //
            //  Found this header, append the new value
            //

            pFVP->_cValues++;

            fRet = pFVP->_strValue.Append( "," ) &&
                   pFVP->_strValue.Append( pszValue );

            goto Found;
        }
    }

    fRet = AddEntry( pszField,
                     pszValue,
                     FALSE,
                     fPossibleFastMap );

Found:

    return fRet;
}



BOOL
PARAM_LIST::ParseSimpleList(
    const CHAR * pszList
    )
/*++

Routine Description:

    Puts the comma separated list into a linked list of field/value pairs
    where the value is always NULL

Arguments:

    pszList - list of comma separated fields

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    BOOL               fRet;

    //
    //  Pick out the fields and values and build the associative list
    //

    {
        INET_PARSER Parser( (CHAR *) pszList );

        Parser.SetListMode( TRUE );

        while ( *(pch = Parser.QueryToken()) )
        {
            fRet = AddEntry( pch,
                             NULL,
                             TRUE );

            if ( !fRet )
                return FALSE;

            Parser.NextItem();
        }
    }

    return TRUE;
}

CHAR *
PARAM_LIST::FindValue(
    const CHAR * pszField,
    BOOL *       pfIsMultiValue  OPTIONAL,
    DWORD *      pcbValue OPTIONAL
    )
/*++

Routine Description:

    Returns the value associated with pszField or NULL of no value was
    found

Arguments:

    pszField - field to search for value for
    pfIsMultiValue - Set to TRUE if this value is a composite of multiple fields
    pcbValue - Set to size of value (excluding nul terminator)


Return Value:

    Pointer to value or NULL if not found

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            if ( pfIsMultiValue )
            {
                *pfIsMultiValue = pFVP->IsMultiValued();
            }

            if ( pcbValue )
            {
                *pcbValue = pFVP->_strValue.QueryCB();
            }

            return pFVP->QueryValue();
        }
    }


    return NULL;
}

BOOL
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL         fUnescape,
    BOOL         fPossibleFastMap
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                   in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    CHAR *             pch;

    if ( !IsListEmpty( &_FreeHead ) )
    {
        LIST_ENTRY * pEntry;

        pEntry = _FreeHead.Flink;

        RemoveEntryList( _FreeHead.Flink );

        pFVP = CONTAINING_RECORD( pEntry, FIELD_VALUE_PAIR, ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    if ( !pFVP->_strField.Copy( pszField ))
        return FALSE;

    if ( !pFVP->_strValue.Copy( pszValue ))
        return FALSE;

    if ( fUnescape )
    {
        //
        //  Normalize the fields and values (unescape and replace
        //  '+' with ' ')
        //

        if ( !UnescapeStr( &pFVP->_strField ) ||
             !UnescapeStr( &pFVP->_strValue ))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    DWORD        cbField,
    const CHAR * pszValue,
    DWORD        cbValue
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

    The fast map is not used and the fields are not unescaped

Arguments:

    pszField         - Field to add
    cbField          - Number of bytes in pszField
    pszValue         - Value to add
    cbValue          - Number of bytes in pszValue

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR *  pFVP;
    CHAR *              pch;
    PLIST_ENTRY         listEntry;

    listEntry = RemoveHeadList( &_FreeHead );

    if ( listEntry != &_FreeHead )
    {
        pFVP = CONTAINING_RECORD(
                            listEntry,
                            FIELD_VALUE_PAIR,
                            ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    if ( !pFVP->_strField.Copy( pszField, cbField ))
        return FALSE;

    if ( !pFVP->_strValue.Copy( pszValue, cbValue ))
        return FALSE;

    return TRUE;
}

BOOL PARAM_LIST::AddParam(
    const CHAR * pszField,
    const CHAR * pszValue
    )
/*++

Routine Description:

    Adds a field/value pair to the list if the field isn't already in the list
    or the value is empty

    The fields added through this method will be escaped

Arguments:

    pszField - Field to add
    pszValue - Value to add


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            //
            //  We found the field, replace the value if it is empty
            //

            if ( !*pFVP->QueryValue() )
            {
                return pFVP->_strValue.Copy( pszValue );
            }

            return TRUE;
        }
    }

    //
    //  The field name wasn't found, add it
    //

    return AddEntry( pszField,
                     pszValue,
                     TRUE );
}

BOOL
PARAM_LIST::RemoveEntry(
    const CHAR * pszFieldName
    )
/*++

Routine Description:

    Removes all occurrences of the specified fieldname from the list

Arguments:

    pszField - Field to remove

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    LIST_ENTRY *       pleNext;
    BOOL               fFound = FALSE;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = pleNext )
    {
        pleNext = ple->Flink;

        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszFieldName ))
        {
            //
            //  We found a matching field, remove it
            //

            RemoveEntryList( ple );

            InsertHeadList( &_FreeHead, ple );

            fFound = TRUE;
        }
    }

    return (fFound);
}


VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    CHAR * * ppszValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    ppszValue - Receives corresponding value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //
    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *ppszValue = pFVP->QueryValue();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    DWORD *  pcbField,
    CHAR * * ppszValue,
    DWORD *  pcbValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    pcbField -  Receives pointer to length of field
    ppszValue - Receives corresponding value
    pcbValue -  Receives pointer to length of value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //

    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *pcbField  = pFVP->_strField.QueryCB();

    *ppszValue = pFVP->QueryValue();
    *pcbValue  = pFVP->_strValue.QueryCB();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

DWORD
PARAM_LIST::GetCount(
    VOID
    )
{
    LIST_ENTRY * pEntry;
    DWORD        cParams = 0;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    for ( pEntry = _FieldListHead.Flink;
          pEntry != &_FieldListHead;
          pEntry = pEntry->Flink )
    {
        cParams++;
    }

    return cParams;
}


VOID
PARAM_LIST::CanonList(
    VOID
    )
{
    FIELD_VALUE_PAIR * pFVP;
    PLIST_ENTRY        listEntry;
    PLIST_ENTRY        nextEntry;
    PLIST_ENTRY        tmpEntry;

    DBG_ASSERT(!m_fCanonicalized);

    //
    // Go through the list and make sure that there are no dups.
    // if there are, convert them into comma separated lists.
    //

    for ( listEntry  = _FieldListHead.Flink;
          listEntry != &_FieldListHead;
          listEntry  = nextEntry
          )
    {
        DWORD fieldLen;
        PCHAR fieldName;

        nextEntry = listEntry->Flink;

        pFVP = CONTAINING_RECORD( listEntry, FIELD_VALUE_PAIR, ListEntry );


        //
        // if field or value is empty, zap it
        //

        if ( (*pFVP->QueryField() == '\0') ||
             (*pFVP->QueryValue() == '\0') )
        {

            RemoveEntryList( listEntry );
            InsertHeadList( &_FreeHead, listEntry );
            continue;
        }

        fieldName = pFVP->QueryField();
        fieldLen = pFVP->_strField.QueryCB();

        //
        // Walk the rest of the list and look for dup fields
        //

        tmpEntry = nextEntry;

        while ( tmpEntry != &_FieldListHead )
        {

            FIELD_VALUE_PAIR * pTmpFVP;
            pTmpFVP = CONTAINING_RECORD(
                                tmpEntry,
                                FIELD_VALUE_PAIR,
                                ListEntry );

            //
            // combine the two fields
            //

            if ( (pTmpFVP->_strField.QueryCB() == fieldLen) &&
                 (_stricmp(pTmpFVP->QueryField(), fieldName) == 0) &&
                 (*pTmpFVP->QueryValue() != '\0') )
            {

                pFVP->_cValues++;

                (VOID)( pFVP->_strValue.Append( "," ) &&
                      pFVP->_strValue.Append(pTmpFVP->QueryValue()) );

                pTmpFVP->_strField.Reset();
            }

            tmpEntry = tmpEntry->Flink;
        }
    }

    m_fCanonicalized = TRUE;
    return;

} // PARAM_LIST::CanonList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\probe\heapstat.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       heapstat.cxx

   Abstract:
       This module contains functions for handling heap related probes.

   Author:

       Murali R. Krishnan    ( MuraliK )     3-Nov-1997 

   Environment:
    
       Win32 - User Mode 

   Project:

       Internet Server Probe DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
//
// Turn off dllexp so this DLL won't export tons of unnecessary garbage.
//

#ifdef dllexp
#undef dllexp
#endif
#define dllexp

# include "iisprobe.hxx"


/************************************************************
 *    Functions 
 ************************************************************/

VOID
HEAP_BLOCK_STATS::AddStatistics( const HEAP_BLOCK_STATS & heapEnumAddend)
{

    // 
    // Walk through the blocks list and accumulate sum
    //

    DWORD i; // index for block size
    for( i = 0 ; i < MAX_HEAP_BLOCK_SIZE ; i++ ) {

        if( heapEnumAddend.BusyCounters[i] != 0 ) {
            this->BusyCounters[i] += heapEnumAddend.BusyCounters[i];
        }

        if ( heapEnumAddend.FreeCounters[i] != 0 ) {
            this->FreeCounters[i] += heapEnumAddend.FreeCounters[i];
        }
    } // for 


    if ( heapEnumAddend.BusyJumbo != 0) {
        this->BusyJumbo += heapEnumAddend.BusyJumbo;
        this->BusyJumboBytes += heapEnumAddend.BusyJumboBytes;
    }

    if ( heapEnumAddend.FreeJumbo != 0) { 

        this->FreeJumbo += heapEnumAddend.FreeJumbo;
        this->FreeJumboBytes += heapEnumAddend.FreeJumboBytes;
    }

    return;
} // HEAP_BLOCK_STATS::AddStatistics()



VOID
HEAP_BLOCK_STATS::UpdateBlockStats(
    IN LPPROCESS_HEAP_ENTRY lpLocalHeapEntry
    )
/*++
  Description:
     This function looks at the data present in the lpLocalHeapEntry and updates
     internal statistics for blocks using that information.
     Note: We ignore the cbOverhead field

  Arguments:
     lpLocalHeapEntry - pointer to Win32 object with details on Process heap entry
     
  Retruns:
     None   
--*/
{
    DWORD entryLength;
    
# if DETAILED_BLOCK_INFO
    CHAR rgchHeapEntry[200];
    wsprintf( rgchHeapEntry, "%08x: @%08x, cbData=%d, cbOver=%d, iRegion=%d, Flags=%08x\n",
    lpLocalHeapEntry, 
              lpLocalHeapEntry->lpData, 
              lpLocalHeapEntry->cbData, 
              lpLocalHeapEntry->cbOverhead, 
              lpLocalHeapEntry->iRegionIndex, 
              lpLocalHeapEntry->wFlags
              );
    OutputDebugString( rgchHeapEntry);
# endif // DETAILED_BLOCK_INFO
    
    entryLength = lpLocalHeapEntry->cbData;
    
    if( lpLocalHeapEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY ) {
        
        if( entryLength < MAX_HEAP_BLOCK_SIZE ) {
            BusyCounters[entryLength] += 1;
        } else {
            BusyJumbo ++;
            BusyJumboBytes += entryLength;
        }
        
    } else {
        
        if( entryLength < MAX_HEAP_BLOCK_SIZE ) {
            FreeCounters[entryLength] += 1;
        } else {
            FreeJumbo ++;
            FreeJumboBytes += entryLength;
        }
        
    }

    return;
}   // HEAP_BLOCK_STATS::UpdateBlockStats()


VOID 
HEAP_BLOCK_STATS::UpdateBlockStats(IN LPHEAPENTRY32 lpHeapEntry)
/*++
  Description:
     This function looks at the data present in the Win95 HeapEntry and updates
     internal statistics for blocks using that information.
     Note: We ignore the cbOverhead field

  Arguments:
     lpHeapEntry - pointer to Win95 object with details on Process heap entry
     
  Retruns:
     None   
--*/
{

    DWORD entryLength;
    
# if DETAILED_BLOCK_INFO
    
    CHAR rgchHeapEntry[200];

    wsprintf( rgchHeapEntry, "%08x: @%08x, cbData=%d, Flags=%08x\n",
              lpHeapEntry, 
              lpHeapEntry->dwAddress, 
              lpHeapEntry->dwBlockSize, 
              lpHeapEntry->dwFlags
              );

    OutputDebugString( rgchHeapEntry);

# endif // DETAILED_BLOCK_INFO
    
    entryLength = (DWORD)lpHeapEntry->dwBlockSize;
    
    if( lpHeapEntry->dwFlags & LF32_FREE ) {
        
        if( entryLength < MAX_HEAP_BLOCK_SIZE ) {
            FreeCounters[entryLength] += 1;
        } else {
            FreeJumbo ++;
            FreeJumboBytes += entryLength;
        }
        
    } else {
        
        if( entryLength < MAX_HEAP_BLOCK_SIZE ) {
            BusyCounters[entryLength] += 1;
        } else {
            BusyJumbo ++;
            BusyJumboBytes += entryLength;
        }
    }

    return;
}   // HEAP_BLOCK_STATS::UpdateBlockStats()


BOOL
HEAP_BLOCK_STATS::LoadHeapStats( IN PHANDLE phHeap)
/*++
  Description:
     This function loads the heap block statistics for given heap handle
      into the current object.

  Arguments:
     phHeap - pointer to Handle for the heap we are interested in.
     
  Returns:
     TRUE on success and FALSE on failure

  Note: "this" object should have been initialized before this call
   Initialization can be done by calling Reset() method
--*/
{
    BOOL fReturn = TRUE;

    DBG_ASSERT( phHeap != NULL);

    //
    // 1. Lock the heap so that there is no interference from other threads
    //

    if ( HeapLock( phHeap)) {
        
        PROCESS_HEAP_ENTRY heapEntry;   // Win32 heap entry structure
        ZeroMemory( (PVOID ) &heapEntry, sizeof(heapEntry)); // initailize heap entry struct

        //
        // 2. Walk the heap enumerating all the blocks
        //

        while ( HeapWalk( phHeap, &heapEntry)) {

            UpdateBlockStats( &heapEntry);
        } // while


        //
        // 3. Unlock the heap before return
        //

        DBG_REQUIRE( HeapUnlock( phHeap));
    } else {

        DBGPRINTF(( DBG_CONTEXT, "Unable to lock heap(%08x)\n", phHeap));
        fReturn = FALSE;
    }

    return ( fReturn);
} // HEAP_BLOCK_STATS::LoadHeapStats()


BOOL 
HEAP_BLOCK_STATS::LoadHeapStats( 
             IN LPHEAPLIST32  phl32, 
             IN HEAPBLOCKWALK  pHeap32First, 
             IN HEAPBLOCKWALK  pHeap32Next
            )
/*++
  Description:
     This function loads the Win95 heap block statistics for given heap
      into the current object.

  Arguments:
     phl32 - pointer to heap list entry for the heap we r interested in.
     pHeap32First - pointer to function for enumerating First heap block
     pHeap32Next - pointer to function for enumerating Next heap block
     
  Returns:
     TRUE on success and FALSE on failure

  Note: "this" object should have been initialized before this call
   Initialization can be done by calling Reset() method
--*/
{
    BOOL fReturn = TRUE;

    DBG_ASSERT( phl32 != NULL);

    HEAPENTRY32  heapEntry;

    ZeroMemory( (PVOID ) &heapEntry, sizeof(heapEntry)); // initailize heap entry struct
    heapEntry.dwSize = sizeof(HEAPENTRY32);

    //
    // Walk the heap enumerating all the blocks
    //

    if ( pHeap32First(&heapEntry, phl32->th32ProcessID, phl32->th32HeapID) ) 
    {
        UpdateBlockStats(&heapEntry);

        while ( pHeap32Next( &heapEntry, phl32->th32ProcessID, phl32->th32HeapID)) {

            UpdateBlockStats( &heapEntry);
        } // while
    } 

    return ( fReturn);

} // HEAP_BLOCK_STATS::LoadHeapStats()



/**********************************************************************
 *    Member Functions of HEAP_STATS
 **********************************************************************/

VOID
HEAP_STATS::ExtractStatsFromBlockStats( const HEAP_BLOCK_STATS * pheapBlockStats)
{

    //
    // initialize statistics to be nothing
    //
    ZeroMemory( this, sizeof( *this));

    // 
    // Walk through the cumulative statistics structure and extract sum
    //

    DWORD i; // index for block size
    for( i = 0 ; i < MAX_HEAP_BLOCK_SIZE ; i++ ) {

        if( pheapBlockStats->BusyCounters[i] != 0) {
            
            this->m_BusyBlocks += pheapBlockStats->BusyCounters[i];
            this->m_BusyBytes  += i * pheapBlockStats->BusyCounters[i];
        }

        if ( pheapBlockStats->FreeCounters[i] != 0 ) {

            this->m_FreeBlocks += pheapBlockStats->FreeCounters[i];
            this->m_FreeBytes  += i * pheapBlockStats->FreeCounters[i];
        }
    } // for 


    if( pheapBlockStats->BusyJumbo != 0) {

        this->m_BusyBlocks += pheapBlockStats->BusyJumbo;
        this->m_BusyBytes  += pheapBlockStats->BusyJumboBytes;
    }

    if ( pheapBlockStats->FreeJumbo != 0 ) {

        this->m_FreeBlocks += pheapBlockStats->FreeJumbo;
        this->m_FreeBytes  += pheapBlockStats->FreeJumboBytes;
    }

    return;

} // HEAP_STATS::ExtractStatsFromBlockStats()



VOID
HEAP_STATS::AddStatistics( const HEAP_STATS & heapStats)
{

    //
    //  Accumulate the statistics from heapStats into the current object
    //

    m_BusyBlocks += heapStats.m_BusyBlocks;
    m_BusyBytes  += heapStats.m_BusyBytes;

    m_FreeBlocks += heapStats.m_FreeBlocks;
    m_FreeBytes  += heapStats.m_FreeBytes;

    return;
} // HEAP_STATS::AddStatistics()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\samples\favlist\favlist.h ===
#define IDS_FAVORITE_SITE 1
#define IDS_BAD_REQUEST   2
#define IDS_200_OK        3
#define IDS_CONTENT_TYPE  4
#define IDS_TITLE_MSG_1   5  
#define IDS_TITLE_MSG_2   6
#define IDS_ERROR_1       7
#define IDS_THANK_YOU     8
#define IDS_DROP_HTM      9
#define IDS_CANNOT_OPEN   10
#define IDS_FONT          11
#define IDS_COULD_NOT_FIND_END_FILE 12
#define IDS_DESCRIPTION   13
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\probe\worker.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    worker.cxx

Abstract:

    This module provides the worker functions for IIS Probe

Author:

    Murali R. Krishnan (MuraliK)   16-July-1996

Revision History:
--*/


//
// Turn off dllexp so this DLL won't export tons of unnecessary garbage.
//

#ifdef dllexp
#undef dllexp
#endif
#define dllexp

# include "iisprobe.hxx"
# include "tsunamip.hxx"
// # include "odbcconn.hxx"
# include "iisassoc.hxx"
# include "iisbind.hxx"
# include "acache.hxx"

# if 0
# include "xbf.hxx"
# include "iiscmr.hxx"
# include "certmap.h"
# include "iiscrmap.hxx"
# include "iismap.hxx"
# endif // 0

# include "setable.hxx"
# include "isapidll.hxx"
# include "wamexec.hxx"


/************************************************************
 *  Define the function pointer type for loading the
 *      dump functions exported by internal IIS DLLs
 ************************************************************/

typedef BOOL (* PFNBoolProbeDumpFunction)( OUT CHAR * pchBuffer,
                                           IN OUT LPDWORD lpcchBuffer);

typedef VOID (* PFNVoidProbeDumpFunction)( OUT CHAR * pchBuffer,
                                       IN OUT LPDWORD lpcchBuffer);


extern "C" VOID
TsDumpCacheCounters( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer );

BOOL SendHeapInfoNT( IN EXTENSION_CONTROL_BLOCK * pecb);
BOOL SendHeapInfo95( IN EXTENSION_CONTROL_BLOCK * pecb);


/************************************************************
 *  Define the macros & variables for gathering size information
 ************************************************************/

# define DefunSizeInfo( a)  { #a , sizeof(a) }
# define DefunString( str)  { str, 0}
# define DefunBlank( )      DefunString( " ")

struct _SIZE_INFO {
    char * pszObject;
    int    cbSize;
} sg_rgSizeInfo[] = {

    {"<hr> <h3> Sizes of Objects </h3> <DL>", 0 },
    {" <br> <DT> <b> Generic Objects </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( IIS_SERVICE),
    DefunSizeInfo( IIS_SERVER_INSTANCE),
    DefunSizeInfo( IIS_ENDPOINT),
    DefunSizeInfo( IIS_SERVER_BINDING),
    DefunSizeInfo( IIS_ASSOCIATION),
    DefunSizeInfo( IIS_ENDPOINT),
    DefunSizeInfo( IIS_VROOT_TABLE),
    DefunBlank(),
    DefunSizeInfo( BUFFER),
    DefunSizeInfo( STR),
    DefunBlank(),
    DefunSizeInfo( EVENT_LOG),
    DefunSizeInfo( CACHE_FILE_INFO),
    DefunSizeInfo( DEFERRED_MD_CHANGE),
    DefunSizeInfo( MIME_MAP_ENTRY),
    DefunSizeInfo( MIME_MAP),
    DefunSizeInfo( TCP_AUTHENT_INFO),
    DefunSizeInfo( TCP_AUTHENT),
    DefunSizeInfo( CACHED_TOKEN),
    DefunBlank(),
    DefunSizeInfo( MB),
    DefunSizeInfo( COMMON_METADATA),
    DefunSizeInfo( METADATA_REF_HANDLER),
    DefunBlank(),
    //    DefunSizeInfo( ODBC_PARAMETER),
    //    DefunSizeInfo( ODBC_CONNECTION),
    //    DefunSizeInfo( ODBC_STATEMENT),
    {" </TABLE>",    0},

    {" <br> <DT> <b> Cache Related Objects </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( TS_DIRECTORY_HEADER),
    DefunSizeInfo( TS_DIRECTORY_INFO),
    DefunSizeInfo( TS_OPEN_FILE_INFO),
    DefunSizeInfo( TS_RESOURCE),
    DefunSizeInfo( TSVC_CACHE),
    //  DefunSizeInfo( CACHE_OBJECT),
    DefunSizeInfo( BLOB_HEADER),
    //  DefunSizeInfo( CACHE_TABLE),
    DefunSizeInfo( VIRTUAL_ROOT_MAPPING),
    // DefunSizeInfo( DIRECTORY_CACHING_INFO),
    DefunSizeInfo( TS_DIR_BUFFERS),
    {" </TABLE>",    0},

    {" <br> <DT> <b> ATQ - Scheduler - AllocCache </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( ATQ_STATISTICS),
    DefunSizeInfo( ATQ_ENDPOINT_INFO),
    DefunSizeInfo( ATQ_ENDPOINT_CONFIGURATION),
    DefunSizeInfo( ATQ_CONTEXT_PUBLIC),
    DefunBlank(),
    DefunSizeInfo( ALLOC_CACHE_CONFIGURATION),
    DefunSizeInfo( ALLOC_CACHE_HANDLER),
    {" </TABLE>",    0},

    {" <br> <DT> <b> IIS Management Objects </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( W3_CONFIG_INFO),
    DefunSizeInfo( FTP_CONFIG_INFO),
    {" </TABLE>",    0},

    {" <br> <DT> <b> W3 Server Related Items </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( W3_SERVER_INSTANCE),
    DefunSizeInfo( W3_SERVER_STATISTICS),
    DefunSizeInfo( W3_IIS_SERVICE),
    DefunSizeInfo( W3_METADATA),
    DefunSizeInfo( W3_URI_INFO),
    {" </TABLE>",    0},

    {" <br> <DT> <b> Client Connection Objects </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( CLIENT_CONN),
    DefunSizeInfo( HTTP_FILTER_DLL),
    DefunSizeInfo( HTTP_REQ_BASE),
    DefunSizeInfo( HTTP_REQUEST),
    DefunSizeInfo( DICTIONARY_MAPPER),
    DefunSizeInfo( HTTP_HEADER_MAPPER),
    DefunSizeInfo( HTTP_HEADERS),
    DefunSizeInfo( INETLOG_INFORMATION),
    {" </TABLE>",    0},

    {" <br> <DT> <b> ISAPI Application Objects </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( HSE_VERSION_INFO),
    DefunSizeInfo( HSE_TF_INFO),
    DefunSizeInfo( EXTENSION_CONTROL_BLOCK),
    DefunSizeInfo( WAM_REQUEST),
    DefunSizeInfo( WAM_EXEC_BASE),
    DefunSizeInfo( WAM_EXEC_INFO),
    DefunSizeInfo( HSE_BASE),
    DefunSizeInfo( HSE_APPDLL),
    DefunSizeInfo( SE_TABLE),
    {" </TABLE>",    0},

    {" <br> <DT> <b> ISAPI Filter Objects </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( HTTP_FILTER_DLL),
    DefunSizeInfo( HTTP_FILTER),
    DefunSizeInfo( FILTER_LIST),
    DefunSizeInfo( FILTER_POOL_ITEM),
    DefunSizeInfo( HTTP_FILTER_VERSION),
    DefunSizeInfo( HTTP_FILTER_CONTEXT ),
    DefunSizeInfo( HTTP_FILTER_RAW_DATA ),
    DefunSizeInfo( HTTP_FILTER_PREPROC_HEADERS ),
    DefunSizeInfo( HTTP_FILTER_AUTHENT ),
    DefunSizeInfo( HTTP_FILTER_AUTHENTEX ),
    DefunSizeInfo( HTTP_FILTER_ACCESS_DENIED ),
    DefunSizeInfo( HTTP_FILTER_LOG ),
    {" </TABLE>",    0},

#if 0
    {" <br> <DT> <b> IIS Certificate Wildcard Mapper </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( CStoreXBF),
    DefunSizeInfo( CPtrXBF),
    DefunSizeInfo( CAllocString),
    DefunSizeInfo( CBlob),
    DefunSizeInfo( CStrPtrXBF),
    DefunSizeInfo( CBlobXBF),
    DefunBlank(),
    DefunSizeInfo( MAP_ASN),
    DefunSizeInfo( MAP_FIELD),
    DefunSizeInfo( CDecodedCert),
    DefunSizeInfo( CIssuerStore),
    DefunSizeInfo( CCertGlobalRuleInfo),
    DefunSizeInfo( CCertMapRule),
    DefunSizeInfo( CIisRuleMapper),
    DefunSizeInfo( Cert_Map),
    DefunBlank(),
    DefunSizeInfo( IISMDB_Fields),
    DefunSizeInfo( IISMDB_HEntry),
    DefunSizeInfo( CIisAcctMapper),
    DefunSizeInfo( CCertMapping),
    DefunSizeInfo( CCert11Mapping),
    DefunSizeInfo( CItaMapping),
    DefunSizeInfo( CMd5Mapping),
    DefunBlank(),
    DefunSizeInfo( IssuerAccepted),
    DefunSizeInfo( MappingClass),
    DefunSizeInfo( CIisAcctMapper),
    DefunSizeInfo( CIisCertMapper),
    DefunSizeInfo( CIisCert11Mapper),
    DefunSizeInfo( CIisItaMapper),
    DefunSizeInfo( CIisMd5Mapper),
    {" </TABLE>",    0},
# endif // 0

    {" <br> <DT> <b> IIS Certificate Wildcard Mapper </b> <br>",    0},
    {" <TABLE BORDER>",    0},
    DefunSizeInfo( XAR),
    DefunSizeInfo( ADDRESS_CHECK),
    DefunSizeInfo( CSidCache),
    {" </TABLE>",    0},

    { " </DL>",                       0}      // sentinel element
};

# define MAX_SIZE_INFO   (sizeof(sg_rgSizeInfo) /sizeof(sg_rgSizeInfo[0]))



BOOL
SendSizeInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    char buff[MAX_SIZE_INFO*100];
    int i;
    DWORD cb = 0;

    for( i = 0; (i < MAX_SIZE_INFO) && (cb < sizeof(buff)); i++) {

        if ( sg_rgSizeInfo[i].cbSize == 0) {
            // special control formatting - echo the pszObject plainly.
            cb += wsprintf( buff + cb, sg_rgSizeInfo[i].pszObject);
        } else {
            cb += wsprintf( buff + cb, "<TR> <TD> %s</TD> <TD>%d</TD> </TR>",
                            sg_rgSizeInfo[i].pszObject,
                            sg_rgSizeInfo[i].cbSize
                            );
        }
    } // for

    return ( pecb->WriteClient( pecb->ConnID, buff, &cb, 0));
} // SendSizeInfo()



# define MAX_DUMP_INFO    (102400)

BOOL
GetProbeDumpAndSendInfo(
   IN EXTENSION_CONTROL_BLOCK * pecb,
   IN LPCSTR          pszModuleName,
   IN LPCSTR          pszFunctionName,
   IN LPCSTR          pszDumpMessage,
   IN BOOL            fReturnsBool
   )
/*++
  This function gets the function pointer for the dump function exported
  the module specified. It calls the dump function to generate the html dump.
  The generated html content is sent to the client using hte ECB provided.

  Arguments:
     pecb  - pointer to EXTENSION_CONTROL_BLOCK structure for talking to IIS.
     pszModuleName - pointer to ANSI string containing the module name
     pszFunctionName - pointer to string containing the function name
     pszDumpMessage - pointer to the dump message for this dump generated.
     fReturnsBool   - if TRUE indicates that the function pointer to be loaded
                          returns BOOL value
                      if FALSE indicates that the function pointer to be loaded
                          returns VOID
  Returns:
    TRUE on success and FALSE if there is any failure.

  Note: Even if the module does not exist, this function will send friendly
  error message. It returns FALSE only if send operation to client fails.
--*/
{
    HMODULE hModule;

    //
    // We use a stack buffer to store the dump information for transmission.
    //
    CHAR pchBuffer[MAX_DUMP_INFO];
    DWORD cchBuff = MAX_DUMP_INFO;
    DWORD cchUsed;

    //
    // Generate the dump header
    //
    cchUsed = wsprintf( pchBuffer,
                       " <hr> %s",
                       pszDumpMessage
                       );

    cchBuff = sizeof(pchBuffer) - cchUsed;

    //
    // Obtain the module name so that we can get the dump function address
    //

    hModule = GetModuleHandle( pszModuleName);
    if ( NULL != hModule) {

        BOOL  fDumpGenerated = FALSE;

        //
        // Get the dump function address for the function specified.
        //
        if ( fReturnsBool) {
            // Use the function pointer with return type BOOL

            PFNBoolProbeDumpFunction pfnProbeDump;
            pfnProbeDump =
                (PFNBoolProbeDumpFunction ) GetProcAddress( hModule,
                                                            pszFunctionName
                                                            );

            if ( NULL != pfnProbeDump) {

                //
                // Call the dump function and obtain the output
                // also require that the function succeeded
                //

                DBG_REQUIRE( (*pfnProbeDump)( pchBuffer + cchUsed, &cchBuff));
                fDumpGenerated = TRUE;
            }
        } else {

            // Use the function pointer with return type VOID

            PFNVoidProbeDumpFunction  pfnProbeDump;
            pfnProbeDump =
                (PFNVoidProbeDumpFunction ) GetProcAddress( hModule,
                                                            pszFunctionName
                                                            );
            if ( NULL != pfnProbeDump) {

                //
                // Call the dump function and obtain the output
                //

                (*pfnProbeDump)( pchBuffer + cchUsed, &cchBuff);
                fDumpGenerated = TRUE;
            }
        }

        if (!fDumpGenerated) {
            //
            // there was an error in loading the function address.
            // indicate failure
            //

            cchBuff = wsprintf( pchBuffer + cchUsed,
                                "<i> GetProcAddress( %s(%08x), %s) failed. "
                                "Error = %d </i> <br>"
                                ,
                                pszModuleName, hModule, pszFunctionName,
                                GetLastError()
                                );
        }
    } else {

        cchBuff = wsprintf( pchBuffer + cchUsed,
                            " <i> Module: %s is not loaded </i>"
                            ,
                            pszModuleName
                            );
    }

    cchBuff+= cchUsed;

    return ( pecb->WriteClient( pecb->ConnID, pchBuffer, &cchBuff, 0));
} // GetProbeDumpAndSendInfo()


inline BOOL
GetVoidDumpAndSendInfo(
   IN EXTENSION_CONTROL_BLOCK * pecb,
   IN LPCSTR          pszModuleName,
   IN LPCSTR          pszFunctionName,
   IN LPCSTR          pszDumpMessage
   )
{
    return ( GetProbeDumpAndSendInfo( pecb,
                                      pszModuleName,
                                      pszFunctionName,
                                      pszDumpMessage,
                                      FALSE          // return value is VOID
                                      )
             );
} // GetVoidDumpAndSendInfo()


inline BOOL
GetBoolDumpAndSendInfo(
   IN EXTENSION_CONTROL_BLOCK * pecb,
   IN LPCSTR          pszModuleName,
   IN LPCSTR          pszFunctionName,
   IN LPCSTR          pszDumpMessage
   )
{
    return ( GetProbeDumpAndSendInfo( pecb,
                                      pszModuleName,
                                      pszFunctionName,
                                      pszDumpMessage,
                                      TRUE          // return value is BOOL
                                      )
             );
} // GetBoolDumpAndSendInfo()





/************************************************************
 *   Worker functions that dump various information
 ************************************************************/

SendCacheCounterInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    static const char g_pszCacheCounterInfo[] =
        "<h3> Cache Aux Counters Information </h3> <br>"
        " Following is a dump of the private counters inside IIS file-handle"
        " cache. These counters are added to find numbers to track down"
        " some memory corruption and function call overhead information."
        " <br>"
        ;

    return ( GetVoidDumpAndSendInfo( pecb,
                                     "infocomm.dll",
                                     "TsDumpCacheCounters",
                                     g_pszCacheCounterInfo
                                     )
             );
} // SendCacheCounterInfo()


SendCacheInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    static const char g_pszCacheInfo[] =
        "<h3> IIS File-handle Cache Information </h3> <br>"
        " Following dump contains the internal state of the IIS file-handle"
        " hash table. It indicates what entries are present in what buckets."
        " <br>"
        ;

    return ( GetVoidDumpAndSendInfo( pecb,
                                     "infocomm.dll",
                                     "TsDumpCacheToHtml",
                                     g_pszCacheInfo
                                     )
             );
} // SendCacheInfo()



BOOL SendAllocCacheInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    static const char g_pszAllocCacheInfo[] =
        "<h3> Allocation Cache Information </h3> <br>"
        " Following dump contains the statistics for various objects using"
        " Allocation cache inside IIS. For each allocation cache object, the"
        " list contains the configuration used, total objects allocated and "
        " number of objects in free-list. It lists the number of calls for"
        " alloc and free operations. Finally it lists the amount of memory"
        " consumed by the objects in allocation cache storage."
        " <br>"
        ;

    return ( GetBoolDumpAndSendInfo( pecb,
                                     "iisrtl.dll",
                                     "AllocCacheDumpStatsToHtml",
                                     g_pszAllocCacheInfo
                                     )
             );
} // SendAllocCacheInfo()


BOOL SendWamInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    static const char g_pszWamTableInfo[] =
        "<h3> WAM Table Information </h3> <br>"
        " IIS 5.0 supports multiple application roots to be created. Each"
        " application root has a WAM instance for processing the requests"
        " for its instance. Following table summarizes the calls made to"
        " various instances current running inside IIS."
        " <br>"
        ;

    return ( GetBoolDumpAndSendInfo( pecb,
                                     "w3svc.dll",
                                     "WamDictatorDumpInfo",
                                     g_pszWamTableInfo
                                     )
             );
} // SendWamInfo()


BOOL SendAspInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    static const char g_pszAspInfo[] =
        "<h3> ASP Information </h3> <br>"
        " Gives a summary of all running ASP applications and internal state"
        " of the ASP.dll instance."
        " <p>"
        ;

    return ( GetBoolDumpAndSendInfo( pecb,
                                     "asp.dll",
                                     "AspStatusHtmlDump",
                                     g_pszAspInfo
                                     )
             );
} // SendAspInfo()

BOOL SendMemoryInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    static const char g_pszMemoryInfo[] =
        "<h3> Web server cache Information </h3> <br>"
        " <br>"
        "<br>"
        ;

    return ( GetVoidDumpAndSendInfo( pecb,
                                     "w3svc.dll",
                                     "DumpW3InfoToHTML",
                                     g_pszMemoryInfo
                                     )
             );

} // SendMemoryInfo()

BOOL SendHeapInfo( IN EXTENSION_CONTROL_BLOCK * pecb )
{
    if (IISGetPlatformType() == PtWindows95)
    {
        return SendHeapInfo95(pecb);
    }
    else
    {
        return SendHeapInfoNT(pecb);
    }
} // SendHeapInfo()


BOOL SendHeapInfoNT( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    static const char g_pszHeapInfo[] =
        "<hr> <h3> Heap Information </h3> <br>"
        " Following dump contains Heap related statistics for the current process (PID=%d)\n"
        " <p>"
        ;

    //
    // We use a stack buffer to store the dump information for transmission.
    //
    CHAR pchBuffer[MAX_DUMP_INFO];
    DWORD cchBuff = MAX_DUMP_INFO;
    DWORD cchUsed;
    DWORD i;
    BOOL fReturn = TRUE;

    //
    //  Generate the dump header with the ProcessId
    //
    cchUsed = wsprintf( pchBuffer,
                        g_pszHeapInfo,
                        GetCurrentProcessId()
                        );

    cchBuff = sizeof(pchBuffer) - cchUsed;

    if (!pecb->WriteClient( pecb->ConnID, pchBuffer, &cchUsed, 0)) {
        return ( FALSE);
    }


    //
    //  Get all the heap handles for the process
    //

# define MAX_PROCESS_HEAP_HANDLES   100
    PHANDLE  rghHeaps[MAX_PROCESS_HEAP_HANDLES];
    ZeroMemory( rghHeaps, sizeof( rghHeaps));

    DWORD nHeaps =
        GetProcessHeaps( sizeof( rghHeaps)/sizeof(rghHeaps[0]),
                         (PHANDLE )rghHeaps);

    if ( nHeaps > (sizeof( rghHeaps)/sizeof(rghHeaps[0]))) {

        cchUsed = wsprintf( pchBuffer,
                            " Number of Process Heaps Found(%d) is more than default(%d)<br>"
                            " Notify the author of IISProbe.dll to change the defaults<br>"
                            ,
                            nHeaps,
                            (sizeof( rghHeaps)/sizeof(rghHeaps[0]))
                            );

        return ( pecb->WriteClient( pecb->ConnID, pchBuffer, &cchUsed, 0));
    }

    //
    // Gather and Dump heap statistics information for each heap handle
    //

    {
        HEAP_STATS heapStatsTotal;
        HEAP_STATS heapStatsInstance;

        //
        // HEAP_BLOCK_STATS is huge - dynamically allocate the memory for the same.
        //

        HEAP_BLOCK_STATS * pheapBlockStats;
        HEAP_BLOCK_STATS * phbsTotal;

        pheapBlockStats = new HEAP_BLOCK_STATS();
        phbsTotal       = new HEAP_BLOCK_STATS;
        if ( (pheapBlockStats == NULL) || (phbsTotal == NULL)) {

            DBGPRINTF((DBG_CONTEXT, "Allocation of heap-enum-context failed\n"));

            if ( pheapBlockStats != NULL) {
                delete pheapBlockStats;
            }

            if ( phbsTotal != NULL) {
                delete phbsTotal;
            }

            return ( FALSE);
        }

        //
        // Dump the header information for heap statistics
        //

        cchUsed = 0;
        cchUsed += wsprintf( pchBuffer + cchUsed,
                             "<TABLE BORDER=1> "
                             " <TH> Heap @ </TH>"
                             " <TH> # Busy Blocks </TH>"
                             " <TH> # Busy Bytes </TH>"
                             " <TH> # Free Blocks </TH>"
                             " <TH> # Free Bytes </TH>"
                             "</TR>"
                             );

        //
        // enumerate through all heaps and obtain the statistics
        //

        for ( i = 0; (i < nHeaps) && (cchUsed < (sizeof(pchBuffer)-100)); i++) {

            DBG_ASSERT( rghHeaps[i] != NULL);

            //
            // initialize the statistics before load
            //
            pheapBlockStats->Reset();
            heapStatsInstance.Reset();

            //
            // Obtain block statistics
            //
            DBG_REQUIRE( pheapBlockStats->LoadHeapStats( rghHeaps[i]));

            //
            // Add block statistics to our cumulative counters and per-block statistics
            //

            (*phbsTotal) += (*pheapBlockStats);
            heapStatsInstance.ExtractStatsFromBlockStats( pheapBlockStats);
            heapStatsTotal += heapStatsInstance;

            //
            // Dump out the block statistics
            //

            cchUsed += wsprintf( pchBuffer + cchUsed,
                                 "<TR>"
                                 " <TD> Heap[%d] @0x%08x </TD>"
                                 "<TD>%d</TD> <TD>%d</TD>"
                                 "<TD>%d</TD> <TD>%d</TD>"
                                 "</TR>\n"
                                 ,
                                 i, rghHeaps[i],
                                 heapStatsInstance.m_BusyBlocks,
                                 heapStatsInstance.m_BusyBytes,
                                 heapStatsInstance.m_FreeBlocks,
                                 heapStatsInstance.m_FreeBytes
                                 );
        } // for

        //
        // dump the total for all heaps
        //

        if ( cchUsed < (sizeof(pchBuffer) - 100)) {

            if ( i != nHeaps ) {
                //
                // Not all heap information was dumped. Indicate to caler.
                //
                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "Only %d heaps out of %d heaps dumped <br>",
                                     i, nHeaps);
            }

            cchUsed += wsprintf( pchBuffer + cchUsed,
                                 "<TR>"
                                 " <TD> Total for all heaps </TD>"
                                 " <TD> %d </TD> <TD> %d </TD>"
                                 " <TD> %d </TD> <TD> %d </TD>"
                                 "</TR>\n"
                                 ,
                                 heapStatsTotal.m_BusyBlocks,
                                 heapStatsTotal.m_BusyBytes,
                                 heapStatsTotal.m_FreeBlocks,
                                 heapStatsTotal.m_FreeBytes
                                 );
        }

        cchUsed += wsprintf( pchBuffer + cchUsed, " </TABLE>\n");

        if (!pecb->WriteClient( pecb->ConnID, pchBuffer, &cchUsed, 0)) {
            fReturn = FALSE;
        }

        // ------------------------------------------------------------
        // Dump Block size information for all heaps
        // ------------------------------------------------------------

        //
        // Dump the header information for heap block statistics
        //

        cchUsed = 0;
        cchUsed += wsprintf( pchBuffer + cchUsed,
                             "<p> Per Block-Size Information for all Heap Blocks <p>"
                             "<TABLE BORDER=1> "
                             " <TH> BlockSize (bytes) </TH>"
                             " <TH> # Busy Blocks </TH>"
                             " <TH> # Busy Bytes </TH>"
                             " <TH> # Free Blocks </TH>"
                             " <TH> # Free Bytes </TH>"
                             "</TR>"
                             );

        //
        // enumerate through all block sizes in the phbsTotal and dump
        //

        for ( i = 0; (i < MAX_HEAP_BLOCK_SIZE) && (cchUsed < (sizeof(pchBuffer)-200)); i++) {

            if ( (phbsTotal->BusyCounters[i] != 0)  ||
                 (phbsTotal->FreeCounters[i] != 0) ) {
                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "<TR>"
                                     "<TD>%d</TD>"
                                     "<TD>%d</TD> <TD>%d</TD>"
                                     "<TD>%d</TD> <TD>%d</TD>"
                                     "</TR>\n"
                                     ,
                                     i,
                                     phbsTotal->BusyCounters[i],
                                     i * phbsTotal->BusyCounters[i],
                                     phbsTotal->FreeCounters[i],
                                     i * phbsTotal->FreeCounters[i]
                                     );
            }
        } // for


        //
        // dump the total for all heaps
        //

        if ( cchUsed < (sizeof(pchBuffer) - 200)) {

            if ( i != MAX_HEAP_BLOCK_SIZE ) {
                //
                // Not all heap information was dumped. Indicate to caler.
                //
                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "Only BlockSizes upto %d are dumped\n",
                                     i);
            } else {

                // dump Jumbo blocks information

                if ( (phbsTotal->BusyJumbo != 0)  ||
                     (phbsTotal->FreeJumbo != 0) ) {
                    cchUsed += wsprintf( pchBuffer + cchUsed,
                                         "<TR>"
                                         " <TD> JumboBlocks (> 64KB) </TD>"
                                         " <TD> %d </TD> <TD> %d </TD>"
                                         " <TD> %d </TD> <TD> %d </TD>"
                                         "</TR>\n"
                                         ,
                                         phbsTotal->BusyJumbo,
                                         phbsTotal->BusyJumboBytes,
                                         phbsTotal->FreeJumbo,
                                         phbsTotal->FreeJumboBytes
                                         );
                }

                // dump totals information
                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "<TR>"
                                     " <TD> <b>Total for all heaps</b> </TD>"
                                     " <TD> %d </TD> <TD> %d </TD>"
                                     " <TD> %d </TD> <TD> %d </TD>"
                                     "</TR>\n"
                                     ,
                                     heapStatsTotal.m_BusyBlocks,
                                     heapStatsTotal.m_BusyBytes,
                                     heapStatsTotal.m_FreeBlocks,
                                     heapStatsTotal.m_FreeBytes
                                     );
            }
        }

        cchUsed += wsprintf( pchBuffer + cchUsed, " </TABLE>\n");

        if (!pecb->WriteClient( pecb->ConnID, pchBuffer, &cchUsed, 0)) {
            fReturn = FALSE;
        }


        // freeup the dynamic memory blocks
        delete (pheapBlockStats);
        delete (phbsTotal);
    }

    // dump the output
    return ( fReturn );

} // SendHeapInfoNT()


BOOL SendHeapInfo95( IN EXTENSION_CONTROL_BLOCK * pecb)
{

    //
    // These pointers are declared because of the need to dynamically link to the
    // functions.  They are exported only by the Windows 95 kernel. Explicitly linking
    // to them will make this application unloadable in Microsoft(R) Windows NT(TM)
    // and will produce an ugly system dialog box.
    //

    static CREATESNAPSHOT pCreateToolhelp32Snapshot = NULL;
    static HEAPLISTWALK   pHeap32ListFirst          = NULL;
    static HEAPLISTWALK   pHeap32ListNext           = NULL;
    static HEAPBLOCKWALK  pHeap32First              = NULL;
    static HEAPBLOCKWALK  pHeap32Next               = NULL;

    static BOOL           fInitialized              = FALSE;

    if (!fInitialized)
    {
        // Initialize tool help functions.

        HMODULE hKernel = NULL;

        //
        // Obtain the module handle of the kernel to retrieve addresses of
        // the tool helper functions.
        //

        hKernel = GetModuleHandle("KERNEL32.DLL");

        if (hKernel)
        {
            pCreateToolhelp32Snapshot =
                (CREATESNAPSHOT)GetProcAddress(hKernel,
                "CreateToolhelp32Snapshot");

            pHeap32ListFirst  = (HEAPLISTWALK)GetProcAddress(hKernel,
                                "Heap32ListFirst");
            pHeap32ListNext   = (HEAPLISTWALK)GetProcAddress(hKernel,
                                "Heap32ListNext");

            pHeap32First      = (HEAPBLOCKWALK)GetProcAddress(hKernel,
                                "Heap32First");
            pHeap32Next       = (HEAPBLOCKWALK)GetProcAddress(hKernel,
                                "Heap32Next");

            //
            // All addresses must be non-NULL to be successful.
            //

            fInitialized =  pCreateToolhelp32Snapshot && pHeap32ListFirst
                            && pHeap32ListNext && pHeap32First && pHeap32Next;
        }
    }

    if (!fInitialized)
    {
        CHAR    pchError[] = "Unable to get Heap function pointers on Win95";
        DWORD   cchUsed    = strlen(pchError);

        if (!pecb->WriteClient( pecb->ConnID, pchError, &cchUsed, 0))
        {
            return FALSE;
        }

        return TRUE;
    }

    static const char g_pszHeapInfo[] =
        "<hr> <h3> Heap Information </h3> <br>"
        " Following dump contains Heap related statistics for the current process (PID=%u)\n"
        " <p>"
        ;
    //
    // We use a stack buffer to store the dump information for transmission.
    //

    CHAR pchBuffer[MAX_DUMP_INFO];
    DWORD cchBuff = MAX_DUMP_INFO;
    DWORD cchUsed;
    DWORD i;
    BOOL fReturn = TRUE;

    //
    //  Generate the dump header with the ProcessId
    //
    cchUsed = wsprintf( pchBuffer,
                        g_pszHeapInfo,
                        GetCurrentProcessId()
                        );

    cchBuff = sizeof(pchBuffer) - cchUsed;

    if (!pecb->WriteClient( pecb->ConnID, pchBuffer, &cchUsed, 0)) {
        return ( FALSE);
    }


    DWORD nHeaps = 0;

    //
    // Create the snapshot
    //

    HANDLE hProcessSnap = pCreateToolhelp32Snapshot(TH32CS_SNAPHEAPLIST , 0);

    if ( (HANDLE)-1 == hProcessSnap)
    {
        // Couldn't get snapshot

        CHAR    pchError[] = "Unable to create Heap List snapshot";
        DWORD   cchUsed    = strlen(pchError);

        if (!pecb->WriteClient( pecb->ConnID, pchError, &cchUsed, 0))
        {
            return FALSE;
        }

        return TRUE;
    }


    //
    // Gather and Dump heap statistics information for each heap handle
    //

    {
        HEAP_STATS heapStatsTotal;
        HEAP_STATS heapStatsInstance;

        //
        // HEAP_BLOCK_STATS is huge - dynamically allocate the memory for the same.
        //

        HEAP_BLOCK_STATS * pheapBlockStats;
        HEAP_BLOCK_STATS * phbsTotal;

        pheapBlockStats = new HEAP_BLOCK_STATS();
        phbsTotal       = new HEAP_BLOCK_STATS;

        if ( (pheapBlockStats == NULL) || (phbsTotal == NULL)) {

            DBGPRINTF((DBG_CONTEXT, "Allocation of heap-enum-context failed\n"));

            if ( pheapBlockStats != NULL) {
                delete pheapBlockStats;
            }

            if ( phbsTotal != NULL) {
                delete phbsTotal;
            }

            return ( FALSE);
        }

        //
        // Dump the header information for heap statistics
        //

        cchUsed = 0;
        cchUsed += wsprintf( pchBuffer + cchUsed,
                             "<TABLE BORDER=1> "
                             " <TH> Heap @ </TH>"
                             " <TH> # Busy Blocks </TH>"
                             " <TH> # Busy Bytes </TH>"
                             " <TH> # Free Blocks </TH>"
                             " <TH> # Free Bytes </TH>"
                             "</TR>"
                             );

        //
        // enumerate through all heaps and obtain the statistics
        //

        HEAPLIST32  hl32 = {0};
        hl32.dwSize = sizeof(HEAPLIST32);

        if ( pHeap32ListFirst(hProcessSnap, &hl32))
        {

            //
            // initialize the statistics before load
            //

            pheapBlockStats->Reset();
            heapStatsInstance.Reset();

            //
            // Obtain block statistics
            //

            DBG_REQUIRE( pheapBlockStats->LoadHeapStats(&hl32, pHeap32First, pHeap32Next));

            //
            // Add block statistics to our cumulative counters and per-block statistics
            //

            (*phbsTotal) += (*pheapBlockStats);
            heapStatsInstance.ExtractStatsFromBlockStats( pheapBlockStats);
            heapStatsTotal += heapStatsInstance;

            nHeaps++;

            //
            // Dump out the block statistics
            //

            cchUsed += wsprintf( pchBuffer + cchUsed,
                                 "<TR>"
                                 " <TD> Heap[%u] @0x%08x </TD>"
                                 "<TD>%u</TD> <TD>%u</TD>"
                                 "<TD>%u</TD> <TD>%u</TD>"
                                 "</TR>\n"
                                 ,
                                 nHeaps, hl32.th32HeapID,
                                 heapStatsInstance.m_BusyBlocks,
                                 heapStatsInstance.m_BusyBytes,
                                 heapStatsInstance.m_FreeBlocks,
                                 heapStatsInstance.m_FreeBytes
                                 );

            while ( (cchUsed < (sizeof(pchBuffer)-100)) &&
                     pHeap32ListNext(hProcessSnap, &hl32)
                  )
            {
                //
                // initialize the statistics before load
                //

                pheapBlockStats->Reset();
                heapStatsInstance.Reset();

                //
                // Obtain block statistics
                //

                DBG_REQUIRE( pheapBlockStats->LoadHeapStats(&hl32, pHeap32First, pHeap32Next));

                //
                // Add block statistics to our cumulative counters and per-block statistics
                //

                (*phbsTotal) += (*pheapBlockStats);
                heapStatsInstance.ExtractStatsFromBlockStats( pheapBlockStats);
                heapStatsTotal += heapStatsInstance;

                nHeaps++;

                //
                // Dump out the block statistics
                //

                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "<TR>"
                                     " <TD> Heap[%u] @0x%08x </TD>"
                                     "<TD>%u</TD> <TD>%u</TD>"
                                     "<TD>%u</TD> <TD>%u</TD>"
                                     "</TR>\n"
                                     ,
                                     nHeaps, hl32.th32HeapID,
                                     heapStatsInstance.m_BusyBlocks,
                                     heapStatsInstance.m_BusyBytes,
                                     heapStatsInstance.m_FreeBlocks,
                                     heapStatsInstance.m_FreeBytes
                                     );
            }
        }

        CloseHandle(hProcessSnap);

        //
        // dump the total for all heaps
        //

        if ( cchUsed > (sizeof(pchBuffer) -100) ) {
            //
            // Not all heap information was dumped. Indicate to caler.
            //
            cchUsed += wsprintf( pchBuffer + cchUsed,
                                 "Only %d heaps dumped <br>",
                                 nHeaps);
        }

        cchUsed += wsprintf( pchBuffer + cchUsed,
                             "<TR>"
                             " <TD> Total for all heaps </TD>"
                             " <TD> %u </TD> <TD> %u </TD>"
                             " <TD> %u </TD> <TD> %u </TD>"
                             "</TR>\n"
                             ,
                             heapStatsTotal.m_BusyBlocks,
                             heapStatsTotal.m_BusyBytes,
                             heapStatsTotal.m_FreeBlocks,
                             heapStatsTotal.m_FreeBytes
                             );

        cchUsed += wsprintf( pchBuffer + cchUsed, " </TABLE>\n");

        if (!pecb->WriteClient( pecb->ConnID, pchBuffer, &cchUsed, 0)) {
            fReturn = FALSE;
        }

        // ------------------------------------------------------------
        // Dump Block size information for all heaps
        // ------------------------------------------------------------

        //
        // Dump the header information for heap block statistics
        //

        cchUsed = 0;
        cchUsed += wsprintf( pchBuffer + cchUsed,
                             "<p> Per Block-Size Information for all Heap Blocks <p>"
                             "<TABLE BORDER=1> "
                             " <TH> BlockSize (bytes) </TH>"
                             " <TH> # Busy Blocks </TH>"
                             " <TH> # Busy Bytes </TH>"
                             " <TH> # Free Blocks </TH>"
                             " <TH> # Free Bytes </TH>"
                             "</TR>"
                             );

        //
        // enumerate through all block sizes in the phbsTotal and dump
        //

        for ( i = 0; (i < MAX_HEAP_BLOCK_SIZE) && (cchUsed < (sizeof(pchBuffer)-200)); i++) {

            if ( (phbsTotal->BusyCounters[i] != 0)  ||
                 (phbsTotal->FreeCounters[i] != 0) ) {
                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "<TR>"
                                     "<TD>%u</TD>"
                                     "<TD>%u</TD> <TD>%u</TD>"
                                     "<TD>%u</TD> <TD>%u</TD>"
                                     "</TR>\n"
                                     ,
                                     i,
                                     phbsTotal->BusyCounters[i],
                                     i * phbsTotal->BusyCounters[i],
                                     phbsTotal->FreeCounters[i],
                                     i * phbsTotal->FreeCounters[i]
                                     );
            }
        } // for


        //
        // dump the total for all heaps
        //

        if ( cchUsed < (sizeof(pchBuffer) - 200)) {

            if ( i != MAX_HEAP_BLOCK_SIZE ) {
                //
                // Not all heap information was dumped. Indicate to caler.
                //
                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "Only BlockSizes upto %d are dumped\n",
                                     i);
            } else {

                // dump Jumbo blocks information

                if ( (phbsTotal->BusyJumbo != 0)  ||
                     (phbsTotal->FreeJumbo != 0) ) {
                    cchUsed += wsprintf( pchBuffer + cchUsed,
                                         "<TR>"
                                         " <TD> JumboBlocks (> 64KB) </TD>"
                                         " <TD> %u </TD> <TD> %u </TD>"
                                         " <TD> %u </TD> <TD> %u </TD>"
                                         "</TR>\n"
                                         ,
                                         phbsTotal->BusyJumbo,
                                         phbsTotal->BusyJumboBytes,
                                         phbsTotal->FreeJumbo,
                                         phbsTotal->FreeJumboBytes
                                         );
                }

                // dump totals information
                cchUsed += wsprintf( pchBuffer + cchUsed,
                                     "<TR>"
                                     " <TD> <b>Total for all heaps</b> </TD>"
                                     " <TD> %u </TD> <TD> %u </TD>"
                                     " <TD> %u </TD> <TD> %u </TD>"
                                     "</TR>\n"
                                     ,
                                     heapStatsTotal.m_BusyBlocks,
                                     heapStatsTotal.m_BusyBytes,
                                     heapStatsTotal.m_FreeBlocks,
                                     heapStatsTotal.m_FreeBytes
                                     );
            }
        }

        cchUsed += wsprintf( pchBuffer + cchUsed, " </TABLE>\n");

        if (!pecb->WriteClient( pecb->ConnID, pchBuffer, &cchUsed, 0)) {
            fReturn = FALSE;
        }


        // freeup the dynamic memory blocks
        delete (pheapBlockStats);
        delete (phbsTotal);
    }

    // dump the output
    return ( fReturn );

} // SendHeapInfo95()



/************************************************************
 *  FAKE Functions
 *
 *  Fake the definitions of certain functions that belong only
 *   in the local compilation of w3svc & infocomm dlls
 *
 ************************************************************/

__int64
GetCurrentTimeInMilliseconds(
    VOID
    )
{ return (0); }



DWORD HASH_TABLE::CalculateHash( IN LPCSTR pszKey, IN DWORD cchKey) const
{ return ( 0); }
VOID HASH_TABLE::Cleanup( VOID) {}
HT_ELEMENT * HASH_TABLE::Lookup( IN LPCSTR pszKey, IN DWORD cchKey)
{ return ( NULL); }

DWORD
IIS_SERVER_INSTANCE::UpdateBindingsHelper(
                                          IN BOOL IsSecure
                                          )
{ return (NO_ERROR); }

DWORD
IIS_SERVER_INSTANCE::UnbindHelper(
                                  IN PLIST_ENTRY BindingListHead
                                  )
{ return ( NO_ERROR); }

BOOL IIS_SERVICE::LoadStr( OUT STR & str, IN  DWORD dwResId, IN BOOL fForceEnglish ) const
{ return ( TRUE); }

DWORD
IIS_SERVICE::UpdateServiceStatus(IN DWORD State,
                                IN DWORD Win32ExitCode,
                                IN DWORD CheckPoint,
                                IN DWORD WaitHint )
{ return ( NO_ERROR); }

BOOL   IIS_SERVICE::RemoveServerInstance(
                                         IN IIS_SERVER_INSTANCE * pInstance
                                         )
{ return ( FALSE); }


INET_PARSER::INET_PARSER( char * pszStart) {}
INET_PARSER::~INET_PARSER(VOID) {}

CHAR * INET_PARSER::AuxEatWhite(VOID) { return ( NULL); }
CHAR * INET_PARSER::AuxEatNonWhite(CHAR ch) { return ( NULL); }
CHAR * INET_PARSER::AuxSkipTo(CHAR ch) { return ( NULL); }

VOID INET_PARSER::TerminateToken( CHAR ch) {}
VOID INET_PARSER::RestoreToken( VOID ) {}
VOID INET_PARSER::TerminateLine( VOID ) {}
VOID INET_PARSER::RestoreLine( VOID ) {}
CHAR * INET_PARSER::NextToken( CHAR ) { return (NULL); }

AC_RESULT ADDRESS_CHECK::CheckName( LPSTR pName ) { return ( AC_NO_LIST); }
VOID TS_DIRECTORY_INFO::CleanupThis(VOID) {};
VOID * TCP_AUTHENT::QueryPrimaryToken(VOID) { return (NULL); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\samples\favlist\favlist.c ===
/*  favlist.c

    ??/??/95    jony    created
    12/01/95    sethp   use server support func for drop dir;
                fixed other problems
*/


#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "httpext.h"
#include "favlist.h"

void urlDecode(char *p);
int TwoHex2Int(char *pC);
void ReplaceSpace(char *pC);

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
{
  HINSTANCE hInst = GetModuleHandle("favlist.dll");
  char szFavoriteSite[MAX_PATH];

  pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

  LoadString(hInst, IDS_FAVORITE_SITE, szFavoriteSite, sizeof(szFavoriteSite));
  lstrcpyn( pVer->lpszExtensionDesc,
            szFavoriteSite,
            HSE_MAX_EXT_DLL_NAME_LEN );

  return TRUE;
}

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pEcb )
{            
    // first parse out the search string
    char* lpBuffer;
    char* lpBuffer2;
    char cPrintBuffer[2048];
    unsigned long ulCount;
    DWORD dwSize = 100;
    DWORD dwBytesRead;
    HANDLE hFile;
    char* lpAddress;
    char* lpDescription;
    char* lpUserName;
    int sLen = 0;
    char szDropFilePath[MAX_PATH];
    DWORD dwLen = MAX_PATH;
    char* cBuffer = (char*)malloc(pEcb->cbTotalBytes+1);
    DWORD dwS = HSE_STATUS_SUCCESS;
    DWORD dwFSize;
    HINSTANCE hInst = GetModuleHandle("favlist.dll");
    char szTmp[MAX_PATH*2];
    char szTmp2[MAX_PATH*2];

    if ( pEcb->cbTotalBytes < 2 )
    {
        LoadString(hInst, IDS_BAD_REQUEST, szTmp, sizeof(szTmp));
        if ( !pEcb->ServerSupportFunction(pEcb->ConnID,
                                    HSE_REQ_SEND_RESPONSE_HEADER,
                                    szTmp,
                                    NULL,
                                    NULL ) )
            dwS = HSE_STATUS_ERROR;
        dwS = HSE_STATUS_SUCCESS;
        goto ex;
    }

    memcpy(cBuffer, pEcb->lpbData, pEcb->cbTotalBytes );
    // delimit buffer
    *(cBuffer + pEcb->cbTotalBytes) = 0;
    urlDecode(cBuffer);

    // first parse off the data
    lpAddress = strtok(cBuffer, "&");
    lpDescription = strtok(NULL, "&");
    lpUserName = strtok(NULL, "&");

    LoadString(hInst, IDS_CONTENT_TYPE, cPrintBuffer, sizeof(cPrintBuffer));
    LoadString(hInst, IDS_200_OK, szTmp, sizeof(szTmp));

    if ( !lpAddress || !lpDescription || !lpUserName )
    {
        if ( !pEcb->ServerSupportFunction(pEcb->ConnID,
                                    HSE_REQ_SEND_RESPONSE_HEADER,
                                    szTmp,
                                    NULL,
                                    (LPDWORD) cPrintBuffer ) )
        {
            dwS = HSE_STATUS_ERROR;
            goto ex;
        }
        goto form_err;
    }

    lpAddress = strstr(lpAddress, "=");
    lpDescription = strstr(lpDescription, "=");
    lpUserName = strstr(lpUserName, "=");

    if ( !lpAddress || !lpDescription || !lpUserName )
    {
        if ( !pEcb->ServerSupportFunction(pEcb->ConnID,
                                    HSE_REQ_SEND_RESPONSE_HEADER,
                                    szTmp,
                                    NULL,
                                    (LPDWORD) cPrintBuffer ) )
        {
            dwS = HSE_STATUS_ERROR;
            goto ex;
        }
        goto form_err;
    }

    ++lpAddress;
    ++lpDescription;
    ++lpUserName;

    ReplaceSpace(lpAddress);
    ReplaceSpace(lpDescription);
    ReplaceSpace(lpUserName);

    if ( !pEcb->ServerSupportFunction(pEcb->ConnID,
                                HSE_REQ_SEND_RESPONSE_HEADER,
                                szTmp,
                                NULL,
                                (LPDWORD) cPrintBuffer ) )
    {
        dwS = HSE_STATUS_ERROR;
        goto ex;
    }

    LoadString(hInst, IDS_TITLE_MSG_1, szTmp, sizeof(szTmp));
    LoadString(hInst, IDS_TITLE_MSG_2, szTmp2, sizeof(szTmp2));
    ulCount = sprintf( cPrintBuffer,
        szTmp,
        szTmp2);

    if ( !pEcb->WriteClient( pEcb->ConnID,
                       cPrintBuffer,
                       &ulCount,
                       0 ) )
    {
        dwS = HSE_STATUS_ERROR;
        goto ex;
    }

    if ((!strcmp(lpAddress, "")) || (!strcmp(lpDescription, "")) || (!strcmp(lpUserName, "")))
        {
form_err:
        LoadString(hInst, IDS_ERROR_1, szTmp, sizeof(szTmp));
        ulCount=sprintf(cPrintBuffer, szTmp );
        if ( !pEcb->WriteClient( pEcb->ConnID,
                       cPrintBuffer,
                       &ulCount,
                       0 ) )
            dwS = HSE_STATUS_ERROR;
        else
            dwS = HSE_STATUS_SUCCESS;
        goto ex;
        }

    LoadString(hInst, IDS_THANK_YOU, szTmp, sizeof(szTmp));
    ulCount = sprintf( cPrintBuffer, szTmp);
    if ( !pEcb->WriteClient( pEcb->ConnID,
                       cPrintBuffer,
                       &ulCount,
                       0 ) )
    {
        dwS = HSE_STATUS_ERROR;
        goto ex;
    }

    // find file location by mapping the virtual path to a file path
    LoadString(hInst, IDS_DROP_HTM, szTmp, sizeof(szTmp));
    strcpy(szDropFilePath, szTmp);

    if ( !pEcb->ServerSupportFunction(pEcb->ConnID,
                                HSE_REQ_MAP_URL_TO_PATH,
                                szDropFilePath,
                                &dwLen,
                                NULL) )
    {
        dwS = HSE_STATUS_ERROR;
        goto ex;
    }

    // read in old file
    hFile = CreateFile( szDropFilePath, GENERIC_READ, FILE_SHARE_READ | 
            FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0L, NULL);
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        if ( (dwFSize = GetFileSize( hFile, NULL )) == 0xffffffff )
        {
            CloseHandle( hFile );
            hFile = INVALID_HANDLE_VALUE;
        }
        else
        {
            lpBuffer = (char*)VirtualAlloc(NULL, 
                    dwFSize+1024+strlen(lpAddress)*2
                        +strlen(lpDescription)+strlen(lpUserName), 
                    MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            lpBuffer2 = lpBuffer;

            if ( ReadFile(hFile, lpBuffer, dwFSize, &dwBytesRead, NULL) )
                lpBuffer[dwBytesRead] = '\0';
            else
                lpBuffer[0] = '\0';
            CloseHandle( hFile );
        }
    }
    
    // reopen for write with new info
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        hFile = CreateFile(szDropFilePath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, CREATE_ALWAYS, 0L, NULL);
    }
    if (hFile == INVALID_HANDLE_VALUE) // can't open the file for writing.
    {
        LoadString(hInst, IDS_CANNOT_OPEN, szTmp, sizeof(szTmp));
        ulCount = sprintf(cPrintBuffer, szTmp);
        if ( !pEcb->WriteClient( pEcb->ConnID,
                       cPrintBuffer,
                       &ulCount,
                       0 ) )
            dwS = HSE_STATUS_ERROR;
        goto ex;
    }
    
    LoadString(hInst, IDS_FONT, szTmp, sizeof(szTmp));
    lpBuffer2 = strstr(lpBuffer, szTmp);
    if (lpBuffer2 == NULL) 
    {
        LoadString(hInst, IDS_COULD_NOT_FIND_END_FILE, szTmp, sizeof(szTmp));
        ulCount = sprintf(cPrintBuffer, szTmp);
        if ( !pEcb->WriteClient( pEcb->ConnID,
               cPrintBuffer,
               &ulCount,
               0 ) )
        {
            dwS = HSE_STATUS_ERROR;
            goto ex;
        }
    }
    
    LoadString(hInst, IDS_DESCRIPTION, szTmp, sizeof(szTmp));
    sLen = sprintf( lpBuffer2, szTmp
        , lpAddress, lpAddress, lpDescription, lpUserName);

    WriteFile(hFile, lpBuffer, strlen(lpBuffer), &dwBytesRead, NULL);
    VirtualFree(lpBuffer, 0, MEM_DECOMMIT | MEM_RELEASE);
    CloseHandle(hFile);

ex:
    free(cBuffer);
    return dwS;
}

/*
 *  Decode the given string in-place by expanding %XX escapes
 */
void urlDecode(char *p) 
{
char *pD;

    pD = p;
    while (*p) {
        if (*p=='%') {
            /* Escape: next 2 chars are hex representation of the actual character */
            p++;
            if (isxdigit(p[0]) && isxdigit(p[1])) {
                *pD++ = (char) TwoHex2Int(p);
                p += 2;
            }
        } else {
            *pD++ = *p++;
        }
    }
    *pD = '\0';
}

/*
 *  The string starts with two hex characters.  Return an integer formed from them.
 */
int TwoHex2Int(char *pC) 
{
int Hi;
int Lo;
int Result;

    Hi = pC[0];
    if ('0'<=Hi && Hi<='9') {
        Hi -= '0';
    } else
    if ('a'<=Hi && Hi<='f') {
        Hi -= ('a'-10);
    } else
    if ('A'<=Hi && Hi<='F') {
        Hi -= ('A'-10);
    }
    Lo = pC[1];
    if ('0'<=Lo && Lo<='9') {
        Lo -= '0';
    } else
    if ('a'<=Lo && Lo<='f') {
        Lo -= ('a'-10);
    } else
    if ('A'<=Lo && Lo<='F') {
        Lo -= ('A'-10);
    }
    Result = Lo + 16*Hi;
    return Result;
}

void ReplaceSpace(char *pC)
{
    char* lppTemp;
    lppTemp = pC;
    while (*lppTemp)
    {
        if (*lppTemp == '+') *lppTemp = ' ';
        lppTemp++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\probe\iisprobe.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    iisprobe.cxx

Abstract:

    This module provides the entry point for probe functionality of 
     IIS

Author:

    Murali R. Krishnan (MuraliK)   16-July-1996

Revision History:
--*/

//
// Turn off dllexp so this DLL won't export tons of unnecessary garbage.
//

#ifdef dllexp
#undef dllexp
#endif
#define dllexp

# include <w3p.hxx>
# include "iisprobe.hxx"


DECLARE_DEBUG_PRINTS_OBJECT();


/************************************************************
 *   IIS Probe - inline documentation

 IIS Probe is a custom ISAPI DLL that links with several IIS DLLs directly. 
 It is an attempt to hook up with some internal data gathering functions in 
 IIS and hence collect probe data for further analysis. IIS Probe collects
 following information today: 
   1) IIS File Hash table configuration and usage
   2) IIS Allocation Cache Data
   3) WAM statistics for multiple instances
   4) Object Sizes (static) for various IIS objects

 IIS probe, being an ISAPI dll can be accessed remotely from any browser and
 also supplies dynamic data without much overhead. 
 
 
 Install iisprobe.dll by just copying it to any directory marked with
  execute permission. 
 For example:
   Copy it to the /scripts directory.
   Access it via the browser by typing
       http:.//<machine-name>/scripts/iisprobe.dll?
        and follow the instructions in menu persented.
 ************************************************************/


BOOL ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb);


DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    BOOL fReturn = TRUE;
    char buff[2048];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

    wsprintf( buff,
              "Content-Type: text/html\r\n"
              "\r\n"
              "<head><title>IIS Probe Page</title></head>\n"
              "<body> This page contains diagnostic information"
              " useful for development - for IIS 4.0 & beyond </body>\n"
              "<p>"
              "<p>"
              );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       NULL,
                                       (LPDWORD) buff )
         ) {
        return HSE_STATUS_ERROR;
    }

    fReturn = ParseAndDispatch( pecb);

    // add to this list when we add more probes here

    return (fReturn ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);

} // HttpExtensionProc()

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( HSE_VERSION_MAJOR, 
                                         HSE_VERSION_MINOR);
    strcpy( pver->lpszExtensionDesc,
            "IIS Probe Application" );

    return TRUE;
}


BOOL
SendAllInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    return ( SendCacheInfo( pecb)       &&
             SendSizeInfo( pecb)        &&
             SendAllocCacheInfo( pecb)  &&
             SendWamInfo( pecb)         &&
             SendAspInfo( pecb)         &&
             SendCacheCounterInfo( pecb)
             );
} // SendAllInfo()


const char * g_pszUsage = 
" <TITLE> IIS Probe Application </TITLE> "
" <HTML> <h2> List of options </h2> "
" <UL> "
" <LI> <A HREF=iisprobe.dll?Usage> Usage Information</A> - this menu"
" <LI> <A HREF=iisprobe.dll?All> Send All Information </A>"
" </UL>"
" <br> <UL>"
" <LI> <A HREF=iisprobe.dll?obj> Size of IIS internal Objects </A>"
" <LI> <A HREF=iisprobe.dll?alloccache> IIS Allocation Cache </A>"
" <LI> <A HREF=iisprobe.dll?wam> WAM Information </A>"
" <LI> <A HREF=iisprobe.dll?asp> ASP Information </A>"
" <LI> <A HREF=iisprobe.dll?ctable> IIS Cache Table State </A>"
" <LI> <A HREF=iisprobe.dll?cctr> IIS Cache Counters </A>"
" </UL>"
" </HTML>"
;

BOOL
SendUsage( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    DWORD cbBuff = strlen( g_pszUsage);

    return ( pecb->WriteClient( pecb->ConnID, (PVOID ) g_pszUsage,
                                &cbBuff, 0)
             );
} // SendUsage()



BOOL
ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    BOOL fReturn = FALSE;

    if ( pecb == NULL) { 
        return ( FALSE);
    }
    
    if ( (pecb->lpszQueryString == NULL) || (*pecb->lpszQueryString == '\0')) {

        return ( SendUsage( pecb));
    }

    switch ( *pecb->lpszQueryString ) {

    case 'a': case 'A': 
        if ( _stricmp( pecb->lpszQueryString, "All") == 0) {
            fReturn = SendAllInfo( pecb);
        } else if ( _stricmp( pecb->lpszQueryString, "alloccache") == 0) {
            fReturn = SendAllocCacheInfo( pecb);
        } else if ( _stricmp( pecb->lpszQueryString, "asp") == 0) {
            fReturn = SendAspInfo( pecb);
        }

        break;

    case 'c': case 'C':
        if ( _stricmp( pecb->lpszQueryString, "cctr") == 0) {
            fReturn = SendCacheCounterInfo( pecb);
        } else if ( _stricmp( pecb->lpszQueryString, "ctable") == 0) {
            fReturn = SendCacheInfo( pecb);
        } 

        break;

    case 'o': case 'O':
        if ( _stricmp( pecb->lpszQueryString, "obj") == 0) {
            fReturn = SendSizeInfo( pecb);
        } 

        break;

    case 'w': case 'W':
        if ( _stricmp( pecb->lpszQueryString, "wam") == 0) {
            fReturn = SendWamInfo( pecb);
        } 

        break;

    case 'u': case 'U': 
    default:
        if ( _stricmp( pecb->lpszQueryString, "Usage") == 0) {
            fReturn = SendUsage( pecb);
        } 

        break;
    } // switch()

    return ( fReturn);
} // ParseAndDispatch()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\probe\main.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    This module provides the entry point for probe functionality of IIS

Author:

    Murali R. Krishnan (MuraliK)   16-July-1996

Revision History:
--*/

//
// Turn off dllexp so this DLL won't export tons of unnecessary garbage.
//

#ifdef dllexp
#undef dllexp
#endif
#define dllexp

# include "iisprobe.hxx"
#include <time.h>


DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisProbeGuid, 
0x784d891B, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

/************************************************************
 *   IIS Probe - inline documentation

 IIS Probe is a custom ISAPI DLL that links with several IIS DLLs directly.
 It is an attempt to hook up with some internal data gathering functions in
 IIS and hence collect probe data for further analysis. IIS Probe collects
 following information today:
   1) IIS File Hash table configuration and usage
   2) IIS Allocation Cache Data
   3) WAM statistics for multiple instances
   4) Object Sizes (static) for various IIS objects
   5) Win32 Heap information for the process

 IIS probe, being an ISAPI dll can be accessed remotely from any browser and
 also supplies dynamic data without much overhead.


 Install iisprobe.dll by just copying it to any directory marked with
  execute permission.
 For example:
   Copy it to the /scripts directory.
   Access it via the browser by typing
       http:.//<machine-name>/scripts/iisprobe.dll?
        and follow the instructions in menu persented.
 ************************************************************/


BOOL ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb);


DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    BOOL fReturn = TRUE;
	DWORD dwSizeOfTitle;
    char buff[2048];

    //
    //  Note the HTTP header block is terminated by a blank '\r\n' pair,
    //  followed by the document body
    //

	time_t tmNow;
	time(&tmNow);

    wsprintf( buff,
              "Content-Type: text/html\r\n"
              "\r\n"
              );

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       NULL,
                                       (LPDWORD) buff )
         ) {
        return HSE_STATUS_ERROR;
    }

    wsprintf( buff,
              "<html>\n"
              "<head><title>IIS Probe Page</title></head>\n"
              "<body> This page contains diagnostic information"
              " useful for development - for IIS 5.0 & beyond </body>\n"
              "<p>%s\n"
              "<p>\n",
              ctime(&tmNow)
              );

	
	dwSizeOfTitle = strlen(buff);

    if  (! pecb->WriteClient( pecb->ConnID, (PVOID) buff, &dwSizeOfTitle, 0))
	{
        return HSE_STATUS_ERROR;
	}


    fReturn = ParseAndDispatch( pecb);

    // add to this list when we add more probes here

    return (fReturn ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);

} // HttpExtensionProc()


BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( HSE_VERSION_MAJOR,
                                         HSE_VERSION_MINOR);
    strcpy( pver->lpszExtensionDesc,
            "IIS Probe Application" );

    return TRUE;
}


BOOL
SendAllInfo( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    return ( SendMemoryInfo       ( pecb) &&
             SendCacheInfo        ( pecb) &&
             SendSizeInfo         ( pecb) &&
             SendAllocCacheInfo   ( pecb) &&
             SendHeapInfo         ( pecb) &&
             SendWamInfo          ( pecb) &&
             SendAspInfo          ( pecb) &&
             SendCacheCounterInfo ( pecb)
             );
} // SendAllInfo()


const char * g_pszUsage =
"<h2> List of Options </h2>\n"
"<UL> \n"
"  <LI> <A HREF=iisprobe.dll?Usage> Usage Information</A> - this menu\n"
"  <LI> <A HREF=iisprobe.dll?All> Send All Information </A>\n"
"</UL>\n"
"<br>\n"
"<UL>\n"
"  <LI> <A HREF=iisprobe.dll?memory> Web server cache usage </A>\n"
"  <LI> <A HREF=iisprobe.dll?obj> Size of IIS internal Objects </A>\n"
"  <LI> <A HREF=iisprobe.dll?heap> Process Heap Information </A>\n"
"  <LI> <A HREF=iisprobe.dll?alloccache> IIS Allocation Cache </A>\n"
"</UL>\n"
"<br>\n"
"<UL>\n"
"  <LI> <A HREF=iisprobe.dll?wam> WAM Information </A>\n"
"  <LI> <A HREF=iisprobe.dll?asp> ASP Information </A>\n"
"  <LI> <A HREF=iisprobe.dll?ctable> IIS Cache Table State </A>\n"
"  <LI> <A HREF=iisprobe.dll?cctr> IIS Cache Counters </A>\n"
"</UL>\n"
;

BOOL
SendUsage( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    DWORD cbBuff = strlen( g_pszUsage);

    return ( pecb->WriteClient( pecb->ConnID, (PVOID) g_pszUsage, &cbBuff, 0));
} // SendUsage()


const char* g_pszTail =
"</BODY>\n"
"</HTML>\n"
;

BOOL
SendTail( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    DWORD cbBuff = strlen( g_pszTail);

    return ( pecb->WriteClient( pecb->ConnID, (PVOID ) g_pszTail, &cbBuff, 0));
} // SendTail()


BOOL
ParseAndDispatch( IN EXTENSION_CONTROL_BLOCK * pecb)
{
    BOOL fReturn = FALSE;

    if ( pecb == NULL) {
        return ( FALSE);
    }

    if ( (pecb->lpszQueryString == NULL) || (*pecb->lpszQueryString == '\0')) {

        return ( SendUsage( pecb)  &&  SendTail(pecb));
    }

    switch ( *pecb->lpszQueryString ) {

    case 'a': case 'A':
        if ( _stricmp( pecb->lpszQueryString, "All") == 0) {
            fReturn = SendAllInfo( pecb);
        } else if ( _stricmp( pecb->lpszQueryString, "alloccache") == 0) {
            fReturn = SendAllocCacheInfo( pecb);
        } else if ( _stricmp( pecb->lpszQueryString, "asp") == 0) {
            fReturn = SendAspInfo( pecb);
        }

        break;

    case 'c': case 'C':
        if ( _stricmp( pecb->lpszQueryString, "cctr") == 0) {
            fReturn = SendCacheCounterInfo( pecb);
        } else if ( _stricmp( pecb->lpszQueryString, "ctable") == 0) {
            fReturn = SendCacheInfo( pecb);
        }

        break;

    case 'h': case 'H':
        if ( _stricmp( pecb->lpszQueryString, "heap") == 0) {
            fReturn = SendHeapInfo( pecb);
        }

        break;

    case 'm': case 'M':
        if ( _stricmp( pecb->lpszQueryString, "memory") == 0) {
            fReturn = SendMemoryInfo( pecb);
        }

        break;

    case 'o': case 'O':
        if ( _stricmp( pecb->lpszQueryString, "obj") == 0) {
            fReturn = SendSizeInfo( pecb);
        }

        break;

    case 'w': case 'W':
        if ( _stricmp( pecb->lpszQueryString, "wam") == 0) {
            fReturn = SendWamInfo( pecb);
        }

        break;

    case 'u': case 'U':
    default:
        if ( _stricmp( pecb->lpszQueryString, "Usage") == 0) {
            fReturn = SendUsage( pecb);
        }

        break;
    } // switch()

    if (fReturn) {
        fReturn = SendTail(pecb);
    }
    
    return ( fReturn);
} // ParseAndDispatch()



extern "C" BOOL WINAPI 
DllMain( 
    HANDLE hModule, 
    DWORD dwReason, 
    LPVOID 
    )
/*++

Routine Description:

    DLL init/terminate notification function

Arguments:

    hModule  - DLL handle
    dwReason - notification type
    LPVOID   - not used

Returns:

    TRUE if success, FALSE if failure

--*/
{
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
#ifdef _NO_TRACING_
            SET_DEBUG_FLAGS(DEBUG_ERROR);
            CREATE_DEBUG_PRINT_OBJECT("iisprobe");
#else
            CREATE_DEBUG_PRINT_OBJECT("iisprobe", IisProbeGuid);
#endif
            if (!VALID_DEBUG_PRINT_OBJECT()) {
                return (FALSE);
            }
            break;

        case DLL_PROCESS_DETACH:
            DELETE_DEBUG_PRINT_OBJECT();
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\samples\srch\srch.cpp ===
/*	srch.cpp

	??/??/95	jony	created
	12/01/95	sethp	use server support func for dir to
				search; fixed other problems
*/


#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "httpext.h"
#include "srch.h"	


// constructor
CSrch::CSrch(char* cData, EXTENSION_CONTROL_BLOCK* pEcb)
{
	char pErrCond[] = "Hjcsbmubs!Ufbn!Nfncfst";
	bUseCase = TRUE;
	bOverflow = FALSE;
	bErr = FALSE;
	bHitSomething = FALSE;
	sCounter = 0;
	sHitCount = -1;
	sPageCount = 0;
	
	strcpy(pszAlias, "");

// swap '+' to ' ' (put the space char back in)
// this gets substituted by WWW server
	char* pData = cData;
	while (*pData)
		{
		if ((*pData == 0x0D) || (*pData == 0x0A)) *pData = '\0';
		pData++;
		}

	pData = cData;
	while (*pData)
		{
		if (*pData == '+') *pData = ' ';
		pData++;
		}

	pExtContext = pEcb;
	DecodeHex(cData);
	if (strstr(cData, Substitutec(pErrCond)) != NULL) bErr = TRUE;
	strncpy(cBuffer, cData, 1024);

	wsprintf(cPrintBuffer,"Content-Type: text/html\r\n"
		"\r\n"
             	"<head>"
		"<title>Search Results</title></head>"
        "<BODY BACKGROUND=\"/samples/images/backgrnd.gif\">"
        "<BODY BGCOLOR=\"FFFFFF\">"
        "<TABLE>"
        "<TR>"
        "<TD><IMG SRC=\"/samples/images/SPACE.gif\" ALIGN=\"top\" ALT=\" \"></TD>"
        "<TD><A HREF=\"/samples/images/p_mh.map\"><IMG SRC=\"/samples/images/p_mh.gif\" ismap ALIGN=\"top\" ALT=\" \" BORDER=0></A></TD>"
        "</TR>"
        "<tr>"
        "<TD></TD>\n"
	    "<TD>"
		"<hr>"
		"<H2><p align=center>Simple Text Search</H2><p>"
		"<p align=center>Search string - %s<p>"
		"<p><hr>",
		cData);

	pEcb->ServerSupportFunction(pEcb->ConnID,
                                HSE_REQ_SEND_RESPONSE_HEADER,
                                "200 OK",
                                NULL,
                                (LPDWORD) cPrintBuffer );

	cParsedData = _strupr(cData);
}

// destructor
CSrch::~CSrch()
{					
	unsigned long ulCount;
	char pErrStr[] =
"=DFOUFS?K!Bmmbse=CS?Hsfh!Bmmfo=CS?Qbusjdjb!Bmwbsf{.Boesbef=CS?Npitjo!Binfe=CS?Nb"
"ebo!Bqqjbi=CS?Tboez!Bsuivs=CS?Fsoftu!Bzefmpuuf=CS?Tbnjub!Cbim=CS?Mboj!Cfsujop=CS"
"?Disjt!Cmboupo=CS?Nbsl!Cspxo=CS?Ljn!Cvsu=CS?Dbsm!Dbmwfmmp=CS?Uipnbt!B/!Dbsfz=CS?"
"Qijmjqqf!Diprvjfs=CS?Joft!Dpmmb{p=CS?Tpqijb!Divoh=CS?Tveiffs!Eivmjqbmmb=CS?Qbvm!"
"Epoofmmz=CS?Spcjo!Epxojf=CS?Nbsujo!Gfsoboef{=CS?Dbnfspo!Gfsspoj=CS?Dsbjh!Gjfcjh="
"CS?Sjdibse!Gjsui=CS?Cjmm!Hbuft=CS?Lzmf!Hfjhfs=CS?Kbnft!Hjmspz=CS?Upoz!Hpegsfz=CS"
"?Gmpsb!Hpmeuixbjuf=CS?Csjbo!Hspui=CS?Mff!Ibsu=CS?Epvhmbt!Ifcfouibm=CS?Lfo!Ijbuu="
"CS?Disjtujob!Ip=CS?Kfgg!Ipxbse=CS?Nbsl!Johbmmt=CS?Qbmjuib!Kbzbtjohif=CS?Dvsu!Kpi"
"otpo=CS?Kpobuibo!Lbvggnbo=CS?Nvsbmj!Lsjtiobo=CS?Exjhiu!Lspttb=CS?Ufsfodf!Lxbo=CS"
"?Lfwjo!Mbncsjhiu=CS?Kpio!Mvefnbo=CS?Ebwf!Nbmdpmn=CS?Spczo!Nbttfz=CS?Sjdl!Nbz=CS?"
"Spo!Nfjkfs=CS?B{gbs!Npb{{bn=CS?Lfjui!Nppsf=CS?Mpsfo!Nppsf=CS?Tubo!Nvsbxtlj=CS?Sp"
"o!Nvssbz=CS?Kbnft!Pmeibn=CS?Qfuf!Ptufotpo=CS?Tbn!Qbuupo=CS?Tfui!Qpmmbdl=CS?Mpsj!"
"Spcjotpo=CS?Cpojub!Tbshfbou=CS?Lfssz!Tdixbsu{=CS?Dbspmzo!Tffmfz=CS?Ljn!Tufccfot="
"CS?Njdibfm!Uipnbt=CS?Ebwje!Usfbexfmm=CS?Tvf!Uvsofs=CS?Csvdf!Xjmmjbnt=CS?Kjn!Zbhf"
"mpxjdi=CS?Kpooz!Zfbshfst=CS?=0DFOUFS?";

	if (bOverflow)
	{
		char pTemp[] = "<p><b>The search criteria returned > 255 hits. Please narrow your search value down and retry.</b><p>";

		ulCount = sizeof(pTemp);
    	pExtContext->WriteClient( pExtContext->ConnID,
        	               pTemp,
            	           &ulCount,
                	       0 );


// clean up the allocated memory
		short sCount;	
		for (sCount = 0; sCount <= sHitCount; sCount++)
			{
			if (sHitStruct[sCount].cHREF != NULL)
				free((LPVOID)sHitStruct[sCount].cHREF);
			}

	
	}

    else if (!bHitSomething)
	{
		if (bErr)
		{
			ulCount = sizeof(pErrStr);
    			pExtContext->WriteClient( pExtContext->ConnID,
        			Substitutec(pErrStr),
            			&ulCount,
                		0 );

		}
		else
		{
			char pTemp[] = "<p><b>No hits found.</b><p></body>";
			ulCount = sizeof(pTemp);
    			pExtContext->WriteClient( pExtContext->ConnID,
        			pTemp,
            			&ulCount,
                		0 );
		}

	}
	else
	{
		Sort();
		short sCount;	
		for (sCount = 0; sCount <= sHitCount; sCount++)
			{
					// hardwired to only work for
					// the "/" virtual root
			ulCount = wsprintf(cPrintBuffer,
				"<a href=/%s>/%s</a> - %d hit(s)<p>",
				sHitStruct[sCount].cHREF,
				sHitStruct[sCount].cHREF,
				sHitStruct[sCount].sHits);

			if (sHitStruct[sCount].cHREF != NULL)
				free((LPVOID)sHitStruct[sCount].cHREF);
						
    		pExtContext->WriteClient( pExtContext->ConnID,
        		               cPrintBuffer,
            		           &ulCount,
                		       0 );

			}
			ulCount = wsprintf(cPrintBuffer,"<p><p>"
			"<p><b>%d hit(s) found on %d page(s).</b><p>"
			,
			sCounter, sPageCount);
	   		pExtContext->WriteClient( pExtContext->ConnID,
	       		               cPrintBuffer,
	           		           &ulCount,
	               		       0 );

		}
    ulCount=wsprintf(cPrintBuffer, "</td></tr></table></body></html>");
    pExtContext->WriteClient( pExtContext->ConnID,
        	               cPrintBuffer,
            	           &ulCount,
                	       0 );


}

// substitute
char* CSrch::Substitutec(LPSTR lpSubstIn)
{
	char	*temp;
	
	temp = lpSubstIn;

	while (*temp)
	{
		*temp = (*temp) - 1;
		temp++;
	}
	
	return lpSubstIn;
}

// selection sort
void CSrch::Sort()
{
    short sCurrent,sCompare,sMax;

    for (sCurrent = 0; sCurrent <= sHitCount; sCurrent++)
            {
            sMax = sCurrent;
            for (sCompare = (sCurrent + 1); sCompare <= sHitCount; sCompare++)
                    if (sHitStruct[sCompare].sHits > sHitStruct[sMax].sHits) sMax = sCompare;

			Swap(sCurrent, sMax);
            }
}

// swap locations of minimum value and current
void CSrch::Swap(short sCurrent,short sMax)
{
    sSwap.sHits = sHitStruct[sMax].sHits;
    sHitStruct[sMax].sHits = sHitStruct[sCurrent].sHits;
   	sHitStruct[sCurrent].sHits = sSwap.sHits;

    sSwap.cHREF = sHitStruct[sMax].cHREF;
    sHitStruct[sMax].cHREF = sHitStruct[sCurrent].cHREF;
   	sHitStruct[sCurrent].cHREF = sSwap.cHREF;

}

// version information
BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
{
  pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

  lstrcpyn( pVer->lpszExtensionDesc,
            "Simple Search Example ISAPI App",
            HSE_MAX_EXT_DLL_NAME_LEN );

  return TRUE;
}

// DLL Entry point
DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pEcb )
{
// first parse out the search string
	char* cData;
	char* cBuffer = (char*)malloc(pEcb->cbAvailable + sizeof(char));

	wsprintf(cBuffer,"%s", pEcb->lpbData);
	cData = strstr(cBuffer,"=");
	cData++;

	CSrch* cHTTPIn = new CSrch(cData, pEcb);

// get the (main) web tree location by calling a server support func

	char szSetDir[MAX_PATH];
	DWORD dwLen = MAX_PATH;

		// hardcode to search the "/" virtual root for now.
		// possible future improvement: search all virtual
		// roots in this server set for read access.
	strcpy(szSetDir, "/");

	pEcb->ServerSupportFunction(pEcb->ConnID,
                                HSE_REQ_MAP_URL_TO_PATH,
                                szSetDir,
                                &dwLen,
                                NULL);

	SetCurrentDirectory(szSetDir);
							
	cHTTPIn->cStartDir = szSetDir;
						
	DWORD dwSize = 100;
							
  	pEcb->GetServerVariable(pEcb->ConnID, "QUERY_STRING", cHTTPIn->pszAlias, &dwSize);

 	cHTTPIn->ListDirectoryContents(szSetDir, "*.htm", cHTTPIn->cParsedData);
		
// clean up before we get run again.
	free(cBuffer);
	delete cHTTPIn;

	return HSE_STATUS_SUCCESS;
}


	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\samples\srch\srchx.cpp ===
/*	srchx.cpp

	??/??/95	jony	created
	12/03/95	sethp	fixed problems
*/

#include <windows.h>
#include <iostream.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "httpext.h"
#include "Srch.h"
					   
// This opens each file and looks for the search info
void CSrch::PrintFindData(WIN32_FIND_DATA *findData, char *findmask)
{
   	char *pszFilename;
   	char cFullname[256];

	GetFullPathName(findData->cFileName, 256, cFullname, &pszFilename);

	FILE *hFile;
	char* pszFileInput = (char*)malloc(256);
	BOOL bTrigger1 = FALSE;

   	if( (hFile = fopen( cFullname, "r" )) != NULL )
   		{				
    	while ( fgets( pszFileInput, 256, hFile ) != NULL)
        	{
			_strupr(pszFileInput);	
			if (strstr(pszFileInput, findmask) != NULL)
				{
				if (!bTrigger1) 
					{
					sHitCount++;
					sHitStruct[sHitCount].sHits = 0;
					sHitStruct[sHitCount].cHREF = (char*)calloc(256, sizeof(char));	
					if (sHitStruct[sHitCount].cHREF == NULL) break;
					
					strcpy(sHitStruct[sHitCount].cHREF,
						 Substituteb(cFullname + strlen(cStartDir)));

					bTrigger1 = TRUE;
					sPageCount++;
					}

				sHitStruct[sHitCount].sHits++; 
						  
				bHitSomething = TRUE; 
				sCounter++;
				if (sCounter > 255)
					{
					bOverflow = TRUE;
					break;
					}
				}
			}		   
      	fclose( hFile );
   		}
	
	free(pszFileInput);

}

// This fn will change a UNC path into a WWW path
const char* CSrch::Substituteb(LPSTR lpSubstIn)
{
	char* cTemp;
	cTemp = lpSubstIn;

	while(*cTemp)
		{
		if (*cTemp == '\\') *cTemp = '/';
		cTemp++;
		}

	return lpSubstIn;

}


// recursive directory scanner. 
void CSrch::ListDirectoryContents( char *dirname, char *filemask, char *findmask)
{
	if(bOverflow) return;

    char *pszFilename;
    char cCurdir[256];
    char cFullname[256];
    HANDLE hFile;
    WIN32_FIND_DATA findData;
    
    if (!GetCurrentDirectory(256, cCurdir)) return;

    if (strcmp(dirname, ".") && strcmp (dirname, ".."))
            {
            if (!SetCurrentDirectory(dirname)) return;
            }

    else return;

    if (!GetFullPathName(filemask, 256, cFullname, &pszFilename)) return;
  
    if (sCounter > 255) 
    	{
		bOverflow = TRUE;
		return;
		
		}

    hFile = FindFirstFile( filemask, &findData);
    while (hFile != INVALID_HANDLE_VALUE)
            {
            PrintFindData(&findData, findmask);
			
            if (!FindNextFile(hFile, &findData) ) break;
            }

    FindClose(hFile);
	
	hFile = FindFirstFile( "*.*", &findData);
    while (hFile != INVALID_HANDLE_VALUE)
            {
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                    ListDirectoryContents(findData.cFileName, filemask, findmask);
                    }

            if (!FindNextFile(hFile, &findData) ) break;
            }

    FindClose(hFile);

    SetCurrentDirectory(cCurdir);
}


// converts a two digit hex value into an int.
int CSrch::Hex2Int(char *pC) 
{
	int Hi;
	int Lo;
	int Result;

    Hi = pC[0];
    if ('0'<=Hi && Hi<='9') 		Hi -= '0';

    else if ('a'<=Hi && Hi<='f') 	Hi -= ('a'-10);
        
    else if ('A'<=Hi && Hi<='F') 	Hi -= ('A'-10);
        
    Lo = pC[1];
    if ('0'<=Lo && Lo<='9')         Lo -= '0';

    else if ('a'<=Lo && Lo<='f')	Lo -= ('a'-10);
        
    else if ('A'<=Lo && Lo<='F')	Lo -= ('A'-10);
        
    Result = Lo + 16*Hi;
    return Result;
}

// prepares a hex value from an HTML doc to be converted into an int.
void CSrch::DecodeHex(char *p) 
{
	char *pD;

    pD = p;
    while (*p) 
    	{
        if (*p=='%') 
        	{
            p++;
            if (isxdigit(p[0]) && isxdigit(p[1])) 
            	{
                *pD++ = (char) Hex2Int(p);
                p += 2;

            	}
        	}
         else *pD++ = *p++;
        
    	}

    *pD = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\samples\srch\srch.h ===
class CSrch
{
public:
	CSrch(char*, EXTENSION_CONTROL_BLOCK* pEcb);
	~CSrch();

	void StoreField(FILE *f,char *Item);
	void urlDecode(char *p);
	int TwoHex2Int(char *pC);
	void strcvrt(char * cStr,char cOld,char cNew);
	void PrintEnviron();

	char cBuffer[1024];
	char cPrintBuffer[4096];

	void PrintFindData(WIN32_FIND_DATA *findData, char *findmask);
	void ListDirectoryContents( char *dirname, char *filemask, char *findmask);
	const char* Substitute(LPSTR lpFindIn);
	const char* Substituteb(LPSTR lpSubstIn);
	char* Substitutec(LPSTR lpSubstIn);
	void Sort();
	void Swap(short sCurrent,short sMin);
	int Hex2Int(char *pC);
	void DecodeHex(char *p);
							
	char* cStartDir;
	char* cParsedData;

	short sCounter;

	char pszAlias[100];
	
	BOOL bUseCase;
	BOOL bHitSomething;
	BOOL bErr;
	BOOL bOverflow;

	EXTENSION_CONTROL_BLOCK* pExtContext;
	struct _HitStruct
		{
		char* cHREF;
		short sHits;
		} sHitStruct[256], sSwap;

	short sHitCount;
	unsigned short sPageCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ssinc\ssinc.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ssinc.cxx

Abstract:

    This module contains the server side include processing code.  We aim
    for support as specified by iis\spec\ssi.doc.  The code is based on
    existing SSI support done in iis\svcs\w3\server\ssinc.cxx.

Author:

    Bilal Alam (t-bilala)       20-May-1996

--*/

#include "ssinc.hxx"

//
//  These are available SSI commands
//

enum SSI_COMMANDS
{
    SSI_CMD_INCLUDE = 0,
    SSI_CMD_ECHO,
    SSI_CMD_FSIZE,          // File size of specified file
    SSI_CMD_FLASTMOD,       // Last modified date of specified file
    SSI_CMD_CONFIG,         // Configure options

    SSI_CMD_EXEC,           // Execute CGI or CMD script

    SSI_CMD_BYTERANGE,      // Custom commands, not defined by NCSA

    SSI_CMD_UNKNOWN
};

//
//  These tags are essentially subcommands for the various SSI_COMMAND values
//

enum SSI_TAGS
{
    SSI_TAG_FILE,          // Used with include, fsize & flastmod
    SSI_TAG_VIRTUAL,

    SSI_TAG_VAR,           // Used with echo

    SSI_TAG_CMD,           // Used with Exec
    SSI_TAG_CGI,
    SSI_TAG_ISA,

    SSI_TAG_ERRMSG,        // Used with Config
    SSI_TAG_TIMEFMT,
    SSI_TAG_SIZEFMT,

    SSI_TAG_UNKNOWN
};

//
//  Variables available to #ECHO VAR = "xxx" but not available in ISAPI
//

enum SSI_VARS
{
    SSI_VAR_DOCUMENT_NAME = 0,
    SSI_VAR_DOCUMENT_URI,
    SSI_VAR_QUERY_STRING_UNESCAPED,
    SSI_VAR_DATE_LOCAL,
    SSI_VAR_DATE_GMT,
    SSI_VAR_LAST_MODIFIED,

    SSI_VAR_UNKNOWN
};

//
//  SSI Exec types
//

enum SSI_EXEC_TYPE
{
    SSI_EXEC_CMD = 1,
    SSI_EXEC_CGI = 2,
    SSI_EXEC_ISA = 4,

    SSI_EXEC_UNKNOWN
};

//
// Globals
//

UINT g_MonthToDayCount[] = {
    0,
    31,
    31 + 28,
    31 + 28 + 31,
    31 + 28 + 31 + 30,
    31 + 28 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30,
    31 + 28 + 31 + 30 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,
} ;

BOOL g_fIsDBCS = FALSE;

//
//  Prototypes
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

class SSI_ELEMENT_LIST;

SSI_ELEMENT_LIST *
SSIParse(
    IN SSI_REQUEST *        pRequest,
    IN STR *                pstrFile,
    IN STR *                pstrURL,
    IN TS_OPEN_FILE_INFO*   pOpenFile,
    IN TSVC_CACHE *         pTsCache
    );

BOOL
SSISend(
    IN SSI_REQUEST *        pRequest,
    IN STR *                pstrFile,
    IN STR *                pstrURL,
    IN SSI_INCLUDE_FILE *   pParent
    );

BOOL
ParseSSITag(
    IN OUT CHAR * *       ppchFilePos,
    IN     CHAR *         pchEOF,
    OUT    BOOL *         pfValidTag,
    OUT    SSI_COMMANDS * pCommandType,
    OUT    SSI_TAGS *     pTagType,
    OUT    CHAR *         pszTagString
    );

BOOL
FreeSELBlob(
    VOID * pvCacheBlob
    );

CHAR *
SSISkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
    );

CHAR *
SSISkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
    );

VOID
InitializeSSIGlobals( VOID );

//
//  Global Data
//

DECLARE_DEBUG_PRINTS_OBJECT()
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisSSIncGuid, 
0x784d891A, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

//
//  This is the list of supported commands
//

struct _SSI_CMD_MAP
{
    CHAR *       pszCommand;
    DWORD        cchCommand;
    SSI_COMMANDS ssiCmd;
}
SSICmdMap[] =
{
    "#include ",  9,  SSI_CMD_INCLUDE,
    "#echo ",     6,  SSI_CMD_ECHO,
    "#fsize ",    7,  SSI_CMD_FSIZE,
    "#flastmod ",10,  SSI_CMD_FLASTMOD,
    "#config ",   8,  SSI_CMD_CONFIG,
    "#exec ",     6,  SSI_CMD_EXEC,
    NULL,         0,  SSI_CMD_UNKNOWN
};

//
//  This is the list of supported tags
//

struct _SSI_TAG_MAP
{
    CHAR *   pszTag;
    DWORD    cchTag;
    SSI_TAGS ssiTag;
}
SSITagMap[] =
{
    "var",      3,  SSI_TAG_VAR,
    "file",     4,  SSI_TAG_FILE,
    "virtual",  7,  SSI_TAG_VIRTUAL,
    "errmsg",   6,  SSI_TAG_ERRMSG,
    "timefmt",  7,  SSI_TAG_TIMEFMT,
    "sizefmt",  7,  SSI_TAG_SIZEFMT,
    "cmd",      3,  SSI_TAG_CMD,
    "cgi",      3,  SSI_TAG_CGI,
    "isa",      3,  SSI_TAG_ISA,
    NULL,       0,  SSI_TAG_UNKNOWN
};

//
//   This is a list of #ECHO variables not supported by ISAPI
//

struct _SSI_VAR_MAP
{
    CHAR *      pszMap;
    DWORD       cchMap;
    SSI_VARS    ssiMap;
}
SSIVarMap[] =
{
    "DOCUMENT_NAME",            13, SSI_VAR_DOCUMENT_NAME,
    "DOCUMENT_URI",             12, SSI_VAR_DOCUMENT_URI,
    "QUERY_STRING_UNESCAPED",   22, SSI_VAR_QUERY_STRING_UNESCAPED,
    "DATE_LOCAL",               10, SSI_VAR_DATE_LOCAL,
    "DATE_GMT",                 8,  SSI_VAR_DATE_GMT,
    "LAST_MODIFIED",            13, SSI_VAR_LAST_MODIFIED,
    NULL,                       0,  SSI_VAR_UNKNOWN
};

BOOL fEnableCmdDirective = FALSE;

//
// Class Definitions
//

// class SSI_FILE
//
// File structure.  All high level functions should use this
// structure instead of dealing with handle specifics themselves.

class SSI_FILE
{
private:
    STR                             _strFilename;
    TSVC_CACHE *                    _pTsCache;
    TS_OPEN_FILE_INFO *             _hHandle;
    HANDLE                          _hMapHandle;
    PVOID                           _pvMappedBase;
    BOOL                            _fValid;
    BOOL                            _fCloseOnDestroy;

    //
    //  Track the current number of open handles for this file.
    //

    DWORD                           _cRefCount;
    CRITICAL_SECTION                _csRef;

public:

    SSI_FILE( IN STR *                  pstrFilename,
              IN TS_OPEN_FILE_INFO *    pOpenFile,
              IN TSVC_CACHE *           pTsCache )
        : 
          _hHandle      ( pOpenFile ),
          _hMapHandle   ( NULL ),
          _pvMappedBase ( NULL ),
          _pTsCache     ( pTsCache ),
          _fValid       ( FALSE ),
          _cRefCount    ( 0),
          _fCloseOnDestroy( FALSE )
    {
        InitializeCriticalSection( &_csRef );
       
        if ( !_strFilename.Copy( pstrFilename->QueryStr() ) )
        {
            return;
        } 
        _fValid = TRUE;
    }
    
    SSI_FILE( IN STR *                  pstrFilename,
              IN TSVC_CACHE *           pTsCache,
              IN HANDLE                 hUser)
        : 
          _hHandle      ( NULL ),
          _hMapHandle   ( NULL ),
          _pvMappedBase ( NULL ),
          _pTsCache     ( pTsCache ),
          _fValid       ( FALSE ),
          _cRefCount    ( 0),
          _fCloseOnDestroy( TRUE )
    {
        InitializeCriticalSection( &_csRef );
       
        if ( !_strFilename.Copy( pstrFilename->QueryStr() ) )
        {
            return;
        } 
        
        _hHandle = TsCreateFile( *_pTsCache,
                                 _strFilename.QueryStr(),
                                 hUser,
                                 TS_CACHING_DESIRED );
        if ( !_hHandle )
        {
            return;
        }
        _fValid = TRUE;
    }

    ~SSI_FILE( VOID )
    {
        if ( _fCloseOnDestroy )
        {
            if ( _hHandle )
            {
                TsCloseHandle( *_pTsCache, _hHandle );
            }
        }
        DeleteCriticalSection( &_csRef );
    }
    
    VOID Lock( VOID )
        { EnterCriticalSection( &_csRef ); }

    VOID UnLock( VOID )
        { LeaveCriticalSection( &_csRef ); }
    
    BOOL IsValid( VOID ) const
    {
        return _fValid;
    }

    PSECURITY_DESCRIPTOR GetSecDesc() const
    {
        return _hHandle->QuerySecDesc();
    }

    BOOL SSICreateFileMapping( VOID )
    // Creates a mapping to a file
    {
        HANDLE              hHandle;

        if ( _hHandle->QueryFileBuffer() )
        {
            return TRUE;
        }
        
        hHandle = _hHandle->QueryFileHandle();
        if ( _hMapHandle != NULL )
        {
            if ( !SSICloseMapHandle() )
            {
                return FALSE;
            }
        }
        _hMapHandle = ::CreateFileMapping( hHandle,
                                           NULL,
                                           PAGE_READONLY,
                                           0,
                                           0,
                                           NULL );

        if ( _hMapHandle == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "CreateFileMapping failed with %d\n",
                        GetLastError() ));
        }

        return _hMapHandle != NULL;
    }

    BOOL SSICloseMapHandle( VOID )
    // Closes mapping to a file
    {
        if ( _hMapHandle != NULL )
        {
            ::CloseHandle( _hMapHandle );
            _hMapHandle = NULL;
        }
        return TRUE;
    }

    BOOL SSIMapViewOfFile( VOID )
    // Maps file to address
    {
        if ( _hHandle->QueryFileBuffer() )
        {
            _pvMappedBase = _hHandle->QueryFileBuffer();
            return TRUE;
        }
        
        if ( _pvMappedBase != NULL )
        {
            if ( !SSIUnmapViewOfFile() )
            {
                return FALSE;
            }
        }
        _pvMappedBase = ::MapViewOfFile( _hMapHandle,
                                         FILE_MAP_READ,
                                         0,
                                         0,
                                         0 );
        if ( _pvMappedBase == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "MapViewOfFile() failed with %d\n",
                        GetLastError() ));
        }
        return _pvMappedBase != NULL;
    }

    BOOL SSIUnmapViewOfFile( VOID )
    // Unmaps file
    {
        if ( !_hHandle->QueryFileBuffer() && _pvMappedBase != NULL )
        {
            ::UnmapViewOfFile( _pvMappedBase );
            _pvMappedBase = NULL;
        }
        return TRUE;
    }

    DWORD SSIGetFileAttributes( VOID )
    // Gets the attributes of a file
    {
        if ( _hHandle == NULL )
        {   
            return 0;
        }
        return _hHandle->QueryAttributes();
    }

    BOOL SSIGetFileSize( OUT DWORD *   pdwLowWord,
                         OUT DWORD *   pdwHighWord )
    // Gets the size of the file.
    {
        if ( _hHandle == NULL )
        {
            return FALSE;
        }
        return _hHandle->QuerySize( pdwLowWord,
                                    pdwHighWord );
    }

    BOOL SSIGetLastModTime( OUT FILETIME * ftTime )
    // Gets the Last modification time of a file.
    {
        if ( _hHandle == NULL )
        {
            return FALSE;
        }
        return _hHandle->QueryLastWriteTime( ftTime );
    }

    PVOID GetMappedBase( VOID )
    {
        return _pvMappedBase;
    }

    STR & GetFilename( VOID )
    {
        return _strFilename;
    }
};

// Class SSI_ELEMENT_ITEM
//
// Represents a SSI command in the document

class SSI_ELEMENT_ITEM
{
private:
    DWORD               _Signature;
    SSI_COMMANDS        _ssiCmd;
    SSI_TAGS            _ssiTag;
    STR *               _pstrTagValue;

    DWORD               _cbBegin;         // Only used for Byte range command
    DWORD               _cbLength;        // Only used for Byte range command
public:

    LIST_ENTRY          _ListEntry;

    SSI_ELEMENT_ITEM( VOID )
        : _ssiCmd   ( SSI_CMD_UNKNOWN ),
          _ssiTag   ( SSI_TAG_UNKNOWN ),
          _Signature( SIGNATURE_SEI ),
          _pstrTagValue( NULL )
    {
        _ListEntry.Flink = NULL;
    }

    ~SSI_ELEMENT_ITEM( VOID )
    {
        if ( _pstrTagValue != NULL )
        {
            delete _pstrTagValue;
        }
        TCP_ASSERT( _ListEntry.Flink == NULL );
        _Signature = SIGNATURE_SEI_FREE;
    }

    VOID SetByteRange( IN DWORD cbBegin,
                       IN DWORD cbLength )
    {
        _ssiCmd   = SSI_CMD_BYTERANGE;
        _cbBegin  = cbBegin;
        _cbLength = cbLength;
    }

    BOOL SetCommand( IN SSI_COMMANDS ssiCmd,
                     IN SSI_TAGS     ssiTag,
                     IN CHAR *       achTag )
    {
        _ssiCmd = ssiCmd;
        _ssiTag = ssiTag;
        _pstrTagValue = new STR( achTag );
        return _pstrTagValue != NULL;
    }

    SSI_COMMANDS QueryCommand( VOID ) const
        { return _ssiCmd; }

    SSI_TAGS QueryTag( VOID ) const
        { return _ssiTag; }

    STR * QueryTagValue( VOID ) const
        { return _pstrTagValue; }

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_SEI; }

    DWORD QueryBegin( VOID ) const
        { return _cbBegin; }

    DWORD QueryLength( VOID ) const
        { return _cbLength; }
};

//  Class SSI_ELEMENT_LIST
//
//  This object sits as a cache blob under a file to be processed as a
//  server side include.  It represents an interpreted list of data elements
//  that make up the file itself.
//

class SSI_ELEMENT_LIST : public BLOB_HEADER
{
private:
    DWORD               _Signature;
    LIST_ENTRY          _ListHead;

    //
    //  These are for tracking the memory mapped file
    //

    DWORD               _cRefCount;
    CRITICAL_SECTION    _csRef;

    //
    //  Provides the utilities needed to open/manipulate files
    //

    SSI_FILE *          _pssiFile;

    //
    //  Name of URL.  Used to resolve FILE="xxx" filenames
    //

    STR                 _strURL;


public:
    SSI_ELEMENT_LIST( VOID )
      : _Signature   ( SIGNATURE_SEL ),
        _pssiFile( NULL ),
        _cRefCount( 0 )
    {
        InitializeListHead( &_ListHead );
        INITIALIZE_CRITICAL_SECTION( &_csRef );
    }

    ~SSI_ELEMENT_LIST( VOID )
    {
        SSI_ELEMENT_ITEM * pSEI;

        while ( !IsListEmpty( &_ListHead ))
        {
            pSEI = CONTAINING_RECORD( _ListHead.Flink,
                                      SSI_ELEMENT_ITEM,
                                      _ListEntry );

            RemoveEntryList( &pSEI->_ListEntry );
            pSEI->_ListEntry.Flink = NULL;
            delete pSEI;
        }
        UnMap();

        if( _pssiFile != NULL )
        {
            delete _pssiFile;
        }

        DeleteCriticalSection( &_csRef );
        _Signature = SIGNATURE_SEL_FREE;

    }

    BOOL AppendByteRange( IN DWORD  cbStart,
                          IN DWORD  cbLength )
    {
        SSI_ELEMENT_ITEM * pSEI;

        pSEI = new SSI_ELEMENT_ITEM;

        if ( !pSEI )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }

        pSEI->SetByteRange( cbStart,
                            cbLength );
        AppendItem( pSEI );

        return TRUE;
    }

    BOOL AppendCommand( IN SSI_COMMANDS  ssiCmd,
                        IN SSI_TAGS      ssiTag,
                        IN CHAR *        pszTag )
    {
        SSI_ELEMENT_ITEM * pSEI;

        pSEI = new SSI_ELEMENT_ITEM;

        if ( !pSEI )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }

        if ( !pSEI->SetCommand( ssiCmd,
                                ssiTag,
                                pszTag ))
        {
            delete pSEI;
            return FALSE;
        }

        AppendItem( pSEI );

        return TRUE;
    }

    VOID AppendItem( IN SSI_ELEMENT_ITEM * pSEI )
    {
        InsertTailList( &_ListHead,
                        &pSEI->_ListEntry );
    }

    CHAR * QueryData( VOID ) const
        { return (CHAR *) _pssiFile->GetMappedBase(); }


    PSECURITY_DESCRIPTOR QuerySecDesc( VOID )
        { return _pssiFile->GetSecDesc(); }

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_SEL; }

    VOID Lock( VOID )
        { EnterCriticalSection( &_csRef ); }

    VOID UnLock( VOID )
        { LeaveCriticalSection( &_csRef ); }

    BOOL UnMap( VOID )
    {
        Lock();
        if ( _cRefCount && !--_cRefCount )
        {
            TCP_REQUIRE( _pssiFile->SSIUnmapViewOfFile() );
            TCP_REQUIRE( _pssiFile->SSICloseMapHandle() );
        }
        UnLock();
        return TRUE;
    }

    BOOL Map( VOID )
    {
        Lock();
        if ( _cRefCount++ == 0 )
        {
            if ( !_pssiFile->SSICreateFileMapping() )
            {
                UnLock();
                return FALSE;
            }
            if ( !_pssiFile->SSIMapViewOfFile() )
            {
                UnMap();
                UnLock();
                return FALSE;
            }
        }
        UnLock();
        return TRUE;
    }

    VOID SetFile( IN SSI_FILE * pssiFile )
        { _pssiFile = pssiFile; }

    SSI_FILE * GetFile( VOID )
        { return _pssiFile; }

    VOID SetURL( IN STR * pstrURL )
    {
        _strURL.Copy( pstrURL->QueryStr() );
    }

    BOOL Send( IN SSI_REQUEST *,
               IN SSI_INCLUDE_FILE *,
               IN STR * );

    BOOL FindInternalVariable( IN OUT STR *,
                               IN OUT DWORD * );
    BOOL GetFullPath( IN SSI_REQUEST *,
                      IN SSI_ELEMENT_ITEM *,
                      OUT STR *,
                      IN DWORD,
                      IN STR *,
                      OUT STR * pstrURL = NULL );

};

BOOL
SSI_ELEMENT_LIST::Send(
    IN SSI_REQUEST *       pRequest,
    IN SSI_INCLUDE_FILE *  pParent,
    IN STR *               pstrURL
    )
/*++

Routine Description:

    This method walks the element list sending the appropriate chunks of
    data

Arguments:

    pRequest - Request context

Return Value:

    TRUE on success, FALSE on any failures

--*/
{
    LIST_ENTRY *       pEntry;
    DWORD              cbSent;
    STACK_STR(         strPath, MAX_PATH);
    SSI_ELEMENT_ITEM * pSEI;

    DWORD              dwID;
    LPCTSTR            apszParms[ 2 ];
    CHAR               achNumberBuffer[ SSI_MAX_NUMBER_STRING ];

    BOOL               bSizeFmtBytes = SSI_DEF_SIZEFMT;
    STACK_STR(         strTimeFmt, 64);

    TCP_ASSERT( CheckSignature() );

    if ( !strTimeFmt.Copy( SSI_DEF_TIMEFMT ) ||
         !Map() )
    {
        return FALSE;
    }

    //
    //  Loop through each element and take the appropriate action
    //

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pSEI = CONTAINING_RECORD( pEntry, SSI_ELEMENT_ITEM, _ListEntry );

        TCP_ASSERT( pSEI->CheckSignature() );

        dwID = 0;

        switch ( pSEI->QueryCommand() )
        {
        case SSI_CMD_BYTERANGE:
            if ( !pRequest->WriteToClient( QueryData() + pSEI->QueryBegin(),
                                            pSEI->QueryLength(),
                                            &cbSent ) )
            {
                UnMap();
                return FALSE;
            }
            break;

        case SSI_CMD_INCLUDE:
            switch ( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
            {
                STACK_STR(      strFullURL, MAX_PATH );

                if ( !GetFullPath( pRequest,
                                   pSEI,
                                   &strPath,
                                   HSE_URL_FLAGS_READ,
                                   pstrURL,
                                   &strFullURL ) )
                {
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                    dwID = SSINCMSG_ERROR_HANDLING_FILE;
                    break;
                }

                SSI_INCLUDE_FILE Child( strPath, pParent );

                if ( !Child.IsValid() )
                {
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                    dwID = SSINCMSG_ERROR_HANDLING_FILE;
                    break;
                }

                if ( pParent->IsRecursiveInclude( strPath ) )
                {
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                    dwID = SSINCMSG_ERROR_RECURSIVE_INCLUDE;
                    break;
                }

                if ( !SSISend( pRequest,
                               &strPath,
                               &strFullURL,
                               &Child ) )
                {
//                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
//                    dwID = SSINCMSG_ERROR_HANDLING_FILE;
                }

                break;
            }
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            if ( dwID )
            {
                pRequest->SSISendError( dwID, apszParms );
            }
            break;

        case SSI_CMD_FLASTMOD:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( !GetFullPath( pRequest,
                                   pSEI,
                                   &strPath,
                                   0,
                                   pstrURL ) ||
                     !pRequest->DoFLastMod( &strPath,
                                            &strTimeFmt,
                                            this) )
                {
                    _ultoa( GetLastError(), achNumberBuffer, 10 );
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_DO_FLASTMOD;
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            if ( dwID )
            {
                pRequest->SSISendError( dwID, apszParms );
            }
            break;

        case SSI_CMD_CONFIG:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_ERRMSG:
                if ( !pRequest->SetUserErrorMessage( pSEI->QueryTagValue() ) )
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }
                break;
            case SSI_TAG_TIMEFMT:
                if ( !strTimeFmt.Copy( pSEI->QueryTagValue()->QueryStr() ) )
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }
                break;
            case SSI_TAG_SIZEFMT:
                if ( _strnicmp( SSI_DEF_BYTES,
                                pSEI->QueryTagValue()->QueryStr(),
                                SSI_DEF_BYTES_LEN ) == 0 )
                {
                    bSizeFmtBytes = TRUE;
                }
                else if ( _strnicmp( SSI_DEF_ABBREV,
                                     pSEI->QueryTagValue()->QueryStr(),
                                     SSI_DEF_ABBREV_LEN ) == 0 )
                {
                    bSizeFmtBytes = FALSE;
                }
                else
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            if ( dwID )
            {
                pRequest->SSISendError( dwID, NULL );
            }
            break;

        case SSI_CMD_FSIZE:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( !GetFullPath( pRequest,
                                   pSEI,
                                   &strPath,
                                   0,
                                   pstrURL ) ||
                     !pRequest->DoFSize( &strPath,
                                         bSizeFmtBytes,
                                         this) )
                {
                    _ultoa( GetLastError(), achNumberBuffer, 10 );
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_DO_FSIZE;
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            if ( dwID )
            {
                pRequest->SSISendError( dwID, apszParms );
            }

            break;

        case SSI_CMD_ECHO:
            if ( pSEI->QueryTag() == SSI_TAG_VAR )
            {
                // First let ISAPI try to evaluate variable.
                if ( pRequest->DoEchoISAPIVariable( pSEI->QueryTagValue() ) )
                {
                    break;
                }
                else
                {
                    DWORD               dwVar;
                    BOOL                fEchoSuccess = FALSE;

                    // if ISAPI couldn't resolve var, try internal list
                    if ( !FindInternalVariable( pSEI->QueryTagValue(),
                                               &dwVar ) )
                    {
                        apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                        dwID = SSINCMSG_CANT_FIND_VARIABLE;
                    }
                    else
                    {
                        switch( dwVar )
                        {
                        case SSI_VAR_DOCUMENT_NAME:
                            fEchoSuccess = pRequest->DoEchoDocumentName( &_pssiFile->GetFilename() );
                            break;
                        case SSI_VAR_DOCUMENT_URI:
                            fEchoSuccess = pRequest->DoEchoDocumentURI( &_strURL );
                            break;
                        case SSI_VAR_QUERY_STRING_UNESCAPED:
                            fEchoSuccess = pRequest->DoEchoQueryStringUnescaped();
                            break;
                        case SSI_VAR_DATE_LOCAL:
                            fEchoSuccess = pRequest->DoEchoDateLocal( &strTimeFmt );
                            break;
                        case SSI_VAR_DATE_GMT:
                            fEchoSuccess = pRequest->DoEchoDateGMT( &strTimeFmt );
                            break;
                        case SSI_VAR_LAST_MODIFIED:
                            fEchoSuccess = pRequest->DoEchoLastModified( &_pssiFile->GetFilename(),
                                                                       &strTimeFmt, this );
                            break;
                        default:
                            apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                            dwID = SSINCMSG_CANT_FIND_VARIABLE;
                        }
                        if ( !fEchoSuccess )
                        {
                            apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                            dwID = SSINCMSG_CANT_EVALUATE_VARIABLE;
                        }
                    }
                }
            }
            else
            {
                dwID = SSINCMSG_INVALID_TAG;
            }

            if ( dwID )
            {
                pRequest->SSISendError( dwID,
                                        apszParms );
            }
            break;

        case SSI_CMD_EXEC:
        {
            SSI_EXEC_TYPE ssiExecType = SSI_EXEC_UNKNOWN;

            if ( pRequest->IsExecDisabled() )
            {
                dwID = SSINCMSG_EXEC_DISABLED;
            }
            else if ( pSEI->QueryTag() == SSI_TAG_CMD )
            {
                if ( !fEnableCmdDirective )
                {
                    dwID = SSINCMSG_CMD_NOT_ENABLED;
                }
                else
                {
                    ssiExecType = SSI_EXEC_CMD;
                }
            }
            else if ( pSEI->QueryTag() == SSI_TAG_CGI )
            {
                ssiExecType = SSI_EXEC_CGI;
            }
            else if ( pSEI->QueryTag() == SSI_TAG_ISA )
            {
                ssiExecType = SSI_EXEC_ISA;
            }
            else
            {
                dwID = SSINCMSG_INVALID_TAG;
            }

            if ( ssiExecType != SSI_EXEC_UNKNOWN )
            {
                DWORD dwFlags = HSE_EXEC_NO_HEADERS | HSE_EXEC_REDIRECT_ONLY;
                if (ssiExecType == SSI_EXEC_CMD)
                    dwFlags |= HSE_EXEC_COMMAND;

                BOOL fOk = pRequest->_pECB->ServerSupportFunction
                (
                    pRequest->_pECB->ConnID,
                    HSE_REQ_EXECUTE_CHILD,
                    (LPVOID) pSEI->QueryTagValue()->QueryStr(),
                    NULL,
                    &dwFlags
                );

                if ( !fOk )
                {
                    DWORD   dwError = GetLastError();

                    _ultoa( dwError, achNumberBuffer, 10 );
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;

                    if ( dwError == ERROR_INVALID_FLAGS )
                    {
                        dwID = SSINCMSG_NO_EXECUTE_PERMISSION;
                    }
                    else
                    {
                        dwID = SSINCMSG_CANT_EXEC_CGI;
                    }
                }
            }

            if ( dwID )
            {
                pRequest->SSISendError( dwID, apszParms );
                break;
            }
            break;
        }
        default:
            pRequest->SSISendError( SSINCMSG_NOT_SUPPORTED,
                                    NULL );
            break;
        }
    }

    UnMap();

    return TRUE;
}

BOOL
SSI_ELEMENT_LIST::GetFullPath(
    IN SSI_REQUEST *        pRequest,
    IN SSI_ELEMENT_ITEM *   pSEI,
    OUT STR *               pstrPath,
    IN DWORD                dwPermission,
    IN STR *                pstrCurrentURL,
    OUT STR *               pstrURL
)
/*++

Routine Description:

    Used to resolve FILE= and VIRTUAL= references.  Fills in the physical
    path of such file references and optionally checks the permissions
    of the virtual directory.

Arguments:

    pRequest - SSI_REQUEST
    pSEI - Element item ( either FILE or VIRTUAL )
    pstrPath - Filled in with physical path of file
    dwPermission - Contains permissions that the virtual
                   path must satisfy. For example HSE_URL_FLAGS_READ.
                   If 0, then no permissions are checked
    pstrCurrentURL - Current .STM URL being parsed
    pstrURL - Full URL filled in here

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    CHAR *              pszValue;
    STR *               pstrValue;
    DWORD               dwMask;
    DWORD               cbBufLen;
    CHAR                achPath[ SSI_MAX_PATH + 1 ];

    //
    //  We recalc the virtual root each time in case the root
    //  to directory mapping has changed
    //

    pstrValue = pSEI->QueryTagValue();
    pszValue = pstrValue->QueryStr();

    if ( *pszValue == '/' )
    {
        achPath[ SSI_MAX_PATH ] = '\0';
        strncpy( achPath, pszValue, SSI_MAX_PATH + 1 );
        if ( achPath[ SSI_MAX_PATH ] != '\0' )
        {
            //
            // buffer size has been exceeded
            //
            return FALSE;
        }
    }
    else if ( (int)pSEI->QueryTag() == (int)SSI_TAG_FILE )
    {
        achPath[ SSI_MAX_PATH ] = '\0'; 
        strncpy( achPath, pstrCurrentURL->QueryStr(), SSI_MAX_PATH + 1 );
        if ( achPath[ SSI_MAX_PATH ] != '\0' )
        {
            //
            // buffer size has been exceeded
            //
            return FALSE;
        }
        // find last '/'
        LPSTR pL = (PCHAR) _mbsrchr( (PUCHAR) achPath, '/' );
        if ( pL == NULL )
        {
            pL = achPath;
        }

        if ( pL == achPath )
        {
            *pL = '/';
        } 
        pL ++;
        strncpy( pL, pszValue, SSI_MAX_PATH + 1 - DIFF( pL - achPath ) );
        if ( achPath[ SSI_MAX_PATH ] != '\0' )
        {
            //
            // buffer size has been exceeded
            //
            return FALSE;
        }

    }
    else
    {
        achPath[0] = '/';
        achPath[ SSI_MAX_PATH ] = '\0';
        strncpy( achPath + 1, pszValue, SSI_MAX_PATH + 1 - 1 );  // decrement one because we copy starting with index 1
        if ( achPath[ SSI_MAX_PATH ] != '\0' )
        {
            //
            // buffer size has been exceeded
            //
            return FALSE;
        }

    }

    //
    //  First canonicalize the URL to be #included
    //

    CanonURL( achPath, g_fIsDBCS );

    //
    //  Map to a physical directory
    //

    if ( !pRequest->LookupVirtualRoot( achPath,
                                       pstrPath,
                                       dwPermission ) )
    {
        if ( GetLastError() == ERROR_ACCESS_DENIED )
        {
            LPCTSTR apszParms[ 1 ];
            apszParms[ 0 ] = achPath;

            pRequest->SSISendError( SSINCMSG_ACCESS_DENIED,
                                    apszParms );
        }
        else
        {
            LPCTSTR apszParms[ 1 ];
            apszParms[ 0 ] = achPath;

            pRequest->SSISendError( SSINCMSG_CANT_RESOLVE_PATH,
                                    apszParms );
        }
        return FALSE;
    }

    return pstrURL ? pstrURL->Copy( achPath ) : TRUE;
}

BOOL
SSI_ELEMENT_LIST::FindInternalVariable(
    IN STR *                pstrVariable,
    OUT PDWORD              pdwID
)
/*++

Routine Description:

    Lookup internal list of SSI variables that aren't supported by ISAPI.
    These include "DOCUMENT_NAME", "DATE_LOCAL", etc.

Arguments:

    pstrVariable - Variable to check
    pdwID - Variable ID (or SSI_VAR_UNKNOWN if not found)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD                   dwCounter = 0;

    while ( ( SSIVarMap[ dwCounter ].pszMap != NULL ) &&
            _strnicmp( SSIVarMap[ dwCounter ].pszMap,
                       pstrVariable->QueryStr(),
                       SSIVarMap[ dwCounter ].cchMap ) )
    {
        dwCounter++;
    }
    if ( SSIVarMap[ dwCounter ].pszMap != NULL )
    {
        *pdwID = SSIVarMap[ dwCounter ].ssiMap;
        return TRUE;
    }
    else
    {
        *pdwID = SSI_VAR_UNKNOWN;
        return FALSE;
    }
}

BOOL
SSIFreeContextRoutine( 
    VOID *              pvContext
)
{
    delete (SSI_ELEMENT_LIST*) pvContext;
    return TRUE;
}

//
// SSI_REQUEST methods
//

BOOL
SSI_REQUEST::DoFLastMod(
    IN STR *               pstrFilename,
    IN STR *               pstrTimeFmt,
    IN SSI_ELEMENT_LIST *  pList
)
/*++

Routine Description:

    Send the LastModTime of file to HTML stream

Arguments:

    pstrFilename - Filename
    pstrTimeFmt - Format of time -> follows strftime() convention

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    FILETIME        ftTime;
    FILETIME        ftLocalTime;
    SYSTEMTIME      sysLocal;

    if ( (NULL == pList) || 
         strcmp(pstrFilename->QueryStr(), (pList->GetFile()->GetFilename().QueryStr())) )
    {
        SSI_FILE ssiFile( pstrFilename, _pTsCache, GetUser() );

        if ( !ssiFile.IsValid() ||
            (!ssiFile.SSIGetLastModTime( &ftTime))
           )
        {
            return FALSE;
        }
    }
    else
    {
        pList->GetFile()->SSIGetLastModTime( &ftTime);
    }

    if ((!FileTimeToLocalFileTime( &ftTime, &ftLocalTime ) ) ||
        (!FileTimeToSystemTime( &ftLocalTime, &sysLocal ) ) )
    {
        return FALSE;
    }

    return SendDate( &sysLocal,
                     pstrTimeFmt );
}

BOOL
SSI_REQUEST::SendDate(
    IN SYSTEMTIME *         psysTime,
    IN STR *                pstrTimeFmt
)
/*++

Routine Description:

    Sends a SYSTEMTIME in appropriate format to HTML stream

Arguments:

    psysTime - SYSTEMTIME containing time to send
    pstrTimeFmt - Format of time (follows strftime() convention)
    fCalcDays - TRUE if days since the beginning of the year should be
        calculated

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    struct tm                   tm;
    CHAR                        achBuffer[ SSI_MAX_TIME_SIZE + 1 ];
    DWORD                       cbBufLen;

    // Convert SYSTEMTIME to 'struct tm'

    tm.tm_sec = psysTime->wSecond;
    tm.tm_min = psysTime->wMinute;
    tm.tm_hour = psysTime->wHour;
    tm.tm_mday = psysTime->wDay;
    tm.tm_mon = psysTime->wMonth - 1;
    tm.tm_year = psysTime->wYear - 1900;
    tm.tm_wday = psysTime->wDayOfWeek;
    tm.tm_yday = g_MonthToDayCount[tm.tm_mon] + tm.tm_mday - 1;

    //
    // Adjust for leap year - note that we do not handle 2100
    //

    if ( (tm.tm_mon) > 1 && !(psysTime->wYear&3) )
    {
        ++tm.tm_yday;
    }

    tm.tm_isdst = -1;       // Daylight savings time flag - have crt compute

    cbBufLen = strftime( achBuffer,
                         SSI_MAX_TIME_SIZE + 1,
                         pstrTimeFmt->QueryStr(),
                         &tm );

    if ( cbBufLen == 0 )
    {
        return FALSE;
    }

    return WriteToClient( achBuffer,
                          cbBufLen,
                          &cbBufLen );
}

BOOL
SSI_REQUEST::LookupVirtualRoot( IN CHAR *       pszVirtual,
                                OUT STR *       pstrPhysical,
                                IN DWORD        dwAccess )
/*++

Routine Description:

    Lookup the given virtual path.  Optionally ensure that its access
    flags are valid for the require request.

Arguments:

    pszVirtual = Virtual path to lookup
    pstrPhysical = Contains the physical path
    dwAccess = Access flags required for a valid request

Return Value:

    TRUE if successful, else FALSE

--*/
{
    HSE_URL_MAPEX_INFO      URLMap;
    DWORD                   dwMask;

    if ( !_pECB->ServerSupportFunction( _pECB->ConnID,
                                        HSE_REQ_MAP_URL_TO_PATH_EX,
                                        pszVirtual,
                                        NULL,
                                        (PDWORD) &URLMap ) )
    {
        return FALSE;
    }

    dwMask = URLMap.dwFlags;

    if ( dwAccess & HSE_URL_FLAGS_READ )
    {
        if ( !(dwMask & HSE_URL_FLAGS_READ ) ||
             ((dwMask & HSE_URL_FLAGS_SSL ) && !_pReq->IsSecurePort()) )
        {
            SetLastError( ERROR_ACCESS_DENIED );
            return FALSE;
        }
    }

    return pstrPhysical->Copy( URLMap.lpszPath );
}

BOOL
SSI_REQUEST::DoEchoISAPIVariable(
    IN STR *            pstrVariable
)
/*++

Routine Description:

    Get ISAPI variable and if successful, send it to HTML stream

Arguments:

    pstrVariable - Variable

Return Value:

    TRUE on variable found and sent success, FALSE on failure

--*/
{
    STACK_STR(          strVar, MAX_PATH);
    DWORD               cbBufLen;

    if ( !GetVariable( pstrVariable->QueryStr(),
                       &strVar ) )
    {
        return FALSE;
    }

    return WriteToClient( strVar.QueryStrA(),
                          strVar.QueryCB(),
                          &cbBufLen );
}

BOOL
SSI_REQUEST::DoEchoDateLocal(
    IN STR *            pstrTimeFmt
)
/*++

Routine Description:

    Sends local time (#ECHO VAR="DATE_LOCAL")

Arguments:

    pstrTimefmt - Format of time (follows strftime() convention)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SYSTEMTIME              sysTime;

    ::GetLocalTime( &sysTime );
    return SendDate( &sysTime,
                     pstrTimeFmt );
}

BOOL
SSI_REQUEST::DoEchoDateGMT(
    IN STR *            pstrTimeFmt
)
/*++

Routine Description:

    Sends GMT time (#ECHO VAR="DATE_GMT")

Arguments:

    pstrTimefmt - Format of time (follows strftime() convention)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SYSTEMTIME              sysTime;

    ::GetSystemTime( &sysTime );
    return SendDate( &sysTime,
                     pstrTimeFmt );
}

BOOL
SSI_REQUEST::DoEchoDocumentName(
    IN STR *            pstrFilename
)
/*++

Routine Description:

    Sends filename of current SSI document (#ECHO VAR="DOCUMENT_NAME")

Arguments:

    pstrFilename - filename to print

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD                   cbBufLen;

    return WriteToClient( pstrFilename->QueryStr(),
                          pstrFilename->QueryCB(),
                          &cbBufLen );
}

BOOL
SSI_REQUEST::DoEchoDocumentURI(
    IN STR *            pstrURL
)
/*++

Routine Description:

    Sends URL of current SSI document (#ECHO VAR="DOCUMENT_URI")

Arguments:

    pstrURL - URL to print

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD                   cbBufLen;

    return WriteToClient( pstrURL->QueryStr(),
                          pstrURL->QueryCB(),
                          &cbBufLen );
}

BOOL
SSI_REQUEST::DoEchoQueryStringUnescaped(
)
/*++

Routine Description:

    Sends unescaped querystring to HTML stream (#ECHO VAR="QUERY_STRING_UNESCAPED")

Arguments:

    none

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD                   cbBufLen;
    STACK_STR(              strVar, MAX_PATH);

    if ( !strVar.Copy( _pECB->lpszQueryString ) )
    {
        return FALSE;
    }

    if ( !strVar.Unescape() )
    {
        return FALSE;
    }

    return WriteToClient( strVar.QueryStr(),
                          strVar.QueryCB(),
                          &cbBufLen );
}

BOOL
SSI_REQUEST::DoEchoLastModified(
    IN STR *            pstrFilename,
    IN STR *            pstrTimeFmt,
    IN SSI_ELEMENT_LIST     *pList
)
/*++

Routine Description:

    Sends LastModTime of current document (#ECHO VAR="LAST_MODIFIED")

Arguments:

    pstrFilename - Filename of current SSI document
    pstrTimeFmt - Time format (follows strftime() convention)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    return DoFLastMod( pstrFilename,
                       pstrTimeFmt,
                       pList);
}

BOOL
SSI_REQUEST::DoFSize(
    IN STR *                pstrFilename,
    IN BOOL                 bSizeFmtBytes,
    IN SSI_ELEMENT_LIST     *pList
)
/*++

Routine Description:

    Sends file size of file to HTML stream

Arguments:

    pstrfilename - Filename
    bSizeFmtBytes - TRUE if count is in Bytes, FALSE if in KBytes

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    BOOL                bRet;
    DWORD               cbSizeLow;
    DWORD               cbSizeHigh;
    CHAR                achInputNumber[ SSI_MAX_NUMBER_STRING + 1 ];
    CHAR                achOutputNumber[ SSI_MAX_NUMBER_STRING + 1 ];
    NUMBERFMT           nfNumberFormat;
    int                 iOutputSize;
    DWORD               dwActualLen;

    if ( (NULL == pList) || 
         strcmp(pstrFilename->QueryStr(), (pList->GetFile()->GetFilename().QueryStr())) )
    {
        SSI_FILE ssiFile( pstrFilename, _pTsCache, GetUser() );

        if ( !ssiFile.IsValid() ||
            (!ssiFile.SSIGetFileSize( &cbSizeLow,
                                      &cbSizeHigh ))
           )
        {
            return FALSE;
        }
    }
    else
    {
        if (!pList->GetFile()->SSIGetFileSize( &cbSizeLow,
                                               &cbSizeHigh ))
        {
            return FALSE;
        }
    }

    if ( cbSizeHigh )
    {
        return FALSE;
    }

    if ( !bSizeFmtBytes )
    {
        // express in terms of KB
        cbSizeLow /= 1000;
    }

    nfNumberFormat.NumDigits = 0;
    nfNumberFormat.LeadingZero = 0;
    nfNumberFormat.Grouping = 3;
    nfNumberFormat.lpThousandSep = ",";
    nfNumberFormat.lpDecimalSep = ".";
    nfNumberFormat.NegativeOrder = 2;

    _snprintf( achInputNumber,
               SSI_MAX_NUMBER_STRING + 1,
               "%ld",
               cbSizeLow );

    iOutputSize = GetNumberFormat( LOCALE_SYSTEM_DEFAULT,
                                   0,
                                   achInputNumber,
                                   &nfNumberFormat,
                                   achOutputNumber,
                                   SSI_MAX_NUMBER_STRING + 1 );
    if ( !iOutputSize )
    {
        return FALSE;
    }

    iOutputSize--;

    return WriteToClient( achOutputNumber,
                          iOutputSize,
                          &dwActualLen );
}

BOOL
SSI_REQUEST::ProcessSSI( VOID )
/*++

Routine Description:

    This is the top level routine for retrieving a server side include
    file.

Arguments:

    none

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "[ProcessSSI] about to process %s\n",
                _strFilename.QueryStr() ));

    SSI_INCLUDE_FILE    Parent( _strFilename, NULL );

    if ( !Parent.IsValid() )
    {
        return FALSE;
    }
    else
    {
        return SSISend( this, &_strFilename, &_strURL, &Parent );
    }
}

// Standalone functions

BOOL
SSISend(
    IN SSI_REQUEST *        pRequest,
    IN STR *                pstrFile,
    IN STR *                pstrURL,
    IN SSI_INCLUDE_FILE *   pParent
    )
/*++

Routine Description:

    This method builds the Server Side Include Element List the first time
    a .stm file is sent.  Subsequently, the element list is checked out from
    the associated cache blob.

    Note:  The HTTP headers have already been sent at this point so for any
    subsequent non-catastrophic errors, we have to insert them into the output
    stream.

Arguments:

    pRequest - SSI Request
    pstrFile - File to send
    pstrURL - URL (from root) of this file
    pParent - Parent SSI include file

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SSI_ELEMENT_LIST *      pSEL = NULL;
    BOOL                    fRet = TRUE;
    BOOL                    fSELCached = FALSE;
    BOOL                    fFileCached = FALSE;
    BOOL                    fMustFree = FALSE;
    TS_OPEN_FILE_INFO *     pOpenFile = NULL;
    DWORD                   dwError;
    LPCTSTR                 apszParms[ 2 ];
    CHAR                    pszNumBuf[ SSI_MAX_NUMBER_STRING ];
    
    pOpenFile = TsCreateFile( *(pRequest->_pTsCache),
                              pstrFile->QueryStr(),
                              pRequest->GetUser(),              // WinSE 5597
                              TS_CACHING_DESIRED );
    if ( pOpenFile )
    {
        //
        // The source file is in the cache.  Check whether we have associated
        // a SSI_ELEMENT_LIST with it.
        //
        
        fFileCached = pOpenFile->QueryFileBuffer() != NULL;
        
        pSEL = (SSI_ELEMENT_LIST*) pOpenFile->QueryContext();
        if ( pSEL )
        {
            fSELCached = TRUE;
        }
        else
        {
            pSEL = SSIParse( pRequest, 
                             pstrFile, 
                             pstrURL,
                             pOpenFile,
                             pRequest->_pTsCache );
        }
    }
    
    if ( !pOpenFile || !pSEL )
    {
        fRet = FALSE;
        
        if ( pRequest->IsBaseFile() )
        {
            dwError = GetLastError();            
            switch( dwError )
            {
            case ERROR_ACCESS_DENIED:
                pRequest->SendResponseHeader( SSI_ACCESS_DENIED,
                                              SSI_HEADER
                                              "<body><h1>"
                                              SSI_ACCESS_DENIED
                                              "</h1></body>" );
                break;
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
            default:        // treat all other failures as 404 
                pRequest->SendResponseHeader( SSI_OBJECT_NOT_FOUND,
                                              SSI_HEADER
                                              "<body><h1>"
                                              SSI_OBJECT_NOT_FOUND
                                              "</h1></body>" );
                break;
            }
        }
        else
        {
            // do not send back file names 
            pRequest->SendResponseHeader( SSI_OBJECT_NOT_FOUND,
                                          SSI_HEADER
                                          "<body><h1>"
                                          SSI_OBJECT_NOT_FOUND
                                          "</h1></body>" );
        }
    }
    
    //
    // Only bother to cache SEL if the file is cached
    // 
    
    if ( fRet && !fSELCached && fFileCached )
    {
        if ( !pOpenFile->SetContext( pSEL, SSIFreeContextRoutine ) )
        {
            delete pSEL;
            pSEL = (SSI_ELEMENT_LIST*) pOpenFile->QueryContext();
            if ( !pSEL )
            {
                DBG_ASSERT( FALSE );
                fRet = FALSE;
            }
            else
            {
                fSELCached = TRUE;
            }
        }
        else
        {
            fSELCached = TRUE;
        }
    }
    
    //
    // If we got this far and this is the base file, we can send the 200 OK
    //

    if ( fRet && pRequest->IsBaseFile() )
    {
        pRequest->SetNotBaseFile();
    
        pRequest->SendResponseHeader( NULL,
                                      SSI_HEADER );
          
    }
    
    if ( pSEL != NULL )
    {
        DBG_ASSERT( pSEL->CheckSignature() );
    }

    //
    // Send response body only if it's not the HEAD request
    //
    
    if ( fRet &&  
         _stricmp(pRequest->_pECB->lpszMethod, "HEAD" ) != 0  )
    {
        if ( !pSEL->Send( pRequest,
                          pParent,
                          pstrURL ) )
        {
            //
            //  Send a failure message
            //

            LPCTSTR apszParms[ 2 ];
            CHAR pszNumBuf[ SSI_MAX_NUMBER_STRING ];
            _ultoa( GetLastError(), pszNumBuf, 10 );
            apszParms[ 0 ] = pstrURL->QueryStr();
            apszParms[ 1 ] = pszNumBuf;

            pRequest->SSISendError( SSINCMSG_ERROR_HANDLING_FILE,
                                    apszParms );
            fRet = FALSE;
        }
    }
    
    //
    // Cleanup SEL if necessary
    //

    if ( !fSELCached )
    {
        if ( pSEL )
        {
            delete pSEL;
        }
    }
        
    if ( pOpenFile )
    {
        TsCloseHandle( *(pRequest->_pTsCache), pOpenFile );
    }
    
    return fRet;
}    


SSI_ELEMENT_LIST *
SSIParse(
    IN SSI_REQUEST *        pRequest,
    IN STR *                pstrFile,
    IN STR *                pstrURL,
    IN TS_OPEN_FILE_INFO*   pOpenFile,
    IN TSVC_CACHE *         pTsCache
    )
/*++

Routine Description:

    This method opens and parses the specified server side include file.

    Note:  The HTTP headers have already been sent at this point so for any
    subsequent non-catastrophic errors, we have to insert them into the output
    stream.

    We keep the file open but that's ok because if a change dir notification
    occurs, the cache blob will get decached at which point we will close
    all of our open handles.

Arguments:

    pRequest - Request context
    pstrFile - File to open and parse
    pstrURL - The URL path of this file
    pOpenFile - Cached file descriptor
    pTsCache - Cache handle

Return Value:

    Created Server Side Include File on success, NULL on failure.

--*/
{
    SSI_FILE *          pssiFile = NULL;
    SSI_ELEMENT_LIST *  pSEL  = NULL;
    CHAR *              pchBeginRange = NULL;
    CHAR *              pchFilePos = NULL;
    CHAR *              pchBeginFile = NULL;
    CHAR *              pchEOF = NULL;
    DWORD               cbSizeLow, cbSizeHigh;

    //
    //  Create the element list
    //

    pSEL = new SSI_ELEMENT_LIST;

    if ( pSEL == NULL )
    {
        goto ErrorExit;
    }

    //
    //  Set the URL (to be used in calculating FILE="xxx" paths
    //

    pSEL->SetURL( pstrURL );

    //
    //  Open the file
    //

    pssiFile = new SSI_FILE( pstrFile, pOpenFile, pTsCache );
    if ( !pssiFile || !pssiFile->IsValid() )
    {
        if (pssiFile)
        {
            delete pssiFile;
            pssiFile = NULL;
        }
        goto ErrorExit;
    }

    pSEL->SetFile( pssiFile );

    //
    //  Make sure a parent doesn't try and include a directory
    //

    if ( pssiFile->SSIGetFileAttributes() & FILE_ATTRIBUTE_DIRECTORY )
    {
        goto ErrorExit;
    }

    if ( !pssiFile->SSIGetFileSize( &cbSizeLow, &cbSizeHigh ) )
    {
        goto ErrorExit;
    }

    if ( cbSizeHigh )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        goto ErrorExit;
    }

    //
    //  Create a file mapping, we shouldn't need to impersonate as we already
    //  have the file open
    //

    if ( !pSEL->Map() )
    {
        goto ErrorExit;
    }

    pchFilePos = pchBeginFile = pchBeginRange = pSEL->QueryData();
    pchEOF     = pchFilePos + cbSizeLow;

    //
    //  Scan for "<!--" or "<%"
    //

    while ( TRUE )
    {
        while ( pchFilePos < pchEOF && *pchFilePos != '<' )
        {
            pchFilePos++;
        }

        if ( pchFilePos + 4 >= pchEOF )
        {
            break;
        }

        //
        //  Is this one of our tags?
        //

        if ( pchFilePos[1] == '%' ||
             !strncmp( pchFilePos, "<!--", 4 ))
        {
            CHAR *        pchBeginTag = pchFilePos;
            SSI_COMMANDS  CommandType;
            SSI_TAGS      TagType;
            CHAR          achTagString[SSI_MAX_PATH + 1];
            BOOL          fValidTag;

            //
            //  Get the tag info.  The file position will be advanced to the
            //  first character after the tag
            //

            if ( !ParseSSITag( &pchFilePos,
                               pchEOF,
                               &fValidTag,
                               &CommandType,
                               &TagType,
                               achTagString ))
            {
                break;
            }

            //
            //  If it's a tag we don't recognize then ignore it
            //

            if ( !fValidTag )
            {
                pchFilePos++;
                continue;
            }

            //
            //  Add the data up to the tag as a byte range
            //

            if ( pchBeginRange != pchBeginTag )
            {
                if ( !pSEL->AppendByteRange( DIFF(pchBeginRange - pchBeginFile),
                                             DIFF(pchBeginTag - pchBeginRange) ))
                {
                    goto ErrorExit;
                }
            }

            pchBeginRange = pchFilePos;

            //
            //  Add the tag
            //

            if ( !pSEL->AppendCommand( CommandType,
                                       TagType,
                                       achTagString ))
            {
                goto ErrorExit;
            }
        }
        else
        {
            //
            //  Not one of our tags, skip the openning angle bracket
            //

            pchFilePos++;
        }
    }

    //
    //  Tack on the last byte range
    //

    if ( pchFilePos > pchBeginRange )
    {
        if ( !pSEL->AppendByteRange( DIFF(pchBeginRange - pchBeginFile),
                                     DIFF(pchFilePos - pchBeginRange) ))
        {
            goto ErrorExit;
        }
    }

    pSEL->UnMap();

    return pSEL;

ErrorExit:

    if ( pSEL != NULL )
    {
        delete pSEL;    // also deletes pssiFile if SetFile has been called.
    }

    return NULL;
}

BOOL
ParseSSITag(
    IN OUT CHAR * *       ppchFilePos,
    IN     CHAR *         pchEOF,
    OUT    BOOL *         pfValidTag,
    OUT    SSI_COMMANDS * pCommandType,
    OUT    SSI_TAGS *     pTagType,
    OUT    CHAR *         pszTagString
    )
/*++

Routine Description:

    This function picks apart an NCSA style server side include expression

    The general form of a server side include directive is:

    <[!-- or %]#[command] [tag]="[value]"[-- or %]>

    For example:

    <!--#include file="myfile.txt"-->
    <%#echo var="HTTP_USER_AGENT"%>
    <!--#fsize virtual="/dir/bar.htm"-->

    For valid commands and tags see \iis\specs\ssi.doc

Arguments:

    ppchFilePos - Pointer to first character of tag on way in, pointer
        to first character after tag on way out if the tag is valid
    pchEOF - Points to first byte beyond the end of the file
    pfValidTag - Set to TRUE if this is a tag we support and all of the
        parameters have been supplied
    pCommandType - Receives SSI command
    pTagType - Receives SSI tag
    pszTagString - Receives value of pTagType.  Must be > SSI_MAX_PATH.

Return Value:

    TRUE if no errors occurred.

--*/
{
    CHAR * pchFilePos = *ppchFilePos;
    CHAR * pchEOT;
    CHAR * pchEndQuote;
    DWORD  i;
    DWORD  cbToCopy;
    DWORD  cbJumpLen = 0;
    BOOL   fNewStyle;           // <% format

    TCP_ASSERT( *pchFilePos == '<' );

    //
    //  Assume this is bad tag
    //

    *pfValidTag = FALSE;

    if ( !strncmp( pchFilePos, "<!--", 4 ) )
    {
        fNewStyle = FALSE;
    }
    else if ( !strncmp( pchFilePos, "<%", 2 ) )
    {
        fNewStyle = TRUE;
    }
    else
    {
        return TRUE;
    }

    //
    //  Find the closing comment token (either --> or %>).  The reason
    //  why we shouldn't simply look for a > is because we want to allow
    //  the user to embed HTML <tags> in the directive
    //  (ex. <!--#CONFIG ERRMSG="<B>ERROR!!!</B>-->)
    //

    pchEOT = strstr( pchFilePos, fNewStyle ? "%>" : "-->" );
    if ( !pchEOT )
    {
        return FALSE;
    }
    cbJumpLen = fNewStyle ? 2 : 3;

    //
    //  Find the '#' that prefixes the command
    //

    pchFilePos = SSISkipTo( pchFilePos, '#', pchEOT );

    if ( !pchFilePos )
    {
        //
        //  No command, bail for this tag
        //
        //  CODEWORK - Check for if expression here
        //

        return TRUE;
    }

    //
    //  Lookup the command
    //

    i = 0;
    while ( SSICmdMap[i].pszCommand )
    {
        if ( *SSICmdMap[i].pszCommand == tolower( *pchFilePos ) &&
             !_strnicmp( SSICmdMap[i].pszCommand,
                         pchFilePos,
                         SSICmdMap[i].cchCommand ))
        {
            *pCommandType = SSICmdMap[i].ssiCmd;

            //
            //  Note the space after the command is included in cchCommand
            //

            pchFilePos += SSICmdMap[i].cchCommand;
            goto FoundCommand;
        }

        i++;
    }

    //
    //  Unrecognized command, bail
    //

    return TRUE;

FoundCommand:

    //
    //  Next, find the tag name
    //

    pchFilePos = SSISkipWhite( pchFilePos, pchEOT );

    if ( !pchFilePos )
        return TRUE;

    i = 0;
    while ( SSITagMap[i].pszTag )
    {
        if ( *SSITagMap[i].pszTag == tolower( *pchFilePos ) &&
             !_strnicmp( SSITagMap[i].pszTag,
                         pchFilePos,
                         SSITagMap[i].cchTag ))
        {
            *pTagType = SSITagMap[i].ssiTag;
            pchFilePos += SSITagMap[i].cchTag;
            goto FoundTag;
        }

        i++;
    }

    //
    //  Tag not found, bail
    //

    return TRUE;

FoundTag:

    //
    //  Skip to the quoted tag value, then find the close quote
    //

    pchFilePos = SSISkipTo( pchFilePos, '"', pchEOT );

    if ( !pchFilePos )
        return TRUE;

    pchEndQuote = SSISkipTo( ++pchFilePos, '"', pchEOT );

    if ( !pchEndQuote )
        return TRUE;

    cbToCopy = min( DIFF(pchEndQuote - pchFilePos), SSI_MAX_PATH );

    memcpy( pszTagString,
            pchFilePos,
            cbToCopy );

    pszTagString[cbToCopy] = '\0';

    *pfValidTag = TRUE;

    *ppchFilePos = pchEOT + cbJumpLen;

    return TRUE;
}

CHAR *
SSISkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
    )
{
    return (CHAR*) memchr( pchFilePos, ch, DIFF(pchEOF - pchFilePos) );
}

CHAR *
SSISkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
    )
{
    while ( pchFilePos < pchEOF )
    {
        if ( !isspace( (UCHAR)(*pchFilePos) ) )
            return pchFilePos;

        pchFilePos++;
    }

    return NULL;
}

VOID
InitializeSSIGlobals( VOID )
/*++

Routine Description:

    Initialize global variables

Return Value:

    none

--*/
{
    HKEY                hKeyParam;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKeyParam ) == NO_ERROR )
    {
        fEnableCmdDirective = !!ReadRegistryDword( hKeyParam,
                                                   "SSIEnableCmdDirective",
                                                   fEnableCmdDirective );
        RegCloseKey( hKeyParam );
    }

    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    g_fIsDBCS =  ((wPrimaryLangID == LANG_JAPANESE) ||
                  (wPrimaryLangID == LANG_CHINESE)  ||
                  (wPrimaryLangID == LANG_KOREAN) );
}

//
// ISAPI DLL Required Entry Points
//

DWORD
WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    BOOL                    bRet;

    DBGPRINTF(( DBG_CONTEXT,
                "HttpExtensionProc() entry point called\n" ));

    SSI_REQUEST ssiReq = pecb;
    if ( !ssiReq.IsValid() || !ssiReq.ProcessSSI() )
    {
        LPCTSTR                 apsz[ 1 ];
        STR                     strLogMessage;

        apsz[ 0 ] = pecb->lpszPathInfo;
        strLogMessage.FormatString( SSINCMSG_LOG_ERROR,
                                    apsz,
                                    SSI_DLL_NAME );

        strncpy( pecb->lpszLogData,
                 strLogMessage.QueryStr(),
                 HSE_LOG_BUFFER_LEN );

        pecb->lpszLogData[HSE_LOG_BUFFER_LEN-1] = 0;

        return HSE_STATUS_ERROR;
    }
    else
    {
        return HSE_STATUS_SUCCESS;
    }
}

BOOL
WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 0, 1 );
    strcpy( pver->lpszExtensionDesc,
            "Server Side Include Extension DLL" );
    return TRUE;
}

BOOL
WINAPI
TerminateExtension(
    DWORD dwFlags
    )
{
    //
    // Flush Tsunami file associated with this extension
    //
    
    TsFlushFilesWithContext();
    return TRUE;
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( SSI_DLL_NAME );
        SET_DEBUG_FLAGS( 0 );
#else
        CREATE_DEBUG_PRINT_OBJECT( SSI_DLL_NAME, IisSSIncGuid );
#endif
        DisableThreadLibraryCalls( hDll );
        InitializeSSIGlobals();
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ssincold\makefile.inc ===
#
# Supplemental rules for generating message file.
#

ssincmsg.h ssincmsg.rc msg00001.bin: ssincmsg.mc
    mc -v ssincmsg.mc

clean::
    -del ssincmsg.h ssincmsg.rc msg00001.bin


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ssincold\ssibgi.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ssibgi.cxx

Abstract:

    Code to do #EXEC ISA 
    
Author:

    Bilal Alam (t-bilala)       20-June-1996

Revision History:

--*/

#include "ssinc.hxx"
#include "ssicgi.hxx"
#include "ssibgi.hxx"

// Globals

BOOL    fExtInitialized = FALSE;
BOOL    fCacheExtensions = TRUE;

extern HANDLE g_hUser;

// Prototypes

extern "C" {
dllexp
BOOL
SEGetEntryPoint(
    const char *            pszDLL,
    HANDLE                  hImpersonation,
    PFN_HTTPEXTENSIONPROC * ppfnSEProc,
    HMODULE *               phMod
    );
}

BOOL
WINAPI
SSIServerSupportFunction(
    HCONN    hConn,
    DWORD    dwRequest,
    LPVOID   lpvBuffer,
    LPDWORD  lpdwSize,
    LPDWORD  lpdwDataType
    );

BOOL
WINAPI
SSIGetServerVariable(
    HCONN    hConn,
    LPSTR    lpszVariableName,
    LPVOID   lpvBuffer,
    LPDWORD  lpdwSize
    );

BOOL
WINAPI
SSIWriteClient(
    HCONN    hConn,
    LPVOID   Buffer,
    LPDWORD  lpdwBytes,
    DWORD    dwReserved
    );

BOOL
WINAPI
SSIReadClient(
    HCONN    hConn,
    LPVOID   Buffer,
    LPDWORD  lpdwBytes
    );

class BGI_INFO
{
public:
    EXTENSION_CONTROL_BLOCK     _ECB;

    SSI_REQUEST *               _pRequest;
    DWORD                       _cRef;
    HMODULE                     _hMod;
    HANDLE                      _hPendingEvent;

    // this variable should be "managed" internally

    STR                         _strQuery;
};

DWORD
InitializeBGI( VOID )
/*
Return Value:

    0 on success, win32 error on failure

--*/
{
    HKEY hkeyParam;

    //
    //  Check to see if we should cache extensions
    //

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hkeyParam ) == NO_ERROR )
    {
        fCacheExtensions = !!ReadRegistryDword( hkeyParam,
                                                W3_CACHE_EXTENSIONS,
                                                TRUE );
        RegCloseKey( hkeyParam );
    }

    fExtInitialized = TRUE;
    return NO_ERROR;
}

BOOL
ProcessBGI(
    IN SSI_REQUEST *        pRequest,
    IN STR *                pstrDLL,
    IN STR *                pstrQueryString
)
{
    BGI_INFO                BGIInfo;
    int                     iRet;
    PFN_HTTPEXTENSIONPROC   pfnSEProc;
    BOOL                    bBGIRet = FALSE;

    if ( !BGIInfo._strQuery.Copy( pstrQueryString->QueryStr() ) )
    {
        return FALSE;
    }

    memcpy( &(BGIInfo._ECB), pRequest->_pECB, sizeof( BGIInfo._ECB ) );
    BGIInfo._pRequest = pRequest;
    BGIInfo._cRef = 2;
    BGIInfo._hPendingEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( BGIInfo._hPendingEvent == NULL )
    {
        return FALSE;
    }
    BGIInfo._ECB.ServerSupportFunction = SSIServerSupportFunction;
    BGIInfo._ECB.GetServerVariable = SSIGetServerVariable;
    BGIInfo._ECB.WriteClient = SSIWriteClient;
    BGIInfo._ECB.ReadClient = SSIReadClient;
    BGIInfo._ECB.ConnID = (HCONN) &BGIInfo;
    BGIInfo._ECB.lpszQueryString = BGIInfo._strQuery.QueryStr();

    if ( !SEGetEntryPoint( pstrDLL->QueryStr(),
                           pRequest->_hUser,
                           &pfnSEProc,
                           &(BGIInfo._hMod) ) )
    {
        LPCTSTR apszParms[ 2 ];
        CHAR pszNumBuf[ SSI_MAX_NUMBER_STRING ];
        _ultoa( GetLastError(), pszNumBuf, 10 );
        apszParms[ 0 ] = pstrDLL->QueryStr();
        apszParms[ 1 ] = pszNumBuf;

        pRequest->SSISendError( SSINCMSG_CANT_LOAD_ISA_DLL,
                                apszParms );

        TCP_REQUIRE( CloseHandle( BGIInfo._hPendingEvent ) );

        return FALSE;
    }

    iRet = pfnSEProc( &(BGIInfo._ECB) );

    switch ( iRet )
    {
    case HSE_STATUS_PENDING:
        bBGIRet = TRUE;
        if ( !InterlockedDecrement( (LONG*) &BGIInfo._cRef ) )
        {
            // Already received a ServerSupportFunction( HSE_REQ_DONE.. )
            break;
        }
        // Wait for ISAPI app to ServerSupportFunction( HSE_REQ_DONE...)
        WaitForSingleObject( BGIInfo._hPendingEvent, INFINITE );
        break;
    case HSE_STATUS_SUCCESS_AND_KEEP_CONN:
    case HSE_STATUS_SUCCESS:
        bBGIRet = TRUE;
        break;        
    case HSE_STATUS_ERROR:
        bBGIRet = FALSE;
        break;
    default:
        bBGIRet = FALSE;
        break;
    }
    if ( !fCacheExtensions )
    {
        PFN_TERMINATEEXTENSION pfnTerminate;

        pfnTerminate = (PFN_TERMINATEEXTENSION) GetProcAddress(
                                                BGIInfo._hMod,
                                                SE_TERM_ENTRY );

        if ( pfnTerminate )
        {
            pfnTerminate( HSE_TERM_MUST_UNLOAD );
        }

        TCP_REQUIRE( FreeLibrary( BGIInfo._hMod ) );
    }

    TCP_REQUIRE( CloseHandle( BGIInfo._hPendingEvent ) );
    return bBGIRet;
}

BOOL
WINAPI
SSIServerSupportFunction(
    HCONN               hConn,
    DWORD               dwHSERequest,
    LPVOID              pData,
    LPDWORD             lpdwSize,
    LPDWORD             lpdwDataType
    )
{
    BGI_INFO *                  pBGIInfo;
    EXTENSION_CONTROL_BLOCK *   pSSIECB;
    SSI_REQUEST *               pRequest;

    pBGIInfo = (BGI_INFO*) hConn;
    pRequest = pBGIInfo->_pRequest;
    pSSIECB = pRequest->_pECB;

    switch ( dwHSERequest )
    {
    case HSE_REQ_SEND_URL_REDIRECT_RESP:
    {
        LPCTSTR apszParms[ 1 ];
        apszParms[ 0 ] = (CHAR*) pData;
        
        pRequest->SSISendError( SSINCMSG_CGI_REDIRECT_RESPONSE,
                                apszParms );
        break;
    }
    case HSE_REQ_SEND_URL:
    case HSE_REQ_SEND_URL_EX:
        LPCTSTR apszParms[ 1 ];
        apszParms[ 0 ] = (CHAR*) pData;

        pRequest->SSISendError( SSINCMSG_ISA_TRIED_SEND_URL,
                                apszParms );
        break;
    case HSE_REQ_DONE_WITH_SESSION:
        if ( !InterlockedDecrement( (LONG*) &(pBGIInfo->_cRef) ) )
        {
            SetEvent( pBGIInfo->_hPendingEvent );
        }
        break;
    case HSE_REQ_SEND_RESPONSE_HEADER:
        if ( lpdwDataType != NULL )
        {
            DWORD       cbSent;
            BYTE *      pbTextToSend;
            
            // only send the message to the client
            // but don't send any header info contained in message

            pbTextToSend = ScanForTerminator( (TCHAR*) lpdwDataType );
            pbTextToSend = ( pbTextToSend == NULL ) ? (BYTE*)lpdwDataType
                                                      : pbTextToSend;
            return pRequest->WriteToClient( pbTextToSend,
                                            strlen( (CHAR*) pbTextToSend ),
                                            &cbSent );
        }
        break;
    default:
        return pSSIECB->ServerSupportFunction( pSSIECB->ConnID,
                                               dwHSERequest,
                                               pData,
                                               lpdwSize,
                                               lpdwDataType );
    }
    return TRUE;
}

BOOL
WINAPI
SSIGetServerVariable(
    HCONN    hConn,
    LPSTR    lpszVariableName,
    LPVOID   lpvBuffer,
    LPDWORD  lpdwSize
)
{
    BGI_INFO *                  pBGIInfo;
    EXTENSION_CONTROL_BLOCK *   pSSIECB;
    DWORD                       cbBytes;

    pBGIInfo = (BGI_INFO*)hConn;
    pSSIECB = pBGIInfo->_pRequest->_pECB;

    if ( !strcmp( lpszVariableName, "QUERY_STRING" ) )
    {
        // intercept GetServerVariable() for QUERY_STRING and return the 
        // string as specified in #EXEC ISA="foo.dll?query_string"
        cbBytes = pBGIInfo->_strQuery.QueryCB() + sizeof( CHAR );
        *lpdwSize = cbBytes;
        memcpy( lpvBuffer, pBGIInfo->_strQuery.QueryStr(), cbBytes );
        return TRUE;
    }
    else
    {
        return pSSIECB->GetServerVariable( pSSIECB->ConnID,
                                           lpszVariableName,
                                           lpvBuffer,
                                           lpdwSize );
    }
}

BOOL
WINAPI
SSIWriteClient(
    HCONN    hConn,
    LPVOID   Buffer,
    LPDWORD  lpdwBytes,
    DWORD    dwReserved
)
{
    EXTENSION_CONTROL_BLOCK *   pSSIECB;

    pSSIECB = ((BGI_INFO*)hConn)->_pRequest->_pECB;

    return pSSIECB->WriteClient( pSSIECB->ConnID,
                                 Buffer,
                                 lpdwBytes,
                                 dwReserved );
}
    
BOOL
WINAPI
SSIReadClient(
    HCONN    hConn,
    LPVOID   Buffer,
    LPDWORD  lpdwBytes
)
{
    EXTENSION_CONTROL_BLOCK *   pSSIECB;

    pSSIECB = ((BGI_INFO*)hConn)->_pRequest->_pECB;

    return pSSIECB->ReadClient( pSSIECB->ConnID,
                                Buffer,
                                lpdwBytes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ssincold\ssicgi.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ssicgi.cxx

Abstract:

    This is CGI code "ripped" from \w3\server\cgi.cxx
    
Author:

    Bilal Alam (t-bilala)       5-June-1996

Revision History:

    See iis\svcs\w3\server\cgi.cxx for prior log

--*/

#include "ssinc.hxx"
#include "ssicgi.hxx"

typedef struct CgiEnvTableEntry_ {
    TCHAR* m_pszName;
    BOOL   m_fIsProcessEnv;
    UINT   m_cchNameLen;
    UINT   m_cchToCopy;     // will be non zero for var to copy from
                            // process environment. In this case m_pszName
                            // points to the environment entry to copy
                            // ( name + '=' + value + '\0' )
                            // otherwise this entry is to be accessed
                            // using GetInfo()
} CgiEnvTableEntry;


//
//  Environment variable block used for CGI
//
//  best if in alphabetical order ( the env list is easier to read )
//  but not mandatory.
//  Note that the "" ( accessed as HTTP_ALL ) will be expanded to a list
//  of unsorted entries, but this list as a whole will be considered to be
//  named "HTTP_ALL" for sorting order.
//

CgiEnvTableEntry CGIEnvTable[] =
{
    {TEXT("AUTH_TYPE"),FALSE},
    {TEXT("ComSpec"),TRUE},
    {TEXT("CONTENT_LENGTH"),FALSE},
    {TEXT("CONTENT_TYPE"),FALSE},
    {TEXT("GATEWAY_INTERFACE"),FALSE},
    {TEXT(""),FALSE},                   // Means insert all HTTP_ headers here
    {TEXT("LOGON_USER"),FALSE},
    {TEXT("PATH"),TRUE},
    {TEXT("PATH_INFO"),FALSE},
    {TEXT("PATH_TRANSLATED"),FALSE},
    {TEXT("QUERY_STRING"),FALSE},
    {TEXT("REMOTE_ADDR"),FALSE},
    {TEXT("REMOTE_HOST"),FALSE},
    {TEXT("REMOTE_USER"),FALSE},
    {TEXT("REQUEST_METHOD"),FALSE},
    {TEXT("SCRIPT_NAME"),FALSE},
    {TEXT("SERVER_NAME"),FALSE},
    {TEXT("SERVER_PORT"),FALSE},
    {TEXT("SERVER_PORT_SECURE"),FALSE},
    {TEXT("SERVER_PROTOCOL"),FALSE},
    {TEXT("SERVER_SOFTWARE"),FALSE},
    {TEXT("SystemRoot"),TRUE},
    {TEXT("UNMAPPED_REMOTE_USER"),FALSE},
    {TEXT("windir"),TRUE},
    {NULL,FALSE}
};

// 
// Globals
//

BOOL fAllowSpecialCharsInShell = FALSE;
BOOL fCreateProcessAsUser = TRUE;
BOOL fCreateProcessWithNewConsole = FALSE;
BOOL fForwardServerEnvironmentBlock = TRUE;
LPSTR  g_pszIisEnv = NULL;
CgiEnvTableEntry *g_pEnvEntries = NULL;
DWORD dwTimeOut = 0;
BOOL fInitialized = FALSE;

class CGI_INFO
{
public:
    CGI_INFO( SSI_REQUEST * pRequest )
        : _pRequest         ( pRequest ),
          _cbData           ( 0 ),
          _hStdOut          ( INVALID_HANDLE_VALUE ),
          _hStdIn           ( INVALID_HANDLE_VALUE ),
          _hProcess         ( INVALID_HANDLE_VALUE ),
          _fShutdown        ( FALSE )
    {
        _hResponseEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    }

    ~CGI_INFO( VOID )
    {
        if ( _hStdOut != INVALID_HANDLE_VALUE )
        {
            if ( !::CloseHandle( _hStdOut ))
            {
                TCP_PRINT((DBG_CONTEXT,
                          "[~CGI_INFO] CloseHandle failed on StdIn, %d\n",
                           GetLastError()));
            }
        }

        if ( _hStdIn != INVALID_HANDLE_VALUE )
        {
            if ( !::CloseHandle( _hStdIn ))
            {
                TCP_PRINT((DBG_CONTEXT,
                          "[~CGI_INFO] CloseHandle failed on StdIn, %d\n",
                           GetLastError()));
            }
        }

        if ( _hProcess != INVALID_HANDLE_VALUE )
        {
            if ( !::CloseHandle( _hProcess ))
            {
                TCP_PRINT((DBG_CONTEXT,
                          "[~CGI_INFO] CloseHandle failed on Process, %d\n",
                           GetLastError()));
            }
        }
        if ( _hResponseEvent != NULL )
        {
            if ( !::CloseHandle( _hResponseEvent ))
            {
                TCP_PRINT((DBG_CONTEXT,
                          "[~CGI_INFO] CloseHandle failed on Process, %d\n",
                           GetLastError()));
            }
        }
    }

    SSI_REQUEST *   _pRequest;

    //
    //  Child process
    //

    HANDLE          _hProcess;

    //
    //  Parent's input and output handles and child's process handle
    //

    HANDLE          _hStdOut;
    HANDLE          _hStdIn;

    //
    //  Handles input from CGI (headers and additional data)
    //

    BUFFER          _Buff;
    UINT            _cbData;

    //
    //  Event to check for hanging processes
    //  and thread shutdown flag
    //

    HANDLE          _hResponseEvent;
    BOOL            _fShutdown;
};

//
// Prototypes
//

BOOL
ProcessCGI(
    SSI_REQUEST *       pRequest,
    const STR *         pstrPath,
    const STR *         pstrURLParams,
    const STR *         pstrWorkingDir,
    STR       *         pstrCmdLine
    );

BOOL SetupChildEnv( SSI_REQUEST * pRequest,
                    BUFFER       * pBuff );

BOOL SetupChildPipes( STARTUPINFO * pstartupinfo,
                      HANDLE      * phParentIn,
                      HANDLE      * phParentOut );

BOOL SetupCmdLine( STR * pstrCmdLine,
                   const STR & strParams );

DWORD CGIThread( PVOID Param );

BOOL ProcessCGIInput( CGI_INFO * pCGIInfo,
                      BYTE     * buff,
                      DWORD      cbRead,
                      BOOL     * pfReadHeaders );

BOOL CheckForTermination( BOOL   * pfTerminated,
                          BUFFER * pbuff,
                          UINT     cbData,
                          BYTE * * ppbExtraData,
                          DWORD *  pcbExtraData,
                          UINT     cbReallocSize );
BOOL
FastScanForTerminator(
    CHAR *  pch,
    UINT    cbData
    );

DWORD
InitializeCGI( 
    VOID 
    );

VOID 
TerminateCGI( 
    VOID 
    );

//
// End of prototypes
//

DWORD
ReadRegistryDword(
    IN HKEY         hkey,
    IN LPSTR        pszValueName,
    IN DWORD        dwDefaultValue
)
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

#ifndef CHICAGO
    if ( hkey != NULL )
    {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if ( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDefaultValue = dwBuffer;
        }
    }
#else
    if ( hkey != NULL )
    {

        err = RegQueryValueEx( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if ( ( err == NO_ERROR )  )
        {
            dwDefaultValue = dwBuffer;
        }
    }
#endif
    return dwDefaultValue;
}   // ReadRegistryDword()

extern "C" int __cdecl 
QsortEnvCmp( 
    const void *pA, 
    const void *pB )
/*++

Routine Description:

    Compare CgiEnvTableEntry using their name entry

Arguments:

    pA - pointer to 1st entry
    pB - pointer to 2nd entry

Returns:

    -1 if 1st entry comes first in sort order,
    0 if identical
    1 if 2nd entry comes first

--*/
{
    LPSTR p1 = ((CgiEnvTableEntry*)pA)->m_pszName;
    LPSTR p2 = ((CgiEnvTableEntry*)pB)->m_pszName;

    if ( ! p1[0] )
    {
        p1 = "HTTP_ALL";
    }

    if ( ! p2[0] )
    {
        p2 = "HTTP_ALL";
    }

    return _stricmp( p1, p2 );
}

DWORD
InitializeCGI( 
    VOID 
    )
/*++

Routine Description:

    Initialize CGI


Arguments:

    None

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    LPVOID               pvEnv;
    UINT                 cchStr;
    UINT                 cchIisEnv;
    UINT                 cEnv;
    INT                  chScanEndOfName;
    CgiEnvTableEntry   * pCgiEnv; 
    HKEY                 hkeyParam;
                        

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hkeyParam ) == NO_ERROR )
    {
        fAllowSpecialCharsInShell = !!ReadRegistryDword( hkeyParam,
                                                "AllowSpecialCharsInShell",
                                                FALSE );

        fForwardServerEnvironmentBlock = !!ReadRegistryDword( 
                hkeyParam,
                "ForwardServerEnvironmentBlock",
                TRUE );

        fCreateProcessAsUser = !!ReadRegistryDword( hkeyParam,
                                                    "CreateProcessAsUser",
                                                    TRUE );

        fCreateProcessWithNewConsole = !!ReadRegistryDword( hkeyParam,
                "CreateProcessWithNewConsole",
                FALSE );

        dwTimeOut = ReadRegistryDword( hkeyParam,
                                       "ScriptTimeOut",
                                       SSI_CGI_DEF_TIMEOUT );
        if ( dwTimeOut >= ((DWORD)-1)/1000 )
        {
            dwTimeOut = (DWORD)-1;
        }
        else
        {
            dwTimeOut *= 1000;
        }

        RegCloseKey( hkeyParam );
    }

    if ( fForwardServerEnvironmentBlock 
            && (pvEnv = GetEnvironmentStrings()) )
    {
        //
        // Compute length of environment block and # of variables
        // ( excluding block delimiter )
        //
        
        cchIisEnv = 0;
        cEnv = 0;

        while ( cchStr = strlen( ((PSTR)pvEnv) + cchIisEnv ) )
        {
            cchIisEnv += cchStr + 1;
            ++cEnv;
        }

        //
        // store it
        //

        if ( (g_pszIisEnv = (LPSTR)LocalAlloc( 
                LMEM_FIXED, cchIisEnv * sizeof(TCHAR))) == NULL )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy( g_pszIisEnv, pvEnv, 
                cchIisEnv * sizeof(TCHAR) );

        FreeEnvironmentStrings( (LPTSTR)pvEnv );

        pvEnv = (PVOID)g_pszIisEnv;

        if ( g_pEnvEntries = new CgiEnvTableEntry [ 
                cEnv + sizeof(CGIEnvTable)/sizeof(CgiEnvTableEntry) ] )
        {
            cchIisEnv = 0;
            cEnv = 0;

            //
            // add process environment to table
            //

            while ( cchStr = strlen( ((PSTR)pvEnv) + cchIisEnv ) )
            {
                g_pEnvEntries[ cEnv ].m_pszName = ((PSTR)pvEnv) + cchIisEnv;
                g_pEnvEntries[ cEnv ].m_fIsProcessEnv = TRUE;

                // compute length of name : up to '=' char

                for ( g_pEnvEntries[ cEnv ].m_cchNameLen = 0 ;
                    ( chScanEndOfName = g_pEnvEntries[ cEnv ].m_pszName
                        [ g_pEnvEntries[ cEnv ].m_cchNameLen ] )
                    && chScanEndOfName != '=' ; )
                {
                    ++g_pEnvEntries[ cEnv ].m_cchNameLen;
                }

                g_pEnvEntries[ cEnv ].m_cchToCopy = cchStr + 1;

                cchIisEnv += cchStr + 1;
                ++cEnv;
            }

            //
            // add CGI environment variables to table
            //

            for ( pCgiEnv = CGIEnvTable ; pCgiEnv->m_pszName ; ++pCgiEnv )
            {
                if ( !pCgiEnv->m_fIsProcessEnv )
                {
                    memcpy( g_pEnvEntries + cEnv, pCgiEnv, 
                            sizeof(CgiEnvTableEntry) );
                    g_pEnvEntries[ cEnv ].m_cchNameLen 
                            = strlen( pCgiEnv->m_pszName );
                    g_pEnvEntries[ cEnv ].m_cchToCopy = 0;
                    ++cEnv;
                }
            }

            //
            // add delimiter entry
            //

            g_pEnvEntries[ cEnv ].m_pszName = NULL;
            
            qsort( g_pEnvEntries, 
                    cEnv, 
                    sizeof(CgiEnvTableEntry), 
                    QsortEnvCmp );
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        g_pEnvEntries = CGIEnvTable;
    }

    fInitialized = TRUE;

    return NO_ERROR;
}


VOID 
TerminateCGI( 
    VOID 
    )
/*++

Routine Description:

    Terminate CGI


Arguments:

    None

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if (g_pszIisEnv != NULL )
    {
        LocalFree( g_pszIisEnv );
        g_pszIisEnv = NULL;
    }

    if ( g_pEnvEntries && g_pEnvEntries != CGIEnvTable )
    {
        delete [] g_pEnvEntries;
        g_pEnvEntries = NULL;
    }
    fInitialized = FALSE;
}

BOOL
ProcessCGI(
    SSI_REQUEST *       pRequest,
    const STR *         pstrPath,
    const STR *         pstrURLParams,
    const STR *         pstrWorkingDir,
    STR       *         pstrCmdLine
    )
/*++

Routine Description:

    Processes a CGI client request

Arguments:

    pRequest - SSI_REQUEST struct used to access ISAPI utilities
    pstrPath - Fully qualified path to executable (or NULL if the module
        is contained in pstrCmdLine)
    pstrURLParams - Parameter list for command (or NULL if the parms
        are specified in pstrCmdLine)
    strWorkingDir - Working directory for spawned process
        (generally the web root).  Can be NULL -> then CWD of command is used
    pstrCmdLine - Optional command line to use instead of the default

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    STARTUPINFO          startupinfo;
    PROCESS_INFORMATION  processinfo;
    BUFFER               buffEnv;
    BOOL                 fRet = FALSE;
    CGI_INFO           * pCGIInfo = NULL;
    DWORD                dwThreadId;
    HANDLE               hThread;
    STR                  strCmdLine;
    DWORD                dwFlags = DETACHED_PROCESS | CREATE_SEPARATE_WOW_VDM;
    DWORD                dwThreadCode;

    TCP_ASSERT( fInitialized );

    if ( !SetupChildEnv( pRequest,
                        &buffEnv ) )
    {
        LPCTSTR apszParms[ 1 ];
        CHAR pszNumBuf[ SSI_MAX_NUMBER_STRING ];
        _ultoa( GetLastError(), pszNumBuf, 10 );
        apszParms[ 0 ] = pszNumBuf;
        
        pRequest->SSISendError( SSINCMSG_CANT_SETUP_CHILD_ENV,
                                apszParms );

        return FALSE;
    } 

    if ( pstrCmdLine == NULL )
    {
        if ( !strCmdLine.Resize( SSI_MAX_PATH + 1 ) ||
             !strCmdLine.Copy( "\"" )       ||
             !strCmdLine.Append( pstrPath ? pstrPath->QueryStr() :
                                            NULL )   ||
             !strCmdLine.Append( "\" " ))
        {
            return FALSE;
        }
        if ( !SetupCmdLine( &strCmdLine,
                        *pstrURLParams ))
        {
            return FALSE;
        }
        pstrCmdLine = &strCmdLine;
    }

    TCP_ASSERT( pstrCmdLine != NULL );

    //
    //  Check to see if we're spawning cmd.exe, if so, refuse the request if
    //  there are any special shell characters.  Note we do the check here
    //  so that the command line has been fully unescaped
    //

    if ( !fAllowSpecialCharsInShell )
    {
        DWORD i;

        if ( strstr( pstrCmdLine->QueryStr(), "cmd.exe" ))
        {
            //
            //  We'll either match one of the characters or the '\0'
            //

            i = strcspn( pstrCmdLine->QueryStr(), "&|(,;%" );

            if ( pstrCmdLine->QueryStr()[i] )
            {
                TCP_PRINT(( DBG_CONTEXT,
                            "[ProcessCGI] Refusing request for command shell due "
                            " to special characters\n" ));
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
        }
    }

    //
    //  Setup the pipes information
    //

    pCGIInfo = new CGI_INFO( pRequest );

    if ( !pCGIInfo )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    memset( &startupinfo, 0, sizeof(startupinfo) );
    startupinfo.cb = sizeof(startupinfo);

    //
    //  We specify an unnamed desktop so a new windowstation will be created
    //  in the context of the calling user
    //

    startupinfo.lpDesktop = "";

    if ( !SetupChildPipes( &startupinfo,
                           &pCGIInfo->_hStdIn,
                           &pCGIInfo->_hStdOut ) )
    {
        LPCTSTR apszParms[ 1 ];
        CHAR pszNumBuf[ SSI_MAX_NUMBER_STRING ];
        _ultoa( GetLastError(), pszNumBuf, 10 );
        apszParms[ 0 ] = pszNumBuf;
        
        pRequest->SSISendError( SSINCMSG_CANT_SETUP_CHILD_PIPES,
                                apszParms );
        goto Exit;
    }

    if ( fCreateProcessWithNewConsole )
    {
        dwFlags = CREATE_NEW_CONSOLE | CREATE_SEPARATE_WOW_VDM;
    }

    //
    //  Spawn the process and close the handles since we don't need them
    //

TryAgain:

    fRet = CreateProcess( pstrPath ? pstrPath->QueryStr() : NULL,
                          pstrCmdLine->QueryStr(),
                          NULL,      // Process security
                          NULL,      // Thread security
                          TRUE,      // Inherit handles
                          dwFlags,
                          buffEnv.QueryPtr(),
                          pstrWorkingDir != NULL ?
                                pstrWorkingDir->QueryStr() : NULL,
                          &startupinfo,
                          &processinfo );

    //
    //  If we get access denied this may be a 16 bit app, so try again w/o
    //  the process detached flag
    //

    if ( !fRet &&
        (GetLastError() == ERROR_ACCESS_DENIED ||
         GetLastError() == ERROR_INVALID_HANDLE ) &&
         (dwFlags & DETACHED_PROCESS) )
    {
        dwFlags &= ~DETACHED_PROCESS;
        goto TryAgain;
    }

    TCP_REQUIRE( CloseHandle( startupinfo.hStdOutput ) );
    TCP_REQUIRE( CloseHandle( startupinfo.hStdInput ) );

    if ( !fRet )
    {
        LPCTSTR apszParms[ 2 ];
        CHAR pszNumBuf[ SSI_MAX_NUMBER_STRING ];
        DWORD dwError = GetLastError();
        _ultoa( dwError, pszNumBuf, 10 );
        apszParms[ 0 ] = pstrCmdLine->QueryStr(),
        apszParms[ 1 ] = pszNumBuf;
        
        pRequest->SSISendError( SSINCMSG_CANT_CREATE_PROCESS,
                                apszParms );
        
        TCP_PRINT((DBG_CONTEXT,
                  "[ProcessCGI] Create process failed, error %d, exe = %s, cmd line = %s\n",
                   GetLastError(),
                   (pstrPath ? pstrPath->QueryStr() : "null"),
                   (pstrCmdLine ? pstrCmdLine->QueryStr() : "null") ));
        goto Exit;
    }

    TCP_REQUIRE( CloseHandle( processinfo.hThread ) );
    TCP_ASSERT( startupinfo.hStdError == startupinfo.hStdOutput);

    //
    //  Save the process handle in case we need to terminate it later on
    //

    pCGIInfo->_hProcess = processinfo.hProcess;

    //
    //  Create a thread to handle IO with the child process
    //

    if ( !(hThread = CreateThread( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) CGIThread,
                                   pCGIInfo,
                                   0,
                                   &dwThreadId )))
    {
        goto Exit;
    }

    //
    //  Here is a crude method of finding runaway/hanging processes
    //

    DWORD dwWaitRes;
    while ( !pCGIInfo->_fShutdown )
    {
        dwWaitRes = WaitForSingleObject( pCGIInfo->_hResponseEvent,
                                         dwTimeOut );
        if ( dwWaitRes == WAIT_OBJECT_0 )
        {
            // got signal in time
            continue;
        }
        else if ( dwWaitRes == WAIT_TIMEOUT )
        {
            // process dead?  Terminating should will cause thread to quit
            TerminateProcess( processinfo.hProcess,
                              SSI_KILLED_PROCESS );

            LPCTSTR apszParms[ 1 ];
            apszParms[ 0 ] = pstrCmdLine->QueryStr();

            pRequest->SSISendError( SSINCMSG_PROCESS_TIMEOUT,
                                    apszParms );
            
            break;
        }
    }

    WaitForSingleObject( hThread, INFINITE );

    if ( !GetExitCodeThread( hThread,
                             &dwThreadCode ) ||
         !dwThreadCode )
    {
        fRet = FALSE;
    }

    TCP_REQUIRE( CloseHandle( hThread ) );

Exit:
    delete pCGIInfo;

    return fRet;
}

/*******************************************************************

    NAME:       SetupChildPipes

    SYNOPSIS:   Creates/duplicates pipes for redirecting stdin and
                stdout to a child process

    ENTRY:      pstartupinfo - pointer to startup info structure, receives
                    child stdin and stdout handles
                phParentIn - Pipe to use for parent reading
                phParenOut - Pipe to use for parent writing

    RETURNS:    TRUE if successful, FALSE on failure

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

BOOL SetupChildPipes( STARTUPINFO * pstartupinfo,
                      HANDLE      * phParentIn,
                      HANDLE      * phParentOut )

{
    SECURITY_ATTRIBUTES sa;

    *phParentIn  = NULL;
    *phParentOut = NULL;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = TRUE;

    pstartupinfo->dwFlags = STARTF_USESTDHANDLES;

    //
    //  Create the pipes then mark them as not inheritted in the
    //  DuplicateHandle to prevent handle leaks
    //

    if ( !CreatePipe( phParentIn,
                      &pstartupinfo->hStdOutput,
                      &sa,
                      0 ) ||
         !DuplicateHandle( GetCurrentProcess(),
                           *phParentIn,
                           GetCurrentProcess(),
                           phParentIn,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS |
                           DUPLICATE_CLOSE_SOURCE) ||
         !CreatePipe( &pstartupinfo->hStdInput,
                      phParentOut,
                      &sa,
                      0 ) ||
         !DuplicateHandle( GetCurrentProcess(),
                           *phParentOut,
                           GetCurrentProcess(),
                           phParentOut,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS |
                           DUPLICATE_CLOSE_SOURCE ))
    {
        goto ErrorExit;
    }

    //
    //  Stdout and Stderror will use the same pipe.  If clients tend
    //  to close stderr, then we'll have to duplicate the handle
    //

    pstartupinfo->hStdError = pstartupinfo->hStdOutput;

    return TRUE;

ErrorExit:
    if ( *phParentIn )
        TCP_REQUIRE( CloseHandle( *phParentIn ));

    if ( *phParentOut )
        TCP_REQUIRE( CloseHandle( *phParentOut ));

    return FALSE;

}

/*******************************************************************

    NAME:       SetupChildEnv

    SYNOPSIS:   Based on the passed pRequest, builds a CGI environment block

    ENTRY:      pRequest - HTTP request object
                pBuff - Buffer to receive environment block

    RETURNS:    TRUE if successful, FALSE on failure

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

BOOL SetupChildEnv( SSI_REQUEST * pRequest,
                    BUFFER       * pBuff )
{
    TCHAR * pch, *pchtmp;
    STR     strVal;
    UINT    cchCurrentPos = 0;      // Points to '\0' in buffer
    UINT    cchName, cchValue;
    UINT    cbNeeded;
    int     i = 0;

    if ( !pBuff->Resize( 1500 * sizeof(TCHAR) ))
    {
        return FALSE;
    }

    //
    //  Build the environment block for CGI
    //

    while ( g_pEnvEntries[i].m_pszName )
    {
        //
        // Check if this is a copy entry from process environment
        //

        if ( g_pEnvEntries[i].m_cchToCopy )
        {
            if ( !pBuff->Resize( (cchCurrentPos + g_pEnvEntries[i].m_cchToCopy)
                    * sizeof(TCHAR) ) )
            {
                return FALSE;
            }

            pch = (TCHAR *) pBuff->QueryPtr();

            memcpy( pch + cchCurrentPos, 
                    g_pEnvEntries[i].m_pszName,
                    g_pEnvEntries[i].m_cchToCopy );

            cchCurrentPos += g_pEnvEntries[i].m_cchToCopy;

            ++i;
            continue;
        }

        //
        //  The NULL string means we're adding all of
        //  the HTTP header fields which requires a little
        //  bit of special processing
        //

        if ( !*g_pEnvEntries[i].m_pszName )
        {
            pch = "ALL_HTTP";
        }
        else
        {
            pch = g_pEnvEntries[i].m_pszName;
        }

        if ( !pRequest->GetVariable( pch,
                                    &strVal ) )
        {
            return FALSE;
        }
        
        cchName = _tcslen( g_pEnvEntries[i].m_pszName );
        cchValue = strVal.QueryCCH();

        //
        //  We need space for the terminating '\0' and the '='
        //

        cbNeeded = ( cchName + cchValue + 1 + 1) * sizeof(TCHAR);

        if ( !pBuff->Resize( cchCurrentPos * sizeof(TCHAR) + cbNeeded,
                             512 ))
        {
            return FALSE;
        }

        //
        //  Replace the '\n' with a '\0' as needed
        //  for the HTTP headers
        //

        if ( !*g_pEnvEntries[i].m_pszName )
        {
            pchtmp = strVal.QueryStr();

            //
            //  Convert the first ':' of each header to to an '=' for the
            //  environment table
            //

            while ( pchtmp = strchr( pchtmp, ':' ))
            {
                *pchtmp = '=';

                if ( !(pchtmp = strchr( pchtmp, '\n' )))
                {
                    break;
                }
            }

            pchtmp = strVal.QueryStr();

            while ( pchtmp = strchr( pchtmp+1, '\n' ))
            {
                *pchtmp = '\0';
            }
        }

        pch = (TCHAR *) pBuff->QueryPtr();

        if ( *g_pEnvEntries[i].m_pszName )
        {
            if ( strVal.QueryStr()[0] )
            {
                memcpy( pch + cchCurrentPos,
                        g_pEnvEntries[i].m_pszName,
                        cchName * sizeof(TCHAR));

                *(pch + cchCurrentPos + cchName) = '=';

                memcpy( pch + cchCurrentPos + cchName + 1,
                        strVal.QueryStr(),
                        (cchValue + 1) * sizeof(TCHAR));

                cchCurrentPos += cchName + cchValue + 1 + 1;
            }
        }
        else
        {
            memcpy( pch + cchCurrentPos + cchName,
                    strVal.QueryStr(),
                    (cchValue + 1) * sizeof(TCHAR));

            cchCurrentPos += cchName + cchValue;
        }

        i++;
    }

    //
    //  Add a '\0' terminator to the environment list
    //

    if ( !pBuff->Resize( (cchCurrentPos + 1) * sizeof(TCHAR)))
    {
        return FALSE;
    }

    *((TCHAR *) pBuff->QueryPtr() + cchCurrentPos) = TEXT('\0');

    return TRUE;
}

/*******************************************************************

    NAME:       SetupCmdLine

    SYNOPSIS:   Sets up a CGI command line

    ENTRY:      pstrCmdLine - Receives command line
                strParams - Parameters following "?" in URL

    HISTORY:
        Johnl       04-Oct-1994 Created

********************************************************************/

BOOL SetupCmdLine( STR * pstrCmdLine,
                   const STR & strParams )
{
    TCHAR * pch;

    //
    //  If an unencoded "=" is found, don't use the command line
    //  (some weird CGI rule)
    //

    if ( _tcschr( strParams.QueryStr(),
                  TEXT('=') ))
    {
        return TRUE;
    }

    //
    //  Replace "+" with spaces and decode any hex escapes
    //

    if ( !pstrCmdLine->Append( strParams ) )
        return FALSE;

    while ( pch = _tcschr( pstrCmdLine->QueryStr(),
                           TEXT('+') ))
    {
        *pch = TEXT(' ');
        pch++;
    }

    return pstrCmdLine->Unescape();
}

/*******************************************************************

    NAME:       CGIThread

    SYNOPSIS:   Sends any gateway data to the scripts stdin and forwards
                the script's stdout to the client through ISAPI

    ENTRY:      Param - Pointer to CGI_INFO structure

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/

DWORD CGIThread( PVOID Param )
{
    CGI_INFO     * pCGIInfo = (CGI_INFO *) Param;
    SSI_REQUEST *  pRequest = pCGIInfo->_pRequest;
    BYTE           buff[2048];
    DWORD          cbRead;
    DWORD          dwExitCode;
    DWORD          err;
    BOOL           fReadHeaders = FALSE;
    BOOL           fRet = TRUE;
    BOOL           fSuccess = TRUE;
    
    //
    //  Now wait for any data the child sends to its stdout or for the
    //  process to exit
    //

    //
    //  Handle input from child
    //

    while (TRUE)
    {
        fRet = ::ReadFile( pCGIInfo->_hStdIn,
                           buff,
                           sizeof(buff),
                           &cbRead,
                           NULL );

        //
        // Let the calling thread know that the process
        // is still responding
        //

        SetEvent( pCGIInfo->_hResponseEvent );

        if ( !fRet )
        {
            err = GetLastError();
            if ( err == ERROR_BROKEN_PIPE )
            {
                break;
            }
            fSuccess = FALSE;
            TCP_PRINT((DBG_CONTEXT,
                       "[CGI_THREAD] ReadFile from child stdout failed, error %d, _hStdIn = %x\n",
                       GetLastError(),
                       pCGIInfo->_hStdIn));
            break;
        }

        //
        //  If no bytes were read, assume the file has been closed so
        //  get out
        //

        if ( !cbRead )
        {
            break;
        }

        //
        //  The CGI script can specify headers to include in the
        //  response.  Wait till we receive all of the headers.
        //

        if ( !fReadHeaders )
        {
            if ( !ProcessCGIInput( pCGIInfo,
                                   buff,
                                   cbRead,
                                   &fReadHeaders ) )
            {
                TCP_PRINT((DBG_CONTEXT,
                          "[CGIThread] ProcessCGIInput failed with error %d\n",
                           GetLastError()));
                fSuccess = FALSE;
                break;
            }

            //
            //  Either we are waiting for the rest of the header or
            //  we've sent the header and any residual data so wait
            //  for more data
            //

            continue;
        }


        if ( !pRequest->WriteToClient( buff,
                                      cbRead,
                                      &cbRead ) )
        {
            fSuccess = FALSE;
            break;
        }
    }

    //
    //  If we had to kill the process, log an error message
    //

    if ( GetExitCodeProcess( pCGIInfo->_hProcess,
                             &dwExitCode )  &&
         dwExitCode == SSI_KILLED_PROCESS )
    {
        TCP_PRINT((DBG_CONTEXT,
                  "[CGI_THREAD] - Spawned process hung\n" ));
        fSuccess = FALSE;
    }
    else
    {
        if ( !fReadHeaders )
        {
            DWORD cbSent;

            //
            // If we never read any headers, thats OK since were just
            // including the CGI output into HTML stream.
            //

            if( !pRequest->WriteToClient( pCGIInfo->_Buff.QueryPtr(),
                                          pCGIInfo->_cbData,
                                          &cbSent ) )
            {
                fSuccess = FALSE;
            }
        }
    }

    pCGIInfo->_fShutdown = TRUE;
    SetEvent( pCGIInfo->_hResponseEvent );

    return fSuccess;
}

/*******************************************************************

    NAME:       ProcessCGIInput

    SYNOPSIS:   Handles headers the CGI program hands back to the server

    ENTRY:      pCGIInfo - Pointer to CGI structure
                buff - Pointer to data just read
                cbRead - Number of bytes read into buff
                pfReadHeaders - Set to TRUE after we've finished processing
                    all of the HTTP headers the CGI script gave us

    HISTORY:
        Johnl       22-Sep-1994 Created

********************************************************************/


BOOL ProcessCGIInput( CGI_INFO * pCGIInfo,
                      BYTE     * buff,
                      DWORD      cbRead,
                      BOOL     * pfReadHeaders )
{
    CHAR *          pchValue;
    CHAR *          pchField;
    BYTE *          pbData;
    DWORD           cbData;
    DWORD           cbSent;
    BOOL            fFoundStatus = FALSE;
    SSI_REQUEST *   pRequest = pCGIInfo->_pRequest;

    TCP_ASSERT( cbRead > 0 );

    if ( !pCGIInfo->_Buff.Resize( pCGIInfo->_cbData + cbRead,
                                  256 ))
    {
        return FALSE;
    }

    memcpy( (BYTE *)pCGIInfo->_Buff.QueryPtr() + pCGIInfo->_cbData,
            buff,
            cbRead );

    pCGIInfo->_cbData += cbRead;

    //
    //  The end of CGI headers are marked by a blank line, check to see if
    //  we've hit that line
    //

    if ( !CheckForTermination( pfReadHeaders,
                               &pCGIInfo->_Buff,
                               pCGIInfo->_cbData,
                               &pbData,
                               &cbData,
                               256 ))
    {
        return FALSE;
    }

    if ( !*pfReadHeaders )
        return TRUE;

    //
    //  We've found the end of the headers, process them and look for
    //  Location: xxxx 
    //  URI: xxxx
    //
    //  In both cases, send a redirect message to HTML stream
    //  For all other headers, simply ignore them (i.e. dont send them)  
    //

    INET_PARSER Parser( (CHAR *) pCGIInfo->_Buff.QueryPtr() );
    while ( *(pchField = Parser.QueryToken()) )
    {
        Parser.SkipTo( ':' );
        Parser += 1;
        pchValue = Parser.QueryToken();

        if ( !::_strnicmp( "Location", pchField, 8 ) ||
             !::_strnicmp( "URI", pchField, 3 ))
        {
            //
            //  The CGI script is redirecting us to another URL.
            //  Just insert into HTML stream a message indicating this
            //  redirection
            //

            STR strURL( pchValue );
            STR strString;
            STR strResp;
            int iLen;

            if ( !strString.LoadString( SSINCMSG_CGI_REDIRECT_RESPONSE,
                                SSI_DLL_NAME ) )
            {
                return FALSE;
            }

            if ( !strResp.Resize( SSI_MAX_ERROR_MESSAGE + 1 ) )
            {
                return FALSE;
            }

            iLen = _snprintf( strResp.QueryStr(),
                              SSI_MAX_ERROR_MESSAGE + 1,
                              strString.QueryStr(),
                              strURL.QueryStr() );

            if ( !pRequest->WriteToClient( strResp.QueryStr(),
                                          iLen,
                                          (DWORD*) &iLen ) )
            {
                return FALSE;
            }
        }
        Parser.NextLine();
    }

    //
    //  If there was additional data in the buffer, send that out now
    //

    if ( cbData )
    {
        if ( !pRequest->WriteToClient( pbData,
                                       cbData,
                                       &cbSent ) )
        {
            return FALSE;
        }
    }
    return TRUE; 
}

/*******************************************************************

    NAME:       ::CheckForTermination

    SYNOPSIS:   Looks in the passed buffer for a line followed by a blank
                line.  If not found, the buffer is resized.

    ENTRY:      pfTerminted - Set to TRUE if this block is terminated
                pbuff - Pointer to buffer data
                cbData - Size of pbuff
                ppbExtraData - Receives a pointer to the first byte
                    of extra data following the header
                pcbExtraData - Number of bytes in data following the header
                cbReallocSize - Increase buffer by this number of bytes
                    if the terminate isn't found

    RETURNS:    TRUE if successful, FALSE otherwise

    HISTORY:
        Johnl       28-Sep-1994 Created

********************************************************************/

BOOL CheckForTermination( BOOL   * pfTerminated,
                          BUFFER * pbuff,
                          UINT     cbData,
                          BYTE * * ppbExtraData,
                          DWORD *  pcbExtraData,
                          UINT     cbReallocSize )
{
    //
    //  Terminate the string but make sure it will fit in the
    //  buffer
    //

    if (  !pbuff->Resize(cbData + 1, cbReallocSize ) )
    {
        return FALSE;
    }

    CHAR * pchReq = (CHAR *) pbuff->QueryPtr();
    *(pchReq + cbData) = '\0';

    //
    //  Scan for double end of line marker
    //

    //
    // if do not care for ptr info, can use fast method
    //

    if ( ppbExtraData == NULL )
    {
        if ( FastScanForTerminator( pchReq, cbData )
                || ScanForTerminator( pchReq ) )
        {
            *pfTerminated = TRUE;
            return TRUE;
        }
        goto not_term;
    }

    *ppbExtraData = ScanForTerminator( pchReq );

    if ( *ppbExtraData )
    {
        *pcbExtraData = cbData - (*ppbExtraData - (BYTE *) pchReq);
        *pfTerminated = TRUE;
        return TRUE;
    }

not_term:

    *pfTerminated = FALSE;

    //
    //  We didn't find the end so increase our buffer size
    //  in anticipation of more data
    //

    return pbuff->Resize( cbData + cbReallocSize );
}

BOOL
FastScanForTerminator(
    CHAR *  pch,
    UINT    cbData
    )
/*++

Routine Description:

    Check if buffer contains a full HTTP header.
    Can return false negatives.

Arguments:

    pch - request buffer
    cbData - # of bytes in pch, excluding trailing '\0'

Return Value:

    TRUE if buffer contains a full HTTP header
    FALSE if could not insure this, does not mean there is
    no full HTTP header.

--*/
{
    if ( cbData > 4 )
    {
        if ( !memcmp(pch+cbData-sizeof("\r\n\r\n")+1, "\r\n\r\n", sizeof("\r\n\r\n")-1  )
            || !memcmp(pch+cbData-sizeof("\n\n")+1, "\n\n", sizeof("\n\n")-1  ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*******************************************************************

    NAME:       ::SkipWhite

    SYNOPSIS:   Skips white space starting at the passed point in the string
                and returns the next non-white space character.

    HISTORY:
        Johnl       23-Aug-1994 Created

********************************************************************/

CHAR * SkipWhite( CHAR * pch )
{
    while ( ISWHITEA( *pch ) )
    {
        pch++;
    }

    return pch;
}


BYTE *
ScanForTerminator(
    TCHAR * pch
    )
/*++

Routine Description:

    Returns the first byte of data after the header

Arguments:

    pch - Zero terminated buffer

Return Value:

    Pointer to first byte of data after the header or NULL if the
    header isn't terminated

--*/
{
    while ( *pch )
    {
        if ( !(pch = strchr( pch, '\n' )))
        {
            break;
        }

        //
        //  If we find an EOL, check if the next character is an EOL character
        //

        if ( *(pch = SkipWhite( pch + 1 )) == W3_EOL )
        {
            return (BYTE *) pch + 1;
        }
        else if ( *pch )
        {
            pch++;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\common\cgi.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      cgi.h

   Abstract:
      This header declares constants used by CGI implementations.

   Author:

       Murali R. Krishnan    ( MuraliK )    19-June-1995

   Environment:
       Win32 -- User Mode

   Project:
   
       CGI Implementations for W3

   Revision History:

--*/

# ifndef _MSCGI_H_
# define _MSCGI_H_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Constants  
 ************************************************************/

//
// Define various environment strings that may be used by CGI interfaces
//

// ANSI values

# define PSZ_AUTH_TYPE_A                  "AUTH_TYPE"
# define PSZ_COM_SPEC_A                   "ComSpec"
# define PSZ_GATEWAY_INTERFACE_A          "GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_A             "CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_A               "CONTENT_TYPE"
# define PSZ_PATH_A                       "PATH"
# define PSZ_PATH_INFO_A                  "PATH_INFO"
# define PSZ_PATH_TRANSLATED_A            "PATH_TRANSLATED"
# define PSZ_QUERY_STRING_A               "QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_A             "REMOTE_ADDR"
# define PSZ_REMOTE_HOST_A                "REMOTE_HOST"
# define PSZ_REMOTE_USER_A                "REMOTE_USER"
# define PSZ_REQUEST_METHOD_A             "REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_A                "SCRIPT_NAME"
# define PSZ_SERVER_NAME_A                "SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_A            "SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_A                "SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_A            "SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_A                "SystemRoot"
# define PSZ_WINDIR_A                     "WINDIR"


// UNICODE values

# define PSZ_AUTH_TYPE_W                  L"AUTH_TYPE"
# define PSZ_COM_SPEC_W                   L"ComSpec"
# define PSZ_GATEWAY_INTERFACE_W          L"GATEWAY_INTERFACE"
# define PSZ_CONTENT_LENGTH_W             L"CONTENT_LENGTH"
# define PSZ_CONTENT_TYPE_W               L"CONTENT_TYPE"
# define PSZ_PATH_W                       L"PATH"
# define PSZ_PATH_INFO_W                  L"PATH_INFO"
# define PSZ_PATH_TRANSLATED_W            L"PATH_TRANSLATED"
# define PSZ_QUERY_STRING_W               L"QUERY_STRING"
# define PSZ_REMOTE_ADDRESS_W             L"REMOTE_ADDR"
# define PSZ_REMOTE_HOST_W                L"REMOTE_HOST"
# define PSZ_REMOTE_USER_W                L"REMOTE_USER"
# define PSZ_REQUEST_METHOD_W             L"REQUEST_METHOD"
# define PSZ_SCRIPT_NAME_W                L"SCRIPT_NAME"
# define PSZ_SERVER_NAME_W                L"SERVER_NAME"
# define PSZ_SERVER_PROTOCOL_W            L"SERVER_PROTOCOL"
# define PSZ_SERVER_PORT_W                L"SERVER_PORT"
# define PSZ_SERVER_SOFTWARE_W            L"SERVER_SOFTWARE"
# define PSZ_SYSTEM_ROOT_W                L"SystemRoot"
# define PSZ_WINDIR_W                     L"WINDIR"



# endif // _MSCGI_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\samples\volresp\volresp.c ===
/*
  volresp.c

  11/29/95	sethp		created

  This ISAPI app does a simple, dummy response to a form to make the 
  Volcano sample web site look better.

  Exports:

    BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )

    As per the ISAPI Spec, this just returns the
    version of the spec that this server was built with.  This
    function is prototyped in httpext.h

    BOOL WINAPI HttpExtensionProc(   EXTENSION_CONTROL_BLOCK *pECB )

    This function does all of the work.

*/

#include <windows.h>
#include <httpext.h>

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
 {
  pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

  lstrcpyn( pVer->lpszExtensionDesc,
            "Volcano Form ISAPI App",
            HSE_MAX_EXT_DLL_NAME_LEN );

  return TRUE;
 } // GetExtensionVersion()

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB )
 {

    CHAR  buff[4096];
    DWORD dwLen;

    wsprintf( buff,
	"Content-Type: text/html\r\n"
	"\r\n"
	"<HTML>\n"
	"<HEAD>\n"
	"<TITLE>Volcano Registration</TITLE>\n"
	"</HEAD>\n"
	"<BODY BACKGROUND=\"/samples/sampsite/images/tiled.gif\" \
BGPROPERTIES=FIXED>\n"
	"<CENTER>\n"
	"<IMG SRC=\"/samples/sampsite/images/headersm.gif\" ALT=\"The \
Volcano Coffee Company\" WIDTH=465>\n"
	"</CENTER>\n"
	"<P>\n"
	"<FONT FACE=\"Arial Black\">\n"
	"<CENTER>\n"
	"<H4>Thanks for registering with the Volcano Coffee Company. \
You'll be hearing from us soon!</H4>\n"
	"<P>\n"
	"<HR>\n"
	"<CENTER>\n"
	"<A HREF=\"/samples/sampsite/default.htm\"><IMG \
SRC=\"/samples/sampsite/images/mainsm.gif\" ALT=\"Main\" BORDER=0 \
WIDTH=102 HEIGHT=45></A>\n"
	"</CENTER>\n"
	"</BODY>\n"
	"</HTML>\n");

    dwLen = lstrlen(buff);

    if ( !pECB->ServerSupportFunction( pECB->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER,
                                       "200 OK",
                                       &dwLen,
                                       (LPDWORD) buff ))
    {
        return HSE_STATUS_ERROR;
    }

    pECB->dwHttpStatusCode=200; // 200 OK

    return HSE_STATUS_SUCCESS;

 } // HttpExtensionProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\ssincold\ssinc.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ssinc.cxx

Abstract:

    This module contains the server side include processing code.  We aim
    for support as specified by iis\spec\ssi.doc.  The code is based on
    existing SSI support done in iis\svcs\w3\server\ssinc.cxx.  

Author:

    Bilal Alam (t-bilala)       20-May-1996

Revision History:

    See iis\svcs\w3\server\ssinc.cxx for prior log

--*/

#include "ssinc.hxx"
#include "ssicgi.hxx"
#include "ssibgi.hxx"

//
//  These are available SSI commands
//

enum SSI_COMMANDS
{
    SSI_CMD_INCLUDE = 0,
    SSI_CMD_ECHO,
    SSI_CMD_FSIZE,          // File size of specified file
    SSI_CMD_FLASTMOD,       // Last modified date of specified file
    SSI_CMD_CONFIG,         // Configure options

    SSI_CMD_EXEC,           // Execute CGI or CMD script

    SSI_CMD_BYTERANGE,      // Custom commands, not defined by NCSA

    SSI_CMD_UNKNOWN
};

//
//  These tags are essentially subcommands for the various SSI_COMMAND values
//

enum SSI_TAGS
{
    SSI_TAG_FILE,          // Used with include, fsize & flastmod
    SSI_TAG_VIRTUAL,

    SSI_TAG_VAR,           // Used with echo

    SSI_TAG_CMD,           // Used with Exec
    SSI_TAG_CGI,
    SSI_TAG_ISA,

    SSI_TAG_ERRMSG,        // Used with Config
    SSI_TAG_TIMEFMT,       
    SSI_TAG_SIZEFMT,
    SSI_TAG_CMDECHO,
    SSI_TAG_CMDPREFIX,
    SSI_TAG_CMDPOSTFIX,

    SSI_TAG_UNKNOWN
};

//
//  Variables available to #ECHO VAR = "xxx" but not available in ISAPI
//

enum SSI_VARS
{
    SSI_VAR_DOCUMENT_NAME = 0,
    SSI_VAR_DOCUMENT_URI,
    SSI_VAR_QUERY_STRING_UNESCAPED,
    SSI_VAR_DATE_LOCAL,
    SSI_VAR_DATE_GMT,
    SSI_VAR_LAST_MODIFIED,

    SSI_VAR_UNKNOWN
};

//
//  Gateway types
//

enum SSI_GATEWAY_TYPE
{
    SSI_GATEWAY_CGI,
    SSI_GATEWAY_CMD,
    SSI_GATEWAY_ISA,

    SSI_GATEWAY_UNKNOWN
};

//
//  Prototypes
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

class SSI_ELEMENT_LIST;

SSI_ELEMENT_LIST *
SSIParse(
    IN SSI_REQUEST * pRequest,
    IN STR *         pstrFile,
    IN STR *         pstrURL,
    OUT BOOL *       pfAccessDenied
    );

BOOL
SSISend(
    IN SSI_REQUEST * pRequest,
    IN STR *         pstrFile,
    IN STR *         pstrURL
    );

BOOL
ParseSSITag(
    IN OUT CHAR * *       ppchFilePos,
    IN     CHAR *         pchEOF,
    OUT    BOOL *         pfValidTag,
    OUT    SSI_COMMANDS * pCommandType,
    OUT    SSI_TAGS *     pTagType,
    OUT    CHAR *         pszTagString
    );

void
FreeSELBlob(
    VOID * pvCacheBlob
    );

CHAR *
SSISkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
    );

CHAR *
SSISkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
    );

SSI_FILE * SSICreateFile(
    IN STR * pstrFilename,
    IN HANDLE hUser
    );

VOID SSICloseFile( 
    IN SSI_FILE * pssiFile
    );

BOOL SSICreateFileMapping( 
    IN SSI_FILE * pssiFile 
    );

BOOL SSICloseMapHandle( 
    IN SSI_FILE * pssiFile 
    );

BOOL SSIMapViewOfFile( 
    IN SSI_FILE * pssiFile
    );

BOOL SSIUnmapViewOfFile( 
    IN SSI_FILE * pssiFile
    );

DWORD SSIGetFileAttributes( 
    IN SSI_FILE * pssiFile 
    );

BOOL SSIGetFileSize( 
    IN SSI_FILE * pssiFile,
    OUT DWORD *   pdwLowWord,
    OUT DWORD *   pdwHighWord 
    );

BOOL SSIGetLastModTime( 
    IN SSI_FILE *  pssiFile,
    OUT FILETIME * ftTime 
    );

// 
// Class Definitions
//

class SSI_ELEMENT_ITEM
{
private:
    DWORD               _Signature;
    SSI_COMMANDS        _ssiCmd;
    SSI_TAGS            _ssiTag;
    STR *               _pstrTagValue;

    DWORD               _cbBegin;         // Only used for Byte range command
    DWORD               _cbLength;        // Only used for Byte range command
public:

    LIST_ENTRY          _ListEntry;
    
    SSI_ELEMENT_ITEM( VOID )
        : _ssiCmd   ( SSI_CMD_UNKNOWN ),
          _ssiTag   ( SSI_TAG_UNKNOWN ),
          _Signature( SIGNATURE_SEI ),
          _pstrTagValue( NULL )
    {
        _ListEntry.Flink = NULL;
    }

    ~SSI_ELEMENT_ITEM( VOID )
    {
        if ( _pstrTagValue != NULL )
        {
            delete _pstrTagValue;
        }
        TCP_ASSERT( _ListEntry.Flink == NULL );
        _Signature = SIGNATURE_SEI_FREE;
    }

    VOID SetByteRange( IN DWORD cbBegin,
                       IN DWORD cbLength )
    {
        _ssiCmd   = SSI_CMD_BYTERANGE;
        _cbBegin  = cbBegin;
        _cbLength = cbLength;
    }

    BOOL SetCommand( IN SSI_COMMANDS ssiCmd,
                     IN SSI_TAGS     ssiTag,
                     IN CHAR *       achTag )
    {
        _ssiCmd = ssiCmd;
        _ssiTag = ssiTag;
        _pstrTagValue = new STR( achTag );
        return _pstrTagValue != NULL;
    }

    SSI_COMMANDS QueryCommand( VOID ) const
        { return _ssiCmd; }

    SSI_TAGS QueryTag( VOID ) const
        { return _ssiTag; }

    STR * QueryTagValue( VOID ) const
        { return _pstrTagValue; }

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_SEI; }

    DWORD QueryBegin( VOID ) const
        { return _cbBegin; }

    DWORD QueryLength( VOID ) const
        { return _cbLength; }

};

//
//  This object sits as a cache blob under a file to be processed as a
//  server side include.  It represents an interpreted list of data elements
//  that make up the file itself.
//

class SSI_ELEMENT_LIST
{
private:
    DWORD               _Signature;
    LIST_ENTRY          _ListHead;

    //
    //  These are for tracking the memory mapped file
    //

    DWORD               _cRefCount;
    CRITICAL_SECTION    _csRef;

    //
    //  Provides the utilities needed to open/manipulate files
    //
    
    SSI_FILE *          _pssiFile;

    //
    //  Name of URL.  Used to resolve FILE="xxx" filenames
    //

    STR                 _strURL;


public:
    SSI_ELEMENT_LIST( SSI_REQUEST * pRequest )
      : _Signature   ( SIGNATURE_SEL ),
        _pssiFile( NULL ),
        _cRefCount( 0 )
    {
        InitializeListHead( &_ListHead );
        InitializeCriticalSection( &_csRef );
    }

    ~SSI_ELEMENT_LIST( VOID )
    {
        SSI_ELEMENT_ITEM * pSEI;

        while ( !IsListEmpty( &_ListHead ))
        {
            pSEI = CONTAINING_RECORD( _ListHead.Flink,
                                      SSI_ELEMENT_ITEM,
                                      _ListEntry );

            RemoveEntryList( &pSEI->_ListEntry );
            pSEI->_ListEntry.Flink = NULL;
            delete pSEI;
        }
        UnMap();

        if( _pssiFile != NULL )
        {
            SSICloseFile( _pssiFile );
        }

        DeleteCriticalSection( &_csRef );
        _Signature = SIGNATURE_SEL_FREE;

    }

    BOOL AppendByteRange( IN DWORD  cbStart,
                          IN DWORD  cbLength )
    {
        SSI_ELEMENT_ITEM * pSEI;

        pSEI = new SSI_ELEMENT_ITEM;

        if ( !pSEI )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }

        pSEI->SetByteRange( cbStart,
                            cbLength );
        AppendItem( pSEI );

        return TRUE;
    }

    BOOL AppendCommand( IN SSI_COMMANDS  ssiCmd,
                        IN SSI_TAGS      ssiTag,
                        IN CHAR *        pszTag )
    {
        SSI_ELEMENT_ITEM * pSEI;

        pSEI = new SSI_ELEMENT_ITEM;

        if ( !pSEI )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }

        if ( !pSEI->SetCommand( ssiCmd,
                                ssiTag,
                                pszTag ))
        {
            return FALSE;
        }

        AppendItem( pSEI );

        return TRUE;
    }

    VOID AppendItem( IN SSI_ELEMENT_ITEM * pSEI )
    {
        InsertTailList( &_ListHead,
                        &pSEI->_ListEntry );
    }

    CHAR * QueryData( VOID ) const
        { return (CHAR *) _pssiFile->_pvMappedBase; }

    BOOL CheckSignature( VOID ) const
        { return _Signature == SIGNATURE_SEL; }

    VOID Lock( VOID )
        { EnterCriticalSection( &_csRef ); }

    VOID UnLock( VOID )
        { LeaveCriticalSection( &_csRef ); }

    BOOL UnMap( VOID )
    {
        Lock();
        if ( _cRefCount && !--_cRefCount )
        {
            TCP_REQUIRE( SSIUnmapViewOfFile( _pssiFile ) );
            TCP_REQUIRE( SSICloseMapHandle( _pssiFile ) );
        }
        UnLock();
        return TRUE;
    }

    BOOL Map( VOID )
    {
        Lock();
        if ( _cRefCount++ == 0 )
        {
            if ( !SSICreateFileMapping( _pssiFile ) )
            {
                UnLock();
                return FALSE;
            }
            if ( !SSIMapViewOfFile( _pssiFile ) )
            {
                UnMap();
                UnLock();
                return FALSE;
            }
        }
        UnLock();
        return TRUE;
    }

    VOID SetFile( IN SSI_FILE * pssiFile )
        { _pssiFile = pssiFile; }

    SSI_FILE * GetFile( VOID )
        { return _pssiFile; }

    VOID SetURL( IN STR * pstrURL )
    {
        _strURL.Copy( pstrURL->QueryStr() );
    }

    VOID SendErrMsg( IN SSI_REQUEST *,
                     IN DWORD,
                     IN LPCTSTR * );
    BOOL Send( SSI_REQUEST * );

    BOOL GetFullPath( IN SSI_REQUEST *,
                      IN SSI_ELEMENT_ITEM *,
                      IN OUT STR *,
                      IN DWORD  );
    BOOL SendDate( IN SSI_REQUEST *,
                   IN SYSTEMTIME *,
                   IN STR * );
    BOOL FindInternalVariable( IN OUT STR *,
                               IN OUT DWORD * );

    // methods for performing #ECHOs

    BOOL DoEchoISAPIVariable( IN SSI_REQUEST *,
                              IN STR * );
    BOOL DoEchoDateLocal( IN SSI_REQUEST *,
                          IN STR * );
    BOOL DoEchoDateGMT( IN SSI_REQUEST *,
                        IN STR * );
    BOOL DoEchoDocumentName( IN SSI_REQUEST * );
    BOOL DoEchoDocumentURI( IN SSI_REQUEST * );
    BOOL DoEchoQueryStringUnescaped( IN SSI_REQUEST * );
    BOOL DoEchoLastModified( IN SSI_REQUEST *,
                             IN STR * );

    // methods for performing other commands

    BOOL DoFLastMod( IN SSI_REQUEST *,
                     IN STR *,
                     IN STR * );
    BOOL DoFSize( IN SSI_REQUEST *,
                  IN STR *,
                  IN BOOL );
    BOOL DoProcessGateway( IN SSI_REQUEST *,
                           IN STR *,
                           IN SSI_GATEWAY_TYPE );
};

//
//  Global Data
//

DECLARE_DEBUG_PRINTS_OBJECT()
DECLARE_DEBUG_VARIABLE();


//
//  This is used to access cache/virtual root mapping code
//

#ifdef DO_CACHE
TSVC_CACHE *     g_ptsvcCache;
#endif

//
//  This is the list of supported commands
//

struct _SSI_CMD_MAP
{
    CHAR *       pszCommand;
    DWORD        cchCommand;
    SSI_COMMANDS ssiCmd;
}
SSICmdMap[] =
{
    "#include ",  9,  SSI_CMD_INCLUDE,
    "#echo ",     6,  SSI_CMD_ECHO,
    "#fsize ",    7,  SSI_CMD_FSIZE,
    "#flastmod ",10,  SSI_CMD_FLASTMOD,
    "#config ",   8,  SSI_CMD_CONFIG,
    "#exec ",     6,  SSI_CMD_EXEC,
    NULL,         0,  SSI_CMD_UNKNOWN
};

//
//  This is the list of supported tags
//

struct _SSI_TAG_MAP
{
    CHAR *   pszTag;
    DWORD    cchTag;
    SSI_TAGS ssiTag;
}
SSITagMap[] =
{
    "var",      3,  SSI_TAG_VAR,
    "file",     4,  SSI_TAG_FILE,
    "virtual",  7,  SSI_TAG_VIRTUAL,
    "errmsg",   6,  SSI_TAG_ERRMSG,
    "timefmt",  7,  SSI_TAG_TIMEFMT,
    "sizefmt",  7,  SSI_TAG_SIZEFMT,
    "cmdecho",  7,  SSI_TAG_CMDECHO,
    "cmdprefix",9,  SSI_TAG_CMDPREFIX,
    "cmdpostfix",10,SSI_TAG_CMDPOSTFIX,
    "cmd",      3,  SSI_TAG_CMD,
    "cgi",      3,  SSI_TAG_CGI,
    "isa",      3,  SSI_TAG_ISA,
    NULL,       0,  SSI_TAG_UNKNOWN
};

//
//   This is a list of #ECHO variables not supported by ISAPI
//

struct _SSI_VAR_MAP
{
    CHAR *      pszMap;
    DWORD       cchMap;
    SSI_VARS    ssiMap;
}
SSIVarMap[] =
{
    "DOCUMENT_NAME",            13, SSI_VAR_DOCUMENT_NAME,
    "DOCUMENT_URI",             12, SSI_VAR_DOCUMENT_URI,
    "QUERY_STRING_UNESCAPED",   22, SSI_VAR_QUERY_STRING_UNESCAPED,
    "DATE_LOCAL",               10, SSI_VAR_DATE_LOCAL,
    "DATE_GMT",                 8,  SSI_VAR_DATE_GMT,
    "LAST_MODIFIED",            13, SSI_VAR_LAST_MODIFIED,
    NULL,                       0,  SSI_VAR_UNKNOWN
};

BOOL
SSI_REQUEST::ProcessSSI( VOID )
/*++

Routine Description:

    This is the top level routine for retrieving a server side include
    file.

Arguments:

    none
    
Return Value:

    TRUE on success, FALSE on failure

--*/
{
    TCP_PRINT(( DBG_CONTEXT,
                "[ProcessSSI] about to process %s\n",
                _strFilename.QueryStr() ));

    return SSISend( this, &_strFilename, &_strURL );
}

BOOL
SSISend(
    IN SSI_REQUEST *  pRequest,
    IN STR *          pstrFile,
    IN STR *          pstrURL
    )
/*++

Routine Description:

    This method builds the Server Side Include Element List the first time
    a .stm file is sent.  Subsequently, the element list is checked out from
    the associated cache blob.

    Note:  The HTTP headers have already been sent at this point so for any
    subsequent non-catastrophic errors, we have to insert them into the output
    stream.

Arguments:

    pRequest - SSI Request
    pstrFile - File to send
    pstrURL - URL (from root) of this file

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SSI_ELEMENT_LIST *      pSEL;
    BOOL                    fRet = TRUE;
    BOOL                    fAccessDenied = FALSE;

#ifdef DO_CACHE
    SSI_ELEMENT_LIST **     ppSELBlob;
    DWORD                   cbBlob;
    BOOL                    fCached = TRUE;
    BOOL                    fMustFree = FALSE;

    //
    //  Check if we've already processed the file and its in cache
    //
    if ( TsCheckOutCachedBlob( *g_ptsvcCache,
                               pstrFile->QueryStr(),
                               SSI_DEMUX,
                               (VOID**) &ppSELBlob,
                               &cbBlob ) )
    {
        //
        // found it! Send a response header if processing base file
        //

        if ( pRequest->_fBaseFile )
        {
            pRequest->_fBaseFile = FALSE;
            pRequest->SendResponseHeader( NULL );
        }

        pSEL = *ppSELBlob;

        goto SendSSI;
    }
#endif
    //  
    //  This file hasn't been processed yet so go process it
    //

    pSEL = SSIParse( pRequest, pstrFile, pstrURL, &fAccessDenied );

    if ( pRequest->_fBaseFile )
    {
        pRequest->_fBaseFile = FALSE;
        if ( !pSEL && fAccessDenied )
        {
            pRequest->SendResponseHeader( SSI_ACCESS_DENIED_HEADER );
            return FALSE;
        } 
        //
        //  Send the response header now even though we do not know for sure
        //  whether all of the included files exist.  If we find a file that
        //  doesn't exist then we'll just include an error message in the document
        //

        if ( !pRequest->SendResponseHeader( NULL ) )
        {
            return FALSE;
        }
    }
    else
    {
        if ( !pSEL )
        {
            //
            //  ParseSSI failed and has already sent the error to the client,
            //  we return TRUE so processing may continue on the parent
            //  include files
            //
            return TRUE;
        }
    }

#ifdef DO_CACHE
    ppSELBlob = &pSEL;

    //
    //  In case allocation/caching fails, initialize ppSELBlob
    //

    if ( !TsAllocateEx( *g_ptsvcCache,
                        sizeof( PVOID ),
                        (VOID**) &ppSELBlob,
                        (PUSER_FREE_ROUTINE) FreeSELBlob ) )
    {
        fCached = FALSE;
        goto SendSSI;
    }

    *ppSELBlob = pSEL;

    if ( !TsCacheDirectoryBlob( *g_ptsvcCache,
                                pstrFile->QueryStr(),
                                SSI_DEMUX,
                                ppSELBlob,
                                sizeof( PVOID ),
                                TRUE ) )
    {
        // remember to free the blob
        fMustFree= TRUE;
        fCached = FALSE;
        goto SendSSI;
    }

#endif
    goto SendSSI;

SendSSI:

    TCP_ASSERT( pSEL->CheckSignature() );

    if ( !pSEL->Send( pRequest ) )
    {
        //
        //  Send a failure message
        //

        LPCTSTR apszParms[ 2 ];
        CHAR pszNumBuf[ SSI_MAX_NUMBER_STRING ];
        _ultoa( GetLastError(), pszNumBuf, 10 );
        apszParms[ 0 ] = pstrFile->QueryStr();
        apszParms[ 1 ] = pszNumBuf;
        
        pRequest->SSISendError( SSINCMSG_ERROR_HANDLING_FILE,
                                apszParms );
        fRet = FALSE;
    }

#ifdef DO_CACHE
    if ( fCached )
    {
        TCP_REQUIRE( TsCheckInCachedBlob( *g_ptsvcCache,
                                          ppSELBlob ) );
    }
    else
    {
        if ( fMustFree )
        {
            TCP_REQUIRE( TsFree( *g_ptsvcCache,
                                 ppSELBlob ) );
        }
        else
        {
            delete *ppSELBlob;
        }
    }
#else
    delete pSEL;
#endif
    return fRet;
}

SSI_ELEMENT_LIST *
SSIParse(
    IN SSI_REQUEST * pRequest,
    IN STR *         pstrFile,
    IN STR *         pstrURL,
    OUT BOOL *       pfAccessDenied
    )
/*++

Routine Description:

    This method opens and parses the specified server side include file.

    Note:  The HTTP headers have already been sent at this point so for any
    subsequent non-catastrophic errors, we have to insert them into the output
    stream.

    We keep the file open but that's ok because if a change dir notification
    occurs, the cache blob will get decached at which point we will close
    all of our open handles.

Arguments:

    pRequest - Request context
    pstrFile - File to open and parse
    pstrURL - The URL path of this file
    pfAccessDenied - Was .STM file access denied?

Return Value:

    Created Server Side Include File on success, NULL on failure.

--*/
{
    SSI_FILE *          pssiFile = NULL;
    SSI_ELEMENT_LIST *  pSEL  = NULL;
    CHAR *              pchBeginRange = NULL;
    CHAR *              pchFilePos = NULL;
    CHAR *              pchBeginFile = NULL;
    CHAR *              pchEOF = NULL;
    DWORD               cbSizeLow, cbSizeHigh;

    //
    //  Create the element list
    //

    pSEL = new SSI_ELEMENT_LIST( pRequest );

    if ( pSEL == NULL )
    {
        goto ErrorExit;
    }

    //
    //  Set the URL (to be used in calculating FILE="xxx" paths
    //

    pSEL->SetURL( pstrURL );

    //
    //  Open the file
    //

    pssiFile = SSICreateFile( pstrFile, pRequest->_hUser );
    if ( !pssiFile )
    {
        *pfAccessDenied = ( GetLastError() == ERROR_ACCESS_DENIED );
        goto ErrorExit;
    }

    pSEL->SetFile( pssiFile );

    //
    //  Make sure a parent doesn't try and include a directory
    //

    if ( SSIGetFileAttributes( pssiFile ) & FILE_ATTRIBUTE_DIRECTORY )
    {
//        SetLastError( SSINCMSG_CANT_INCLUDE_DIR );
        goto ErrorExit;
    }

    if ( !SSIGetFileSize( pssiFile, &cbSizeLow, &cbSizeHigh ) )
    {
        goto ErrorExit;
    }
    
    if ( cbSizeHigh )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        goto ErrorExit;
    }

    //
    //  Create a file mapping, we shouldn't need to impersonate as we already
    //  have the file open
    //

    if ( !pSEL->Map() )
    {
        goto ErrorExit;
    }

    pchFilePos = pchBeginFile = pchBeginRange = pSEL->QueryData();
    pchEOF     = pchFilePos + cbSizeLow;

    //
    //  Scan for "<!--" or "<%"
    //

    while ( TRUE )
    {
        while ( pchFilePos < pchEOF && *pchFilePos != '<' )
        {
            pchFilePos++;
        }

        if ( pchFilePos >= pchEOF )
        {
            break;
        }

        //
        //  Is this one of our tags?
        //

        if ( pchFilePos[1] == '%' ||
             !strncmp( pchFilePos, "<!--", 4 ))
        {
            CHAR *        pchBeginTag = pchFilePos;
            SSI_COMMANDS  CommandType;
            SSI_TAGS      TagType;
            CHAR          achTagString[SSI_MAX_PATH + 1];
            BOOL          fValidTag;

            //
            //  Get the tag info.  The file position will be advanced to the
            //  first character after the tag
            //

            if ( !ParseSSITag( &pchFilePos,
                               pchEOF,
                               &fValidTag,
                               &CommandType,
                               &TagType,
                               achTagString ))
            {
                break;
            }

            //
            //  If it's a tag we don't recognize then ignore it
            //

            if ( !fValidTag )
            {
                pchFilePos++;
                continue;
            }

            //
            //  Add the data up to the tag as a byte range
            //

            if ( pchBeginRange != pchBeginTag )
            {
                if ( !pSEL->AppendByteRange( pchBeginRange - pchBeginFile,
                                             pchBeginTag - pchBeginRange ))
                {
                    goto ErrorExit;
                }

                pchBeginRange = pchFilePos;
            }

            //
            //  Add the tag
            //

            if ( !pSEL->AppendCommand( CommandType,
                                       TagType,
                                       achTagString ))
            {
                goto ErrorExit;
            }
        }
        else
        {
            //
            //  Not one of our tags, skip the openning angle bracket
            //

            pchFilePos++;
        }
    }

    //
    //  Tack on the last byte range
    //

    if ( pchFilePos > pchBeginRange )
    {
        if ( !pSEL->AppendByteRange( pchBeginRange - pchBeginFile,
                                     pchFilePos - pchBeginRange ))
        {
            goto ErrorExit;
        }
    }

    pSEL->UnMap();

    return pSEL;

ErrorExit:

    if ( pssiFile != NULL )
    {
        SSICloseFile( pssiFile );
    }

    if ( pSEL != NULL )
    {
        delete pSEL;
    }

    LPCTSTR apszParms[ 2 ];
    CHAR    pszNumBuf[ SSI_MAX_NUMBER_STRING ];
    _ultoa( GetLastError(), pszNumBuf, 10 );
    apszParms[ 0 ] = pstrFile->QueryStr();
    apszParms[ 1 ] = pszNumBuf;

    pRequest->SSISendError( SSINCMSG_ERROR_HANDLING_FILE,
                            apszParms );

    return NULL;
}

BOOL
ParseSSITag(
    IN OUT CHAR * *       ppchFilePos,
    IN     CHAR *         pchEOF,
    OUT    BOOL *         pfValidTag,
    OUT    SSI_COMMANDS * pCommandType,
    OUT    SSI_TAGS *     pTagType,
    OUT    CHAR *         pszTagString
    )
/*++

Routine Description:

    This function picks apart an NCSA style server side include expression

    The general form of a server side include directive is:

    <[!-- or %]#[command] [tag]="[value]"[-- or %]>

    For example:

    <!--#include file="myfile.txt"-->
    <%#echo var="HTTP_USER_AGENT"%>
    <!--#fsize virtual="/dir/bar.htm"-->

    For valid commands and tags see \iis\specs\ssi.doc

Arguments:

    ppchFilePos - Pointer to first character of tag on way in, pointer
        to first character after tag on way out if the tag is valid
    pchEOF - Points to first byte beyond the end of the file
    pfValidTag - Set to TRUE if this is a tag we support and all of the
        parameters have been supplied
    pCommandType - Receives SSI command
    pTagType - Receives SSI tag
    pszTagString - Receives value of pTagType.  Must be > SSI_MAX_PATH.

Return Value:

    TRUE if no errors occurred.

--*/
{
    CHAR * pchFilePos = *ppchFilePos;
    CHAR * pchEOT;
    CHAR * pchEndQuote;
    DWORD  i;
    DWORD  cbToCopy;
    DWORD  cbJumpLen = 0;
    BOOL   fNewStyle;           // <% format

    TCP_ASSERT( *pchFilePos == '<' );

    //
    //  Assume this is bad tag
    //

    *pfValidTag = FALSE;

    if ( !strncmp( pchFilePos, "<!--", 4 ) )
    {
        fNewStyle = FALSE;
    }
    else if ( !strncmp( pchFilePos, "<%", 2 ) )
    {
        fNewStyle = TRUE;
    }
    else
    {
        return TRUE;
    }

    //
    //  Find the closing comment token (either --> or %>).  The reason
    //  why we shouldn't simply look for a > is because we want to allow
    //  the user to embed HTML <tags> in the directive
    //  (ex. <!--#CONFIG ERRMSG="<B>ERROR!!!</B>-->)
    //

    pchEOT = strstr( pchFilePos, fNewStyle ? "%>" : "-->" );
    if ( !pchEOT )
    {
        return FALSE;
    }
    cbJumpLen = fNewStyle ? 2 : 3;

    //
    //  Find the '#' that prefixes the command
    //

    pchFilePos = SSISkipTo( pchFilePos, '#', pchEOT );

    if ( !pchFilePos )
    {
        //
        //  No command, bail for this tag
        //
        //  CODEWORK - Check for if expression here
        //

        return TRUE;
    }

    //
    //  Lookup the command
    //

    i = 0;
    while ( SSICmdMap[i].pszCommand )
    {
        if ( *SSICmdMap[i].pszCommand == tolower( *pchFilePos ) &&
             !_strnicmp( SSICmdMap[i].pszCommand,
                         pchFilePos,
                         SSICmdMap[i].cchCommand ))
        {
            *pCommandType = SSICmdMap[i].ssiCmd;

            //
            //  Note the space after the command is included in cchCommand
            //

            pchFilePos += SSICmdMap[i].cchCommand;
            goto FoundCommand;
        }

        i++;
    }

    //
    //  Unrecognized command, bail
    //

    return TRUE;

FoundCommand:

    //
    //  Next, find the tag name
    //

    pchFilePos = SSISkipWhite( pchFilePos, pchEOT );

    if ( !pchFilePos )
        return TRUE;

    i = 0;
    while ( SSITagMap[i].pszTag )
    {
        if ( *SSITagMap[i].pszTag == tolower( *pchFilePos ) &&
             !_strnicmp( SSITagMap[i].pszTag,
                         pchFilePos,
                         SSITagMap[i].cchTag ))
        {
            *pTagType = SSITagMap[i].ssiTag;
            pchFilePos += SSITagMap[i].cchTag;
            goto FoundTag;
        }

        i++;
    }

    //
    //  Tag not found, bail
    //

    return TRUE;

FoundTag:

    //
    //  Skip to the quoted tag value, then find the close quote
    //

    pchFilePos = SSISkipTo( pchFilePos, '"', pchEOT );

    if ( !pchFilePos )
        return TRUE;

    pchEndQuote = SSISkipTo( ++pchFilePos, '"', pchEOT );

    if ( !pchEndQuote )
        return TRUE;

    cbToCopy = min( (pchEndQuote - pchFilePos), SSI_MAX_PATH );

    memcpy( pszTagString,
            pchFilePos,
            cbToCopy );

    pszTagString[cbToCopy] = '\0';

    *pfValidTag = TRUE;

    *ppchFilePos = pchEOT + cbJumpLen;

    return TRUE;
}

BOOL
SSI_ELEMENT_LIST::Send(
    SSI_REQUEST * pRequest
    )
/*++

Routine Description:

    This method walks the element list sending the appropriate chunks of
    data

Arguments:

    pRequest - Request context

Return Value:

    TRUE on success, FALSE on any failures

--*/
{
    LIST_ENTRY *       pEntry;
    DWORD              cbSent;
    STR                strPath;
    SSI_ELEMENT_ITEM * pSEI;

    STR                strTimeFmt( SSI_DEF_TIMEFMT );
    STR                strCmdPrefix( SSI_DEF_CMDPREFIX );
    STR                strCmdPostfix( SSI_DEF_CMDPOSTFIX );
    BOOL               bSizeFmtBytes( SSI_DEF_SIZEFMT );
    BOOL               bCmdEcho( SSI_DEF_CMDECHO );
    
    TCP_ASSERT( CheckSignature() );

    if ( !Map() )
    {
        return FALSE;
    }

    //
    //  Loop through each element and take the appropriate action
    //

    for ( pEntry  = _ListHead.Flink;
          pEntry != &_ListHead;
          pEntry  = pEntry->Flink )
    {
        pSEI = CONTAINING_RECORD( pEntry, SSI_ELEMENT_ITEM, _ListEntry );

        TCP_ASSERT( pSEI->CheckSignature() );

        switch ( pSEI->QueryCommand() )
        {
        case SSI_CMD_BYTERANGE:
            if ( !pRequest->WriteToClient( QueryData() + pSEI->QueryBegin(),
                                            pSEI->QueryLength(),
                                            &cbSent ) )
            {
                UnMap();
                return FALSE;
            }
            break;

        case SSI_CMD_INCLUDE:
            switch ( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( !GetFullPath( pRequest,
                                   pSEI,
                                   &strPath,
                                   VROOT_MASK_READ ) ||
                     !SSISend( pRequest,
                               &strPath,
                               pSEI->QueryTagValue() ) )
                {
                    LPCTSTR apszParms[ 1 ];
                    apszParms[ 0 ] = strPath.QueryStr();
                    
                    SendErrMsg( pRequest,
                                SSINCMSG_ERROR_HANDLING_FILE,
                                apszParms );
                    break;
                }

                break;

            default:
                SendErrMsg( pRequest,
                            SSINCMSG_INVALID_TAG,
                            NULL );
                break;
            }
            break;

        case SSI_CMD_FLASTMOD:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( !GetFullPath( pRequest,
                                   pSEI,
                                   &strPath,
                                   0 ) ||
                     !DoFLastMod( pRequest,
                                  &strPath,
                                  &strTimeFmt ) )
                {
                    LPCTSTR apszParms[ 1 ];
                    apszParms[ 0 ] = strPath.QueryStr();

                    SendErrMsg( pRequest,
                                SSINCMSG_CANT_DO_FLASTMOD,
                                apszParms );
                    break;
                }
                break;
            default:
                SendErrMsg( pRequest,
                            SSINCMSG_INVALID_TAG,
                            NULL );
                break;
            }
            break;
            
        case SSI_CMD_CONFIG:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_ERRMSG:
                pRequest->SetUserErrorMessage( pSEI->QueryTagValue() );
                break;
            case SSI_TAG_TIMEFMT:
                strTimeFmt.Copy( pSEI->QueryTagValue()->QueryStr() );
                break;
            case SSI_TAG_SIZEFMT:
                if ( _strnicmp( SSI_DEF_BYTES,
                                pSEI->QueryTagValue()->QueryStr(),
                                SSI_DEF_BYTES_LEN + 1 ) == 0 )
                {
                    bSizeFmtBytes = TRUE;
                }
                else if ( _strnicmp( SSI_DEF_ABBREV,
                                     pSEI->QueryTagValue()->QueryStr(),
                                     SSI_DEF_ABBREV_LEN + 1 ) == 0 )
                {
                    bSizeFmtBytes = FALSE;
                }
                else
                {
                    SendErrMsg( pRequest,
                                SSINCMSG_INVALID_TAG,
                                NULL );
                }
                break;
            case SSI_TAG_CMDECHO:
                if ( _strnicmp( SSI_DEF_ON,
                                pSEI->QueryTagValue()->QueryStr(),
                                SSI_DEF_ON_LEN + 1 ) == 0 )
                {
                    bCmdEcho = TRUE;
                }
                else if ( _strnicmp( SSI_DEF_OFF,
                                     pSEI->QueryTagValue()->QueryStr(),
                                     SSI_DEF_OFF_LEN + 1) == 0 )
                {
                    bCmdEcho = FALSE;
                }
                else
                {
                    SendErrMsg( pRequest,
                                SSINCMSG_INVALID_TAG,
                                NULL );
                }
                break;
            case SSI_TAG_CMDPREFIX:
                strCmdPrefix.Copy( pSEI->QueryTagValue()->QueryStr() );
                break;
            case SSI_TAG_CMDPOSTFIX:
                strCmdPostfix.Copy( pSEI->QueryTagValue()->QueryStr() );
                break;
            default:
                SendErrMsg( pRequest,
                            SSINCMSG_INVALID_TAG,
                            NULL );
                break;
            }
            break;

        case SSI_CMD_FSIZE:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( !GetFullPath( pRequest,
                                   pSEI,
                                   &strPath,
                                   0 ) ||
                     !DoFSize( pRequest,
                               &strPath,
                               bSizeFmtBytes ) )
                {
                    LPCTSTR apszParms[ 1 ];
                    apszParms[ 0 ] = strPath.QueryStr();
                    
                    SendErrMsg( pRequest,
                                SSINCMSG_CANT_DO_FSIZE,
                                apszParms );
                    break;
                }
                break;

            default:
                SendErrMsg( pRequest,
                            SSINCMSG_INVALID_TAG,
                            NULL );
                break;
            }
            break;

        case SSI_CMD_ECHO:
            if ( pSEI->QueryTag() == SSI_TAG_VAR )
            {
                // First let ISAPI try to evaluate variable.
                if ( DoEchoISAPIVariable( pRequest,
                                          pSEI->QueryTagValue() ) )
                {
                    break;
                }
                else
                {
                    DWORD               dwVar;
                    BOOL                fEchoError = FALSE;
                    
                    // if ISAPI couldn't resolve var, try internal list
                    if ( !FindInternalVariable( pSEI->QueryTagValue(),
                                               &dwVar ) )
                    {
                        LPCTSTR apszParms[ 1 ];
                        apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                        
                        SendErrMsg( pRequest,
                                    SSINCMSG_CANT_FIND_VARIABLE,
                                    apszParms );
                        break;
                    }
                    switch( dwVar )
                    {
                    case SSI_VAR_DOCUMENT_NAME:
                        if ( !DoEchoDocumentName( pRequest ) )
                        {
                            fEchoError = TRUE;
                        }
                        break;
                    case SSI_VAR_DOCUMENT_URI:
                        if ( !DoEchoDocumentURI( pRequest ) )
                        {
                            fEchoError = TRUE;
                        }
                        break;
                    case SSI_VAR_QUERY_STRING_UNESCAPED:
                        if ( !DoEchoQueryStringUnescaped( pRequest ) )
                        {
                            fEchoError = TRUE;
                        }
                        break;
                    case SSI_VAR_DATE_LOCAL:
                        if ( !DoEchoDateLocal( pRequest, &strTimeFmt ) )
                        {
                            fEchoError = TRUE;
                        }
                        break;
                    case SSI_VAR_DATE_GMT:
                        if ( !DoEchoDateGMT( pRequest, &strTimeFmt ) )
                        {
                            fEchoError = TRUE;
                        }
                        break;
                    case SSI_VAR_LAST_MODIFIED:
                        if ( !DoEchoLastModified( pRequest, &strTimeFmt ) )
                        {
                            fEchoError = TRUE;
                        }
                        break;
                    default:
                    {
                        LPCTSTR apszParms[ 1 ];
                        apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                        
                        SendErrMsg( pRequest,
                                    SSINCMSG_CANT_FIND_VARIABLE,
                                    apszParms );
                        break;
                    }
                    }
                    if ( fEchoError )
                    {
                        LPCTSTR apszParms[ 1 ];
                        apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                        
                        SendErrMsg( pRequest,
                                    SSINCMSG_CANT_EVALUATE_VARIABLE,
                                    apszParms );
                    }
                }
            }
            else 
            {
                SendErrMsg( pRequest,
                            SSINCMSG_INVALID_TAG,
                            NULL );
            }
            break;
        case SSI_CMD_EXEC:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_CMD:
                if ( !DoProcessGateway( pRequest,
                                      pSEI->QueryTagValue(),
                                      SSI_GATEWAY_CMD ) )
                {
                    LPCTSTR apszParms[ 1 ];
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();
                    
                    SendErrMsg( pRequest,
                                SSINCMSG_CANT_EXEC_CMD,
                                apszParms );
                }
                break;
            case SSI_TAG_CGI:
                if ( !DoProcessGateway( pRequest,
                                      pSEI->QueryTagValue(),
                                      SSI_GATEWAY_CGI ) )
                {
                    LPCTSTR apszParms[ 1 ];
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();

                    SendErrMsg( pRequest,
                                SSINCMSG_CANT_EXEC_CGI,
                                apszParms );
                }
                break;
            case SSI_TAG_ISA:
                if ( !DoProcessGateway( pRequest,
                                      pSEI->QueryTagValue(),
                                      SSI_GATEWAY_ISA ) )
                {
                    LPCTSTR apszParms[ 1 ];
                    apszParms[ 0 ] = pSEI->QueryTagValue()->QueryStr();

                    SendErrMsg( pRequest,
                                SSINCMSG_CANT_EXEC_ISA,
                                apszParms );
                }
                break;
            default:
                SendErrMsg( pRequest,
                            SSINCMSG_INVALID_TAG,
                            NULL );
                break;
            }
            break;
        default:
            SendErrMsg( pRequest,
                        SSINCMSG_NOT_SUPPORTED,
                        NULL );
            break;
        }
    }

    UnMap();

    return TRUE;
}

VOID
SSI_ELEMENT_LIST::SendErrMsg(
    IN SSI_REQUEST * pRequest,
    IN DWORD         dwMessageID,
    IN LPCTSTR       apszParms[]
    )
{
    pRequest->SSISendError( dwMessageID,
                            apszParms );
}

BOOL
SSI_ELEMENT_LIST::GetFullPath(
    IN SSI_REQUEST *        pRequest,
    IN SSI_ELEMENT_ITEM *   pSEI,
    OUT STR *               pstrPath,
    IN DWORD                dwPermission
)
{
    CHAR *              pszValue;
    STR *               pstrValue;
    DWORD               dwMask;
    DWORD               cbBufLen;
    CHAR                achPath[ SSI_MAX_PATH + 1 ];
    TSVC_CACHE          tsvcCache( INET_HTTP_SVC_ID );

    //
    //  We recalc the virtual root each time in case the root
    //  to directory mapping has changed
    //

    pstrValue = pSEI->QueryTagValue();
    pszValue = pstrValue->QueryStr();
        
    if ( *pszValue == '/' )
        strcpy( achPath, pszValue );
    else if ( (int)pSEI->QueryTag() == (int)SSI_TAG_FILE )
    {
        strcpy( achPath, _strURL.QueryStr() );
        LPSTR pL = achPath + lstrlen( achPath );
        while ( pL > achPath && pL[-1] != '/' )
            --pL;
        if ( pL == achPath )
            *pL++ = '/';
        strcpy( pL, pszValue );
    }
    else
    {
        achPath[0] = '/';
        strcpy( achPath+1, pszValue );
    }
    
    //
    //  Map to a physical directory
    //

    if ( !pstrPath->Resize( SSI_MAX_PATH + 1 ) )
    {
        return FALSE;
    }

    cbBufLen = SSI_MAX_PATH + 1;

    if ( !TsLookupVirtualRoot( tsvcCache,
                               achPath,
                               pstrPath->QueryStr(),
                               &cbBufLen,
                               &dwMask ) )
    {
        return FALSE;
    }

    if ( dwPermission && !( dwMask & dwPermission ) )
    {
        LPCTSTR apszParms[ 1 ];
        apszParms[ 0 ] = achPath;
        
        SendErrMsg( pRequest,
                    SSINCMSG_ACCESS_DENIED,
                    apszParms );
        return FALSE;
    }

    return TRUE;
}

BOOL
SSI_ELEMENT_LIST::DoFLastMod(
    IN SSI_REQUEST *       pRequest,
    IN STR *               pstrFilename,
    IN STR *               pstrTimeFmt
)
{
    SSI_FILE *                  pssiFile;
    FILETIME                    ftTime;
    SYSTEMTIME                  sysTime;
    SYSTEMTIME                  sysLocal;

    pssiFile = SSICreateFile( pstrFilename, pRequest->_hUser );
    if ( !pssiFile )
    {
        return FALSE;
    }
    
    if ( !SSIGetLastModTime( pssiFile, &ftTime ) )
    {
        SSICloseFile( pssiFile );
        return FALSE;
    }
    SSICloseFile( pssiFile );

    if ( !::FileTimeToSystemTime( &ftTime, &sysTime ) )
    {
        return FALSE;
    }

    if ( !::SystemTimeToTzSpecificLocalTime( NULL,
                                             &sysTime,
                                             &sysLocal ) )
    {
        return FALSE;
    }

    return SendDate( pRequest,
                     &sysLocal,
                     pstrTimeFmt );
}

BOOL
SSI_ELEMENT_LIST::SendDate(
    IN SSI_REQUEST *        pRequest,
    IN SYSTEMTIME *         psysTime,
    IN STR *                pstrTimeFmt
)
{
    struct tm                   tm;
    CHAR                        achBuffer[ SSI_MAX_TIME_SIZE + 1 ];
    DWORD                       cbBufLen;
    
    // Convert SYSTEMTIME to 'struct tm'

    tm.tm_sec = psysTime->wSecond;
    tm.tm_min = psysTime->wMinute;
    tm.tm_hour = psysTime->wHour;
    tm.tm_mday = psysTime->wDay;
    tm.tm_mon = psysTime->wMonth - 1;
    tm.tm_year = psysTime->wYear - 1900;
    tm.tm_wday = psysTime->wDayOfWeek;

    cbBufLen = strftime( achBuffer,
                         SSI_MAX_TIME_SIZE + 1,
                         pstrTimeFmt->QueryStr(),
                         &tm );

    if ( cbBufLen == 0 )
    {
        return FALSE;
    }

    return pRequest->WriteToClient( achBuffer,
                                    cbBufLen,
                                    &cbBufLen );
}

BOOL
SSI_ELEMENT_LIST::DoEchoISAPIVariable(
    IN SSI_REQUEST *    pRequest,
    IN STR *            pstrVariable
)
{
    STR                 strVar;
    DWORD               cbBufLen;

    if ( !pRequest->GetVariable( pstrVariable->QueryStr(),
                                 &strVar ) )                                 
    {
        return FALSE;
    }

    return pRequest->WriteToClient( strVar.QueryStrA(),
                                    strVar.QueryCB(),
                                    &cbBufLen );
}

BOOL
SSI_ELEMENT_LIST::DoEchoDateLocal(
    IN SSI_REQUEST *    pRequest,
    IN STR *            pstrTimeFmt
)
{
    SYSTEMTIME              sysTime;

    ::GetLocalTime( &sysTime );
    return SendDate( pRequest,
                     &sysTime,
                     pstrTimeFmt );
}

BOOL
SSI_ELEMENT_LIST::DoEchoDateGMT(
    IN SSI_REQUEST *    pRequest,
    IN STR *            pstrTimeFmt
)
{
    SYSTEMTIME              sysTime;

    ::GetSystemTime( &sysTime );
    return SendDate( pRequest,
                     &sysTime,
                     pstrTimeFmt );
}

BOOL
SSI_ELEMENT_LIST::DoEchoDocumentName(
    IN SSI_REQUEST *    pRequest
)
{
    DWORD                   cbBufLen;

    return pRequest->WriteToClient( _pssiFile->_strFilename.QueryStrA(),
                                    _pssiFile->_strFilename.QueryCB(),
                                    &cbBufLen );
}

BOOL
SSI_ELEMENT_LIST::DoEchoDocumentURI(
    IN SSI_REQUEST *    pRequest
)
{
    DWORD                   cbBufLen;

    return pRequest->WriteToClient( _strURL.QueryStrA(),
                                    _strURL.QueryCB(),
                                    &cbBufLen );
}

BOOL
SSI_ELEMENT_LIST::DoEchoQueryStringUnescaped(
    IN SSI_REQUEST *    pRequest
)
{
    DWORD                   cbBufLen;
    STR                     strVar;
    
    if ( !pRequest->GetVariable( "QUERY_STRING",
                                  &strVar ) )
    {
        return FALSE;
    }
    strVar.Unescape();

    return pRequest->WriteToClient( strVar.QueryStrA(),
                                    strVar.QueryCB(),
                                    &cbBufLen );
}

BOOL
SSI_ELEMENT_LIST::DoEchoLastModified(
    IN SSI_REQUEST *    pRequest,
    IN STR *            pstrTimeFmt
)
{
    return DoFLastMod( pRequest,
                       &_pssiFile->_strFilename,
                       pstrTimeFmt );
}

BOOL
SSI_ELEMENT_LIST::DoFSize(
    IN SSI_REQUEST *    pRequest,
    IN STR *            pstrFilename,
    IN BOOL             bSizeFmtBytes
)
{
    BOOL                bRet;
    DWORD               cbSizeLow;
    DWORD               cbSizeHigh;
    SSI_FILE *          pssiFile;
    CHAR                achInputNumber[ SSI_MAX_NUMBER_STRING + 1 ];
    CHAR                achOutputNumber[ SSI_MAX_NUMBER_STRING + 1 ];
    NUMBERFMT           nfNumberFormat;
    int                 iOutputSize;
    DWORD               dwActualLen;

    pssiFile = SSICreateFile( pstrFilename, pRequest->_hUser );
    if ( pssiFile == NULL )
    {
        return FALSE;
    }

    bRet = SSIGetFileSize( pssiFile,
                           &cbSizeLow,
                           &cbSizeHigh );
    if ( !bRet )
    {
        SSICloseFile( pssiFile );
        return FALSE;
    }

    if ( cbSizeHigh )
    {
        SSICloseFile( pssiFile );
        return FALSE;
    }

    SSICloseFile( pssiFile );

    if ( !bSizeFmtBytes )
    {
        // express in terms of KB
        cbSizeLow /= 1000;
    }

    nfNumberFormat.NumDigits = 0;
    nfNumberFormat.LeadingZero = 0;
    nfNumberFormat.Grouping = 3;
    nfNumberFormat.lpThousandSep = ",";
    nfNumberFormat.lpDecimalSep = ".";
    nfNumberFormat.NegativeOrder = 2;
    
    _snprintf( achInputNumber,
               SSI_MAX_NUMBER_STRING + 1,
               "%ld",
               cbSizeLow );
    
    iOutputSize = GetNumberFormat( LOCALE_SYSTEM_DEFAULT,
                                   0,
                                   achInputNumber,
                                   &nfNumberFormat,
                                   achOutputNumber,
                                   SSI_MAX_NUMBER_STRING + 1 );
    if ( !iOutputSize )
    {
        return FALSE;
    }

    iOutputSize--;

    return pRequest->WriteToClient( achOutputNumber,
                                    iOutputSize,
                                    &dwActualLen );
}

BOOL
SSI_ELEMENT_LIST::FindInternalVariable(
    IN STR *                pstrVariable,
    OUT PDWORD              pdwID
)
{
    DWORD                   dwCounter = 0;

    while ( ( SSIVarMap[ dwCounter ].pszMap != NULL ) &&
            _strnicmp( SSIVarMap[ dwCounter ].pszMap,
                       pstrVariable->QueryStr(),
                       SSIVarMap[ dwCounter ].cchMap ) )
    {
        dwCounter++;
    }
    if ( SSIVarMap[ dwCounter ].pszMap != NULL )
    {
        *pdwID = SSIVarMap[ dwCounter ].ssiMap;
        return TRUE;
    }
    else
    {
        *pdwID = SSI_VAR_UNKNOWN;
        return FALSE;
    }
}

BOOL
SSI_ELEMENT_LIST::DoProcessGateway(
    SSI_REQUEST *           pRequest,
    STR *                   pstrPath,
    SSI_GATEWAY_TYPE        sgtType
)
/*++

Routine Description:

    Handles #EXEC CMD=,CGI=,ISA=
    
Arguments:

    pRequest - SSI_REQUEST class used to send data to client
    pstrPath - Command specified in #EXEC call
    sgtType  - Type of gateway


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL        fRet = TRUE;

    switch ( sgtType )
    {
    case SSI_GATEWAY_CGI:
    case SSI_GATEWAY_ISA:
    {
        STR         strURLParams;
        STR         strWorkingDir;
        STR         strFull;
        STR         strPathCopy;
        TCHAR *     pch;
        DWORD       cbBufLen = SSI_MAX_PATH + 1;
        DWORD       cbDirSize;
        TSVC_CACHE  tsvcCache( INET_HTTP_SVC_ID );
        DWORD       dwMask;
        
        //
        //  Need to separate any params specified in URL
        //

        strPathCopy.Copy( pstrPath->QueryStr() );
        
        pch = strchr( strPathCopy.QueryStr(), TEXT('?') );

        if ( pch != NULL )
        {
            *pch = TEXT('\0');
        }

        strURLParams.Copy( pch != NULL ? pch + 1 : "" );

        strFull.Resize( SSI_MAX_PATH + 1 );

        //
        //  We need to the working directory of the path
        //  TsLookupVirtualRoot() appears to be the only way for this DLL
        //  to get the working directory of a CGI script (for now?)
        //

        if ( !TsLookupVirtualRoot( tsvcCache,
                                   strPathCopy.QueryStr(),
                                   strFull.QueryStr(),
                                   &cbBufLen,
                                   &dwMask,
                                   &cbDirSize ) )
        {
            return FALSE;
        }

        if ( !( dwMask & VROOT_MASK_EXECUTE ) )
        {
            LPCTSTR apszParms[ 1 ];
            apszParms[ 0 ] = strFull.QueryStr();
            
            SendErrMsg( pRequest,
                        SSINCMSG_NO_EXECUTE_PERMISSION,
                        apszParms );
                        
            return FALSE;
        }

        if ( sgtType == SSI_GATEWAY_CGI )
        {
            if ( !strWorkingDir.Resize( ( cbBufLen + 1 ) * sizeof( CHAR ) ) )
            {
                return FALSE;
            }

            strWorkingDir.Copy( strFull.QueryStr() );
            *( strWorkingDir.QueryStr() + cbDirSize ) = TEXT('\0');

            fRet = ProcessCGI( pRequest,
                               &strFull,
                               &strURLParams,
                               &strWorkingDir,
                               NULL );
        }
        else
        {
            fRet = ProcessBGI( pRequest,
                               &strFull,
                               &strURLParams );
        }
        break;
    }
    case SSI_GATEWAY_CMD:
        fRet = ProcessCGI( pRequest,
                           NULL,
                           NULL,
                           NULL,
                           pstrPath );
        break;
    default:
        TCP_ASSERT( 0 );
    }                       
    return fRet;
}

VOID
FreeSELBlob(
    VOID * pvCacheBlob
    )
{
    if ( pvCacheBlob )
    {
        TCP_ASSERT( (*((SSI_ELEMENT_LIST **)pvCacheBlob))->CheckSignature() );
        delete *((SSI_ELEMENT_LIST **)pvCacheBlob);
    }
}

CHAR *
SSISkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
    )
{
    while ( pchFilePos < pchEOF )
    {
        if ( *pchFilePos == ch )
            return pchFilePos;

        pchFilePos++;
    }

    return NULL;
}

CHAR *
SSISkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
    )
{
    while ( pchFilePos < pchEOF )
    {
        if ( !isspace( *pchFilePos ) )
            return pchFilePos;

        pchFilePos++;
    }

    return NULL;
}

//
// SSI_FILE utilities
//

SSI_FILE * SSICreateFile( IN STR * pstrFilename,
                          IN HANDLE hUser )
// Opens a file to be read.  For now use Win32, later may use ISAPI
// Returns SSI_FILE structure to be used throughout access of file
{
    SSI_FILE *              pssiFile;

    pssiFile = new SSI_FILE;
    if ( pssiFile == NULL )
    {
        return NULL;
    }
#ifdef DO_CACHE
    TS_OPEN_FILE_INFO *             hHandle;

    hHandle = TsCreateFile( *g_ptsvcCache,
                            pstrFilename->QueryStr(),
                            hUser,
                            TS_CACHING_DESIRED );
#else
    HANDLE                          hHandle;
    
    hHandle = ::CreateFile( pstrFilename->QueryStr(),
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
    if ( hHandle == INVALID_HANDLE_VALUE )
    {
        hHandle = NULL;
    }
#endif
    if ( hHandle == NULL )
    {
        delete pssiFile;
        return NULL;
    }
    pssiFile->_hHandle = hHandle;
    pssiFile->_strFilename.Copy( pstrFilename->QueryStr() );
    return pssiFile;
}

VOID SSICloseFile( IN SSI_FILE * pssiFile )
// Closes file and destructs SSI_FILE structure
{
    if ( pssiFile->_pvMappedBase != NULL )
    {
        SSIUnmapViewOfFile( pssiFile );
    }
    if ( pssiFile->_hMapHandle != NULL )
    {
        SSICloseMapHandle( pssiFile );
    }
    if ( pssiFile->_hHandle != NULL )
    {
#ifdef DO_CACHE
        TsCloseHandle( *g_ptsvcCache,
                       pssiFile->_hHandle );
#else
        ::CloseHandle( pssiFile->_hHandle );
#endif
    }
    delete pssiFile;
}

BOOL SSICreateFileMapping( IN SSI_FILE * pssiFile )
// Creates a mapping to a file
{
    HANDLE              hHandle;

#ifdef DO_CACHE
    hHandle = pssiFile->_hHandle->QueryFileHandle();
#else
    hHandle = pssiFile->_hHandle;
#endif
    if ( pssiFile->_hMapHandle != NULL )
    {
        if ( !SSICloseMapHandle( pssiFile ) )
        {
            return FALSE;
        }
    }
    pssiFile->_hMapHandle = ::CreateFileMapping( hHandle,
                                                 NULL,
                                                 PAGE_READONLY,
                                                 0,
                                                 0,
                                                 NULL );
    
    return pssiFile->_hMapHandle != NULL;
}

BOOL SSICloseMapHandle( IN SSI_FILE * pssiFile )
// Closes mapping to a file
{
    if ( pssiFile->_hMapHandle != NULL )
    {
        ::CloseHandle( pssiFile->_hMapHandle );
        pssiFile->_hMapHandle = NULL;
    }
    return TRUE;
}

BOOL SSIMapViewOfFile( IN SSI_FILE * pssiFile )
// Maps file to address
{
    if ( pssiFile->_pvMappedBase != NULL )
    {
        if ( !UnmapViewOfFile( pssiFile ) )
        {
            return FALSE;
        }
    }
    pssiFile->_pvMappedBase = ::MapViewOfFile( pssiFile->_hMapHandle,
                                               FILE_MAP_READ,
                                               0,
                                               0,
                                               0 );
    return pssiFile->_pvMappedBase != NULL;
}

BOOL SSIUnmapViewOfFile( IN SSI_FILE * pssiFile )
// Unmaps file
{
    if ( pssiFile->_pvMappedBase != NULL )
    {
        ::UnmapViewOfFile( pssiFile->_pvMappedBase );
        pssiFile->_pvMappedBase = NULL;
    }
    return TRUE;
}

DWORD SSIGetFileAttributes( IN SSI_FILE * pssiFile )
// Gets the attributes of a file
{
#ifdef DO_CACHE
    return pssiFile->_hHandle->QueryAttributes();
#else
    return ::GetFileAttributes( pssiFile->_strFilename.QueryStr() );
#endif
}

BOOL SSIGetFileSize( IN SSI_FILE * pssiFile,
                  OUT DWORD *   pdwLowWord,
                  OUT DWORD *   pdwHighWord )
// Gets the size of the file. 
{
#ifdef DO_CACHE
    return pssiFile->_hHandle->QuerySize( pdwLowWord,
                                          pdwHighWord );
#else
    *pdwLowWord = ::GetFileSize( pssiFile->_hHandle,
                                 pdwHighWord );
    return *pdwLowWord != 0xfffffff;
#endif
}

BOOL SSIGetLastModTime( IN SSI_FILE *  pssiFile,
                     OUT FILETIME * ftTime )
// Gets the Last modification time of a file.
{
    HANDLE          hHandle;

#ifdef DO_CACHE
    hHandle = pssiFile->_hHandle->QueryFileHandle();
#else
    hHandle = pssiFile->_hHandle;
#endif
    return ::GetFileTime( hHandle,
                          NULL,
                          NULL,
                          ftTime );
}

//
// ISAPI DLL Required Entry Points
//

DWORD
WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    STR                     strLogMessage;
    BOOL                    bRet;
    DWORD                   dwStringID;
    LPCTSTR                 apsz[ 1 ];

    TCP_PRINT(( DBG_CONTEXT,
                "HttpExtensionProc() entry point called\n" ));

    SSI_REQUEST ssiReq = pecb;
    bRet = ssiReq.ProcessSSI();
    
    apsz[ 0 ] = pecb->lpszPathInfo;
    strLogMessage.FormatString( bRet ? SSINCMSG_LOG_SUCCESS : SSINCMSG_LOG_ERROR,
                                apsz,
                                SSI_DLL_NAME );


    strncpy( pecb->lpszLogData,
             strLogMessage.QueryStr(),
             HSE_LOG_BUFFER_LEN );

    return bRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR;
}

BOOL
WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 0, 1 );
    strcpy( pver->lpszExtensionDesc,
            "Server Side Include Extension DLL" );
    return TRUE;
}

BOOL
WINAPI
TerminateExtension(
    DWORD dwFlags
    )
{
    return TRUE;
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( SSI_DLL_NAME );
        SET_DEBUG_FLAGS( 0 );
    
        if ( InitializeCGI() != NO_ERROR )
        {
            return FALSE;
        }
        if ( InitializeBGI() != NO_ERROR )
        {
            return FALSE;
        }
#ifdef DO_CACHE
        g_ptsvcCache = new TSVC_CACHE( SSINC_SVC_ID );
        if ( g_ptsvcCache == NULL )
        {
            return FALSE;
        }
#endif
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:
        TerminateCGI();
#ifdef DO_CACHE
        TsCacheFlush( SSINC_SVC_ID );
        delete g_ptsvcCache;
#endif
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\test\w3test.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    w3test.c

Abstract:

    This module tests the web server's server extension interface

Author:

    John Ludeman (johnl)   13-Oct-1994

Revision History:

    Tony Godfrey (tonygod) 15-Sep-1997 - fixed TerminateExtension

--*/

#include <windows.h>
//#include <httpext.h>
#include <iisext.h>

// Global variable used to track outstanding threads
DWORD g_dwThreadCount;

#define BUFFER_LENGTH 4096

// Debug macro
CHAR g_szDebug[256];
#define DEBUG(DebugString, Param)\
{\
    wsprintf( g_szDebug, DebugString, Param );\
    OutputDebugString( g_szDebug );\
}

// Prototypes
DWORD WINAPI SimulatePendIOThread( LPDWORD lpParams );
BOOL WINAPI DllMain( HANDLE hInst, ULONG Reason, LPVOID Reserved );

BOOL WINAPI DoAction(
    EXTENSION_CONTROL_BLOCK * pecb,
    char * pszAction,
    BOOL * pfKeepConn
    );

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK * pecb )
{
    BOOL fKeepConn = FALSE;
    DWORD dwThreadId;
    HANDLE hThread;

    if ( !_strnicmp( pecb->lpszQueryString,
                    "SimulatePendingIO",
                    17))
    {
        InterlockedIncrement( &g_dwThreadCount );
        hThread = CreateThread( 
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) SimulatePendIOThread,
            pecb,
            0,
            &dwThreadId 
            );
        if ( hThread == NULL ) {
            InterlockedDecrement( &g_dwThreadCount );
        } else {
            CloseHandle( hThread );
        }

        return HSE_STATUS_PENDING;
    }
    else
    {
        if ( !DoAction( pecb,
                        pecb->lpszQueryString,
                        &fKeepConn ))
        {
            return HSE_STATUS_ERROR;
        }
    }

    return fKeepConn ? HSE_STATUS_SUCCESS_AND_KEEP_CONN :
                       HSE_STATUS_SUCCESS;
}

BOOL WINAPI DoAction(
    EXTENSION_CONTROL_BLOCK * pecb,
    char * pszAction,
    BOOL * pfKeepConn
    )
{
    char *buff;
    int  ret;
    int  i;
    int  cb;

    buff = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, BUFFER_LENGTH + 1 );
    if ( buff == NULL ) {
        return FALSE;
    }
    //
    // Log the request here
    //

    strcpy( pecb->lpszLogData, ", ISAPI Data->" );
    strcat( pecb->lpszLogData, pszAction );

    if ( !_stricmp( pszAction,
                  "HSE_REQ_SEND_URL_REDIRECT_RESP" ))
    {
        //
        //  pecb->pszPathInfo is the URL to redirect to
        //

        HeapFree( GetProcessHeap(), 0, buff );
        return pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_URL_REDIRECT_RESP,
                                  pecb->lpszPathInfo,
                                  NULL,
                                  NULL );
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_SEND_URL" ))
    {
        //
        //  pecbb->lpszPathInfo is the URL to send
        //

        HeapFree( GetProcessHeap(), 0, buff );
        return pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_URL,
                                  pecb->lpszPathInfo,
                                  0,
                                  0 );
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_SEND_RESPONSE_HEADER" ))
    {
        wsprintf( buff,
                  "Content-type: text/html\r\n"
                  "\r\n"
                  "<head><title>Response header test</title></head>\n"
                  "<body><h1>HTTP status code supplied in the path info was \"%s\"</h1></body>\n",
                  pecb->lpszPathInfo );

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  pecb->lpszPathInfo,     // HTTP status code
                                  NULL,
                                  (LPDWORD) buff );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        cb = wsprintf( buff,
                       "Content-Type: text/html\r\n"
                       "\r\n"
                       "<head><title>Response header test</title></head>\n"
                       "<body><h1>Specified status code was %s</h1></body>\n",
                       pecb->lpszPathInfo );

        ret = pecb->WriteClient( pecb->ConnID,
                                 buff,
                                 &cb,
                                 0 );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_strnicmp( pszAction,
                          "GET_VAR",
                          7 ))
    {
        CHAR * pch;

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) "Content-Type: text/html\r\n"
                                            "\r\n" );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        cb = BUFFER_LENGTH;

        if ( !(pch = strchr( pszAction, '&' )) )
        {
            pch = "ALL_HTTP";
        }
        else
        {
            pch++;
        }

        ret = pecb->GetServerVariable( pecb->ConnID,
                                       pch,
                                       buff,
                                       &cb );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        strcat( buff, "\r\n" );

        cb = strlen( buff );

        ret = pecb->WriteClient( pecb->ConnID,
                                 buff,
                                 &cb,
                                 0 );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_MAP_URL_TO_PATH" ))
    {
        char Path[MAX_PATH + 1];
        DWORD cbPath = sizeof( Path );

        strcpy( Path, pecb->lpszPathInfo );

        ret = pecb->ServerSupportFunction( pecb->ConnID,
                                           HSE_REQ_MAP_URL_TO_PATH,
                                           Path,
                                           &cbPath,
                                           NULL );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        wsprintf( buff,
                  "Content-type: text/html\r\n"
                  "\r\n"
                  "<head><title>URL map test</title></head>\n"
                  "<body><h1>URL \"%s\" maps to \"%s\""
                  "cbPath is %d</h1></body>\n",
                  pecb->lpszPathInfo,
                  Path,
                  cbPath );

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) buff );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_stricmp( pszAction,
                       "HSE_REQ_MAP_URL_TO_PATH_EX" ))
    {
        HSE_URL_MAPEX_INFO  mapinfo;

        ret = pecb->ServerSupportFunction( pecb->ConnID,
                                           HSE_REQ_MAP_URL_TO_PATH_EX,
                                           pecb->lpszPathInfo,
                                           NULL,
                                           (DWORD *) &mapinfo );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        wsprintf( buff,
                  "Content-type: text/html\r\n"
                  "\r\n"
                  "<head><title>URL map_ex test</title></head>\n"
                  "<body><h1>URL \"%s\" maps to \"%s\""
                  "dwFlags = 0x%08x\n"
                  "cchMatchingPath = %d\n"
                  "cchMatchingURL  = %d\n</h1></body>",
                  pecb->lpszPathInfo,
                  mapinfo.lpszPath,
                  mapinfo.dwFlags,
                  mapinfo.cchMatchingPath,
                  mapinfo.cchMatchingURL );

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) buff );

        HeapFree( GetProcessHeap(), 0, buff );
        return ret;
    }
    else if ( !_stricmp( pszAction,
                       "Keep_Alive" ))
    {
        DWORD cbBuff = BUFFER_LENGTH;
        DWORD cbDoc;
        CHAR  achDoc[4096];
        BOOL  fKeepAlive = FALSE;

        if ( !pecb->GetServerVariable( pecb->ConnID,
                                       "HTTP_CONNECTION",
                                       buff,
                                       &cbBuff ))
        {
            *buff = '\0';
        }

        cbDoc = wsprintf( achDoc,
                          "<head><title>Keep alive test</title></head>\n"
                          "This document is being kept alive."
                        );

        //
        //  This assumes keep-alive comes first in the list
        //

        if ( !_strnicmp( buff, "keep-alive", 10 ))
        {
            fKeepAlive = TRUE;
            wsprintf( buff,
                      "Content-type: text/html\r\n"
                      "Connection: keep-alive\r\n"
                      "Content-Length: %d\r\n"
                      "\r\n",
                      cbDoc );
        }
        else
        {
            wsprintf( buff,
                      "Content-type: text/html\r\n"
                      "\r\n"
                      "<head><title>Keep alive test</title></head>\n"
                      "Client did not specify keep alive!"
                      );
        }

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) buff ) &&
              pecb->WriteClient( pecb->ConnID,
                                 achDoc,
                                 &cbDoc,
                                 0 );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        if ( fKeepAlive ) {
            *pfKeepConn = TRUE;
        }

        HeapFree( GetProcessHeap(), 0, buff );
        return TRUE;
    }
    else if ( !strncmp( pszAction,
                        "Open_Reg",
                        7 ))
    {
        CHAR * pch;
        DWORD  err;
        HKEY   hKey;
        HKEY   hSubKey;
        HANDLE hFile;

        ret = pecb->ServerSupportFunction(
                                  pecb->ConnID,
                                  HSE_REQ_SEND_RESPONSE_HEADER,
                                  NULL,
                                  NULL,
                                  (LPDWORD) "Content-Type: text/html\r\n"
                                            "\r\n" );

        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        //
        //  The path info begins with the portion of the registry to open
        //

        if ( !_strnicmp( pecb->lpszPathInfo + 1,
                        "HKEY_CLASSES_ROOT",
                        17 ))
        {
            pch = pecb->lpszPathInfo + 19;
            hKey = HKEY_CLASSES_ROOT;
        }
        else if ( !_strnicmp( pecb->lpszPathInfo + 1,
                        "HKEY_CURRENT_USER",
                        17 ))
        {
            pch = pecb->lpszPathInfo + 19;
            hKey = HKEY_CURRENT_USER;
        }
        else if ( !_strnicmp( pecb->lpszPathInfo + 1,
                             "HKEY_LOCAL_MACHINE",
                             18 ))
        {
            pch = pecb->lpszPathInfo + 20;
            hKey = HKEY_LOCAL_MACHINE;
        }
        else if ( !_strnicmp( pecb->lpszPathInfo + 1,
                        "HKEY_USERS",
                        10 ))
        {
            pch = pecb->lpszPathInfo + 12;
            hKey = HKEY_USERS;
        }

        err = RegOpenKey( hKey,
                          pch,
                          &hSubKey );

        if ( err )
        {
            cb = wsprintf( buff,
                           "Failed to open registry key %s, error %d\n",
                           pecb->lpszPathInfo,
                           err );
        }
        else
        {
            cb = wsprintf( buff,
                           "Successfully opened registry key %s\n",
                           pecb->lpszPathInfo );

            RegCloseKey( hSubKey );
        }

        pecb->WriteClient( pecb->ConnID,
                           buff,
                           &cb,
                           0 );

        HeapFree( GetProcessHeap(), 0, buff );
        return TRUE;
    }

    else if ( !_stricmp( pszAction,
                       "Open_File" ))
    {
        CHAR  *pch;
        DWORD  err;
        HKEY   hKey;
        HKEY   hSubKey;
        HANDLE hFile;
        DWORD dwBytesRead;
        DWORD dwFileSize = 0;
        DWORD dwError;

        //
        //  The path translated is the filename to open
        //

        hFile = CreateFile(
            pecb->lpszPathTranslated,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            dwError = GetLastError();
            wsprintf(
                buff,
                "Content-Type: text/html\r\n\r\n"
                );
            ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );
            if ( !ret ) {
                HeapFree( GetProcessHeap(), 0, buff );
                return FALSE;
            }
            cb = wsprintf(
                buff,
                "<head><title>Unable to open file</title></head>\r\n"
                "<body><h1>Unable to open file</h1>\r\n"
                "CreateFile failed: %ld\r\n<p>"
                "Filename: %s<p></body>",
                dwError,
                pecb->lpszPathTranslated
                );
            pecb->WriteClient(
                pecb->ConnID,
                buff,
                &cb,
                0
                );
                
            HeapFree( GetProcessHeap(), 0, buff );
            return TRUE;
        }
        dwFileSize = GetFileSize( hFile, NULL );
        pch = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize + 1 );
        ret = ReadFile(
            hFile,
            pch,
            dwFileSize,
            &dwBytesRead,
            NULL
            );
        if ( !ret ) {
            dwError = GetLastError();
        }
        pch[dwBytesRead] = 0;
        CloseHandle( hFile );
        if ( !ret ) {
            wsprintf(
                buff,
                "Content-Type: text/html\r\n\r\n"
                );
            ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );
            if ( !ret ) {
                HeapFree( GetProcessHeap(), 0, buff );
                return FALSE;
            }
            cb = wsprintf(
                buff,
                "<head><title>Unable to Read File</title></head>\r\n"
                "<body><h1>Unable to Read File</h1>\r\n"
                "ReadFile failed: %ld<p>\r\n"
                "Filename: %s</body>",
                dwError,
                pecb->lpszPathTranslated
                );
            pecb->WriteClient(
                pecb->ConnID,
                buff,
                &cb,
                0
                );
                
            HeapFree( GetProcessHeap(), 0, buff );
            return TRUE;
        }

        wsprintf(
            buff,
            "Content-Type: text/html\r\n\r\n"
            );
        ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );
        if ( !ret ) {
            HeapFree( GetProcessHeap(), 0, buff );
            return FALSE;
        }

        pecb->WriteClient(
            pecb->ConnID,
            pch,
            &dwBytesRead,
            0
            );

        HeapFree( GetProcessHeap(), 0, buff );
        HeapFree( GetProcessHeap(), 0, pch );

        return TRUE;
    }
        
    else if ( !_stricmp( pszAction,
                       "SimulateFault" ))
    {
        *((CHAR *)0xffffffff) = 'a';
        HeapFree( GetProcessHeap(), 0, buff );
        return FALSE;
    }

    wsprintf( buff,
              "Content-Type: text/html\r\n\r\n"
              "<head><title>Unknown Test command</title></head>\n"
              "<body><h1>Unknown Test Command</h1>\n"
              "<p>Usage:"
              "<p>Query string contains one of the following:"
              "<p>"
              "<p> HSE_REQ_SEND_URL_REDIRECT_RESP"
              "<p> HSE_REQ_SEND_URL"
              "<p> HSE_REQ_SEND_RESPONSE_HEADER"
              "<p> HSE_REQ_MAP_URL_TO_PATH"
              "<p> GET_VAR&var_to_get"
              "<p> SimulateFault"
              "<p> Keep_Alive"
              "<p> Open_Reg"
              "<p> Open_File"
              "<p>"
              "<p> For example:"
              "<p>"
              "<p>   http://computer/scripts/w3test.dll?CGI_VAR"
              "<p>"
              "<p> or SimulatePendingIO with one of the above action strings"
              "<p>"
              "<p> such as:"
              "<p>"
              "<p> http://computer/scripts/w3test.dll?SimulatePendingIO&HSE_REQ_SEND_URL"
              "<p>"
              "<p> The Path info generally contains the URL or response to use"
              "</body>\n");

    ret = pecb->ServerSupportFunction(
                              pecb->ConnID,
                              HSE_REQ_SEND_RESPONSE_HEADER,
                              "200 OK",
                              NULL,
                              (LPDWORD) buff );

    cb = wsprintf( buff,
                   "<p>cbTotalBytes = %d<p> cbAvailable = %d<p>"
                   "lpszContentType = %s<p> lpszPathInfo = %s<p>"
                   "lpszPathTranslated = %s",
                   pecb->cbTotalBytes,
                   pecb->cbAvailable,
                   pecb->lpszContentType,
                   pecb->lpszPathInfo,
                   pecb->lpszPathTranslated );

    pecb->WriteClient( pecb->ConnID,
                       buff,
                       &cb,
                       0 );

    cb = pecb->cbAvailable;

    pecb->WriteClient( pecb->ConnID,
                       pecb->lpbData,
                       &cb,
                       0 );


    while ( pecb->cbAvailable < pecb->cbTotalBytes )
    {
        cb = min( pecb->cbTotalBytes - pecb->cbAvailable, BUFFER_LENGTH );

        if ( !pecb->ReadClient( pecb->ConnID,
                                buff,
                                &cb ) ||
             !cb )
        {
            break;
        }

        pecb->cbAvailable += cb;

        pecb->WriteClient( pecb->ConnID,
                           buff,
                           &cb,
                           0 );

    }

    HeapFree( GetProcessHeap(), 0, buff );
    return TRUE;
}

DWORD WINAPI SimulatePendIOThread( LPDWORD lpParams )
{
    EXTENSION_CONTROL_BLOCK * pecb = (EXTENSION_CONTROL_BLOCK *) lpParams;
    char *psz;
    DWORD dwStatus;
    BOOL fKeepConn = FALSE;

    Sleep( 5000 );

    psz = strchr( pecb->lpszQueryString, '&' );

    if ( psz )
        psz++;
    else
        psz = "No action string specified";

    DoAction( pecb,
              psz,
              &fKeepConn );

    dwStatus = fKeepConn ? HSE_STATUS_SUCCESS_AND_KEEP_CONN :
               HSE_STATUS_SUCCESS;

    pecb->ServerSupportFunction( pecb,
                                 HSE_REQ_DONE_WITH_SESSION,
                                 &dwStatus,
                                 0,
                                 0 );
    InterlockedDecrement( &g_dwThreadCount );
    return 0;
}


BOOL GetExtensionVersion( HSE_VERSION_INFO * pver )
{
    pver->dwExtensionVersion = MAKELONG( 0, 1 );
    strcpy( pver->lpszExtensionDesc, "Extension test example" );

    return TRUE;
}

BOOL TerminateExtension( DWORD dwFlags )
{
    DEBUG( "[W3Test.TerminateExtension] Extension terminating!\r\n", 0 );
    while ( g_dwThreadCount > 0 ) {
        DEBUG( "[W3Test.TerminateExtension] Thread Count: %ld\r\n", g_dwThreadCount );
        SleepEx( 1000, FALSE );
    }
    SleepEx( 1000, FALSE );
    return TRUE;
}


BOOL WINAPI DllMain( HANDLE hInst, ULONG Reason, LPVOID Reserved )
{
    switch( Reason ) {

       case DLL_PROCESS_ATTACH:
           g_dwThreadCount = 0;
           break;

       case DLL_PROCESS_DETACH:
           break;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\common\resource.h ===
// Used by dynodbc.rc
#define IDS_ERRORMSG                    1
#define IDS_ODBCERRMSG                  2

// Used by html.rc
#define IDS_EXPIREMSG                   3
#define IDS_RETURNMSG                   4
#define IDS_RETURNHTMLMSG               5
#define IDS_ENDHTML                     7
#define IDS_CREATE_ODBC_FAIL    8
#define IDS_CREATE_ODBC         10
#define IDS_DSNFORMEXE          11
#define IDS_LIST_ODBC_DRIVERS   12
#define IDS_ACCESS_DRIVER       13
#define IDS_DRIVER              14
#define IDS_DSN                 15
#define IDS_SQL_SERVER          16
#define IDS_SERVER              17
#define IDS_ACCESS_DRIVER_1     18
#define IDS_NEWDB               19
#define IDS_DBQ_EQUAL           20
#define IDS_DBQ                 21
#define IDS_GENERAL             22
#define IDS_ATTR                23
#define IDS_CREATE_DB           24
#define IDS_START_ODBC          25
#define IDS_DATASOURCE_CREATE   26
#define IDS_SUCCESSFUL          27
#define IDS_FAILED              28
#define IDS_SERVER_NAME_ATTR_STR    29
#define IDS_DATABASE_NAME_ATTR_STR  30
#define IDS_SPECIFY_ODBC        31
#define IDS_CREATE_ODBC_GETDRVR 32
#define IDS_CREATE_LOG_TABLE    33
#define IDS_ATTEMPT_CREATE_LOG  34
#define IDS_SELECT_NAME         35
#define IDS_OPTION              36
#define IDS_SELECT              37
#define IDS_CREATE_MS_LOG       38
#define IDS_CREATE_MS_LOG_2     39
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\common\dynodbc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dynodbc.c

Abstract:

    This module provides functions for dynamically loading the ODBC 
       functions.

Author:

    Murali R. Krishnan  (MuraliK)  3-Nov-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
# include "dynodbc.h"
# include "html.h"
#include "resource.h"

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

pfnSQLAllocConnect        pSQLAllocConnect   ;
pfnSQLAllocEnv            pSQLAllocEnv       ;
pfnSQLAllocStmt           pSQLAllocStmt      ;
pfnSQLBindCol             pSQLBindCol        ;
pfnSQLCancel              pSQLCancel         ;
pfnSQLColAttributes       pSQLColAttributes  ;
pfnSQLConnect             pSQLConnect        ;
pfnSQLDescribeCol         pSQLDescribeCol    ;
pfnSQLDisconnect          pSQLDisconnect     ;
pfnSQLError               pSQLError          ;
pfnSQLExecDirect          pSQLExecDirect     ;
pfnSQLExecute             pSQLExecute        ;
pfnSQLFetch               pSQLFetch          ;
pfnSQLFreeConnect         pSQLFreeConnect    ;
pfnSQLFreeEnv             pSQLFreeEnv        ;
pfnSQLFreeStmt            pSQLFreeStmt       ;
pfnSQLGetCursorName       pSQLGetCursorName  ;
pfnSQLNumResultCols       pSQLNumResultCols  ;
pfnSQLPrepare             pSQLPrepare        ;
pfnSQLRowCount            pSQLRowCount       ;
pfnSQLSetCursorName       pSQLSetCursorName  ;
pfnSQLTransact            pSQLTransact       ;

pfnSQLSetConnectOption    pSQLSetConnectOption;
pfnSQLDrivers             pSQLDrivers         ;
pfnSQLDataSources         pSQLDataSources     ;
pfnSQLBindParameter       pSQLBindParameter   ;

pfnSQLConfigDataSource    pSQLConfigDataSource ;

#define LOAD_ENTRY( Name )     (p##Name = (pfn##Name) GetProcAddress( hMod, #Name ))

static char szErrMsg[_MAX_PATH];
static char szODBCErrMsg[_MAX_PATH];

BOOL  fODBCLoaded = FALSE;

BOOL
DynLoadODBC(
    VOID
    )
{
    HMODULE hMod;

    if ( fODBCLoaded )
        return TRUE;

    if ( (hMod = (HMODULE) LoadLibrary( "odbc32.dll" ))) {

        if ( LOAD_ENTRY( SQLAllocConnect   )  &&
         LOAD_ENTRY( SQLAllocEnv       )  &&
         LOAD_ENTRY( SQLAllocStmt      )  &&
         LOAD_ENTRY( SQLBindCol        )  &&
         LOAD_ENTRY( SQLCancel         )  &&
         LOAD_ENTRY( SQLColAttributes  )  &&
         LOAD_ENTRY( SQLConnect        )  &&
         LOAD_ENTRY( SQLDescribeCol    )  &&
         LOAD_ENTRY( SQLDisconnect     )  &&
         LOAD_ENTRY( SQLError          )  &&
         LOAD_ENTRY( SQLExecDirect     )  &&
         LOAD_ENTRY( SQLExecute        )  &&
         LOAD_ENTRY( SQLFetch          )  &&
         LOAD_ENTRY( SQLFreeConnect    )  &&
         LOAD_ENTRY( SQLFreeEnv        )  &&
         LOAD_ENTRY( SQLFreeStmt       )  &&
         LOAD_ENTRY( SQLNumResultCols  )  &&
         LOAD_ENTRY( SQLPrepare        )  &&
         LOAD_ENTRY( SQLRowCount       )  &&
         LOAD_ENTRY( SQLTransact       )  &&
         LOAD_ENTRY( SQLSetConnectOption )  &&
         LOAD_ENTRY( SQLDrivers          )  &&
         LOAD_ENTRY( SQLDataSources      )  &&
         LOAD_ENTRY( SQLBindParameter    ))    {
			fODBCLoaded = TRUE;
            return TRUE;
        }
	}
     else {
		 HINSTANCE hInst = GetModuleHandle(NULL);

		 LoadString(hInst, IDS_ERRORMSG, szErrMsg, sizeof(szErrMsg));
		 LoadString(hInst, IDS_ODBCERRMSG, szODBCErrMsg, sizeof(szODBCErrMsg));
		 StartHTML(szODBCErrMsg, FALSE);
		 printf(szErrMsg);
		 EndHTML();
	 }
    return FALSE;
} // DynLoadODBC()


BOOL  fODBCInstallerLoaded = FALSE;

BOOL
DynLoadODBCInstaller(
    VOID
    )
{
    HMODULE hMod;

    if ( fODBCInstallerLoaded )
        return TRUE;

    if ( (hMod = (HMODULE) LoadLibrary( "odbccp32.dll" ))) {
		if ( LOAD_ENTRY( SQLConfigDataSource)) {
			fODBCInstallerLoaded = TRUE;
            return TRUE;
        }
	}
     else {
		 HINSTANCE hInst = GetModuleHandle(NULL);

		 LoadString(hInst, IDS_ERRORMSG, szErrMsg, sizeof(szErrMsg));
		 LoadString(hInst, IDS_ODBCERRMSG, szODBCErrMsg, sizeof(szODBCErrMsg));
		 StartHTML(szODBCErrMsg, FALSE);
		 printf(szErrMsg);
		 EndHTML();
	 }
               
    return FALSE;
} // DynLoadODBCInstaller()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\common\html.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      html.h

   Abstract:
      This header declares functions for starting and ending an HTML page.

   Author:

     Kyle Geiger (kyleg)  1995-12-1

   Revision History:

--*/


# ifndef _HTML_H_
# define _HTML_H_


void StartHTML(char * s, int fNoCache);
void EndHTML();
void TranslateEscapes(char * p, DWORD l);
void TranslateEscapes2(char * p, DWORD l);

//
// Converts SPACE to + for cgi arguments
//

void
ConvertSP2Plus(
    char * String1,
    char * String2
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\common\dynodbc.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      dynodbc.h

   Abstract:
      This header declares functions for dynamically loading ODBC.

   Author:

       Murali R. Krishnan    ( MuraliK )    3-Nov-1995

   Environment:
       Win32 -- User Mode

   Project:
   
      

   Revision History:
      kyleg 1/9/96  Added SQLConfigDatasource from odbc installer
	                currently only used in NEWDSN.C

--*/

# ifndef _DYNODBC_H_
# define _DYNODBC_H_

/************************************************************
 *     Include Headers
 ************************************************************/


//
// SQL-ODBC interface headers
//
# include "sql.h"
# include "sqlext.h"
# include <odbcinst.h>


/************************************************************
 *   Dynamic Load support
 ************************************************************/

BOOL
DynLoadODBC(
    VOID
    );

//
//  Prototypes form sql.h
//

typedef RETCODE (SQL_API * pfnSQLAllocConnect)(
    HENV        henv,
    HDBC   FAR *phdbc);

typedef RETCODE (SQL_API * pfnSQLAllocEnv)(
    HENV   FAR *phenv);

typedef RETCODE (SQL_API * pfnSQLAllocStmt)(
    HDBC        hdbc,
    HSTMT  FAR *phstmt);

typedef RETCODE (SQL_API * pfnSQLBindCol)(
    HSTMT       hstmt,
    UWORD       icol,
    SWORD       fCType,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLCancel)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLColAttributes)(
    HSTMT       hstmt,
    UWORD       icol,
    UWORD       fDescType,
    PTR         rgbDesc,
	SWORD       cbDescMax,
    SWORD  FAR *pcbDesc,
    SDWORD FAR *pfDesc);

typedef RETCODE (SQL_API * pfnSQLConnect)(
    HDBC        hdbc,
    UCHAR  FAR *szDSN,
    SWORD       cbDSN,
    UCHAR  FAR *szUID,
    SWORD       cbUID,
    UCHAR  FAR *szAuthStr,
    SWORD       cbAuthStr);

typedef RETCODE (SQL_API * pfnSQLDescribeCol)(
    HSTMT       hstmt,
    UWORD       icol,
    UCHAR  FAR *szColName,
    SWORD       cbColNameMax,
    SWORD  FAR *pcbColName,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable);

typedef RETCODE (SQL_API * pfnSQLDisconnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLError)(
    HENV        henv,
    HDBC        hdbc,
    HSTMT       hstmt,
    UCHAR  FAR *szSqlState,
    SDWORD FAR *pfNativeError,
    UCHAR  FAR *szErrorMsg,
    SWORD       cbErrorMsgMax,
    SWORD  FAR *pcbErrorMsg);

typedef RETCODE (SQL_API * pfnSQLExecDirect)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLExecute)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFetch)(
    HSTMT       hstmt);

typedef RETCODE (SQL_API * pfnSQLFreeConnect)(
    HDBC        hdbc);

typedef RETCODE (SQL_API * pfnSQLFreeEnv)(
    HENV        henv);

typedef RETCODE (SQL_API * pfnSQLFreeStmt)(
    HSTMT       hstmt,
    UWORD       fOption);

typedef RETCODE (SQL_API * pfnSQLGetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursorMax,
    SWORD  FAR *pcbCursor);

typedef RETCODE (SQL_API * pfnSQLNumResultCols)(
    HSTMT       hstmt,
    SWORD  FAR *pccol);

typedef RETCODE (SQL_API * pfnSQLPrepare)(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

typedef RETCODE (SQL_API * pfnSQLRowCount)(
    HSTMT       hstmt,
    SDWORD FAR *pcrow);

typedef RETCODE (SQL_API * pfnSQLSetCursorName)(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursor);

typedef RETCODE (SQL_API * pfnSQLTransact)(
    HENV        henv,
    HDBC        hdbc,
    UWORD       fType);

//
//  Prototypes form sqlext.h
//

typedef RETCODE (SQL_API * pfnSQLSetConnectOption)(
    HDBC        hdbc,
    UWORD       fOption,
    UDWORD      vParam);

typedef RETCODE (SQL_API * pfnSQLDrivers)(
    HENV        henv,
    UWORD       fDirection,
	UCHAR FAR  *szDriverDesc,
	SWORD		cbDriverDescMax,
	SWORD FAR  *pcbDriverDesc,
	UCHAR FAR  *szDriverAttributes,
    SWORD       cbDrvrAttrMax,
    SWORD  FAR *pcbDrvrAttr);

typedef RETCODE (SQL_API * pfnSQLBindParameter)(
    HSTMT       hstmt,
	UWORD		ipar,
	SWORD		fParamType,
    SWORD       fCType,
	SWORD		fSqlType,
    UDWORD      cbColDef,
    SWORD       ibScale,
    PTR         rgbValue,
	SDWORD		cbValueMax,
    SDWORD FAR *pcbValue);

typedef RETCODE (SQL_API * pfnSQLDataSources)(
    HENV        henv,
    UWORD       fDirection,
    UCHAR  FAR *szDSN,
    SWORD       cbDSNMax,
    SWORD  FAR *pcbDSN,
    UCHAR  FAR *szDescription,
    SWORD       cbDescriptionMax,
    SWORD  FAR *pcbDescription);

typedef BOOL (INSTAPI * pfnSQLConfigDataSource) (
    HWND       hwndParent,
	WORD       fRequest,
    LPCSTR     lpszDriver,
    LPCSTR     lpszAttributes);




/************************************************************
 *   Variables  
 ************************************************************/

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

extern pfnSQLAllocConnect        pSQLAllocConnect   ;
extern pfnSQLAllocEnv            pSQLAllocEnv       ;
extern pfnSQLAllocStmt           pSQLAllocStmt      ;
extern pfnSQLBindCol             pSQLBindCol        ;
extern pfnSQLCancel              pSQLCancel         ;
extern pfnSQLColAttributes       pSQLColAttributes  ;
extern pfnSQLConnect             pSQLConnect        ;
extern pfnSQLDescribeCol         pSQLDescribeCol    ;
extern pfnSQLDisconnect          pSQLDisconnect     ;
extern pfnSQLError               pSQLError          ;
extern pfnSQLExecDirect          pSQLExecDirect     ;
extern pfnSQLExecute             pSQLExecute        ;
extern pfnSQLFetch               pSQLFetch          ;
extern pfnSQLFreeConnect         pSQLFreeConnect    ;
extern pfnSQLFreeEnv             pSQLFreeEnv        ;
extern pfnSQLFreeStmt            pSQLFreeStmt       ;
extern pfnSQLGetCursorName       pSQLGetCursorName  ;
extern pfnSQLNumResultCols       pSQLNumResultCols  ;
extern pfnSQLPrepare             pSQLPrepare        ;
extern pfnSQLRowCount            pSQLRowCount       ;
extern pfnSQLSetCursorName       pSQLSetCursorName  ;
extern pfnSQLTransact            pSQLTransact       ;

extern pfnSQLSetConnectOption    pSQLSetConnectOption;
extern pfnSQLDrivers             pSQLDrivers         ;
extern pfnSQLDataSources         pSQLDataSources     ;
extern pfnSQLBindParameter       pSQLBindParameter   ;

/* from odbcinst.h*/
extern pfnSQLConfigDataSource    pSQLConfigDataSource;


# endif // _DYNODBC_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\dsnform\dsnform.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  dsnform.c

  Abstract:

  Displays a driver and prompts for information necessary to create an
  ODBC datasource.   Special cases are made for SQL Server and Access drivers.

  Author:

  Kyle Geiger (kyleg)  1995-12-1

  Revision History:

  --*/


#include <windows.h>
#include <stdio.h>

#include "dynodbc.h"
#include "cgi.h"
#include "html.h"
#include "resource.h"

# define MAX_DATA       2048

#define SUCCESS(rc)    (!((rc)>>1))


int __cdecl
main( int argc, char * argv[])
{
    char    rgchQuery[MAX_DATA];
    CHAR    rgchQueryNS[MAX_DATA];
    char  pszExtra[MAX_DATA*3];
    DWORD   dwLen;
    CHAR    szSQLServer[MAX_DATA];
    CHAR    szAccessDriver[MAX_DATA];
    CHAR    szTmp[MAX_DATA*3];
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ( !DynLoadODBC())
        return (1);

        // Get the driver and attibute information from the link
        dwLen = GetEnvironmentVariableA( PSZ_QUERY_STRING_A, rgchQuery, MAX_DATA);

        // Convert percent escapes
        TranslateEscapes2(rgchQuery, dwLen);

        // do special case processing for certain drivers (sql server, access, ddp, other)
        strcpy(pszExtra,"");
        LoadString(hInst, IDS_SQL_SERVER, szSQLServer, sizeof(szSQLServer));
        LoadString(hInst, IDS_ACCESS_DRIVER_1, szAccessDriver, sizeof(szAccessDriver));
        if (!strcmp(rgchQuery, szSQLServer)) {
                // find server name from URL, put in  attribute string
                LoadString(hInst, IDS_SERVER_NAME_ATTR_STR, pszExtra, sizeof(pszExtra));
        }
        else if (!strcmp(rgchQuery, szAccessDriver)) {
                // find server name from URL, put in  attribute string
                LoadString(hInst, IDS_DATABASE_NAME_ATTR_STR, pszExtra, sizeof(pszExtra));
        }

    //
    // convert SPACE to +
    //

    ConvertSP2Plus(rgchQuery,rgchQueryNS);
//strcpy( rgchQueryNS, rgchQuery);
OutputDebugString("******************");
OutputDebugString(rgchQueryNS);
OutputDebugString("\n\r");

    LoadString(hInst, IDS_SPECIFY_ODBC, szTmp, sizeof(szTmp));
    StartHTML(szTmp, 0);
    LoadString(hInst, IDS_CREATE_ODBC, szTmp, sizeof(szTmp));
    printf( szTmp, rgchQuery, rgchQueryNS, pszExtra);

    EndHTML();

    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\common\html.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "resource.h"

void StartHTML(char * title, int fNoCache)
{
        char szExpireMsg[_MAX_PATH];
        char szReturnMsg[_MAX_PATH];
        char szReturnHtmlMsg[_MAX_PATH*4];
        HINSTANCE hInst = GetModuleHandle(NULL);

        LoadString(hInst, IDS_EXPIREMSG, szExpireMsg, sizeof(szExpireMsg));
        LoadString(hInst, IDS_RETURNMSG, szReturnMsg, sizeof(szReturnMsg));
        LoadString(hInst, IDS_RETURNHTMLMSG, szReturnHtmlMsg, sizeof(szReturnHtmlMsg));
        if (fNoCache)
                printf("%s\r\n", szExpireMsg);

    printf( szReturnHtmlMsg, title, szReturnMsg);
}

void EndHTML()
{
    char szEndHtml[_MAX_PATH];

    HINSTANCE hInst = GetModuleHandle(NULL);
    LoadString(hInst, IDS_ENDHTML, szEndHtml, sizeof(szEndHtml));
    printf( szEndHtml );
}


// translates HTTP escapes to ASCII equivalents
// assumes HTTP escapes are of the form %dd, where the first digit is 0-9 and
// the second is 0-F
void TranslateEscapes(char * p, long l)
{
        char * p2;
        int c1;
        int c2;

        for(p2=p; l; l--) {
                if (*p == '+' )
                        *p = ' ';

                if (*p == '%' && *(p+1) != '%') {
                        p++;
                        c1=toupper(*p);
                        c2=toupper(*(p+1));

                        //*p2++ = (*p-'0')*16 + ((*(p+1))>= 'A' ? *(p+1)-'A'+10 : *(p+1)-'0');

                        *p2++ = (c1>='A' ? c1-'A'+10 : c1-'0')*16 +
                                    (c2>='A' ? c2-'A'+10 : c2-'0');

                        p += 2;
            l -= 2;
            }
                else
                        *p2++=*p++;
        }

}


//
// This is like TranslateEscapes but fixes a problem where the description
// string gets broken
//

void
TranslateEscapes2(
                char * p,
                long len
                )
{
    char * p2;
    int c1;
    int c2;

    for(p2=p; len > 0; len--) {

        if (*p == '+' ) {
            *p = ' ';
        }

        if (*p == '%' && *(p+1) != '%') {

            p++;

            c1=toupper(*p);
            c2=toupper(*(p+1));

            //*p2++ = (*p-'0')*16 + ((*(p+1))>= 'A' ? *(p+1)-'A'+10 : *(p+1)-'0');

            *p2 = (c1>='A' ? c1-'A'+10 : c1-'0')*16 +
                                (c2>='A' ? c2-'A'+10 : c2-'0');

            if (*p2 == '+' ) {
                *p2 = ' ';
            }

            ++p2;

            p += 2;
            len -= 2;

        } else {
            *p2++=*p++;
        }
    }

    *p2 = '\0';

} // TranslateEscapes2



void
ConvertSP2Plus(
    char * String1,
    char * String2
    )
{
    char *p = String1;
    char *q = String2;
    char ch;

    do {

        ch = *p;

        *q = (ch == ' ') ? '+' : ch;

        ++p;
        ++q;

    } while (ch != '\0');

    return;

} // ConvertSP2Plus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\getdrvrs\getdrvrs.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  getdrvrs.c

  Abstract:

  This module returns a web page with all ODBC drivers installed on the web server.
  The drivers are displayed as links, which when clicked will launch another application
  (DSNFORM.EXE) to prompt for the data source name and other driver specific info

  Author:

  Kyle Geiger 17-Nov-1995
  (with thanks to MuraliK for providing the ODBC dynamic loading routines)

  Revision History:

  --*/


#include <windows.h>
#include <stdio.h>
#include "dynodbc.h"
#include "html.h"
#include "resource.h"

#define MAX_DATA       2048

#define SUCCESS(rc)    (!((rc)>>1))

int
__cdecl
main( int argc, char * argv[])
{
    RETCODE rc;                    // Return code for ODBC functions
    HENV    henv;                  // Environment Handle

    char    szDriver[MAX_DATA+1];  // Variable to hold Driver name
    char    szDriverNS[MAX_DATA+1];  // Variable to hold Driver name with space
                                     // converted to +

    SWORD   cbDriver;              // Output length of data Driver
    char    szDesc[MAX_DATA+1];    // Variable to hold Driver description
    SWORD   cbDesc;                // Output length of data description
    BOOL    fFirst;                // flag for first time through loop
    char    szList[MAX_DATA];      // driver list
    HINSTANCE hInst = GetModuleHandle(NULL);
    char szDsnFormExe[MAX_PATH];
    char szListODBCDrivers[MAX_PATH];
    char szCreateODBC[MAX_PATH*3];

           // see if ODBC is installed and can load.  If not, an error is returned
    if ( !DynLoadODBC())
            return (1);

        // retrieve all installed drivers, put in szList formatted as HTML links to DSNFORM.EXE
    pSQLAllocEnv(&henv);
    rc=pSQLDrivers(henv, SQL_FETCH_FIRST,
                   (UCHAR FAR *) szDriver,
                   MAX_DATA, &cbDriver,
                   (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);

        fFirst=FALSE;
        szList[0]='\0';

    while (SUCCESS(rc)) {

        //
        // Replace SP with +
        //

        strcpy(szDriverNS, szDriver);

        if (!fFirst) {
            fFirst=TRUE;
        }

        LoadString(hInst, IDS_DSNFORMEXE, szDsnFormExe, sizeof(szDsnFormExe));

        sprintf(
            szList+strlen(szList),szDsnFormExe,
            szDriverNS, szDriver);

        rc=pSQLDrivers(henv, SQL_FETCH_NEXT,
                     (UCHAR FAR * ) szDriver, MAX_DATA, &cbDriver,
                     (UCHAR FAR * ) szDesc, MAX_DATA, &cbDesc);
    }

        LoadString(hInst, IDS_LIST_ODBC_DRIVERS, szListODBCDrivers, sizeof(szListODBCDrivers));
        StartHTML(szListODBCDrivers, FALSE);
        // if no drivers found, return error page
    if (!fFirst) {
        LoadString(hInst, IDS_CREATE_ODBC_FAIL, szCreateODBC, sizeof(szCreateODBC));
        printf( szCreateODBC );
    }
        // otherwise, display the driver names as links
    else {
        LoadString(hInst, IDS_CREATE_ODBC_GETDRVR, szCreateODBC, sizeof(szCreateODBC));
         printf( szCreateODBC ,szList);
    }
        EndHTML();
    pSQLFreeEnv(henv);
    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\mkilog\mkilog.c ===
/*++
  
  Copyright (c) 1994  Microsoft Corporation
  
  Module Name:
  
  mkilog.c
  
  Abstract:
  
  This module creates a log table using ODBC data sources.
  
  Author:
  
  Kyle Geiger & Murali R. Krishnan  (MuraliK)  1-Nov-1995
  
  Revision History:
  
  --*/


#include <windows.h>
#include <stdio.h>

# include "dynodbc.h"
#include "html.h"
#include "resource.h"

# define DEFAULT_LEN       ( 256)
# define MAX_DATA       2048

# define FOUND_DRIVER   ( 7)
#define SUCCESS(rc)    (!((rc)>>1))


int __cdecl
main( int argc, char * argv[])
{
    RETCODE rc;          // Return code for ODBC functions
    HENV    henv;           // Environment Handle
    char    szDSN[MAX_DATA+1];  // Variable to hold DSN name
    SWORD   cbDSN;         // Output length of data DSN
    char    szDesc[MAX_DATA+1]; // Variable to hold DSN description
    SWORD   cbDesc;        // Output length of data description
    int     fFirst;
    char    szList[MAX_DATA];
    char    szSQLServer[MAX_DATA];
    char    szCreateLogTable[MAX_DATA];
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ( !DynLoadODBC()) 
        return (1);

    
    pSQLAllocEnv(&henv);
    rc=pSQLDrivers(henv, SQL_FETCH_FIRST, 
                   (UCHAR FAR *) szDSN, 
                   MAX_DATA, &cbDSN, 
                   (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);

    LoadString(hInst, IDS_SQL_SERVER, szSQLServer, sizeof(szSQLServer));
    while (SUCCESS(rc)) {
        if (!_stricmp(szDSN, szSQLServer) )
          rc=FOUND_DRIVER;
        else
          rc=pSQLDrivers(henv, SQL_FETCH_NEXT, 
                         (UCHAR FAR * ) szDSN, MAX_DATA, &cbDSN, 
                         (UCHAR FAR * ) szDesc, MAX_DATA, &cbDesc);
    }
    LoadString(hInst, IDS_CREATE_LOG_TABLE, szCreateLogTable, sizeof(szCreateLogTable));
    StartHTML(szCreateLogTable, 1);
    if (FOUND_DRIVER != rc) {
        char    szAttemptCreateLog[MAX_DATA*3];
        LoadString(hInst, IDS_ATTEMPT_CREATE_LOG, szAttemptCreateLog, sizeof(szAttemptCreateLog));
        printf( szAttemptCreateLog);
        pSQLFreeEnv(henv);
        return (1);
    }

    rc=pSQLDataSources(henv, SQL_FETCH_FIRST, 
                       (UCHAR FAR *) szDSN, MAX_DATA, &cbDSN, 
                       (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);

    fFirst=FALSE;
    while (SUCCESS(rc)) {
        if (!_stricmp(szDesc, szSQLServer) ) {
            char    szOption[MAX_DATA];
            if (!fFirst) {
                char    szSelectName[MAX_DATA];
                fFirst=TRUE;
                LoadString(hInst, IDS_SELECT_NAME, szSelectName, sizeof(szSelectName));
                strcpy(szList,szSelectName);
            }
            LoadString(hInst, IDS_OPTION, szOption, sizeof(szOption));
            sprintf(szList+strlen(szList),szOption, szDSN);
        }
        rc=pSQLDataSources(henv, SQL_FETCH_NEXT, 
                           (UCHAR FAR *) szDSN, MAX_DATA, &cbDSN, 
                           (UCHAR FAR *) szDesc, MAX_DATA, &cbDesc);
    } // while data sources found

    /* any datasources for SQL Server found?  if so, generate the form for create*/
    if (fFirst) {
        char    szSelect[MAX_DATA];
        char    szCreateMSLog[MAX_DATA*3];
        LoadString(hInst, IDS_SELECT, szSelect, sizeof(szSelect));
        strcat(szList, szSelect);

        LoadString(hInst, IDS_CREATE_MS_LOG, szCreateMSLog, sizeof(szCreateMSLog));
        printf( szCreateMSLog, szList);
    }
    else {
        char    szCreateMSLog[MAX_DATA*3];
        LoadString(hInst, IDS_CREATE_MS_LOG_2, szCreateMSLog, sizeof(szCreateMSLog));
        printf( szCreateMSLog );
        
    }
    EndHTML(); 
    pSQLFreeEnv(henv);
    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\gateways\tools\newdsn\newdsn.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  newdsn.c

  Abstract:

  This module creates a data source given information from DSNFORM.EXE

  Author:

  Kyle Geiger

  Revision History:

  --*/


#include <windows.h>
#include <stdio.h>
#include <odbcinst.h>
#include "dynodbc.h"
#include "cgi.h"
#include "html.h"
#include "resource.h"

# define MAX_DATA       1024

#define SUCCESS(rc)    (!((rc)>>1))


int __cdecl
main( int argc, char * argv[])
{
    BOOL rc;          // Return code for ODBC functions
    char    rgchQuery[MAX_DATA];
    long    dwLen;
        char *  p;
        char    szDriver[MAX_DATA];
        char *  pszDriver;
        char    szAttr[MAX_DATA];
        char *  pszAttr;
        char    szAttr2[MAX_DATA];
        char *  pszAttr2;
        BOOL    fCreateDB=FALSE;
        char    szAccessDriver[MAX_DATA];
        char    szDsn[MAX_DATA];
        char    szSQLServer[MAX_DATA];
        char    szServer[MAX_DATA];
        char    szNewDB[MAX_DATA];
        char    szDBQ[MAX_DATA];
        char    szDBQEqual[MAX_DATA];
        char    szGeneral[MAX_DATA];
        char    szTmp[MAX_DATA];
        char    szSuccessful[MAX_DATA];
        char    szFail[MAX_DATA];
        HINSTANCE hInst = GetModuleHandle(NULL);

    if ( !DynLoadODBC())
        return (1);

    // get dsn name, custom attributes, and attribute string from form
    dwLen = GetEnvironmentVariableA( PSZ_QUERY_STRING_A, rgchQuery, MAX_DATA);
        if (!dwLen)
        {
        // debugging cases
        /*
        strcpy(rgchQuery, "driver=SQL%20Server&dsn=foo2&attr=server%3D%7Bkyleg0%7D%3Bdbq%3Dpubs");
        strcpy(rgchQuery, "driver=Microsoft Access Driver (*.mdb)&dsn=foo4&dbq=c%3A%5Cfoo4.mdb&newdb=CREATE_DB&attr=");
        strcpy(rgchQuery, "driver=Microsoft Access Driver (*.mdb)&dsn=foo5&dbq=c%3A%5Cfoo4.mdb&newdb=dbq&attr=");
        */
        LoadString(hInst, IDS_ACCESS_DRIVER, szAccessDriver, sizeof(szAccessDriver));
        strcpy(rgchQuery, szAccessDriver);
        dwLen=strlen(rgchQuery);

        }

        // get rid of percent junk
        TranslateEscapes2(rgchQuery, dwLen);

        LoadString(hInst, IDS_DRIVER, szDriver, sizeof(szDriver));
        // find driver name from URL
        p=strstr(rgchQuery, szDriver)+7;
        pszDriver=szDriver;
        for(;p && *p && *p!='&'; p++)
                *pszDriver++= *p;
        *pszDriver++='\0';

        LoadString(hInst, IDS_DSN, szDsn, sizeof(szDsn));
        // find dsn name from URL, put in  attribute string
        p=strstr(rgchQuery, szDsn);
        pszAttr=szAttr;
        for(; p && *p && *p!='&'; p++)
                *pszAttr++= *p;
        *pszAttr++='\0';

        LoadString(hInst, IDS_SQL_SERVER, szSQLServer, sizeof(szSQLServer));
        LoadString(hInst, IDS_SERVER, szServer, sizeof(szServer));
        LoadString(hInst, IDS_ACCESS_DRIVER_1, szAccessDriver, sizeof(szAccessDriver));
        LoadString(hInst, IDS_NEWDB, szNewDB, sizeof(szNewDB));
        LoadString(hInst, IDS_DBQ, szDBQ, sizeof(szDBQ));
        LoadString(hInst, IDS_DBQ_EQUAL, szDBQEqual, sizeof(szDBQEqual));
        LoadString(hInst, IDS_GENERAL, szGeneral, sizeof(szGeneral));
        // do special case processing for certain drivers (sql server, access, ddp, other)
        if (!strcmp(szDriver, szSQLServer)) {
                // find server name from URL, put in  attribute string
                p=strstr(rgchQuery, szServer);
                for(; p && *p && *p!='&'; p++)
                        *pszAttr++= *p;
                *pszAttr++='\0';
        }
        else if (!strcmp(szDriver, szAccessDriver)) {
                // find database name from URL, put in  attribute string
                // the radio button group 'newdb' return either CREATE_DB for a new database
                // or DBQ for an existing MDB file
                // the edit control for the database name ('dbq') is appended after the CREATE_DB
                // or DBQ attribute
                p=strstr(rgchQuery, szNewDB)+6;
                fCreateDB=(*p=='C');

                // if creating a database, also need to add the dsn pointing to it
                // this requires two different attribute strings, one like:
                //    dsn=foo;CREATE_DB=<filename>, where the dsn is ignored
                // which is derived from
                //    dsn=foo&newdb=CREATE_DB&dbq=<filename>
                // and
                //    dsn=foo;dbq=<filename>
                // which is derived from
                //    dsn=foo&newdb=dbq&dbq=<filename>
                if (fCreateDB) {
                        strcpy(szAttr2, szAttr);
                        for(; p && *p && *p!='&'; p++)
                                *pszAttr++= *p;
                        // assert: szAttr= "driver=foo\0dsn=bar\0CREATE_DB"
                        // assert: szAttr2= "driver=foo\0dsn=bar\0"
                    p = strstr(rgchQuery, szDBQEqual)+3;
                        pszAttr2=szAttr2+strlen(szAttr2)+1;
                        strcpy(pszAttr2,szDBQ);
                        // assert: szAttr2= "driver=foo\0dsn=bar\0dbq"
                        pszAttr2+=3;
                        for(; p && *p && *p!='&'; p++) {
                            *pszAttr++= *p;
                                *pszAttr2++= *p;
                            }
                        // assert: szAttr= "driver=foo\0dsn=bar\0CREATE_DB=<filename>"
                        // assert: szAttr2= "driver=foo\0dsn=bar\0dbq=<filename>"
                        strcpy(pszAttr, szGeneral);
                    pszAttr+=9;
                        *pszAttr2++='\0';
                        *pszAttr2='\0';

                        // assert: szAttr= "driver=foo\0dsn=bar\0CREATE_DB=<filename> General"

                }
                else {
                p = strstr(rgchQuery, szDBQEqual);
                        for(; p && *p && *p!='&'; p++)
                           *pszAttr++= *p;
                }


        }

        LoadString(hInst, IDS_ATTR, szTmp, sizeof(szTmp));
        // now add any additional items from attribute string
        p=strstr(rgchQuery, szTmp);
        if (p != NULL) {
                p+=5;

        for(; p && *p && *p!='&'; p++) {
                if ( *p == ';' ) {
                        *pszAttr++='\0';
                } else if ( *p == '+') {
                        *pszAttr++=' ';
                } else {
                        *pszAttr++ = *p;
            }
        }
    }

        *pszAttr='\0';

         // call ODBC to add the data source
    rc= SQLConfigDataSource(NULL, ODBC_ADD_SYS_DSN, szDriver, szAttr);

        LoadString(hInst, IDS_CREATE_DB, szTmp, sizeof(szTmp));
        // special case for Access:  if just created a database, now need to add the DSN
        if (rc && strstr(rgchQuery, szTmp)) {
                rc= SQLConfigDataSource(NULL, ODBC_ADD_SYS_DSN, szDriver, szAttr2);
        }

        LoadString(hInst, IDS_START_ODBC, szTmp, sizeof(szTmp));
        StartHTML(szTmp, 1);
        LoadString(hInst, IDS_DATASOURCE_CREATE, szTmp, sizeof(szTmp));
        LoadString(hInst, IDS_SUCCESSFUL, szSuccessful, sizeof(szSuccessful));
        LoadString(hInst, IDS_FAILED, szFail, sizeof(szFail));
        printf( szTmp, (rc) ? szSuccessful : szFail );


    EndHTML();
    return (1);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\iwrproxy\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\iwrproxy\iwr_p_stub.c ===
#include "iwr_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\idl\makefile.inc ===
#
#   makefil0
#       Makefile for generating RPC stubs of W3 Service.
#
#   Specify the following in the file for use
#
#   CLIENT_DIR  
#   SERVER_DIR
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt

#
#  Name it w3svci to prevent conflicts with net\inc\w3svc.h
#

IDL_FILE_NAME   = w3svci
IDL_FLAGS       = -ms_ext -c_ext -oldnames $(MIDL_OPTIMIZATION_NT5)
IMPORTS         = ..\..\..\inc\infoimp

CLIENT_H        = $(O)\$(IDL_FILE_NAME)_c.h
SERVER_H        = $(O)\$(IDL_FILE_NAME)_s.h

CLIENT_ACF      = $(IDL_FILE_NAME).acf
SERVER_ACF      = $(IDL_FILE_NAME).acf

!IFNDEF  DISABLE_NET_UNICODE
UNICODE         = 1
NET_C_DEFINES   = -DUNICODE
!ENDIF


SDKINC          = $(SDK_INC_PATH)
INETINC         = -I..\..\..\inc
SDKCRTINC       = $(CRT_INC_PATH)

INCS            = -I. -I$(SDKINC) -I$(SDKCRTINC) $(INETINC)

CLIENT_STUB     = $(O)\$(IDL_FILE_NAME)_c.c
SERVER_STUB     = $(O)\$(IDL_FILE_NAME)_s.c

CLIENT_TARGETS  = $(CLIENT_STUB) \
                  $(CLIENT_H)
SERVER_TARGETS  = $(SERVER_STUB) \
                  $(SERVER_H)

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)
EXTRN_DEPENDS   = $(IDL_FILE_NAME).acf $(IMPORTS).h

CLIENT_FLAGS    = -server none -acf $(CLIENT_ACF) -header $(CLIENT_H)
SERVER_FLAGS    = -client none -acf $(SERVER_ACF) -header $(SERVER_H)

MSC_WARNING_LEVEL= /W3 /WX

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delsrc all

delsrc:
        -erase $(TARGETS)


#
#  MIDL Compile stuff
# 
$(CLIENT_TARGETS):  .\$(IDL_FILE_NAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(CLIENT_ACF)
    midl $(IDL_FLAGS) $(CPP) $(CLIENT_FLAGS) .\$(IDL_FILE_NAME).idl -cstub $(CLIENT_STUB) $(INCS)

$(SERVER_TARGETS):  .\$(IDL_FILE_NAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(SERVER_ACF)
    midl $(IDL_FLAGS) $(CPP) $(SERVER_FLAGS) .\$(IDL_FILE_NAME).idl -sstub $(SERVER_STUB) $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\iwrproxy\iwr_i_stub.c ===
#include "iwr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\iwrproxy\wam_p_stub.c ===
#include "wam_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\iwrproxy\wam_i_stub.c ===
#include "wam_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\mib\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll/obj is used.
     
   Author:

        Murali R. Krishnan    ( MuraliK )    23-Febt-1995

   Project:
       SNMP Extension agent for Gopher Service on Windows NT.

   Revision History:


   Note: 
      Most of the macros defined here are used only if DBG is set. Otherwise
         they just default to some null values, which compiler can take 
         care of.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   (  DbgOutputStderr | DbgOutputKdb)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_SNMP_INIT                  0x00001000
# define DEBUG_SNMP_TRAP                  0x00002000
# define DEBUG_SNMP_QUERY                 0x00004000
# define DEBUG_SNMP_RESOLVE               0x00008000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\mib\main.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for Http Service on Windows NT.

Created:

  MuraliK   22-Feb-1995

Revision History:
  Murali R. Krishnan (MuraliK)  16-Nov-1995 Removed undoc apis

--*/

/************************************************************
 *   Include Headers
 ************************************************************/

# include "mib.h"
# include "apiutil.h"

#define DEFAULT_TRACE_FLAGS     (DEBUG_SNMP_RESOLVE)

# include "dbgutil.h"
# include "iis64.h"

/************************************************************
 *   Variable Definitions
 ************************************************************/

//
// Definition of the MIB objects
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          HttpServer(3)
//                                              HttpStatistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//

static UINT   sg_rguiPrefix[] =  { 1, 3, 6, 1, 4, 1, 311, 1, 7, 3};
static AsnObjectIdentifier sg_MibOidPrefix =
                      OID_FROM_UINT_ARRAY( sg_rguiPrefix);

# define HTTP_PREFIX_OID_LENGTH    ( GET_OID_LENGTH( sg_MibOidPrefix))

# define HTTP_STATISTICS_OID_SUFFIX            ( 1)


//
// Following is the global description of all MIB Entries ( Mibe s) for
//   Http Service.
// Definition appears as:
//  Mibe( MIB Entry Name, Index in MIB Block, HttpStatisticsField)
//
//   Incidentally, MIB Entry suffix coincides with the entry name in OID Tree
//
//  Any New MIB should be added here. and dont change use of after this defn.
//

# define ALL_MIB_ENTRIES()    \
Mibe( TotalBytesSent_HighWord,     1,    TotalBytesSent.HighPart)       \
Mibe( TotalBytesSent_LowWord,      2,    TotalBytesSent.LowPart)        \
Mibe( TotalBytesReceived_HighWord, 3,    TotalBytesReceived.HighPart)   \
Mibe( TotalBytesReceived_LowWord,  4,    TotalBytesReceived.LowPart)    \
Mibe( TotalFilesSent,              5,    TotalFilesSent)                \
Mibe( TotalFilesReceived,          6,    TotalFilesReceived)            \
Mibe( CurrentAnonymousUsers,       7,    CurrentAnonymousUsers)         \
Mibe( CurrentNonAnonymousUsers,    8,    CurrentNonAnonymousUsers)      \
Mibe( TotalAnonymousUsers,         9,    TotalAnonymousUsers)           \
Mibe( TotalNonAnonymousUsers,      10,   TotalNonAnonymousUsers)        \
Mibe( MaxAnonymousUsers,           11,   MaxAnonymousUsers)             \
Mibe( MaxNonAnonymousUsers,        12,   MaxNonAnonymousUsers)          \
Mibe( CurrentConnections,          13,   CurrentConnections)            \
Mibe( MaxConnections,              14,   MaxConnections)                \
Mibe( ConnectionAttempts,          15,   ConnectionAttempts)            \
Mibe( LogonAttempts,               16,   LogonAttempts)                 \
Mibe( TotalOptions,                17,   TotalOptions)                  \
Mibe( TotalGets,                   18,   TotalGets)                     \
Mibe( TotalPosts,                  19,   TotalPosts)                    \
Mibe( TotalHeads,                  20,   TotalHeads)                    \
Mibe( TotalPuts ,                  21,   TotalPuts)                     \
Mibe( TotalDeletes ,               22,   TotalDeletes)                  \
Mibe( TotalTraces ,                23,   TotalTraces)                   \
Mibe( TotalMove,                   24,   TotalMove)                     \
Mibe( TotalCopy,                   25,   TotalCopy)                     \
Mibe( TotalMkcol,                  26,   TotalMkcol)                    \
Mibe( TotalPropfind,               27,   TotalPropfind)                 \
Mibe( TotalProppatch,              28,   TotalProppatch)                \
Mibe( TotalSearch,                 29,   TotalSearch)                   \
Mibe( TotalLock,                   30,   TotalLock)                     \
Mibe( TotalUnlock,                 31,   TotalUnlock)                   \
Mibe( TotalOthers,                 32,   TotalOthers)                   \
Mibe( CurrentCGIRequests,          33,   CurrentCGIRequests)            \
Mibe( CurrentBGIRequests,          34,   CurrentBGIRequests)            \
Mibe( TotalCGIRequests,            35,   TotalCGIRequests)              \
Mibe( TotalBGIRequests,            36,   TotalBGIRequests)              \
Mibe( MaxCGIRequests,              37,   MaxCGIRequests)                \
Mibe( MaxBGIRequests,              38,   MaxBGIRequests)                \
Mibe( CurrentBlockedRequests,      39,   CurrentBlockedRequests)        \
Mibe( TotalBlockedRequests,        40,   TotalBlockedRequests)          \
Mibe( TotalAllowedRequests,        41,   TotalAllowedRequests)          \
Mibe( TotalRejectedRequests,       42,   TotalRejectedRequests)         \
Mibe( TotalNotFoundErrors,         43,   TotalNotFoundErrors)           \
Mibe( TotalLockedErrors,           44,   TotalLockedErrors)             \
Mibe( MeasuredBandwidth,           45,   MeasuredBw)                    \
Mibe( CurrentCalAuth,              46,   CurrentCalAuth)                \
Mibe( MaxCalAuth,                  47,   MaxCalAuth)                    \
Mibe( TotalFailedCalAuth,          48,   TotalFailedCalAuth)            \
Mibe( CurrentCalSsl,               49,   CurrentCalSsl)                 \
Mibe( MaxCalSsl,                   50,   MaxCalSsl)                     \
Mibe( TotalFailedCalSsl,           51,   TotalFailedCalSsl)


//
// Individual OID Definitions.
//   All Leaf variables should have a zero appended to their OID to indicate
//   that it is the only instance of this variable and that it exists.
//  Declare just the id's starting from next to the prefix given above.
//


//
// Few Convenience Macros for MIB entries addition.
//

# define MIB_VAR_NAME( NameSuffix)       MIB_ ## NameSuffix

# define DEFINE_MIBOID( NameSuffix, uiArray)   \
           UINT MIB_VAR_NAME( NameSuffix)[] = uiArray

# define DEFINE_MIBOID_LEAF( NameSuffix, NodeNumber) \
           UINT MIB_VAR_NAME( NameSuffix)[] = \
                          { HTTP_STATISTICS_OID_SUFFIX, ( NodeNumber), 0 }

//
// Define all the OIDs. First define the higher level node and then leaves.
//
DEFINE_MIBOID( Statistics,     { HTTP_STATISTICS_OID_SUFFIX} );

//
//  Define the Leaf OIDs.
//
# define Mibe( NameSuffix, Index, FieldName)  \
     DEFINE_MIBOID_LEAF( NameSuffix, Index);

//
// Expand the macro ALL_MIB_ENTRIES to obtain definitions of MIB Leafs.
//
ALL_MIB_ENTRIES()

# undef Mibe


//
//  MIB Variable definition
//

//
// Define Mibe()  to be for variable definitions of counters.
//  Note that the comma is appearing before a new counter name. It is used
//   for structure initialization.
//

# define OFFSET_IN_HTTP_STATISTICS( Field)    \
     FIELD_OFFSET( W3_STATISTICS_1,   Field)

# define Mibe( NameSuffix, Index, Field)        \
     , MIB_COUNTER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( NameSuffix)), \
                    OFFSET_IN_HTTP_STATISTICS(Field),              \
                    MibStatisticsWorker)

static MIB_ENTRY  sg_rgHttpMib[] = {

    //
    // Statistics
    //

    MIB_ENTRY_HEADER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( Statistics)))
    ALL_MIB_ENTRIES()
};

# undef Mibe




static MIB_ENTRIES  sg_HttpMibs =
  {
    &sg_MibOidPrefix,
    ( sizeof( sg_rgHttpMib) / sizeof( MIB_ENTRY)),
    sg_rgHttpMib
  };



DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisW3MibGuid, 
0x784d891C, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif





/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    Http MIB DLL. It initialises local variables and prepares the
    interface for the process to use SNMP Extension Agents for HTTP service.

 Messages            Actions

    ProcessAttach        Initializes winsock and data structures.
                          It fails if winsock has not already been started.

    ProcessDetach        Cleans up local data structures and disconnects from
                         winsock.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH: {

        //
        // Initialize various modules
        //

        break;
    } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH: {

       //
       // Only cleanup when we are called because of a FreeLibrary().
       //  i.e., when lpvContext == NULL
       // If we are called because of a process termination, dont free anything
       //   the system will free resources and memory for us.
       //

       if ( lpvContext == NULL) {

           //
           // Code to be executed on successful termination
           //

           DELETE_DEBUG_PRINT_OBJECT();
       }

       break;
   } /* case DLL_PROCESS_DETACH */

   default:
       break;
  }    /* switch */

  return ( fReturn);
}  /* DllLibMain() */





/************************************************************
 *  Entry Points of SNMP Extension DLL For Http Service
 ************************************************************/

//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;





BOOL
SnmpExtensionInit(
    IN  DWORD                 dwTimeZeroReference,
    OUT HANDLE              * phPollForTrapEvent,
    OUT AsnObjectIdentifier * pAsnOidSupportedView
    )
/*++
  Description:
     The Extension Agent DLLs provide this entry point SnmpExtensionInit()
     to co-ordinate the initializations of the extension agent and the
     extendible  agent.
     The Extendible agent provides extension agent with a time zero reference.
     The Extension Agent provides Extendible agent with an Event Handle
         for communicating occurences of traps.
     The Extension Agent also provides Extendible agent with an ObjectId
         representing the root of the MIB structure
         that it (extension) supports.

  Arguments:
     dwTimeZeroReference    DWORD containing the Time Zero Reference for sync.
     phPollForTrapEvent     pointer to handle which on successful return
                             may contain an event handle to be polled for
                             traps.
     pAsnOidSupportedView   pointer to ASN ( Abstract Syntax Notation OID)
                             that contains the oid representing root of the
                             MIB structure.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "httpmib", IisW3MibGuid);
#else
    CREATE_DEBUG_PRINT_OBJECT( "httpmib");
    SET_DEBUG_FLAGS( DEBUG_SNMP_RESOLVE);    // enable flags if needed.
#endif

    IF_DEBUG( SNMP_INIT) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Entering SnmpExtensionInit( %u, %08x, %08x)\n",
                    dwTimeZeroReference,
                    phPollForTrapEvent,
                    pAsnOidSupportedView));
    }


    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *pAsnOidSupportedView = sg_MibOidPrefix; // NOTE!  structure copy

    //
    // Though the following is a handle, dont use INVALID_HANDLE_VALUE ( -1)
    //  because that constant is only for few people ( Win32). But all through
    //  NT invalid handle value is NULL ( 0).
    //

    *phPollForTrapEvent = NULL;

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return ( TRUE);

}   // SnmpExtensionInit()



BOOL
SnmpExtensionTrap(
    OUT AsnObjectIdentifier * pAsnOidEnterprise,
    OUT AsnInteger          * pAsniGenericTrap,
    OUT AsnInteger          * pAsniSpecificTrap,
    OUT AsnTimeticks        * pAsnTimeStamp,
    OUT RFC1157VarBindList  * pRfcVariableBindings
    )
/*++
  Description:
     This function is used to communicate traps to the Extendible Agent.
     The Extendible Agent will invoke this entry point when the trap event
      ( supplied at the initialization time) is asserted, which indicates
      that zero or more traps had occured.
     The Extendible agent will repeatedly query this function till this
      function returns FALSE.

  Arguments:
    pAsnOidEnterprise      pointer to ASN OID for Enterprise, indicating
                             original enterprise generating trap.
    pAsniGenericTrap       pointer to ASN Integer which on return will
                             contain the indication of the generic trap.
    pAsniSpecificTrap      pointer to ASN Integer which on return will
                             contain the specific trap generated.
    pAsnTimeStamp          pointer to ASN containing the received Time-Stamp.
    pRfcVariableBindings   pointer to RFC 1157 compliant variable bindings.


  Returns:
    TRUE if success and there are more traps to be queried.
    FALSE if all traps are answered and work done.

--*/
{

    IF_DEBUG( SNMP_TRAP) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering SnmpExtensionTrap( pOidE=%08x, pGenTrap=%08x,"
                    " pSpecificTrap = %08x, pTimeStamp=%08x, pVars=%08x)\n",
                    pAsnOidEnterprise,
                    pAsniGenericTrap,
                    pAsniSpecificTrap,
                    pAsnTimeStamp,
                    pRfcVariableBindings));
    }

    //
    //  We don't support traps (yet).
    //

    return ( FALSE);

}   // SnmpExtensionTrap()





BOOL
SnmpExtensionQuery(
    IN BYTE                     bRequestType,
    IN OUT RFC1157VarBindList * pRfcVariableBindings,
    OUT AsnInteger         *    pAsniErrorStatus,
    OUT AsnInteger         *    pAsniErrorIndex
    )
/*++
  Description:
    This function is called by Extendible Agent to resolve the SNMP requests
    for queries on MIB Variables in the Extension Agent's supported MIB view.
    ( which was supplied at initialization time).
    The Request Type is GET, GETNEXT, and SET.

  Arguments:
    bRequestType    byte containing the type of request.
                    It can be one of
                     ASN_RFC1157_GETREQUEST
                     ASN_RFC1157_GETNEXTREQUEST
                     ASN_RFC1157_SETREQUEST

    pRfcVariableBindings
                   pointer to RFC 1157 compliant variable bindings.

    pAsniErrorStatus
                   pointer to ASN Integer for Error Status

    pAsniErrorIndex
                  pointer to ASN INteger giving the index for error.

  Returns:
    TRUE on success and FALSE on failure.
--*/

{
    W3_STATISTICS_1    HttpStatistics;
    LPW3_STATISTICS_1  pHttpStatistics = NULL;
    NET_API_STATUS     Status;


    IF_DEBUG( SNMP_QUERY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering SnmpExtensionQuery( Req=0x%x, pVars=%08x,"
                    " pAsniError=%08x, pAsniIndex=%08x).\n",
                    bRequestType, pRfcVariableBindings,
                    pAsniErrorStatus, pAsniErrorIndex));
    }


    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //

    Status = W3QueryStatistics2(
                            NULL,                    // pszServer
                            0,
                            INET_INSTANCE_GLOBAL,
                            0,
                            (LPBYTE *) &pHttpStatistics );

    //
    //  Status Errors not checked for  here!
    //  Reason:
    //    If the verb is GET_NEXT beyond the block we support,
    //           then there is no need to worry about the error at all.
    //    If the verb is GET within the block, it will get NULL value
    //           ( due the memset() done above).
    //

    try
    {
        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        RFC1157VarBind * pVarBinding;

        for( pVarBinding = pRfcVariableBindings->list;
            pVarBinding < ( pRfcVariableBindings->list +
                            pRfcVariableBindings->len);
            pVarBinding++ ) {

            *pAsniErrorStatus = ResolveVarBinding( pVarBinding,
                                                  bRequestType,
                                                  pHttpStatistics,
                                                  &sg_HttpMibs);

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if(( *pAsniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
               ( bRequestType == MIB_GETNEXT ) ) {

                IF_DEBUG( SNMP_QUERY) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                "At the End of Mib View for this Agent."
                                "Incrementing the variable to next block.\n"));
                }

                *pAsniErrorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

                SNMP_oidfree( &pVarBinding->name );
                SNMP_oidcpy( &pVarBinding->name, &sg_MibOidPrefix);
                pVarBinding->name.ids[ HTTP_PREFIX_OID_LENGTH - 1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            *pAsniErrorIndex =
              (( *pAsniErrorStatus != SNMP_ERRORSTATUS_NOERROR ) ?
               (( DIFF(pVarBinding - pRfcVariableBindings->list)) + 1) : 0);

        } // for

    } // try
    except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  For now do nothing.
        //

        IF_DEBUG( SNMP_QUERY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Exception occured while resolving "
                        " SnmpExtensionQuery()"));
        }

    }

    if ( pHttpStatistics )
    {
        MIDL_user_free( pHttpStatistics );
    }

    IF_DEBUG( SNMP_QUERY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Returning from GophMib::Query() with "
                    " Error Status = %u. Error Index = %u.\n",
                    *pAsniErrorStatus,
                    *pAsniErrorIndex));
    }

    return ( SNMPAPI_NOERROR);
}   // SnmpExtensionQuery()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\perfmon\makefile.inc ===
MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)
BinariesROOT=$(_NTTREE)
InetsrvROOT=$(_NTTREE)\inetsrv

copyini:
        if not exist "$(BinariesROOT)" mkdir $(BinariesROOT)
        if not exist "$(InetsrvROOT)" mkdir $(InetsrvROOT)

#       old
#       $(MY_BINPLACE) w3ctrs51.ini
#       $(MY_BINPLACE) w3ctrs51.h
#
#       new
#       copy fileand rename to iis51 name
	echo f |xcopy /y w3ctrs.ini $(BinariesROOT)\w3ctrs51.ini
	echo f |xcopy /y w3ctrs.h $(InetsrvROOT)\w3ctrs51.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\mib\mib.c ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.c

   Abstract:

      This defines Auxiliary functions for defining an SNMP Extension Agent
         for collecting and querying Statistical information.

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Feb-1995

   Environment:

       User Mode -- Win32

   Project:

       SNMP Extension DLL for HTTP Service DLL

   Functions Exported:

     UINT  ResolveVarBinding();
     UINT  MibStatisticsWorker();

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "mib.h"

# include "dbgutil.h"

static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  );

static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics
  );


static VOID
PrintAsnObjectIdentifier( IN char * pszOidDescription,
                          IN AsnObjectIdentifier * pAsno)
{

# if DBG

    UINT len = pAsno->idLength;
    UINT i;

    DBG_ASSERT( pAsno != NULL);

    DBGPRINTF( ( DBG_CONTEXT,
                "Printing Oid %s = %08x. Length = %u.\n",
                pszOidDescription,
                pAsno, len));

    for(i = 0; i < len; i++) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "AsnOid[ %u] = %u\n",
                    i, pAsno->ids[i]));
    }

# endif // DBG

    return;
} // PrintAsnObjectIdentifier()




/************************************************************
 *    Functions
 ************************************************************/

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind   * pRfcVarBinding,
   IN BYTE                   pduAction,
   IN LPVOID                 pStatistics,
   IN LPMIB_ENTRIES          pMibEntries
  )
/*++
  Description:
    This function resolves a single variable binding. Modifies the variable
       on a GET or a GET-NEXT.

  Arguments:
     pRfcVarBinding    pointer to RFC Variable Bindings
     pduAction      Protocol Data Unit Action specified.
     pStatistics    pointer to statisitcs data structure containing
                      values of counter data.
     pMibEntries    pointer to MIB_ENTRIES context information
                      which contains prefix, array of MIB_ENTRIES and
                      count of the entries.
  Returns:
    Standard PDU error codes.

  Note:
--*/
{
    AsnObjectIdentifier  AsnTempOid;
    LPMIB_ENTRY  pMibScan;
    UINT         pduResult = SNMP_ERRORSTATUS_NOERROR;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // Search for the variable binding name in the mib.
    //

    IF_DEBUG( SNMP_RESOLVE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding( Var=%08x, Action=%x) called.\n",
                    pRfcVarBinding, pduAction));

        PrintAsnObjectIdentifier( " Variable to Resolve",
                                 &pRfcVarBinding->name);
    }

    for( pMibScan = pMibEntries->prgMibEntry;
        pMibScan < pMibUpperBound;
        pMibScan++) {

        int iCmpResult;

        //
        // Create a fully qualified OID for the current item in the MIB.
        //  and use it for comparing against variable to be resolved.
        //

        SNMP_oidcpy( &AsnTempOid, pMibEntries->pOidPrefix);
        SNMP_oidappend( &AsnTempOid, &pMibScan->asnOid);

        iCmpResult = SNMP_oidcmp( &pRfcVarBinding->name, &AsnTempOid);
        SNMP_oidfree( &AsnTempOid);

        IF_DEBUG( SNMP_RESOLVE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Comparing with suffix Oid  %08x yields %d\n",
                        &pMibScan->asnOid, iCmpResult));
            PrintAsnObjectIdentifier( " StatisticsSuffix",
                                      &pMibScan->asnOid);
        }

        if ( iCmpResult == 0) {

            //
            // Found a match. Stop the search and process.
            //

            break;

        } else
          if ( iCmpResult < 0) {

              //
              // This could be the OID of a leaf ( withoug a trailing 0) or
              //  it could contain an invalid OID ( between valid OIDs).
              //

              if ( pduAction == MIB_GETNEXT) {

                  //
                  // Advance the variable binding to next entry
                  //
                  SNMP_oidfree( &pRfcVarBinding->name);
                  SNMP_oidcpy( &pRfcVarBinding->name,
                                pMibEntries->pOidPrefix);
                  SNMP_oidappend( &pRfcVarBinding->name, &pMibScan->asnOid);

                  if ( ( pMibScan->bType != ASN_RFC1155_OPAQUE) &&
                       ( pMibScan->bType != ASN_SEQUENCE)) {

                      pduAction = MIB_GET;
                  }

              } else {

                  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              }

              //
              // Stop and process the appropriate entry.
              //

              break;
          } // ( iCmpResult < 0)

    } // for


    if ( pMibScan >= pMibUpperBound) {

        pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // A match is found or further processing is required.
        //

        DBG_ASSERT( pMibScan < pMibUpperBound);
        if ( pMibScan->pMibFunc == NULL) {

            //
            // This happens only if the match is for Group OID
            //

            pduResult = ( ( pduAction != MIB_GETNEXT) ?
                       SNMP_ERRORSTATUS_NOSUCHNAME:
                         MibGetNextVar( pRfcVarBinding,
                                       pMibScan,
                                       pMibEntries,
                                       pStatistics));
        } else {

            pduResult = ( pMibScan->pMibFunc) ( pRfcVarBinding,
                                               pduAction,
                                               pMibScan,
                                               pMibEntries,
                                               pStatistics);
        }
    }


    IF_DEBUG( SNMP_RESOLVE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding returns %u.\n",
                    pduResult));
    }

    return ( pduResult);

} // ResolveVarBinding()






UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT   pduResult = SNMP_ERRORSTATUS_NOERROR;
                 // default indicating action to be done at end of switch

    switch( pduAction) {

      case MIB_SET:
      case MIB_GETNEXT:

        // action is performed at the end of switch statement.
        break;


      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  If no statistics do no action.
        //  If this is the header field ( non-leaf) do no action
        //   Otherwise, perform action as if this is the leaf node.
        //

        if ( pStatistics == NULL || pMibeCurrent->lFieldOffset == -1) {

            pduResult = SNMP_ERRORSTATUS_GENERR;
        }

        // Action on this node is performed at the end of the switch statement.
        break;

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch()


    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // Use the generic leaf function to perform the action specified.
        //
        pduResult = MibLeafFunction( pRfcVarBinding, pduAction, pMibeCurrent,
                                    pMibEntries, pStatistics);
    }

    return ( pduResult);

} // MibStatisticsWorker()




static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics
    and that this is a leaf node of the MIB tree.
  This is a generic function for leaf nodes.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;  // default is error value.

    switch( pduAction ) {

      case MIB_GETNEXT:

        //
        //  Determine if we're within the range and not at the end.
        //  If not within the range the above default pduResult == NOSUCHNAME
        //         is the required error message.
        //

        if ( ( pMibeCurrent >= pMibEntries->prgMibEntry) &&
             ( pMibeCurrent <
              ( pMibEntries->prgMibEntry + pMibEntries->cMibEntries))) {

            pduResult = MibGetNextVar( pRfcVarBinding,
                                      pMibeCurrent,
                                      pMibEntries,
                                      pStatistics);
        }

        break;

      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  Make sure that this variable's ACCESS is GET'able.
        //  If the access prohibits from GETting it, report error as
        //    NOSUCHNAME ( default value of pduResult in initialization above)
        //

        if(( pMibeCurrent->uiAccess == MIB_ACCESS_READ ) ||
           ( pMibeCurrent->uiAccess == MIB_ACCESS_READWRITE ) ) {

            DWORD  dwValue;

            //
            //  Setup pRfcVarBinding's return value.
            //

            DBG_ASSERT( pStatistics != NULL);

            pRfcVarBinding->value.asnType = pMibeCurrent->bType;
            dwValue = *( (LPDWORD )((LPBYTE )pStatistics +
                                    pMibeCurrent->lFieldOffset));

            pduResult = SNMP_ERRORSTATUS_NOERROR;  // we found a value.

            switch( pMibeCurrent->bType)  {

              case ASN_RFC1155_GAUGE:
                pRfcVarBinding->value.asnValue.gauge = (AsnGauge ) dwValue;
                break;

              case ASN_RFC1155_COUNTER:
                pRfcVarBinding->value.asnValue.counter = (AsnCounter ) dwValue;
                break;

              case ASN_INTEGER:
                pRfcVarBinding->value.asnValue.number = (AsnInteger ) dwValue;
                break;

              case ASN_RFC1155_IPADDRESS:
              case ASN_OCTETSTRING:
                //
                //  Not supported for this MIB (yet).
                //  Fall through to indicate generic error.
                //

              default:

                //
                // Sorry! Type in Mibe does not suit our purpose.
                //   Indicate generic error.
                //
                pduResult = SNMP_ERRORSTATUS_GENERR;
                break;
            } // innner switch

        } // if ( valid read access)

        break;

      case MIB_SET:

        //
        //  We don't support settable variables (yet).
        //   Fall through for error.
        //

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch ( pduAction)


    return ( pduResult);

} // MibLeafFunction()





static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics)
/*++
  Description:
     This function sets the binding variable to iterate to the next variable.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.

  Returns:
     PDU Error Codes.
--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // If within the range of MIB ENTRIES process.
    //

    if ( pMibeCurrent >= pMibEntries->prgMibEntry) {

        //
        //  Scan through the remaining MIB Entries
        //

        LPMIB_ENTRY  pMibeScan;

        for( pMibeScan = pMibeCurrent+1;
             pMibeScan < pMibUpperBound;
             pMibeScan++ ) {

            //
            // Setup variable bindings for the next MIB variable
            //

            SNMP_oidfree( &pRfcVarBinding->name);
            SNMP_oidcpy( &pRfcVarBinding->name, pMibEntries->pOidPrefix);
            SNMP_oidappend( &pRfcVarBinding->name, &pMibeScan->asnOid);

            //
            //  If the function pointer is not NULL and the type of the MIB
            //  variable is anything but OPAQUE, then call the function to
            //  process the MIB variable.
            //

            if(( pMibeScan->pMibFunc != NULL ) &&
               ( pMibeScan->bType    != ASN_RFC1155_OPAQUE ) ) {

                pduResult = ( pMibeScan->pMibFunc)( pRfcVarBinding,
                                                   MIB_GETFIRST,
                                                   pMibeScan,
                                                   pMibEntries,
                                                   pStatistics);
                break;
            }

            //
            // On failure in the scan, pduResult will have default value
            //    as initialized above in declaration.
            //

        } // for
    }

    return ( pduResult);

} // MibGetNextVar()

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\mib\mib.h ===
/*++  BUILD Version: 001   // Increment this if a change has global effects

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.h

   Abstract:

     Generic Macros and Functions for SNMP Extension Agent for
       gathering statistics information for Internet Services on NT.

   Author:

       Murali R. Krishnan    ( MuraliK )    22-Feb-1995

   Environment:

      User Mode -- Win32

   Project:

      HTTP Server SNMP MIB DLL

   Revision History:

--*/

# ifndef _MIB_H_
# define _MIB_H_

/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <snmp.h>

#include <lm.h>
#include <iisinfo.h>


/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
//  MIB function actions.
//

#define MIB_GET         ( ASN_RFC1157_GETREQUEST)
#define MIB_SET         ( ASN_RFC1157_SETREQUEST)
#define MIB_GETNEXT     ( ASN_RFC1157_GETNEXTREQUEST)
#define MIB_GETFIRST    ( ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0 )


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3



/************************************************************
 *   Type Definitions
 ************************************************************/


typedef UINT ( * LPMIBFUNC)(
                            RFC1157VarBind    *  pRfcVarBind,
                            UINT                 Action,
                            struct _MIB_ENTRY *  pMibeCurrent,
                            struct _MIB_ENTRIES* pMibEntries,
                            LPVOID               pStatistics
                            );


typedef struct _MIB_ENTRY  {

    AsnObjectIdentifier   asnOid;       // OID for mib variable
    LONG                  lFieldOffset; // filed offset
    UINT                  uiAccess;     // type of accesss( R, W, R/W, None)
    LPMIBFUNC             pMibFunc;     // ptr to function managing this var.
    BYTE                  bType;        // Type( integer, counter, gauage).

} MIB_ENTRY, FAR * LPMIB_ENTRY;


typedef struct  _MIB_ENTRIES {

    AsnObjectIdentifier  *  pOidPrefix;  // Oid with prefix for MIB ENTRIES
    int                     cMibEntries; // count of MIB_ENTRIES in the array
    LPMIB_ENTRY             prgMibEntry; // ptr to array of MIB_ENTRIES

} MIB_ENTRIES, FAR * LPMIB_ENTRIES;


/************************************************************
 *    Macros convenient for defining above MIB_ENTRY objects
 ************************************************************/

//
// GET_OID_LENGTH( oid)  gets the length of the oid.
//

# define  GET_OID_LENGTH( oid)           ((oid).idLength)

//
//  Macro to determine number of sub-oid's in an array of UINTs.
//

#define OID_SIZEOF( uiArray )      ( sizeof( uiArray) / sizeof(UINT) )

//
// OID_FROM_UINT_ARRAY():  Macro to define OID from an Array of UINTs
//
# define OID_FROM_UINT_ARRAY( uiArray)   { OID_SIZEOF( uiArray), uiArray }


//
// Macros for creating MIB Entries ( as specified in struct _MIB_ENTRY above)
//  MIB_ENTRY_HEADER:  creates a generic MIB_ENTRY for a MIB group header.
//  MIB_ENTRY_ITEM:    creates a generic MIB_ENTRY for a MIB variable.
//  MIB_COUNTER:       creates a counter type MIB_ENTRY
//  MIB_INTEGER:       creates an integer type MIB_ENTRY
//

# define MIB_ENTRY_HEADER( oid)             \
           {   oid,                         \
               -1,                          \
               MIB_NOACCESS,                \
               NULL,                        \
               ASN_RFC1155_OPAQUE,          \
           }

# define MIB_ENTRY_ITEM( oid, offset, access, type, func)  \
           {   oid,            \
               offset,         \
               access,         \
               ( func),        \
               ( type),        \
           }

# define MIB_COUNTER( oid, field, func)    \
     MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_RFC1155_COUNTER, func)

# define MIB_INTEGER( oid, field, func)    \
           MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_INTEGER, func)



/************************************************************
 *    Function Prototypes
 ************************************************************/

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind * pRfcVarBinding,
   IN BYTE                 pduAction,
   IN LPVOID               pStatistics,
   IN LPMIB_ENTRIES        pMibEntries
  );


UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   );



# endif // _MIB_H_

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\perfmon\w3ctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3ctrs.h

    Offset definitions for the W3 Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    W3OpenPerformanceData procecedure, they will be added to the
    W3 Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the W3CTRS.DLL DLL code as well as the
    W3CTRS.INI definition file.  W3CTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        KestutiP    15-May-1999 Added Service Uptime counters

*/


#ifndef _W3CTRS_H_
#define _W3CTRS_H_


//
//  The W3 Server counter object.
//

#define W3_COUNTER_OBJECT                     0


//
//  The individual counters.
//

#define W3_BYTES_SENT_COUNTER                 2
#define W3_BYTES_RECEIVED_COUNTER             4
#define W3_BYTES_TOTAL_COUNTER                6
#define W3_FILES_SENT_COUNTER                 8

#define W3_FILES_SENT_SEC                     10
#define W3_FILES_RECEIVED_COUNTER             12
#define W3_FILES_RECEIVED_SEC                 14
#define W3_FILES_TOTAL_COUNTER                16
#define W3_FILES_SEC                          18

#define W3_CURRENT_ANONYMOUS_COUNTER          20
#define W3_CURRENT_NONANONYMOUS_COUNTER       22
#define W3_TOTAL_ANONYMOUS_COUNTER            24
#define W3_ANONYMOUS_USERS_SEC                26
#define W3_TOTAL_NONANONYMOUS_COUNTER         28

#define W3_NON_ANONYMOUS_USERS_SEC            30
#define W3_MAX_ANONYMOUS_COUNTER              32
#define W3_MAX_NONANONYMOUS_COUNTER           34
#define W3_CURRENT_CONNECTIONS_COUNTER        36
#define W3_MAX_CONNECTIONS_COUNTER            38

#define W3_CONNECTION_ATTEMPTS_COUNTER        40
#define W3_CONNECTION_ATTEMPTS_SEC            42
#define W3_LOGON_ATTEMPTS_COUNTER             44
#define W3_LOGON_ATTEMPTS_SEC                 46
#define W3_TOTAL_OPTIONS_COUNTER              48

#define W3_TOTAL_OPTIONS_SEC                  50
#define W3_TOTAL_GETS_COUNTER                 52
#define W3_TOTAL_GETS_SEC                     54
#define W3_TOTAL_POSTS_COUNTER                56
#define W3_TOTAL_POSTS_SEC                    58

#define W3_TOTAL_HEADS_COUNTER                60
#define W3_TOTAL_HEADS_SEC                    62
#define W3_TOTAL_PUTS_COUNTER                 64
#define W3_TOTAL_PUTS_SEC                     66
#define W3_TOTAL_DELETES_COUNTER              68

#define W3_TOTAL_DELETES_SEC                  70
#define W3_TOTAL_TRACES_COUNTER               72
#define W3_TOTAL_TRACES_SEC                   74
#define W3_TOTAL_MOVE_COUNTER                 76
#define W3_TOTAL_MOVE_SEC                     78

#define W3_TOTAL_COPY_COUNTER                 80
#define W3_TOTAL_COPY_SEC                     82
#define W3_TOTAL_MKCOL_COUNTER                84
#define W3_TOTAL_MKCOL_SEC                    86
#define W3_TOTAL_PROPFIND_COUNTER             88

#define W3_TOTAL_PROPFIND_SEC                 90
#define W3_TOTAL_PROPPATCH_COUNTER            92
#define W3_TOTAL_PROPPATCH_SEC                94
#define W3_TOTAL_SEARCH_COUNTER               96
#define W3_TOTAL_SEARCH_SEC                   98

#define W3_TOTAL_LOCK_COUNTER                 100
#define W3_TOTAL_LOCK_SEC                     102
#define W3_TOTAL_UNLOCK_COUNTER               104
#define W3_TOTAL_UNLOCK_SEC                   106
#define W3_TOTAL_OTHERS_COUNTER               108

#define W3_TOTAL_OTHERS_SEC                   110
#define W3_TOTAL_REQUESTS_COUNTER             112
#define W3_TOTAL_REQUESTS_SEC                 114
#define W3_TOTAL_CGI_REQUESTS_COUNTER         116
#define W3_CGI_REQUESTS_SEC                   118

#define W3_TOTAL_BGI_REQUESTS_COUNTER         120
#define W3_BGI_REQUESTS_SEC                   122
#define W3_TOTAL_NOT_FOUND_ERRORS_COUNTER     124
#define W3_TOTAL_NOT_FOUND_ERRORS_SEC         126
#define W3_TOTAL_LOCKED_ERRORS_COUNTER        128

#define W3_TOTAL_LOCKED_ERRORS_SEC            130
#define W3_CURRENT_CGI_COUNTER                132
#define W3_CURRENT_BGI_COUNTER                134
#define W3_MAX_CGI_COUNTER                    136
#define W3_MAX_BGI_COUNTER                    138

#define W3_CURRENT_CAL_AUTH_COUNTER           140
#define W3_MAX_CAL_AUTH_COUNTER               142
#define W3_TOTAL_FAILED_CAL_AUTH_COUNTER      144
#define W3_CURRENT_CAL_SSL_COUNTER            146
#define W3_MAX_CAL_SSL_COUNTER                148

#define W3_TOTAL_FAILED_CAL_SSL_COUNTER       150
#define W3_BLOCKED_REQUESTS_COUNTER           152
#define W3_ALLOWED_REQUESTS_COUNTER           154
#define W3_REJECTED_REQUESTS_COUNTER          156
#define W3_CURRENT_BLOCKED_REQUESTS_COUNTER   158

#define W3_MEASURED_BANDWIDTH_COUNTER         160

#define W3_SERVICE_UPTIME_COUNTER             162

#endif  // _W3CTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\perfmon\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "vgactrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\perfmon\perfw3.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfw3.c

    This file implements the Extensible Performance Objects for
    the W3 Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.

        MuraliK     16-Nov-1995 Modified dependencies and removed NetApi
        SophiaC     06-Nov-1996 Supported mutlitiple instances
		MingLu      21-Nov-1999 Optimized W3 performance counter routine
*/

#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <iis64.h>
#include "iisinfo.h"
#include "w3svc.h"
#include "w3ctrs.h"
#include "w3msg.h"
#include "perfutil.h"

#define APP_NAME                     (TEXT("W3Ctrs"))


//
//  Private globals.
//

DWORD   cOpens    = 0;                  // Active "opens" reference count.
BOOL    fInitOK   = FALSE;              // TRUE if DLL initialized OK.
DWORD   cbTotalRequired = 0;            // Total space for retrieving perf data
HANDLE  hEventLog = NULL;               // Event log handle

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenW3PerformanceData;
PM_COLLECT_PROC CollectW3PerformanceData;
PM_CLOSE_PROC   CloseW3PerformanceData;

//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenW3PerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD OpenW3PerformanceData( LPWSTR lpDeviceNames )
{
    NET_API_STATUS          neterr;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK )
    {

        //
        //  This is the *first* open.
        //

        // open event log interface

        if (hEventLog == NULL){
            hEventLog = RegisterEventSource (
                        (LPTSTR)NULL,  // Use Local Machine
                         APP_NAME      // event log app name to find in registry
						);
			if (hEventLog == NULL)
            {
                return GetLastError();
            }
        }

		// call rpc to init remote data structure for w3 counters
		
		neterr = InitW3CounterStructure(NULL, 
										&cbTotalRequired
										);

		// log rpc err info to event log 
        if( neterr != NERR_Success )
        {  
            // if the server is down, we don't log an error.
		    if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                    neterr == RPC_S_UNKNOWN_IF         ||
                    neterr == ERROR_SERVICE_NOT_ACTIVE ||
                    neterr == RPC_S_CALL_FAILED_DNE ))
            {
            
		        ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                             0, W3_UNABLE_QUERY_W3SVC_DATA,
                             (PSID)NULL, 0,
                             sizeof(neterr), NULL,
                             (PVOID)(&neterr));
            }

			return ERROR_SUCCESS;
        }

		if( cbTotalRequired == 0 )
		{
			return ERROR_SUCCESS;
		}

		fInitOK = true;
    }

    //
    //  Bump open counter.
    //

    InterlockedIncrement((LPLONG)&cOpens);
    
    return ERROR_SUCCESS;

}   // OpenW3PerformanceData

/*******************************************************************

    NAME:       CollectW3PerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectW3PerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    NET_API_STATUS          neterr;
	LPBYTE                  * lppPerfData = (LPBYTE*)lppData;

    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return ERROR_SUCCESS;
    }

	if( *lpcbTotalBytes < cbTotalRequired ){
	    //*lpcbTotalBytes  = cbTotalRequired; 
		return ERROR_MORE_DATA;
	}

	//One rpc call to get all the counters infomation
	neterr = CollectW3PerfData(
					           NULL, 
					           lpValueName, 
					           *lppPerfData, 
					           lpcbTotalBytes, 
					           lpNumObjectTypes
							   );

	// log rpc err info to event log 
    if( neterr != NERR_Success )
    {    
        // if the server is down, we don't log an error.
		if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                neterr == RPC_S_UNKNOWN_IF         ||
                neterr == ERROR_SERVICE_NOT_ACTIVE ||
                neterr == RPC_S_CALL_FAILED_DNE ))
        {
			ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
				         0, W3_UNABLE_QUERY_W3SVC_DATA,
					     (PSID)NULL, 0,
						 sizeof(neterr), NULL,
						 (PVOID)(&neterr));

        }

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

		return ERROR_SUCCESS;
    }

    // align the total bytes to a QWORD_MULTIPLE

    *lpcbTotalBytes = QWORD_MULTIPLE(*lpcbTotalBytes);
    
    if( *lpcbTotalBytes && *lpNumObjectTypes )
	{
		*lppData = *lppPerfData + *lpcbTotalBytes;
	}

	return ERROR_SUCCESS;

}   // CollectW3PerformanceData

/*******************************************************************

    NAME:       CloseW3PerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseW3PerformanceData( VOID )
{
    //
    //  No real cleanup to do here.
    //

    DWORD dwCount = InterlockedDecrement((LPLONG)&cOpens);
    
    if (dwCount == 0) 
    {
        if (hEventLog != NULL)
        {
            DeregisterEventSource (hEventLog);
            hEventLog = NULL;
        }
    }

    return ERROR_SUCCESS;

}   // CloseW3PerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\scale\makefile.inc ===
copyini:
    binplace w3ctrs.ini
    binplace w3ctrs.h


.\w3msg.h .\msg00001.bin .\w3msg.rc : .\w3msg.mc
	mc -v  w3msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\scale\iis30\makefile.inc ===
copyini:
    binplace w3ctrs.ini
    binplace w3ctrs.h


.\w3msg.h .\msg00001.bin .\w3msg.rc : .\w3msg.mc
	mc -v  w3msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\scale\perfdll.h ===
typedef DWORD (APIENTRY PerfFunction) ( LPSTR pszValue, LPSTR pszServer );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\perfmon\w3data.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3ata.h

    Extensible object definitions for the W3 Server's counter
    objects & counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#ifndef _W3ATA_H_
#define _W3ATA_H_

#pragma pack(8) 

//
//  The counter structure returned.
//

typedef struct _W3_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            W3ObjectType;
    PERF_COUNTER_DEFINITION     W3BytesSent;
    PERF_COUNTER_DEFINITION     W3BytesReceived;
    PERF_COUNTER_DEFINITION     W3BytesTotal;
    PERF_COUNTER_DEFINITION     W3FilesSent;

    PERF_COUNTER_DEFINITION     W3FilesSentSec;
    PERF_COUNTER_DEFINITION     W3FilesReceived;
    PERF_COUNTER_DEFINITION     W3FilesReceivedSec;
    PERF_COUNTER_DEFINITION     W3FilesTotal;
    PERF_COUNTER_DEFINITION     W3FilesSec;

    PERF_COUNTER_DEFINITION     W3CurrentAnonymous;
    PERF_COUNTER_DEFINITION     W3CurrentNonAnonymous;
    PERF_COUNTER_DEFINITION     W3TotalAnonymous;
    PERF_COUNTER_DEFINITION     W3AnonymousUsersSec;
    PERF_COUNTER_DEFINITION     W3TotalNonAnonymous;

    PERF_COUNTER_DEFINITION     W3NonAnonymousUsersSec;
    PERF_COUNTER_DEFINITION     W3MaxAnonymous;
    PERF_COUNTER_DEFINITION     W3MaxNonAnonymous;
    PERF_COUNTER_DEFINITION     W3CurrentConnections;
    PERF_COUNTER_DEFINITION     W3MaxConnections;

    PERF_COUNTER_DEFINITION     W3ConnectionAttempts;
    PERF_COUNTER_DEFINITION     W3ConnectionAttemptsSec;
    PERF_COUNTER_DEFINITION     W3LogonAttempts;
    PERF_COUNTER_DEFINITION     W3LogonAttemptsSec;
    PERF_COUNTER_DEFINITION     W3TotalOptions;

    PERF_COUNTER_DEFINITION     W3TotalOptionsSec;
    PERF_COUNTER_DEFINITION     W3TotalGets;
    PERF_COUNTER_DEFINITION     W3TotalGetsSec;
    PERF_COUNTER_DEFINITION     W3TotalPosts;
    PERF_COUNTER_DEFINITION     W3TotalPostsSec;

    PERF_COUNTER_DEFINITION     W3TotalHeads;
    PERF_COUNTER_DEFINITION     W3TotalHeadsSec;
    PERF_COUNTER_DEFINITION     W3TotalPuts;
    PERF_COUNTER_DEFINITION     W3TotalPutsSec;
    PERF_COUNTER_DEFINITION     W3TotalDeletes;

    PERF_COUNTER_DEFINITION     W3TotalDeletesSec;
    PERF_COUNTER_DEFINITION     W3TotalTraces;
    PERF_COUNTER_DEFINITION     W3TotalTracesSec;
    PERF_COUNTER_DEFINITION     W3TotalMove;
    PERF_COUNTER_DEFINITION     W3TotalMoveSec;

    PERF_COUNTER_DEFINITION     W3TotalCopy;
    PERF_COUNTER_DEFINITION     W3TotalCopySec;
    PERF_COUNTER_DEFINITION     W3TotalMkcol;
    PERF_COUNTER_DEFINITION     W3TotalMkcolSec;
    PERF_COUNTER_DEFINITION     W3TotalPropfind;

    PERF_COUNTER_DEFINITION     W3TotalPropfindSec;
    PERF_COUNTER_DEFINITION     W3TotalProppatch;
    PERF_COUNTER_DEFINITION     W3TotalProppatchSec;
    PERF_COUNTER_DEFINITION     W3TotalSearch;
    PERF_COUNTER_DEFINITION     W3TotalSearchSec;

    PERF_COUNTER_DEFINITION     W3TotalLock;
    PERF_COUNTER_DEFINITION     W3TotalLockSec;
    PERF_COUNTER_DEFINITION     W3TotalUnlock;
    PERF_COUNTER_DEFINITION     W3TotalUnlockSec;
    PERF_COUNTER_DEFINITION     W3TotalOthers;

    PERF_COUNTER_DEFINITION     W3TotalOthersSec;
    PERF_COUNTER_DEFINITION     W3TotalRequests;
    PERF_COUNTER_DEFINITION     W3TotalRequestsSec;
    PERF_COUNTER_DEFINITION     W3TotalCGIRequests;
    PERF_COUNTER_DEFINITION     W3CGIRequestsSec;

    PERF_COUNTER_DEFINITION     W3TotalBGIRequests;
    PERF_COUNTER_DEFINITION     W3BGIRequestsSec;
    PERF_COUNTER_DEFINITION     W3TotalNotFoundErrors;
    PERF_COUNTER_DEFINITION     W3TotalNotFoundErrorsSec;
    PERF_COUNTER_DEFINITION     W3TotalLockedErrors;

    PERF_COUNTER_DEFINITION     W3TotalLockedErrorsSec;
    PERF_COUNTER_DEFINITION     W3CurrentCGIRequests;
    PERF_COUNTER_DEFINITION     W3CurrentBGIRequests;
    PERF_COUNTER_DEFINITION     W3MaxCGIRequests;
    PERF_COUNTER_DEFINITION     W3MaxBGIRequests;

#if defined(CAL_ENABLED)
    PERF_COUNTER_DEFINITION     W3CurrentCalAuth;
    PERF_COUNTER_DEFINITION     W3MaxCalAuth;
    PERF_COUNTER_DEFINITION     W3TotalFailedCalAuth;
    PERF_COUNTER_DEFINITION     W3CurrentCalSsl;
    PERF_COUNTER_DEFINITION     W3MaxCalSsl;
    PERF_COUNTER_DEFINITION     W3TotalFailedCalSsl;
#endif

    PERF_COUNTER_DEFINITION     W3BlockedRequests;
    PERF_COUNTER_DEFINITION     W3AllowedRequests;
    PERF_COUNTER_DEFINITION     W3RejectedRequests;
    PERF_COUNTER_DEFINITION     W3CurrentBlockedRequests;
    PERF_COUNTER_DEFINITION     W3MeasuredBandwidth;

    PERF_COUNTER_DEFINITION     W3ServiceUptime;

} W3_DATA_DEFINITION;

typedef struct _W3_COUNTER_BLOCK {
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    LONGLONG            BytesSent;
    LONGLONG            BytesReceived;
    LONGLONG            BytesTotal;
    DWORD               FilesSent;

    DWORD               FilesSentSec;
    DWORD               FilesReceived;
    DWORD               FilesReceivedSec;
    DWORD               FilesTotal;
    DWORD               FilesSec;

    DWORD               CurrentAnonymous;
    DWORD               CurrentNonAnonymous;
    DWORD               TotalAnonymous;
    DWORD               AnonymousUsersSec;
    DWORD               TotalNonAnonymous;

    DWORD               NonAnonymousUsersSec;
    DWORD               MaxAnonymous;
    DWORD               MaxNonAnonymous;
    DWORD               CurrentConnections;
    DWORD               MaxConnections;

    DWORD               ConnectionAttempts;
    DWORD               ConnectionAttemptsSec;
    DWORD               LogonAttempts;
    DWORD               LogonAttemptsSec;
    DWORD               TotalOptions;

    DWORD               TotalOptionsSec;
    DWORD               TotalGets;
    DWORD               TotalGetsSec;
    DWORD               TotalPosts;
    DWORD               TotalPostsSec;

    DWORD               TotalHeads;
    DWORD               TotalHeadsSec;
    DWORD               TotalPuts;
    DWORD               TotalPutsSec;
    DWORD               TotalDeletes;

    DWORD               TotalDeletesSec;
    DWORD               TotalTraces;
    DWORD               TotalTracesSec;
    DWORD               TotalMove;
    DWORD               TotalMoveSec;

    DWORD               TotalCopy;
    DWORD               TotalCopySec;
    DWORD               TotalMkcol;
    DWORD               TotalMkcolSec;
    DWORD               TotalPropfind;

    DWORD               TotalPropfindSec;
    DWORD               TotalProppatch;
    DWORD               TotalProppatchSec;
    DWORD               TotalSearch;
    DWORD               TotalSearchSec;

    DWORD               TotalLock;
    DWORD               TotalLockSec;
    DWORD               TotalUnlock;
    DWORD               TotalUnlockSec;
    DWORD               TotalOthers;

    DWORD               TotalOthersSec;
    DWORD               TotalRequests;
    DWORD               TotalRequestsSec;
    DWORD               TotalCGIRequests;
    DWORD               CGIRequestsSec;

    DWORD               TotalBGIRequests;
    DWORD               BGIRequestsSec;
    DWORD               TotalNotFoundErrors;
    DWORD               TotalNotFoundErrorsSec;
	DWORD				TotalLockedErrors;

    DWORD               TotalLockedErrorsSec;
    DWORD               CurrentCGIRequests;
    DWORD               CurrentBGIRequests;
    DWORD               MaxCGIRequests;
    DWORD               MaxBGIRequests;

#if defined(CAL_ENABLED)
    DWORD               CurrentCalAuth;
    DWORD               MaxCalAuth;
    DWORD               TotalFailedCalAuth;
    DWORD               CurrentCalSsl;
    DWORD               MaxCalSsl;
    DWORD               TotalFailedCalSsl;
#endif

    DWORD               BlockedRequests;
    DWORD               AllowedRequests;
    DWORD               RejectedRequests;
    DWORD               CurrentBlockedRequests;
    DWORD               MeasuredBandwidth;

    DWORD               ServiceUptime;
} W3_COUNTER_BLOCK, * PW3_COUNTER_BLOCK;

extern  W3_DATA_DEFINITION    W3DataDefinition;

#define NUMBER_OF_W3_COUNTERS ((sizeof(W3_DATA_DEFINITION) -        \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))

//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _W3ATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\scale\iis30\perfdll.h ===
typedef DWORD (APIENTRY PerfFunction) ( LPSTR pszValue, LPSTR pszServer );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\scale\perfdll.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfdll.cxx

    This trivial DLL grabs statistics from the w3 server

    FILE HISTORY:
        t-bilala    04-01-97    Leveraged from perfw3.cxx in \perfmon
*/

#include <windows.h>
#include <lm.h>
#include <string.h>
#include <stdlib.h>
#include <ole2.h>
#include "iisinfo.h"
#include "perfdll.h"

//
//  Public prototypes.
//

PerfFunction        GetPerformanceData;

DWORD
GetStatisticsValue(
    IN LPSTR                pszValue,
    IN W3_STATISTICS_1 *    pW3Stats
);



/*******************************************************************

    NAME:       GetPerformanceData

    SYNOPSIS:   Get performance counter value from web server.

    ENTRY:      pszValue - The name of the value to retrieve
                pszServerName - Server name

    RETURNS:    DWORD - value of performance counter 

********************************************************************/
DWORD
GetPerformanceData(
    IN LPSTR            pszValue,
    IN LPSTR            pszServer
)
{
    W3_STATISTICS_1         * pW3Stats = NULL;
    NET_API_STATUS          neterr;
    DWORD                   dwValue;
    WCHAR                   achBuffer[ MAX_PATH ];

    if ( pszValue == NULL )
    {
        return 0;
    }

    if ( pszServer != NULL )
    {
        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   pszServer,
                                   -1,
                                   achBuffer,
                                   MAX_PATH ) )
        {
            return FALSE;
        }
    }

    neterr = W3QueryStatistics2(
                            pszServer ? achBuffer : NULL,
                            0,
                            1,  // instance id
                            0,
                            (LPBYTE *)&pW3Stats );

    if( neterr != NERR_Success )
    {
        CHAR    achBuffer[ 256 ];
        
        wsprintf( achBuffer,
                  "Error was %d\n",
                  neterr );

        OutputDebugString( achBuffer );

        dwValue = 0;
    }
    else
    {
        dwValue = GetStatisticsValue( pszValue, pW3Stats );
    }

    if ( pW3Stats != NULL )
    {
        MIDL_user_free( pW3Stats );
    }

    return dwValue;
    
}

DWORD
GetStatisticsValue(
    IN LPSTR                pszValue,
    IN W3_STATISTICS_1 *    pW3Stats
)
{
    if ( !_stricmp( pszValue, "TotalUsers" ) )
    {
        return pW3Stats->TotalAnonymousUsers + pW3Stats->TotalNonAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "TotalFilesSent" ) )
    {
        return pW3Stats->TotalFilesSent;
    }
    else if ( !_stricmp( pszValue, "TotalFilesReceived" ) )
    {
        return pW3Stats->TotalFilesReceived;
    }
    else if ( !_stricmp( pszValue, "CurrentAnonymousUsers" ) )
    {
        return pW3Stats->CurrentAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "CurrentNonAnonymousUsers" ) )
    {
        return pW3Stats->CurrentNonAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "TotalAnonymousUsers" ) )
    {
        return pW3Stats->TotalAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "MaxAnonymousUsers" ) )
    {
        return pW3Stats->MaxAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "MaxNonAnonymousUsers" ) )
    {
        return pW3Stats->MaxNonAnonymousUsers;
    }
    else if ( !_stricmp( pszValue, "CurrentConnections" ) )
    {
        return pW3Stats->CurrentConnections;
    }
    else if ( !_stricmp( pszValue, "MaxConnections" ) )
    {
        return pW3Stats->MaxConnections;
    }
    else if ( !_stricmp( pszValue, "ConnectionAttempts" ) )
    {
        return pW3Stats->ConnectionAttempts;
    }
    else if ( !_stricmp( pszValue, "LogonAttempts" ) )
    {
        return pW3Stats->LogonAttempts;
    }
    else if ( !_stricmp( pszValue, "TotalGets" ) )
    {
        return pW3Stats->TotalGets;
    }
    else if ( !_stricmp( pszValue, "TotalPosts" ) )
    {
        return pW3Stats->TotalPosts;
    }
    else if ( !_stricmp( pszValue, "TotalHeads" ) )
    {
        return pW3Stats->TotalHeads;
    }
    else if ( !_stricmp( pszValue, "TotalPuts" ) )
    {
        return pW3Stats->TotalPuts;
    }
    else if ( !_stricmp( pszValue, "TotalDeletes" ) )
    {
        return pW3Stats->TotalDeletes;
    }
    else if ( !_stricmp( pszValue, "TotalTraces" ) )
    {
        return pW3Stats->TotalTraces;
    }
    else if ( !_stricmp( pszValue, "TotalOthers" ) )
    {
        return pW3Stats->TotalOthers;
    }
    else if ( !_stricmp( pszValue, "TotalCGIRequests" ) )
    {
        return pW3Stats->TotalCGIRequests;
    }
    else if ( !_stricmp( pszValue, "TotalBGIRequests" ) )
    {
        return pW3Stats->TotalBGIRequests;
    }
    else if ( !_stricmp( pszValue, "TotalNotFoundErrors" ) )
    {
        return pW3Stats->TotalNotFoundErrors;
    }
    else if ( !_stricmp( pszValue, "CurrentCGIRequests" ) )
    {
        return pW3Stats->CurrentCGIRequests;
    }
    else if ( !_stricmp( pszValue, "CurrentBGIRequests" ) )
    {
        return pW3Stats->CurrentBGIRequests;
    }
    else if ( !_stricmp( pszValue, "MaxCGIRequests" ) )
    {
        return pW3Stats->MaxCGIRequests;
    }
    else if ( !_stricmp( pszValue, "MaxBGIRequests" ) )
    {
        return pW3Stats->MaxBGIRequests;
    }
    else if ( !_stricmp( pszValue, "CurrentBlockedRequests" ) )
    {
        return pW3Stats->CurrentBlockedRequests;
    }
    else if ( !_stricmp( pszValue, "TotalBlockedRequests" ) )
    {
        return pW3Stats->TotalBlockedRequests;
    }
    else if ( !_stricmp( pszValue, "TotalAllowedRequests" ) )
    {
        return pW3Stats->TotalAllowedRequests;
    }
    else if ( !_stricmp( pszValue, "TotalRejectedRequests" ) )
    {
        return pW3Stats->TotalRejectedRequests;
    }
    else if ( !_stricmp( pszValue, "MeasuredBw" ) )
    {
        return pW3Stats->MeasuredBw;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\perfmon\w3data.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1996           **/
/**********************************************************************/

/*
    w3ata.c

    Constant data structures for the W3 Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        Bob Watson/MuraliK     03-Oct-1996 - Added rate counters for W3.

*/


#include <windows.h>
#include <winperf.h>
#include <w3ctrs.h>
#include <w3data.h>

static W3_COUNTER_BLOCK     w3c;

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

W3_DATA_DEFINITION W3DataDefinition =
{
    {   // W3ObjectType
        sizeof(W3_DATA_DEFINITION) + sizeof (W3_COUNTER_BLOCK),
        sizeof(W3_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        W3_COUNTER_OBJECT,
        0,
        W3_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_W3_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // W3BytesSent/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_SENT_COUNTER,
        0,
        W3_BYTES_SENT_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesSent),
        0 // assigned in open procedure
    },

    {   // W3BytesReceived/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_RECEIVED_COUNTER,
        0,
        W3_BYTES_RECEIVED_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesReceived),
        0 // assigned in open procedure
    },

    {   // W3BytesTotal/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_TOTAL_COUNTER,
        0,
        W3_BYTES_TOTAL_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesTotal),
        0 // assigned in open procedure
    },

    {   // W3FilesSent
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_COUNTER,
        0,
        W3_FILES_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesSent),
        0 // assigned in open procedure
    },

    {   // W3FilesSentSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_SEC,
        0,
        W3_FILES_SENT_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesSentSec),
        0 // assigned in open procedure
    },

    {   // W3FilesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_COUNTER,
        0,
        W3_FILES_RECEIVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesReceived),
        0 // assigned in open procedure
    },

    {   // W3FilesReceivedSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_SEC,
        0,
        W3_FILES_RECEIVED_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesReceivedSec),
        0 // assigned in open procedure
    },

    {   // W3FilesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_TOTAL_COUNTER,
        0,
        W3_FILES_TOTAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesTotal),
        0 // assigned in open procedure
    },

    {   // W3FilesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SEC,
        0,
        W3_FILES_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesSec),
        0 // assigned in open procedure
    },

    {   // W3CurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_ANONYMOUS_COUNTER,
        0,
        W3_CURRENT_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentAnonymous),
        0 // assigned in open procedure
    },

    {   // W3CurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_NONANONYMOUS_COUNTER,
        0,
        W3_CURRENT_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentNonAnonymous),
        0 // assigned in open procedure
    },

    {   // W3TotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_ANONYMOUS_COUNTER,
        0,
        W3_TOTAL_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalAnonymous),
        0 // assigned in open procedure
    },

    {   // W3TotalAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ANONYMOUS_USERS_SEC,
        0,
        W3_ANONYMOUS_USERS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.AnonymousUsersSec),
        0 // assigned in open procedure
    },

    {   // W3NonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NONANONYMOUS_COUNTER,
        0,
        W3_TOTAL_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNonAnonymous),
        0 // assigned in open procedure
    },

    {   // W3NonAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_NON_ANONYMOUS_USERS_SEC,
        0,
        W3_NON_ANONYMOUS_USERS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.NonAnonymousUsersSec),
        0 // assigned in open procedure
    },

    {   // W3MaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_ANONYMOUS_COUNTER,
        0,
        W3_MAX_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxAnonymous),
        0 // assigned in open procedure
    },

    {   // W3MaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_NONANONYMOUS_COUNTER,
        0,
        W3_MAX_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxNonAnonymous),
        0 // assigned in open procedure
    },

    {   // W3CurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CONNECTIONS_COUNTER,
        0,
        W3_CURRENT_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentConnections),
        0 // assigned in open procedure
    },

    {   // W3MaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CONNECTIONS_COUNTER,
        0,
        W3_MAX_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxConnections),
        0 // assigned in open procedure
    },

    {   // W3ConnectionAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_COUNTER,
        0,
        W3_CONNECTION_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ConnectionAttempts),
        0 // assigned in open procedure
    },
    {   // W3ConnectionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_SEC,
        0,
        W3_CONNECTION_ATTEMPTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.ConnectionAttemptsSec),
        0 // assigned in open procedure
    },

    {   // W3LogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_COUNTER,
        0,
        W3_LOGON_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.LogonAttempts),
        0 // assigned in open procedure
    },

    {   // W3LogonAttemptsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_SEC,
        0,
        W3_LOGON_ATTEMPTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.LogonAttemptsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalOptions
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_COUNTER,
        0,
        W3_TOTAL_OPTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOptions),
        0 // assigned in open procedure
    },

    {   // W3TotalOptionsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_SEC,
        0,
        W3_TOTAL_OPTIONS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOptionsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalGets
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_COUNTER,
        0,
        W3_TOTAL_GETS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalGets),
        0 // assigned in open procedure
    },

    {   // W3TotalGetsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_SEC,
        0,
        W3_TOTAL_GETS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalGetsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalPosts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_COUNTER,
        0,
        W3_TOTAL_POSTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPosts),
        0 // assigned in open procedure
    },

    {   // W3TotalPostsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_SEC,
        0,
        W3_TOTAL_POSTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPostsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalHeads
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_COUNTER,
        0,
        W3_TOTAL_HEADS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalHeads),
        0 // assigned in open procedure
    },

    {   // W3TotalHeadsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_SEC,
        0,
        W3_TOTAL_HEADS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalHeadsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalPuts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_COUNTER,
        0,
        W3_TOTAL_PUTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPuts),
        0 // assigned in open procedure
    },

    {   // W3TotalPutsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_SEC,
        0,
        W3_TOTAL_PUTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPutsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalDeletes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_COUNTER,
        0,
        W3_TOTAL_DELETES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalDeletes),
        0 // assigned in open procedure
    },

    {   // W3TotalDeletesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_SEC,
        0,
        W3_TOTAL_DELETES_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalDeletesSec),
        0 // assigned in open procedure
    },

    {   // W3TotalTraces
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_COUNTER,
        0,
        W3_TOTAL_TRACES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalTraces),
        0 // assigned in open procedure
    },

    {   // W3TotalTracesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_SEC,
        0,
        W3_TOTAL_TRACES_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalTracesSec),
        0 // assigned in open procedure
    },

    {   // W3TotalMove
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_COUNTER,
        0,
        W3_TOTAL_MOVE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMove),
        0 // assigned in open procedure
    },

    {   // W3TotalMoveSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_SEC,
        0,
        W3_TOTAL_MOVE_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMoveSec),
        0 // assigned in open procedure
    },

    {   // W3TotalCopy
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_COUNTER,
        0,
        W3_TOTAL_COPY_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCopy),
        0 // assigned in open procedure
    },

    {   // W3TotalCopySec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_SEC,
        0,
        W3_TOTAL_COPY_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalCopySec),
        0 // assigned in open procedure
    },

    {   // W3TotalMkcol
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_COUNTER,
        0,
        W3_TOTAL_MKCOL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMkcol),
        0 // assigned in open procedure
    },

    {   // W3TotalMkcolSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_SEC,
        0,
        W3_TOTAL_MKCOL_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMkcolSec),
        0 // assigned in open procedure
    },

    {   // W3TotalPropfind
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_COUNTER,
        0,
        W3_TOTAL_PROPFIND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPropfind),
        0 // assigned in open procedure
    },

    {   // W3TotalPropfindSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_SEC,
        0,
        W3_TOTAL_PROPFIND_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPropfindSec),
        0 // assigned in open procedure
    },

    {   // W3TotalProppatch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_COUNTER,
        0,
        W3_TOTAL_PROPPATCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalProppatch),
        0 // assigned in open procedure
    },

    {   // W3TotalProppatchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_SEC,
        0,
        W3_TOTAL_PROPPATCH_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalProppatchSec),
        0 // assigned in open procedure
    },

    {   // W3TotalSearch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_COUNTER,
        0,
        W3_TOTAL_SEARCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalSearch),
        0 // assigned in open procedure
    },

    {   // W3TotalSearchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_SEC,
        0,
        W3_TOTAL_SEARCH_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalSearchSec),
        0 // assigned in open procedure
    },

    {   // W3TotalLock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_COUNTER,
        0,
        W3_TOTAL_LOCK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLock),
        0 // assigned in open procedure
    },

    {   // W3TotalLockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_SEC,
        0,
        W3_TOTAL_LOCK_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLockSec),
        0 // assigned in open procedure
    },

    {   // W3TotalUnlock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_COUNTER,
        0,
        W3_TOTAL_UNLOCK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalUnlock),
        0 // assigned in open procedure
    },

    {   // W3TotalUnlockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_SEC,
        0,
        W3_TOTAL_UNLOCK_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalUnlockSec),
        0 // assigned in open procedure
    },

    {   // W3TotalOthers
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_COUNTER,
        0,
        W3_TOTAL_OTHERS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOthers),
        0 // assigned in open procedure
    },

    {   // W3TotalOthersSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_SEC,
        0,
        W3_TOTAL_OTHERS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOthersSec),
        0 // assigned in open procedure
    },

    {   // W3TotalRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_COUNTER,
        0,
        W3_TOTAL_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalRequests),
        0 // assigned in open procedure
    },

    {   // W3TotalRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_SEC,
        0,
        W3_TOTAL_REQUESTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalRequestsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalCGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        0,
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCGIRequests),
        0 // assigned in open procedure
    },

    {   // W3TotalCGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CGI_REQUESTS_SEC,
        0,
        W3_CGI_REQUESTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.CGIRequestsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalBGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        0,
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalBGIRequests),
        0 // assigned in open procedure
    },

    {   // W3TotalBGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BGI_REQUESTS_SEC,
        0,
        W3_BGI_REQUESTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.BGIRequestsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalNotFoundErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        0,
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNotFoundErrors),
        0 // assigned in open procedure
    },

    {   // W3TotalNotFoundErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        0,
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalNotFoundErrorsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalLockedErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        0,
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLockedErrors),
        0 // assigned in open procedure
    },

    {   // W3TotalLockedErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_SEC,
        0,
        W3_TOTAL_LOCKED_ERRORS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLockedErrorsSec),
        0 // assigned in open procedure
    },

    {   // W3CurrentCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CGI_COUNTER,
        0,
        W3_CURRENT_CGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCGIRequests),
        0 // assigned in open procedure
    },

    {   // W3CurrentBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BGI_COUNTER,
        0,
        W3_CURRENT_BGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBGIRequests),
        0 // assigned in open procedure
    },

    {   // W3MaxCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CGI_COUNTER,
        0,
        W3_MAX_CGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCGIRequests),
        0 // assigned in open procedure
    },

    {   // W3MaxBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_BGI_COUNTER,
        0,
        W3_MAX_BGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxBGIRequests),
        0 // assigned in open procedure
    },

#if defined(CAL_ENABLED)
    {   // W3CurrentCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_AUTH_COUNTER,
        0,
        W3_CURRENT_CAL_AUTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalAuth),
        0 // assigned in open procedure
    },

    {   // W3MaxCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_AUTH_COUNTER,
        0,
        W3_MAX_CAL_AUTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalAuth),
        0 // assigned in open procedure
    },

    {   // W3TotalFailedCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        0,
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalAuth),
        0 // assigned in open procedure
    },

    {   // W3CurrentCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_SSL_COUNTER,
        0,
        W3_CURRENT_CAL_SSL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalSsl),
        0 // assigned in open procedure
    },

    {   // W3MaxCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_SSL_COUNTER,
        0,
        W3_MAX_CAL_SSL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalSsl),
        0 // assigned in open procedure
    },

    {   // W3TotalFailedCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        0,
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalSsl),
        0 // assigned in open procedure
    },
#endif

    {   // W3BlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.BlockedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3AllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.AllowedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3RejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.RejectedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3CurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBlockedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3MeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MEASURED_BANDWIDTH_COUNTER,
        0,
        W3_MEASURED_BANDWIDTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MeasuredBandwidth),
        0 // assigned in open procedure
    },

    {   // W3ServiceUptime
        sizeof(PERF_COUNTER_DEFINITION),
        W3_SERVICE_UPTIME_COUNTER,
        0,
        W3_SERVICE_UPTIME_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ServiceUptime),
        0 // assigned in open procedure
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\w3\server\basereq.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    basereq.cxx

    This module contains the http base request class implementation


    FILE HISTORY:
        Johnl           24-Aug-1994   Created
        MuraliK         16-May-1995   Modified LogInformation structure
                                      after adding additional fields.
        MuraliK         13-Oct-1995   Created basereq file from old httreq.cxx
*/


#include "w3p.hxx"
#include <inetinfo.h>
#include "basereq.hxx"
#include <lonsi.hxx>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>

#include <iscaptrc.h>

#pragma warning( disable:4355 )   // 'this' used in base member initialization

//
//  Private constants.
//


//
//  Default response buffer size
//

#define DEF_RESP_BUFF_SIZE           4096

//
// minimum buffer size after custom headers
//

#define POST_CUSTOM_HEADERS_SIZE    256

//
//  We cache our read and write buffers but if they get beyond this size, we
//  free it and start from scratch on the next request
//

#define MAX_CLIENT_SIZE_ALLOWED      (4 * 4096)

//
//  Handle used to indicate request to deny access to current HTTP request
//

#define IIS_ACCESS_DENIED_HANDLE     ((HANDLE)1)

//
//  Public functions.
//

//
//  Private functions.
//

#define CONST_TO_STRING(x)  #x

HTTP_REQ_BASE::HTTP_REQ_BASE(
    CLIENT_CONN * pClientConn,
    PVOID         pvInitialBuff,
    DWORD         cbInitialBuff
    ) :
    _tcpauth             ( TCPAUTH_SERVER | TCPAUTH_UUENCODE ),
    _Filter              ( this ),
    _fValid              ( FALSE ),
    _bufServerResp       ( DEF_RESP_BUFF_SIZE ),
    _dwLogHttpResponse   ( HT_DONT_LOG ),
    _pURIInfo            ( NULL ),
    _pMetaData           ( NULL )
{
#if defined(CAL_ENABLED)
    m_pCalAuthCtxt = NULL;
    m_pCalSslCtxt = NULL;
#endif

    InitializeSession( pClientConn,
                       pvInitialBuff,
                       cbInitialBuff );
    DBG_ASSERT( pClientConn->CheckSignature() );

    if ( !_Filter.IsValid() ||
         !_bufServerResp.QueryPtr() )
    {
        return;
    }

    _acIpAccess = AC_NOT_CHECKED;
    _fNeedDnsCheck = FALSE;

    _fValid = TRUE;
}

VOID
HTTP_REQ_BASE::InitializeSession(
    CLIENT_CONN * pClientConn,
    PVOID         pvInitialBuff,
    DWORD         cbInitialBuff
    )
/*++

Routine Description:

    This is a pseudo constructor called by the buffer list code.

    This routine should initialize all of the items that should be reset
    between TCP sessions (but may remain valid over multiple requests on the
    same TCP session, i.e., "Connection: keep-alive")

Arguments:

    pClientConn - Client connection object we're speaking to

--*/
{
    _pClientConn        = pClientConn;
    _pW3Instance        = NULL;
    _pW3Stats           = g_pW3Stats;
    _fKeepConn          = FALSE;
    _fSecurePort        = pClientConn->IsSecurePort();

    ResetAuth( TRUE );
    _fSingleRequestAuth = FALSE;

    _cFilesSent         = 0;
    _cFilesReceived     = 0;
    _cbBytesSent        = 0;
    _cbBytesReceived    = 0;
    _cbTotalBytesSent   = 0;
    _cbTotalBytesReceived= 0;

    _fAsyncSendPosted   = FALSE;

    _Filter.Reset();
    _pAuthFilter = NULL;

    _strHostAddr.Reset();
    _dwRenegotiated    = 0;
    _dwSslNegoFlags = 0;

    IF_DEBUG(REQUEST) {
        DBGPRINTF(( DBG_CONTEXT,
                "[InitializeSession] time=%u HTTP=%08x\n",
                GetTickCount(), (LPVOID)this
             ));
    }
}

HTTP_REQ_BASE::~HTTP_REQ_BASE( VOID )
{
}


BOOL
HTTP_REQ_BASE::ResetAuth(
    BOOL    fSessionReset
    )
/*++

Routine Description:

    This method is called to reset authentication status.

Arguments:

    None

--*/
{
    TCP_REQUIRE( _tcpauth.Reset( fSessionReset ) );
    _fClearTextPass     = FALSE;
    _fAnonymous         = FALSE;
    _fMappedAcct        = FALSE;
    _fAuthenticating    = FALSE;
    _fLoggedOn          = FALSE;
    _fInvalidAccessToken = FALSE;
    _fAuthTypeDigest    = FALSE;
    _fAuthSystem        = FALSE;
    _fAuthCert          = FALSE;

    _cbLastAnonAcctDesc = 0;

    _strAuthType.Reset();
    _strUserName.Reset();
    _strPassword.Reset();
    _strUnmappedUserName.Reset();
    _strUnmappedPassword.Reset();

    _fSingleRequestAuth = FALSE;

#if defined(CAL_ENABLED)
    if ( m_pCalAuthCtxt )
    {
        CalDisconnect( m_pCalAuthCtxt );
        m_pCalAuthCtxt = NULL;
    }
#endif

    return TRUE;
}


BOOL
HTTP_REQ_BASE::Reset(
    BOOL fResetPipelineInfo
    )
/*++

Routine Description:

    This method is called after an individual request has been processed.
    If the session is being kept open, this object can be used again for
    the next request on this TCP session.  In this case, various items such
    as authentication information etc. remain valid.

    The method is also called once when the object is first allocated.

Arguments:

--*/
{
    _fStartTimeValid    = FALSE;

    _VersionMajor       = 0;
    _VersionMinor       = 0;
    _cbEntityBody       = 0;
    _cbTotalEntityBody  = 0;
    _cbContentLength    = 0;

