CENTER,  
    1, 1, CTRL_USEMARLETT | CTRL_DISABLEONWINLOGON, {0x0075, 0x0000}},
   };

static int c_nColumnStart[] = {0, CX_COLUMN0, CX_COLUMN1};

    

//////////////////////////////////////////////////////////////////////////////
//
// APIs
//
//////////////////////////////////////////////////////////////////////////////

extern "C" BOOL WINAPI GetPopupTipbar(HWND hwndParent, DWORD dwFlags)
{
    if ( !(dwFlags & UTB_GTI_WINLOGON) )
    {
        TurnOffSpeechIfItsOn( );
    }

    return GetTipbarInternal(hwndParent, UTB_GTI_POPUP | dwFlags, NULL);
}

BOOL GetTipbarInternal(HWND hwndParent, DWORD dwFlags, CDeskBand *pDeskBand)
{
    DWORD dwSFSFlags;
    BOOL fPopup = (dwFlags & UTB_GTI_POPUP) ? TRUE : FALSE;

    g_bWinLogon = (dwFlags & UTB_GTI_WINLOGON) ? TRUE : FALSE;

    //
    // MSAA support
    //
    InitTipbarAcc();

    InitFromReg();

    if (!g_bShowTipbar)
        return NULL;

    //
    // we don't have to create TrayIconWnd under explorer's desk band.
    //
    if (fPopup)
    {
        g_pTrayIconWnd = new CTrayIconWnd();
        if (!g_pTrayIconWnd)
            return FALSE;

        g_pTrayIconWnd->CreateWnd();
    }

    g_pTipbarWnd = new CTipbarWnd(fPopup ? g_dwWndStyle : g_dwChildWndStyle);
    if (!g_pTipbarWnd)
        return FALSE;

    if (!g_pTipbarWnd->Initialize())
        return FALSE;

    g_pTipbarWnd->Init(!fPopup, pDeskBand);


    g_pTipbarWnd->CreateWnd(hwndParent);
    SetWindowText(g_pTipbarWnd->GetWnd(), TF_FLOATINGLANGBAR_WNDTITLE);

    DWORD dwPrevFlags = 0;
    if (!fPopup)
    {
        g_pTipbarWnd->GetLangBarMgr()->GetPrevShowFloatingStatus(&dwPrevFlags);

        g_pTipbarWnd->GetLangBarMgr()->ShowFloating(TF_SFT_DESKBAND);
    }

    g_pTipbarWnd->GetLangBarMgr()->GetShowFloatingStatus(&dwSFSFlags);
    g_pTipbarWnd->ShowFloating(dwSFSFlags);

    //
    // get the previous show floating status.
    // if it does not have TF_SFT_DESKBAND, the floating toolbar
    // was minimized.
    // if it has TF_SFT_DESKBAND, exploere just started. Then we don't
    // want to adjust the deskband and use the default size.
    // (Explorer remembers the position of the previous logon.)
    //
    if (!fPopup && (dwPrevFlags & TF_SFT_DESKBAND))
        g_pTipbarWnd->SetDeskbandSizeAdjusted();

    g_hwndParent = hwndParent;

    return TRUE;
}

extern "C" void WINAPI ClosePopupTipbar()
{
    if (g_fInClosePopupTipbar)
        return;

    g_fInClosePopupTipbar = TRUE;

    if (g_pTipbarWnd)
    {
        g_pTipbarWnd->ClearDeskBandPointer();
        g_pTipbarWnd->DestroyWnd();
        g_pTipbarWnd->Release();
        g_pTipbarWnd = NULL;
    }

    if (g_pTrayIconWnd)
    {
        g_pTrayIconWnd->DestroyWnd();
        delete g_pTrayIconWnd;
        g_pTrayIconWnd = NULL;
    }

    UninitSkipRedrawHKLArray();

    g_fInClosePopupTipbar = FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////


extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

//+---------------------------------------------------------------------------
//
//  GetCompartment
//
//----------------------------------------------------------------------------

HRESULT GetGlobalCompartment(REFGUID rguidComp, ITfCompartment **ppComp)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;

    if (FAILED(hr = TF_GetGlobalCompartment(&pCompMgr)))
    {
         Assert(0);
         goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  SetCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT SetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD dw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetGlobalCompartment(rguidComp, &pComp)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(0, &var);
        pComp->Release();
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  GetGlobalCompartmentDWORD
//
//----------------------------------------------------------------------------

HRESULT GetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD *pdw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    *pdw = 0;
    if (SUCCEEDED(hr = GetGlobalCompartment(rguidComp, &pComp)))
    {
        if ((hr = pComp->GetValue(&var)) == S_OK)
        {
            Assert(var.vt == VT_I4);
            *pdw = var.lVal;
        }
        pComp->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  TurnOffSpeechIfItsOn
//
//----------------------------------------------------------------------------
void  TurnOffSpeechIfItsOn()
{
    // turn off the mic here only if someone set speech on
    DWORD dw = 0; 
    HRESULT hr = GetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw);
    if (SUCCEEDED(hr) && dw > 0)
    {
        SetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_OPENCLOSE, 0);
    }
}

//+---------------------------------------------------------------------------
//
// InitSkipRedrawHKLArray
//
//+---------------------------------------------------------------------------

void InitSkipRedrawHKLArray()
{
    CMyRegKey key;
    HKL *phkl;

    Assert(!g_prghklSkipRedrawing);
    g_prghklSkipRedrawing = new CStructArray<HKL>;
    if (!g_prghklSkipRedrawing)
        return;

    if (IsOnNT51())
    {
        phkl = g_prghklSkipRedrawing->Append(1);
        if (phkl)
            *phkl = (HKL)IntToPtr(0xe0010411);
    }

    if (key.Open(HKEY_LOCAL_MACHINE, c_szSkipRedrawHKL, KEY_READ) == S_OK)
    {
        char szValue[255];
        DWORD dwIndex = 0;
        while (key.EnumValue(dwIndex, szValue, ARRAYSIZE(szValue)) == S_OK)
        {
            if ((szValue[0] == '0') && 
                ((szValue[1] == 'X') || (szValue[1] == 'x')))
            {
                phkl = g_prghklSkipRedrawing->Append(1);
                if (phkl)
                    *phkl = (HKL)IntToPtr(AsciiToNum(&szValue[2]));
            }
            dwIndex++;
        }
    }
}

//+---------------------------------------------------------------------------
//
// UninitSkipRedrawHKLArray
//
//+---------------------------------------------------------------------------

void UninitSkipRedrawHKLArray()
{
    if (!g_prghklSkipRedrawing)
        return;

    delete g_prghklSkipRedrawing;
    g_prghklSkipRedrawing = NULL;
}

//+---------------------------------------------------------------------------
//
// IsSkipRedrawHKL
//
//+---------------------------------------------------------------------------

BOOL IsSkipRedrawHKL(HKL hkl)
{
    int i;

    if (0x0411 != LANGID(LOWORD(HandleToLong(hkl))))
        return FALSE;

    if (!g_prghklSkipRedrawing)
        return FALSE;

    for (i = 0; i < g_prghklSkipRedrawing->Count(); i++)
    {
        HKL *phkl = g_prghklSkipRedrawing->GetPtr(i);
        if (phkl && (*phkl == hkl))
            return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// InitFromReg
//
//+---------------------------------------------------------------------------

BOOL InitFromReg()
{
    CMyRegKey key;
    CMyRegKey keyUTB;
    DWORD dwValue;
    LANGID langID = 0;

    if (key.Open(HKEY_CURRENT_USER, c_szCicKey, KEY_READ) == S_OK)
    {
        if (key.QueryValue(dwValue, c_szShowTipbar) == S_OK)
            g_bShowTipbar = dwValue ? TRUE : FALSE;
    }

    if (keyUTB.Open(HKEY_CURRENT_USER, c_szUTBKey, KEY_READ) == S_OK)
    {
        if (keyUTB.QueryValue(dwValue, c_szShowDebugMenu) == S_OK)
            g_bShowDebugMenu = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szNewLook) == S_OK)
            g_bNewLook = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szIntelliSense) == S_OK)
            g_bIntelliSense = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szShowCloseMenu) == S_OK)
            g_bShowCloseMenu = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szTimeOutNonIntentional) == S_OK)
            g_uTimeOutNonIntentional = dwValue * 1000;

        if (keyUTB.QueryValue(dwValue, c_szTimeOutIntentional) == S_OK)
        {
            g_uTimeOutIntentional = dwValue * 1000;
            g_uTimeOutMax = g_uTimeOutIntentional * 6;
        }

        if (keyUTB.QueryValue(dwValue, c_szShowMinimizedBalloon) == S_OK)
            g_bShowMinimizedBalloon = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szLeft) == S_OK)
            g_nLeft = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTop) == S_OK)
            g_nTop = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szExcludeCaptionButtons) == S_OK)
            g_bExcludeCaptionButtons = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szShowShadow) == S_OK)
            g_bShowShadow = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szTaskbarTheme) == S_OK)
            g_fTaskbarTheme = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szVertical) == S_OK)
            g_fVertical = dwValue ? TRUE : FALSE;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseSTUBSTART) == S_OK)
            g_uTimerElapseSTUBSTART          = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseSTUBEND) == S_OK)
            g_uTimerElapseSTUBEND            = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseBACKTOALPHA) == S_OK)
            g_uTimerElapseBACKTOALPHA        = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseONTHREADITEMCHANGE) == S_OK)
            g_uTimerElapseONTHREADITEMCHANGE = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseSETWINDOWPOS) == S_OK)
            g_uTimerElapseSETWINDOWPOS       = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseONUPDATECALLED) == S_OK)
            g_uTimerElapseONUPDATECALLED     = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseSYSCOLORCHANGED) == S_OK)
            g_uTimerElapseSYSCOLORCHANGED    = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseDISPLAYCHANGE) == S_OK)
            g_uTimerElapseDISPLAYCHANGE      = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseUPDATEUI) == S_OK)
            g_uTimerElapseUPDATEUI           = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseSHOWWINDOW) == S_OK)
            g_uTimerElapseSHOWWINDOW           = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseMOVETOTRAY) == S_OK)
            g_uTimerElapseMOVETOTRAY           = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseTRAYWNDONDELAYMSG) == S_OK)
            g_uTimerElapseTRAYWNDONDELAYMSG           = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseDOACCDEFAULTACTION) == S_OK)
            g_uTimerElapseDOACCDEFAULTACTION           = dwValue;

        if (keyUTB.QueryValue(dwValue, c_szTimerElapseENSUREFOCUS) == S_OK)
            g_uTimerElapseENSUREFOCUS           = dwValue;

        if (IsOnNT51() && keyUTB.QueryValue(dwValue, c_szShowDeskBand) == S_OK)
            g_bShowDeskBand = dwValue ? TRUE : FALSE;

        if (IsOnNT51() && keyUTB.QueryValue(dwValue, c_szTimerElapseSHOWDESKBAND) == S_OK)
            g_uTimerElapseSHOWDESKBAND          = dwValue;
    }


    InitSkipRedrawHKLArray();
 
    if (g_bNewLook)
    {
        g_dwWndStyle = UIWINDOW_TOPMOST | 
                       // UIWINDOW_WSDLGFRAME | 
                       UIWINDOW_HASTOOLTIP | 
                       UIWINDOW_HABITATINWORKAREA | 
                       UIWINDOW_OFC10TOOLBAR |
                       UIWINDOW_TOOLWINDOW;

        if (IsOnNT51())
        {
            g_dwWndStyle &= ~UIWINDOW_OFC10TOOLBAR;
            g_dwWndStyle |= UIWINDOW_WHISTLERLOOK;
            // g_dwWndStyle |= UIWINDOW_WSBORDER;
        }

        if (g_bShowShadow)
            g_dwWndStyle |= UIWINDOW_HASSHADOW;

        g_dwMenuStyle = UIWINDOW_TOPMOST | 
                        UIWINDOW_TOOLWINDOW | 
                        UIWINDOW_OFC10MENU |
                        UIWINDOW_HASSHADOW |
                        UIWINDOW_HABITATINSCREEN;
    }
    else
    {
        g_dwWndStyle = UIWINDOW_TOPMOST | 
                       UIWINDOW_HASTOOLTIP | 
                       UIWINDOW_WSDLGFRAME |
                       UIWINDOW_HABITATINWORKAREA;
        g_dwMenuStyle = UIWINDOW_TOPMOST | 
                        UIWINDOW_WSDLGFRAME |
                        UIWINDOW_HABITATINSCREEN;
    }

    g_dwChildWndStyle = UIWINDOW_CHILDWND;

    if (IsOnNT51())
    {
        g_dwChildWndStyle |= UIWINDOW_WHISTLERLOOK | 
                             UIWINDOW_HASTOOLTIP |
                             UIWINDOW_NOMOUSEMSGFROMSETCURSOR;
    }

    langID = GetPlatformResourceLangID();
    if (PRIMARYLANGID(langID) == LANG_ARABIC || PRIMARYLANGID(langID) == LANG_HEBREW)
    {
        g_dwWndStyle |= UIWINDOW_LAYOUTRTL;
        g_dwChildWndStyle |= UIWINDOW_LAYOUTRTL;
        g_dwMenuStyle |= UIWINDOW_LAYOUTRTL;
        g_fRTL = TRUE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetTopLevelWindow
//
//+---------------------------------------------------------------------------

HWND GetTopLevelWindow(HWND hwnd)
{
    HWND hwndT,hwndRet;
    HWND hwndDsktop = GetDesktopWindow();

    hwndT = hwndRet = hwnd;

    while (hwndT && hwndT != hwndDsktop)
    {
        HWND hwndT0;
        hwndRet = hwndT;
        hwndT0 = GetParent(hwndT);

        if (IsOn98() && !hwndT0)
        {
            //
            // GetLastActivePopup() returns hwnd->hwndLastActive.
            // But top level owner's hwndLastActive is used.
            // We need to find a top level owner.
            //
            hwndT0 = GetWindow(hwndT, GW_OWNER);
        }
        hwndT = hwndT0;
    }

    return(hwndRet);
}

//+---------------------------------------------------------------------------
//
// MyWaitForInputIdle
//
//+---------------------------------------------------------------------------

#define UTB_INPUTIDLETIMEOUT 2000

DWORD MyWaitForInputIdle(DWORD dwThreadId, DWORD dwTimeOut)
{
    DWORD dwRet = -1;
    DWORD dwProcessId = 0;
    DWORD dwThreadFlags;

    if (g_pTipbarWnd && g_pTipbarWnd->IsSFDeskband())
    {
        //
        //  Skip it on the Deskband that is belong to Explorer process.
        //
        return 0;
    }

    //
    // If the target thread is in marshaling call, we can behave as it's busy.
    //
    if (TF_IsInMarshaling(dwThreadId))
        return WAIT_TIMEOUT;

    if (TF_GetThreadFlags(dwThreadId, &dwThreadFlags, &dwProcessId, NULL) && dwProcessId)
    {
        dwRet = 0;

        if (IsOnNT() && 
            Is16bitThread(dwProcessId, dwThreadId))
        {
            //
            // we need to do something here to detect 16bit idle.
            //
        }
        else if (IsOnNT() || !(dwThreadFlags & TLF_NOWAITFORINPUTIDLEONWIN9X))
        {
#if 0
            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 
                                      FALSE, dwProcessId);
            if (hProcess)
            {
                dwRet = WaitForInputIdle(hProcess, dwTimeOut);
                CloseHandle(hProcess);
            }
            else
                dwRet = -1;
#else
            dwRet = TF_CheckThreadInputIdle(dwThreadId, dwTimeOut);
#endif
        }
    }

    return dwRet;
}

//+---------------------------------------------------------------------------
//
// ClearMsgQueue
//
//+---------------------------------------------------------------------------

void ClearMsgQueue()
{
    MSG msg;
    ULONG ulQuitCode;
    BOOL fQuitReceived = FALSE;
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD))
    {
        if (msg.message == WM_QUIT)
        {
            ulQuitCode = (ULONG)(msg.wParam);
            fQuitReceived = TRUE;
        }

        DispatchMessage(&msg);
    }

    if (fQuitReceived)
        PostQuitMessage(ulQuitCode);
   
}

//+---------------------------------------------------------------------------
//
// IsFullScreenSize
//
//+---------------------------------------------------------------------------

BOOL IsFullScreenSize(HWND hwnd)
{
    RECT rc;
    GetWindowRect(hwnd, &rc);
    if ((rc.left <= 0) &&
        (rc.top <= 0)&&
        (rc.right >= GetSystemMetrics(SM_CXFULLSCREEN)) &&
        (rc.bottom >= GetSystemMetrics(SM_CYFULLSCREEN)))
    {
        return TRUE;
    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
// InitUniqueString
//
//----------------------------------------------------------------------------

BOOL GetUserSIDString(DWORD dwProcessId, char *pch, UINT cch)
{
    HANDLE hToken = NULL;
    char *pszStringSid = NULL;
    HANDLE hProcess;

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);

    if (hProcess)
        OpenProcessToken(hProcess, TOKEN_QUERY, &hToken);

    if (hToken)
    {
        DWORD dwReturnLength = 0;
        void  *pvUserBuffer = NULL;

        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwReturnLength);

        pvUserBuffer = cicMemAllocClear(dwReturnLength);
        if (pvUserBuffer &&
            GetTokenInformation(hToken,
                                 TokenUser,
                                 pvUserBuffer,
                                 dwReturnLength,
                                 &dwReturnLength))
        {
            if (!ConvertSidToStringSid(((TOKEN_USER*)(pvUserBuffer))->User.Sid,
                                       &pszStringSid))
            {
                if (pszStringSid)
                    LocalFree(pszStringSid);

                pszStringSid = NULL;
            }

        }

        if (pvUserBuffer)
        {
            cicMemFree(pvUserBuffer);
        }

        CloseHandle(hToken);
    }

    if (hProcess)
        CloseHandle(hProcess);

    if (pszStringSid)
    {
        StringCchCopy(pch, cch, pszStringSid);
        LocalFree(pszStringSid);
        return TRUE;
    }

    *pch = '\0';
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// InitCurrentProcessSid
//
//+---------------------------------------------------------------------------

BOOL g_fSidInit = FALSE;
char g_szSid[UNLEN + 1];

BOOL InitCurrentProcessSid()
{
    if (g_fSidInit)
        return TRUE;

    if (GetUserSIDString(GetCurrentProcessId(), g_szSid, ARRAYSIZE(g_szSid)))
        g_fSidInit = TRUE;

    return g_fSidInit;
}


//+---------------------------------------------------------------------------
//
// IsVisibleWindowInDesktop()
//
//+---------------------------------------------------------------------------

BOOL CALLBACK EnumVisibleWindowProc(HWND hwnd, LPARAM lParam)
{
    DWORD dwProcessId;

    if (!GetWindowThreadProcessId(hwnd, &dwProcessId))
        dwProcessId = 0;

    //
    // we're not interested in ctfmon's process window.
    //
    if (g_pTipbarWnd && !g_pTipbarWnd->IsInDeskBand())
        if (dwProcessId == GetCurrentProcessId())
            return TRUE;

    if (IsWindowVisible(hwnd))
    {
        if (g_fSidInit)
        {
            // 
            // if the process is owned by different user, we skip it.
            // 
            char szSid[UNLEN + 1];
            GetUserSIDString(dwProcessId, szSid, ARRAYSIZE(szSid));
            if (lstrcmp(szSid, g_szSid))
                return TRUE;
        }

        BOOL *pfFound = (BOOL *)lParam;
        *pfFound = TRUE;
        return FALSE;
    }

    return TRUE;
}

BOOL IsVisibleWindowInDesktop()
{
    BOOL fFound = FALSE;

    InitCurrentProcessSid();
    EnumWindows(EnumVisibleWindowProc, (LPARAM)&fFound);
    return fFound;
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarGripper
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CTipbarGripper::ctor
//
//----------------------------------------------------------------------------

CTipbarGripper::CTipbarGripper(CTipbarWnd *pTipbarWnd, RECT *prc, DWORD dwStyle) : CUIFGripper( pTipbarWnd, prc, dwStyle) 
{
    _pTipbarWnd = pTipbarWnd;
    _fInMenu = FALSE;
}

//+---------------------------------------------------------------------------
//
// CTipbarGripper::OnSetCursor
//
//----------------------------------------------------------------------------

BOOL CTipbarGripper::OnSetCursor(UINT uMsg, POINT pt)
{
    if (!_fInMenu)
        return CUIFGripper::OnSetCursor(uMsg, pt);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// CTipbarGripper::OnRButtonUp
//
//----------------------------------------------------------------------------

void CTipbarGripper::OnRButtonUp(POINT pt)
{
    if (!g_bShowDebugMenu)
        return;

    HMENU hMenu = CreatePopupMenu();
    if (!hMenu)
        return;

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    ClientToScreen(_pTipbarWnd->GetWnd(), &pt);


    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, IDM_CLOSECICLOAD, "Close cicload");

#ifdef DEBUG
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, IDM_BREAK, CRStr(IDS_BREAK));
#endif
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, IDCANCEL, CRStr(IDS_CANCEL));

    _fInMenu = TRUE;
    int nRet = TrackPopupMenuEx(hMenu,
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, _pTipbarWnd->GetWnd(), NULL);
    _fInMenu = FALSE;

    DestroyMenu(hMenu);

    switch (nRet)
    {
        case IDM_CLOSECICLOAD:
            {
                _pTipbarWnd->UnInit();
                if (IsWindow(g_hwndParent))
                    DestroyWindow(g_hwndParent);
                MSG msg;
                while(PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE | PM_NOYIELD));
                PostQuitMessage(0);
            }
            break;

#ifdef DEBUG
        case IDM_BREAK:
            DebugBreak();
            break;
#endif
    }

}

//+---------------------------------------------------------------------------
//
// CTipbarGripper::OnLButtonUp
//
//----------------------------------------------------------------------------

void CTipbarGripper::OnLButtonUp(POINT pt)
{
    _pTipbarWnd->RestoreFromStub();

    //
    // Mouse Drag/Drop from floating language bar to deskband.
    //
    if (IsOnNT51())
    {
        APPBARDATA abd;
        RECT rcTrayWnd;

        abd.cbSize = sizeof(APPBARDATA);

        abd.hWnd = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

        if (SHAppBarMessage(ABM_GETTASKBARPOS, &abd))
        {
            POINT ptCursor;

            rcTrayWnd = abd.rc;

            GetCursorPos(&ptCursor);

            if ((ptCursor.x >= rcTrayWnd.left && ptCursor.x <= rcTrayWnd.right) &&
                (ptCursor.y >= rcTrayWnd.top && ptCursor.y <= rcTrayWnd.bottom))
            {
                if (g_pTipbarWnd)
                    g_pTipbarWnd->GetLangBarMgr()->ShowFloating(TF_SFT_DESKBAND |
                                                                TF_SFT_EXTRAICONSONMINIMIZED);

            }
        }
    }

    CUIFGripper::OnLButtonUp(pt);

    //
    // CUIFGripper::OnLButonUp() calls MoveWindow.
    // Now we update pos flags of TipbarWnd.
    //
    _pTipbarWnd->UpdatePosFlags();
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarWnd
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTipbarWnd::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarEventSink))
    {
        *ppvObj = SAFECAST(this, ITfLangBarEventSink *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarEventSink_P))
    {
        *ppvObj = SAFECAST(this, ITfLangBarEventSink_P *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTipbarWnd::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTipbarWnd::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarWnd::CTipbarWnd(DWORD dwStyle) : CUIFWindow(g_hInst, dwStyle)
{
    Dbg_MemSetThisName(TEXT("CTipbarWnd"));
    POINT pt;
    RECT rc;

    pt.x = g_nLeft;
    pt.y = g_nTop;
    CUIGetScreenRect(pt, &rc);
    if (!PtInRect(&rc, pt))
    {
         if (IsOnFE())
         {
             RECT rcWork;
             SystemParametersInfo( SPI_GETWORKAREA, 0, &rcWork, 0 );
             g_nLeft = rcWork.right;
             g_nTop  = rcWork.bottom;
         }
         else if (g_fRTL)
         {
             g_nLeft = GetSystemMetrics(SM_CXSIZE) * 3;
             g_nTop  = 0;
         }
         else
         {
             g_nLeft = GetSystemMetrics(SM_CXSCREEN) - (GetSystemMetrics(SM_CXSIZE) * 3);
             g_nTop  = 0;
         }
    }
   
    Move(g_nLeft, g_nTop, STATUSWND_WIDTH, STATUSWND_HEIGHT);

    //
    // initialize Pos flags after calling Move().
    //
    UpdatePosFlags();

    _fShowText = FALSE;
    _fInStub = FALSE;

    _hfontMarlett = CreateFont(8, 8, 0, 0, 400, FALSE, FALSE, FALSE, SYMBOL_CHARSET, 0, 0, 0, 0, "Marlett");

    ITfLangBarMgr *putb;
    if (SUCCEEDED(TF_CreateLangBarMgr(&putb)) && putb)
    {
        putb->QueryInterface(IID_ITfLangBarMgr_P, (void **)&_putb);

        putb->Release();
    }
   

    if (dwStyle & UIWINDOW_WHISTLERLOOK)
    {
        if (g_fTaskbarTheme)
            SetActiveTheme(L"TASKBAR", TBP_BACKGROUNDBOTTOM, TS_NORMAL );
        else
            SetActiveTheme(L"REBAR", 0, TS_NORMAL );
    }

    SetVertical(g_fVertical);

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarWnd::~CTipbarWnd()
{
    Assert(!_pModalMenu);

    UnInit();

    DeleteObject(_hfontMarlett);
    if (_hfontVert)
        DeleteObject(_hfontVert);

    TFUninitLib_Thread(&g_libTLS);
}

//+---------------------------------------------------------------------------
//
// UnInit
//
//----------------------------------------------------------------------------

void CTipbarWnd::UnInit()
{
    SetFocusThread(NULL);

    int i;
    for (i = 0; i < _rgThread.Count(); i++)
    {
        CTipbarThread *pThread = _rgThread.Get(i);
        if (!pThread)
            continue;

        pThread->_UninitItemList(TRUE);
        pThread->Disconnect();
        pThread->_Release();
    }
    _rgThread.Clear();

    if (_putb)
        _putb->UnadviseEventSink(_dwlbimCookie);

    SafeReleaseClear(_putb);
}

//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

HRESULT CTipbarWnd::OnSetFocus(DWORD dwThreadId)
{
    BOOL fNewThread = FALSE;
    CTipbarThread *pThread;
    CTipbarThread *pPrevFocusThread;
    BOOL fWasInFullScreen = _fInFullScreen;
    HWND hwndFore = GetForegroundWindow();
    DWORD dwThreadIdFore = GetWindowThreadProcessId(hwndFore, NULL);
    HRESULT hr;
    CTipbarThread *pThreadPrev = NULL;
    BOOL fSkipRedrawOnNoItem = FALSE;

    TraceMsg(TF_FUNC, "focusnfy OnSetFocus %x ", dwThreadId);

    //
    // if the toolbar is being terminated, do nothing.
    //
    if (_fTerminating)
        return S_OK;

    if (_dwThreadIdWaitNotify && (_dwThreadIdWaitNotify != dwThreadId))
        return S_OK;
    //
    // If this MSUTB is in ctfmon.exe and the langbar status is in Deskband,
    // this meutb should stop wroking.
    //
    if (!_fInDeskBand && IsSFDeskband())
        return S_OK;

    if (!IsWindow(GetWnd()))
        return E_FAIL;

    StartPendingUpdateUI();
    AddRef();

    if (!_fInDeskBand && dwThreadIdFore)
    {
        BOOL fScreenSaverRunning = FALSE;

        if (IsOnNT5() || IsOn98())
        {
            SystemParametersInfo(SPI_GETSCREENSAVERRUNNING, 0,
                                 &fScreenSaverRunning, FALSE);
        }

        if (IsFullScreenWindow(hwndFore) || fScreenSaverRunning)
        {
            if (GetWindowLongPtr(GetWnd(), GWL_STYLE) & WS_VISIBLE)
            {
                Show(FALSE);
                _fInFullScreen = TRUE;
                _dwPrevTBStatus = _dwSFTFlags;
            }
        }
        else if (fWasInFullScreen)
        {
            Show(TRUE);
            _fInFullScreen = FALSE;

            //
            // Bug#500507 - Need to recover language bar show status value.
            //
            if (!(_dwPrevTBStatus & TF_SFT_DESKBAND))
                GetLangBarMgr()->ShowFloating(_dwPrevTBStatus);
        }
    }

    KillTimer(TIPWND_TIMER_SETWINDOWPOS);
    SetTimer(TIPWND_TIMER_SETWINDOWPOS, g_uTimerElapseSETWINDOWPOS);

    pThread = _FindThread(dwThreadId);
    if (_pFocusThread && (pThread == _pFocusThread))
    {
        hr = S_OK;
        goto Exit;
    }

    //
    // keep the current focus thread.
    //
    pPrevFocusThread = _pFocusThread;

    CancelMenu();

    if (!pThread)
    {
        pThread = _CreateThread(dwThreadId);
        if (!pThread)
        {
            hr = E_FAIL;
            goto Exit;
        }

        fNewThread = TRUE;
    }

    //
    // focus has been change during creating pThread.
    // we don't have to do anything now.
    //
    if (_pFocusThread && (pPrevFocusThread != _pFocusThread))
    {
        hr = S_OK;
        goto Exit;
    }

    if (_pFocusThread)
    {
        _pFocusThread->RemoveUIObjs();
    }

    SetFocusThread(pThread);

    if (pThread)
    {
        Assert(pThread == _pFocusThread);
        BOOL fItemChanged = pThread->_fItemChanged;

        //
        // addref to increment the refcount.
        //
        pThread->_AddRef();

        hr = S_OK;
        if (fItemChanged)
            hr = pThread->_UninitItemList(TRUE);

        if (SUCCEEDED(hr))
        {
            pThread->RemoveUIObjs();

            if (fItemChanged)
                pThread->InitItemList();
        }

        //
        // UninitItemList and InitItemList make marshaling calls.
        // we need to check _pFocusThread again.
        //
        if (pThread == _pFocusThread)
        {
            pThread->LocateItems();
            pThread->AddUIObjs();

            if (fNewThread || fItemChanged)
            {
                if (!pThread->UpdateItems())
                {
                    pThread->RemoveUIObjs();
                    SetFocusThread(NULL);
                }
            }
            else if (pThread->IsDirtyItem())
            {
                //
                // this thread has a update dirty item. Need to update now.
                // We got OnUpdate call while it was background thread.
                //
                KillTimer(TIPWND_TIMER_ONUPDATECALLED);
                SetTimer(TIPWND_TIMER_ONUPDATECALLED, g_uTimerElapseONUPDATECALLED);
            }
        }

        fSkipRedrawOnNoItem = pThread->_fSkipRedrawOnNoItem;
        //
        // release to decrement the refcount.
        //
        pThread->_Release();
    }

    _ctrlbtnHolder.EnableBtns();

    if (_fShowTrayIcon)
    {
       KillTimer(TIPWND_TIMER_MOVETOTRAY);
       SetTimer(TIPWND_TIMER_MOVETOTRAY, g_uTimerElapseMOVETOTRAY);
    }

    //
    // Cic#4712
    //
    if (_dwThreadItemChangedForTimer != dwThreadId)
    {
        KillOnTheadItemChangeTimer();
    }

    hr = S_OK;

Exit:
    if (fSkipRedrawOnNoItem)
        KillTimer(TIPWND_TIMER_UPDATEUI);

    EndPendingUpdateUI();
    Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// IsFullScreenWindow
//
//+---------------------------------------------------------------------------

BOOL CTipbarWnd::IsFullScreenWindow(HWND hwnd)
{
    ULONG_PTR dwStyle;
    ULONG_PTR dwExStyle;

    dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
    if (!(dwStyle & WS_VISIBLE))
        return FALSE;

    if (dwStyle & WS_CAPTION)
        return FALSE;

    dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);

#ifdef OLD_FULLSCREENDETECTION
    if (dwExStyle & WS_EX_TOOLWINDOW)
        return FALSE;

    if (!IsZoomed(hwnd) && !(dwExStyle & WS_EX_LAYERED))
    {
        if (IsFullScreenSize(hwnd))
            return TRUE;
    }
#else
    if (dwExStyle & WS_EX_LAYERED)
        return FALSE;

    //
    // #376691
    //
    // the full screen mode of Windows Media Player uses WS_EX_TOOLWINDOW style.
    // we need to check if it is fullscreen window or not.
    //
    if (dwExStyle & WS_EX_TOOLWINDOW)
    {
        if (hwnd == shellwnd.GetWndProgman())
            return FALSE;
    }

    //
    // And some shell fullscreen window (such as slide show) 
    // has "mazimized" status. So we don't want to check IsZoomed().
    //
    // Thus any application without caption covers the screen won't have a 
    // floating toolbar. 
    //
    if (IsFullScreenSize(hwnd))
        return TRUE;
#endif

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// SetFocusThread
//
//----------------------------------------------------------------------------

HRESULT CTipbarWnd::SetFocusThread(CTipbarThread *pThread)
{
    if (pThread == _pFocusThread)
        return S_OK;

    DWORD dwThreadId = GetCurrentThreadId();

    DestroyOverScreenSizeBalloon();

    if (_pFocusThread)
    {
        _pFocusThread->SetFocus(FALSE);
        AttachThreadInput(dwThreadId, _pFocusThread->_dwThreadId, FALSE);
    }

    _pFocusThread = pThread;

    //
    // we will attach the focus thread input into this thread when
    // when we need (mouse message comes and any other case?). 
    //
    _fFocusAttached = FALSE;

    if (_pFocusThread)
    {
        _pFocusThread->SetFocus(TRUE);
    }

    if (!_pFocusThread)
    {
        if (!IsVisibleWindowInDesktop())
        {
            // this is a hack to shut down ctfmon.exe when we're in a terminal server session
            // and the main app has shutdown and no shell is running -- terminal server won't
            // end the session as long as ctfmon is running which effectively locks the machine.
            // See cicero bug 4235.
            //
            // Issue: got some more info from the terminal server team, another cleaner fix:
            //
            // Anyway if you need to put something in "not wait for" list, just add a value to 
            // "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\SysProcs" key.
            // Name of the value should be equal to a name of executable, type is REG_DWORD, value is 0.
            if (!_fInDeskBand)
                PostQuitMessage(0);
            else if (_pDeskBand)
                _pDeskBand->DeleteBand();

        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AttachFocusThread
//
//----------------------------------------------------------------------------

HRESULT CTipbarWnd::AttachFocusThread()
{
    if (_fFocusAttached)
        return TRUE;

    // 
    // Attach the focus thread when mouse message is coming.  Since this 
    // toolbar window is disabled window, using different input focus
    // causes unexpected focus change.
    //

    if (_pFocusThread)
    {
        DWORD dwThreadId = GetCurrentThreadId();
        AttachThreadInput(dwThreadId, _pFocusThread->_dwThreadId, TRUE);
        _fFocusAttached = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ThreadTerminate
//
//----------------------------------------------------------------------------

HRESULT CTipbarWnd::OnThreadTerminate(DWORD dwThreadId)
{
    HRESULT hr;

    StartPendingUpdateUI();
    AddRef();

    hr = OnThreadTerminateInternal(dwThreadId);
    if (!_pFocusThread)
        EnsureFocusThread();

    EndPendingUpdateUI();
    Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnThreadTerminateInternal
//
//----------------------------------------------------------------------------

HRESULT CTipbarWnd::OnThreadTerminateInternal(DWORD dwThreadId)
{
    TraceMsg(TF_FUNC, "focusnfy OnThreadTerminate %x ", dwThreadId);

    int i;
    for (i = 0; i < _rgThread.Count(); i++)
    {
        CTipbarThread *pThread = _rgThread.Get(i);
        if (!pThread)
            continue;

        if (pThread->_dwThreadId == dwThreadId)
        {
            _rgThread.Remove(i, 1);

            pThread->RemoveUIObjs();

            CleanUpThreadPointer(pThread, FALSE);

            pThread->_UninitItemList(TRUE);
            pThread->Disconnect();
            pThread->_Release();
            goto Exit;
        }
    }

Exit:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CleanUpThreadPointer
//
// This function make sure CTipbarWnd does not have pThread pointer any more.
//
//----------------------------------------------------------------------------

void CTipbarWnd::CleanUpThreadPointer(CTipbarThread *pThread, BOOL fCheckThreadArray)
{
    Assert(pThread);

    if (fCheckThreadArray)
    {
        int i;
        for (i = 0; i < _rgThread.Count(); i++)
        {
            if (pThread == _rgThread.Get(i))
            {
                _rgThread.Remove(i, 1);
                break;
            }
        }
    }

    if (pThread == _pFocusThread)
        SetFocusThread(NULL);

    if (pThread == _pttModal)
        _pttModal = NULL;

    if (pThread == _pThreadShowWindowAtTimer)
        _pThreadShowWindowAtTimer = NULL;
}

//+---------------------------------------------------------------------------
//
// EnsureFocusThread
//
//----------------------------------------------------------------------------

void CTipbarWnd::EnsureFocusThread()
{
    if (_pFocusThread)
    {
        Assert(0); 
        return;
    }

    if (_fTerminating)
        return;

    if (_fInEnsureFocusThread)
        return;

    _fInEnsureFocusThread = TRUE;

    HWND hwndFore = GetForegroundWindow();
    if (hwndFore)
    {
        DWORD dwThreadId = GetWindowThreadProcessId(hwndFore, NULL);
        if (dwThreadId)
            OnSetFocus(dwThreadId);
    }

    _fInEnsureFocusThread = FALSE;
}

//+---------------------------------------------------------------------------
//
// OnThreadItemChange
//
//----------------------------------------------------------------------------

HRESULT CTipbarWnd::OnThreadItemChange(DWORD dwThreadId)
{
    CTipbarThread *pThread;
    TraceMsg(TF_FUNC, "focusnfy OnThreadItemChange %x ", dwThreadId);

    //
    // if the toolbar is being terminated, do nothing.
    //
    if (_fTerminating)
        return S_OK;

    //
    // If this MSUTB is in ctfmon.exe and the langbar status is in Deskband,
    // this meutb should stop wroking.
    //
    if (!_fInDeskBand && IsSFDeskband())
        return S_OK;

    pThread = _FindThread(dwThreadId);
    if (!pThread)
    {
#if 0
        //
        // Issue: #365434 - In the running of Deskband after just restart
        // machine, this hit will disable the showing deskband.
        //
        if (!_pFocusThread)
            Show(FALSE);
#endif

        return S_OK;
    }

    if ((_dwThreadIdWaitNotify && (_dwThreadIdWaitNotify != dwThreadId)) ||
        (pThread != _pFocusThread))
    {
        pThread->_fItemChanged = TRUE;
        return S_OK;
    }

    KillOnTheadItemChangeTimer();

    _dwThreadItemChangedForTimer = dwThreadId;
    KillTimer(TIPWND_TIMER_ONUPDATECALLED);
    SetTimer(TIPWND_TIMER_ONTHREADITEMCHANGE, g_uTimerElapseONTHREADITEMCHANGE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnThreadItemChange
//
//----------------------------------------------------------------------------

HRESULT CTipbarWnd::OnThreadItemChangeInternal(DWORD dwThreadId)
{
    CTipbarThread *pThread;
    HRESULT hr = S_OK;

    TraceMsg(TF_FUNC, "focusnfy OnThreadItemChangeInternal %x ", dwThreadId);

    if (_dwThreadIdWaitNotify && (_dwThreadIdWaitNotify != dwThreadId))
        return S_OK;

    //
    // If this MSUTB is in ctfmon.exe and the langbar status is in Deskband,
    // this meutb should stop wroking.
    //
    if (!_fInDeskBand && IsSFDeskband())
        return S_OK;

    pThread = _FindThread(dwThreadId);

    if (!pThread)
        return S_OK;

    if (pThread != _pFocusThread)
    {
        pThread->_fItemChanged = TRUE;
        return hr;
    }

    //
    // Ok, dwThreadId has a focus now, we need immediate action to update
    // langbar.
    //
    Assert(dwThreadId == pThread->_dwThreadId);

    StartPendingUpdateUI();

    //
    // addref to increment the refcount.
    //
    pThread->_AddRef();

    hr = pThread->_UninitItemList(TRUE);

    if (SUCCEEDED(hr))
    {
        pThread->RemoveUIObjs();
        hr = pThread->InitItemList();

        if (SUCCEEDED(hr))
        {
            //
            // UninitItemList and InitItemList make marshaling calls.
            // we need to check _pFocusThread again.
            //
            if (pThread == _pFocusThread)
            {
                pThread->LocateItems();
                pThread->AddUIObjs();
                pThread->UpdateItems();
            }
        }
    }

    //
    // release to decrement the refcount.
    //
    pThread->_Release();

    //
    // #366835
    //
    // We got an error for the focus thread. Marshalling stubs might been gone!
    // Let's restart marshaling.
    //
    if (hr == RPC_E_CONNECTION_TERMINATED)
    {
        //
        // Throw away lost marshalled interfaces.
        //
        OnThreadTerminateInternal(dwThreadId);

        //
        // OnSetFocus() will reacate CTipbarThread.
        //
        OnSetFocus(dwThreadId);
    }

    _ctrlbtnHolder.EnableBtns();

    // InvalidateRect(GetWnd(), NULL, TRUE);
    if (_fShowTrayIcon)
    {
        KillTimer(TIPWND_TIMER_MOVETOTRAY);
        SetTimer(TIPWND_TIMER_MOVETOTRAY, g_uTimerElapseMOVETOTRAY);
    }

    EndPendingUpdateUI();
    return hr;
}

//+---------------------------------------------------------------------------
//
// MoveToTray
//
//----------------------------------------------------------------------------

void CTipbarWnd::MoveToTray()
{
    //
    // we don't use NotyfTrayIcon on WinXP.
    //
    if (IsOnNT51())
        return;

    if (!g_pTrayIconWnd)
        return;

    //
    // Even if the floating toolbar setting is "minimized", we need to show
    // it when explorer.exe is not running.
    //
    if (!g_pTrayIconWnd->GetNotifyWnd())
    {
        Show(TRUE);
        return;
    }

    if (_fShowTrayIcon)
    {
        if (_pFocusThread)
        { 
            if (TF_IsInMarshaling(_pFocusThread->_dwThreadId))
            {
                SetTimer(TIPWND_TIMER_MOVETOTRAY, g_uTimerElapseMOVETOTRAY);
                return;
            }
        }
        //
        // we move to TrayIcon. Make sure the toolbar is hidden.
        //
        KillTimer(TIPWND_TIMER_SHOWWINDOW);
        Show(FALSE);

        DestroyOverScreenSizeBalloon();
        CTipbarItem *pItem = NULL;
        BOOL fIsKeyboardItemVisible = FALSE;
        CTipbarItem *pKeyboardItem = NULL;
        if (_pFocusThread)
        {
            if (_pFocusThread->IsConsole())
                pItem = _pFocusThread->GetItem(GUID_LBI_INATITEM);
            else
                pItem = _pFocusThread->GetItem(GUID_LBI_CTRL);

            if (pItem && !pItem->IsVisibleInToolbar())
                pItem = NULL;

            pKeyboardItem = _pFocusThread->GetItem(GUID_TFCAT_TIP_KEYBOARD);
            if (pKeyboardItem && !pKeyboardItem->IsInHiddenStatus())
                fIsKeyboardItemVisible = TRUE;
        }

        //
        // we don't have to show UTB's Main Icon when
        //   - there is LBI_INATITEM or LBI_CTRL item.
        //   - there is a visible keyboard item.
        //
        g_pTrayIconWnd->SetMainIcon(pItem ? NULL : fIsKeyboardItemVisible ? NULL : GetFocusKeyboardLayout());

        if (!g_pTrayIconWnd->_fShowExtraIcons)
        {
            DWORD dwRAIFlags = 0;
            if (pItem)
                dwRAIFlags |= TIW_RAI_LEAVELANGICON;

            if (fIsKeyboardItemVisible)
                dwRAIFlags |= TIW_RAI_LEAVEKEYBOARDICON;

            g_pTrayIconWnd->RemoveAllIcon(dwRAIFlags);

            if (pItem)
            {
                pItem->MoveToTray();
            }
            else if (fIsKeyboardItemVisible)
            {
                Assert(!!pKeyboardItem)
                pKeyboardItem->MoveToTray();
            }
        }
        else if (_pFocusThread)
        {
            int i;

            g_pTrayIconWnd->RemoveUnusedIcons(&_pFocusThread->_rgItem);

            for (i = 0; i < _pFocusThread->_rgItem.Count(); i++)
            {
                if (TF_IsInMarshaling(_pFocusThread->_dwThreadId))
                {
                    SetTimer(TIPWND_TIMER_MOVETOTRAY, g_uTimerElapseMOVETOTRAY);
                    return;
                }

                pItem = _pFocusThread->_rgItem.Get(i);
                if (pItem)
                    pItem->MoveToTray();
            }
        }
    }
}
//+---------------------------------------------------------------------------
//
// OnModalInput
//
//----------------------------------------------------------------------------

STDAPI CTipbarWnd::OnModalInput(DWORD dwThreadId, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_KEYDOWN:
        case WM_KEYUP:
            if (_pttModal)
            {
                Assert(_pModalMenu);
                Assert(_pttModal->_dwThreadId == dwThreadId);
                _pModalMenu->PostKey((uMsg == WM_KEYUP), wParam, lParam);
            }
            break;

        case WM_NCLBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        case WM_NCMBUTTONDOWN:
            break;

        case WM_NCLBUTTONUP:
        case WM_NCRBUTTONUP:
        case WM_NCMBUTTONUP:
            //
            // Multi Monitor
            //
            // if the disable window is in the negative location of 
            // screen coordinate, wm_ncxx message is generated. 
            // (maybe this is not mm specific, since siable window does not
            //  get WM_NCHITTEST.)
            // 
            // we just forward this message to modal menu window as a normal
            // mouse message to simulate the mouse action.
            //
            if (_pttModal)
            {
                Assert(_pModalMenu);
                Assert(_pttModal->_dwThreadId == dwThreadId);
                HWND hwnd = _pModalMenu->GetWnd();
                if (hwnd) 
                {
                    POINT pt;
                    POINTSTOPOINT( pt, MAKEPOINTS( lParam ) );
                    ScreenToClient(hwnd, &pt);
                    PostMessage(hwnd,
                                uMsg + (WM_MOUSEMOVE - WM_NCMOUSEMOVE),
                                wParam,
                                MAKELPARAM(pt.x, pt.y));
                }
            }
            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
            break;

        default:
            CancelMenu();
            break;
            
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ShowFloating
//
//----------------------------------------------------------------------------

STDAPI CTipbarWnd::ShowFloating(DWORD dwFlags)
{
    if (_fInDeskBand)
    {
        _dwSFTFlags = dwFlags;

        if (dwFlags & TF_SFT_DESKBAND)
        {
            //
            // If we don't have _pFocusThread, the empty langbar is shown.
            // Try to get the thread of the foreground window. This may not
            // work correctly because the actual focus could be different 
            // from the thread of the foreground window.
            //
            if (!_pFocusThread)
            {
                KillTimer(TIPWND_TIMER_ENSUREFOCUS);
                SetTimer(TIPWND_TIMER_ENSUREFOCUS, g_uTimerElapseENSUREFOCUS);
            }

            //
            // Update Extra icons changing options
            //
            KillTimer(TIPWND_TIMER_SYSCOLORCHANGED);
            SetTimer(TIPWND_TIMER_SYSCOLORCHANGED, g_uTimerElapseSYSCOLORCHANGED);
        }

        if (dwFlags & TF_SFT_EXTRAICONSONMINIMIZED)
        {
            _fAddExtraIcon = TRUE;
            ClearDeskbandSizeAdjusted();
        }
        else if (dwFlags & TF_SFT_NOEXTRAICONSONMINIMIZED)
        {
            _fAddExtraIcon = FALSE;
            ClearDeskbandSizeAdjusted();
        }

        return S_OK;
    }
    
    if (dwFlags & TF_SFT_SHOWNORMAL)
    {
        //
        // we update the itemlist from registry now.
        // something might be change during deskbanding.
        //
        _itemList.Load();

        SetShowTrayIcon(FALSE);

        //
        // Call SetLangBar() before updating _dwSFTFlags.
        //
        SetLangBand(FALSE);

        //
        // Set SHOWNOARMAL flag before calling OnSetFocus().
        //
        _dwSFTFlags = TF_SFT_SHOWNORMAL;

        //
        // If we don't have _pFocusThread, the empty langbar is shown.
        // Try to get the thread of the foreground window. This may not
        // work correctly because the actual focus could be different 
        // from the thread of the foreground window.
        //
        if (!_pFocusThread)
            EnsureFocusThread();

        Show(TRUE);

    }
    else if (dwFlags & TF_SFT_DOCK)
    {
        //
        // Call SetLangBar() before updating _dwSFTFlags.
        //
        SetLangBand(FALSE);
        _dwSFTFlags = TF_SFT_DOCK;
    }
    else if (dwFlags & TF_SFT_MINIMIZED)
    {
        SetShowTrayIcon(TRUE);
        KillTimer(TIPWND_TIMER_SHOWWINDOW);
        Show(FALSE);

        //
        // Call SetLangBar() before updating _dwSFTFlags.
        //
        SetLangBand(FALSE);

        _dwSFTFlags = TF_SFT_MINIMIZED;
    }
    else if (dwFlags & TF_SFT_HIDDEN)
    {
        SetShowTrayIcon(FALSE);
        KillTimer(TIPWND_TIMER_SHOWWINDOW);
        Show(FALSE);

        //
        // Call SetLangBar() before updating _dwSFTFlags.
        //
        SetLangBand(FALSE);
        _dwSFTFlags = TF_SFT_HIDDEN;

        TurnOffSpeechIfItsOn();
    }
    else if (dwFlags & TF_SFT_DESKBAND)
    {
        SetShowTrayIcon(FALSE);
        KillTimer(TIPWND_TIMER_SHOWWINDOW);
        KillTimer(TIPWND_TIMER_SHOWDESKBAND);
        Show(FALSE);

        //
        // if the process of explorer belongs to different user, we don't 
        // set langband.
        //
        if (InitCurrentProcessSid())
        {
            DWORD dwProcessIdTray;
            HWND hwndTray = shellwnd.GetWndTray();
            GetWindowThreadProcessId(hwndTray, &dwProcessIdTray);
            if (dwProcessIdTray)
            {
                char szSid[UNLEN + 1];
                GetUserSIDString(dwProcessIdTray, szSid, ARRAYSIZE(szSid));
                if (lstrcmp(szSid, g_szSid))
                    return S_OK;
    
            }
        }

        //
        // Need to make sure adding the language bar menu on taskbar
        //
        SetRegisterLangBand(TRUE);

        //
        // BugBug#377897 - Always show the extra additional icons in case of
        // single keyboard layout.
        //
        if (IsSFNoExtraIcon())
        {
            if (IsSingleKeyboardLayout())
            {
                GetLangBarMgr()->ShowFloating(TF_SFT_EXTRAICONSONMINIMIZED);
            }
        }

        //
        // Call SetLangBar() before updating _dwSFTFlags.
        //
        if (SetLangBand(TRUE))
            _dwSFTFlags = TF_SFT_DESKBAND;
        else
            SetTimer(TIPWND_TIMER_SHOWDESKBAND, g_uTimerElapseSHOWDESKBAND);
    }

    if (dwFlags & TF_SFT_NOTRANSPARENCY)
    {
         SetAlpha(255, FALSE);
    }
    else if (dwFlags & TF_SFT_LOWTRANSPARENCY)
    {
         SetAlpha(128, FALSE);
    }
    else if (dwFlags & TF_SFT_HIGHTRANSPARENCY)
    {
         SetAlpha(62, FALSE);
    }

    if (dwFlags & TF_SFT_LABELS)
    {
        SetShowText(TRUE);
    }
    else if (dwFlags & TF_SFT_NOLABELS)
    {
        SetShowText(FALSE);
    }

    if (dwFlags & TF_SFT_EXTRAICONSONMINIMIZED)
    {
        _fAddExtraIcon = TRUE;

        if (g_pTrayIconWnd)
        {
            g_pTrayIconWnd->_fShowExtraIcons = TRUE;
            if (_fShowTrayIcon)
                SetShowTrayIcon(TRUE);
        }
    }
    else if (dwFlags & TF_SFT_NOEXTRAICONSONMINIMIZED)
    {
        _fAddExtraIcon = FALSE;

        if (g_pTrayIconWnd)
        {
            g_pTrayIconWnd->_fShowExtraIcons = FALSE;
            if (_fShowTrayIcon)
                SetShowTrayIcon(TRUE);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetItemFloatingRect
//
//----------------------------------------------------------------------------

STDAPI CTipbarWnd::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    HRESULT hr;

    if (IsShowTrayIcon())
        return E_UNEXPECTED;

    if (!_pFocusThread)
        return E_FAIL;

    if (_pFocusThread->_dwThreadId != dwThreadId)
        return E_FAIL;

    hr = E_FAIL;

    int i;
    for (i = 0; i < _pFocusThread->_rgItem.Count(); i++)
    {
        CTipbarItem *pItem = _pFocusThread->_rgItem.Get(i);
        if (!pItem)
            continue;

        if (pItem->IsVisibleInToolbar() && IsEqualGUID(*pItem->GetGUID(), rguid))
        {
            pItem->GetScreenRect(prc);
            hr = S_OK;
            break;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnLangBarUpdate
//
//----------------------------------------------------------------------------

STDAPI CTipbarWnd::OnLangBarUpdate(UINT uUpdate, LPARAM lParam)
{
    switch (uUpdate)
    {
        case TF_LBU_CAPSKANAKEY:
            _ctrlbtnHolder.UpdateCapsKanaState(lParam);
            break;

        case TF_LBU_NTCONSOLELANGCHANGE:
            if (_pFocusThread && _pFocusThread->IsConsole())
            {
                CTipbarItem *pItem = _pFocusThread->GetItem(GUID_LBI_INATITEM);
                if (pItem)
                {
                    CLBarInatItem *plbi = (CLBarInatItem *)pItem->GetNotifyUI();

                    HKL hkl = (HKL)lParam;
                    if (!hkl)
                    {
                        //
                        // #403714
                        //
                        // Don't know when GetKeyboardLayout() starts returning
                        // the correct value for the Console thread id.
                        // Want to use another timer to have an interval but
                        // having lots of code and path is not good idea at
                        // this time (just before releasing WinXP).
                        // Calling Sleep() with small interval looks the 
                        // safest way to solve this problem.
                        //
                        Sleep(50);
                        hkl = GetKeyboardLayout(_pFocusThread->_dwThreadId);
                    }

                    plbi->SetHKL(hkl);
                    if (g_pTrayIconWnd)
                    {
                       g_pTrayIconWnd->SetMainIcon(NULL);
                    }
                }
                _pFocusThread->UpdateItems();
            }
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FindAndCreateThread
//
//----------------------------------------------------------------------------

CTipbarThread *CTipbarWnd::_FindThread(DWORD dwThreadId)
{
    int i;
    for (i = 0; i < _rgThread.Count(); i++)
    {
        CTipbarThread *pThread = _rgThread.Get(i);
        if (!pThread)
            continue;

        if (pThread->_dwThreadId == dwThreadId)
        {
            DWORD dwProcessId;
            DWORD dwThreadFlags;
            DWORD dwTickTime;

            //
            // TF_GetThreadFlag() does not work corrently on 
            // winlogon desktop..
            //
            if (g_bWinLogon)
                break;

            TF_GetThreadFlags(dwThreadId, &dwThreadFlags, &dwProcessId, &dwTickTime);

            if (!dwProcessId || 
                (dwProcessId != pThread->_dwProcessId) ||
                (dwTickTime != pThread->_dwTickTime))
            {
                OnThreadTerminateInternal(dwThreadId);
                pThread = NULL;
            }

            return pThread;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// FindAndCreateThread
//
//----------------------------------------------------------------------------

CTipbarThread *CTipbarWnd::_CreateThread(DWORD dwThreadId)
{
    HRESULT hr;
    CTipbarThread *pThread = _FindThread(dwThreadId);

    if (pThread)
        return pThread;

    CTipbarThread **ppThread;

    MyWaitForInputIdle(dwThreadId, UTB_INPUTIDLETIMEOUT);

    pThread = new CTipbarThread(this);
    if (!pThread)
        goto Exit;

    hr = pThread->Init(dwThreadId);
    if (FAILED(hr))
    {
        goto FreeThread;
    }

    if (SUCCEEDED(pThread->InitItemList()))
    {
        TraceMsg(TF_GENERAL, "OnSetFocus Create New CTipbarThreadm");

        ppThread = _rgThread.Append(1);
        if (!ppThread)
        {
            goto FreeThread;
        }

        *ppThread = pThread;
    }
    else
    {
        TraceMsg(TF_GENERAL, "focusnfy OnSetFocus fail to create CTipbarThreadm");
FreeThread:
        pThread->_UninitItemList(TRUE);
        pThread->Disconnect();
        pThread->_Release();
        pThread = NULL;
        goto Exit;
    }

Exit:
    return pThread;
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

void CTipbarWnd::Init(BOOL fInDeskBand, CDeskBand *pDeskBand)
{
    RECT rc;


    if (_fInDeskBand = fInDeskBand)
        _fShowText = FALSE;
 
    _pDeskBand = pDeskBand;

    ::SetRect(&rc, 0, 0, 0, 0);

    if (g_bNewLook && 
        !_pWndFrame &&
        (GetStyle() & UIWINDOW_OFC10TOOLBAR))
    {
        UINT uWndFrameStyle;

        uWndFrameStyle = UIWNDFRAME_THIN | UIWNDFRAME_NORESIZE;

        _pWndFrame = new CUIFWndFrame(this, &rc, uWndFrameStyle);

        if (_pWndFrame)
        {
            _pWndFrame->Initialize();

            AddUIObj(_pWndFrame);
        }
    }

    if (!_pGripper && !_fInDeskBand)
    {
        _pGripper = new CTipbarGripper(this, &rc, IsVertical() ? UIGRIPPER_VERTICAL : 0);

        if (_pGripper)
        {
            _pGripper->Initialize();

            AddUIObj(_pGripper);
        }
    }


    _ctrlbtnHolder.Init(this);

    if (!IsVertical())
        Move(_xWnd, _yWnd, 0, GetTipbarHeight());
    else
        Move(_xWnd, _yWnd, GetTipbarHeight(), 0);
}

//+---------------------------------------------------------------------------
//
// SetVertical
//
//----------------------------------------------------------------------------

void CTipbarWnd::SetVertical(BOOL fVertical)
{
    int iPartID;
    _fVertical = fVertical;

    if (_fVertical)
        iPartID = TBP_BACKGROUNDLEFT;
    else
        iPartID = TBP_BACKGROUNDBOTTOM;

    if (_pGripper)
    {
        DWORD dwStyle = _pGripper->GetStyle();
        if (fVertical)
            dwStyle |= UIGRIPPER_VERTICAL;
        else
            dwStyle &= ~UIGRIPPER_VERTICAL;
        _pGripper->SetStyle(dwStyle);
    }

    if (g_fTaskbarTheme)
        SetActiveTheme(L"TASKBAR", iPartID, TS_NORMAL );

    if (!_fInDeskBand)
    {
        if (!IsVertical())
            Move(_xWnd, _yWnd, 0, GetTipbarHeight());
        else
            Move(_xWnd, _yWnd, GetTipbarHeight(), 0);
    }

    if (GetWnd())
    {
        KillTimer(TIPWND_TIMER_SYSCOLORCHANGED);
        SetTimer(TIPWND_TIMER_SYSCOLORCHANGED, g_uTimerElapseSYSCOLORCHANGED);
    }
}

//+---------------------------------------------------------------------------
//
// InitThemeMargins
//
//----------------------------------------------------------------------------

void CTipbarWnd::InitThemeMargins()
{
    CUIFTheme themeBtn;
    memset(&_marginsItem, 0, sizeof(_marginsItem));
    _cxItemMargin = CX_ITEMMARGIN;
    _nItemDistance = ITEMDISTANCE;
    _nCtrlItemHeightMargin = CTRLITEMHEIGHTMARGIN;
    _cxCapBtn = GetSystemMetrics( SM_CXSIZE );

    themeBtn.SetActiveTheme(L"TOOLBAR", TP_BUTTON, 0);
    if (SUCCEEDED(themeBtn.OpenThemeData(GetWnd())))
    {
        themeBtn.GetThemeMargins(NULL, TS_NORMAL, 
                                 TMT_CONTENTMARGINS, 
                                 NULL, &_marginsItem);
        _cxItemMargin = CX_ITEMMARGIN_THEME;
        _nItemDistance = ITEMDISTANCE_THEME;
        _nCtrlItemHeightMargin = CTRLITEMHEIGHTMARGIN_THEME;
    }

    themeBtn.CloseThemeData();
    themeBtn.SetActiveTheme(L"WINDOW", WP_CLOSEBUTTON, 0);
    if (SUCCEEDED(themeBtn.OpenThemeData(GetWnd())))
    {
        SIZE size;
        themeBtn.GetThemePartSize(NULL, TS_NORMAL, 
                                  NULL,
                                  TS_TRUE, 
                                  &size);

        int cy = themeBtn.GetThemeSysSize(SM_CYSIZE);
        _cxCapBtn = MulDiv(cy, size.cx, size.cy);
    }
}


//+---------------------------------------------------------------------------
//
// UpdateVerticalFont
//
//----------------------------------------------------------------------------

void CTipbarWnd::UpdateVerticalFont()
{
    if (_fVertical)
    {
        if (_hfontVert)
        {
            DeleteObject(_hfontVert);
            SetFontToThis(NULL);
            _hfontVert = NULL;
        }

        _hfontVert = CreateVerticalFont();
        SetFontToThis(_hfontVert);
    }
    else
    {
        SetFontToThis(NULL);
    }
}

//+---------------------------------------------------------------------------
//
// CheckEAFonts
//
//----------------------------------------------------------------------------

int CALLBACK FindEAEnumFontProc(const LOGFONT *plf, const TEXTMETRIC *ptm, WORD wType, LPARAM lParam)
{
    BOOL *pf = (BOOL *)lParam;

    if (wType != TRUETYPE_FONTTYPE)
        return 1;

    if (plf->lfFaceName[0] == '@')
    {
        *pf = TRUE;
        return 0;
    }

    return 1;
}

BOOL CheckEAFonts()
{
    HDC hdc = GetDC(NULL);
    BOOL fFound = FALSE;

    EnumFonts(hdc, NULL, (FONTENUMPROC)FindEAEnumFontProc, (LPARAM)&fFound);

    ReleaseDC(NULL, hdc);
    return fFound;
}


//+---------------------------------------------------------------------------
//
// CreateVerticalFont
//
//----------------------------------------------------------------------------

HFONT CTipbarWnd::CreateVerticalFont()
{
    HFONT hfontVert = NULL;
    CUIFTheme themeBtn;
    themeBtn.SetActiveTheme(L"TOOLBAR", TP_BUTTON, 0);

    if (!GetWnd())
        return NULL;

    BOOL fIsEAFonts = CheckEAFonts();

    if (SUCCEEDED(themeBtn.OpenThemeData(GetWnd())))
    {
        LOGFONTW lfw;
        Assert(IsOnNT51());

        if (SUCCEEDED(themeBtn.GetThemeFont(NULL, 0 , TMT_FONT, &lfw)))
        {
            lfw.lfEscapement = 2700;
            lfw.lfOrientation = 2700;
            lfw.lfOutPrecision = OUT_TT_ONLY_PRECIS;

            if (fIsEAFonts)
            {
                //
                // Use @font for vertical langbar.
                //
                WCHAR szFaceName[LF_FACESIZE];
                szFaceName[0] = L'@';
                StringCchCopyW(&szFaceName[1], ARRAYSIZE(szFaceName) -1, lfw.lfFaceName);
                StringCchCopyW(lfw.lfFaceName, ARRAYSIZE(lfw.lfFaceName), szFaceName);

            }
            hfontVert = CreateFontIndirectW(&lfw);
            goto CheckFont;
        }
    }

    LOGFONT lf;
    HFONT hDefFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
    GetObject(hDefFont, sizeof(LOGFONT), &lf);
    lf.lfEscapement = 2700;
    lf.lfOrientation = 2700;
    lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;

    if (fIsEAFonts)
    {
        //
        // Use @font for vertical langbar.
        //
        char szFaceName[LF_FACESIZE];
        szFaceName[0] = '@';
        StringCchCopy(&szFaceName[1], ARRAYSIZE(szFaceName) -1, lf.lfFaceName);
        StringCchCopy(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), szFaceName);
    }

    hfontVert = CreateFontIndirect(&lf);

CheckFont:
    return hfontVert;
}

//+---------------------------------------------------------------------------
//
// SetLangBand
//
//----------------------------------------------------------------------------

BOOL CTipbarWnd::SetLangBand(BOOL fLangBand, BOOL fNotify)
{
    BOOL fRet = TRUE;

    if (fLangBand == (IsSFDeskband() ? TRUE : FALSE))
        return fRet;

    //
    // Set/Remove language band object
    //
    HWND hwndTray = shellwnd.GetWndTray();

    if (fNotify && hwndTray)
    {
#ifndef CUAS_ENABLE
        DWORD_PTR dwResult;
        LRESULT lResult = (LRESULT)0;

        lResult = SendMessageTimeout(hwndTray,
                                     TM_LANGUAGEBAND,
                                     0,
                                     fLangBand,
                                     SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                     5000,
                                     &dwResult);

        //
        // Checking the language band setting fail case
        //
        if (!lResult || dwResult != fLangBand)
        {
            Assert(0);
        }
#else
        DWORD_PTR dwResult;
        LRESULT lResult = (LRESULT)0;

        //
        // Workaround fixes of Cicero 5181
        // Explorer process doesn't initialize _ptbs yet when receive TM_LANGUAGEBAND.
        //
        HWND hwndIME = NULL;

        //
        // we should not load IMM32 here. If there is no IMM32.DLL loaded,
        // there is no hwndIME.
        //
        if (GetSystemModuleHandle("imm32.dll"))
            hwndIME = ImmGetDefaultIMEWnd(hwndTray);

        if (hwndIME)
        {
            lResult = SendMessageTimeout(hwndIME,
                                         WM_IME_SYSTEM,
                                         fLangBand ? IMS_SETLANGBAND : IMS_RESETLANGBAND,
                                         (LPARAM)hwndTray,
                                         SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                         5000,
                                         &dwResult);
        }
        else
        {
            lResult = SendMessageTimeout(hwndTray,
                                         TM_LANGUAGEBAND,
                                         0,
                                         fLangBand,
                                         SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                         5000,
                                         &dwResult);
        }

        //
        // Checking the language band setting fail case
        //
        if (!lResult || dwResult != fLangBand)
        {
            Assert(0);
        }
#endif
    }
    else
    {
        fRet = FALSE;
    }

    //
    // If this MSUTB is in ctfmon.exe and the langbar status is in Deskband,
    // this meutb should stop wroking.
    //
    if (!_fInDeskBand && fLangBand)
    {
        KillTimer(TIPWND_TIMER_SYSCOLORCHANGED);
        SetTimer(TIPWND_TIMER_SYSCOLORCHANGED, g_uTimerElapseSYSCOLORCHANGED);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// SetMoveRect
//
//----------------------------------------------------------------------------

void CTipbarWnd::SetMoveRect( int x, int y, int nWidth, int nHeight)
{
    if (_fInDeskBand)
    {
       //
       // In case of DeskBand case, only update width and height.
       //
       _nWidth = nWidth;
       _nHeight = nHeight;

       return;
    }

    _rcNew.left   = x;
    _rcNew.top    = y;
    _rcNew.right  = nWidth;
    _rcNew.bottom = nHeight;
    _fNeedMoveWindow = TRUE;

    StartPendingUpdateUI();

    RECT rc;
    SIZE sizeWndFrame;
    sizeWndFrame.cx = 0;
    sizeWndFrame.cy = 0;
    if (_pWndFrame)
    {
        ::SetRect(&rc, 0, 0,
                  nWidth - GetCxDlgFrame(),
                  nHeight - GetCyDlgFrame());
        _pWndFrame->SetRect(&rc);
        _pWndFrame->GetFrameSize( &sizeWndFrame );
    }

    if (_pGripper)
    {
        if (!IsVertical())
        {
            ::SetRect(&rc,
                      sizeWndFrame.cx,
                      sizeWndFrame.cy,
                      sizeWndFrame.cx + GetGripperWidth(),
                      nHeight - GetCyDlgFrame() - sizeWndFrame.cy);
        }
        else
        {
            ::SetRect(&rc,
                      sizeWndFrame.cx,
                      sizeWndFrame.cy,
                      nWidth - GetCxDlgFrame() - sizeWndFrame.cx,
                      sizeWndFrame.cy + GetGripperWidth());
        }
        _pGripper->SetRect(&rc);
    }
    EndPendingUpdateUI();
}

//+---------------------------------------------------------------------------
//
// GetGripperWidth
//
//----------------------------------------------------------------------------

int CTipbarWnd::GetGripperWidth()
{ 
    if (_fInDeskBand)
        return 0;

    if (_pGripper)
    {
        if (SUCCEEDED(_pGripper->EnsureThemeData(GetWnd())))
        {
            int nRet = -1;

            SIZE size;
            HDC hdc = GetDC(GetWnd());
            if (SUCCEEDED(_pGripper->GetThemePartSize(hdc, 
                                                      TS_NORMAL,
                                                      NULL, 
                                                      TS_TRUE, 
                                                      &size)))
            {
                if (!IsVertical())
                   nRet = size.cx + CUI_GRIPPER_THEME_MARGIN * 2;
                else
                   nRet = size.cy + CUI_GRIPPER_THEME_MARGIN * 2;
            }

            ReleaseDC(GetWnd(), hdc);

            if (nRet >= 0)
                return nRet;
        }
    }

    return 5;
}

//+---------------------------------------------------------------------------
//
// Move
//
//----------------------------------------------------------------------------

void CTipbarWnd::Move( int x, int y, int nWidth, int nHeight)
{
    CUIFWindow::Move(x, y, nWidth, nHeight);
}

//+---------------------------------------------------------------------------
//
// LocateCtrlButtons
//
//----------------------------------------------------------------------------

void CTipbarWnd::LocateCtrlButtons()
{
    DWORD dwFlags = 0;

    if (IsSFDeskband() && IsSFNoExtraIcon())
        dwFlags |= TCBH_NOCOLUMN;

    if (!IsCapKanaShown())
        dwFlags |= TCBH_NOCOLUMN0;

    SIZE sizeWndFrame;
    sizeWndFrame.cx = 0;
    sizeWndFrame.cy = 0;
    if (_pWndFrame != NULL) 
        _pWndFrame->GetFrameSize( &sizeWndFrame );

    int nTipbarHeight = GetTipbarHeight();
    RECT rc;
    GetRect(&rc);
    int nHeightPadding = 0;

    if (!IsVertical())
    {
        if (rc.bottom - rc.top > nTipbarHeight)
            nHeightPadding = (rc.bottom - rc.top - nTipbarHeight) / 2;

        int xNew;
        if (_fNeedMoveWindow)
            xNew =  _rcNew.right - GetCtrlButtonWidth() - sizeWndFrame.cx;
        else
            xNew =  _nWidth - GetCtrlButtonWidth() - sizeWndFrame.cx;

        _ctrlbtnHolder.Locate(this, 
                              xNew,
                              sizeWndFrame.cy + nHeightPadding, 
                              nTipbarHeight - (sizeWndFrame.cy * 2), 
                              dwFlags, FALSE);
    }
    else
    {
        if (rc.right - rc.left > nTipbarHeight)
            nHeightPadding = (rc.right - rc.left - nTipbarHeight) / 2;

        int yNew;
        if (_fNeedMoveWindow)
            yNew =  _rcNew.bottom - GetCtrlButtonWidth() - sizeWndFrame.cy;
        else
            yNew =  _nHeight - GetCtrlButtonWidth() - sizeWndFrame.cy;

        _ctrlbtnHolder.Locate(this, 
                              sizeWndFrame.cx + nHeightPadding,
                              yNew,
                              nTipbarHeight - (sizeWndFrame.cx * 2), 
                              dwFlags, TRUE);
    }
}

//+---------------------------------------------------------------------------
//
// GetFocusKeyboardLayout
//
//----------------------------------------------------------------------------

HKL CTipbarWnd::GetFocusKeyboardLayout() 
{
    return GetKeyboardLayout(_pFocusThread ? _pFocusThread->_dwThreadId : 0);
}

//+---------------------------------------------------------------------------
//
// HandleMouseMsg
//
//----------------------------------------------------------------------------

void CTipbarWnd::HandleMouseMsg( UINT uMsg, POINT pt )
{
    if (_fInHandleMouseMsg)
        return;

    //
    // Bug#477031: Add the reference count to finish the current task before
    // destructing this object.
    //
    //
    AddRef();

    _fInHandleMouseMsg = TRUE;

    if (_pFocusThread)
    {
        AttachFocusThread();

        if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN))
            if (!MyWaitForInputIdle(_pFocusThread->_dwThreadId, 
                                    UTB_INPUTIDLETIMEOUT))
                _pFocusThread->_ptw->_putb->RestoreLastFocus(NULL, FALSE);
    }

    POINT ptScrn = pt;
    ClientToScreen(GetWnd(), &ptScrn);
    if (WindowFromPoint(ptScrn) == GetWnd())
    {
        SetAlpha(255, TRUE);

        if (_fInStub)
        {
            KillTimer(TIPWND_TIMER_STUBEND);

            if (!_fInStubShow)
               SetTimer(TIPWND_TIMER_STUBSTART, g_uTimerElapseSTUBSTART);
        }
    }
    else
    {
        SetAlpha(_bAlpha, TRUE);

        if (_fInStub && _fInStubShow)
            SetTimer(TIPWND_TIMER_STUBEND, g_uTimerElapseSTUBEND);
    }
    CUIFWindow::HandleMouseMsg(uMsg, pt);

    if (uMsg == WM_RBUTTONUP)
    {
       CUIFObject *pUIObj = ObjectFromPoint( pt );
       if (pUIObj && pUIObj->GetID() != (-1))
       {
           PostMessage(GetWnd(), WM_LBWND_SHOWCONTEXTMENU, 0, MAKELPARAM(pt.x, pt.y));
       }
    }

    _fInHandleMouseMsg = FALSE;
    Release();
}

//+---------------------------------------------------------------------------
//
// OnMouseOutFromWindow
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnMouseOutFromWindow( POINT pt )
{
    StartBackToAlphaTimer();

    if (_fInStub && _fInStubShow)
        SetTimer(TIPWND_TIMER_STUBEND, g_uTimerElapseSTUBEND);
}

//+---------------------------------------------------------------------------
//
// CheckO10Flag
//
//----------------------------------------------------------------------------

#ifdef USE_OFC10LOOKONWINXP

void CTipbarWnd::CheckO10Flag()
{
    if (!g_bNewLook)
        return;

    EnsureThemeData(GetWnd());
    if (IsThemeActive() || _fInDeskBand)
    {
        g_dwWndStyle &= ~UIWINDOW_OFC10TOOLBAR;
    }
    else
    {
        g_dwWndStyle |= UIWINDOW_OFC10TOOLBAR;
    }

    SetStyle(g_dwWndStyle);
    CreateScheme();
}
#endif

//+---------------------------------------------------------------------------
//
// OnCreate
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnCreate(HWND hWnd)
{

    if (g_fTaskbarTheme)
         SetWindowTheme(hWnd, L"TASKBAR", NULL);

#ifdef USE_OFC10LOOKONWINXP
    CheckO10Flag();
#endif

    if (_fVertical)
    {
        if (!_hfontVert)
        {
            _hfontVert = CreateVerticalFont();
        }
        SetFontToThis(_hfontVert);
    }
 
    _ctrlbtnHolder.UpdateBitmap(this);

    _itemList.Load();

    if (_putb)
        _putb->AdviseEventSink(this, hWnd, TF_LBESF_GLOBAL, &_dwlbimCookie);

    if (_pFocusThread)
        _pFocusThread->InitItemList();
  
    InitHighContrast();
    SetAlpha(128, FALSE);

    InitMetrics();


    //
    // MSAA support
    //
    Assert(!_pTipbarAcc);
    _pTipbarAcc = new CTipbarAccessible(this);
    if (_pTipbarAcc)
    {
        _pTipbarAcc->SetWindow(hWnd);
    }
}

//+---------------------------------------------------------------------------
//
// SetAlpha
//
//----------------------------------------------------------------------------

typedef BOOL (WINAPI * SETLAYERWINDOWATTRIBUTE)(HWND, COLORREF, BYTE, DWORD);
void CTipbarWnd::SetAlpha(BYTE bAlpha, BOOL fTemp)
{
    if (!_fInDeskBand && IsOnNT5())
    {

        //
        // we don't do alpha blending.
        //
        //    when high contrast is on 
        //    when Modal Menu is shown.
        //
        //
        if (IsHighContrastOn() ||
            _pModalMenu)
        {
            fTemp = TRUE;
            bAlpha = 255;
        }

        if (!fTemp)
            _bAlpha = bAlpha;

        if (_bCurAlpha == bAlpha)
            return;

        CUIFShadow *pShadowWnd = GetShadowWnd();
        if (pShadowWnd)
        {
            EnableShadow(bAlpha == 255);
            pShadowWnd->Show((bAlpha == 255) && IsVisible());
        }

        DWORD dwExStyle = GetWindowLong(GetWnd(), GWL_EXSTYLE);
        SetWindowLong(GetWnd(), GWL_EXSTYLE, dwExStyle | WS_EX_LAYERED);

        static SETLAYERWINDOWATTRIBUTE  pfnSetLayeredWindowAttributes = NULL;
        if (!pfnSetLayeredWindowAttributes)
        {
            HINSTANCE hUser32;
            hUser32 = GetSystemModuleHandle(TEXT("user32.dll"));
            if (hUser32)
                pfnSetLayeredWindowAttributes = (SETLAYERWINDOWATTRIBUTE)GetProcAddress(hUser32, TEXT("SetLayeredWindowAttributes"));
        }

        if (pfnSetLayeredWindowAttributes)
            pfnSetLayeredWindowAttributes(GetWnd(), 0, (BYTE)bAlpha, LWA_ALPHA);


        _bCurAlpha = bAlpha;
    }
}

//+---------------------------------------------------------------------------
//
// OnDestroy
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnDestroy(HWND hWnd)
{
    CancelMenu();

    //
    // MSAA support
    //
    if (_pTipbarAcc)
        _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_DESTROY, this);

    OnTerminateToolbar();

    if (_pTipbarAcc)
    {
        _pTipbarAcc->ClearAccItems();
        _pTipbarAcc->Release();
        _pTipbarAcc = NULL;
    }

    CoUninit();

    if (_putb)
        _putb->UnadviseEventSink(_dwlbimCookie);
}

//+---------------------------------------------------------------------------
//
// OnShowWindow
//
//----------------------------------------------------------------------------

LRESULT CTipbarWnd::OnShowWindow( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    //
    // MSAA support
    //
    if (_pTipbarAcc)
    {
        if (wParam) 
        {
            _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_SHOW ,this);

            // 
            // MSCANDUI does this.
            // 
            // REVIEW: KOJIW: Unless we send notify EVENT_OBJECT_FOCUS, 
            // we never receive WM_GETOBJECT message.  Why???
            // 

            _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_FOCUS ,this);
        }
        else 
        {
            _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_HIDE ,this);
        }
    }

    return CUIFWindow::OnShowWindow( hWnd, uMsg, wParam, lParam );
}

//+---------------------------------------------------------------------------
//
// OnEndSession
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnEndSession(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if (!g_bWinLogon)
        OnTerminateToolbar();

    if (wParam)
    {
        if (lParam & ENDSESSION_LOGOFF)
        {
            KillTimer(TIPWND_TIMER_SHOWWINDOW);
            Show(FALSE);
        }
        else
        {
            OnTerminateToolbar();

            AddRef();
            DestroyWindow(hwnd);
            Release();
        }
    }
}

//+---------------------------------------------------------------------------
//
// OnTerminateToolbar
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnTerminateToolbar()
{
    _fTerminating = TRUE;

    DestroyOverScreenSizeBalloon();

    TerminateAllThreads(TRUE);

    if (!_fInDeskBand)
        SavePosition();
}

//+---------------------------------------------------------------------------
//
// SavePosition
//
//----------------------------------------------------------------------------

void CTipbarWnd::SavePosition()
{
    CMyRegKey keyUTB;

    if (keyUTB.Create(HKEY_CURRENT_USER, c_szUTBKey) == S_OK)
    {
        POINT pt;
        pt.x = 0;
        pt.y = 0;
        MyClientToScreen(&pt, NULL);
        keyUTB.SetValue((DWORD)pt.x, c_szLeft);
        keyUTB.SetValue((DWORD)pt.y, c_szTop);
        keyUTB.SetValue((DWORD)_fVertical ? 1 : 0, c_szVertical);
    }
}

//+---------------------------------------------------------------------------
//
// TerminateAllThreads
//
//----------------------------------------------------------------------------

void CTipbarWnd::TerminateAllThreads(BOOL fTerminatFocusThread)
{
    int nCnt = _rgThread.Count();
    int i;
    DWORD *pdwThread;

    pdwThread = new DWORD[nCnt + 1];
    if (!pdwThread)
        return;

    for (i = 0; i < nCnt; i++)
    {
        pdwThread[i] = 0;

        CTipbarThread *pThread = _rgThread.Get(i);
        if (!pThread)
            continue;

        if (!fTerminatFocusThread && (pThread == _pFocusThread))
            continue;

        pdwThread[i] = pThread->_dwThreadId;
    }

    
    for (i = 0; i < nCnt; i++)
    {
        if (pdwThread[i])
            OnThreadTerminateInternal(pdwThread[i]);
    }

    delete[] pdwThread;
}

//+---------------------------------------------------------------------------
//
// SetShowText()
//
//----------------------------------------------------------------------------

void CTipbarWnd::SetShowText(BOOL fShowText) 
{
    _fShowText = fShowText;

    if (_pFocusThread)
    {
        OnThreadItemChange(_pFocusThread->_dwThreadId);
    }

    TerminateAllThreads(FALSE);
}

//+---------------------------------------------------------------------------
//
// OnWindowPosChanged
//
//----------------------------------------------------------------------------

LRESULT CTipbarWnd::OnWindowPosChanged(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (_pFocusThread)
    {
        int i;
        for (i = 0; i < _pFocusThread->_rgItem.Count(); i++)
        {
            CTipbarItem *pItem = _pFocusThread->_rgItem.Get(i);
            if (pItem)
                pItem->OnPosChanged();
        }
    }

    return CUIFWindow::OnWindowPosChanged(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// OnWindowPosChanging
//
//----------------------------------------------------------------------------

LRESULT CTipbarWnd::OnWindowPosChanging(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    WINDOWPOS *pwp = (WINDOWPOS *)lParam;

    if (!(pwp->flags & SWP_NOZORDER))
    {
        CUIFToolTip *ptip = GetToolTipWnd();

        //
        // we don't patch hwndInsertAfter, when
        //    - Tooltip is being shown.
        //    - Modal Popup menu is shown.
        //
        if ((!ptip || !(ptip->IsBeingShown())) &&
            !_pttModal)
            pwp->hwndInsertAfter = HWND_TOP;
    }

    return CUIFWindow::OnWindowPosChanged(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// OnEraseBkGnd()
//
//----------------------------------------------------------------------------

LRESULT CTipbarWnd::OnEraseBkGnd( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{ 
    return 1;
}

//+---------------------------------------------------------------------------
//
// PaintObject()
//
//----------------------------------------------------------------------------

void CTipbarWnd::PaintObject( HDC hDC, const RECT *prcUpdate )
{
    // KillTimer(TIPWND_TIMER_ONUPDATECALLED);

    if (_fNeedMoveWindow)
    {
        Move(_rcNew.left, _rcNew.top, _rcNew.right, _rcNew.bottom);
        _fNeedMoveWindow = FALSE;
    }

    if (_pFocusThread && _pFocusThread->IsDirtyItem())
    {
        _pFocusThread->CallOnUpdateHandler();

        //
        // #432697: Stress fault
        //
        // ClosePopupTipbar() could be called while CallOnUpdateHandler()
        // is calling marshaling. We should check if g_pTIpbarWnd is 
        // available.
        //
        if (!g_pTipbarWnd)
            return;
    }

    CUIFWindow::PaintObject(hDC, prcUpdate);
}

//+---------------------------------------------------------------------------
//
// UpdateUI()
//
//----------------------------------------------------------------------------

void CTipbarWnd::UpdateUI( const RECT *prcUpdate )
{
    // TraceMsg(TF_FUNC, "UpdateUI");

    KillTimer(TIPWND_TIMER_UPDATEUI);

    if (_dwThreadItemChangedForTimer ||
        _dwPendingUpdateUI || 
        (_pFocusThread && _pFocusThread->IsDirtyItem()))
    {
        SetTimer(TIPWND_TIMER_UPDATEUI, g_uTimerElapseUPDATEUI);
        return;
    }

    if (_fNeedMoveWindow)
    {
        // TraceMsg(TF_FUNC, "UpdateUI need move window");
        StartPendingUpdateUI();
        Move(_rcNew.left, _rcNew.top, _rcNew.right, _rcNew.bottom);
        _fNeedMoveWindow = FALSE;
        EndPendingUpdateUI();
    }

    TraceMsg(TF_FUNC, "UpdateUI update now ");
    CUIFWindow::UpdateUI(NULL);
}


//+---------------------------------------------------------------------------
//
// SetShowTrayIcon()
//
//----------------------------------------------------------------------------

void CTipbarWnd::SetShowTrayIcon(BOOL fShowTrayIcon) 
{
    _fShowTrayIcon = fShowTrayIcon;

    if (_fShowTrayIcon && _pFocusThread)
    {
        KillTimer(TIPWND_TIMER_MOVETOTRAY);
        SetTimer(TIPWND_TIMER_MOVETOTRAY, g_uTimerElapseMOVETOTRAY);
    }
    else if (g_pTrayIconWnd)
    {
        g_pTrayIconWnd->SetMainIcon(NULL);
        g_pTrayIconWnd->RemoveAllIcon(0);
    }



}

//+---------------------------------------------------------------------------
//
// ShowOverScreenSizeBalloon
//
//----------------------------------------------------------------------------

void CTipbarWnd::ShowOverScreenSizeBalloon()
{
    RECT rc;
    POINT pt;
    CTipbarCtrlButton *pcuiCtrlbtn = _ctrlbtnHolder.GetCtrlBtn(ID_CBTN_EXTMENU);
    if (!pcuiCtrlbtn)
    {
        Assert(0);
        return;
    }

    DestroyOverScreenSizeBalloon();

    _pblnOverScreenSize = new CUIFBalloonWindow(g_hInst, UIBALLOON_OK);
    if (!_pblnOverScreenSize)
        return;

    _pblnOverScreenSize->Initialize();

    pcuiCtrlbtn->GetRect(&rc);
    pt.x = (rc.left + rc.right) / 2;
    pt.y = rc.top;
    MyClientToScreen(&pt, &rc);

    _pblnOverScreenSize->SetTargetPos(pt);
    _pblnOverScreenSize->SetExcludeRect(&rc);

    _pblnOverScreenSize->SetText(CRStr(IDS_OVERSCREENSIZE));
    _pblnOverScreenSize->CreateWnd(GetWnd());

}

//+---------------------------------------------------------------------------
//
// DestroyMinimizeBalloon
//
//----------------------------------------------------------------------------

void CTipbarWnd::DestroyOverScreenSizeBalloon()
{
    if (_pblnOverScreenSize)
    {
        if (IsWindow(_pblnOverScreenSize->GetWnd()))
            DestroyWindow(_pblnOverScreenSize->GetWnd());
        delete _pblnOverScreenSize;
        _pblnOverScreenSize = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CancelMenu
//
//----------------------------------------------------------------------------

void CTipbarWnd::CancelMenu()
{
    if (_pttModal)
    {
        if (_pttModal->_ptw && _pttModal->_ptw->_putb)
            _pttModal->_ptw->StartModalInput(NULL, _pttModal->_dwThreadId);
        Assert(_pModalMenu);
        _pModalMenu->CancelMenu();

        StartBackToAlphaTimer();
    }
}

//+---------------------------------------------------------------------------
//
// MoveToStub
//
//----------------------------------------------------------------------------

void CTipbarWnd::MoveToStub(BOOL fHide)
{
    RECT rc;
    _fInStub = TRUE;

    SystemParametersInfo(SPI_GETWORKAREA, 0, (void *)&rc, FALSE);

    if (fHide)
    {
        _xWnd = rc.right - (24 + 14);
        _fInStubShow = FALSE;
    }
    else
    {
        RECT rcWnd;
        GetWindowRect(GetWnd(), &rcWnd);
        _xWnd = rc.right - (rcWnd.right - rcWnd.left);
        _fInStubShow = TRUE;
    }
    _yWnd = rc.bottom - GetTipbarHeight() - _cyDlgFrame;

    if (_pFocusThread)
        _pFocusThread->MyMoveWnd(0, 0);
}

//+---------------------------------------------------------------------------
//
// RestoreFromStub
//
//----------------------------------------------------------------------------

void CTipbarWnd::RestoreFromStub()
{
    _fInStub = FALSE;
    _fInStubShow = FALSE;
    KillTimer(TIPWND_TIMER_STUBSTART);
    KillTimer(TIPWND_TIMER_STUBEND);
}

//+---------------------------------------------------------------------------
//
// CTipbarWnd::KillOnThreadItemChangeTimer
//
//----------------------------------------------------------------------------

void CTipbarWnd::KillOnTheadItemChangeTimer()
{
    DWORD dwThreadId = _dwThreadItemChangedForTimer;
    _dwThreadItemChangedForTimer = 0;

    KillTimer(TIPWND_TIMER_ONTHREADITEMCHANGE);

    if (dwThreadId)
    {
        CTipbarThread *pThread = _FindThread(dwThreadId);
        if (pThread)
            pThread->_fItemChanged = TRUE;
    }
}


//+---------------------------------------------------------------------------
//
// CTipbarWnd::OnTimer
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnTimer(UINT uId)
{
    DWORD dwFocusThreadId;
    DWORD dwRet;

    AddRef();

    switch (uId)
    {
        case TIPWND_TIMER_STUBSTART:
            KillTimer(TIPWND_TIMER_STUBSTART);
            MoveToStub(FALSE);
            break;

        case TIPWND_TIMER_STUBEND:
            KillTimer(TIPWND_TIMER_STUBEND);
            MoveToStub(TRUE);
            break;

        case TIPWND_TIMER_BACKTOALPHA:
            KillTimer(TIPWND_TIMER_BACKTOALPHA);
            SetAlpha(_bAlpha, TRUE);
            break;

        case TIPWND_TIMER_ONTHREADITEMCHANGE:
            //
            // OnThreadItemChangeInternat will disconnect the marshaling for
            // all items. It is better todo this later.
            //
            dwRet = MyWaitForInputIdle(_dwThreadItemChangedForTimer,  
                                       UTB_INPUTIDLETIMEOUT);
            if (dwRet)
            {
                if (dwRet != WAIT_TIMEOUT)
                {
                    KillTimer(TIPWND_TIMER_ONTHREADITEMCHANGE);
                    _dwThreadItemChangedForTimer = 0;
                }
                break;
            }

            if (!_pttModal)
            {
                KillTimer(TIPWND_TIMER_ONTHREADITEMCHANGE);

                //
                // #509156
                //
                // Set _dwThreadItemChagnedForTimer before calling 
                // OnThreadItemChangeInternal(). During the marshaling call 
                // in the function, someone else may set 
                // _dwThreadItemChangedForTimer.
                //
                DWORD dwThreadIdTemp = _dwThreadItemChangedForTimer;
                _dwThreadItemChangedForTimer = 0;
                OnThreadItemChangeInternal(dwThreadIdTemp);
            }
            break;

        case TIPWND_TIMER_SETWINDOWPOS:
            KillTimer(TIPWND_TIMER_SETWINDOWPOS);
            SetWindowPos(GetWnd(), HWND_TOP, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
            break;

        case TIPWND_TIMER_ONUPDATECALLED:
            KillTimer(TIPWND_TIMER_ONUPDATECALLED);
            //
            // if _dwThreadItemChangedForTimer is not 0, we will
            // update all items later.
            //
            if (_pFocusThread && 
                (_pFocusThread->_dwThreadId != _dwThreadItemChangedForTimer))
            {
                if (!_pFocusThread->CallOnUpdateHandler())
                {
                    if (_pFocusThread)
                        OnThreadItemChange(_pFocusThread->_dwThreadId);
                }
            }
            break;

        case TIPWND_TIMER_SYSCOLORCHANGED:
            KillTimer(TIPWND_TIMER_SYSCOLORCHANGED);

            //
            // the sys colors were changed, we recreate all thread info
            // again.
            //

            if (_pFocusThread)
                dwFocusThreadId = _pFocusThread->_dwThreadId;
            else
                dwFocusThreadId = 0;

            TerminateAllThreads(TRUE);

            UpdateVerticalFont();

            if (dwFocusThreadId)
                OnSetFocus(dwFocusThreadId);

            InitMetrics();
            _ctrlbtnHolder.UpdateBitmap(this);
            InitHighContrast();
            SetAlpha(255, TRUE);

            ::RedrawWindow(GetWnd(), 
                           NULL, 
                           NULL, 
                           RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW);
            break;

        case TIPWND_TIMER_DISPLAYCHANGE:
            KillTimer(TIPWND_TIMER_DISPLAYCHANGE);

            AdjustPosOnDisplayChange();
            break;


        case TIPWND_TIMER_UPDATEUI:
            KillTimer(TIPWND_TIMER_UPDATEUI);
            UpdateUI(NULL);
            break;

        case TIPWND_TIMER_SHOWWINDOW:
            KillTimer(TIPWND_TIMER_SHOWWINDOW);

            if (_pThreadShowWindowAtTimer == _pFocusThread)
                Show(_fShowWindowAtTimer);

            _pThreadShowWindowAtTimer = NULL;
    
            //
            // If the window was over the screen and hide some items,
            // we show balloon tips.
            //
            if (_fShowOverItemBalloonAtTimer)
                ShowOverScreenSizeBalloon();

            break;

        case TIPWND_TIMER_SHOWDESKBAND:
            if (SetLangBand(TRUE))
            {
                _dwSFTFlags = TF_SFT_DESKBAND;
                KillTimer(TIPWND_TIMER_SHOWDESKBAND);
            }

            break;

        case TIPWND_TIMER_MOVETOTRAY:
            KillTimer(TIPWND_TIMER_MOVETOTRAY);
            MoveToTray();
            break;

        case TIPWND_TIMER_ENSUREFOCUS:
            if (_pDeskBand && _pDeskBand->IsInTipbarCreating())
                break;
                
            KillTimer(TIPWND_TIMER_ENSUREFOCUS);
            if (!_pFocusThread)
                EnsureFocusThread();
            break;

        case TIPWND_TIMER_DOACCDEFAULTACTION:
            //
            // MSAA support
            //
            KillTimer(TIPWND_TIMER_DOACCDEFAULTACTION);
            if (_pTipbarAcc && _nDoAccDefaultActionItemId)
            {
                _pTipbarAcc->DoDefaultActionReal(_nDoAccDefaultActionItemId);
                _nDoAccDefaultActionItemId = 0;
            }
            break;

        default:
            if ((uId >= TIPWND_TIMER_DEMOTEITEMFIRST) &&
                (uId < TIPWND_TIMER_DEMOTEITEMLAST))
            {
                LANGBARITEMSTATE *pItemState;
                if (pItemState = _itemList.GetItemStateFromTimerId(uId))
                {
                    CTipbarItem *pItem;
                    _itemList.SetDemoteLevel(pItemState->guid, DL_HIDDENLEVEL1);
                    if (_pFocusThread && 
                        (pItem = _pFocusThread->GetItem(pItemState->guid)))
                    {
                        Assert(!pItem->IsHiddenStatusControl())
                        pItem->AddRemoveMeToUI(FALSE);
                    }
                }
                break;
            }
    }

    Release();
    return;
}


//+---------------------------------------------------------------------------
//
// CTipbarWnd::OnSysColoeChange
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnSysColorChange()
{
    KillTimer(TIPWND_TIMER_SYSCOLORCHANGED);
    SetTimer(TIPWND_TIMER_SYSCOLORCHANGED, g_uTimerElapseSYSCOLORCHANGED);
}

//+---------------------------------------------------------------------------
//
// OnUser
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnUser(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
     POINT pt;

     switch (uMsg)
     {
         case WM_LBWND_SHOWCONTEXTMENU:
             pt.x = LOWORD(lParam);
             pt.y = HIWORD(lParam);
             MyClientToScreen(&pt, NULL);
             ShowContextMenu(pt, NULL, TRUE);
             break;

         default:
             if (uMsg == g_wmTaskbarCreated)
             {
                 shellwnd.Clear();
             }
             break;
     }
}

//+---------------------------------------------------------------------------
//
// OnSettingChange
//
//----------------------------------------------------------------------------

LRESULT CTipbarWnd::OnSettingChange(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
        case 0:
        case SPI_SETHIGHCONTRAST:
        case SPI_SETNONCLIENTMETRICS:
            KillTimer(TIPWND_TIMER_SYSCOLORCHANGED);
            SetTimer(TIPWND_TIMER_SYSCOLORCHANGED, g_uTimerElapseSYSCOLORCHANGED);
            break;
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
// OnDisplayChange
//
//----------------------------------------------------------------------------

LRESULT CTipbarWnd::OnDisplayChange(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    if (!_fInDeskBand)
    {
        KillTimer(TIPWND_TIMER_DISPLAYCHANGE);
        SetTimer(TIPWND_TIMER_DISPLAYCHANGE, g_uTimerElapseDISPLAYCHANGE);
    }
    return CUIFWindow::OnDisplayChange(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// AdjustPosOnDisplayChange
//
//----------------------------------------------------------------------------

void CTipbarWnd::AdjustPosOnDisplayChange()
{
    RECT rc;
    RECT rcWnd;
    int xWnd = _xWnd;
    int yWnd = _yWnd;

    Assert(!_fInDeskBand);

    rcWnd.left = _xWnd;
    rcWnd.top = _yWnd;
    rcWnd.right = _xWnd + _nWidth;
    rcWnd.bottom = _yWnd + _nHeight;
    if (!GetWorkArea(&rcWnd, &rc))
        return;

    if (_fPosLeft)
        xWnd = rc.left;

    if (_fPosTop)
        yWnd = rc.top;

    if (_fPosRight)
        xWnd = rc.right - _nWidth;

    if (_fPosBottom)
        yWnd = rc.bottom - _nHeight;

    if ((xWnd != _xWnd) || (yWnd != _yWnd))
        Move(xWnd, yWnd, _nWidth, _nHeight);
}

//+---------------------------------------------------------------------------
//
// UpdatePosFlags
//
//----------------------------------------------------------------------------

#define POSFLAG_MARGIN 2

void CTipbarWnd::UpdatePosFlags()
{
    RECT rc;
    RECT rcWnd;

    if (_fInDeskBand)
        return;


    rcWnd.left = _xWnd;
    rcWnd.top = _yWnd;
    rcWnd.right = _xWnd + _nWidth;
    rcWnd.bottom = _yWnd + _nHeight;
    if (!GetWorkArea(&rcWnd, &rc))
        return;

    if (_xWnd <= rc.left + POSFLAG_MARGIN)
        _fPosLeft = TRUE;
    else
        _fPosLeft = FALSE;

    if (_yWnd <= rc.top + POSFLAG_MARGIN)
        _fPosTop = TRUE;
    else
        _fPosTop = FALSE;

    if (_xWnd + _nWidth >= rc.right - POSFLAG_MARGIN)
        _fPosRight = TRUE;
    else
        _fPosRight = FALSE;

    if (_yWnd + _nHeight >= rc.bottom - POSFLAG_MARGIN)
        _fPosBottom = TRUE;
    else
        _fPosBottom = FALSE;

}

//+---------------------------------------------------------------------------
//
// AutoAdjustDeskBandSize
//
//----------------------------------------------------------------------------

BOOL CTipbarWnd::AutoAdjustDeskBandSize()
{
    if (_fDeskbandSizeAdjusted)
        return FALSE;

    if (!_pFocusThread)
        return FALSE;

    if (_pFocusThread->IsCtfmonProcess())
        return FALSE;

    //
    // if _fAdjustDeskbandIfNoRoom is on, don't put fFit so we don't 
    // do anything if there is a room.
    //
    BOOL fFit = TRUE;
    if (_fAdjustDeskbandIfNoRoom)
        fFit = FALSE;

    _fAdjustDeskbandIfNoRoom = FALSE;

    if (AdjustDeskBandSize(fFit))
    {
        SetDeskbandSizeAdjusted();
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// AdjustDeskBandSize
//
//----------------------------------------------------------------------------

BOOL CTipbarWnd::AdjustDeskBandSize(BOOL fFit)
{
    if (!_fInDeskBand)
        return FALSE;

    if (!_pDeskBand)
        return FALSE;

    return _pDeskBand->ResizeRebar(GetWnd(), 
                                   IsVertical() ? _nHeight : _nWidth, 
                                   fFit);
}

//+---------------------------------------------------------------------------
//
// GetThread
//
//----------------------------------------------------------------------------

CTipbarThread *CTipbarWnd::GetThread(DWORD dwThreadId)
{
    int i;
    for (i = 0; i < _rgThread.Count(); i++)
    {
        CTipbarThread *pThread = _rgThread.Get(i);
        if (!pThread)
            continue;

        if (pThread->_dwThreadId == dwThreadId)
        {
            if (TF_GetThreadFlags(dwThreadId, NULL, NULL, NULL))
            {
                return pThread;
            }
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
// RestoreLastFocs
//
//----------------------------------------------------------------------------

void CTipbarWnd::RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev)
{
    if (_putb)
        _putb->RestoreLastFocus(pdwThreadId, fPrev);
}

//+---------------------------------------------------------------------------
//
// StartModalInput
//
//----------------------------------------------------------------------------

void CTipbarWnd::StartModalInput(ITfLangBarEventSink *pSink, DWORD dwThreadId)
{
    if (!_putb)
        return;

    _putb->SetModalInput(pSink, dwThreadId, 0);

    //
    // we want this to track a mouse event of Tray window.
    //
    if (g_pTrayIconWnd)
        _putb->SetModalInput(pSink, g_pTrayIconWnd->GetThreadIdTray(), 0);

    //
    // we want this to track a mouse event of CMD prompt window.
    //
    _putb->SetModalInput(pSink, GetCurrentThreadId(), TF_LBSMI_FILTERCURRENTTHREAD );
}

//+---------------------------------------------------------------------------
//
// StopModalInput
//
//----------------------------------------------------------------------------

void CTipbarWnd::StopModalInput(DWORD dwThreadId)
{
    if (!_putb)
        return;

    _putb->SetModalInput(NULL, dwThreadId, 0);

    if (g_pTrayIconWnd)
        _putb->SetModalInput(NULL, g_pTrayIconWnd->GetThreadIdTray(), 0);

    _putb->SetModalInput(NULL, GetCurrentThreadId(), 0);
}

//+---------------------------------------------------------------------------
//
// ClearLBItemList
//
//----------------------------------------------------------------------------

void CTipbarWnd::ClearLBItemList()
{
    _itemList.Clear();
    if (_pFocusThread)
    {
        OnThreadItemChange(_pFocusThread->_dwThreadId);
    }
}

//+---------------------------------------------------------------------------
//
// ShowMenuExtendMenu
//
//----------------------------------------------------------------------------

void CTipbarWnd::ShowContextMenu(POINT pt, RECT *prc, BOOL fExtendMenuItems)
{
    CUTBContextMenu *pMenu = NULL;
    RECT rc;
    CTipbarThread *ptt = GetFocusThread();
    DWORD dwThreadId;
    UINT uId = CUI_MENU_UNSELECTED;

    //
    // CTipbarWnd could be destroyed during ShowPopup().
    //
    AddRef();

    if (!prc)
    {
        rc.left   = pt.x;
        rc.top    = pt.y;
        rc.right  = pt.x;
        rc.bottom = pt.y;
        prc = &rc;
    }

    if (!ptt)
        goto Exit;

    pMenu = new CUTBContextMenu(this);
    if (!pMenu)
        goto Exit;

    if (!pMenu->Init())
        goto Exit;

    _pttModal = ptt;
    StartModalInput(this, ptt->_dwThreadId);

    dwThreadId = GetCurrentThreadId();
    _pModalMenu = pMenu;

    uId = pMenu->ShowPopup(this, pt, prc, fExtendMenuItems);

    _pModalMenu = NULL;

    if (_pttModal)
        StopModalInput(_pttModal->_dwThreadId);
    _pttModal = NULL;

    if (uId != CUI_MENU_UNSELECTED)
    {
        pMenu->SelectMenuItem(uId);
    }

Exit:
    if (pMenu)
        delete pMenu;

    Release();
}

//+---------------------------------------------------------------------------
//
// IsInItemChangOrDirty
//
//----------------------------------------------------------------------------

BOOL CTipbarWnd::IsInItemChangeOrDirty(CTipbarThread *pThread)
{
    if (pThread->_dwThreadId == _dwThreadItemChangedForTimer)
        return TRUE;

    return pThread->IsDirtyItem();
}

//+---------------------------------------------------------------------------
//
// OnGetObject
//
//----------------------------------------------------------------------------

LRESULT CTipbarWnd::OnGetObject( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    LRESULT lResult = (LRESULT)0;

    switch (lParam) 
    {
        //
        // We process the OBJID_CLIENT object identifier;
        // this is the client area of our application
        // window.
        //

        case OBJID_CLIENT: 
        {
            HRESULT hr;

            if (_pTipbarAcc == NULL) 
            {
                return E_OUTOFMEMORY;
            }


            if (!_pTipbarAcc->IsInitialized()) 
            {
                //
                //
                //
                hr = EnsureCoInit();
                if (FAILED(hr)) 
                {
                    break;
                }
     

                //
                //    Initialize our Accessible object.  If the
                //      initialization fails, delete the Accessible
                //      object and return the failure code.
                //

                hr = _pTipbarAcc->Initialize();
                if (FAILED(hr)) 
                {
                    _pTipbarAcc->Release();
                    _pTipbarAcc = NULL;

                    lResult = (LRESULT)hr;
                    break;
                }

                //
                //    Send an EVENT_OBJECT_CREATE WinEvent for the
                //      creation of the Accessible object for the
                //      client area.
                //

                _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_CREATE , this);
            }

            //
            //    Call LresultFromObject() to create reference to
            //      our Accessible object that MSAA will marshal to
            //      the client.
            //

            lResult = _pTipbarAcc->CreateRefToAccObj( wParam );
            break;
        }

    }


    return lResult;
}

//+---------------------------------------------------------------------------
//
// OnThemeChanged
//
//----------------------------------------------------------------------------

void CTipbarWnd::OnThemeChanged(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
#ifdef USE_OFC10LOOKONWINXP
    CheckO10Flag();
#endif
    CUIFWindow::OnThemeChanged(hwnd, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// StartDoDefaultActionTimer
//
//----------------------------------------------------------------------------

BOOL CTipbarWnd::StartDoAccDefaultActionTimer(CTipbarItem *pItem)
{
   if (!_pTipbarAcc)
       return FALSE;

   _nDoAccDefaultActionItemId = _pTipbarAcc->GetIDOfItem(pItem);
   if ((_nDoAccDefaultActionItemId == 0) || (_nDoAccDefaultActionItemId == -1))
       return FALSE;

   KillTimer(TIPWND_TIMER_DOACCDEFAULTACTION);
   SetTimer(TIPWND_TIMER_DOACCDEFAULTACTION, g_uTimerElapseDOACCDEFAULTACTION);

   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarThread
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarThread::CTipbarThread(CTipbarWnd *ptw)
{

    Dbg_MemSetThisName(TEXT("CTipbarThread"));

    _ptw = ptw;
    _dwThreadId = 0;
    _plbim = NULL;
    _ref = 1;
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

HRESULT CTipbarThread::Init(DWORD dwThreadId)
{
    DWORD dwThreadIdTmp;
    HRESULT hr = S_OK;

    _dwThreadId = dwThreadId;

    if (!TF_GetThreadFlags(_dwThreadId, &_dwThreadFlags, &_dwProcessId, &_dwTickTime))
       return E_FAIL;

    if (IsConsole())
       return S_OK;

    // What's happening: we eventually reach InternalGetThreadUIManager
    // which, if _dwThreadId is NULL, will substitute 
    // g_ShareMem.dwActiveThreadId.
    // This is dangerous, because if the active thread does not match
    // this one we'll do rpc and _plbim will be on the wrong thread.
    // Passing in _dwThreadId seems like the right thing to do....
    
    hr = _ptw->GetLangBarMgr()->GetThreadLangBarItemMgr(_dwThreadId, &_plbim, &dwThreadIdTmp);
    if (FAILED(hr))
        return hr;

    Assert(dwThreadIdTmp == _dwThreadId);

    return hr;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarThread::~CTipbarThread()
{
#ifdef DEBUG
    Assert(!_fInCallOnUpdateHandler);
#endif

    if (_ptw)
    {
        Assert(this != _ptw->GetFocusThread());
        RemoveUIObjs();

        _ptw->CleanUpThreadPointer(this, TRUE);
    }

    _UninitItemList(TRUE);
    SafeReleaseClear(_plbim);
}

//+---------------------------------------------------------------------------
//
// _AddRef
//
//----------------------------------------------------------------------------

ULONG CTipbarThread::_AddRef( )
{
    _ref++;

    return _ref;
}

//+---------------------------------------------------------------------------
//
// _Release
//
//----------------------------------------------------------------------------

ULONG CTipbarThread::_Release( )
{
    ULONG cr;
 
    _ref--;

    cr = _ref;

    if (cr == 0) {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

BOOL CTipbarThread::SetFocus(BOOL fFocus)
{

    if (!fFocus)
    {
        int i;
        for (i = 0; i < _rgItem.Count(); i++)
        {
            CTipbarItem *pItem = _rgItem.Get(i);
            CTipbarBalloonItem *pballoon;
            if (pItem &&
                SUCCEEDED(pItem->QueryInterface(IID_PRIV_BALLOONITEM, (void **)&pballoon)))
            {
                pballoon->DestroyBalloonTip();
                pballoon->Release();
            }
        }

    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// InitItemList
//
//----------------------------------------------------------------------------
#define NUM_GETITEMATONCE   30

HRESULT CTipbarThread::InitItemList()
{
    HRESULT hr = E_FAIL;
    IEnumTfLangBarItems *pEnum = NULL;
    RECT rc;
    CEnumCatCache *penumcache = NULL;
    CGuidDwordCache *pgdcache = NULL;

    if (!_ptw)
        return hr;

    SIZE sizeWndFrame;
    sizeWndFrame.cx = 0;
    sizeWndFrame.cy = 0;
    if (_ptw->GetWndFrame() != NULL) 
        _ptw->GetWndFrame()->GetFrameSize( &sizeWndFrame );

    _ptw->InitThemeMargins();

    if (!IsVertical())
    {
        rc.left   = _ptw->GetGripperWidth() + 1 + sizeWndFrame.cx;
        rc.top    = 0 + sizeWndFrame.cy;
        rc.right  = 0;
        rc.bottom = _ptw->GetTipbarHeight() - sizeWndFrame.cy;
    }
    else
    {
        rc.left   = 0 + sizeWndFrame.cx;
        rc.top    = _ptw->GetGripperWidth() + 1 + sizeWndFrame.cy;
        rc.right  = _ptw->GetTipbarHeight() - sizeWndFrame.cx;
        rc.bottom = 0;
    }


    _nNumItem = 0;

    penumcache = new CEnumCatCache;
    if (!penumcache)
    {
        TraceMsg(TF_FUNC, "could not create CEnumCatCache");
        goto Exit;
    }

    pgdcache = new CGuidDwordCache;
    if (!pgdcache)
    {
        TraceMsg(TF_FUNC, "could not create CGuidDwordCache");
        goto Exit;
    }

    if (_plbim)
    {
        ULONG ulFetched = 0;
        ITfLangBarItem *plbi[NUM_GETITEMATONCE] = {NULL};
        TF_LANGBARITEMINFO lbiInfo[NUM_GETITEMATONCE];
        DWORD dwStatus[NUM_GETITEMATONCE];
        ULONG ul;
        if (SUCCEEDED(hr = _plbim->GetItems(NUM_GETITEMATONCE, 
                                            plbi, 
                                            lbiInfo, 
                                            dwStatus, 
                                            &ulFetched)) && ulFetched)
        {
            for (ul = 0; ul < ulFetched; ul++)
            {
                if (plbi[ul])
                {
                    if (SUCCEEDED(hr))
                    {
                        if (!InsertItem(plbi[ul], 
                                   penumcache, 
                                   pgdcache, 
                                   &rc,
                                   _ptw->GetThemeMargins(),
                                   &lbiInfo[ul], 
                                   &dwStatus[ul]))
                        {
                            hr =  E_FAIL;
                        }
                    }

                    plbi[ul]->Release();
                }
            }

        }

        if (SUCCEEDED(hr))
            _AdviseItemsSink();
    }
    else if (IsConsole())
    {
        CLBarInatItem *pInatItem = new CLBarInatItem(_dwThreadId);
        if (pInatItem)
        {
#ifdef DEBUG
            Assert(!_fIsInatItem);
            _fIsInatItem = TRUE;
#endif

            TF_LANGBARITEMINFO lbiInfo;
            DWORD dwStatus;
            pInatItem->GetInfo(&lbiInfo);
            pInatItem->GetStatus(&dwStatus);
            InsertItem(pInatItem, penumcache, pgdcache, &rc, _ptw->GetThemeMargins(), &lbiInfo, &dwStatus);

            pInatItem->Release();

            _AdviseItemsSink();
            hr = S_OK;
        }
    }

    LocateItems();

Exit:

    if (penumcache)
        delete penumcache;

    if (pgdcache)
        delete pgdcache;

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetTextSize
//
//----------------------------------------------------------------------------

void CTipbarThread::GetTextSize(BSTR bstr, SIZE *psize)
{
    HFONT hfontOld = NULL;
    HDC hdc = GetDC(_ptw->GetWnd());

    if (SUCCEEDED(_ptw->EnsureThemeData(_ptw->GetWnd())))
    {
        RECT rcText;
        LOGFONTW lf;
        HFONT hfont = NULL;
        CUIFTheme themeBtn;

        Assert(IsOnNT51());

        themeBtn.SetActiveTheme(L"TOOLBAR", TP_BUTTON, 0);

        if (SUCCEEDED(themeBtn.OpenThemeData(_ptw->GetWnd())))
        {
            if (SUCCEEDED(themeBtn.GetThemeFont(NULL, 0 , TMT_FONT, &lf)))
                if (hfont = CreateFontIndirectW(&lf))
                    hfontOld = (HFONT)SelectObject(hdc, hfont);

            themeBtn.GetThemeTextExtent(hdc, 0 , bstr, SysStringLen(bstr),0, NULL, &rcText);
        }
        psize->cx = rcText.right;
        psize->cy = rcText.bottom;
 

        if (hfontOld)
            SelectObject(hdc, hfontOld);

        if (hfont)
            DeleteObject(hfont);
    }
    else
    {
        if (_ptw->GetFont())
            hfontOld = (HFONT)SelectObject(hdc, _ptw->GetFont());

        FLGetTextExtentPoint32( hdc, bstr, SysStringLen(bstr), psize);

        if (hfontOld)
            SelectObject(hdc, hfontOld);
    }


    ReleaseDC(_ptw->GetWnd(), hdc);
}

//+---------------------------------------------------------------------------
//
// InsertItem
//
//----------------------------------------------------------------------------

BOOL CTipbarThread::InsertItem(ITfLangBarItem *plbi, CEnumCatCache *penumcache, CGuidDwordCache *pgdcache, RECT *prc, MARGINS *pmargins, TF_LANGBARITEMINFO *plbiInfo, DWORD *pdwStatus)
{
    ITfLangBarItemButton *plbiButton = NULL;
    ITfLangBarItemBitmapButton *plbiBitmapButton = NULL;
    ITfLangBarItemBitmap *plbiBitmap = NULL;
    ITfLangBarItemBalloon *plbiBalloon = NULL;
    CTipbarItem *ptbItem = NULL;
    RECT rc = {0, 0, 0, 0};
    BOOL bRet = FALSE;
    BSTR bstrText = NULL;

    Assert(plbi);

    if ((SUCCEEDED(plbi->QueryInterface(IID_ITfLangBarItemButton, 
                                       (void **)&plbiButton))) ||
        (SUCCEEDED(plbi->QueryInterface(IID_ITfLangBarItemBitmapButton, 
                                       (void **)&plbiBitmapButton))))
    {
        if (!_ptw)
            goto Next;

        SIZE sizeText = {0,0};
        DWORD dwNuiBtnStyle = 0;
        DWORD dwSBtnShowType = 0;
        int nWidth = _ptw->GetSmIconWidth() + _ptw->GetItemMargin();

        if (_ptw->IsShowText())
        {
            dwSBtnShowType |= UITBBUTTON_TEXT;
            HRESULT hr;

            if (plbiButton)
               hr = plbiButton->GetText(&bstrText);
            else if (plbiBitmapButton)
               hr = plbiBitmapButton->GetText(&bstrText);
            else 
               goto Next;

            //
            // check if it is disconnected.
            //
            if (!_ptw)
               goto Next;

            if (SUCCEEDED(hr) && bstrText)
            {

                GetTextSize(bstrText, &sizeText);
                //
                // use height for text margin.
                //
                nWidth += (sizeText.cx + (sizeText.cy / 2));
            }
        }

        nWidth += pmargins->cxLeftWidth;
        nWidth += pmargins->cxRightWidth;

        dwNuiBtnStyle =  plbiInfo->dwStyle & 
                         (TF_LBI_STYLE_BTN_BUTTON | 
                          TF_LBI_STYLE_BTN_MENU | 
                          TF_LBI_STYLE_BTN_TOGGLE);

        if ((dwNuiBtnStyle & (TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_BTN_MENU))
             == (TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_BTN_MENU))
            nWidth += 14;

        if (!IsVertical())
        {
            prc->right  = prc->left + nWidth;
        }
        else
        {
            prc->bottom = prc->top + nWidth;
            dwNuiBtnStyle |= UITBBUTTON_VERTICAL;
        }

        if (plbiButton)
        {
            ptbItem = new CTipbarButtonItem(this, 
                                      plbiButton, 
                                      plbiButton, 
                                      0, 
                                      prc, 
                                      0,
                                      dwNuiBtnStyle,
                                      dwSBtnShowType,
                                      plbiInfo,
                                      *pdwStatus);
        }
        else if (plbiBitmapButton)
        {
            ptbItem = new CTipbarBitmapButtonItem(this, 
                                      plbiBitmapButton, 
                                      plbiBitmapButton, 
                                      0, 
                                      prc, 
                                      0,
                                      dwNuiBtnStyle,
                                      dwSBtnShowType,
                                      plbiInfo,
                                      *pdwStatus);
        }
        else
        {
            Assert(0);
            goto Next;
        }

        if (!ptbItem)
            goto Next;

        ptbItem->Init();

        if (IsVertical())
            ptbItem->SetFont(_ptw->GetVerticalFont());

        ptbItem->SetText((bstrText && SysStringLen(bstrText)) ? bstrText : NULL);
        ptbItem->SetTextSize(&sizeText);

        GetSortScore(ptbItem->GetItemSortScore(), plbiInfo, penumcache, pgdcache);
        ptbItem->SetWidth(nWidth);

    }
    else if (SUCCEEDED(plbi->QueryInterface(IID_ITfLangBarItemBitmap, 
                                            (void **)&plbiBitmap)))
    {
        if (!_ptw)
            goto Next;

        if (!plbiBitmap)
            goto Next;

        SIZE sizeDefault = {_ptw->GetSmIconWidth() * 2,
                            _ptw->GetSmIconHeight()};
        SIZE size;
        plbiBitmap->GetPreferredSize(&sizeDefault, &size);

        if (!_ptw)
            goto Next;

        if (!IsVertical())
            prc->right  = prc->left + size.cx;
        else
            prc->bottom  = prc->top + size.cx;

        ptbItem = new CTipbarBitmapItem(this, 
                                  plbiBitmap, 
                                  plbiBitmap, 
                                  0, 
                                  prc, 
                                  0,
                                  plbiInfo,
                                  *pdwStatus);

        if (!ptbItem)
            goto Next;

        ptbItem->Init();
        GetSortScore(ptbItem->GetItemSortScore(), plbiInfo, penumcache, pgdcache);
        ptbItem->SetWidth(size.cx);
    }
    else if (SUCCEEDED(plbi->QueryInterface(IID_ITfLangBarItemBalloon, 
                                            (void **)&plbiBalloon)))
    {
        if (!_ptw)
            goto Next;

        if (!plbiBalloon)
            goto Next;

        SIZE sizeDefault = {32,16};
        SIZE size;
        plbiBalloon->GetPreferredSize(&sizeDefault, &size);

        if (!_ptw)
            goto Next;

        if (!IsVertical())
            prc->right  = prc->left + size.cx;
        else
            prc->bottom  = prc->top + size.cx;

        ptbItem = new CTipbarBalloonItem(this, 
                                         plbiBalloon, 
                                         plbiBalloon, 
                                         0, 
                                         prc, 
                                         0,
                                         plbiInfo,
                                         *pdwStatus);

        if (!ptbItem)
            goto Next;

        ptbItem->Init();

        if (IsVertical())
            ptbItem->SetFont(_ptw->GetVerticalFont());

        GetSortScore(ptbItem->GetItemSortScore(), plbiInfo, penumcache, pgdcache);
        ptbItem->SetWidth(size.cx);

    }

Next:
    SafeReleaseClear(plbiButton);
    SafeReleaseClear(plbiBitmapButton);
    SafeReleaseClear(plbiBitmap);
    SafeReleaseClear(plbiBalloon);

    if (!_ptw && ptbItem)
    {
        delete ptbItem;
        ptbItem = NULL;
    }
        
    if (ptbItem)
    {
        CTipbarItem **pptbItem = _rgItem.Append(1);
        if (pptbItem)
        {
            *pptbItem = ptbItem;

            if (!IsVertical())
               prc->left = prc->right;
            else
               prc->top = prc->bottom;

            _nNumItem++;
            bRet = TRUE;
        }
        else
        {
            delete ptbItem;
            ptbItem = NULL;
        }
    }

    if (bstrText)
        SysFreeString(bstrText);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// _UninitItemList
//
//----------------------------------------------------------------------------

HRESULT CTipbarThread::_UninitItemList(BOOL fUnAdvise)
{
    int i = 0;
    HRESULT hr = S_OK;

    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (!pItem)
            continue;

        pItem->Disconnect();
    }

    if (fUnAdvise)
    {
        if ((_dwThreadId == GetCurrentThreadId()) ||
            !MyWaitForInputIdle(_dwThreadId, UTB_INPUTIDLETIMEOUT))
           hr = _UnadviseItemsSink();
    }

    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (!pItem)
            continue;

        if (_ptw)
            pItem->RemoveMeToUI(_ptw);

        pItem->ClearConnections();

        if (!_ptw)
            pItem->ClearWnd();
        else
            pItem->DetachWnd();
        pItem->UninitUIResource();
        pItem->Release();
    }

    _rgItem.Clear();

    RemoveAllSeparators();
 
    return hr;
}

//+---------------------------------------------------------------------------
//
// _AdviseItemsSink
//
//----------------------------------------------------------------------------

void CTipbarThread::_AdviseItemsSink()
{
    HRESULT hr;
    int nCnt = _rgItem.Count();
    int i = 0;
    ITfLangBarItemSink **pplbis = NULL;
    GUID *pguid = NULL;
    DWORD *pdwCookie = NULL;

    if (!_plbim || !nCnt)
        goto Exit;

    pplbis = new ITfLangBarItemSink*[nCnt];
    if (!pplbis)
        goto Exit;

    pguid = new GUID[nCnt];
    if (!pguid)
        goto Exit;
    
    pdwCookie = new DWORD[nCnt];
    if (!pdwCookie)
        goto Exit;
    
    for (i = 0; (i < nCnt) && (i < _rgItem.Count()); i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (!pItem)
        {
            Assert(0);
            goto Exit;
        }

        pguid[i] = *pItem->GetGUID();

        hr = pItem->QueryInterface(IID_ITfLangBarItemSink, (void **)&pplbis[i]);
        if (FAILED(hr))
        {
            Assert(0);
            goto Exit;
        }


    }
   
    if (FAILED(_plbim->AdviseItemsSink(nCnt, pplbis, pguid, pdwCookie)))
        goto Exit;

    for (i = 0; (i < nCnt) && (i < _rgItem.Count()); i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (pItem)
            pItem->_dwlbiSinkCookie = pdwCookie[i];

        pplbis[i]->Release();
    }

Exit:
    if (pplbis)
        delete[] pplbis;
    if (pguid)
        delete[] pguid;
    if (pdwCookie)
        delete[] pdwCookie;
}

//+---------------------------------------------------------------------------
//
// _UnadviseItemsSink
//
//----------------------------------------------------------------------------

HRESULT CTipbarThread::_UnadviseItemsSink()
{
    int nCnt = _rgItem.Count();
    int i = 0;
    DWORD *pdwCookie = NULL;
    HRESULT hr = S_OK;

    if (!nCnt)
        goto Exit;

    if (!_plbim)
    {
        hr = E_FAIL;
        goto Exit;
    }
    
    pdwCookie = new DWORD[nCnt];
    if (!pdwCookie)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    for (i = 0; i < nCnt; i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (pItem)
            pdwCookie[i] = pItem->_dwlbiSinkCookie;
    }
   
    if (FAILED(hr = _plbim->UnadviseItemsSink(nCnt, pdwCookie)))
        goto Exit;
Exit:
    if (pdwCookie)
        delete[] pdwCookie;


    return hr;
}

//+---------------------------------------------------------------------------
//
// IsHKLToSkipRedrawOnNoItem
//
//----------------------------------------------------------------------------

BOOL CTipbarWnd::IsHKLToSkipRedrawOnNoItem()
{
    return IsSkipRedrawHKL(GetFocusKeyboardLayout());
}

//+---------------------------------------------------------------------------
//
// LocateItems
//
//----------------------------------------------------------------------------

void CTipbarThread::LocateItems()
{
    int i = 0;
    SIZE sizeWndFrame;
    POINT pt;
    RECT rcWork;
    RECT rc;
    BOOL fOverScreen = FALSE;
    int nTipbarHeight;

    _fSkipRedrawOnNoItem = FALSE;

    if (!_ptw)
        return;

    _ptw->GetRect(&rc);

    pt.x = rc.left;
    pt.y = rc.top;
    CUIGetWorkAreaRect(pt, &rcWork);

    sizeWndFrame.cx = 0;
    sizeWndFrame.cy = 0;
    if (_ptw->GetWndFrame() != NULL) 
        _ptw->GetWndFrame()->GetFrameSize( &sizeWndFrame );

    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *ptbItem = _rgItem.Get(i);
        CTipbarItem *ptbMin = NULL;
        if (!ptbItem)
            continue;
         

        int j;
        CItemSortScore issMin(-1, -1, -1);
        int nMin;

        for (j = i; j < _rgItem.Count(); j++)
        {
             CTipbarItem *ptb = _rgItem.Get(j);
             CItemSortScore *piss = ptb->GetItemSortScore();
             if (issMin > *piss)
             {
                 ptbMin = ptb;
                 issMin = *piss;
                 nMin = j;
             }
        }
        if (ptbMin)
        {
            CTipbarItem **pptbItem = _rgItem.GetPtr(i);
            CTipbarItem **pptbMin = _rgItem.GetPtr(nMin);

            *pptbItem = ptbMin;
            *pptbMin = ptbItem;
        }

    }

LocateItemsAgain:
    RemoveAllSeparators();

    nTipbarHeight = _ptw->GetTipbarHeight();
    if (!IsVertical())
    {
        rc.left   = 1 + _ptw->GetGripperWidth() + sizeWndFrame.cx;

        if (rc.bottom - rc.top > nTipbarHeight)
        {
            int nHeightPadding = (rc.bottom - rc.top - nTipbarHeight) / 2;

            if (nHeightPadding > CY_ITEMMARGIN_THEME)
                nHeightPadding -= CY_ITEMMARGIN_THEME;
            else
                nHeightPadding = 0;

            rc.top    += (0 + sizeWndFrame.cy + nHeightPadding);
            rc.bottom -= (sizeWndFrame.cy + nHeightPadding);
        }
        else
        {
            rc.top    = 0 + sizeWndFrame.cy;
            rc.bottom = nTipbarHeight - sizeWndFrame.cy;
        }

    }
    else
    {
        rc.top   = 1 + _ptw->GetGripperWidth() + sizeWndFrame.cx;

        if (rc.right - rc.left > nTipbarHeight)
        {
            int nHeightPadding = (rc.right - rc.left - nTipbarHeight) / 2;

            if (nHeightPadding > CY_ITEMMARGIN_THEME)
                nHeightPadding -= CY_ITEMMARGIN_THEME;
            else
                nHeightPadding = 0;

            rc.left  += (0 + sizeWndFrame.cy + nHeightPadding);
            rc.right -= (sizeWndFrame.cy + nHeightPadding);
        }
        else
        {
            rc.left  = 0 + sizeWndFrame.cy;
            rc.right = nTipbarHeight - sizeWndFrame.cy;
        }
    }

    i = 0;
    DWORD dwCatScore = 0;
    ULONG ulShownItemInPrevCat = 0;
    BOOL bShowToolbar = FALSE;
    LANGID langid = LANGID(LOWORD(HandleToLong(_ptw->GetFocusKeyboardLayout())));

    CTipbarItem *ptbLastHiddenableItem = NULL;

    while (i < _rgItem.Count())
    {
        LANGBARITEMSTATE *pItemState;
        CTipbarItem *ptbItem = _rgItem.Get(i);
        DWORD dwWidth = ptbItem->GetWidth();

        if (ptbItem->IsHiddenStatusControl())
        {
            if (ptbItem->IsInHiddenStatus())
                goto HideThis;
        }
        else
        {
            pItemState = _ptw->_itemList.FindItem(*ptbItem->GetGUID());
            if (pItemState)
            {
                if (!pItemState->IsShown())
                    goto HideThis;
            }
            else
            {
                if (ptbItem->IsHiddenByDefault())
                    goto HideThis;
            }
            ptbLastHiddenableItem = ptbItem;
        }

        if (_ptw->IsSFDeskband() && _ptw->IsSFNoExtraIcon())
        {
            REFGUID rguidItem = *ptbItem->GetGUID();

            if (!IsEqualGUID(rguidItem, GUID_TFCAT_TIP_KEYBOARD) &&
                !IsEqualGUID(rguidItem, GUID_LBI_INATITEM) &&
                !IsEqualGUID(rguidItem, GUID_LBI_CTRL) &&
                (!IsFELangId(langid) || (IsFELangId(langid) && !ptbItem->IsShownInTray())))
                goto HideThis;
        }

        if (ptbItem->IsShownInTrayOnly())
        {
HideThis:
            RECT rcEmp = {0, 0, 0, 0};
            ptbItem->SetRect(&rcEmp);
            ptbItem->VisibleInToolbar(FALSE);
            goto Next;
        }

        if (!ptbItem->IsHiddenStatusControl())
            _ptw->_itemList.StartDemotingTimer(*ptbItem->GetGUID(), FALSE);

        //
        // If we find an Item to be shown, we show toolbar.
        // If we have only "HideOnNoOterItems" to be shown, we hide toolbar.
        //
        if (!ptbItem->IsHideOnNoOtherItems())
        {
            bShowToolbar = TRUE;
        }

        if (ulShownItemInPrevCat && (dwCatScore != ptbItem->GetCatScore()))
        {
            DWORD dwSepStyle = 0;
            if (!IsVertical())
                rc.right  = rc.left + _ptw->GetItemDistance();
            else
            {
                rc.bottom = rc.top + _ptw->GetItemDistance();
                dwSepStyle |= UITBSEPARATOR_VERTICAL;
            }

            CUIFSeparator *pSep = new CUIFSeparator(_ptw, -1, &rc, dwSepStyle);
            if (pSep)
            {
                int nCntSep = _rgSep.Count();
                pSep->Initialize();

                if (_rgSep.Insert(nCntSep, 1))
                {
                    _rgSep.Set(nCntSep, pSep);
                }
                else
                {
                    delete pSep;
                    pSep = NULL;
                }
            }

            if (!IsVertical())
               rc.left = rc.right;
            else
               rc.top = rc.bottom;

            ulShownItemInPrevCat = 0;
        }

        dwCatScore = ptbItem->GetCatScore();

        if (!IsVertical())
            rc.right  = rc.left + dwWidth;
        else
            rc.bottom  = rc.top + dwWidth;

        ptbItem->SetRect(&rc);
        ptbItem->VisibleInToolbar(TRUE);

        if (!IsVertical())
           rc.left = rc.right;
        else
           rc.top = rc.bottom;

        ulShownItemInPrevCat++;
Next:
        i++;
    }

    // Add the last sepcarator
    if (!IsVertical())
       rc.right  = rc.left + 4;
    else
       rc.bottom  = rc.top + 4;

    DWORD dwSepStyle = 0;
    if (IsVertical())
       dwSepStyle |= UITBSEPARATOR_VERTICAL;

    CUIFSeparator *pSep = new CUIFSeparator(_ptw, -1, &rc, dwSepStyle);

    if (pSep)
    {
        int nCntSep = _rgSep.Count();
        pSep->Initialize();
        if (_rgSep.Insert(nCntSep, 1))
        {
            _rgSep.Set(nCntSep, pSep);
        }
        else
        {
            delete pSep;
            pSep = NULL;
        }
    }


    if (!IsVertical())
    {
        rc.left = rc.right;
        // allocate the space for ctrl buttons.
        rc.right  = rc.left + _ptw->GetCtrlButtonWidth();
    }
    else
    {
        rc.top = rc.bottom;
        // allocate the space for ctrl buttons.
        rc.bottom  = rc.top + _ptw->GetCtrlButtonWidth();
    }

    _sizeWnd.cx = rc.right + sizeWndFrame.cx;
    _sizeWnd.cy = rc.bottom + sizeWndFrame.cy;

    if (_ptw->GetWndFrame() != NULL) 
    {
        RECT rcWnd;
        rcWnd.left   = 0;
        rcWnd.top    = 0;
        rcWnd.right  = _sizeWnd.cx;
        rcWnd.bottom = _sizeWnd.cy;
        _ptw->GetWndFrame()->SetRect(&rcWnd);
    }

    //
    // If the window is wider than WorkArea, we hide one item and locate items
    // again.
    //
    if (_sizeWnd.cx > (rcWork.right - rcWork.left))
    {
        fOverScreen = TRUE;
        if (ptbLastHiddenableItem)
        {
            _ptw->_itemList.SetDemoteLevel(*ptbLastHiddenableItem->GetGUID(), 
                                           DL_HIDDENLEVEL1);
            goto LocateItemsAgain;
        }
    }

    //
    // Exclude caption buttons.
    //
    int dxOffset = 0;
    int dyOffset = 0;
    if (!IsVertical() && g_bExcludeCaptionButtons)
    {
        RECT rcWnd;
        _ptw->GetRect(&rcWnd);
        _ptw->MyClientToScreen(NULL, &rcWnd);
        if (_ptw->CheckExcludeCaptionButtonMode(&rcWnd, &rcWork))
        {
            if ((rcWnd.left + _sizeWnd.cx + _ptw->GetCxDlgFrame()) > 
                (rcWork.right - (_ptw->GetCaptionButtonWidth() * 3)))
            {
                dyOffset = 0 - rcWnd.top;
                dxOffset = (rcWork.right - (_ptw->GetCaptionButtonWidth() * 3)) - 
                           (rcWnd.left + _sizeWnd.cx + _ptw->GetCxDlgFrame());
                _ptw->SetRect(&rcWnd);
                _ptw->SetExcludeCaptionButtonMode(TRUE);
            }
        }
        else
            _ptw->SetExcludeCaptionButtonMode(FALSE);
    }

    MyMoveWnd(dxOffset, dyOffset);

    if (!_ptw)
        goto Exit;

    _ptw->_fIsItemShownInFloatingToolbar = bShowToolbar;
    //
    // We show or hide only when toolbar is floating arround.
    //
    if (IsFocusThread() && _ptw->IsSFShowNormal() && !_ptw->IsInFullScreen())
    {
        // 
        //  Satori Hack.
        // 
        // If the focus thread is running with Satori we don't hide 
        // the toolbar.
        // 
        if (!bShowToolbar && _ptw->IsHKLToSkipRedrawOnNoItem())
        {
            _fSkipRedrawOnNoItem = TRUE;
            goto Exit;
        }


        _ptw->_fShowWindowAtTimer = bShowToolbar;
        _ptw->_pThreadShowWindowAtTimer = this;
        _ptw->_fShowOverItemBalloonAtTimer = fOverScreen;

        _ptw->KillTimer(TIPWND_TIMER_SHOWWINDOW);
        _ptw->SetTimer(TIPWND_TIMER_SHOWWINDOW, g_uTimerElapseSHOWWINDOW);

#if 0
        _ptw->Show(bShowToolbar);

        //
        // If the window was over the screen and hide some items,
        // we show balloon tips.
        //
        if (fOverScreen)
            _ptw->ShowOverScreenSizeBalloon();
#endif
    }
Exit:
    return;
}

//+---------------------------------------------------------------------------
//
// GetSortScore
//
//----------------------------------------------------------------------------

void CTipbarThread::GetSortScore(CItemSortScore *pScore, TF_LANGBARITEMINFO *plbiInfo, CEnumCatCache *penumcache, CGuidDwordCache *pgdcache)
{
    DWORD dwSub = 0;
    DWORD dwCat = 0;
    DWORD dwCatIndex = 256;
    IEnumGUID *pEnum;
    BOOL bFound = FALSE;
    GUID guid;
  
    //
    // check system device type button.
    //
    if (pEnum = penumcache->GetEnumItemsInCategory(GUID_TFCAT_CATEGORY_OF_TIP))
    {
        while (!bFound && (pEnum->Next(1, &guid, NULL) == S_OK))
        {
            dwCatIndex++;

            if (!(dwCat = pgdcache->GetGuidDWORD(guid)))
               dwCat = dwCatIndex;

            if (IsEqualGUID(guid, plbiInfo->guidItem))
                bFound = TRUE;
            else
            {
                IEnumGUID *pEnumTip;
                if (pEnumTip = penumcache->GetEnumItemsInCategory(guid))
                {
                    CLSID clsid;
                    while (!bFound && (pEnumTip->Next(1, &clsid, NULL) == S_OK))
                    {

                        dwSub++;

                        if (IsEqualGUID(clsid, plbiInfo->clsidService))
                        {
                            bFound = TRUE;
                        }
                    }
                }
            }
        }
    }

    if (bFound)
    {
        pScore->Set(dwCat, plbiInfo->ulSort, dwSub);
        return;
    }

    //
    // check system toolbar button.
    //
    if (IsEqualGUID(GUID_NULL, plbiInfo->clsidService))
    {
        pScore->Set(0, plbiInfo->ulSort, 0);
        return;
    }
    else if (IsEqualGUID(CLSID_SYSTEMLANGBARITEM, plbiInfo->clsidService))
    {
        pScore->Set(0, plbiInfo->ulSort, 0);
        return;
    }
    else if (IsEqualGUID(CLSID_SYSTEMLANGBARITEM2, plbiInfo->clsidService))
    {
        pScore->Set((-1), plbiInfo->ulSort, 0);
        return;
    }
    else if (IsEqualGUID(CLSID_SYSTEMLANGBARITEM_KEYBOARD, plbiInfo->clsidService))
    {
        dwCat = pgdcache->GetGuidDWORD(GUID_TFCAT_TIP_KEYBOARD);
        pScore->Set(dwCat, plbiInfo->ulSort, (DWORD)-1);
        return;
    }
    else if (IsEqualGUID(CLSID_SYSTEMLANGBARITEM_SPEECH, plbiInfo->clsidService))
    {
        dwCat = pgdcache->GetGuidDWORD(GUID_TFCAT_TIP_SPEECH);
        pScore->Set(dwCat, plbiInfo->ulSort, (DWORD)-1);
        return;
    }
    else if (IsEqualGUID(CLSID_SYSTEMLANGBARITEM_HANDWRITING, plbiInfo->clsidService))
    {
        dwCat = pgdcache->GetGuidDWORD(GUID_TFCAT_TIP_HANDWRITING);
        pScore->Set(dwCat, plbiInfo->ulSort, (DWORD)-1);
        return;
    }

    pScore->Set((DWORD)-1, (DWORD)-1, (DWORD)-1);
    return;
}

//+---------------------------------------------------------------------------
//
// UpdateItems
//
//----------------------------------------------------------------------------

BOOL CTipbarThread::UpdateItems()
{
    int i;

    _fItemChanged = FALSE;

    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *ptbItem = _rgItem.Get(i);

        if (ptbItem)
            ptbItem->OnUpdate(TF_LBI_STATUS | TF_LBI_BTNALL | TF_LBI_BMPALL | TF_LBI_BALLOON);

    }

    for (i = 0; i < _rgSep.Count(); i++)
    {
        CUIFSeparator *pSep = _rgSep.Get(i);
        if (pSep)
            pSep->CallOnPaint();
    }
    return TRUE;
}


//+---------------------------------------------------------------------------
//
// MyMoveWnd
//
//----------------------------------------------------------------------------

void CTipbarThread::MyMoveWnd(int dxOffset, int dyOffset)
{
    if (!_ptw)
        return;

    if (_ptw->GetFocusThread() != this)
        return;

    POINT pt;
    RECT rc;
    RECT rcWork;

    _ptw->GetRect(&rc);
    pt.x = rc.left;
    pt.y = rc.top;
    CUIGetWorkAreaRect(pt, &rcWork);

    GetWindowRect(_ptw->GetWnd(), &rc);
    int x = rc.left + dxOffset;
    int y = rc.top + dyOffset;

    if (_ptw->IsInExcludeCaptionButtonMode())
    {
        //
        // now we're in exclude caption button mode.
        // adjust position to the next of caption buttons.
        //
        if (_ptw->CheckExcludeCaptionButtonMode(&rc, &rcWork))
        {
            x = (rcWork.right - (_ptw->GetCaptionButtonWidth() * 3)) -
                (_sizeWnd.cx + _ptw->GetCxDlgFrame());
            y = 0;
        }
        else
        {
            _ptw->SetExcludeCaptionButtonMode(FALSE);
        }
    }

    if (!IsVertical())
    {
        _ptw->SetMoveRect(x, y,
                          _sizeWnd.cx + _ptw->GetCxDlgFrame(),
                          _ptw->GetTipbarHeight() + _ptw->GetCyDlgFrame());
    }
    else
    {
        _ptw->SetMoveRect(x, y,
                          _ptw->GetTipbarHeight() + _ptw->GetCxDlgFrame(),
                          _sizeWnd.cy + _ptw->GetCyDlgFrame());
    }

    SIZE sizeWndFrame;
    sizeWndFrame.cx = 0;
    sizeWndFrame.cy = 0;
    if (_ptw->GetWndFrame() != NULL) 
        _ptw->GetWndFrame()->GetFrameSize( &sizeWndFrame );

    _ptw->LocateCtrlButtons();

    //
    // call AutoAdjustDeskBandSize() now.
    // this function adjust the deskband size at first call only.
    //
    _ptw->AutoAdjustDeskBandSize();
}

//+---------------------------------------------------------------------------
//
// AddUIObjs
//
//----------------------------------------------------------------------------

void CTipbarThread::AddUIObjs()
{

    _AddRef();

    int i;
    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *ptbItem = _rgItem.Get(i);
        if (ptbItem && ptbItem->IsVisibleInToolbar())
             ptbItem->AddMeToUI(_ptw);

    }

    AddAllSeparators();
    MyMoveWnd(0, 0);

    _Release();
}

//+---------------------------------------------------------------------------
//
// AddAllSeparators
//
//----------------------------------------------------------------------------

void CTipbarThread::AddAllSeparators()
{
    int i;
    for (i = 0; i < _rgSep.Count(); i++)
    {
        CUIFSeparator *pSep = _rgSep.Get(i);
        if (pSep)
            _ptw->AddUIObj(pSep);
    }
}

//+---------------------------------------------------------------------------
//
// RemoveUIObjs
//
//----------------------------------------------------------------------------

void CTipbarThread::RemoveUIObjs()
{
    int i;
    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *ptbItem = _rgItem.Get(i);
        if (ptbItem)
            ptbItem->RemoveMeToUI(_ptw);
    }
    RemoveAllSeparators();
}

//+---------------------------------------------------------------------------
//
// RemoveAllSeparators
//
//----------------------------------------------------------------------------

void CTipbarThread::RemoveAllSeparators()
{
    int i;
    for (i = 0; i < _rgSep.Count(); i++)
    {
        CUIFSeparator *pSep = _rgSep.Get(i);
        if (pSep)
        {
            if (_ptw)
                _ptw->RemoveUIObj(pSep);

            delete pSep;
        }
    }
    _rgSep.Clear();
}

//+---------------------------------------------------------------------------
//
// GetItem
//
//----------------------------------------------------------------------------

CTipbarItem *CTipbarThread::GetItem(REFGUID guid)
{
    int i;
    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *ptbItem = _rgItem.Get(i);
        if (ptbItem)
        {
            GUID *pguid= ptbItem->GetGUID();
            if (IsEqualGUID(*pguid, guid))
                return ptbItem;
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
// IsDirtyItem
//
//----------------------------------------------------------------------------

DWORD CTipbarThread::IsDirtyItem()
{
    DWORD dwFlags = 0;

    int i;
    for (i = 0; i < _rgItem.Count(); i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (pItem)
            dwFlags |= pItem->GetDirtyUpdateFlags();
    }

    return dwFlags;
}

//+---------------------------------------------------------------------------
//
// CallOnUpdateHandler
//
//----------------------------------------------------------------------------

BOOL CTipbarThread::CallOnUpdateHandler()
{
    int i;
    int nCnt;
    DWORD dwFlags;
    CTipbarItemGuidArray rgGuid;
    DWORD *pdw = NULL;
    BOOL bRet = TRUE;

    //
    // Windows Bug #367869.
    //
    // AddRef now because there is a change for this thread to be removed.
    //
    _AddRef();

#ifdef DEBUG
    _fInCallOnUpdateHandler = TRUE;
#endif

    //
    // we want to use g_pTipbarWnd instead of _ptw. 
    // _ptw could be disconnected during this function. If it is disconnected,
    // we can not decrement the pending counter.
    //
    if (g_pTipbarWnd)
        g_pTipbarWnd->StartPendingUpdateUI();

    //
    // if there is no items, do nothing
    //
    nCnt = _rgItem.Count();
    if (!nCnt)
    {
        goto Exit;
    }

    if (!_plbim)
    {
        if (IsConsole())
        {
            for (i = 0; i < _rgItem.Count(); i++)
            {
                DWORD dwStatus;

                CTipbarItem *pItem = _rgItem.Get(i);

                if (pItem && pItem->GetNotifyUI())
                {
                    dwFlags = pItem->GetDirtyUpdateFlags();
                    if (dwFlags & TF_LBI_STATUS)
                        pItem->GetNotifyUI()->GetStatus(&dwStatus);
                    else
                        dwStatus = 0;

                    pItem->ClearDirtyUpdateFlags();
                    pItem->OnUpdateHandler(dwFlags, dwStatus);
                }
            }
        }
        goto Exit;
    }

    rgGuid.Init(&_rgItem);

    //
    // if there is no dirty flag, do nothig.
    //
    dwFlags = IsDirtyItem();
    if (!dwFlags)
        goto Exit;

    pdw = new DWORD[nCnt];
    if (!pdw)
        goto Exit;

    //
    // Clear the each item OnUpdate() request
    //
    for (i = 0; (i < nCnt) && (i < _rgItem.Count()); i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (!pItem)
            continue;

        pItem->ClearOnUpdateRequest();
    }

    //
    // get items flag at once.
    //
    if (FAILED(_plbim->GetItemsStatus(nCnt, rgGuid.GetPtr(), pdw)))
    {
        TraceMsg(TF_FUNC, "GetItemStatus failed");
        bRet = FALSE;
        goto Exit;
    }

    for (i = 0; (i < nCnt) && (i < _rgItem.Count()); i++)
    {
        CTipbarItem *pItem = _rgItem.Get(i);
        if (!pItem)
            continue;

        //
        // Skip the current item update request if the item has another OnUpdate() Request
        //
        if (pItem->IsNewOnUpdateRequest())
            continue;

        dwFlags = pItem->GetDirtyUpdateFlags();
        if (dwFlags)
        {
            pItem->ClearDirtyUpdateFlags();
            pItem->OnUpdateHandler(dwFlags, pdw[i]);
        }
    }

Exit:
    if (pdw)
        delete[] pdw;

    //
    // we want to use g_pTipbarWnd instead of _ptw. 
    // _ptw could be disconnected during this function. If it is disconnected,
    // we can not decrement the pending counter.
    //
    if (g_pTipbarWnd)
        g_pTipbarWnd->EndPendingUpdateUI();

#ifdef DEBUG
    _fInCallOnUpdateHandler = FALSE;
#endif

    _Release();

    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarItem::CTipbarItem(CTipbarThread *ptt, 
                         ITfLangBarItem *plbi, 
                         TF_LANGBARITEMINFO *plbiInfo, 
                         DWORD dwStatus)
{
    _ptt = ptt;
    _lbiInfo = *plbiInfo;
    _plbi = plbi;
    _plbi->AddRef();
    _fToolTipInit = FALSE;
    _fAddedToUI = FALSE;
    _fDisconnected = FALSE;

    _dwDirtyUpdateFlags = (TF_LBI_STATUS | TF_LBI_BTNALL | TF_LBI_BMPALL | TF_LBI_BALLOON);

    _dwStatus = dwStatus;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarItem::~CTipbarItem()
{
    if (_ptt && _ptt->_ptw && _ptt->_ptw->GetAccessible())
    {
        _ptt->_ptw->GetAccessible()->RemoveAccItem(this);
    }

    SafeRelease(_plbi);
}


//+---------------------------------------------------------------------------
//
// OnSetCursor
//
//----------------------------------------------------------------------------

BOOL CTipbarItem::OnSetCursor(UINT uMsg, POINT pt)
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// GetToolTip
//
//----------------------------------------------------------------------------

LPCWSTR CTipbarItem::GetToolTip()
{
    AddRef();

    if (!_fToolTipInit)
    {
        BSTR bstrTooltip;
        HRESULT hr;

        _fToolTipInit = TRUE;
        if (FAILED(hr =_plbi->GetTooltipString(&bstrTooltip)))
            return NULL;

        if (bstrTooltip)
        {
            SetToolTip(bstrTooltip);
            SysFreeString(bstrTooltip);
        }
    }

    LPCWSTR psz;
    psz = GetToolTipFromUIOBJ();

    Release();
    return psz;
}

//+---------------------------------------------------------------------------
//
// AddedToUI
//
//----------------------------------------------------------------------------

void CTipbarItem::_AddedToUI()
{
    if (!IsConnected())
        return;

    AddRef();

    _fAddedToUI = TRUE;
    if (_dwDirtyUpdateFlags)
    {
        DWORD dwStatus;
 
        if (_dwDirtyUpdateFlags & TF_LBI_STATUS)
            _plbi->GetStatus(&dwStatus);
        else
            dwStatus = 0;
 
        OnUpdateHandler(_dwDirtyUpdateFlags, dwStatus);
        _dwDirtyUpdateFlags = 0;
    }
 
    if (_ptt && _ptt->_ptw && _ptt->_ptw->GetAccessible())
    {
        _ptt->_ptw->GetAccessible()->AddAccItem(this);
    }

    Release();
}

//+---------------------------------------------------------------------------
//
// RemovedToUI
//
//----------------------------------------------------------------------------

void CTipbarItem::_RemovedToUI()
{
    _fAddedToUI = FALSE;
 
    if (_ptt && _ptt->_ptw && _ptt->_ptw->GetAccessible())
    {
        _ptt->_ptw->GetAccessible()->RemoveAccItem(this);
    }
}

//+---------------------------------------------------------------------------
//
// Update
//
//----------------------------------------------------------------------------

HRESULT CTipbarItem::OnUpdate(DWORD dwFlags)
{
    DWORD dwPrevDirtyUpdateFlags = _dwDirtyUpdateFlags;
    if (!IsConnected())
        return S_OK;

    _dwDirtyUpdateFlags |= dwFlags;
    _fNewOnUpdateRequest = TRUE;

    //
    // if this item is not aded to UI or TrayIcon,
    // we don't have to update anything yet.
    // OnUpdate() will be called again 
    // when this item is added to UI or TrayIcon.
    //
    if ((!(dwFlags & TF_LBI_STATUS)) && !_fAddedToUI && !_fAddedToIconTray)
    {
        return S_OK;
    }

    if (_ptt && _ptt->_ptw && _ptt->_ptw->GetWnd())
    {
        _ptt->_ptw->KillTimer(TIPWND_TIMER_ONUPDATECALLED);
        _ptt->_ptw->SetTimer(TIPWND_TIMER_ONUPDATECALLED, g_uTimerElapseONUPDATECALLED);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUpdateHandler
//
//----------------------------------------------------------------------------

HRESULT CTipbarItem::OnUpdateHandler(DWORD dwFlags, DWORD dwStatus)
{
    if (!IsConnected())
        return S_OK;

    BOOL fPrevHidden = TRUE;

    if (IsHiddenStatusControl())
        fPrevHidden = IsInHiddenStatus();

    if (dwFlags & TF_LBI_TOOLTIP)
    {
        _fToolTipInit = FALSE;
    }

    if (dwFlags & TF_LBI_STATUS)
    {
        BOOL fEnabled = (_dwStatus & TF_LBI_STATUS_DISABLED) ? FALSE : TRUE;

        if (!IsHiddenStatusControl())
        {
            // Assert(dwStatus & TF_LBI_STATUS_HIDDEN);
            dwStatus &= ~TF_LBI_STATUS_HIDDEN;
        }

        //
        // MSAA support
        //
        if (_dwStatus != dwStatus)
        {
            if (_ptt && _ptt->_ptw && _ptt->_ptw->GetAccessible())
                _ptt->_ptw->GetAccessible()->NotifyWinEvent( EVENT_OBJECT_STATECHANGE , this);
        }

        _dwStatus = dwStatus;

        if (fEnabled && (_dwStatus & TF_LBI_STATUS_DISABLED))
             Enable(FALSE);
        else if (!fEnabled && !(_dwStatus & TF_LBI_STATUS_DISABLED))
             Enable(TRUE);
    }

    if (IsHiddenStatusControl())
    {
        if (fPrevHidden != IsInHiddenStatus())
            AddRemoveMeToUI(!IsInHiddenStatus() && !IsShownInTrayOnly());
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// AddRemoveMeToUI
//
//----------------------------------------------------------------------------

void CTipbarItem::AddRemoveMeToUI(BOOL fAdd)
{
    if (!IsConnected())
        return;

    _ptt->LocateItems();
    _ptt->AddAllSeparators();
    if (fAdd)
    {
        Assert(IsVisibleInToolbar());
        AddMeToUI(_ptt->_ptw);
    }
    else
    {
        Assert(!IsVisibleInToolbar());
        RemoveMeToUI(_ptt->_ptw);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarButtonItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTipbarButtonItem::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItemSink))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemSink *);
    }
    else if (IsEqualIID(riid, IID_PRIV_BUTTONITEM))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTipbarButtonItem::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTipbarButtonItem::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarButtonItem::CTipbarButtonItem(CTipbarThread *ptt, 
                                     ITfLangBarItem *plbi, 
                                     ITfLangBarItemButton *plbiButton, 
                                     DWORD dwId, 
                                     RECT *prc, 
                                     DWORD dwStyle, 
                                     DWORD dwNuiBtnStyle, 
                                     DWORD dwSBtnShowType, 
                                     TF_LANGBARITEMINFO *plbiInfo,
                                     DWORD dwStatus)
                    : CUIFToolbarButton(ptt->_ptw, 
                                     dwId, 
                                     prc, 
                                     dwStyle, 
                                     dwNuiBtnStyle, 
                                     dwSBtnShowType) , 
                    CTipbarItem(ptt, plbi, plbiInfo, dwStatus)
{
    Dbg_MemSetThisName(TEXT("CTipbarButtonItem"));

    _plbiButton = plbiButton;
    _plbiButton->AddRef();


    if (_dwStatus & TF_LBI_STATUS_DISABLED)
        Enable(FALSE);

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarButtonItem::~CTipbarButtonItem()
{
    UninitUIResource();
    SafeRelease(_plbiButton);
}


//+---------------------------------------------------------------------------
//
// OnUpdateHandler
//
//----------------------------------------------------------------------------

HRESULT CTipbarButtonItem::OnUpdateHandler(DWORD dwFlags, DWORD dwStatus)
{
    BOOL fPrevHidden = TRUE;

    if (!IsConnected())
        return S_OK;

    HRESULT hr = S_OK;
    BOOL fCallPaint = FALSE;
    BOOL fUpdateToggleStatus = FALSE;

    //
    // add ref count to be safe for releasing during marshaling.
    //
    AddRef();

    if (dwFlags & TF_LBI_ICON)
    {
        HICON hIconOld;
        HICON hIcon = GetIcon();

        if (!_ptt || !_ptt->_ptw)
            goto Exit;

        if (hIconOld = GetIconFromUIObj())
            DestroyIcon(hIconOld);


        if (hIcon)
        {
            HICON hSmIcon = NULL;
            int cxSmIcon;
            int cySmIcon;

#ifdef SCALE_ICON
            cxSmIcon = GetSystemMetrics( SM_CXSMICON );
            cySmIcon = GetSystemMetrics( SM_CYSMICON );
#else
            cxSmIcon = 16;
            cySmIcon = 16;
#endif

            if (IsTextColorIcon())
            {
                COLORREF rgbText = GetSysColor(COLOR_BTNTEXT);
                if (_ptt && 
                    _ptt->_ptw && 
                    SUCCEEDED(_pBtn->EnsureThemeData(_ptt->_ptw->GetWnd())))
                {
                    COLORREF col;
                    if (SUCCEEDED(_pBtn->GetThemeColor(TS_NORMAL, TMT_TEXTCOLOR, &col)))
                        rgbText = col;
                }

                CMaskBitmap maskbmp;
                maskbmp.Init(hIcon, 16,16, rgbText);

                ICONINFO ii;
                ii.fIcon = TRUE;
                ii.xHotspot = 0;
                ii.yHotspot = 0;
                ii.hbmMask = maskbmp.GetBmpMask();
                ii.hbmColor = maskbmp.GetBmp();
                hSmIcon = CreateIconIndirect(&ii);

            }
            else
            {
#ifdef SCALE_ICON
                hSmIcon = StretchIcon(hIcon, cxSmIcon, cySmIcon);
#else
                hSmIcon = (HICON)CopyImage(hIcon, 
                                           IMAGE_ICON, 
                                           cxSmIcon, cySmIcon,
                                           LR_COPYFROMRESOURCE);
#endif
            }

            SetIcon(hSmIcon ? hSmIcon : hIcon);

            if (!IsHiddenStatusControl() && IsVisibleInToolbar())
                StartDemotingTimer(FALSE);

            if (hSmIcon)
                DestroyIcon(hIcon);
        }
        else
            SetIcon((HICON)NULL);

        fCallPaint = TRUE;
    }

    if ((dwFlags & TF_LBI_TEXT) && 
        _ptt && 
        _ptt->_ptw && 
        _ptt->_ptw->IsShowText())
    {
        BSTR bstr;
        hr =  _plbiButton->GetText(&bstr);

        if (FAILED(hr))
            goto Exit;
        
        if (_ptt && bstr && (!GetText() || wcscmp(GetText(), bstr)))
        {
            SIZE size;
            _ptt->GetTextSize(bstr, &size);

            SetText(SysStringLen(bstr) ? bstr : NULL);


            if (_sizeText.cx != size.cx)
            {
                _dwWidth += (size.cx - _sizeText.cx);
                _ptt->LocateItems();
            }

            _sizeText = size;
            fCallPaint = TRUE;
        }

        if (bstr)
            SysFreeString(bstr);
    }

    if (IsHiddenStatusControl())
        fPrevHidden = IsInHiddenStatus();

    CTipbarItem::OnUpdateHandler(dwFlags, dwStatus);

    if (_pBtn->GetToggleState() != IsToggled())
    {
       _pBtn->SetToggleState(IsToggled());
       fUpdateToggleStatus = TRUE;
    }

    if ((dwFlags & (TF_LBI_ICON | TF_LBI_TOOLTIP)) || 
        fUpdateToggleStatus ||
        (fPrevHidden != IsInHiddenStatus()))
    {
        // we need to call Thread's MoveToTray too keep the order of Icons.
        // _ptt->_ptw->MoveToTray();
        if (_ptt && _ptt->_ptw && _ptt->_ptw->IsShowTrayIcon())
        {
            _ptt->_ptw->KillTimer(TIPWND_TIMER_MOVETOTRAY);
            _ptt->_ptw->SetTimer(TIPWND_TIMER_MOVETOTRAY, g_uTimerElapseMOVETOTRAY);
        }
    }

    if (fCallPaint)
        CallOnPaint();

Exit:
    Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// OnRightClick
//
//----------------------------------------------------------------------------

void CTipbarButtonItem::OnRightClick()
{
    if (_plbiButton)
    {
        HRESULT hr;
        POINT pt;
        RECT rc;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiButton);

        if (pac)
        {
            hr = pac->OnClick(TF_LBI_CLK_RIGHT, pt, &rc);
            pac->_Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }


        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);

            return;
        }
    }
}

//+---------------------------------------------------------------------------
//
// OnLeftClick
//
//----------------------------------------------------------------------------

void CTipbarButtonItem::OnLeftClick()
{
    if (_plbiButton)
    {
        HRESULT hr;
        POINT pt;
        RECT rc;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiButton);

        if (pac)
        {
            hr = pac->OnClick(TF_LBI_CLK_LEFT, pt, &rc);
            pac->_Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }


        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
               _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            return;
        }

        if (!IsHiddenStatusControl() && IsVisibleInToolbar())
            StartDemotingTimer(TRUE);
    }
}

//+---------------------------------------------------------------------------
//
// OnShowMenu
//
//----------------------------------------------------------------------------

void CTipbarButtonItem::OnShowMenu()
{
    if (!_ptt)
        return;

    if (!_ptt->_ptw)
        return;

    if (_plbiButton)
    {
        POINT pt;
        RECT rc;
        GetRect(&rc);
        pt.x = rc.left;
        pt.y = rc.bottom;
        MyClientToScreen(&pt, &rc);

        DoModalMenu(&pt, &rc);
    }
}

//+---------------------------------------------------------------------------
//
// DoModalMenu
//
//----------------------------------------------------------------------------

void CTipbarButtonItem::DoModalMenu(POINT *ppt, RECT *prc)
{
    HRESULT hr;
    UINT uId;
    DWORD dwThreadId;
    CTipbarWnd *ptw;

    if (!_ptt)
        return;

    if (!_ptt->_ptw)
        return;

    CUTBLBarMenu *pMenu = new CUTBLBarMenu(g_hInst);
    if (!pMenu)
        return;

    AddRef();

    hr = _plbiButton->InitMenu(pMenu);
    if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
    {
        if (_ptt && _ptt->_ptw)
            _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
        goto Exit;
    }
    if (FAILED(hr))
        goto Exit;

    ptw = _ptt->_ptw;
    dwThreadId = _ptt->_dwThreadId;
    Assert(!_ptt->_ptw->_pttModal);
    ptw->_pttModal = _ptt;
    ptw->StartModalInput(ptw, dwThreadId);

    Assert(!ptw->_pModalMenu);
    ptw->_pModalMenu = pMenu;
    uId = pMenu->ShowPopup(ptw, *ppt, prc);

    ptw->_pModalMenu = NULL;

    ptw->StopModalInput(dwThreadId);
    ptw->_pttModal = NULL;

    if (IsConnected() && (uId != CUI_MENU_UNSELECTED))
    {
        CAsyncCall *pac = new CAsyncCall(_plbiButton);
        if (pac)
        {
            hr = pac->OnMenuSelect(uId);
            pac->_Release();
        }

        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            goto Exit;
        }

        if (FAILED(hr))
            goto Exit;
    }

Exit:
    pMenu->Release();
    Release();
}


//+---------------------------------------------------------------------------
//
// MoveToTray
//
//----------------------------------------------------------------------------

void CTipbarButtonItem::MoveToTray()
{
    if (!g_pTrayIconWnd)
        return;

    if (IsVisibleInToolbar() && (IsShownInTray() || IsShownInTrayOnly()))
    {
        HICON hIcon = GetIcon();
        if (hIcon)
        {
            SIZE size;
            if (IsToggled() && CUIGetIconSize(hIcon, &size))
            {
                COLORREF cr;
                RECT rc;
                CBitmapDC hdcSrc(TRUE);
                CBitmapDC hdcMask(TRUE);

#if 0
                CUIFScheme *pscheme = _ptt->_ptw->GetUIFScheme();
                if (!pscheme)
                   cr = GetSysColor(COLOR_HIGHLIGHT);
                else
                   cr = pscheme->GetColor(UIFCOLOR_MOUSEDOWNBKGND);
#else
                   cr = GetSysColor(COLOR_HIGHLIGHT);
#endif

                CSolidBrush hbrBk(cr);
                hdcSrc.SetDIB(size.cx, size.cy);
                hdcMask.SetBitmap(size.cx, size.cy, 1, 1);
                rc.left = 0;
                rc.top = 0;
                rc.right  = size.cx;
                rc.bottom = size.cy;
                FillRect(hdcSrc, &rc, (HBRUSH)hbrBk);
                DrawIconEx(hdcSrc, 0, 0, hIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
                FillRect(hdcMask, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH));
                ICONINFO ii;
                ii.fIcon = TRUE;
                ii.xHotspot = 0;
                ii.yHotspot = 0;
                ii.hbmMask = hdcMask.GetBitmap();
                ii.hbmColor = hdcSrc.GetBitmap();
                DestroyIcon(hIcon);
                hIcon = CreateIconIndirect(&ii);
            }
            
            if (hIcon)
            {
                g_pTrayIconWnd->SetIcon(*GetGUID(), IsMenuBtn(), hIcon, GetToolTip());
                DestroyIcon(hIcon);
            }
        }
         
    }
    else
    {
        g_pTrayIconWnd->SetIcon(*GetGUID(), IsMenuBtn(), NULL, NULL);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarBitmapButtonItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTipbarBitmapButtonItem::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItemSink))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemSink *);
    }
    else if (IsEqualIID(riid, IID_PRIV_BITMAPBUTTONITEM))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTipbarBitmapButtonItem::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTipbarBitmapButtonItem::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarBitmapButtonItem::CTipbarBitmapButtonItem(CTipbarThread *ptt, 
                                     ITfLangBarItem *plbi, 
                                     ITfLangBarItemBitmapButton *plbiBitmapButton, 
                                     DWORD dwId, 
                                     RECT *prc, 
                                     DWORD dwStyle, 
                                     DWORD dwNuiBtnStyle, 
                                     DWORD dwSBtnShowType, 
                                     TF_LANGBARITEMINFO *plbiInfo,
                                     DWORD dwStatus)
                    : CUIFToolbarButton(ptt->_ptw, 
                                     dwId, 
                                     prc, 
                                     dwStyle, 
                                     dwNuiBtnStyle, 
                                     dwSBtnShowType) , 
                    CTipbarItem(ptt, plbi, plbiInfo, dwStatus)
{
    Dbg_MemSetThisName(TEXT("CTipbarBitmapButtonItem"));

    _plbiBitmapButton = plbiBitmapButton;
    _plbiBitmapButton->AddRef();

    if (_dwStatus & TF_LBI_STATUS_DISABLED)
        Enable(FALSE);

    _cRef = 1;

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarBitmapButtonItem::~CTipbarBitmapButtonItem()
{
    HBITMAP hbmpOld;
    HBITMAP hbmpMaskOld;

    hbmpOld = GetBitmap();
    hbmpMaskOld = GetBitmapMask();
    if (hbmpOld)
        DeleteObject(hbmpOld);
    if (hbmpMaskOld)
        DeleteObject(hbmpMaskOld);
    SetBitmap((HBITMAP)NULL);
    SetBitmapMask((HBITMAP)NULL);

    SafeRelease(_plbiBitmapButton);
}

//+---------------------------------------------------------------------------
//
// Update
//
//----------------------------------------------------------------------------

HRESULT CTipbarBitmapButtonItem::OnUpdateHandler(DWORD dwFlags, DWORD dwStatus)
{
    if (!IsConnected())
        return S_OK;

    HRESULT hr = S_OK;
    BOOL fCallPaint = FALSE;

    //
    // add ref count to be safe for releasing during marshaling.
    //
    AddRef();

    if (dwFlags & TF_LBI_BITMAP)
    {
        if (!_GetBitmapFromNUI())
        {
            hr = E_FAIL;
            goto Exit;
        }
        
        if (!IsHiddenStatusControl() && IsVisibleInToolbar())
            StartDemotingTimer(FALSE);

        fCallPaint = TRUE;
    }

    if ((dwFlags & TF_LBI_TEXT) && 
        _ptt &&
        _ptt->_ptw &&
        _ptt->_ptw->IsShowText())
    {
        BSTR bstr;
        hr = _plbiBitmapButton->GetText(&bstr);

        if (FAILED(hr))
            goto Exit;
        
        if (bstr && (!GetText() || wcscmp(GetText(), bstr)))
        {
            SIZE size;
            _ptt->GetTextSize(bstr, &size);

            SetText(SysStringLen(bstr) ? bstr : NULL);


            if (_sizeText.cx != size.cx)
            {
                _dwWidth += (size.cx - _sizeText.cx);
                _ptt->LocateItems();
            }

            _sizeText = size;
            fCallPaint = TRUE;
        }

        if (bstr)
            SysFreeString(bstr);
    }

    CTipbarItem::OnUpdateHandler(dwFlags, dwStatus);

    if (_pBtn->GetToggleState() != IsToggled())
    {
       _pBtn->SetToggleState(IsToggled());
    }

    if (fCallPaint)
        CallOnPaint();

Exit:
    Release();
    return hr;
}


//+---------------------------------------------------------------------------
//
// _GetBitmapFromNUI
//
//----------------------------------------------------------------------------

BOOL CTipbarBitmapButtonItem::_GetBitmapFromNUI()
{
    BOOL bRet = FALSE;
    HBITMAP hbmp;
    HBITMAP hbmpMask;
    HBITMAP hbmpOld;
    HBITMAP hbmpMaskOld;
    int x, y;

    hbmpOld = GetBitmap();
    if (hbmpOld)
        DeleteObject(hbmpOld);
    hbmpMaskOld = GetBitmapMask();
    if (hbmpMaskOld)
        DeleteObject(hbmpMaskOld);
    SetBitmap((HBITMAP)NULL);
    SetBitmapMask((HBITMAP)NULL);

    x = GetRectRef().right - GetRectRef().left;
    y = GetRectRef().bottom - GetRectRef().top;
    if (_ptt->_ptw->IsShowText())
        y -= 12;

    HRESULT hr = _plbiBitmapButton->DrawBitmap(x, y, 0, &hbmp, &hbmpMask);

    if (SUCCEEDED(hr))
    {
        SetBitmap(hbmp);
        SetBitmapMask(hbmpMask);
        bRet = TRUE;
    }

    return bRet;
}



//+---------------------------------------------------------------------------
//
// OnRightClick
//
//----------------------------------------------------------------------------

void CTipbarBitmapButtonItem::OnRightClick()
{
    if (_plbiBitmapButton)
    {
        HRESULT hr;
        POINT pt;
        RECT rc;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiBitmapButton);

        if (pac)
        {
            hr = pac->OnClick(TF_LBI_CLK_RIGHT, pt, &rc);
            pac->_Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            return;
        }
    }
}

//+---------------------------------------------------------------------------
//
// OnLeftClick
//
//----------------------------------------------------------------------------

void CTipbarBitmapButtonItem::OnLeftClick()
{
    if (_plbiBitmapButton)
    {
        HRESULT hr;
        POINT pt;
        RECT rc;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiBitmapButton);

        if (pac)
        {
            hr = pac->OnClick(TF_LBI_CLK_LEFT, pt, &rc);
            pac->_Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            return;
        }

        if (!IsHiddenStatusControl() && IsVisibleInToolbar())
            StartDemotingTimer(TRUE);
    }
}

//+---------------------------------------------------------------------------
//
// OnShowMenu
//
//----------------------------------------------------------------------------

void CTipbarBitmapButtonItem::OnShowMenu()
{
    if (!_ptt)
        return;

    if (!_ptt->_ptw)
        return;

    if (_plbiBitmapButton)
    {
        POINT pt;
        RECT rc;
        GetRect(&rc);
        pt.x = rc.left;
        pt.y = rc.bottom;
        MyClientToScreen(&pt, &rc);
        HRESULT hr;
        UINT uId;
        DWORD dwThreadId;
        CTipbarWnd *ptw;

        CUTBLBarMenu *pMenu = new CUTBLBarMenu(g_hInst);
        if (!pMenu)
            return;

        hr = _plbiBitmapButton->InitMenu(pMenu);
        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            goto Exit;
        }
        if (FAILED(hr))
            goto Exit;

        ptw = _ptt->_ptw;
        dwThreadId = _ptt->_dwThreadId;

        Assert(!ptw->_pttModal);
        ptw->_pttModal = _ptt;
        ptw->StartModalInput(ptw, dwThreadId);

        Assert(!ptw->_pModalMenu);
        ptw->_pModalMenu = pMenu;
        uId = pMenu->ShowPopup(ptw, pt, &rc);
        ptw->_pModalMenu = NULL;

        ptw->StopModalInput(dwThreadId);
        ptw->_pttModal = NULL;

        if (IsConnected() && (uId != CUI_MENU_UNSELECTED))
        {
            Assert(_ptt);
            CAsyncCall *pac = new CAsyncCall(_plbiBitmapButton);
            if (pac)
            {
                hr = pac->OnMenuSelect(uId);
                pac->_Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
            {
                ptw->OnThreadTerminate(dwThreadId);
                goto Exit;
            }
            if (FAILED(hr))
                goto Exit;
        }

Exit:
        pMenu->Release();
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarBitmapItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTipbarBitmapItem::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItemSink))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemSink *);
    }
    else if (IsEqualIID(riid, IID_PRIV_BITMAPITEM))
    {
        *ppvObj = this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTipbarBitmapItem::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CTipbarBitmapItem::Release()
{
    _cRef--;
    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
        return 0;
    }

    return _cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarBitmapItem::CTipbarBitmapItem(CTipbarThread *ptt, 
                                     ITfLangBarItem *plbi,
                                     ITfLangBarItemBitmap *plbiBitmap, 
                                     DWORD dwId, 
                                     RECT *prc, 
                                     DWORD dwStyle, 
                                     TF_LANGBARITEMINFO *plbiInfo,
                                     DWORD dwStatus)
                   : CUIFObject(ptt->_ptw, 
                                dwId, 
                                prc, 
                                dwStyle) , 
                     CTipbarItem(ptt, plbi, plbiInfo, dwStatus)
{
    Dbg_MemSetThisName(TEXT("CTipbarBitmapItem"));

    _plbiBitmap = plbiBitmap;
    _plbiBitmap->AddRef();

    if (_dwStatus & TF_LBI_STATUS_DISABLED)
        Enable(FALSE);

    _cRef = 1;

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTipbarBitmapItem::~CTipbarBitmapItem()
{
    if (_hbmp)
        DeleteObject(_hbmp);
    SafeRelease(_plbiBitmap);
}

//+---------------------------------------------------------------------------
//
// Update
//
//----------------------------------------------------------------------------

HRESULT CTipbarBitmapItem::OnUpdateHandler(DWORD dwFlags, DWORD dwStatus)
{
    if (!IsConnected())
        return S_OK;

    HRESULT hr = S_OK;
    BOOL fCallPaint = FALSE;

    //
    // add ref count to be safe for releasing during marshaling.
    //
    AddRef();


    if (dwFlags & TF_LBI_BITMAP)
    {
        if (!_GetBitmapFromNUI())
        {
            hr = E_FAIL;
            goto Exit;
        }
        
        fCallPaint = TRUE;
    }

    CTipbarItem::OnUpdateHandler(dwFlags, dwStatus);

    if (fCallPaint)
        CallOnPaint();

Exit:
    Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// _GetBitmapFromNUI
//
//----------------------------------------------------------------------------

BOOL CTipbarBitmapItem::_GetBitmapFromNUI()
{
    BOOL bRet = TRUE;
    HBITMAP hbmp = NULL;
    HBITMAP hbmpMask = NULL;
    int x = GetRectRef().right - GetRectRef().left;
    int y = GetRectRef().bottom - GetRectRef().top;

    HRESULT hr = _plbiBitmap->DrawBitmap(x, y, 0, &hbmp, &hbmpMask);

    if (FAILED(hr))
    {
        if (_hbmp)
           DeleteObject(_hbmp);
        _hbmp = NULL;
        bRet = FALSE;
    }

    if (!hbmpMask)
    {
        if (_hbmp)
           DeleteObject(_hbmp);
        _hbmp = hbmp;
    }
    else
    {
        CUIFScheme *pScheme = GetUIFScheme();

        if (_hbmp)
           DeleteObject(_hbmp);

        _hbmp = CreateMaskBmp(&GetRectRef(), hbmp, hbmpMask,
                              pScheme->GetBrush(UIFCOLOR_CTRLBKGND), 0, 0);
    }

    if (hbmp)
        DeleteObject(hbmp);
    if (hbmpMask)
        DeleteObject(hbmpMask);

    return bRet;
}

//+---------------------------------------------------------------------------
//
// OnPaint
//
//----------------------------------------------------------------------------

void CTipbarBitmapItem::OnPaint( HDC hdc )
{
    CBitmapDC hdcMem(TRUE);
    hdcMem.SetBitmap(_hbmp);

    BitBlt(hdc, 
           GetRectRef().left, 
           GetRectRef().top, 
           GetRectRef().right - GetRectRef().left,
           GetRectRef().bottom - GetRectRef().top, 
           hdcMem, 
           0, 
           0, 
           SRCCOPY);

}

//+---------------------------------------------------------------------------
//
// SetRect
//
//----------------------------------------------------------------------------

void CTipbarBitmapItem::SetRect( const RECT *prc ) 
{

    if (((GetRectRef().bottom - GetRectRef().top) != (prc->bottom - prc->top)) ||
        ((GetRectRef().right - GetRectRef().left) != (prc->right - prc->left)))
    {
        if (_hbmp)
            DeleteObject(_hbmp);
        _hbmp = NULL;
    }

    CUIFObject::SetRect(prc);
}

//+---------------------------------------------------------------------------
//
// OnRightClick
//
//----------------------------------------------------------------------------

void CTipbarBitmapItem::OnRightClick()
{
    if (_plbiBitmap)
    {
        POINT pt;
        RECT rc;
        HRESULT hr;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiBitmap);
        if (!pac)
            return;

        hr = pac->OnClick(TF_LBI_CLK_RIGHT, pt, &rc);
        pac->_Release();

        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            return;
        }
    }
}

//+---------------------------------------------------------------------------
//
// OnLeftClick
//
//----------------------------------------------------------------------------

void CTipbarBitmapItem::OnLeftClick()
{
    if (_plbiBitmap)
    {
        HRESULT hr;
        POINT pt;
        RECT rc;
        GetCursorPos(&pt);
        GetRect(&rc);
        MyClientToScreen(&rc);

        CAsyncCall *pac = new CAsyncCall(_plbiBitmap);

        if (pac)
        {
            hr = pac->OnClick(TF_LBI_CLK_LEFT, pt, &rc);
            pac->_Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }


        if (RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr))
        {
            if (_ptt && _ptt->_ptw)
                _ptt->_ptw->OnThreadTerminate(_ptt->_dwThreadId);
            return;
        }

        if (!IsHiddenStatusControl() && IsVisibleInToolbar())
            StartDemotingTimer(TRUE);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarCtrlButtonHolder
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarCtrlButtonHolder::CTipbarCtrlButtonHolder()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
//+---------------------------------------------------------------------------

void CTipbarCtrlButtonHolder::Init(CTipbarWnd *ptw)
{
    int i;
    RECT rc;
    ::SetRect(&rc, 0, 0, 0, 0);

    if (ptw->IsInDeskBand())
        _pcbCtrlBtn = g_cbCtrlBtnDeskBand;
    else
        _pcbCtrlBtn = g_cbCtrlBtn;

    for (i = 0; i < NUM_CTRLBUTTONS; i++)
    {
        Assert(!_rgpCtrlBtn[i]);

        _rgpCtrlBtn[i] = new CTipbarCtrlButton(ptw, 
                                               _pcbCtrlBtn[i].dwId, 
                                               &rc,
                                               _pcbCtrlBtn[i].dwStyle);
        _rgpCtrlBtn[i]->Initialize();

        ptw->AddUIObj(_rgpCtrlBtn[i]);

        if (_pcbCtrlBtn[i].dwFlags & CTRL_USEMARLETT)
            _rgpCtrlBtn[i]->SetFont(ptw->GetMarlett());
 
        if (_pcbCtrlBtn[i].dwFlags & CTRL_ICONFROMRES)
        {
            if (_pcbCtrlBtn[i].dwId == ID_CBTN_CAPSKEY)
            {
                _rgpCtrlBtn[i]->SetVKey(VK_CAPITAL);
            }
            else
            {
                _rgpCtrlBtn[i]->SetVKey(VK_KANA);
            }
            _rgpCtrlBtn[i]->SetToggleStateByVKey();
        }
        else
            _rgpCtrlBtn[i]->SetText(_pcbCtrlBtn[i].wsz);

    }
}

//+---------------------------------------------------------------------------
//
// EnableBtns
//
//+---------------------------------------------------------------------------

void CTipbarCtrlButtonHolder::EnableBtns()
{
    int i;
    for (i = 0; i < NUM_CTRLBUTTONS; i++)
    {
        if (_pcbCtrlBtn[i].dwFlags & CTRL_DISABLEONWINLOGON)
        {
            if (g_bWinLogon || (g_pTipbarWnd && g_pTipbarWnd->IsSFMinmized()))
                _rgpCtrlBtn[i]->Enable(FALSE);
            else
                _rgpCtrlBtn[i]->Enable(TRUE);
        }
    }
}

//+---------------------------------------------------------------------------
//
// UpdateBitmap
//
//+---------------------------------------------------------------------------

void CTipbarCtrlButtonHolder::UpdateBitmap(CTipbarWnd *ptw)
{
    int i;

    for (i = 0; i < NUM_CTRLBUTTONS; i++)
    {
        if (_pcbCtrlBtn[i].dwFlags & CTRL_ICONFROMRES)
        {
            HBITMAP hbmp;
            HBITMAP hbmpMask;
            COLORREF rgbText = GetSysColor(COLOR_BTNTEXT);
            if (SUCCEEDED(_rgpCtrlBtn[i]->EnsureThemeData(ptw->GetWnd())))
            {
                COLORREF col;
                if (SUCCEEDED(_rgpCtrlBtn[i]->GetThemeColor(TS_NORMAL, TMT_TEXTCOLOR, &col)))
                    rgbText = col;
            }

            if (_pcbCtrlBtn[i].dwId == ID_CBTN_CAPSKEY)
            {
                if (!ptw->IsVertical())
                    _maskbmpCap.Init(ID_BITMAP_CAPS , 
                                     KANACAPSBMP_WIDTH,  
                                     KANACAPSBMP_HEIGHT, 
                                     rgbText);
                else
                    _maskbmpCap.Init(ID_BITMAP_CAPSV,  
                                     KANACAPSBMP_HEIGHT, 
                                     KANACAPSBMP_WIDTH, 
                                     rgbText);

                hbmp = _maskbmpCap.GetBmp();
                hbmpMask = _maskbmpCap.GetBmpMask();
            }
            else
            {
                if (!ptw->IsVertical())
                    _maskbmpKana.Init(ID_BITMAP_KANA , 
                                      KANACAPSBMP_WIDTH,  
                                      KANACAPSBMP_HEIGHT, 
                                      rgbText);
                else
                    _maskbmpKana.Init(ID_BITMAP_KANAV,  
                                      KANACAPSBMP_HEIGHT, 
                                      KANACAPSBMP_WIDTH, 
                                      rgbText);

                hbmp = _maskbmpKana.GetBmp();
                hbmpMask = _maskbmpKana.GetBmpMask();
            }

            _rgpCtrlBtn[i]->SetBitmap(hbmp);
            _rgpCtrlBtn[i]->SetBitmapMask(hbmpMask);
        }
    }
}
 
//+---------------------------------------------------------------------------
//
// Locate
//
//+---------------------------------------------------------------------------

void CTipbarCtrlButtonHolder::Locate(CTipbarWnd *ptw, int x, int y, int nHeight, DWORD dwFlags, BOOL fVertical)
{
    int i;
    int nCtrlItemHeight = (nHeight - ptw->GetCtrlItemHeightMargin() * 2) / 2;
    c_nColumnStart[0] = 0;
    c_nColumnStart[1] = CX_COLUMN0  +
                        ptw->GetThemeMargins()->cxLeftWidth +
                        ptw->GetThemeMargins()->cxRightWidth;
    c_nColumnStart[2] = CX_COLUMN1  +
                        ptw->GetThemeMargins()->cxLeftWidth +
                        ptw->GetThemeMargins()->cxRightWidth;

    for (i = 0; i < NUM_CTRLBUTTONS; i++)
    {
        RECT rc;
        int nColumn = _pcbCtrlBtn[i].nColumn;
        int nRow = _pcbCtrlBtn[i].nRow;

        if (dwFlags & TCBH_NOCOLUMN)
        {
            rc.left = 0;
            rc.top = 0;
            rc.right = 0;
            rc.bottom = 0;
            _rgpCtrlBtn[i]->SetRect(&rc);
            continue;
        }
        
        if (dwFlags & TCBH_NOCOLUMN0)
        {
            if (!_pcbCtrlBtn[i].nColumn)
            {
                rc.left = 0;
                rc.top = 0;
                rc.right = 0;
                rc.bottom = 0;
                _rgpCtrlBtn[i]->SetRect(&rc);
                continue;
            }
 
            nColumn--;
        }
 
        if (!fVertical)
        {
            rc.left = x + c_nColumnStart[nColumn];
            rc.top = ptw->GetCtrlItemHeightMargin() + y + nRow * nCtrlItemHeight;
            rc.right = rc.left + c_nColumnStart[_pcbCtrlBtn[i].nColumn + 1];
            rc.bottom = rc.top + nCtrlItemHeight;
        }
        else
        {
            //
            // swap Row when this is the vertical langbar.
            //
            rc.left = ptw->GetCtrlItemHeightMargin() + x + (1 - nRow) * nCtrlItemHeight;
            rc.top = y + c_nColumnStart[nColumn];
            rc.right = rc.left + nCtrlItemHeight;
            rc.bottom = rc.top + c_nColumnStart[_pcbCtrlBtn[i].nColumn + 1];
        }
 
        _rgpCtrlBtn[i]->SetRect(&rc);

    }
}

//+---------------------------------------------------------------------------
//
// GetWidth
//
//+---------------------------------------------------------------------------

int CTipbarCtrlButtonHolder::GetWidth(DWORD dwFlags)
{
    if (dwFlags & TCBH_NOCOLUMN)
        return 0;

    int nWidth = 0;

    if (!(dwFlags & TCBH_NOCOLUMN0))
        nWidth += c_nColumnStart[1];

    nWidth += c_nColumnStart[2];
    return nWidth;
}

//+---------------------------------------------------------------------------
//
// UpdateCapsKanaState
//
//+---------------------------------------------------------------------------

void CTipbarCtrlButtonHolder::UpdateCapsKanaState(LPARAM lParam)
{
    int i;
    for (i = 0; i < NUM_CTRLBUTTONS; i++)
    {
        if (_rgpCtrlBtn[i]->GetVKey())
        {
            if (_rgpCtrlBtn[i]->GetVKey() == VK_CAPITAL)
                _rgpCtrlBtn[i]->SetToggleState((lParam & TF_LBUF_CAPS) ? TRUE: FALSE);
            else if (_rgpCtrlBtn[i]->GetVKey() == VK_KANA)
                _rgpCtrlBtn[i]->SetToggleState((lParam & TF_LBUF_KANA) ? TRUE: FALSE);
        }
    }
}

//+---------------------------------------------------------------------------
//
// GetCtrlBtn
//
//+---------------------------------------------------------------------------

CTipbarCtrlButton *CTipbarCtrlButtonHolder::GetCtrlBtn(DWORD dwId)
{
    int i;
    for (i = 0; i < NUM_CTRLBUTTONS; i++)
    {
        if (_rgpCtrlBtn[i]->GetID() == dwId)
            return _rgpCtrlBtn[i];
    }

    return NULL;
}
//////////////////////////////////////////////////////////////////////////////
//
// CTipbarCtrlButton
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTipbarCtrlButton::CTipbarCtrlButton(CTipbarWnd *ptw, 
                                     DWORD dwId, 
                                     const RECT *prc,
                                     DWORD dwStyle) 
                  : CUIFButton2(ptw, 
                                dwId, 
                                prc, 
                                dwStyle)
{
    _ptw = ptw;
    _fInMenu = FALSE;
    SetToolTip(CRStr(IDS_CONTROLBUTTONTOOLTIP + dwId));
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

void CTipbarCtrlButton::OnLButtonUp(POINT pt)
{
    CUIFButton2::OnLButtonUp(pt);
    CUTBMinimizeLangBarDlg *pMinimizeDlg;

    switch (GetID())
    {
        case ID_CBTN_MINIMIZE:
            //
            // Use Deskband object instead of system tray icon on NT51
            //
            if (IsOnNT51())
            {
                if (!_ptw->IsSFDeskband())
                {
                    _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_DESKBAND);

                    if (pMinimizeDlg = new CUTBMinimizeLangBarDlg)
                    {
                        pMinimizeDlg->DoModal(_ptw->GetWnd());
                        pMinimizeDlg->_Release();
                    }
                }
                break;
            }
            else
            {
                _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_MINIMIZED);

                if (pMinimizeDlg = new CUTBMinimizeLangBarDlg)
                {
                    pMinimizeDlg->DoModal(_ptw->GetWnd());
                    pMinimizeDlg->_Release();
                }
                break;
            }

        case ID_CBTN_RESTORE:
            //
            // Use Deskband object instead of system tray icon on NT51
            //
            Assert(IsOnNT51());
            if (_ptw->IsSFDeskband())
            {
                _ptw->GetLangBarMgr()->ShowFloating(TF_SFT_SHOWNORMAL);
            }
            break;

        case ID_CBTN_EXTMENU:
            ShowExtendMenu(pt);
            break;

        case ID_CBTN_KANAKEY:
            keybd_event(VK_KANA, 0, 0, 0);
            keybd_event(VK_KANA, 0, KEYEVENTF_KEYUP, 0);
            break;

        case ID_CBTN_CAPSKEY:
            keybd_event(VK_CAPITAL, 0, 0, 0);
            keybd_event(VK_CAPITAL, 0, KEYEVENTF_KEYUP, 0);
            break;
    }

}

//+---------------------------------------------------------------------------
//
// ShowExtendMenu
//
//----------------------------------------------------------------------------

void CTipbarCtrlButton::ShowExtendMenu(POINT pt)
{
    CUTBIntelliMenu *pMenu;
    RECT rc;
    GetRect(&rc);
    MyClientToScreen(&pt, &rc);
    DWORD dwThreadId;
    UINT uId = CUI_MENU_UNSELECTED;

    if (!_ptw)
        return;

    if (!_ptw->GetFocusThread())
        return;

    dwThreadId = _ptw->GetFocusThread()->_dwThreadId;

    pMenu = new CUTBIntelliMenu(_ptw);
    if (!pMenu)
        return;

    if (!pMenu->Init())
        goto Exit;

    _ptw->_pttModal = _ptw->GetFocusThread();

    _ptw->StartModalInput(_ptw, dwThreadId);

    _ptw->_pModalMenu = pMenu;

    uId = pMenu->ShowPopup(_ptw, pt, &rc);

    _ptw->_pModalMenu = NULL;

    _ptw->StopModalInput(dwThreadId);
    _ptw->_pttModal = NULL;

    if (uId != CUI_MENU_UNSELECTED)
    {
        pMenu->SelectMenuItem(uId);
    }

Exit:
    delete pMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\tipbar.h ===
//
// tipbar.h
//

#ifndef _TIPBAR_H_
#define _TIPBAR_H_

#include "private.h"
#include "cuitb.h"
#include "cuiwnd.h"
#include "ptrary.h"
#include "utbmenu.h"
#include "slbarid.h"
#include "itemlist.h"
#include "maskbmp.h"
#include "tlapi.h"
#include "cuibln.h"
#include "msutbapi.h"
#include "utbacc.h"
#include "resource.h"
#include "shellwnd.h"

//
// from uim\nuictrl.cpp
//
HRESULT WINAPI TF_RunInputCPL();


#define STATUSWND_WIDTH 100
#define STATUSWND_HEIGHT 24
#define STATUSWND_DEF_X 50
#define STATUSWND_DEF_Y 580

#define CX_ITEMMARGIN            6
#define CY_ITEMMARGIN            6
#define CX_ITEMMARGIN_THEME      4
#define CY_ITEMMARGIN_THEME      2
#define ITEMDISTANCE             6
#define ITEMDISTANCE_THEME       2

#define CTRLITEMHEIGHTMARGIN           0
#define CTRLITEMHEIGHTMARGIN_THEME     1

#define KANACAPSBMP_WIDTH   21
#define KANACAPSBMP_HEIGHT   7

class CTipbarThread;
class CTipbarButtonItem;
class CTipbarItem;
class CTipbarWnd;
class CTipbarCtrlButton;
class CEnumCatCache;
class CGuidDwordCache;
class CTipbarCtrlButtonHolder;
class CDeskBand;

extern const IID IID_PRIV_BUTTONITEM;
extern const IID IID_PRIV_BITMAPBUTTONITEM;
extern const IID IID_PRIV_BITMAPITEM;
extern const IID IID_PRIV_BALLOONITEM;

extern DWORD g_dwWndStyle;
extern DWORD g_dwMenuStyle;
extern const TCHAR c_szUTBKey[];
extern const TCHAR c_szShowDeskBand[];
extern const TCHAR c_szDontShowCloseLangBarDlg[];
extern const TCHAR c_szDontShowMinimizeLangBarDlg[];
extern const TCHAR c_szShowMinimizedBalloon[];
extern BOOL  g_bShowCloseMenu;
extern BOOL  g_bShowMinimizedBalloon;
extern BOOL  g_bWinLogon;
extern BOOL  g_bShowDeskBand;

extern BOOL g_fTaskbarTheme;

extern BOOL g_bIntelliSense;

//
// IDs for Timer
//
#define TIPWND_TIMER_STUBSTART          1
#define TIPWND_TIMER_STUBEND            2
#define TIPWND_TIMER_BACKTOALPHA        3
#define TIPWND_TIMER_ONTHREADITEMCHANGE 4
#define TIPWND_TIMER_SETWINDOWPOS       5
#define TIPWND_TIMER_ONUPDATECALLED     6
#define TIPWND_TIMER_SYSCOLORCHANGED    7
#define TIPWND_TIMER_UPDATEUI           8
#define TIPWND_TIMER_SHOWWINDOW         9
#define TIPWND_TIMER_MOVETOTRAY         10
#define TIPWND_TIMER_DOACCDEFAULTACTION 11
#define TIPWND_TIMER_DISPLAYCHANGE      12
#define TIPWND_TIMER_ENSUREFOCUS        13
#define TIPWND_TIMER_SHOWDESKBAND       14

extern UINT g_uTimerElapseTRAYWNDONDELAYMSG;
extern UINT g_uTimerElapseDOACCDEFAULTACTION;

#define TRAYICONWND_TIMER_ONDELAYMSG    100

#define TIPWND_TIMER_DEMOTEITEMFIRST  10000
#define TIPWND_TIMER_DEMOTEITEMLAST   10050

BOOL GetTipbarInternal(HWND hwndParent, DWORD dwFlags, CDeskBand *pDeskBand);
BOOL IsDeskBandFromReg();


//////////////////////////////////////////////////////////////////////////////
//
// predefined control buttons
//
//////////////////////////////////////////////////////////////////////////////

struct CTRLBTNMAP {
    DWORD dwId;
    DWORD dwStyle;
    int   nColumn;
    int   nRow;
    DWORD dwFlags;
    WCHAR wsz[2];
};

#define CY_CTRLBTN      9
#define CX_COLUMN0     24
#define CX_COLUMN1     16

#define CTRL_USEMARLETT          0x0001
#define CTRL_ICONFROMRES         0x0002
#define CTRL_TOGGLEBUTTON        0x0004
#define CTRL_DISABLEONWINLOGON   0x0008

#define ID_CBTN_MINIMIZE  100
#define ID_CBTN_EXTMENU   101
#define ID_CBTN_KANAKEY   102
#define ID_CBTN_CAPSKEY   103
#define ID_CBTN_RESTORE   104
#define NUM_CTRLBUTTONS   4

// #define CX_CTRLBTNAREA    (12 + 24)

//
// dwFlags for CTipbarCtrlButtonHolder::Locate()
//
#define TCBH_NOCOLUMN0 0x0001
#define TCBH_NOCOLUMN  0x0002

//////////////////////////////////////////////////////////////////////////////
//
// misc func
//
//////////////////////////////////////////////////////////////////////////////

BOOL InitFromReg();

HRESULT SetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD dw);
HRESULT GetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD *pdw);
void  TurnOffSpeechIfItsOn();

//////////////////////////////////////////////////////////////////////////////
//
// CItemSortScore
//
//////////////////////////////////////////////////////////////////////////////

class CItemSortScore
{
public:
     CItemSortScore(DWORD dwCat = 0, DWORD dwItem = 0, DWORD dwSub = 0)
     {
         _dwCat = dwCat;
         _dwItem = dwItem;
         _dwSub = dwSub;
     }

     void Set(DWORD dwCat, DWORD dwItem, DWORD dwSub)
     {
         _dwCat = dwCat;
         _dwItem = dwItem;
         _dwSub = dwSub;
     }

     friend int operator >(CItemSortScore &s1, CItemSortScore &s2)
     {
         if (s1._dwCat > s2._dwCat)
              return 1;
         else if (s1._dwCat < s2._dwCat)
              return 0;

         if (s1._dwItem > s2._dwItem)
              return 1;
         else if (s1._dwItem < s2._dwItem)
              return 0;

         if (s1._dwSub > s2._dwSub)
              return 1;
         else if (s1._dwSub < s2._dwSub)
              return 0;

         return 0;
     }

     CItemSortScore& operator =(const CItemSortScore& iss)
     {
         _dwCat = iss._dwCat;
         _dwItem = iss._dwItem;
         _dwSub = iss._dwSub;
         return *this;
     }

     DWORD GetCat() {return _dwCat;}

private:
     DWORD _dwCat;
     DWORD _dwItem;
     DWORD _dwSub;
};

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarGripper
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarGripper: public CUIFGripper
{
public:
    CTipbarGripper(CTipbarWnd *pTipbarWnd, RECT *prc, DWORD dwStyle);

    BOOL OnSetCursor(UINT uMsg, POINT pt);
    void OnRButtonUp(POINT pt);
    void OnLButtonUp(POINT pt);

    CTipbarWnd *_pTipbarWnd;
    BOOL _fInMenu;
};

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarCtrlButtonHolder
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarCtrlButtonHolder
{
public:
    CTipbarCtrlButtonHolder();

    void Init(CTipbarWnd *ptw);
    void EnableBtns();
    void UpdateBitmap(CTipbarWnd *ptw);
    void Locate(CTipbarWnd *ptw, int x, int y, int nHeight, DWORD dwFlags, BOOL fVertical);
    int GetWidth(DWORD dwFlags);
    void UpdateCapsKanaState(LPARAM lParam);

    CTipbarCtrlButton *GetCtrlBtn(DWORD dwId);
private:
    CTRLBTNMAP *_pcbCtrlBtn;
    CTipbarCtrlButton *_rgpCtrlBtn[NUM_CTRLBUTTONS];
    CMaskBitmap _maskbmpCap;
    CMaskBitmap _maskbmpKana;
};


//////////////////////////////////////////////////////////////////////////////
//
// CTipbarWnd
//
//////////////////////////////////////////////////////////////////////////////

//
// for Get/SetNotifyStatus()
//
#define TW_NS_ONSETFOCUS           0x0001
#define TW_NS_ONTHREADITEMCHANGE   0x0002

class CTipbarWnd:  public ITfLangBarEventSink,
                   public ITfLangBarEventSink_P,
                   public CTipbarAccItem,
                   public CTipbarCoInitialize,
                   public CUIFWindow
{
public:
    CTipbarWnd(DWORD dwStyle);
    ~CTipbarWnd();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangBarEventSink
    //
    STDMETHODIMP OnSetFocus(DWORD dwThreadId);
    STDMETHODIMP OnThreadTerminate(DWORD dwThreadId);
    STDMETHODIMP OnThreadItemChange(DWORD dwThreadId);
    STDMETHODIMP OnModalInput(DWORD dwThreadId, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP ShowFloating(DWORD dwFlags);
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);

    //
    // ITfLangBarEventSink_P
    //
    STDMETHODIMP OnLangBarUpdate(UINT uUpdate, LPARAM lParam);

    // void UpdateUI() {InvalidateRect(GetWnd(), NULL, FALSE);}

    BOOL IsFullScreenWindow(HWND hwnd);
    HRESULT SetFocusThread(CTipbarThread *pThread);
    HRESULT AttachFocusThread();
    HRESULT OnThreadItemChangeInternal(DWORD dwThreadId);
    HRESULT OnThreadTerminateInternal(DWORD dwThreadId);
    void CleanUpThreadPointer(CTipbarThread *pThread, BOOL fCheckThreadArray);
    void EnsureFocusThread();

    void Init(BOOL fInDeskband, CDeskBand *pDeskBand);
    void UnInit();
    void SetVertical(BOOL fVertical);
    void UpdateVerticalFont();
    HFONT CreateVerticalFont();
    BOOL SetLangBand(BOOL fLangBand, BOOL fNotify = TRUE);
    void SetMoveRect( int x, int y, int nWidth, int nHeight);
    virtual void Move( int x, int y, int nWidth, int nHeight);
    void LocateCtrlButtons();
    void SetAlpha(BYTE bAlpha, BOOL fTemp);

    DWORD _dwlbimCookie;

    BOOL IsInDeskBand() {return _fInDeskBand;}

    void DestroyWnd()
    {
        if (IsWindow(GetWnd()))
            DestroyWindow(GetWnd());
    }

    int GetTipbarHeight()
    {
        int nRet;
        SIZE sizeWndFrame;

        // window frame

        sizeWndFrame.cx = 0;
        sizeWndFrame.cy = 0;
        if (_pWndFrame != NULL) {
            _pWndFrame->GetFrameSize( &sizeWndFrame );
        }
        nRet = _cySmIcon;

        nRet += max(CY_ITEMMARGIN,
                    CY_ITEMMARGIN_THEME + _marginsItem.cyTopHeight + _marginsItem.cyBottomHeight);
        nRet += (sizeWndFrame.cy * 2);
        return nRet;
    }

    DWORD GetWndStyle( void )
    {
        return CUIFWindow::GetWndStyle() & ~WS_BORDER;
    }

    BOOL CheckExcludeCaptionButtonMode(RECT *prcWnd, RECT *prcWork)
    {
        //
        // if the window is not top, we don't move to exclude caption mode.
        //
        if (prcWnd->top >= prcWork->top + 5)
            return FALSE;

        //
        // if the window is near right-top corner, we move to exclude caption
        // mode.
        //
        if (prcWnd->right + (_cxCapBtn * 5) >= prcWork->right)
            return TRUE;

        return FALSE;
    }

    BOOL IsShowText() {return _fShowText;}
    BOOL IsShowTrayIcon() {return _fShowTrayIcon;}

    void SetShowText(BOOL fShowText);
    void SetShowTrayIcon(BOOL fShowTrayIcon);
    void MoveToStub(BOOL fHide);
    void RestoreFromStub();

    CTipbarThread *GetFocusThread() {return _pFocusThread;}
    CTipbarThread *GetThread(DWORD dwThread);
    void RestoreLastFocus(DWORD *pdwThreadId, BOOL fPrev);

    CModalMenu *_pModalMenu;
    void CancelMenu();
    CTipbarThread *_pttModal;

    void SetWaitNotifyThread(DWORD dwThread) { _dwThreadIdWaitNotify = dwThread;}
    ITfLangBarMgr_P *GetLangBarMgr() {return _putb;}

    BOOL IsSFShowNormal() { return (_dwSFTFlags & TF_SFT_SHOWNORMAL) ? TRUE : FALSE; }
    BOOL IsSFDocked()     { return (_dwSFTFlags & TF_SFT_DOCK) ? TRUE : FALSE; }
    BOOL IsSFMinmized()   { return (_dwSFTFlags & TF_SFT_MINIMIZED) ? TRUE : FALSE; }
    BOOL IsSFHidden()     { return (_dwSFTFlags & TF_SFT_HIDDEN) ? TRUE : FALSE; }
    BOOL IsSFDeskband()         { return (_dwSFTFlags & TF_SFT_DESKBAND) ? TRUE : FALSE; }
    BOOL IsSFNoExtraIcon()      { return !_fAddExtraIcon; }

    CLangBarItemList _itemList;
    HFONT GetMarlett() {return _hfontMarlett;}
    HFONT GetVerticalFont() {return _hfontVert;}

    int GetCtrlButtonWidth()
    {
        DWORD dwFlags = 0;

        if (IsSFDeskband() && IsSFNoExtraIcon())
            dwFlags |= TCBH_NOCOLUMN;

        if (!IsCapKanaShown())
            dwFlags |= TCBH_NOCOLUMN0;

        return _ctrlbtnHolder.GetWidth(dwFlags);
    }

    void InitHighContrast()
    {
        HIGHCONTRAST hc;
        _fHighContrastOn = FALSE;
        hc.cbSize = sizeof(HIGHCONTRAST);
        if (SystemParametersInfo(SPI_GETHIGHCONTRAST,
                                 sizeof(HIGHCONTRAST),
                                 &hc,
                                 FALSE))
        {
            if (hc.dwFlags & HCF_HIGHCONTRASTON)
                _fHighContrastOn = TRUE;
        }
    }

    BOOL IsHighContrastOn() {return _fHighContrastOn ? TRUE : FALSE;}

    void InitMetrics()
    {
        _cxSmIcon = GetSystemMetrics( SM_CXSMICON );
        _cySmIcon = GetSystemMetrics( SM_CYSMICON );
        LONG_PTR dwStyle = GetWindowLongPtr(GetWnd(), GWL_STYLE);
        if (dwStyle & WS_DLGFRAME)
        {
            _cxDlgFrame = GetSystemMetrics(SM_CXDLGFRAME) * 2;
            _cyDlgFrame = GetSystemMetrics(SM_CYDLGFRAME) * 2;
        }
        else if (dwStyle & WS_BORDER)
        {
            _cxDlgFrame = GetSystemMetrics(SM_CXBORDER) * 2;
            _cyDlgFrame = GetSystemMetrics(SM_CYBORDER) * 2;
        }
        else
        {
            _cxDlgFrame = 0;
            _cyDlgFrame = 0;
        }
    }

    int GetSmIconWidth() {return _cxSmIcon;}
    int GetSmIconHeight() {return _cySmIcon;}
    int GetCxDlgFrame() {return _cxDlgFrame;}
    int GetCyDlgFrame() {return _cyDlgFrame;}

    int GetGripperWidth();

    void StartModalInput(ITfLangBarEventSink *pSink, DWORD dwThreadId);
    void StopModalInput(DWORD dwThreadId);

    CUIFWndFrame *GetWndFrame() {return _pWndFrame;}

    void MoveToTray();

    void ClearLBItemList();

    void MyClientToScreen(POINT *ppt, RECT *prc)
    {
        if (ppt)
            ClientToScreen(GetWnd(), ppt);
        if (prc)
        {
            ClientToScreen(GetWnd(), (POINT *)&prc->left);
            ClientToScreen(GetWnd(), (POINT *)&prc->right);
        }
    }
    void ShowOverScreenSizeBalloon();
    void DestroyOverScreenSizeBalloon();

    void SetExcludeCaptionButtonMode(BOOL bSet) {_bInExcludeCaptionButtonMode = bSet;}
    BOOL IsInExcludeCaptionButtonMode() {return _bInExcludeCaptionButtonMode;}
    void ShowContextMenu(POINT pt, RECT *prc, BOOL fExtendMenuItems);


    BOOL IsCapKanaShown()
    {
        HKL hkl = GetFocusKeyboardLayout();
        return (LOWORD(hkl) == 0x411) ? TRUE : FALSE;
    }

    CTipbarCtrlButtonHolder *GetCtrlButtonHolder() {return &_ctrlbtnHolder;}

    BOOL IsInFullScreen() {return _fInFullScreen;}

    BOOL _fIsItemShownInFloatingToolbar;

    void StartPendingUpdateUI()
    {
        _dwPendingUpdateUI++;
    }

    void EndPendingUpdateUI()
    {
        Assert(_dwPendingUpdateUI > 0);
        _dwPendingUpdateUI--;
    }

    BOOL IsInItemChangeOrDirty(CTipbarThread *pThread);

    BSTR GetAccName( void )
    {
        return SysAllocString(CRStr(IDS_LANGBAR));
    }

    void GetAccLocation( RECT *prc )
    {
        GetRect(prc);
    }

    BOOL StartDoAccDefaultActionTimer(CTipbarItem *pItem);
    CTipbarAccessible *GetAccessible()  {return _pTipbarAcc;}

    BOOL IsVertical() {return _fVertical;}

    void UpdatePosFlags();

    BOOL AutoAdjustDeskBandSize();
    BOOL AdjustDeskBandSize(BOOL fFit);
    void ClearDeskbandSizeAdjusted()
    {
        _fDeskbandSizeAdjusted = FALSE;
    }

    void SetDeskbandSizeAdjusted()
    {
        _fDeskbandSizeAdjusted = TRUE;
    }

    void SetAdjustDeskbandIfNoRoom()
    {
        _fAdjustDeskbandIfNoRoom = TRUE;
    }

    BOOL IsSingleKeyboardLayout()
    {
        if (::GetKeyboardLayoutList(0, NULL) == 1)
            return TRUE;

        return FALSE;
    }

    HKL GetFocusKeyboardLayout() ;

    UINT_PTR SetTimer(UINT_PTR nIDEvent, UINT uElapse)
    {
        if (!IsWindow(GetWnd()))
            return 0;

        return ::SetTimer(GetWnd(), nIDEvent, uElapse, NULL);
    }

    UINT_PTR KillTimer(UINT_PTR nIDEvent)
    {
        if (!IsWindow(GetWnd()))
            return 0;

        return ::KillTimer(GetWnd(), nIDEvent);
    }

private:
    CTipbarThread *_FindThread(DWORD dwThread);
    CTipbarThread *_CreateThread(DWORD dwThread);
    void OnCreate(HWND hWnd);
    void OnDestroy(HWND hWnd);
    void OnEndSession(HWND hwnd, WPARAM wParam, LPARAM lParam);
    void SavePosition();
    void HandleMouseMsg( UINT uMsg, POINT pt );
    void OnMouseOutFromWindow( POINT pt );
    void OnTimer(UINT uId);
    void OnSysColorChange();
    void OnUser(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnShowWindow( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    LRESULT OnSettingChange(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnDisplayChange(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnWindowPosChanged(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnWindowPosChanging(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnEraseBkGnd( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    LRESULT OnGetObject( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    void OnThemeChanged(HWND hwnd, WPARAM wParam, LPARAM lParam);
    void PaintObject( HDC hDC, const RECT *prcUpdate );
    void UpdateUI(const RECT *prcUpdate );

    void AdjustPosOnDisplayChange();

    void KillOnTheadItemChangeTimer();

    void OnTerminateToolbar();
    void TerminateAllThreads(BOOL fTerminatFocusThread);

    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, GWLP_USERDATA,
                      (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
    }

    static CTipbarWnd *GetThis(HWND hWnd)
    {
        CTipbarWnd *p = (CTipbarWnd *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
        Assert(p != NULL);
        return p;
    }


#ifdef USE_OFC10LOOKONWINXP
    void CheckO10Flag();
#endif

    void StartBackToAlphaTimer()
    {
        //
        // doubld-click-time * 3 is ok?
        //
        ::SetTimer(GetWnd(),
                   TIPWND_TIMER_BACKTOALPHA,
                   GetDoubleClickTime() * 3,
                   NULL);
    }

    CUIFWndFrame *_pWndFrame;
    CTipbarGripper *_pGripper;
    CTipbarThread *_pFocusThread;
    CPtrArray<CTipbarThread> _rgThread;
    BYTE _bAlpha;
    BOOL _fFocusAttached : 1;
    BOOL _fInDeskBand : 1;
    BOOL _fVertical : 1;
    BOOL _bCurAlpha : 1;

    BOOL _fShowText : 1;
    BOOL _fShowTrayIcon : 1;
    BOOL _fInStub : 1;
    BOOL _fInStubShow : 1;
    BOOL _fHighContrastOn : 1;
    BOOL _fInFullScreen : 1;

    BOOL _fNeedMoveWindow : 1;
    BOOL _fInHandleMouseMsg : 1;
    BOOL _bInExcludeCaptionButtonMode : 1;
    BOOL _fInEnsureFocusThread : 1;
    BOOL _fDeskbandSizeAdjusted : 1;
    BOOL _fAdjustDeskbandIfNoRoom : 1;

    BOOL _fTerminating : 1;

    BOOL _fAddExtraIcon : 1;

    BOOL _fPosTop : 1;
    BOOL _fPosBottom : 1;
    BOOL _fPosRight : 1;
    BOOL _fPosLeft : 1;

    int   _cxCapBtn;
    DWORD _dwSFTFlags;
    DWORD _dwPrevTBStatus;

    int _cxSmIcon;
    int _cySmIcon;
    int _cxDlgFrame;
    int _cyDlgFrame;

    HFONT _hfontMarlett;
    HFONT _hfontVert;
    ITfLangBarMgr_P *_putb;

    DWORD _dwThreadIdWaitNotify;
    CTipbarCtrlButtonHolder _ctrlbtnHolder;

    CUIFBalloonWindow *_pblnOverScreenSize;

    DWORD _dwThreadItemChangedForTimer;

    DWORD  _dwPendingUpdateUI;
    RECT _rcNew;

    //
    // MSAA support
    //
    CTipbarAccessible *_pTipbarAcc;
    int _nDoAccDefaultActionItemId;

    MARGINS _marginsItem;
    int _cxItemMargin;
    int _nItemDistance;
    int _nCtrlItemHeightMargin;

public:
    MARGINS *GetThemeMargins() {return &_marginsItem;}
    int GetItemMargin()
    {
        return _cxItemMargin;
    }

    int GetItemDistance()
    {
        return _nItemDistance;
    }

    int GetCtrlItemHeightMargin()
    {
        return _nCtrlItemHeightMargin;
    }

    int GetCaptionButtonWidth()
    {
        return _cxCapBtn;
    }

    void InitThemeMargins();

    BOOL _fShowWindowAtTimer : 1;
    BOOL _fShowOverItemBalloonAtTimer : 1;
    CTipbarThread *_pThreadShowWindowAtTimer;

    BOOL IsHKLToSkipRedrawOnNoItem();

    void ClearDeskBandPointer()
    {
        _pDeskBand = NULL;
    }

private:

    CDeskBand *_pDeskBand;

    CShellWndThread shellwnd;
    int _cRef;
};

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarThread
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarThread
{
public:
    CTipbarThread(CTipbarWnd *ptw);
    ~CTipbarThread();

    ULONG _AddRef( );
    ULONG _Release( );

    HRESULT Init(DWORD dwThreadId);
    HRESULT InitItemList();
    void GetTextSize(BSTR bstr, SIZE *psize);
    BOOL InsertItem(ITfLangBarItem *plbi, CEnumCatCache *penumcache, CGuidDwordCache *pgdcache, RECT *prc, MARGINS *pmargins, TF_LANGBARITEMINFO *plbiInfo, DWORD *pdwStatus);
    HRESULT _UninitItemList(BOOL fUnAdvise);
    void _AdviseItemsSink();
    HRESULT _UnadviseItemsSink();
    BOOL UpdateItems();
    void AddUIObjs();
    void RemoveUIObjs();
    void AddAllSeparators();
    void RemoveAllSeparators();
    void LocateItems();
    void GetSortScore(CItemSortScore *pscore, TF_LANGBARITEMINFO *plbiInfo, CEnumCatCache *penumcache, CGuidDwordCache *pgdcache);
    void MyMoveWnd(int dxOffset, int dyOffset);

    BOOL SetFocus(BOOL fFocus);

    BOOL IsFocusThread()
    {
        if (!_ptw)
            return FALSE;

        return (this == _ptw->GetFocusThread()) ? TRUE : FALSE;
    }

    void Disconnect()
    {
        _ptw = NULL;
    }

    DWORD IsDirtyItem();
    BOOL CallOnUpdateHandler();

    CTipbarWnd *_ptw;
    ITfLangBarItemMgr *_plbim;
    CPtrArray<CTipbarItem> _rgItem;
    CPtrArray<CUIFSeparator> _rgSep;
    int _nNumItem;
    CTipbarItem *GetItem(REFGUID guid);

    BOOL IsConsole() {return (_dwThreadFlags & TLF_NTCONSOLE) ? TRUE : FALSE;}
    BOOL IsTIMActive() {return (_dwThreadFlags & TLF_TIMACTIVE) ? TRUE : FALSE;}
    BOOL Is16bitTask() {return (_dwThreadFlags & TLF_16BITTASK) ? TRUE : FALSE;}
    BOOL IsCtfmonProcess() {return (_dwThreadFlags & TLF_CTFMONPROCESS) ? TRUE : FALSE;}

    DWORD _dwThreadId;
    DWORD _dwThreadFlags;
    DWORD _dwProcessId;
    SIZE _sizeWnd;
    DWORD _dwTickTime;
    BOOL _fItemChanged : 1;
    BOOL _fSkipRedrawOnNoItem : 1;

    BOOL IsVertical()
    {
        if (!_ptw)
            return FALSE;

        return _ptw->IsVertical();
    }


#ifdef DEBUG
    BOOL _fInCallOnUpdateHandler;
    BOOL _fIsInatItem;
#endif

private:
    ULONG _ref;
};


//////////////////////////////////////////////////////////////////////////////
//
// CTipbarItem
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarItem : public CTipbarAccItem
{
public:
    CTipbarItem(CTipbarThread *ptt, ITfLangBarItem *plbi, TF_LANGBARITEMINFO *plbiInfo, DWORD dwStatus);
    virtual ~CTipbarItem();

    virtual STDMETHODIMP  QueryInterface(REFIID riid, void **ppvObj)  = 0;
    virtual STDMETHODIMP_(ULONG) AddRef(void)   = 0;
    virtual STDMETHODIMP_(ULONG) Release(void)   = 0;

    virtual STDMETHODIMP OnUpdate(DWORD dwFlags);

    virtual BOOL OnSetCursor(UINT uMsg, POINT pt);
    virtual void OnPosChanged() { return;}
    void SetWidth(DWORD dw) {_dwWidth = dw;}
    DWORD GetWidth() {return _dwWidth;}
    CItemSortScore *GetItemSortScore() {return &_score;}
    DWORD GetCatScore() {return _score.GetCat();}

    virtual HRESULT OnUpdateHandler(DWORD dwFlags, DWORD dwStatus);
    virtual void SetRect( const RECT *prc ) = 0;
    virtual void AddMeToUI(CUIFObject *pobj) = 0;
    virtual void RemoveMeToUI(CUIFObject *pobj) = 0;

    void _AddedToUI();
    void _RemovedToUI();

    virtual void OnLeftClick() = 0;

    virtual BOOL Init() = 0;
    virtual void DetachWnd() = 0;
    virtual void ClearWnd() = 0;
    virtual void Enable(BOOL fEnable) = 0;
    virtual void SetToolTip(LPCWSTR pwszToolTip) = 0;
    virtual LPCWSTR GetToolTipFromUIOBJ() = 0;
    virtual LPCWSTR GetToolTip();
    virtual HICON GetIconFromUIObj() {return NULL;}
    virtual void GetScreenRect(RECT *prc) = 0;
    virtual void MoveToTray() {};
    virtual void UninitUIResource() {}
    virtual void SetFont(HFONT hfont) {}
    virtual void SetText( WCHAR *psz) {}

    DWORD _dwlbiSinkCookie;


    DWORD GetStatus() {return _dwStatus;}
    BOOL IsHiddenStatusControl() {return (_lbiInfo.dwStyle & TF_LBI_STYLE_HIDDENSTATUSCONTROL) ? TRUE : FALSE;}
    BOOL IsShownInTray() {return (_lbiInfo.dwStyle & TF_LBI_STYLE_SHOWNINTRAY) ? TRUE : FALSE;}
    BOOL IsShownInTrayOnly() {return (_lbiInfo.dwStyle & TF_LBI_STYLE_SHOWNINTRAYONLY) ? TRUE : FALSE;}
    BOOL IsHideOnNoOtherItems() {return (_lbiInfo.dwStyle & TF_LBI_STYLE_HIDEONNOOTHERITEMS) ? TRUE : FALSE;}
    BOOL IsHiddenByDefault() {return (_lbiInfo.dwStyle & TF_LBI_STYLE_HIDDENBYDEFAULT) ? TRUE : FALSE;}
    BOOL IsToggled() {return (_dwStatus & TF_LBI_STATUS_BTN_TOGGLED) ? TRUE : FALSE;}
    BOOL IsMenuBtn() {return (_lbiInfo.dwStyle & TF_LBI_STYLE_BTN_MENU) ? TRUE : FALSE;}
    BOOL IsInHiddenStatus() {return (_dwStatus & TF_LBI_STATUS_HIDDEN) ? TRUE : FALSE;}
    BOOL IsDisabled() {return (_dwStatus & TF_LBI_STATUS_DISABLED) ? TRUE : FALSE;}
    BOOL IsTextColorIcon() {return (_lbiInfo.dwStyle & TF_LBI_STYLE_TEXTCOLORICON) ? TRUE : FALSE;}
    WCHAR *GetDescriptionRef() {return _lbiInfo.szDescription;}
    GUID *GetGUID() {return &_lbiInfo.guidItem;}
    ITfLangBarItem *GetNotifyUI() {return _plbi;}

    BOOL IsSystemItem()
    {
        return (IsEqualGUID(CLSID_SYSTEMLANGBARITEM, _lbiInfo.clsidService)) ? TRUE : FALSE;
    }

    DWORD GetDirtyUpdateFlags() {return _dwDirtyUpdateFlags;}
    void ClearDirtyUpdateFlags() {_dwDirtyUpdateFlags = 0;}
    void AddRemoveMeToUI(BOOL fAdd);
    BOOL IsVisibleInToolbar() {return _fVisibleInToolbar;}
    void VisibleInToolbar(BOOL fVisible) {_fVisibleInToolbar = fVisible;}

    void ClearOnUpdateRequest() {_fNewOnUpdateRequest = FALSE;}
    BOOL IsNewOnUpdateRequest() {return _fNewOnUpdateRequest;}

    void ClearConnections()
    {
        _ptt = NULL;
        SafeReleaseClear(_plbi);
    }

    void Disconnect()
    {
        _fDisconnected = TRUE;
    }

    BOOL IsConnected()
    {
        if (_fDisconnected)
            return FALSE;

        if (!_ptt)
            return FALSE;

        if (!_ptt->_ptw)
            return FALSE;

        if (!_plbi)
            return FALSE;

        return TRUE;
    }

    BSTR GetAccName( void )
    {
        return SysAllocString(_lbiInfo.szDescription);
    }

    void GetAccLocation( RECT *prc )
    {
        GetScreenRect(prc);
    }

    BOOL DoAccDefaultAction()
    {
        if (!_ptt || !_ptt->_ptw)
             return FALSE;

        _ptt->_ptw->StartDoAccDefaultActionTimer(this);
        return TRUE;
    }

    virtual void SetActiveTheme(LPCWSTR pszClassList, int iPartID = 0, int iStateID = 0) = 0;

    void SetTextSize(SIZE *psize)
    {
        _sizeText = *psize;
    }

protected:
    void MyClientToScreen(RECT *prc)
    {
        if (!_ptt || !_ptt->_ptw)
            return;

        _ptt->_ptw->MyClientToScreen(NULL, prc);
    }
    void MyClientToScreen(POINT *ppt, RECT *prc)
    {
        if (!_ptt || !_ptt->_ptw)
            return;

        _ptt->_ptw->MyClientToScreen(ppt, prc);
    }

    void StartDemotingTimer(BOOL fIntentionally)
    {
        if (!g_bIntelliSense)
            return;

        if (!_ptt || !_ptt->_ptw)
            return;

        if (!fIntentionally)
            fIntentionally = _ptt->_ptw->_itemList.IsStartedIntentionally(*GetGUID());
        _ptt->_ptw->_itemList.StartDemotingTimer(*GetGUID(), fIntentionally);
    }

    TF_LANGBARITEMINFO _lbiInfo;
    DWORD _dwStatus;

    DWORD _dwWidth;
    CTipbarThread *_ptt;
    ITfLangBarItem *_plbi;

    SIZE _sizeText;

    BOOL _fToolTipInit : 1;
    BOOL _fAddedToUI : 1;
    BOOL _fAddedToIconTray : 1;
    BOOL _fVisibleInToolbar : 1;
    BOOL _fDisconnected : 1;
    BOOL _fNewOnUpdateRequest : 1;
    DWORD _dwDirtyUpdateFlags;

    int _cRef;

private:
    CItemSortScore _score;
};

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarItemGuidArray
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarItemGuidArray
{
public:
    CTipbarItemGuidArray() {_pguid = NULL;}
    ~CTipbarItemGuidArray()
    {
        if (_pguid)
            delete _pguid;
    }

    BOOL Init(CPtrArray<CTipbarItem> *prgItem)
    {
        int i;
        _pguid = new GUID[prgItem->Count()];
        if (!_pguid)
            return FALSE;

        for (i = 0; i < prgItem->Count(); i++)
        {
            CTipbarItem *ptbItem = prgItem->Get(i);
            Assert(ptbItem);
            _pguid[i] = *ptbItem->GetGUID();
        }
        return TRUE;
    }

    GUID *GetPtr() {return _pguid;}

private:
    GUID *_pguid;
};

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarButtonItem
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarButtonItem: public CTipbarItem,
                         public CUIFToolbarButton,
                         public ITfLangBarItemSink
{
public:
    CTipbarButtonItem(CTipbarThread *ptt,
                      ITfLangBarItem *plbi,
                      ITfLangBarItemButton *plbiButton,
                      DWORD dwId,
                      RECT *prc,
                      DWORD dwStyle,
                      DWORD dwSBtnStyle,
                      DWORD dwSBtnShowType,
                      TF_LANGBARITEMINFO *plbiInfo,
                      DWORD dwStatus);
    ~CTipbarButtonItem();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangbarItemSink methods
    //
    STDMETHODIMP OnUpdate(DWORD dwFlags)
    {
        return CTipbarItem::OnUpdate(dwFlags);
    }

    BOOL Init()
    {
        CUIFToolbarButton::Initialize();
        return CUIFToolbarButton::Init();
    }

    virtual void UninitUIResource()
    {
        HICON hIconOld = GetIconFromUIObj();
        if (hIconOld)
            DestroyIcon(hIconOld);
        SetIcon((HICON)NULL);
    }

    void DetachWnd() {DetachWndObj();}
    void ClearWnd() {ClearWndObj();}
    void Enable(BOOL fEnable)
    {
        CUIFToolbarButton::Enable(fEnable);
    }

    void SetToolTip(LPCWSTR pwszToolTip)
    {
        CUIFToolbarButton::SetToolTip(pwszToolTip);
    }

    LPCWSTR GetToolTipFromUIOBJ()
    {
        return CUIFToolbarButton::GetToolTip();
    }

    LPCWSTR GetToolTip()
    {
        return CTipbarItem::GetToolTip();
    }

    HICON GetIconFromUIObj()
    {
        return CUIFToolbarButton::GetIcon();
    }

    HICON GetIcon()
    {
        HICON hIcon;
        if (_plbiButton->GetIcon(&hIcon) == S_OK)
            return hIcon;

        return NULL;
    }

    void GetScreenRect(RECT *prc)
    {
        GetRect(prc);
        MyClientToScreen(prc);
    }

    void SetFont(HFONT hfont)
    {
        CUIFToolbarButton::SetFont(hfont);
    }

    void SetText(WCHAR *psz)
    {
        CUIFToolbarButton::SetText(psz);
    }


    BOOL OnSetCursor(UINT uMsg, POINT pt) {return CTipbarItem::OnSetCursor(uMsg, pt);}
    void OnRightClick();
    void OnLeftClick();
    void OnShowMenu();
    void DoModalMenu(POINT *ppt, RECT *prc);
    HRESULT OnUpdateHandler(DWORD dwFlags, DWORD dwStatus);

    void SetRect( const RECT *prc ) {CUIFToolbarButton::SetRect(prc);}
    void AddMeToUI(CUIFObject *pobj)
    {
        if (!pobj)
            return;

        pobj->AddUIObj(this);
        _AddedToUI();
    }
    void RemoveMeToUI(CUIFObject *pobj)
    {
        if (!pobj)
            return;

        pobj->RemoveUIObj(this);
        _RemovedToUI();
    }

    void MoveToTray();


    ITfLangBarItemButton *GetNotifyUIButton() {return _plbiButton;}
    ITfLangBarItemButton *GetLangBarItem() {return _plbiButton;}

    virtual void SetActiveTheme(LPCWSTR pszClassList, int iPartID, int iStateID )
    {
        CUIFToolbarButton::SetActiveTheme(pszClassList, iPartID, iStateID);
    }

    //
    // MSAA Support
    //
    BSTR GetAccDefaultAction()
    {
        return SysAllocString(CRStr(IDS_LEFTCLICK));
    }


    BOOL DoAccDefaultActionReal()
    {
        if (IsMenuOnly())
            OnShowMenu();
        else
            OnLeftClick();
        return TRUE;
    }
private:
    ITfLangBarItemButton *_plbiButton;
};

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarBitmapButtonItem
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarBitmapButtonItem: public CTipbarItem,
                               public CUIFToolbarButton,
                               public ITfLangBarItemSink
{
public:
    CTipbarBitmapButtonItem(CTipbarThread *ptt,
                      ITfLangBarItem *plbi,
                      ITfLangBarItemBitmapButton *plbiBitmapButton,
                      DWORD dwId,
                      RECT *prc,
                      DWORD dwStyle,
                      DWORD dwSBtnStyle,
                      DWORD dwSBtnShowType,
                      TF_LANGBARITEMINFO *plbiInfo,
                      DWORD dwStatus);
    ~CTipbarBitmapButtonItem();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangbarItemSink methods
    //
    STDMETHODIMP OnUpdate(DWORD dwFlags)
    {
        return CTipbarItem::OnUpdate(dwFlags);
    }

    BOOL Init()
    {
        CUIFToolbarButton::Initialize();
        return CUIFToolbarButton::Init();
    }
    void DetachWnd() {DetachWndObj();}
    void ClearWnd() {ClearWndObj();}
    void Enable(BOOL fEnable)
    {
        CUIFToolbarButton::Enable(fEnable);
    }

    void SetToolTip(LPCWSTR pwszToolTip)
    {
        CUIFToolbarButton::SetToolTip(pwszToolTip);
    }

    LPCWSTR GetToolTipFromUIOBJ()
    {
        return CUIFToolbarButton::GetToolTip();
    }

    LPCWSTR GetToolTip()
    {
        return CTipbarItem::GetToolTip();
    }

    void GetScreenRect(RECT *prc)
    {
        GetRect(prc);
        MyClientToScreen(prc);
    }

    void SetFont(HFONT hfont)
    {
        CUIFToolbarButton::SetFont(hfont);
    }

    void SetText(WCHAR *psz)
    {
        CUIFToolbarButton::SetText(psz);
    }

    BOOL OnSetCursor(UINT uMsg, POINT pt) {return CTipbarItem::OnSetCursor(uMsg, pt);}
    void OnRightClick();
    void OnLeftClick();
    void OnShowMenu();
    HRESULT OnUpdateHandler(DWORD dwFlags, DWORD dwStatus);

    void SetRect( const RECT *prc ) {CUIFToolbarButton::SetRect(prc);}
    void AddMeToUI(CUIFObject *pobj)
    {
        if (!pobj)
            return;

        pobj->AddUIObj(this);
        _AddedToUI();
    }
    void RemoveMeToUI(CUIFObject *pobj)
    {
        if (!pobj)
            return;

        pobj->RemoveUIObj(this);
        _RemovedToUI();
    }

    ITfLangBarItemBitmapButton *GetLangBarItem() {return _plbiBitmapButton;}

    virtual void SetActiveTheme(LPCWSTR pszClassList, int iPartID, int iStateID )
    {
        CUIFToolbarButton::SetActiveTheme(pszClassList, iPartID, iStateID);
    }

    //
    // MSAA Support
    //
    BSTR GetAccDefaultAction()
    {
        return SysAllocString(CRStr(IDS_LEFTCLICK));
    }

    BOOL DoAccDefaultActionReal()
    {
        if (IsMenuOnly())
            OnShowMenu();
        else
            OnLeftClick();
        return TRUE;
    }

private:
    BOOL _GetBitmapFromNUI();

    ITfLangBarItemBitmapButton *_plbiBitmapButton;

};

//////////////////////////////////////////////////////////////////////////////
//
// CTipbarBitmapItem
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarBitmapItem: public CTipbarItem,
                         public CUIFObject,
                         public ITfLangBarItemSink
{
public:
    CTipbarBitmapItem(CTipbarThread *ptt,
                      ITfLangBarItem *plbi,
                      ITfLangBarItemBitmap *plbiButton,
                      DWORD dwId,
                      RECT *prc,
                      DWORD dwStyle,
                      TF_LANGBARITEMINFO *plbiInfo,
                      DWORD dwStatus);

    ~CTipbarBitmapItem();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangbarItemSink methods
    //
    STDMETHODIMP OnUpdate(DWORD dwFlags)
    {
        return CTipbarItem::OnUpdate(dwFlags);
    }

    BOOL Init()
    {
        CUIFObject::Initialize();

        return TRUE;
    }
    void DetachWnd() {DetachWndObj();}
    void ClearWnd() {ClearWndObj();}

    void Enable(BOOL fEnable)
    {
        CUIFObject::Enable(fEnable);
    }

    void SetToolTip(LPCWSTR pwszToolTip)
    {
        CUIFObject::SetToolTip(pwszToolTip);
    }

    LPCWSTR GetToolTipFromUIOBJ()
    {
        return CUIFObject::GetToolTip();
    }

    LPCWSTR GetToolTip()
    {
        return CTipbarItem::GetToolTip();
    }

    void GetScreenRect(RECT *prc)
    {
        GetRect(prc);
        MyClientToScreen(prc);
    }

    BOOL OnSetCursor(UINT uMsg, POINT pt) {return CTipbarItem::OnSetCursor(uMsg, pt);}
    void OnPaint( HDC hdc );
    void OnRightClick();
    void OnLeftClick();
    HRESULT OnUpdateHandler(DWORD dwFlags, DWORD dwStatus);

    void SetRect( const RECT *prc );
    void AddMeToUI(CUIFObject *pobj)
    {
        if (!pobj)
            return;

        pobj->AddUIObj(this);
        _AddedToUI();
    }
    void RemoveMeToUI(CUIFObject *pobj)
    {
        if (!pobj)
            return;

        pobj->RemoveUIObj(this);
        _RemovedToUI();
    }

    BOOL _GetBitmapFromNUI();

    HBITMAP GetBitmap( void )      { return _hbmp; }

    ITfLangBarItemBitmap *GetLangBarItem() {return _plbiBitmap;}

    virtual void SetActiveTheme(LPCWSTR pszClassList, int iPartID, int iStateID )
    {
        CUIFObject::SetActiveTheme(pszClassList, iPartID, iStateID);
    }

    //
    // MSAA Support
    //
    BSTR GetAccDefaultAction()
    {
        return SysAllocString(CRStr(IDS_LEFTCLICK));
    }

    BOOL DoAccDefaultActionReal()
    {
        OnLeftClick();
        return TRUE;
    }
private:
    ITfLangBarItemBitmap *_plbiBitmap;
    HBITMAP _hbmp;
};


//////////////////////////////////////////////////////////////////////////////
//
// CTipbarCtrlButton
//
//////////////////////////////////////////////////////////////////////////////

class CTipbarCtrlButton: public CUIFButton2
{
public:
    CTipbarCtrlButton(CTipbarWnd *ptw, DWORD dwId, const RECT *prc, DWORD dwStyle);
    ~CTipbarCtrlButton() {};

    CTipbarWnd *_ptw;

    void OnLButtonUp(POINT pt);

    void SetVKey(UINT uVKey)
    {
        _uVKey = uVKey;
    }

    UINT GetVKey() {return _uVKey;}


    void SetToggleStateByVKey()
    {
        Assert(_uVKey);
        SHORT sKeyState;
        sKeyState = GetKeyState(_uVKey);
        CUIFButton2::SetToggleState((sKeyState & 0x01) ? TRUE : FALSE);
    }

    void ShowExtendMenu(POINT pt);
private:
    BOOL _fInMenu;

    void MyClientToScreen(POINT *ppt, RECT *prc)
    {
        _ptw->MyClientToScreen(ppt, prc);
    }

    UINT _uVKey;
};

#endif // _TIPBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbdlgs.cpp ===
//
// utbdlgs.cpp
//

#include "private.h"
#include "globals.h"
#include "resource.h"
#include "tipbar.h"
#include "utbdlgs.h"
#include "cregkey.h"
#include "regstr.h"


extern HINSTANCE g_hInst;


const TCHAR  c_szCTFMon[]  = TEXT("CTFMON.EXE");

BOOL CUTBCloseLangBarDlg::_fIsDlgShown = FALSE;
BOOL CUTBMinimizeLangBarDlg::_fIsDlgShown = FALSE;

//+---------------------------------------------------------------------------
//
// DoCloseLangbar
//
//----------------------------------------------------------------------------

void DoCloseLangbar()
{
    CMyRegKey key;
    ITfLangBarMgr *putb = NULL;

    HRESULT hr = TF_CreateLangBarMgr(&putb);

    if (SUCCEEDED(hr) && putb)
    {
        hr = putb->ShowFloating(TF_SFT_HIDDEN);
        SafeReleaseClear(putb);
    }

    if (SUCCEEDED(hr))
        TurnOffSpeechIfItsOn();


    if (key.Open(HKEY_CURRENT_USER, REGSTR_PATH_RUN, KEY_ALL_ACCESS) == S_OK)
    {
        key.DeleteValue(c_szCTFMon);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CUTBLangBarDlg
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// DlgProc
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK CUTBLangBarDlg::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            SetThis(hDlg, lParam);

            //
            // System could get cmdshow from USERSTARTUPDATA and it is 
            // minimized. So we need to restore the window.
            //
            ShowWindow(hDlg, SW_RESTORE);
            UpdateWindow(hDlg);
            break;

        case WM_COMMAND:
            GetThis(hDlg)->OnCommand(hDlg, wParam, lParam);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// StartThread
//
//----------------------------------------------------------------------------

BOOL CUTBLangBarDlg::StartThread()
{
    HANDLE hThread;
    DWORD dwThreadId;

    if (IsDlgShown())
        return FALSE;

    SetDlgShown(TRUE);

    hThread = CreateThread(NULL, 0, s_ThreadProc, this, 0, &dwThreadId);

    if (hThread)
    {
        _AddRef();
        CloseHandle(hThread);
    }
    else
        SetDlgShown(FALSE);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// s_ThreadProc
//
//----------------------------------------------------------------------------

DWORD CUTBLangBarDlg::s_ThreadProc(void *pv)
{
    CUTBLangBarDlg *_this = (CUTBLangBarDlg *)pv;
    return _this->ThreadProc();
}

//+---------------------------------------------------------------------------
//
// ThreadProc
//
//----------------------------------------------------------------------------

DWORD CUTBLangBarDlg::ThreadProc()
{
    Assert(_pszDlgStr);
    MuiDialogBoxParam(g_hInst,
                      _pszDlgStr,
                      NULL, 
                      DlgProc,
                      (LPARAM)this);

    SetDlgShown(FALSE);

    _Release();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CUTBCloseLangBarDlg
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// DoModal
//
//----------------------------------------------------------------------------

int CUTBCloseLangBarDlg::DoModal(HWND hWnd)
{
    CMyRegKey key;
    BOOL bShow = TRUE;

    if (key.Open(HKEY_CURRENT_USER, c_szUTBKey, KEY_READ) == S_OK)
    {
        DWORD dwValue;
        if (key.QueryValue(dwValue, c_szDontShowCloseLangBarDlg) == S_OK)
            bShow = dwValue ? FALSE : TRUE;
    }

    if (!bShow)
        return 0;

    StartThread();
    return 1;
}


//+---------------------------------------------------------------------------
//
// OnCommand
//
//----------------------------------------------------------------------------

BOOL CUTBCloseLangBarDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{

    switch (LOWORD(wParam))
    {
        case IDOK:
        {
            DoCloseLangbar();

            if (IsDlgButtonChecked(hDlg, IDC_DONTSHOWAGAIN))
            {
                CMyRegKey key;

                if (key.Create(HKEY_CURRENT_USER, c_szUTBKey) == S_OK)
                    key.SetValue(1, c_szDontShowCloseLangBarDlg);
            }
            EndDialog(hDlg, 1);
            break;
        }
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CUTBMinimizeLangBarDlg
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// DoModal
//
//----------------------------------------------------------------------------

int CUTBMinimizeLangBarDlg::DoModal(HWND hWnd)
{
    CMyRegKey key;
    BOOL bShow = FALSE; // #478364: default is FALSE from now.

    if (key.Open(HKEY_CURRENT_USER, c_szUTBKey, KEY_READ) == S_OK)
    {
        DWORD dwValue;
        if (key.QueryValue(dwValue, c_szDontShowMinimizeLangBarDlg) == S_OK)
            bShow = dwValue ? FALSE : TRUE;
    }

    if (!bShow)
        return 0;


    StartThread();
    return 1;
}

//+---------------------------------------------------------------------------
//
// OnCommand
//
//----------------------------------------------------------------------------

BOOL CUTBMinimizeLangBarDlg::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{

    switch (LOWORD(wParam))
    {
        case IDOK:
            if (IsDlgButtonChecked(hDlg, IDC_DONTSHOWAGAIN))
            {
                CMyRegKey key;
                if (key.Create(HKEY_CURRENT_USER, c_szUTBKey) == S_OK)
                    key.SetValue(1, c_szDontShowMinimizeLangBarDlg);
            }
            EndDialog(hDlg, 1);
            break;

        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ThreadProc
//
//----------------------------------------------------------------------------

DWORD CUTBMinimizeLangBarDlg::ThreadProc()
{
    //
    // for JP MSIME2002.
    //
    // Japanese MSIME2002 always add and remove item at every focus change.
    // if we show the minimized dialog box immediately, the deskband
    // size won't include the items of MSIME2002.
    // Wait 700ms so the dialog box is shown after MSIME2002 add its item
    // and the langband can calc the size with them.
    //
    // And we think showing this dialog box is not good UI. Like a normal 
    // window, we should show animation to let the end user know 
    // where the minimzed is gone to.
    //

    Sleep(700);

    return CUTBLangBarDlg::ThreadProc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbmenu.cpp ===
//
// lbmenu.cpp
//

#include "private.h"
#include "globals.h"
#include "utbmenu.h"
#include "cuimenu.h"
#include "xstring.h"
#include "tipbar.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CUTBMenuWnd
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// Initialize
//
//----------------------------------------------------------------------------

CUIFObject *CUTBMenuWnd::Initialize()
{
    Assert(!_pTipbarAcc);

    _pTipbarAcc = new CTipbarAccessible(this);

    return CUIFObject::Initialize();
}

//+---------------------------------------------------------------------------
//
// OnCreate
//
//----------------------------------------------------------------------------

void CUTBMenuWnd::OnCreate(HWND hWnd)
{
    if (_pTipbarAcc)
    {
        _pTipbarAcc->SetWindow(hWnd);
    }
}

//+---------------------------------------------------------------------------
//
// OnDestroy
//
//----------------------------------------------------------------------------

void CUTBMenuWnd::OnDestroy(HWND hWnd)
{
    //
    // MSAA support
    //
    if (_pTipbarAcc)
    {
        _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_DESTROY, this);
        _pTipbarAcc->ClearAccItems();
        _pTipbarAcc->Release();
        _pTipbarAcc = NULL;
    }

    CoUninit();
}

//+---------------------------------------------------------------------------
//
// OnShowWindow
//
//----------------------------------------------------------------------------

LRESULT CUTBMenuWnd::OnShowWindow( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    //
    // MSAA support
    //
    if (_pTipbarAcc)
    {
        if (wParam) 
        {
            _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_SHOW ,this);

            // 
            // MSCANDUI does this.
            // 
            // REVIEW: KOJIW: Unless we send notify EVENT_OBJECT_FOCUS, 
            // we never receive WM_GETOBJECT message.  Why???
            // 

            _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_FOCUS ,this);
        }
        else 
        {
            _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_HIDE ,this);
        }
    }

	return CUIFMenu::OnShowWindow( hWnd, uMsg, wParam, lParam );
}

//+---------------------------------------------------------------------------
//
// CTipbarWnd::OnTimer
//
//----------------------------------------------------------------------------

void CUTBMenuWnd::OnTimer(UINT uId)
{

    switch (uId)
    {
        case TIPWND_TIMER_DOACCDEFAULTACTION:
            //
            // MSAA support
            //
            ::KillTimer(GetWnd(), TIPWND_TIMER_DOACCDEFAULTACTION);
            if (_pTipbarAcc && _nDoAccDefaultActionItemId)
            {
                _pTipbarAcc->DoDefaultActionReal(_nDoAccDefaultActionItemId);
                _nDoAccDefaultActionItemId = 0;
            }
            break;

        default:
            break;
    }

    return;
}

//+---------------------------------------------------------------------------
//
// OnGetObject
//
//----------------------------------------------------------------------------

LRESULT CUTBMenuWnd::OnGetObject( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    LRESULT lResult = (LRESULT)0;

    switch (lParam) 
    {
        //
        // We process the OBJID_CLIENT object identifier;
        // this is the client area of our application
        // window.
        //

        case OBJID_CLIENT: 
        {
            HRESULT hr;

            if (_pTipbarAcc == NULL) 
            {
                return E_OUTOFMEMORY;
            }


            if (!_pTipbarAcc->IsInitialized()) 
            {
                //
                //
                //
                hr = EnsureCoInit();
                if (FAILED(hr)) 
                {
                    break;
                }
     

                //
                //    Initialize our Accessible object.  If the
                //      initialization fails, delete the Accessible
                //      object and return the failure code.
                //

                hr = _pTipbarAcc->Initialize();
                if (FAILED(hr)) 
                {
                    _pTipbarAcc->Release();
                    _pTipbarAcc = NULL;

                    lResult = (LRESULT)hr;
                    break;
                }

                //
                //    Send an EVENT_OBJECT_CREATE WinEvent for the
                //      creation of the Accessible object for the
                //      client area.
                //

                _pTipbarAcc->NotifyWinEvent( EVENT_OBJECT_CREATE , this);
            }

            //
            //    Call LresultFromObject() to create reference to
            //      our Accessible object that MSAA will marshal to
            //      the client.
            //

            lResult = _pTipbarAcc->CreateRefToAccObj( wParam );
            break;
        }

    }

    return lResult;
}

//+---------------------------------------------------------------------------
//
// StartDoDefaultActionTimer
//
//----------------------------------------------------------------------------

BOOL CUTBMenuWnd::StartDoAccDefaultActionTimer(CUTBMenuItem *pItem)
{
   if (!_pTipbarAcc)
       return FALSE;

   _nDoAccDefaultActionItemId = _pTipbarAcc->GetIDOfItem(pItem);
   if ((_nDoAccDefaultActionItemId == 0) || (_nDoAccDefaultActionItemId == -1))
       return FALSE;

   if (IsWindow(GetWnd()))
   {
       ::KillTimer(GetWnd(), TIPWND_TIMER_DOACCDEFAULTACTION);
       ::SetTimer(GetWnd(), 
                  TIPWND_TIMER_DOACCDEFAULTACTION,
                  g_uTimerElapseDOACCDEFAULTACTION, 
                  NULL);
   }

   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CUIModalMenu
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CancelMenu
//
//----------------------------------------------------------------------------

void CModalMenu::CancelMenu()
{
    if (_pCuiMenu)
        _pCuiMenu->CancelMenu();
}

//+---------------------------------------------------------------------------
//
// CreateMenu
//
//----------------------------------------------------------------------------

void CModalMenu::PostKey(BOOL fUp, WPARAM wParam, LPARAM lParam)
{
    Assert(_pCuiMenu);
    _pCuiMenu->PostKey(fUp, wParam, lParam);
}

//////////////////////////////////////////////////////////////////////////////
//
// CUTBLBarMenuItem
//
//////////////////////////////////////////////////////////////////////////////

BOOL CUTBLBarMenuItem::InsertToUI(CUTBMenuWnd *pCuiMenu)
{
    UINT uFlags = MF_BYPOSITION;
    if (_dwFlags & TF_LBMENUF_SEPARATOR)
    {
        uFlags |= MF_SEPARATOR;
        pCuiMenu->InsertSeparator();


        return TRUE;
    }

    if (_dwFlags & TF_LBMENUF_SUBMENU)
    {
        Assert(_pUTBMenu);
        CUTBMenuWnd *pCuiMenuSub;
        CUTBMenuItem *pCuiItem;

        pCuiMenuSub = ((CUTBLBarMenu *)_pSubMenu)->CreateMenuUI();
        if (!pCuiMenuSub)
            return FALSE;

        pCuiItem = new CUTBMenuItem(pCuiMenu);
        if (!pCuiItem)
        {
            delete pCuiMenuSub;
            return FALSE;
        }

        pCuiItem->Initialize();
        pCuiItem->Init((UINT)-1, _bstr);
        pCuiItem->SetSub(pCuiMenuSub);

        if (_hbmp)
            pCuiItem->SetBitmap(_hbmp);

        if (_hbmpMask)
            pCuiItem->SetBitmapMask(_hbmpMask);

        pCuiMenu->InsertItem(pCuiItem);

        if (pCuiMenu->GetAccessible())
            pCuiMenu->GetAccessible()->AddAccItem(pCuiItem);

        return TRUE;
    }

    CUTBMenuItem *pCuiItem = new CUTBMenuItem(pCuiMenu);
    if (!pCuiItem)
    {
        return FALSE;
    }

    pCuiItem->Initialize();
    pCuiItem->Init(_uId, _bstr);

    if (_dwFlags & TF_LBMENUF_GRAYED)
        pCuiItem->Gray(TRUE);

    if (_dwFlags & TF_LBMENUF_CHECKED)
        pCuiItem->Check(TRUE);
    else if (_dwFlags & TF_LBMENUF_RADIOCHECKED)
        pCuiItem->RadioCheck(TRUE);

    if (_hbmp)
        pCuiItem->SetBitmap(_hbmp);

    if (_hbmpMask)
        pCuiItem->SetBitmapMask(_hbmpMask);

    pCuiMenu->InsertItem(pCuiItem);

    if (pCuiMenu->GetAccessible())
        pCuiMenu->GetAccessible()->AddAccItem(pCuiItem);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CUTBLBarMenu
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CUTBLBarMenu::CUTBLBarMenu(HINSTANCE hInst)
{
    _hInst = hInst;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CUTBLBarMenu::~CUTBLBarMenu()
{
}

//+---------------------------------------------------------------------------
//
// ShowPopup
//
//----------------------------------------------------------------------------

UINT CUTBLBarMenu::ShowPopup(CUIFWindow *pcuiWndParent, const POINT pt, const RECT *prcArea)
{
    if (_pCuiMenu)
         return 0;

    _pCuiMenu = CreateMenuUI();
    if (!_pCuiMenu)
        return  CUI_MENU_UNSELECTED;

    UINT uRet = _pCuiMenu->ShowModalPopup(pcuiWndParent, prcArea, TRUE);

    delete _pCuiMenu;
    _pCuiMenu = NULL;
    return uRet;
}



//+---------------------------------------------------------------------------
//
// CreateMenu
//
//----------------------------------------------------------------------------

CUTBMenuWnd *CUTBLBarMenu::CreateMenuUI()
{
    CUTBMenuWnd *pCuiMenu = new CUTBMenuWnd(_hInst, g_dwMenuStyle, 0);

    if (!pCuiMenu)
        return pCuiMenu;

    pCuiMenu->Initialize();

    int i;
    for (i = 0; i < _rgItem.Count(); i++)
    {
        CUTBLBarMenuItem *pItem = (CUTBLBarMenuItem *)_rgItem.Get(i);
        pItem->InsertToUI(pCuiMenu);
    }

    return pCuiMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbmenu.h ===
//
// lbmenu.h
//
// Generic ITfTextEventSink object
//

#ifndef UTBMENU_H
#define UTBMENU_H

#include "ctfutb.h"
#include "lbmenu.h"
#include "cuimenu.h"
#include "ptrary.h"
#include "cresstr.h"
#include "utbacc.h"
#include "resource.h"

class CUTBLBarMenu;
class CUIFWindow;
class CUTBMenuItem;

//////////////////////////////////////////////////////////////////////////////
//
// CUTBMenuWnd
//
//////////////////////////////////////////////////////////////////////////////

class CUTBMenuWnd : public CTipbarAccItem,
                    public CTipbarCoInitialize,
                    public CUIFMenu
{
public:

    CUTBMenuWnd(HINSTANCE hInst, DWORD dwWndStyle, DWORD dwMenuStyle) : CUIFMenu(hInst, dwWndStyle, dwMenuStyle)
    {
   
    }

    virtual CUIFObject *Initialize( void );

    BSTR GetAccName( void ) 
    {
        return SysAllocString(CRStr(IDS_MENUWINDOW));
    }

    LONG GetAccRole( void )
    {
        return ROLE_SYSTEM_WINDOW;
    }

    void GetAccLocation( RECT *prc )
    {
        GetRect(prc);
    }

    void OnTimer(UINT uId);
    BOOL StartDoAccDefaultActionTimer(CUTBMenuItem *pItem);
    CTipbarAccessible *GetAccessible()  {return _pTipbarAcc;}

    void OnCreate(HWND hWnd);
    void OnDestroy(HWND hWnd);
    LRESULT OnGetObject( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    LRESULT OnShowWindow( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:
    CTipbarAccessible *_pTipbarAcc;
    int _nDoAccDefaultActionItemId;
};

//////////////////////////////////////////////////////////////////////////////
//
// CUTBMenuItem
//
//////////////////////////////////////////////////////////////////////////////

class CUTBMenuItem : public CTipbarAccItem,
                     public CUIFMenuItem
{
public:
    CUTBMenuItem(CUTBMenuWnd *pMenuWnd) : CUIFMenuItem(pMenuWnd)
    {
        _pMenuWnd = pMenuWnd;
    }

    virtual ~CUTBMenuItem()
    {
        if (_hbmp)
        {
            DeleteObject(_hbmp);
            _hbmp = NULL;
        }

        if (_hbmpMask)
        {
            DeleteObject(_hbmpMask);
            _hbmpMask = NULL;
        }
    }

    BSTR GetAccName( void ) 
    {
        return SysAllocString(_psz);
    }

    LONG GetAccRole( void )
    {
        if (IsSeparator() & TF_LBMENUF_SEPARATOR)
            return ROLE_SYSTEM_SEPARATOR;

        return ROLE_SYSTEM_MENUITEM;
    }

    void GetAccLocation( RECT *prc )
    {
        GetRect(prc);
        ClientToScreen(_pMenuWnd->GetWnd(), (POINT *)&prc->left);
        ClientToScreen(_pMenuWnd->GetWnd(), (POINT *)&prc->right);
    }

    //
    // MSAA Support
    //
    BSTR GetAccDefaultAction()
    {
        return SysAllocString(CRStr(IDS_LEFTCLICK));
    }

    BOOL DoAccDefaultAction()
    {
        if (!_pMenuWnd)
             return FALSE;

        _pMenuWnd->StartDoAccDefaultActionTimer(this);
        return TRUE;
    }

    BOOL DoAccDefaultActionReal()
    {
        if (GetSub())
            ShowSubPopup();
        else
        {
            POINT pt = {0,0};
            OnLButtonUp(pt);
        }
        return TRUE;
    }

private:
    CUTBMenuWnd *_pMenuWnd;
};


//////////////////////////////////////////////////////////////////////////////
//
// ModalMenu
//
//////////////////////////////////////////////////////////////////////////////

class CModalMenu
{
public:
    CModalMenu() {}
    virtual ~CModalMenu() {}

    void CancelMenu();
    void PostKey(BOOL fUp, WPARAM wParam, LPARAM lParam);
    HWND GetWnd() 
    {
        if (!_pCuiMenu)
            return NULL;

        return _pCuiMenu->GetWnd();
    }

protected:
    CUTBMenuItem *InsertItem(CUTBMenuWnd *pCuiMenu, int nId, int nIdStr)
    {
        CUTBMenuItem *pCuiItem = NULL;

        if (!(pCuiItem = new CUTBMenuItem(pCuiMenu)))
            return NULL;

        if (!pCuiItem->Initialize())
            goto ErrExit;

        if (!pCuiItem->Init(nId, CRStr(nIdStr)))
            goto ErrExit;

        if (!pCuiMenu->InsertItem(pCuiItem))
        {
ErrExit:
            delete pCuiItem;
            return NULL;
        }

        return pCuiItem;
    }

    CUTBMenuWnd *_pCuiMenu;
};

//////////////////////////////////////////////////////////////////////////////
//
// CUTBLBarMenuItem
//
//////////////////////////////////////////////////////////////////////////////

class CUTBLBarMenuItem : public CCicLibMenuItem
{
public:
    CUTBLBarMenuItem(CUTBLBarMenu *pUTBMenu)
    {
        _pUTBMenu = pUTBMenu;
    }

    ~CUTBLBarMenuItem() {}

    BOOL InsertToUI(CUTBMenuWnd *pCuiMenu);

private:
    CUTBLBarMenu *_pUTBMenu;
};


//////////////////////////////////////////////////////////////////////////////
//
// CUTBLBarMenu
//
//////////////////////////////////////////////////////////////////////////////


class CUTBLBarMenu :  public CCicLibMenu,
                      public CModalMenu
{
public:
    CUTBLBarMenu(HINSTANCE hInst);
    virtual ~CUTBLBarMenu();


    UINT ShowPopup(CUIFWindow *pcuiWndParent, const POINT pt, const RECT *prcArea);
    CUTBMenuWnd *CreateMenuUI();

    virtual CCicLibMenu *CreateSubMenu()
    {
        return new CUTBLBarMenu(_hInst);
    }

    virtual CCicLibMenuItem *CreateMenuItem()
    {
        return new CUTBLBarMenuItem(this);
    }

    CUTBMenuWnd *GetCuiMenu() {return _pCuiMenu;}
private:
    HINSTANCE _hInst;
};

#endif UTBMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbdlgs.h ===
//
// dlgs.h
//
// Generic ITfTextEventSink object
//

#ifndef DLGS_H
#define DLGS_H

void DoCloseLangbar();

//////////////////////////////////////////////////////////////////////////////
//
// CUTBLangBarDlg
//
//////////////////////////////////////////////////////////////////////////////

class CUTBLangBarDlg
{
public:
    CUTBLangBarDlg() 
    { 
        _cRef = 1;
    }

    
    LONG _AddRef()
    {
        _cRef++;
        return _cRef;
    }

    LONG _Release()
    {
        LONG ret = --_cRef;
        if (!_cRef)
            delete this;

        return ret;
    }

    virtual int DoModal(HWND hWnd) = 0;

    static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)lParam);
    }

    static CUTBLangBarDlg *GetThis(HWND hWnd)
    {
        CUTBLangBarDlg *p = (CUTBLangBarDlg *)GetWindowLongPtr(hWnd, DWLP_USER);
        Assert(p != NULL);
        return p;
    }

    virtual BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam) 
    {
        return TRUE;
    }

    BOOL StartThread();

    PTSTR _pszDlgStr;
    virtual BOOL IsDlgShown() = 0;
    virtual void SetDlgShown(BOOL fShow) = 0;
protected:
    virtual DWORD ThreadProc();
private:
    static DWORD s_ThreadProc(void *pv);
    TCHAR _szName[256];
    LONG _cRef;
};

#define ISDLGSHOWFUNC()                                             \
    BOOL IsDlgShown() {return _fIsDlgShown;}                        \
    void SetDlgShown(BOOL fShow) {_fIsDlgShown = fShow;}            \
    static BOOL _fIsDlgShown;

//////////////////////////////////////////////////////////////////////////////
//
// CUTBCloseLangBarDlg
//
//////////////////////////////////////////////////////////////////////////////

class CUTBCloseLangBarDlg : public CUTBLangBarDlg
{
public:
    CUTBCloseLangBarDlg() 
    {
        _pszDlgStr = IsOnNT51() ? MAKEINTRESOURCE(IDD_CLOSELANGBAR51) : MAKEINTRESOURCE(IDD_CLOSELANGBAR);
    }

    int DoModal(HWND hWnd);
    BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);

    ISDLGSHOWFUNC();
};

//////////////////////////////////////////////////////////////////////////////
//
// CUTBMinimizeLangBarDlg
//
//////////////////////////////////////////////////////////////////////////////

class CUTBMinimizeLangBarDlg : public CUTBLangBarDlg
{
public:
    CUTBMinimizeLangBarDlg() 
    {
        _pszDlgStr = IsOnNT51() ? MAKEINTRESOURCE(IDD_MINIMIZELANGBAR51): MAKEINTRESOURCE(IDD_MINIMIZELANGBAR);
    }

    int DoModal(HWND hWnd);
    BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);

    virtual DWORD ThreadProc();

    ISDLGSHOWFUNC();
};

#endif // DLGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbtray.h ===
//
// utbtray.h
//


#ifndef UTBTRAY_H
#define UTBTRAY_H

#include "ptrary.h"
#include "cuibln.h"
#include "slbarid.h"
#include "nuiinat.h"

class CTrayIconWnd;
class CTipbarItem;

#define WM_TIW_MAINICON            (WM_USER + 0x0000)
#define WM_TIW_MAINICON_DELAY      (WM_USER + 0x0001)
#define WM_TIW_WIN32IMEICON        (WM_USER + 0x0002)
#define WM_TIW_WIN32IMEICON_DELAY  (WM_USER + 0x0003)
#define WM_TIW_START               (WM_USER + 0x1000)

#define TIW_INDICATOR_ID_MAIN       0x0000
#define TIW_INDICATOR_ID_WIN32IME   0x0001

#define TIW_INDICATOR_ID_START      0x1000

#define TIW_RAI_LEAVELANGICON       0x0001
#define TIW_RAI_LEAVEKEYBOARDICON   0x0002

extern const GUID GUID_LBI_TRAYMAIN;

//////////////////////////////////////////////////////////////////////////////
//
// CTrayIconItem
//
//////////////////////////////////////////////////////////////////////////////

class CTrayIconItem
{
public:
    CTrayIconItem(CTrayIconWnd *ptiwnd);
    virtual ~CTrayIconItem();

    BOOL _Init(HWND hwnd, UINT uCallbackMessage, UINT uID, REFGUID rguid);

    virtual BOOL SetIcon(HICON hIcon, const WCHAR *pszTooltip);
    BOOL RemoveIcon();

    virtual BOOL OnMsg(WPARAM wParam, LPARAM lParam) {return FALSE;}
    virtual BOOL OnDelayMsg(UINT uMsg) {return FALSE;}

    UINT GetMsg() {return _uCallbackMessage;}

    BOOL UpdateMenuRectPoint();
    const GUID *GetGuid()   {return &_guidBtnItem;}
    UINT GetID() {return _uID;}
    BOOL IsShownInTray() {return _fShownInTray;}

protected:
    HWND _hwnd;
    UINT _uCallbackMessage;
    UINT _uID;
    BOOL _fIconPrev;
    BOOL _fShownInTray;
    CTrayIconWnd *_ptiwnd;

    DWORD _dwThreadFocus;
    GUID _guidBtnItem;

    RECT _rcClick;
    POINT _ptClick;
};

//////////////////////////////////////////////////////////////////////////////
//
// CButtonIconItem
//
//////////////////////////////////////////////////////////////////////////////

class CButtonIconItem : public CTrayIconItem
{
public:
    CButtonIconItem(CTrayIconWnd *ptiwnd, BOOL fMenuButtonItem);
    ~CButtonIconItem();

    virtual BOOL OnMsg(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnDelayMsg(UINT uMsg);

protected:
    BOOL _fMenuButtonItem;
};

//////////////////////////////////////////////////////////////////////////////
//
// CMainIconItem
//
//////////////////////////////////////////////////////////////////////////////

class CMainIconItem : public CButtonIconItem
{
public:
    CMainIconItem(CTrayIconWnd *ptiwnd) : CButtonIconItem(ptiwnd, TRUE) {}
    ~CMainIconItem() {}

    BOOL Init(HWND hwnd)
    {
        return _Init(hwnd, 
                     WM_TIW_MAINICON, 
                     TIW_INDICATOR_ID_MAIN, 
                     GUID_LBI_TRAYMAIN);
    }

    virtual BOOL OnDelayMsg(UINT uMsg);
    HKL _hkl;
};

//////////////////////////////////////////////////////////////////////////////
//
// CTrayIconWnd
//
//////////////////////////////////////////////////////////////////////////////

class CTrayIconWnd
{
public:
    CTrayIconWnd();
    ~CTrayIconWnd();

    HWND CreateWnd();
    HWND GetWnd() {return _hWnd;}
    void DestroyWnd() 
    {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }

    static BOOL RegisterClass();
    BOOL SetMainIcon(HKL hkl);
    HWND GetNotifyWnd() 
    {
        if (!IsWindow(_hwndNotify))
            FindTrayEtc();

        return _hwndNotify;
    }

    BOOL SetIcon(REFGUID rguid, BOOL fMenu, HICON hIcon, const WCHAR *pszToolTip);

    void RemoveAllIcon(DWORD dwFlags)
    {
        int i;
        for (i = 0;i < _rgIconItems.Count(); i++)
        {
            CTrayIconItem *pItem = _rgIconItems.Get(i);

            if (dwFlags & TIW_RAI_LEAVELANGICON)
            {
                if (IsEqualGUID(*pItem->GetGuid(), GUID_LBI_INATITEM) ||
                    IsEqualGUID(*pItem->GetGuid(), GUID_LBI_CTRL))
                    continue;
            }

            if (dwFlags & TIW_RAI_LEAVEKEYBOARDICON)
            {
                if (IsEqualGUID(*pItem->GetGuid(), GUID_TFCAT_TIP_KEYBOARD))
                    continue;
            }

            if (pItem->GetID() >=  TIW_INDICATOR_ID_START)
                pItem->RemoveIcon();
        }
        return;
    }

    BOOL IsShownInTray(REFGUID rguid)
    {
        CTrayIconItem *pItem = FindIconItem(rguid);
        return pItem ? pItem->IsShownInTray() : FALSE;
    }

    void RemoveUnusedIcons(CPtrArray<CTipbarItem> *prgItem);

    BOOL _fShowExtraIcons;
    BOOL _fInTrayMenu;
    UINT _uCurCallbackMessage;
    UINT _uCurMouseMessage;
    void CallOnDelayMsg();

    DWORD GetThreadIdTray() {return _dwThreadIdTray;}
    DWORD GetThreadIdProgman() {return _dwThreadIdProgman;}

private:
    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HWND _hWnd;
    static const char _szWndClass[];

    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        if (lParam)
            SetWindowLongPtr(hWnd, GWLP_USERDATA, 
                          (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
        else
            SetWindowLongPtr(hWnd, GWLP_USERDATA, 0);
    }

    static CTrayIconWnd *GetThis(HWND hWnd)
    {
        return (CTrayIconWnd *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    }

    static BOOL CALLBACK EnumChildWndProc(HWND hwnd, LPARAM lParam);
    BOOL FindTrayEtc();

    HKL _hklCurrent;
    HICON _hiconWin32Current;
    HWND  _hwndTray;
    HWND  _hwndNotify;
    DWORD _dwThreadIdTray;
    DWORD _dwThreadIdForIcon;
    HWND  _hwndProgman;
    DWORD _dwThreadIdProgman;

    BOOL OnIconMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    CMainIconItem *_ptiiMain;

    CPtrArray<CTrayIconItem> _rgIconItems;

    CTrayIconItem *FindIconItem(REFGUID rguid)
    {
        int i;
        for (i = 0;i < _rgIconItems.Count(); i++)
        {
            CTrayIconItem *pItem = _rgIconItems.Get(i);
            if (IsEqualGUID(rguid, *pItem->GetGuid()))
                return pItem;
        }
        return NULL;
    }

    UINT _uNextMsg;
    UINT _uNextID;

};

#endif //UTBTRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\muilib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <windows.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <ole2.h>
#include <advpub.h>
#include <ccstock.h>
#include <debug.h>
#include <inetreg.h>
#include <ocidl.h>
#include <comcat.h>
#include <olectl.h>
#include <mlang.h>
#include "msctf.h"
#include "osver.h" // must be last
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\muilib\mui.cpp ===
#include "private.h"
#include "mui.h"
#include "immxutil.h"
#include "ciccs.h"

struct Tag_MuiInfo
{
    HINSTANCE   hinstLocRes;
    HINSTANCE   hinstOrg;
    TCHAR       szLocResDll[MAX_PATH];
    TCHAR       szCodePage[10];
    DWORD       dwCodePage;
    BOOL        fLoaded;
} g_muiInfo;

typedef struct
{
    LANGID langid;
    BOOL fFoundLang;
} ENUMLANGDATA;

typedef BOOL (WINAPI *PFNGETFILEVERSIONINFO)(LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef DWORD (WINAPI *PFNGETFILEVERSIONINFOSIZE)(LPTSTR lptstrFilename, LPDWORD lpdwHandle);
typedef BOOL (WINAPI *PFNVERQUERYVALUE)(const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);

static struct
{
    PFNGETFILEVERSIONINFO pfnGetFileVersionInfo;
    PFNGETFILEVERSIONINFOSIZE pfnGetFileVersionInfoSize;
    PFNVERQUERYVALUE pfnVerQueryValue;
} g_VersionFuncTbl = { 0 };

static HINSTANCE g_hVersion = NULL;

CCicCriticalSectionStatic g_csMuiLib;

static BOOL g_bEnableMui = FALSE;

const TCHAR c_szMuiDir[] = TEXT("\\mui\\fallback\\");
const TCHAR c_szMuiExt[] = TEXT(".mui");
const TCHAR c_szVerTranslate[] = TEXT("\\VarFileInfo\\Translation");

#define VERSIONSIZE     11
#define VERSION_MINOR_INDEX     9

typedef UINT (WINAPI *PFNGETSYSTEMWINDOWSDIRECTORY) (LPSTR lpBuffer, UINT uSize);
static PFNGETSYSTEMWINDOWSDIRECTORY pfnGetSystemWindowsDirectory = NULL;


BOOL GetFileVersionString(LPSTR pszFileName, LPTSTR pszVerStr, UINT uVerStrLen);

////////////////////////////////////////////////////////////////////////////
//
//  MuiResAssure
//
////////////////////////////////////////////////////////////////////////////

__inline void MuiResAssure()
{
    if(g_bEnableMui && g_muiInfo.hinstLocRes == NULL && !g_muiInfo.fLoaded)
    {
        g_muiInfo.hinstLocRes = MuiLoadLibrary(g_muiInfo.szLocResDll,
                                                g_muiInfo.hinstOrg);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MuiLoadResource
//
////////////////////////////////////////////////////////////////////////////

void MuiLoadResource(HINSTANCE hinstOrg, LPTSTR pszLocResDll)
{
    LANGID langRes = 0;

    InitOSVer();

    if (!g_csMuiLib.Init())
        return;

    if (!IsOnNT51())
        g_bEnableMui = TRUE;

    if (g_muiInfo.hinstLocRes == NULL)
    {
        if (g_bEnableMui)
        {
            g_muiInfo.hinstOrg = hinstOrg;

            StringCchCopy(g_muiInfo.szLocResDll,
                          ARRAYSIZE(g_muiInfo.szLocResDll),
                          pszLocResDll);
        }
        else
        {
            g_muiInfo.hinstLocRes = hinstOrg;
        }
    }

    langRes = GetPlatformResourceLangID();

    GetLocaleInfo(MAKELCID(langRes, SORT_DEFAULT),
                  LOCALE_IDEFAULTANSICODEPAGE,
                  g_muiInfo.szCodePage,
                  ARRAYSIZE(g_muiInfo.szCodePage));

    if (!AsciiToNumDec(g_muiInfo.szCodePage, &g_muiInfo.dwCodePage) ||
        IsValidCodePage(g_muiInfo.dwCodePage) == 0)
    {
        g_muiInfo.dwCodePage = GetACP();
    }

    g_muiInfo.fLoaded = FALSE;
}

void MuiLoadResourceW(HINSTANCE hinstOrg, LPWSTR pszLocResDll)
{
    TCHAR szResName[MAX_PATH];

    WideCharToMultiByte(1252, NULL, pszLocResDll, -1, szResName, MAX_PATH, NULL, NULL);

    return MuiLoadResource(hinstOrg, szResName);
}

////////////////////////////////////////////////////////////////////////////
//
// MuiFlushDlls
//
// Call this routine to free all loaded dlls.
// Caller can keep using mui apis, the dlls will be reloaded on demand.
////////////////////////////////////////////////////////////////////////////

void MuiFlushDlls(HINSTANCE hinstOrg)
{
    if (g_muiInfo.hinstLocRes != NULL && g_muiInfo.hinstLocRes != hinstOrg)
    {
        FreeLibrary(g_muiInfo.hinstLocRes);

        g_muiInfo.hinstLocRes = NULL;
        g_muiInfo.fLoaded = FALSE;
    }

    if (g_hVersion != NULL)
    {
        FreeLibrary(g_hVersion);
        g_hVersion = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////
//
// MuiClearResource
//
// Safe to call from dll detach.
// Call this routine to free all static resources.
// Must call MuiLoadReource again before using mui apis.
////////////////////////////////////////////////////////////////////////////

void MuiClearResource()
{
    g_csMuiLib.Delete();
}

////////////////////////////////////////////////////////////////////////////
//
//  MuiFreeResource
//
// Not safe to call from dll detach -- libraries may be freed.
////////////////////////////////////////////////////////////////////////////

void MuiFreeResource(HINSTANCE hinstOrg)
{
    MuiFlushDlls(hinstOrg);
    MuiClearResource();
}


////////////////////////////////////////////////////////////////////////////
//
//  MuiGetHinstance
//
////////////////////////////////////////////////////////////////////////////

HINSTANCE MuiGetHinstance()
{
    MuiResAssure();

    return g_muiInfo.hinstLocRes;
}

////////////////////////////////////////////////////////////////////////////
//
//  MuiLoadLibrary
//
////////////////////////////////////////////////////////////////////////////

HINSTANCE MuiLoadLibrary(LPCTSTR lpLibFileName, HMODULE hModule)
{
    HINSTANCE hResInst = NULL;
    TCHAR szTemp[10];
    TCHAR szMuiPath[MAX_PATH * 2];
    TCHAR szOrgDllPath[MAX_PATH];
    TCHAR szMuiVerStr[MAX_PATH];
    TCHAR szOrgVerStr[MAX_PATH];
    LPCTSTR lpMuiPath = NULL;
    LANGID langid;
    UINT uSize = 0;


    EnterCriticalSection(g_csMuiLib);
        
    langid = GetPlatformResourceLangID();

    // 409 is default resource langid in base dll, so we can skip the extra work
    if (langid == 0x0409)
        goto Exit;

    if (hModule)
    {
        if (GetWindowsDirectory(szMuiPath, MAX_PATH))
        {
            StringCchCat(szMuiPath, ARRAYSIZE(szMuiPath), c_szMuiDir);
            StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%04x\\"), langid);
            StringCchCat(szMuiPath, ARRAYSIZE(szMuiPath), szTemp);
            StringCchCat(szMuiPath, ARRAYSIZE(szMuiPath), lpLibFileName);
            StringCchCat(szMuiPath, ARRAYSIZE(szMuiPath), c_szMuiExt);

            if (lstrlen(szMuiPath) >= MAX_PATH*2)
                goto Exit;

        }

        if (hModule)
        {
            //
            // Get current full file path.
            //
            GetModuleFileName(hModule, szOrgDllPath, ARRAYSIZE(szOrgDllPath));
        }
        else
        {
            *szOrgDllPath = TEXT('\0');
        }
    }

    if (!(GetFileVersionString(szMuiPath, szMuiVerStr, ARRAYSIZE(szMuiVerStr)) &&
          GetFileVersionString(szOrgDllPath, szOrgVerStr, ARRAYSIZE(szOrgVerStr))))
    {
        goto Exit;
    }

    //
    // Checking the major version and ignore the minor version
    //
    if (strncmp(szMuiVerStr, szOrgVerStr, VERSION_MINOR_INDEX) != 0)
        goto Exit;

    if (!hResInst)
    {
        //hResInst = LoadLibraryEx(szMuiPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
        hResInst = LoadLibrary(szMuiPath);
    }

Exit:
    g_muiInfo.fLoaded = TRUE;

    LeaveCriticalSection(g_csMuiLib);

    return hResInst;
}


////////////////////////////////////////////////////////////////////////////
//
//  MuiLoadString
//
////////////////////////////////////////////////////////////////////////////

int MuiLoadString(HINSTANCE hinstOrg, UINT uID, LPSTR lpBuffer, INT nBufferMax)
{

    LPWSTR lpWCBuf;
    UINT cch = 0;

    lpWCBuf = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * (nBufferMax + 1));

    if (lpWCBuf && MuiLoadStringWrapW(hinstOrg, uID, lpWCBuf, nBufferMax))
    {
        cch = WideCharToMultiByte(g_muiInfo.dwCodePage, NULL, lpWCBuf, -1, lpBuffer, nBufferMax, NULL, NULL);
    }

    if (lpWCBuf)
        LocalFree(lpWCBuf);

    return cch;
}

////////////////////////////////////////////////////////////////////////////
//
//  MuiLoadStringWrapW
//
////////////////////////////////////////////////////////////////////////////

int MuiLoadStringWrapW(HINSTANCE hinstOrg, UINT uID, LPWSTR lpBuffer, UINT nBufferMax)
{
    HINSTANCE hinstLocRes;

    MuiResAssure();

    if (g_muiInfo.hinstLocRes && g_muiInfo.hinstOrg == hinstOrg)
        hinstLocRes = g_muiInfo.hinstLocRes;
    else
        hinstLocRes = hinstOrg;

    if (nBufferMax <= 0) return 0;                  // sanity check

    PWCHAR pwch;

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    HRSRC hrsrc;
    int cwch = 0;

    hrsrc = FindResourceA(hinstLocRes, (LPSTR)(LONG_PTR)(1 + uID / 16), (LPSTR)RT_STRING);
    if (hrsrc) {
        pwch = (PWCHAR)LoadResource(hinstLocRes, hrsrc);
        if (pwch) {
            /*
             *  Now skip over the strings in the resource until we
             *  hit the one we want.  Each entry is a counted string,
             *  just like Pascal.
             */
            for (uID %= 16; uID; uID--) {
                pwch += *pwch + 1;
            }
            cwch = min(*pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
        }
    }
    lpBuffer[cwch] = L'\0';                 /* Terminate the string */
    return cwch;
}


////////////////////////////////////////////////////////////////////////////
//
//  MuiDialogBoxParam
//
////////////////////////////////////////////////////////////////////////////

INT_PTR MuiDialogBoxParam(
    HINSTANCE hInstance,
    LPCTSTR lpTemplateName,
    HWND hwndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam)
{
    HRSRC hrsr;
    HGLOBAL hGlobal;
    LPDLGTEMPLATE pTemplate;
    INT_PTR iRet = -1;
    HINSTANCE hMuiInstance;

    if (!IsOnNT51() && g_muiInfo.hinstLocRes)
        hMuiInstance = g_muiInfo.hinstLocRes;
    else
        hMuiInstance = hInstance;

    if (hrsr = FindResource(hMuiInstance, lpTemplateName, RT_DIALOG))
    {
        if (hGlobal = LoadResource(hMuiInstance, hrsr))
        {
            if (pTemplate = (LPDLGTEMPLATE)LockResource(hGlobal))
            {
                if(IsOnNT())
                   iRet = DialogBoxIndirectParamW(hMuiInstance, pTemplate, hwndParent, lpDialogFunc, dwInitParam);
                else
                   iRet = DialogBoxIndirectParamA(hMuiInstance, pTemplate, hwndParent, lpDialogFunc, dwInitParam);
            }
        }
    }

    return iRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  EnumLangProc
//
////////////////////////////////////////////////////////////////////////////
BOOL
CALLBACK
EnumLangProc(
    HANDLE hModule,     // resource-module handle
    LPCTSTR lpszType,   // pointer to resource type
    LPCTSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LONG_PTR lParam     // application-defined parameter
   )
{
    ENUMLANGDATA *pLangData;

    pLangData = (ENUMLANGDATA *) lParam;

    //
    // for localized build contains multiple resource,
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time
    //
    if ((wIDLanguage == 0x409) && (pLangData->fFoundLang)) {
        return TRUE;
    }

    pLangData->langid      = wIDLanguage;
    pLangData->fFoundLang  = TRUE;

    return TRUE;        // continue enumeration
}

const TCHAR c_szKeyResLocale[] = TEXT(".Default\\Control Panel\\desktop\\ResourceLocale");
const TCHAR c_szNlsLocale[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale");

////////////////////////////////////////////////////////////////////////////
//
//  GetPlatformResourceLangID
//
////////////////////////////////////////////////////////////////////////////

LANGID GetPlatformResourceLangID(void)
{
    static LANGID langRes = 0;

    // we do this only once
    if (langRes == 0)
    {
        LANGID langidTemp = 0;
        if (IsOnNT5())  // w2k or above
        {
            HMODULE hmod = GetSystemModuleHandle(TEXT("KERNEL32"));
            FARPROC pfn  = NULL;
            if (hmod)
            {
                pfn = GetProcAddress(hmod, "GetUserDefaultUILanguage");
            }

            if (pfn)
                langidTemp = (LANGID) pfn();

        }
        else if (IsOnNT())
        {
            ENUMLANGDATA LangData = {0};
            HMODULE hmod = GetSystemModuleHandle(TEXT("ntdll.dll"));

            if (hmod)
            {
                EnumResourceLanguages(
                    hmod,
                    (LPCTSTR) RT_VERSION,
                    (LPCTSTR) UIntToPtr(1),
                    (ENUMRESLANGPROC)EnumLangProc,
                     (LONG_PTR)&LangData );

                langidTemp = LangData.langid;
            }

        }
        else if (IsOn95() || IsOn98()) // win9x, Me
        {
            HKEY hkey = NULL;
            DWORD dwCnt;
            TCHAR szLocale[128];


            dwCnt = ARRAYSIZE(szLocale);

            if (ERROR_SUCCESS 
               == RegOpenKeyEx(HKEY_USERS, c_szKeyResLocale, 0, KEY_READ, &hkey))
            {
                if (ERROR_SUCCESS==RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE)szLocale, &dwCnt))
                {
                    langidTemp = (LANGID)AsciiToNum(szLocale);
                }
            }
            else if (ERROR_SUCCESS
                 == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szNlsLocale, 0, KEY_READ, &hkey))
            {
                if (ERROR_SUCCESS==RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE)szLocale, &dwCnt))
                {
                    langidTemp = (LANGID)AsciiToNum(szLocale);
                }
            }

            RegCloseKey(hkey);
        }
        if (!langidTemp)
        {
            langidTemp = GetSystemDefaultLangID();
        }

        EnterCriticalSection(g_csMuiLib);
        
        langRes = langidTemp;

        LeaveCriticalSection(g_csMuiLib);
    }
    return langRes;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetFileVersionString
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFileVersionString(LPTSTR pszFileName, LPTSTR pszVerStr, UINT uVerStrLen)
{
    BOOL bRet = FALSE;
    DWORD dwVerHandle;
    DWORD dwVerInfoSize;
    LPVOID lpVerData = NULL;
    LANGID langid;

    // for perf, since we only execute this code once or zero times
    // per process, we'll do an explicit LoadLibrary instead of
    // statically linking
    if (g_hVersion == NULL)
    {
        if ((g_hVersion = LoadSystemLibrary(TEXT("version.dll"))) == NULL)
            return FALSE;

        g_VersionFuncTbl.pfnGetFileVersionInfo = (PFNGETFILEVERSIONINFO)GetProcAddress(g_hVersion, TEXT("GetFileVersionInfoA"));
        g_VersionFuncTbl.pfnGetFileVersionInfoSize = (PFNGETFILEVERSIONINFOSIZE)GetProcAddress(g_hVersion, TEXT("GetFileVersionInfoSizeA"));
        g_VersionFuncTbl.pfnVerQueryValue = (PFNVERQUERYVALUE)GetProcAddress(g_hVersion, TEXT("VerQueryValueA"));
    }

    if (g_VersionFuncTbl.pfnGetFileVersionInfo == NULL ||
        g_VersionFuncTbl.pfnGetFileVersionInfoSize == NULL ||
        g_VersionFuncTbl.pfnVerQueryValue == NULL)
    {
        return FALSE;
    }

    langid = GetPlatformResourceLangID();

    dwVerInfoSize = g_VersionFuncTbl.pfnGetFileVersionInfoSize(pszFileName, &dwVerHandle);

    if (dwVerInfoSize)
    {
        int i;
        UINT cbTranslate;
        UINT cchVer = 0;
        LPDWORD lpTranslate;
        LPTSTR lpszVer = NULL;
        TCHAR   szVerName[MAX_PATH];

        lpVerData = LocalAlloc(LPTR, dwVerInfoSize);

        g_VersionFuncTbl.pfnGetFileVersionInfo(pszFileName, dwVerHandle, dwVerInfoSize, lpVerData);

        szVerName[0] = TEXT('\0');

        if (g_VersionFuncTbl.pfnVerQueryValue(lpVerData, (LPTSTR)c_szVerTranslate, (LPVOID*)&lpTranslate, &cbTranslate))
        {
            cbTranslate /= sizeof(DWORD);

            for (i = 0; (UINT) i < cbTranslate; i++)
            {
                if (LOWORD(*(lpTranslate + i)) == langid)
                {
                    StringCchPrintf(szVerName, ARRAYSIZE(szVerName), TEXT("\\StringFileInfo\\%04X%04X\\"), LOWORD(*(lpTranslate + i)), HIWORD(*(lpTranslate + i)));
                    break;
                }
            }
        }

        if (szVerName[0] == TEXT('\0'))
        {
            StringCchCopy(szVerName, ARRAYSIZE(szVerName), TEXT("\\StringFileInfo\\040904B0\\"));
        }

        StringCchCat(szVerName, ARRAYSIZE(szVerName), TEXT("FileVersion"));

        if (g_VersionFuncTbl.pfnVerQueryValue(lpVerData, szVerName, (LPVOID*)&lpszVer, &cchVer))
        {
            StringCchCopy(pszVerStr, uVerStrLen, lpszVer);
            *(pszVerStr + VERSIONSIZE) = TEXT('\0');

            bRet = TRUE;
        }

        if (lpVerData)
            LocalFree((HANDLE)lpVerData);
    }

    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUIACP
//
////////////////////////////////////////////////////////////////////////////

DWORD GetUIACP()
{
    if (!(g_muiInfo.dwCodePage))
    {
        LANGID langRes = 0;

        langRes = GetPlatformResourceLangID();

        GetLocaleInfo(MAKELCID(langRes, SORT_DEFAULT),
                      LOCALE_IDEFAULTANSICODEPAGE,
                      g_muiInfo.szCodePage,
                      ARRAYSIZE(g_muiInfo.szCodePage));

        if (!AsciiToNumDec(g_muiInfo.szCodePage, &g_muiInfo.dwCodePage))
        {
            g_muiInfo.dwCodePage = GetACP();
        }
    }

    if (IsValidCodePage(g_muiInfo.dwCodePage) == 0)
        g_muiInfo.dwCodePage = GetACP();

    return g_muiInfo.dwCodePage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\msutb\utbtray.cpp ===
//
// utbtray.cpp
//

#include "private.h"
#include "globals.h"
#include "utbtray.h"
#include "inatlib.h"
#include "xstring.h"
#include "inatlib.h"
#include "tipbar.h"
#include "shlapip.h"
#include "nuiinat.h"
#include "resource.h"
#include "cresstr.h"
#include "cregkey.h"
#include "nuiinat.h"
#include "dlgs.h"

HICON WINAPI TF_GetLangIcon(WORD langid , WCHAR *psz, UINT cchMax);

const char CTrayIconWnd::_szWndClass[] = "CTrayIconWndClass";
extern UINT  g_wmTaskbarCreated;
extern CTipbarWnd *g_pTipbarWnd;

/* e0b724e9-6f76-45f7-b4c1-b1c0fabce23e */
const GUID GUID_LBI_TRAYMAIN = { 
    0xe0b724e9,
    0x6f76,
    0x45f7,
    {0xb4, 0xc1, 0xb1, 0xc0, 0xfa, 0xbc, 0xe2, 0x3e}
  };


//////////////////////////////////////////////////////////////////////////////
//
// CTrayIconItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTrayIconItem::CTrayIconItem(CTrayIconWnd *ptiwnd)
{
    _fIconPrev = FALSE;
    _ptiwnd = ptiwnd;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTrayIconItem::~CTrayIconItem()
{
    RemoveIcon();
}


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CTrayIconItem::_Init(HWND hwnd, UINT uCallbackMessage, UINT uID, REFGUID rguid)
{
    _hwnd = hwnd;
    _uCallbackMessage = uCallbackMessage;
    _uID = uID;
    _guidBtnItem = rguid;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

BOOL CTrayIconItem::SetIcon(HICON hIcon,  const WCHAR *pszTooltip)
{
    DWORD dwMessage;

    if (!hIcon)
        return FALSE;

    if (!_fIconPrev)
        dwMessage = NIM_ADD;
    else
        dwMessage = NIM_MODIFY;

    if (IsOnNT())
    {
        NOTIFYICONDATAW tndw;
        tndw.cbSize           = sizeof(NOTIFYICONDATAW);
        tndw.hWnd             = _hwnd;
        tndw.uCallbackMessage = _uCallbackMessage;
        tndw.uID              = _uID;
        tndw.uFlags           = NIF_MESSAGE | NIF_ICON;
        tndw.hIcon = hIcon;
        if (pszTooltip)
        {
            tndw.uFlags |= NIF_TIP;
            StringCchCopyW(tndw.szTip, ARRAYSIZE(tndw.szTip), pszTooltip);
        }
        Shell_NotifyIconW(dwMessage, &tndw);
    }
    else
    {
        NOTIFYICONDATA tnd;
        tnd.cbSize           = sizeof(NOTIFYICONDATA);
        tnd.hWnd             = _hwnd;
        tnd.uCallbackMessage = _uCallbackMessage;
        tnd.uID              = _uID;
        tnd.uFlags           = NIF_MESSAGE | NIF_ICON;
        tnd.hIcon = hIcon;
        if (pszTooltip)
        {
            tnd.uFlags |= NIF_TIP;
            StringCchCopyA(tnd.szTip, ARRAYSIZE(tnd.szTip), WtoA(pszTooltip));
        }
        Shell_NotifyIcon(dwMessage, &tnd);
    }

    _fIconPrev = TRUE;
    _fShownInTray = TRUE;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// RemoveIcon
//
//----------------------------------------------------------------------------

BOOL CTrayIconItem::RemoveIcon()
{
    NOTIFYICONDATA tnd;

    if (_fIconPrev) // this check is esp useful because we delay load shell32.dll
    {
        tnd.cbSize           = sizeof(NOTIFYICONDATA);
        tnd.hWnd             = _hwnd;
        tnd.uCallbackMessage = _uCallbackMessage;
        tnd.uID              = _uID;
        tnd.uFlags           = NIF_MESSAGE | NIF_ICON | NIF_TIP;
        tnd.hIcon            = NULL;
        tnd.szTip[0]         = '\0';

        Shell_NotifyIcon(NIM_DELETE, &tnd);
    }

    _fIconPrev = FALSE;
    _fShownInTray = FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UpdateMenuRectPoint
//
//----------------------------------------------------------------------------

BOOL CTrayIconItem::UpdateMenuRectPoint()
{
    HWND hwndNotify = _ptiwnd->GetNotifyWnd();
    GetClientRect(hwndNotify, &_rcClick);
    ClientToScreen(hwndNotify, (LPPOINT)&_rcClick.left);
    ClientToScreen(hwndNotify, (LPPOINT)&_rcClick.right);

    GetCursorPos(&_ptClick);
    // *ppt = *(LPPOINT)prc;
    // MapWindowPoints(hwndNotify, NULL, ppt, 2);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CButtonIconItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CButtonIconItem::CButtonIconItem(CTrayIconWnd *ptiwnd, BOOL fMenuButtonItem) : CTrayIconItem(ptiwnd)
{
    _fMenuButtonItem = fMenuButtonItem;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CButtonIconItem::~CButtonIconItem()
{
}

//+---------------------------------------------------------------------------
//
// OnMsg
//
//----------------------------------------------------------------------------

BOOL CButtonIconItem::OnMsg(WPARAM wParam, LPARAM lParam)
{
    CTipbarThread *ptt;

    if ((lParam == WM_LBUTTONDOWN) || (lParam == WM_RBUTTONDOWN) ||
        (lParam == WM_LBUTTONDBLCLK) || (lParam == WM_RBUTTONDBLCLK))
    {
        if (_ptiwnd->_fInTrayMenu)
           return FALSE;

        g_pTipbarWnd->CancelMenu();
        _ptiwnd->_uCurCallbackMessage = _uCallbackMessage;
        _ptiwnd->_uCurMouseMessage = (UINT)lParam;
        ::KillTimer(_ptiwnd->GetWnd(), TRAYICONWND_TIMER_ONDELAYMSG);
        ::SetTimer(_ptiwnd->GetWnd(), TRAYICONWND_TIMER_ONDELAYMSG, g_uTimerElapseTRAYWNDONDELAYMSG, NULL);

        ptt = g_pTipbarWnd->GetFocusThread();

        g_pTipbarWnd->RestoreLastFocus(&_dwThreadFocus, TRUE);

        if (ptt && (ptt->_dwThreadId == _dwThreadFocus))
            g_pTipbarWnd->SetWaitNotifyThread(_dwThreadFocus);
        else
            g_pTipbarWnd->SetWaitNotifyThread(0);


        UpdateMenuRectPoint();
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// OnDelayMsg
//
//----------------------------------------------------------------------------

BOOL CButtonIconItem::OnDelayMsg(UINT uMsg)
{
    CTipbarThread *ptt;
    CTipbarButtonItem *pLangBtn;
    BOOL bRet = FALSE;

    _ptiwnd->_fInTrayMenu = TRUE;

    Assert((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN) ||
           (uMsg == WM_LBUTTONDBLCLK) || (uMsg == WM_RBUTTONDBLCLK));

    g_pTipbarWnd->SetWaitNotifyThread(0);
    if (!_dwThreadFocus)
    {
        //
        // we failed to set foreground at OnMsg.
        // so we try again here.
        //
        g_pTipbarWnd->RestoreLastFocus(&_dwThreadFocus, TRUE);
        // if (!_dwThreadFocus)
        // {
           //
           // ok now we give up to restore focus.
           //
           // MessageBeep(0);
           // goto Exit;
        // }
    }
    _dwThreadFocus = 0;

    ptt = g_pTipbarWnd->GetFocusThread();
    if (!ptt)
        goto Exit;

    if (g_pTipbarWnd->IsInItemChangeOrDirty(ptt))
    {
        ::KillTimer(_ptiwnd->GetWnd(), TRAYICONWND_TIMER_ONDELAYMSG);
        ::SetTimer(_ptiwnd->GetWnd(), TRAYICONWND_TIMER_ONDELAYMSG, g_uTimerElapseTRAYWNDONDELAYMSG, NULL);
        goto Exit;
    }
    
    pLangBtn = (CTipbarButtonItem *)(ptt->GetItem(_guidBtnItem));
    if (!pLangBtn)
    {
        if (IsEqualGUID(_guidBtnItem, GUID_LBI_CTRL))
        {
            pLangBtn = (CTipbarButtonItem *)(ptt->GetItem(GUID_LBI_INATITEM));
            if (!pLangBtn)
                goto Exit;
        }
        else
        {
            //
            // In this case, it is MSUTB's CLBarInatItem.
            //
            bRet = TRUE;
            goto Exit;
        }
    }

    if (uMsg == WM_LBUTTONDOWN)
    {
        if (_fMenuButtonItem)
        {
            g_pTipbarWnd->CancelMenu();
            pLangBtn->DoModalMenu(&_ptClick, &_rcClick);
        }
        else
        {
            pLangBtn->OnLeftClick();
        }
    }
    else if (uMsg == WM_RBUTTONDOWN)
    {
        if (IsEqualGUID(_guidBtnItem, GUID_LBI_CTRL) ||
            IsEqualGUID(_guidBtnItem, GUID_TFCAT_TIP_KEYBOARD))
        {
            g_pTipbarWnd->ShowContextMenu(_ptClick, &_rcClick, TRUE);
        }
        else
        {
            pLangBtn->OnRightClick();
        }
    }
    else if (uMsg == WM_LBUTTONDBLCLK)
    {
        if (IsEqualGUID(_guidBtnItem, GUID_LBI_CTRL))
        {
            g_pTipbarWnd->GetLangBarMgr()->ShowFloating(TF_SFT_SHOWNORMAL);
        }
    }

    bRet = TRUE;

Exit:
    _ptiwnd->_fInTrayMenu = FALSE;
    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CMainIconItem
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// OnDelayMsg
//
//----------------------------------------------------------------------------

BOOL CMainIconItem::OnDelayMsg(UINT uMsg)
{
    BOOL bRet = CButtonIconItem::OnDelayMsg(uMsg);

    if (!bRet)
        return bRet;

    if (uMsg == WM_LBUTTONDBLCLK) 
    {
        if (g_pTipbarWnd->_fIsItemShownInFloatingToolbar)
            g_pTipbarWnd->GetLangBarMgr()->ShowFloating(TF_SFT_SHOWNORMAL);
    }
    else if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN))
    {
        g_pTipbarWnd->ShowContextMenu(_ptClick, &_rcClick, (uMsg == WM_RBUTTONDOWN));
    }

    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CTrayIconWnd
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTrayIconWnd::CTrayIconWnd()
{
    _uNextMsg = WM_TIW_START;
    _uNextID = TIW_INDICATOR_ID_START;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CTrayIconWnd::~CTrayIconWnd()
{
    int nCnt = _rgIconItems.Count();
    int i;


    for ( i = 0; i < nCnt; i++)
    {
        CTrayIconItem *pItem = _rgIconItems.Get(i);
        delete pItem;
    }

}

//+---------------------------------------------------------------------------
//
// CreateWnd
//
//----------------------------------------------------------------------------

HWND CTrayIconWnd::CreateWnd()
{
    _hWnd = CreateWindowEx(0, _szWndClass, TEXT(""), 
                           WS_DISABLED, 
                           0, 0, 0, 0, 
                           NULL, 0, g_hInst, this);


    FindTrayEtc();

    CTrayIconItem **ppItem;

    _ptiiMain = new CMainIconItem(this);
    if (_ptiiMain)
    {
        _ptiiMain->Init(_hWnd);
        ppItem = _rgIconItems.Append(1);
        if (ppItem)
            *ppItem = _ptiiMain;
    }

    return _hWnd;
}

//+---------------------------------------------------------------------------
//
// RegisterClass
//
//----------------------------------------------------------------------------

BOOL CTrayIconWnd::RegisterClass()
{
    WNDCLASSEX wc;

    memset(&wc, 0, sizeof(wc));
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_HREDRAW | CS_VREDRAW ;
    wc.hInstance     = g_hInst;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.lpfnWndProc   = _WndProc;
    wc.lpszClassName = _szWndClass;
    ::RegisterClassEx(&wc);

    return TRUE;
}

//---------------------------------------------------------------------------
//
//  BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam)
//
//  Look at the class names using GetClassName to see if you can find the
//  Tray notification Window.
//
//---------------------------------------------------------------------------

static TCHAR szNotifyWindow[] = TEXT("TrayNotifyWnd");
BOOL CALLBACK CTrayIconWnd::EnumChildWndProc(HWND hwnd, LPARAM lParam)
{
    char    szString[50];
    CTrayIconWnd *_this = (CTrayIconWnd *)lParam;

    GetClassName(hwnd, (LPSTR) szString, sizeof(szString));

    if (0 == lstrcmp(szString, szNotifyWindow))
    {
        _this->_hwndNotify = hwnd;
        return FALSE;
    }

    return TRUE;
}

BOOL CTrayIconWnd::FindTrayEtc()
{
    _hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);

    if (!_hwndTray)
    {
        return FALSE;
    }

    EnumChildWindows(_hwndTray, (WNDENUMPROC)EnumChildWndProc, (LPARAM)this);

    if (!_hwndNotify)
    {
        return FALSE;
    }

    _dwThreadIdTray = GetWindowThreadProcessId(_hwndTray, NULL);

    _hwndProgman = FindWindow("Progman", NULL);
    _dwThreadIdProgman = GetWindowThreadProcessId(_hwndProgman, NULL);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
//----------------------------------------------------------------------------

void CTrayIconWnd::CallOnDelayMsg()
{
    int nCnt = _rgIconItems.Count();
    int i;
    BOOL bRet = FALSE;

    CTrayIconItem *pItem = NULL;
    for ( i = 0; i < nCnt; i++)
    {
        CTrayIconItem *pItemTemp = _rgIconItems.Get(i);
        if (_uCurCallbackMessage == pItemTemp->GetMsg())
        {
            pItem = pItemTemp;
            break;
        }
    }

    if (!pItem)
        return;

    pItem->OnDelayMsg(_uCurMouseMessage);
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK CTrayIconWnd::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTrayIconWnd *_this;

    switch (uMsg)
    {
        case WM_CREATE:
            SetThis(hWnd, lParam);
            break;

        case WM_DESTROY:
            SetThis(hWnd, 0);
            break;

        case WM_TIMER:
            {
                if (wParam == TRAYICONWND_TIMER_ONDELAYMSG)
                {
                    ::KillTimer(hWnd, TRAYICONWND_TIMER_ONDELAYMSG);
                    _this = GetThis(hWnd);

                    if (_this)
                        _this->CallOnDelayMsg();
                }
            }
            break;

        default:
            if (uMsg >= WM_USER)
            {
                _this = GetThis(hWnd);
            
                if (!_this || !_this->OnIconMessage(uMsg, wParam, lParam))
                    return DefWindowProc(hWnd, uMsg, wParam, lParam);
            }
            else
            {
                return DefWindowProc(hWnd, uMsg, wParam, lParam);
            }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
// SetMainIcon
//
//----------------------------------------------------------------------------

BOOL CTrayIconWnd::SetMainIcon(HKL hkl)
{
    if (hkl)
    {
        HICON hIcon;
        WCHAR wsz[64];

        if (hkl == _ptiiMain->_hkl)
            return TRUE;
        
        hIcon = TF_GetLangIcon((LANGID)HandleToUlong(hkl),  wsz, ARRAYSIZE(wsz));

        if (hIcon)
        {
            _ptiiMain->SetIcon(hIcon, wsz);
            DestroyIcon(hIcon);
        }
        else
            _ptiiMain->SetIcon(LoadIcon(g_hInst, 
                                        MAKEINTRESOURCE(ID_ICON_CONTROLBTN)), 
                               CRStr(IDS_CONTROLBTN));
        _ptiiMain->_hkl = hkl;
    }
    else
    {
        _ptiiMain->RemoveIcon();
        _ptiiMain->_hkl = NULL;
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// OnIconMessage
//
//----------------------------------------------------------------------------

BOOL CTrayIconWnd::OnIconMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int nCnt = _rgIconItems.Count();
    int i;
    BOOL bRet = FALSE;

    if (g_pTipbarWnd)
        g_pTipbarWnd->AttachFocusThread();

    for ( i = 0; i < nCnt; i++)
    {
        CTrayIconItem *pItem = _rgIconItems.Get(i);
        if (uMsg == pItem->GetMsg())
        {
            pItem->OnMsg(wParam, lParam);
            bRet = TRUE;
            break;
        }
    }
    return bRet;
}

//+---------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

BOOL CTrayIconWnd::SetIcon(REFGUID rguid, BOOL fMenu, HICON hIcon, const WCHAR *pszToolTip)
{
    BOOL bRet;
    CTrayIconItem *pItem;
    pItem = FindIconItem(rguid);

    //
    // we don't have to create new Itom to be removed.
    //
    if (!pItem && hIcon)
    {
        CTrayIconItem **ppItem;
        pItem = new CButtonIconItem(this, fMenu);
        if (!pItem)
            return FALSE;

        pItem->_Init(GetWnd(), _uNextMsg, _uNextID, rguid);
        _uNextMsg += 2;
        _uNextID += 1;

        //
        // check if these numbers dont go over.
        //
        Assert(_uNextMsg >= WM_USER);
        Assert(_uNextMsg < WM_APP);
        Assert(_uNextID < 0x8000000);

        ppItem = _rgIconItems.Append(1);
        if (ppItem)
            *ppItem = pItem;
    }

    if (!pItem)
        return FALSE;

    if (hIcon)
       bRet = pItem->SetIcon(hIcon, pszToolTip);
    else
       bRet = pItem->RemoveIcon();

    return bRet;
}

//+---------------------------------------------------------------------------
//
// RemoveUnusedIcons
//
//----------------------------------------------------------------------------

void CTrayIconWnd::RemoveUnusedIcons(CPtrArray<CTipbarItem> *prgItem)
{
    int i,j;
    for (i = 0;i < _rgIconItems.Count(); i++)
    {
        CTrayIconItem *pItem = _rgIconItems.Get(i);
        BOOL fFound;

        if (IsEqualGUID(GUID_LBI_TRAYMAIN, *pItem->GetGuid()))
            continue;

        fFound = FALSE;

        for (j = 0;j < prgItem->Count(); j++)
        {
             CTipbarItem *pTipbarItem = prgItem->Get(j);

             //
             // in case, this item is in tray icon...
             // The item may be "show satus" in other thread.
             //
             // if (!pTipbarItem->IsShown())
             //     continue;
            
             if (IsEqualGUID(*pTipbarItem->GetGUID(), *pItem->GetGuid()))
             {
                 fFound = TRUE;
                 break;
             }
        }

        if (!fFound)
        {
             pItem->RemoveIcon();
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\isos.cpp ===
#include "private.h"
#include "proj.h"

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
STDAPI_(BOOL) staticIsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOA s_osvi;
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;

        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);
    }

    switch (dwOS)
    {
    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId));
#endif
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_MEMPHIS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_MEMPHIS_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;

    case OS_NT4:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId)) &&
#endif
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_NT5:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\msctfp_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

/* c6debc0a-f2b2-4f17-930e-ca9faff4cd04 */
const GUID GUID_TFCAT_TIP_REFERENCE = { 
    0xc6debc0a,
    0xf2b2,
    0x4f17,
    {0x93, 0x0e, 0xca, 0x9f, 0xaf, 0xf4, 0xcd, 0x04}
  };

/* 5130a009-5540-4fcf-97eb-aad33fc0ee09 */
const GUID GUID_TFCAT_TIP_PROOFING = { 
    0x5130a009,
    0x5540,
    0x4fcf,
    {0x97, 0xeb, 0xaa, 0xd3, 0x3f, 0xc0, 0xee, 0x09}
  };

/* 7ae86bb7-262c-431e-9111-c974b6b7cac3 */
const GUID GUID_TFCAT_TIP_SMARTTAG = { 
    0x7ae86bb7,
    0x262c,
    0x431e,
    {0x91, 0x11, 0xc9, 0x74, 0xb6, 0xb7, 0xca, 0xc3}
  };

/* cc33ce20-13c6-4e88-a4b4-78f1b685c762 */
const GUID GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT = { 
    0xcc33ce20,
    0x13c6,
    0x4e88,
    {0xa4, 0xb4, 0x78, 0xf1, 0xb6, 0x85, 0xc7, 0x62}
  };

/* c0db7b30-7b78-4dac-b52a-5fd61e7b58fa */
const GUID GUID_SERVICE_TEXTSTORE = { 
    0xc0db7b30,
    0x7b78,
    0x4dac,
    {0xb5, 0x2a, 0x5f, 0xd6, 0x1e, 0x7b, 0x58, 0xfa}
  };

/* aabf7f9a-4487-4b2e-8164-e54c5fe19204 */
const GUID GUID_SERVICE_TF = { 
    0xaabf7f9a,
    0x4487,
    0x4b2e,
    {0x81, 0x64, 0xe5, 0x4c, 0x5f, 0xe1, 0x92, 0x04}
  };


/* b7a578d2-9332-438a-a403-4057d05c3958 */
const GUID GUID_COMPARTMENT_MSCANDIDATEUI_WINDOW = {
    0xb7a578d2,
    0x9332,
    0x438a,
    {0xa4, 0x3, 0x40, 0x57, 0xd0, 0x5c, 0x39, 0x58}
   };

// {F3DA8BD4-0786-49c2-8C09-6839D8B84F58}
const GUID GUID_MODEBIAS_DEFAULT = {
    0xf3da8bd4,
    0x0786,
    0x49c2,
    { 0x8c, 0x9, 0x68, 0x39, 0xd8, 0xb8, 0x4f, 0x58}
   };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\debug.c ===
//
// Debug squirty functions
//

#ifdef UNIX
// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shellib"
#define SZ_MODULE           "SHELLIB"
#endif

#define NONTOSPINTERLOCK
#include <ntosp.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "proj.h"
#include "assert.h"
#pragma  hdrstop

#include <platform.h> // LINE_SEPARATOR_STR and friends
#include <winbase.h> // for GetModuleFileNameA


#define DM_DEBUG              0

#define WINCAPI __cdecl
#define DATASEG_READONLY    ".text"	        // don't use this, compiler does this for you


// Flags for StrToIntEx
#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L


#if defined(DEBUG) || defined(PRODUCT_PROF)
// (c_szCcshellIniFile and c_szCcshellIniSecDebug are declared in debug.h)
extern CHAR const FAR c_szCcshellIniFile[];
extern CHAR const FAR c_szCcshellIniSecDebug[];
HANDLE g_hDebugOutputFile = INVALID_HANDLE_VALUE;


void ShellDebugAppendToDebugFileA(LPCSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbWrite = lstrlenA(pszOutputString);
        WriteFile(g_hDebugOutputFile, pszOutputString, cbWrite, &cbWrite, NULL);
    }
}

void ShellDebugAppendToDebugFileW(LPCWSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        char szBuf[500];

        DWORD cbWrite = WideCharToMultiByte(CP_ACP, 0, pszOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        WriteFile(g_hDebugOutputFile, szBuf, cbWrite, &cbWrite, NULL);
    }
}

#if 1 // Looking at the assertW stuff, it delegates already to assertA -- I'm not sure
      // why I really need these wrappers!  (What was broken on my build?  I don't know,
      // but obviously the stuff below was half baked -- there are still problems.)
      // So I'm removing this for now so as to not bother anyone else...  [mikesh]
      //
      // Fixed a few problems and it worked for me. (edwardp)
      //
//
// We cannot link to shlwapi, because comctl32 cannot link to shlwapi.
// Duplicate some functions here so unicode stuff can run on Win95 platforms.
//
VOID MyOutputDebugStringWrapW(LPCWSTR lpOutputString)
{
    if (staticIsOS(OS_NT))
    {
        OutputDebugStringW(lpOutputString);
        ShellDebugAppendToDebugFileW(lpOutputString);
    }
    else
    {
        char szBuf[500];

        WideCharToMultiByte(CP_ACP, 0, lpOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        OutputDebugStringA(szBuf);
        ShellDebugAppendToDebugFileA(szBuf);
    }
}
#define OutputDebugStringW MyOutputDebugStringWrapW

VOID MyOutputDebugStringWrapA(LPCSTR lpOutputString)
{
    OutputDebugStringA(lpOutputString);
    ShellDebugAppendToDebugFileA(lpOutputString);
}

#define OutputDebugStringA MyOutputDebugStringWrapA

LPWSTR MyCharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
{
    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}
#define CharPrevW MyCharPrevWrapW

int MywvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist)
{
    if (staticIsOS(OS_NT))
    {
        return wvsprintfW(pwszOut, pwszFormat, arglist);
    }
    else
    {
        char szFormat[500];
        char szOut[1024+40]; // this is how big our ach buffers are
        int iRet;

        WideCharToMultiByte(CP_ACP, 0, pwszFormat, -1, szFormat, ARRAYSIZE(szFormat), NULL, NULL);

        iRet = wvsprintfA(szOut, szFormat, arglist);

        MultiByteToWideChar(CP_ACP, 0, szOut, -1, pwszOut, 1024+40);

        return iRet;
    }
}

#define wvsprintfW MywvsprintfWrapW

int MywsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
    int iRet;
    
    va_list ArgList;
    va_start(ArgList, pwszFormat);

    iRet = MywvsprintfWrapW(pwszOut, pwszFormat, ArgList);

    va_end(ArgList);

    return iRet;
}
#define wsprintfW MywsprintfWrapW

LPWSTR lstrcpyWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    while((*pszDst++ = *pszSrc++));

    return pszDst;
}
#define lstrcpyW lstrcpyWrapW

LPWSTR lstrcatWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    return lstrcpyWrapW(pszDst + lstrlenW(pszDst), pszSrc);
}
#define lstrcatW lstrcatWrapW

#endif 


/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
static
BOOL
MyStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }

#endif

#ifdef DEBUG

EXTERN_C g_bUseNewLeakDetection = FALSE;

DWORD g_dwDumpFlags     = 0;        // DF_*

#ifdef FULL_DEBUG
DWORD g_dwTraceFlags    = TF_ERROR | TF_WARNING;     // TF_*
#ifndef BREAK_ON_ASSERTS
#define BREAK_ON_ASSERTS
#endif
#else
DWORD g_dwTraceFlags    = TF_ERROR;  // TF_*
#endif

#ifdef BREAK_ON_ASSERTS
DWORD g_dwBreakFlags    = BF_ASSERT;// BF_*
#else
DWORD g_dwBreakFlags    = 0;        // BF_*
#endif

DWORD g_dwPrototype     = 0;        
DWORD g_dwFuncTraceFlags = 0;       // FTF_*

// TLS slot used to store depth for CcshellFuncMsg indentation

static DWORD g_tlsStackDepth = TLS_OUT_OF_INDEXES;

// Hack stack depth counter used when g_tlsStackDepth is not available

static DWORD g_dwHackStackDepth = 0;

static char g_szIndentLeader[] = "                                                                                ";

static WCHAR g_wszIndentLeader[] = L"                                                                                ";


static CHAR const FAR c_szNewline[] = LINE_SEPARATOR_STR;   // (Deliberately CHAR)
static WCHAR const FAR c_wszNewline[] = TEXTW(LINE_SEPARATOR_STR);

extern CHAR const FAR c_szTrace[];              // (Deliberately CHAR)
extern CHAR const FAR c_szErrorDbg[];           // (Deliberately CHAR)
extern CHAR const FAR c_szWarningDbg[];         // (Deliberately CHAR)
extern CHAR const FAR c_szGeneralDbg[];         // (Deliberately CHAR)
extern CHAR const FAR c_szFuncDbg[];            // (Deliberately CHAR)
extern CHAR const FAR c_szMemLeakDbg[];
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszErrorDbg[]; 
extern WCHAR const FAR c_wszWarningDbg[];
extern WCHAR const FAR c_wszGeneralDbg[];
extern WCHAR const FAR c_wszFuncDbg[];
extern WCHAR const FAR c_wszMemLeakDbg[];

extern const CHAR  FAR c_szAssertMsg[];
extern CHAR const FAR c_szAssertFailed[];
extern const WCHAR  FAR c_wszAssertMsg[];
extern WCHAR const FAR c_wszAssertFailed[];

extern CHAR const FAR c_szRip[];
extern CHAR const FAR c_szRipNoFn[];
extern WCHAR const FAR c_wszRip[];
extern WCHAR const FAR c_wszRipNoFn[];

extern int GetProcessInformationA(OUT LPSTR pszBuf);
extern int GetProcessInformationW(OUT LPWSTR pszBuf);

/*-------------------------------------------------------------------------
Purpose: Adds one of the following prefix strings to pszBuf:
           "t   MODULE  "
           "err MODULE  "
           "wrn MODULE  "

         Returns the count of characters written.
*/
int
SetPrefixStringA(
    OUT LPSTR pszBuf,
    IN  DWORD dwFlags)
{
    GetProcessInformationA(pszBuf);

    if (TF_ALWAYS == dwFlags)
        lstrcatA(pszBuf, c_szTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcatA(pszBuf, c_szWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcatA(pszBuf, c_szErrorDbg);
    else if (IsFlagSet(dwFlags, TF_GENERAL))
        lstrcatA(pszBuf, c_szGeneralDbg);
    else if (IsFlagSet(dwFlags, TF_FUNC))
        lstrcatA(pszBuf, c_szFuncDbg);
    else if (IsFlagSet(dwFlags, TF_MEMORY_LEAK))
        lstrcatA(pszBuf, c_szMemLeakDbg);
    else
        lstrcatA(pszBuf, c_szTrace);
    return lstrlenA(pszBuf);
}


int
SetPrefixStringW(
    OUT LPWSTR pszBuf,
    IN  DWORD  dwFlags)
{
    GetProcessInformationW(pszBuf);

    if (TF_ALWAYS == dwFlags)
        lstrcatW(pszBuf, c_wszTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcatW(pszBuf, c_wszWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcatW(pszBuf, c_wszErrorDbg);
    else if (IsFlagSet(dwFlags, TF_GENERAL))
        lstrcatW(pszBuf, c_wszGeneralDbg);
    else if (IsFlagSet(dwFlags, TF_FUNC))
        lstrcatW(pszBuf, c_wszFuncDbg);
    else if (IsFlagSet(dwFlags, TF_MEMORY_LEAK))
        lstrcatW(pszBuf, c_wszMemLeakDbg);
    else
        lstrcatW(pszBuf, c_wszTrace);
    return lstrlenW(pszBuf);
}


static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}



// Issue (scotth): Use the Ccshell functions.  _AssertMsg and
// _DebugMsg are obsolete.  They will be removed once all the 
// components don't have TEXT() wrapping their debug strings anymore.


void 
WINCAPI 
_AssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        wvsprintfA(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_AssertMsgW(
    BOOL f, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);

        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
_AssertStrLenW(
    LPCWSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenW(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
_AssertStrLenA(
    LPCSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenA(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
WINCAPI 
_DebugMsgA(
    DWORD flag, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfA(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringA(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_DebugMsgW(
    DWORD flag, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfW(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringW(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                        // ASSERT
        }
    }
}


//
//  Smart debug functions
//



/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellAssertFailedA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside,
    BOOL bPopupAssert)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];
    int  len;

    len = GetProcessInformationA(ach);

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach+len, c_szAssertFailed, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays assertion string.

*/
BOOL
CcshellAssertFailedW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside,
    BOOL bPopupAssert)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[1024];    // Some callers use more than 256
    int  len;

    len = GetProcessInformationW(ach);

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  We can get this
    // if we get an assert in some of the W functions in shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellAssertFailedA(szFile, line, szEval, bBreakInside, bPopupAssert);
    }

    wsprintfW(ach+len, c_wszAssertFailed, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for function call trace
         messages.

*/
void
CcshellStackEnter(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth + 1));
        }
    else
        {
        g_dwHackStackDepth++;
        }
    }


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for functionc all trace
         messages.

*/
void
CcshellStackLeave(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        if (EVAL(0 < dwDepth))
            {
            EVAL(TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth - 1)));
            }
        }
    else
        {
        if (EVAL(0 < g_dwHackStackDepth))
            {
            g_dwHackStackDepth--;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the stack depth.

*/
static
DWORD
CcshellGetStackDepth(void)
    {
    DWORD dwDepth;

    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));
        }
    else
        {
        dwDepth = g_dwHackStackDepth;
        }

    return dwDepth;
    }


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellAssertMsgA
*/
void
CDECL
CcshellAssertMsgW(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellDebugMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellDebugMsgW(
    DWORD flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceW(LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_dwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringW(ach, TF_ATL);
        lstrcatW(ach, L"(ATL) ");
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);
        wvsprintfW(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringW(ach);
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellFuncMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellFuncMsgW(
    DWORD flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
    {
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
        DWORD dwStackDepth;
        LPWSTR pszLeaderEnd;
        WCHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < SIZECHARS(g_szIndentLeader))
            {
            pszLeaderEnd = &g_wszIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_wszIndentLeader[SIZECHARS(g_wszIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfW(ach, L"%s %s", c_wszTrace, g_wszIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
*/
void
CDECL
CcshellAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew
*/
void
CDECL
CcshellDebugMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceA(LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_dwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringA(ach, TF_ATL);
        lstrcatA(ach, "(ATL) ");
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
    }
}


/*----------------------------------------------------------
Purpose: Debug spew for function trace calls
*/
void
CDECL
CcshellFuncMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        DWORD dwStackDepth;
        LPSTR pszLeaderEnd;
        CHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < sizeof(g_szIndentLeader))
            {
            pszLeaderEnd = &g_szIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_szIndentLeader[sizeof(g_szIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfA(ach, "%s %s", c_szTrace, g_szIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if hrTest is a failure code.
*/
HRESULT 
TraceHR(
    HRESULT hrTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING &&
        FAILED(hrTest))
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "THR: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, hrTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return hrTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if bTest is false.
*/
BOOL 
TraceBool(
    BOOL bTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && !bTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TBOOL: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!
        }
    }
    return bTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if iTest is -1.
*/
int 
TraceInt(
    int iTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && -1 == iTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TINT: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!
        }
    }
    return iTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if pvTest is NULL.
*/
LPVOID 
TracePtr(
    LPVOID pvTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && NULL == pvTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TPTR: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!
        }
    }
    return pvTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if dwTest is a Win32 failure code.
*/
DWORD  
TraceWin32(
    DWORD dwTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING &&
        ERROR_SUCCESS != dwTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TW32: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, dwTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return dwTest;
}


/*-------------------------------------------------------------------------
Purpose: 
*/
int GetProcessInformationA(OUT LPSTR pszBuf)
{
    WCHAR buf[1024];
    int result;

    result = GetProcessInformationW(buf);

    result = WideCharToMultiByte(CP_ACP,     // code page
                                 0,          // performance and mapping flags
                                 buf,        // address of wide-char string
                                 (int)result,    // number of char string
                                 pszBuf,         // address of buffer for new string
                                 (int)MAX_PATH,  // size of buffer
                                 NULL,     // default for unmappable char
                                 NULL);    // flag set when default char
    pszBuf[result] = '\0';

    return result;
}

typedef PTEB (WINAPI* PFNNTCURRENTTEB)(VOID);

HMODULE hNtDll = NULL;
PFNNTCURRENTTEB pfnNtCurrentTeb = NULL;

int GetProcessInformationW(OUT LPWSTR pszBuf)
{
    static CONST WCHAR *wszUnknown = L"???";
    WCHAR              *pwszImage;
    ULONG              ulLenImage;

    DWORD       dwT;
    DWORD       dwP;
    DWORD       dwSession;

    if (hNtDll != (HMODULE)-1)
    {
        hNtDll = LoadLibrary(TEXT("NTDLL.DLL"));
        if (hNtDll != NULL)
        {
            pfnNtCurrentTeb = (PFNNTCURRENTTEB)GetProcAddress(hNtDll, "NtCurrentTeb");
            if (pfnNtCurrentTeb == NULL)
            {
                pfnNtCurrentTeb = NULL;
                FreeLibrary(hNtDll);
                hNtDll = (HMODULE)-1;
            }
        }
    }

    if (hNtDll == (HMODULE)-1)
        return 0;

    if (hNtDll == NULL)
        return 0;

    if (pfnNtCurrentTeb == NULL)
        return 0;

    {
        PTEB        pteb;
        PPEB        ppeb;

        if (pteb = (*pfnNtCurrentTeb)()) {
            dwT = HandleToUlong(pteb->ClientId.UniqueThread);
            dwP = HandleToUlong(pteb->ClientId.UniqueProcess);
        } else {
            dwT = dwP = 0;
        }

        if ((ppeb = NtCurrentPeb()) && ppeb->ProcessParameters != NULL) {
            /*
             * Get Pointers to the image path
             */
            pwszImage = ppeb->ProcessParameters->ImagePathName.Buffer;
            ulLenImage = (ppeb->ProcessParameters->ImagePathName.Length) / sizeof(WCHAR);

            /*
             * If the ProcessParameters haven't been normalized yet, then do it.
             */
            if (pwszImage != NULL && !(ppeb->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
                pwszImage = (PWSTR)((PCHAR)(pwszImage) + (ULONG_PTR)(ppeb->ProcessParameters));
            }

            /*
             * Munge out the path part.
             */
            if (pwszImage != NULL && ulLenImage != 0) {
                PWSTR pwszT = pwszImage + (ulLenImage - 1);
                ULONG ulLenT = 1;

                while (ulLenT != ulLenImage && *(pwszT-1) != L'\\') {
                    pwszT--;
                    ulLenT++;
                }

                pwszImage = pwszT;
                ulLenImage = ulLenT;
            }

        } else {
            pwszImage = (PWSTR)wszUnknown;
            ulLenImage = 3;
        }
    }

    {
        PPEB ppeb = NtCurrentPeb();

        dwSession = (ppeb != NULL ? ppeb->SessionId : 0);
    }

    wsprintfW(pszBuf, L"(s: %d %#lx.%lx %s) ", dwSession, dwP, dwT, pwszImage);

    return lstrlenW(pszBuf);
}

//
//  Debug .ini functions
//


#pragma data_seg(DATASEG_READONLY)

// (These are deliberately CHAR)
CHAR const FAR c_szNull[] = "";
CHAR const FAR c_szZero[] = "0";
CHAR const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
CHAR const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
CHAR const FAR c_szIniKeyFuncTraceFlags[] = "FuncTraceFlags";
CHAR const FAR c_szIniKeyDumpFlags[] = "DumpFlags";
CHAR const FAR c_szIniKeyProtoFlags[] = "Prototype";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef BOOL_INI_VALUES
/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };
#endif


#ifdef BOOL_INI_VALUES
/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
*/
BOOL
PRIVATE
IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    Assert(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TraceMsg(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
*/
void
PRIVATE
ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szCcshellIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif



/*----------------------------------------------------------
Purpose: This function converts a wide-char string to a multi-byte
         string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszAnsi will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszWide is NULL, then *ppszAnsi will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
static
BOOL
MyAnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
        {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            Assert(pszBuf);
            psz = pszBuf;
            }

        if (psz)
            {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppszAnsi = psz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


#ifdef UNICODE

/*----------------------------------------------------------
Purpose: Wide-char wrapper for StrToIntExA.

Returns: see StrToIntExA
*/
static
BOOL
MyStrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    // Most strings will simply use this temporary buffer, but AnsiFromUnicode
    // will allocate a buffer if the supplied string is bigger.
    CHAR szBuf[MAX_PATH];

    LPSTR pszString;
    BOOL bRet = MyAnsiFromUnicode(&pszString, pwszString, szBuf, SIZECHARS(szBuf));

    if (bRet)
        {
        bRet = MyStrToIntExA(pszString, dwFlags, piRet);
        MyAnsiFromUnicode(&pszString, NULL, szBuf, 0);
        }
    return bRet;
    }
#endif // UNICODE


#ifdef UNICODE
#define MyStrToIntEx        MyStrToIntExW
#else
#define MyStrToIntEx        MyStrToIntExA
#endif


const TCHAR c_szDimmWrpKey[] = TEXT("SOFTWARE\\Microsoft\\Cicero\\DebugFlag\\");

DWORD GetGlobalDebugFlag(const char *p)
{
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;
    DWORD dw = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDimmWrpKey, 0,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return dw;
    }


    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);

    if (RegQueryValueEx(hKey, p, 0, &dwType,
                        (LPBYTE)&dw, &dwSize) != ERROR_SUCCESS)
        dw = 0;

    RegCloseKey(hKey);
    return dw;
}


/*----------------------------------------------------------
Purpose: This function reads a .ini file to determine the debug
         flags to set.  The .ini file and section are specified
         by the following manifest constants:

                SZ_DEBUGINI
                SZ_DEBUGSECTION

         The debug variables that are set by this function are
         g_dwDumpFlags, g_dwTraceFlags, g_dwBreakFlags, and
         g_dwFuncTraceFlags, g_dwPrototype.

Returns: TRUE if initialization is successful
*/
BOOL
PUBLIC
CcshellGetDebugFlags(void)
    {
    CHAR szRHS[MAX_PATH];
    int val;

    // Issue (scotth): Yes, COMCTL32 exports StrToIntEx, but I
    //  don't want to cause a dependency delta and force everyone
    //  to get a new comctl32 just because they built debug.
    //  So use a local version of StrToIntEx.

    // Trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwTraceFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwTraceFlags = 3; // default to TF_ERROR and TF_WARNING trace messages
#endif

    g_dwTraceFlags |= GetGlobalDebugFlag(c_szIniKeyTraceFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyTraceFlags, g_dwTraceFlags);

    // Function trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyFuncTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwFuncTraceFlags = (DWORD)val;

    g_dwFuncTraceFlags |= GetGlobalDebugFlag(c_szIniKeyFuncTraceFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyFuncTraceFlags, g_dwFuncTraceFlags);

    // Dump Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyDumpFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwDumpFlags = (DWORD)val;

    g_dwDumpFlags |= GetGlobalDebugFlag(c_szIniKeyDumpFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyDumpFlags, g_dwDumpFlags);

    // Break Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyBreakFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwBreakFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwBreakFlags = 5; // default to break on ASSERT and TF_ERROR
#endif

    g_dwBreakFlags |= GetGlobalDebugFlag(c_szIniKeyBreakFlags);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyBreakFlags, g_dwBreakFlags);

    // Prototype Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyProtoFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwPrototype = (DWORD)val;

    // Are we using the new leak detection from shelldbg.dll?
    GetPrivateProfileStringA("ShellDbg",
                            "NewLeakDetection",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_bUseNewLeakDetection = BOOLIFY(val);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyProtoFlags, g_dwPrototype);

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "DebugOutputFile",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);
    if (szRHS != TEXT('\0'))
    {
        g_hDebugOutputFile = CreateFileA(szRHS, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    return TRUE;
    }

#endif // DEBUG

#ifdef PRODUCT_PROF

DWORD g_dwProfileCAP = 0;        

BOOL PUBLIC CcshellGetDebugFlags(void)
{
    CHAR szRHS[MAX_PATH];
    int val;

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "Profile",
                            "",
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwProfileCAP = (DWORD)val;

    return TRUE;
}
#endif // PRODUCT_PROF 


static BOOL g_fWhackPathBuffers = FALSE;
void DEBUGWhackPathBufferA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch))
        {
            ZeroMemory(psz, cch*sizeof(char));
        }
    }
}
void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch))
        {
            ZeroMemory(psz, cch*sizeof(WCHAR));
        }
    }
}
void DEBUGWhackPathStringA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch) && IS_VALID_STRING_PTRA(psz, -1))
        {
            UINT len = lstrlenA(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringA: caller of caller passed strange Path string (>MAX_PATH)");
            }
            else
            {
                ZeroMemory(psz+len, (cch-len)*sizeof(char));
            }
        }
    }
}
void DEBUGWhackPathStringW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch) && IS_VALID_STRING_PTRW(psz, -1))
        {
            UINT len = lstrlenW(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringW: caller of caller passed strange Path string (>MAX_PATH)");
            }
            else
            {
                ZeroMemory(psz+len, (cch-len)*sizeof(WCHAR));
            }
        }
    }
}


BOOL GetDebuggerCmd(char *psz)
{
    HKEY hkDebug;
    BOOL bRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"),
                                      0, KEY_READ, &hkDebug))
    {
        TCHAR szDebugger[MAX_PATH * 2];
        DWORD cbString = sizeof(szDebugger);

        if (ERROR_SUCCESS == RegQueryValueEx(hkDebug, TEXT("Debugger"), NULL,
                                 NULL, (LPBYTE) szDebugger, &cbString))
        {
            // Find the first token (which is the debugger exe name/path)

            LPTSTR pszCmdLine = szDebugger;

            if ( *pszCmdLine == TEXT('\"') )
            {
                //
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                //

                while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
                {
                    NULL;
                }

                //
                // If we stopped on a double-quote (usual case), skip
                // over it.
                //

                if ( *pszCmdLine == TEXT('\"') )
                {
                    pszCmdLine++;
                }

            }
            else 
            {
                while (*pszCmdLine > TEXT(' '))
                {
                    pszCmdLine++;
                }
            }

            // Don't need the rest of the args, etc
            *pszCmdLine = TEXT('\0');   

            // If the doctor is in, we don't allow the Debug action

            if (lstrlen(szDebugger) && 
                lstrcmpi(szDebugger, TEXT("drwtsn32")) &&
                lstrcmpi(szDebugger, TEXT("drwtsn32.exe")))
            {
                lstrcpy(psz, szDebugger);
                bRet = TRUE;
            }
        }

    }
    return bRet;
}

typedef BOOL (*ISDEBUGGERPRESENT)(void);
BOOL MyIsDebuggerPresent()
{
    HINSTANCE hInstKernel = GetModuleHandle(TEXT("kernel32"));
    ISDEBUGGERPRESENT pfn;
    pfn = (ISDEBUGGERPRESENT)GetProcAddress(hInstKernel, TEXT("IsDebuggerPresent"));
    if (!pfn)
        return TRUE;

    return (pfn)();
}

BOOL AttachDebugger(DWORD pid)
{
    DWORD dwError = ERROR_SUCCESS;
    TCHAR szCmdline[MAX_PATH * 2];
    TCHAR szDebugger[MAX_PATH * 2];

    STARTUPINFO sinfo =
    {
        sizeof(STARTUPINFO),
    };
    PROCESS_INFORMATION pinfo;

    if (MyIsDebuggerPresent())
         return TRUE;

    if (!GetDebuggerCmd(szDebugger))
        return FALSE;

    wsprintf(szCmdline, TEXT("%s -p %ld"), szDebugger, pid);
 

    if (FALSE == CreateProcess(NULL, //m_pszDebugger,
                               szCmdline,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_NEW_CONSOLE,
                               NULL,
                               NULL,
                               &sinfo,
                               &pinfo))
    {
        dwError = GetLastError();
    }
    else
    {
        WaitForInputIdle(pinfo.hProcess, 30000);
        CloseHandle(pinfo.hThread);
        CloseHandle(pinfo.hProcess);
    }


    return (ERROR_SUCCESS != dwError) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_


// get DECLSPEC_IMPORT stuff right for oleaut32.h, we are defing these
#define _OLEAUT32_      


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <advpub.h>
#include <ccstock.h>
#include <debug.h>
#include <inetreg.h>
#include <ocidl.h>
#include <comcat.h>
#include <olectl.h>
#include <mlang.h>
#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h> 
#include "msctf.h"
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\thdutil.cpp ===
//
// thread.cpp
//

#include "private.h"
#include "tlhelp32.h"
#include "osver.h"
#include "thdutil.h"
#include "vdmdbg.h"
#include "immxutil.h"

//+---------------------------------------------------------------------------
//
// Is16bit()
//
//----------------------------------------------------------------------------

typedef INT (*VDMENUMTASKWOW)(DWORD dwProcessId, TASKENUMPROC fp, LPARAM lParam);
typedef struct tag_MYENUMWOW {
    DWORD dwThreadId;
    BOOL bRet;
} MYENUMWOW;

BOOL TaskEnumProc(DWORD dwThreadId, WORD hMod16, WORD hTask16, LPARAM lParam )
{
    MYENUMWOW *pewow = (MYENUMWOW *)lParam;

    if (pewow->dwThreadId == dwThreadId)
    {
        pewow->bRet = TRUE;
        return TRUE;
    }
    return FALSE;
}

BOOL NTIs16bit(DWORD dwProcessId, DWORD dwThreadId)
{
   static VDMENUMTASKWOW fpEnumTask = NULL;

   MYENUMWOW ewow;

   if (!fpEnumTask)
   {
       HINSTANCE hMod = LoadSystemLibrary("vdmdbg.dll");
       fpEnumTask = (VDMENUMTASKWOW)GetProcAddress(hMod, "VDMEnumTaskWOW");
       if (!fpEnumTask)
           return FALSE;
   }
   ewow.dwThreadId = dwThreadId;
   ewow.bRet = FALSE;
   fpEnumTask(dwProcessId, TaskEnumProc, (LPARAM)&ewow);

   return ewow.bRet;
}

BOOL Is16bitThread(DWORD dwProcessId, DWORD dwThreadId)
{
    if (IsOnNT51())
    {
        GUITHREADINFO guiti;
        guiti.cbSize = sizeof(GUITHREADINFO);
        if (GetGUIThreadInfo(dwThreadId, &guiti))
        {
            return (guiti.flags & GUI_16BITTASK) ? TRUE : FALSE;
        }
    }
    else if (IsOnNT())
    {
        return NTIs16bit(dwProcessId, dwThreadId);
    }
    else
    {
        // Win9xEnumProcess(Win9xEnumProcessProc, NULL);
        // not implemented yet.
        Assert(0);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\thdutil.h ===
//
// thread.h
//

#if 0
typedef BOOL (*ENUMTHREAD)(DWORD dwThreadId, DWORD dwProcessId, void *pv);
BOOL EnumThreads(ENUMTHREAD pfnEnum, void *pv);
BOOL IsThreadId(DWORD dwThreadId);
DWORD GetProcessId(DWORD dwThreadId);
DWORD GetThreadInputIdle(DWORD dwProcessId, DWORD dwThreadId);
#endif

BOOL Is16bitThread(DWORD dwProcessId, DWORD dwThreadId);

#ifdef LATER
typedef BOOL (*WIN9XENUMPROCESS)(DWORD dwProcessId, void *pv);
BOOL Win9xEnumProcess(WIN9XENUMPROCESS pfnEnum, void *pv);
#endif

#if 0
typedef struct _THREADFIND {
    DWORD dwThreadId;
    DWORD dwProcessId;
    BOOL bFound;
} THREADFIND;

BOOL CALLBACK EnumThreadProc(DWORD dwThreadId, DWORD dwProcessId, THREADFIND *ptc);

typedef struct _SYSTEM_PROCESS_INFORMATION_NT4 {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SpareUl2;
    ULONG SpareUl3;
    ULONG PeakVirtualSize;
    ULONG VirtualSize;
    ULONG PageFaultCount;
    ULONG PeakWorkingSetSize;
    ULONG WorkingSetSize;
    ULONG QuotaPeakPagedPoolUsage;
    ULONG QuotaPagedPoolUsage;
    ULONG QuotaPeakNonPagedPoolUsage;
    ULONG QuotaNonPagedPoolUsage;
    ULONG PagefileUsage;
    ULONG PeakPagefileUsage;
    ULONG PrivatePageCount;
} SYSTEM_PROCESS_INFORMATION_NT4, *PSYSTEM_PROCESS_INFORMATION_NT4;

typedef struct _SYSTEM_THREAD_INFORMATION_NT4 {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} SYSTEM_THREAD_INFORMATION_NT4, *PSYSTEM_THREAD_INFORMATION_NT4;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
// #include <winsock.h>

#ifdef DEBUG
extern DWORD g_dwThreadDllMain;
#endif

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? _hinst : (_hinst = LoadLibrary(#_dll)))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UCHAR(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, unsigned char *, _fn, _args, _nargs, 0)
#define DELAY_LOAD_ULONG(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, ULONG, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    Assert(g_dwThreadDllMain != GetCurrentThreadId());  \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- OLEAUT32.DLL ---------------


HINSTANCE g_hinstOLEAUT32 = NULL;

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, RegisterTypeLib,
    (ITypeLib *ptlib, OLECHAR *szFullPath, OLECHAR *szHelpDir),
    (ptlib, szFullPath, szHelpDir));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadTypeLib,
    (const OLECHAR *szFile, ITypeLib **pptlib), (szFile, pptlib));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SetErrorInfo,
   (unsigned long dwReserved, IErrorInfo*perrinfo), (dwReserved, perrinfo));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadRegTypeLib,
    (REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib **pptlib),
    (rguid, wVerMajor, wVerMinor, lcid, pptlib));

#undef VariantClear
#undef VariantCopy

// Use QuickVariantInit instead!
//DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, VariantInit, 
//    (VARIANTARG *pvarg), (pvarg));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantClear,
    (VARIANTARG *pvarg), (pvarg));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantCopy,
    (VARIANTARG *pvargDest, VARIANTARG *pvargSrc), (pvargDest, pvargSrc));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantCopyInd,
    (VARIANT * pvarDest, VARIANTARG * pvargSrc), (pvarDest, pvargSrc));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantChangeType,
    (VARIANTARG *pvargDest, VARIANTARG *pvarSrc, unsigned short wFlags, VARTYPE vt),
    (pvargDest, pvarSrc, wFlags, vt));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringLen,
    (const OLECHAR*pch, unsigned int i), (pch, i));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocString,
    (const OLECHAR*pch), (pch));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringByteLen,
     (LPCSTR psz, UINT i), (psz, i));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringByteLen,
     (BSTR bstr), (bstr));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, SysFreeString, (BSTR bs), (bs));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, DispGetIDsOfNames,
    (ITypeInfo*ptinfo, OLECHAR **rgszNames, UINT cNames, DISPID*rgdispid),
    (ptinfo, rgszNames, cNames, rgdispid));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, CreateErrorInfo,
    (ICreateErrorInfo **pperrinfo), (pperrinfo));

DELAY_LOAD_SAFEARRAY(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayCreateVector,
    (VARTYPE vt, long iBound, ULONG cElements), (vt, iBound, cElements) );

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayAccessData,
    (SAFEARRAY * psa, void HUGEP** ppvData), (psa, ppvData));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayUnaccessData,
    (SAFEARRAY * psa), (psa) );

DELAY_LOAD_SAFEARRAY(g_hinstOLEAUT32, OLEAUT32, SafeArrayCreate,
    (VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound), (vt, cDims, rgsabound));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32, SafeArrayPutElement,
     (SAFEARRAY * psa, LONG * rgIndices, void * pv), (psa, rgIndices, pv));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetElemsize,
    (SAFEARRAY * psa), (psa) );

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetLBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plLBound),
    (psa,nDim,plLBound));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetUBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plUBound),
    (psa,nDim,plUBound));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv), (psa, rgIndices, pv));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayGetDim,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayLock,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayUnlock,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringLen,
    (BSTR bstr), (bstr));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SafeArrayDestroy,
    (SAFEARRAY * psa), (psa));

DELAY_LOAD_INT(g_hinstOLEAUT32, OLEAUT32.DLL, DosDateTimeToVariantTime,
    (USHORT wDosDate, USHORT wDosTime, DOUBLE * pvtime), (wDosDate, wDosTime, pvtime));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VarI4FromStr,
    (OLECHAR FAR * strIn, LCID lcid, DWORD dwFlags, LONG * plOut), (strIn, lcid, dwFlags, plOut));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VarUI4FromStr,
    (OLECHAR FAR * strIn, LCID lcid, DWORD dwFlags, ULONG * pulOut), (strIn, lcid, dwFlags, pulOut));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VarR8FromDec,
    (DECIMAL *pdecIn, double *pdbOut), (pdecIn, pdbOut));



#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\proj.h ===
//
// proj.h:      Main header
//
//


#ifndef __PROJ_H__
#define __PROJ_H__

#ifndef STRICT
#define STRICT
#endif

#if defined(WINNT) || defined(WINNT_ENV)

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif

#endif  // WINNT

#include <windows.h>
#include <commctrl.h>
#include <shlobj.h>
#include <debug.h>
//#include <port32.h>
#include <ccstock.h>

//#include <shsemip.h>        // for _ILNext


// Some files are compiled twice: once for unicode and once for ansi.
// There are some functions which do not want to be declared twice
// (the ones which don't use string parameters).  Otherwise we'd get
// duplicate redefinitions.
//
// These are wrapped with #ifdef DECLARE_ONCE.
#ifdef UNICODE
#define DECLARE_ONCE
#else
#undef DECLARE_ONCE
#endif


// Note that CharNext is not supported on win95.  Normally we would
// include w95wraps.h, but comctl does not link to shlwapi and
// we don't want to add this dependency.
#ifdef UNICODE
// Note that this will still break if we ever go back to non-unicode
__inline LPWSTR CharNextWrapW_(LPWSTR psz) {return ++psz;}
#undef CharNext
#define CharNext CharNextWrapW_
#endif


#endif // __PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\varutil.cpp ===
#include "private.h"
#include "varutil.h"
#include "varcomp.h"

//+---------------------------------------------------------------------------
//
// CicVarCmp
//
//----------------------------------------------------------------------------

HRESULT CicVarCmp(VARIANT *pvar1, VARIANT *pvar2)
{
    if (V_VT(pvar1) != V_VT(pvar2))
        return S_FALSE;

    FCmp comp = VariantCompare.GetComparator( (VARENUM) pvar1->vt );

    if (!comp)
        return S_FALSE;

    if (!comp( (PROPVARIANT const &)*pvar1, (PROPVARIANT const &)*pvar2 ))
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\adddelete.cpp ===
//
//
// Sapilayr TIP CAddDeleteWord implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "adddelete.h"
#include "mui.h"


WCHAR  CAddDeleteWord::m_Delimiter[MAX_DELIMITER] = {
                    0x0009,0x000A,0x000D,0x0020,
                    0x0022,0x0023,0x0025,0x0026,0x0027,0x0028,0x0029,0x002A,  // "#%&'()*
                    0x002B,0x002C,0x002D,0x002F,0x003A,0x003B,0x003C,0x003D,  // +,-/:;<=
                    0x003E,0x0040,0x005B,0x005D,0x0021,0x002E,0x003F,0x005E,  // >@[]!.?^
                    0x007B,0x007C,0x007D,0x007E,                              // {|}~
                    0x0000
};


// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CAddDeleteWord
//
// -----------------------------------------------------------------------------------------------------------

CAddDeleteWord::CAddDeleteWord(CSapiIMX *psi) 
{
    m_psi = psi;
    m_cpRangeLastUsedIP = NULL;
    m_fCurIPIsSelection = FALSE;

    _pCSpTask = NULL;

    m_fMessagePopUp = FALSE;
    m_fToOpenAddDeleteUI = FALSE;
    m_fAddDeleteUIOpened = FALSE;
    m_fInDisplayAddDeleteUI = FALSE;
}

CAddDeleteWord::~CAddDeleteWord( ) 
{

};


// This function will be called by SR SPEI_SOUND_START callback function
// It will save current selection or IP.
//
// And compare the current IP with the last saved IP, if both of them are 
// not empty, and have the same start anchor, sptip tip will pop up a 
// message box to ask if user wants to popup SR Add/Remove Word dialog UI.
//
// If Add/Delete UI is not opened, we just want to inject feedbackui as usual

HRESULT  CAddDeleteWord::SaveCurIPAndHandleAddDelete_InjectFeedbackUI( )
{
    HRESULT hr = E_FAIL;

    m_fAddDeleteUIOpened = FALSE;
    hr = m_psi->_RequestEditSession(ESCB_SAVECURIP_ADDDELETEUI, TF_ES_READWRITE);
    return hr;
}


HRESULT CAddDeleteWord::_SaveCurIPAndHandleAddDeleteUI(TfEditCookie ec, ITfContext *pic)
{
    HRESULT  hr = S_OK;
    CComPtr<ITfRange>  cpCurIP;
    CComPtr<ITfRange>  cpLastIP;
    BOOL     fEmptyLast= FALSE;
    BOOL     fEmptyCur = TRUE;

    // Save the current IP first.
#ifdef SHOW_ADD_DELETE_POPUP_MESSAGE
    // if we need to activate this code we need to move this function
    // into the hypothesis handler, otherwise we will reactivate the bug
    // Cicero 3800 - sticky ip behavior makes typing/talking impractical
    // Hence I put a non conditional assert here
    Assert(0);

    m_psi->SaveCurrentIP(ec, pic);
#endif

    // Compare current IP with last saved IP
    // If user selects the same range twice, just open SR Add/remove dialog UI

    cpCurIP = m_psi->GetSavedIP( );
    cpLastIP  = GetLastUsedIP( );

    m_fAddDeleteUIOpened = FALSE;

    if ( cpCurIP )
    {
        // Save the Org IP by cloning the current IP.
        if ( m_cpRangeOrgIP )
            m_cpRangeOrgIP.Release( );

        cpCurIP->Clone(&m_cpRangeOrgIP);

        hr = cpCurIP->IsEmpty(ec, &fEmptyCur);
    }

    m_fCurIPIsSelection = !fEmptyCur;

#ifdef SHOW_ADD_DELETE_POPUP_MESSAGE

    if ( (S_OK == hr) && m_fCurIPIsSelection && cpLastIP)
    {
        hr = cpLastIP->IsEmpty(ec, &fEmptyLast);

        if ( (S_OK == hr) && !fEmptyLast )
        {
            BOOL   fEqualStart = FALSE;
            hr = cpCurIP->IsEqualStart(ec, cpLastIP, TF_ANCHOR_START, &fEqualStart);

            if ( (S_OK == hr) && fEqualStart )
            {
                // Open the dialog UI
                if ( !m_fMessagePopUp )
                {

                    BOOL  fDictStat;

                    // If Mic status is ON, turn it off.

                    fDictStat = m_psi->GetDICTATIONSTAT_DictOnOff( );

                    if ( fDictStat == TRUE)
                    {
                        m_psi->SetDICTATIONSTAT_DictOnOff(FALSE);
                    }

                    DialogBoxParam(g_hInst, 
                                   MAKEINTRESOURCE(IDD_OPEN_ADD_DELETE),
                                   m_psi->_GetAppMainWnd(),
                                   DlgProc,
                                   (LPARAM)this);

                    if ( fDictStat )
                        m_psi->SetDICTATIONSTAT_DictOnOff(TRUE);

                    m_fMessagePopUp = TRUE;
                }

                if ( m_fToOpenAddDeleteUI )
                    hr = _HandleAddDeleteWord(ec, pic);

            }
        }
    }
#endif

#ifdef SHOW_FEEDBACK_AT_SOUNDSTART
    if ( !m_fAddDeleteUIOpened && !m_fCurIPIsSelection)
    {
        BOOL fAware =  IsFocusFullAware(m_psi->_tim);
        hr = m_psi->_AddFeedbackUI(ec, 
                                   fAware ? DA_COLOR_AWARE : DA_COLOR_UNAWARE,
                                   3);
    }
#endif

    return hr;
}


//+---------------------------------------------------------------------------
//
// DlgProc
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK CAddDeleteWord::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR  iRet = TRUE;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            SetThis(hDlg, lParam);
            break;

        case WM_COMMAND:
            GetThis(hDlg)->OnCommand(hDlg, wParam, lParam);
            break;

        default:
            iRet = FALSE;
    }

    return iRet;

}

//+---------------------------------------------------------------------------
//
// OnCommand
//
//----------------------------------------------------------------------------

BOOL CAddDeleteWord::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{

    switch (LOWORD(wParam))
    {
        case IDOK:

            m_fToOpenAddDeleteUI = TRUE;
            EndDialog(hDlg, 1);
            break;

        case IDCANCEL:

            m_fToOpenAddDeleteUI = FALSE;
            EndDialog(hDlg, 0);
            break;

        default:

            m_fToOpenAddDeleteUI = FALSE;
            return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// CAddDeleteWord::_HandleAddDeleteWord
//
// Handle Add/Delete Word UI related work.
// This function will be called when user clicks the speech language bar menu 
// and select Add/Delete Word(s)... item.
//
//---------------------------------------------------------------------------+
HRESULT CAddDeleteWord::_HandleAddDeleteWord( TfEditCookie ec,ITfContext *pic )
{

    HRESULT  hr = S_OK;
    WCHAR    *pwzNewWord=NULL;
    CComPtr<ITfRange>  cpCurRange = NULL;
    ULONG    cchSize;
    BOOL     fEmptySelection=TRUE;

    // Get the current Selection

    TraceMsg(TF_GENERAL, "_HandleAddDeleteWord is called");

    if ( pic == NULL )
        return E_FAIL;

    GetSelectionSimple(ec, pic, &cpCurRange);

    // Check to see if the current selection is empty.

    if ( cpCurRange!= NULL )
    {
        hr = cpCurRange->IsEmpty(ec, &fEmptySelection);
        
        if ( hr != S_OK )
            return hr;
    }

    // If the current Selection is not empty, we need to get the correct word to send to the Add/Remove dialog
    // as its initial word.

    if  (( cpCurRange != NULL )  &&  !fEmptySelection )
    {
          ULONG    i, j, iKeep;
          BOOL     fDelimiter;

          // Get the text of the selection.
          // Follow the below rules to get the right word.
          //
          // If the current selection is longer than MAX_SELECED wchars of string, discard the rest.
          // 
          // If there is a delimiter ( space, tab, ... ) inside the selection, take the part prior to the first
          // delimiter as the right word.

          pwzNewWord = (WCHAR *) cicMemAllocClear( (MAX_SELECTED+1) * sizeof(WCHAR) );
          if ( pwzNewWord == NULL )
          {
               hr = E_OUTOFMEMORY;
               return hr;
          }

          cchSize =  MAX_SELECTED;

          hr = cpCurRange->GetText(ec, 0, pwzNewWord, MAX_SELECTED, &cchSize);

          if ( hr  != S_OK )
          {
              // GetRangeText  returns wrong, release the allocated memory

              cicMemFree(pwzNewWord);
              return hr;
          }

          pwzNewWord[cchSize] = L'\0';

          // Get the first delimiter if there is one.
              
          fDelimiter = FALSE;
          iKeep = 0;

          for ( i=0; i < cchSize; i++)
          {
               for ( j=0; j<MAX_DELIMITER; j++)
               {
                   if ( m_Delimiter[j] == 0x0000)
                       break;
                   if  ( pwzNewWord[i] == m_Delimiter[j])
                   {
                       fDelimiter = TRUE;
                       iKeep = i;
                       break;
                   }
               }
               if (  fDelimiter == TRUE )
                   break;
          }
          if ( fDelimiter )
          {
              cchSize = iKeep;
              pwzNewWord[cchSize] = L'\0';
          }
    }
    else
    {
          pwzNewWord = NULL;
          cchSize = 0;
    }

    hr = DisplayAddDeleteUI(pwzNewWord, cchSize);

    if ( pwzNewWord != NULL )
    {
        cicMemFree(pwzNewWord);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CAddDeleteWord::_DisplayAddDeleteUI
//
// 
// Display the Add/Delete UI with pwszInitWord.
// 
//---------------------------------------------------------------------------+

HRESULT CAddDeleteWord::DisplayAddDeleteUI(WCHAR  *pwzInitWord, ULONG   cchSize)
{
    HRESULT hr = S_OK;

    if (m_fInDisplayAddDeleteUI)
    {
        return hr;
    }
    m_fInDisplayAddDeleteUI = TRUE;

    m_dstrInitWord.Clear();

    if (pwzInitWord != NULL)
        m_dstrInitWord.Append(pwzInitWord, cchSize);

    PostMessage(m_psi->_GetWorkerWnd(), WM_PRIV_ADDDELETE, 0, 0);

    return hr;
}

HRESULT CAddDeleteWord::_DisplayAddDeleteUI(void)
{
    HRESULT   hr = S_OK;
    WCHAR     pwzTitle[64];

    // Display the UI

    pwzTitle[0] = '\0';
    CicLoadStringWrapW(g_hInst, IDS_UI_ADDDELETE, pwzTitle, ARRAYSIZE(pwzTitle));

    CComPtr<ISpRecognizer>    cpRecoEngine;

    m_psi->GetSpeechTask(&_pCSpTask, FALSE);

    if ( _pCSpTask ) 
    {
        hr = _pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpRecoEngine);
        if (S_OK == hr && cpRecoEngine)
        {

            // If Mic status is ON, turn it off.
            DWORD dwDictStatBackup = m_psi->GetDictationStatBackup();

            DWORD dwBefore;
            CComPtr<ITfThreadMgr> cpTim = m_psi->_tim;

            if (S_OK != 
                GetCompartmentDWORD(cpTim, GUID_COMPARTMENT_SPEECH_DISABLED, &dwBefore, FALSE)
                )
            {
                dwBefore = 0;
            }
            SetCompartmentDWORD(m_psi->_GetId(), cpTim, GUID_COMPARTMENT_SPEECH_DISABLED, TF_DISABLE_DICTATION, FALSE);
            cpRecoEngine->DisplayUI(m_psi->_GetAppMainWnd(), pwzTitle, SPDUI_AddRemoveWord, m_dstrInitWord, m_dstrInitWord.Length() * sizeof(WCHAR));

            m_fAddDeleteUIOpened = TRUE;
            SetCompartmentDWORD(m_psi->_GetId(), cpTim, GUID_COMPARTMENT_SPEECH_DISABLED, dwBefore, FALSE);

            // After Add/Remove work is done, restore the previous Mic status.
            SetCompartmentDWORD(m_psi->_GetId(), cpTim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwDictStatBackup, FALSE);
        }
    }
    m_fInDisplayAddDeleteUI = FALSE;

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\candlist.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       candlist.cpp
//
//  Contents:   CCandidateList
//
//----------------------------------------------------------------------------

#include "private.h"
#include "ctffunc.h"
#include "candlist.h"

//////////////////////////////////////////////////////////////////////////////
//
// CCandidateString
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor, dtor
//
//----------------------------------------------------------------------------

CCandidateString::CCandidateString(ULONG nIndex, WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, ULONG ulID, HICON hIcon, WCHAR *pwzWord)
{
    _psz = new WCHAR[wcslen(psz) + 1];
    if (_psz)
        wcscpy(_psz, psz);

    _langid = langid;
    _pv = pv;

    m_bstrWord = NULL;
    if (pwzWord)
    {
        m_bstrWord = SysAllocString(pwzWord);
    }
    m_hIcon = hIcon;
    m_ulID = ulID;

    _punk = punk;
    if (_punk)
       _punk->AddRef();
    _pszRead = NULL;

    _nIndex = nIndex;
    _cRef = 1;
}

CCandidateString::~CCandidateString()
{
    if (_punk)
       _punk->Release();
    if (_psz)
        delete[] _psz;
    if(_pszRead)
        delete[] _pszRead;
    SysFreeString(m_bstrWord);
    if (m_hIcon)
        DestroyIcon(m_hIcon);
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCandidateString::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCandidateString))
    {
        *ppvObj = (ITfCandidateString *)(this);
    }
    if (m_hIcon && IsEqualIID(riid, IID_ITfCandidateStringIcon))
    {
        *ppvObj = (ITfCandidateStringIcon *)(this);
    }
    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CCandidateString::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CCandidateString::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// GetString
//
//----------------------------------------------------------------------------

HRESULT CCandidateString::GetString(BSTR *pbstr)
{
    if (!pbstr)
       return E_INVALIDARG;

    *pbstr = NULL;

    if (_psz)
    {
        *pbstr = SysAllocString(_psz);
    } 
    
    if(*pbstr)
       return S_OK;

    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetIndex
//
//----------------------------------------------------------------------------

HRESULT CCandidateString::GetIndex(ULONG *pnIndex)
{
    *pnIndex = _nIndex;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCandidateList
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor, dtor
//
//----------------------------------------------------------------------------


CCandidateList::CCandidateList(CANDLISTCALLBACK pfnCallback, ITfContext *pic, ITfRange *pRange, CANDLISTCALLBACK pfnOptionsCallback)
{
    _pfnCallback = pfnCallback;
    _pfnOptionsCallback = pfnOptionsCallback;
    _pic = pic;
    _pic->AddRef();
    _pRange = pRange;
    _pRange->AddRef();
    _cRef = 1;
}

CCandidateList::~CCandidateList()
{
    _pic->Release();
    _pRange->Release();
    while(_rgCandStr.Count())
    {
        CCandidateString *pCandString;
        pCandString = _rgCandStr.Get(0);
        _rgCandStr.Remove(0, 1);
        delete pCandString;
    }

    while(_rgOptionsStr.Count())
    {
        CCandidateString *pCandString;
        pCandString = _rgOptionsStr.Get(0);
        _rgOptionsStr.Remove(0, 1);
        delete pCandString;
    }
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCandidateList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCandidateList))
    {
        *ppvObj = (ITfCandidateList *)(this);
    }
    if (_pfnOptionsCallback && IsEqualIID(riid, IID_ITfOptionsCandidateList))
    {
        *ppvObj = (ITfOptionsCandidateList *)(this);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CCandidateList::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CCandidateList::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// EnumCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::EnumCandidates(IEnumTfCandidates **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumCandidates(this, FALSE)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetCandidate(ULONG nIndex, ITfCandidateString **ppCand)
{
    CCandidateString *pCandString;
    int nCnt = _rgCandStr.Count();
    if (nIndex >= (ULONG)nCnt)
        return E_FAIL;

    pCandString = _rgCandStr.Get(nIndex);
    return pCandString->QueryInterface(IID_ITfCandidateString, (void **)ppCand);
}

//+---------------------------------------------------------------------------
//
// GetCandidateNum
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetCandidateNum(ULONG *pnCnt)
{
    *pnCnt = (ULONG)_rgCandStr.Count();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetResult
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::SetResult(ULONG nIndex, TfCandidateResult imcr)
{
    if (!_pfnCallback)
        return S_OK;

    if (nIndex >= (ULONG)_rgCandStr.Count())
        return E_FAIL;

    return (_pfnCallback)(_pic, _pRange, _rgCandStr.Get(nIndex), imcr);
}

//+---------------------------------------------------------------------------
//
// EnumCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::EnumOptionsCandidates(IEnumTfCandidates **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumCandidates(this, TRUE)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// GetCandidate
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetOptionsCandidate(ULONG nIndex, ITfCandidateString **ppCand)
{
    CCandidateString *pCandString;
    int nCnt = _rgOptionsStr.Count();
    if (nIndex >= (ULONG)nCnt)
        return E_FAIL;

    pCandString = _rgOptionsStr.Get(nIndex);
    return pCandString->QueryInterface(IID_ITfCandidateString, (void **)ppCand);
}

//+---------------------------------------------------------------------------
//
// GetCandidateNum
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::GetOptionsCandidateNum(ULONG *pnCnt)
{
    *pnCnt = (ULONG)_rgOptionsStr.Count();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetOptionsResult
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::SetOptionsResult(ULONG nIndex, TfCandidateResult imcr)
{
    if (!_pfnOptionsCallback)
        return S_OK;

    if (nIndex >= (ULONG)_rgOptionsStr.Count())
        return E_FAIL;

    return (_pfnOptionsCallback)(_pic, _pRange, _rgOptionsStr.Get(nIndex), imcr);
}

//+---------------------------------------------------------------------------
//
// AddString
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::AddString(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID, HICON hIcon)
{
    int nCnt = _rgCandStr.Count();
    CCandidateString *pCand = new CCandidateString(nCnt, psz, langid, pv, punk, ulID, hIcon);

    if (!pCand)
        return E_OUTOFMEMORY;

    if (!_rgCandStr.Insert(nCnt, 1))
    {
        pCand->Release();
        return E_OUTOFMEMORY;
    }

    _rgCandStr.Set(nCnt, pCand);

    if (ppCandStr)
    {
        *ppCandStr = pCand;
        (*ppCandStr)->AddRef();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AddString
//
//----------------------------------------------------------------------------

HRESULT CCandidateList::AddOption(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID, HICON hIcon, WCHAR *pwzWord)
{
    int nCnt = _rgOptionsStr.Count();
    CCandidateString *pCand = new CCandidateString(nCnt, psz, langid, pv, punk, ulID, hIcon, pwzWord);

    if (!pCand)
        return E_OUTOFMEMORY;

    if (!_rgOptionsStr.Insert(nCnt, 1))
    {
        pCand->Release();
        return E_OUTOFMEMORY;
    }
    _rgOptionsStr.Set(nCnt, pCand);

    if (ppCandStr)
    {
        *ppCandStr = pCand;
        (*ppCandStr)->AddRef();
    }
    return S_OK;
}

HRESULT CCandidateString::GetWord(BSTR *pbstr)
{
    if (!pbstr)
       return E_INVALIDARG;

    *pbstr = NULL;

    if (m_bstrWord)
    {
        *pbstr = SysAllocString(m_bstrWord);
    } 
    
    if(*pbstr)
       return S_OK;

    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
// GetID
//
//----------------------------------------------------------------------------

HRESULT CCandidateString::GetID(ULONG *pulID)
{
    *pulID = m_ulID;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CEnumCandidates
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor, dtor
//
//----------------------------------------------------------------------------

CEnumCandidates::CEnumCandidates(CCandidateList *pList, BOOL fOptionsCandidates)
{
    _pList = pList;
    _rgCandList = fOptionsCandidates ? &_pList->_rgOptionsStr : &_pList->_rgCandStr;
    _pList->AddRef();
    _nCur = 0;

    _cRef = 1;
}

CEnumCandidates::~CEnumCandidates()
{
    _pList->Release();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CEnumCandidates::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumTfCandidates))
    {
        *ppvObj = (IEnumTfCandidates *)(this);
    }

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CEnumCandidates::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CEnumCandidates::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Clone(IEnumTfCandidates **ppEnum)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    while (cFetched < ulCount)
    {
        CCandidateString *pCand;

        if (_nCur >= _rgCandList->Count())
            break;

        pCand = _rgCandList->Get(_nCur);
        if (FAILED(pCand->QueryInterface(IID_ITfCandidateString, (void **)ppCand)))
            break;

        ppCand++;
        cFetched++;
        _nCur++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Reset()
{
    _nCur = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT CEnumCandidates::Skip(ULONG ulCount)
{
    while (ulCount)
    {
        if (_nCur >= _rgCandList->Count())
            break;

        _nCur++;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\adddelete.h ===
// --------------------------------------------------------------------------------------------------------
//
//  File Name:  adddelete.h
//
//  This file declares CAddDeleteWord class, which is used to handle SR AddRemove Word UI case.
//
//  User can open Add/Remove Word dialog by click speech tools -- Add/Delete word item
//
//  Or select the same document range twice.
//
// --------------------------------------------------------------------------------------------------------

#ifndef _ADDDELETE_H
#define _ADDDELETE_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

#define MAX_SELECTED     20
#define MAX_DELIMITER    34

class __declspec(novtable) CAddDeleteWord 
{
public:
    CAddDeleteWord(CSapiIMX *psi);
    virtual ~CAddDeleteWord( );

    ITfRange *GetLastUsedIP(void) {return m_cpRangeLastUsedIP;}

    void SaveLastUsedIPRange( ) 
    {
        // When m_fCurIPIsSelection is true, means this current IP is selected by user.
        if ( m_fCurIPIsSelection && m_cpRangeOrgIP )
        {
            m_cpRangeLastUsedIP.Release();
            m_cpRangeLastUsedIP = m_cpRangeOrgIP; // comptr addrefs
        }
    }

    HRESULT SaveCurIPAndHandleAddDelete_InjectFeedbackUI( );
    HRESULT _SaveCurIPAndHandleAddDeleteUI(TfEditCookie ec, ITfContext *pic);
    HRESULT _HandleAddDeleteWord(TfEditCookie ec,ITfContext *pic);
    HRESULT DisplayAddDeleteUI(WCHAR  *pwzInitWord, ULONG   cchSize);
    HRESULT _DisplayAddDeleteUI(void);

    BOOL    WasAddDeleteUIOpened( )  { return m_fAddDeleteUIOpened; }

    static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static void SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)lParam);
    }

    static CAddDeleteWord *GetThis(HWND hWnd)
    {
        CAddDeleteWord *p = (CAddDeleteWord *)GetWindowLongPtr(hWnd, DWLP_USER);
        Assert(p != NULL);
        return p;
    }

    BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
    static  WCHAR    m_Delimiter[MAX_DELIMITER];

private:
    CSapiIMX     *m_psi;
    CSpTask      *_pCSpTask;

    BOOL         m_fCurIPIsSelection;
    BOOL         m_fMessagePopUp;         // If the message pop up
    BOOL         m_fToOpenAddDeleteUI;    // If user wants to open Add/delete word by select the same range twice.
    BOOL         m_fAddDeleteUIOpened;    // If the Add/delete UI window was opened.
    BOOL         m_fInDisplayAddDeleteUI; // TRUE if we're in the middle of 
                                          // showing the UI

    // the last used IP Range
    CComPtr<ITfRange> m_cpRangeLastUsedIP;

    // the original IP Range right before user starts to speak
    CComPtr<ITfRange> m_cpRangeOrgIP;
    CSpDynamicString m_dstrInitWord;

};

#endif  // _ADDDELETE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\prvlib\varcomp.cpp ===
//
//  varcomp.cpp
//
//  Issue:     string comparisons ignore sort spec lcid.
//  Issue -- unsupported types:
//                      VT_RECORD
//
//  Notes:      The following comparisons are suppored
//
//              Variant     Equality    Relational  Bitwise
//              ----------- ----------- ----------  -------
//
//              VT_EMPTY        X
//              VT_NULL         X
//              VT_I2           X           X           X
//              VT_I4           X           X           X
//              VT_R4           X           X
//              VT_R8           X           X
//              VT_CY           X           X
//              VT_DATE         X           X
//              VT_BSTR         X           X
//              VT_DISPATCH     -
//              VT_ERROR        X           X           X
//              VT_BOOL         X
//              VT_VARIANT      X           X
//              VT_UNKNOWN      -
//              VT_DECIMAL      X           X
//              VT_I1           X           X           X
//              VT_UI1          X           X           X
//              VT_UI2          X           X           X
//              VT_UI4          X           X           X
//              VT_I8           X           X           X
//              VT_UI8          X           X           X
//              VT_INT          X           X           X
//              VT_UINT         X           X           X
//              VT_VOID         -
//              VT_HRESULT      X           X           X
//              VT_PTR          -
//              VT_SAFEARRAY    -
//              VT_CARRAY       -
//              VT_USERDEFINED  -
//              VT_LPSTR        X           X
//              VT_LPWSTR       X           X
//              VT_FILETIME     X           X
//              VT_BLOB         X           X
//              VT_STREAM
//              VT_STORAGE
//              VT_STREAMED_OBJECT
//              VT_STORED_OBJECT
//              VT_BLOB_OBJECT  X           X
//              VT_CF           X           X
//              VT_CLSID        X
//

#include "private.h"

#include "varcomp.h"


CComparators VariantCompare;


//
// DEFAULT.  Used for optimization in looped comparisons.  If we can't
//           determine the way to compare, then use this default.
//

int VT_DEFAULT_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

//
// VT_EMPTY
//

int VT_EMPTY_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

BOOL VT_EMPTY_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( TRUE );
}

BOOL VT_EMPTY_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( FALSE );
}

//
// VT_NULL
//

int VT_NULL_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

BOOL VT_NULL_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( TRUE );
}

BOOL VT_NULL_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( FALSE );
}

//
// VT_I2
//

int VT_I2_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal - v2.iVal );
}

BOOL VT_I2_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal < v2.iVal );
}

BOOL VT_I2_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal <= v2.iVal );
}

BOOL VT_I2_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal >= v2.iVal );
}

BOOL VT_I2_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal > v2.iVal );
}

BOOL VT_I2_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal == v2.iVal );
}

BOOL VT_I2_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal != v2.iVal );
}

BOOL VT_I2_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.iVal & v2.iVal) == v2.iVal );
}

BOOL VT_I2_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.iVal & v2.iVal) != 0 );
}

//
// VT_I4
//

int VT_I4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( v1.lVal > v2.lVal ) ? 1 : ( v1.lVal < v2.lVal ) ? -1 : 0;
}

BOOL VT_I4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal < v2.lVal );
}

BOOL VT_I4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal <= v2.lVal );
}

BOOL VT_I4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal >= v2.lVal );
}

BOOL VT_I4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal > v2.lVal );
}

BOOL VT_I4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal == v2.lVal );
}

BOOL VT_I4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal != v2.lVal );
}

BOOL VT_I4_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.lVal & v2.lVal) == v2.lVal );
}

BOOL VT_I4_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.lVal & v2.lVal) != 0 );
}

//
// VT_R4
//

//
// We can't use floating point in the kernel.  Luckily, it's easy to
// fake comparisons on floating point.  The format of an IEEE floating
// point number is:
//
//     <sign bit> <biased exponent> <normalized mantissa>
//
// Because the exponent is biased, after flipping the sign bit we can
// make all comparisons as if the numbers were unsigned long.
//

ULONG const R4_SignBit = 0x80000000;

int VT_R4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    // axp (not x86) generates exceptions when floating point numbers
    // don't look like ieee floating point numbers.  This can happen
    // with bogus queries or bogus values stored in properties or the
    // property store.

    #if (_X86_ == 1)
        return ( v1.fltVal > v2.fltVal ) ? 1 :
               ( v1.fltVal < v2.fltVal ) ? -1 : 0;
    #else
        ULONG u1 = v1.ulVal ^ R4_SignBit;
        ULONG u2 = v2.ulVal ^ R4_SignBit;

        if ( (v1.ulVal & v2.ulVal & R4_SignBit) != 0 )
            return ( ( u1 > u2 ) ? -1 : ( u1 < u2 ) ?  1 : 0 );
        else
            return ( ( u1 > u2 ) ?  1 : ( u1 < u2 ) ? -1 : 0 );
    #endif
}

BOOL VT_R4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) < 0;
}

BOOL VT_R4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) <= 0;
}

BOOL VT_R4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) >= 0;
}

BOOL VT_R4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) > 0;
}

BOOL VT_R4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal == v2.ulVal );
}

BOOL VT_R4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal != v2.ulVal );
}

//
// VT_R8
//

LONGLONG const R8_SignBit = 0x8000000000000000;

int VT_R8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    // axp (not x86) generates exceptions when floating point numbers
    // don't look like ieee floating point numbers.  This can happen
    // with bogus queries or bogus values stored in properties or the
    // property store.

    #if (_X86_ == 1)
        return ( v1.dblVal > v2.dblVal ) ? 1 :
               ( v1.dblVal < v2.dblVal ) ? -1 : 0;

    #else
        if ( (v1.uhVal.QuadPart & v2.uhVal.QuadPart & R8_SignBit) != 0 )
            return( (v1.uhVal.QuadPart ^ R8_SignBit) < (v2.uhVal.QuadPart ^ R8_SignBit) ? 1 :
                    (v1.uhVal.QuadPart ^ R8_SignBit) == (v2.uhVal.QuadPart ^ R8_SignBit) ? 0 :
                    -1 );
        else
            return( (v1.uhVal.QuadPart ^ R8_SignBit) > (v2.uhVal.QuadPart ^ R8_SignBit) ? 1 :
                    (v1.uhVal.QuadPart ^ R8_SignBit) == (v2.uhVal.QuadPart ^ R8_SignBit) ? 0 :
                    -1 );
    #endif // 0
}

BOOL VT_R8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) < 0;
}

BOOL VT_R8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) <= 0;
}

BOOL VT_R8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) >= 0;
}

BOOL VT_R8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) > 0;
}

BOOL VT_R8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart == v2.uhVal.QuadPart );
}

BOOL VT_R8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart != v2.uhVal.QuadPart );
}

//
// VT_BSTR
//

int VT_BSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    return wcscmp( pxv1, pxv2);
}

BOOL VT_BSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) < 0 );
}

BOOL VT_BSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) <= 0 );
}

BOOL VT_BSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) >= 0 );
}

BOOL VT_BSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) > 0 );
}

BOOL VT_BSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    return( wcscmp( pxv1, pxv2) == 0 );
}

BOOL VT_BSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    return( wcscmp( pxv1, pxv2) != 0 );
}

//
// VT_BOOL
//

int VT_BOOL_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if (v1.boolVal == 0)
        if (v2.boolVal == 0)
            return( 0 );
        else
            return( -1 );
    else
        if (v2.boolVal == 0)
            return( 1 );
        else
            return( 0 );
}

BOOL VT_BOOL_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( ((v1.boolVal==0) && (v2.boolVal==0))  ||
            ((v1.boolVal!=0) && (v2.boolVal!=0)) );
}

BOOL VT_BOOL_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( !VT_BOOL_EQ( v1, v2 ) );
}

//
// VT_VARIANT
//

int VT_VARIANT_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.vt != v2.vt )
        return v1.vt - v2.vt;

    FCmp comp = VariantCompare.GetComparator( (VARENUM) v1.vt );

    if (0 == comp)
        return 0;
    else
        return comp( v1, v2 );
}

BOOL VT_VARIANT_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) < 0;
}

BOOL VT_VARIANT_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) <= 0;
}

BOOL VT_VARIANT_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) >= 0;
}

BOOL VT_VARIANT_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) > 0;
}

BOOL VT_VARIANT_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) == 0;
}

BOOL VT_VARIANT_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) != 0;
}

//
// VT_DECIMAL
//

int VT_DEC_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.decVal.sign  == v2.decVal.sign  &&
         v1.decVal.scale == v2.decVal.scale &&
         v1.decVal.Hi32  == v2.decVal.Hi32  &&
         v1.decVal.Lo64  == v2.decVal.Lo64)
        return 0;

    int iSign = v1.decVal.sign == DECIMAL_NEG ? -1 : 1;

    if ( v1.decVal.sign != v2.decVal.sign )
        return iSign;

    if ( v1.decVal.scale == v2.decVal.scale )
    {
        int iRet = 0;
        if (v1.decVal.Hi32 != v2.decVal.Hi32)
            iRet = (v1.decVal.Hi32 < v2.decVal.Hi32) ? -1 : 1;
        else if (v1.decVal.Lo64 != v2.decVal.Lo64)
            iRet = (v1.decVal.Lo64 < v2.decVal.Lo64) ? -1 : 1;
        return iRet * iSign;
    }

    double d1;
    VarR8FromDec( (DECIMAL*)&v1.decVal, &d1 );
    double d2;
    VarR8FromDec( (DECIMAL*)&v2.decVal, &d2 );

    return (( d1 > d2 ) ? 1 : ( d1 < d2 ) ? -1 : 0);
}

BOOL VT_DEC_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) < 0;
}

BOOL VT_DEC_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) <= 0;
}

BOOL VT_DEC_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) >= 0;
}

BOOL VT_DEC_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) > 0;
}

BOOL VT_DEC_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) == 0;
}

BOOL VT_DEC_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) != 0;
}

//
// VT_I1
//

int VT_I1_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal - v2.cVal );
}

BOOL VT_I1_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal < v2.cVal );
}

BOOL VT_I1_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal <= v2.cVal );
}

BOOL VT_I1_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal >= v2.cVal );
}

BOOL VT_I1_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal > v2.cVal );
}

BOOL VT_I1_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal == v2.cVal );
}

BOOL VT_I1_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal != v2.cVal );
}

BOOL VT_I1_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.cVal & v2.cVal) == v2.cVal );
}

BOOL VT_I1_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.cVal & v2.cVal) != 0 );
}


//
// VT_UI1
//

int VT_UI1_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal - v2.bVal );
}

BOOL VT_UI1_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal < v2.bVal );
}

BOOL VT_UI1_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal <= v2.bVal );
}

BOOL VT_UI1_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal >= v2.bVal );
}

BOOL VT_UI1_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal > v2.bVal );
}

BOOL VT_UI1_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal == v2.bVal );
}

BOOL VT_UI1_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal != v2.bVal );
}

BOOL VT_UI1_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.bVal & v2.bVal) == v2.bVal );
}

BOOL VT_UI1_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.bVal & v2.bVal) != 0 );
}

//
// VT_UI2
//

int VT_UI2_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal - v2.uiVal );
}

BOOL VT_UI2_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal < v2.uiVal );
}

BOOL VT_UI2_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal <= v2.uiVal );
}

BOOL VT_UI2_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal >= v2.uiVal );
}

BOOL VT_UI2_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal > v2.uiVal );
}

BOOL VT_UI2_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal == v2.uiVal );
}

BOOL VT_UI2_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal != v2.uiVal );
}

BOOL VT_UI2_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uiVal & v2.uiVal) == v2.uiVal );
}

BOOL VT_UI2_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uiVal & v2.uiVal) != 0 );
}
//
// VT_UI4
//

int VT_UI4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( v1.ulVal > v2.ulVal ) ? 1 : ( v1.ulVal < v2.ulVal ) ? -1 : 0;
}

BOOL VT_UI4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal < v2.ulVal );
}

BOOL VT_UI4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal <= v2.ulVal );
}

BOOL VT_UI4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal >= v2.ulVal );
}

BOOL VT_UI4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal > v2.ulVal );
}

BOOL VT_UI4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal == v2.ulVal );
}

BOOL VT_UI4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal != v2.ulVal );
}

BOOL VT_UI4_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.ulVal & v2.ulVal) == v2.ulVal );
}

BOOL VT_UI4_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.ulVal & v2.ulVal) != 0 );
}

//
// VT_I8
//

int VT_I8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart >  v2.hVal.QuadPart ? 1 :
            v1.hVal.QuadPart == v2.hVal.QuadPart ? 0 :
            -1 );
}

BOOL VT_I8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart < v2.hVal.QuadPart );
}

BOOL VT_I8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart <= v2.hVal.QuadPart );

}

BOOL VT_I8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart >= v2.hVal.QuadPart );
}

BOOL VT_I8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart > v2.hVal.QuadPart );
}

BOOL VT_I8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart == v2.hVal.QuadPart );
}

BOOL VT_I8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart != v2.hVal.QuadPart );
}

BOOL VT_I8_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.hVal.QuadPart & v2.hVal.QuadPart) == v2.hVal.QuadPart );
}

BOOL VT_I8_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.hVal.QuadPart & v2.hVal.QuadPart) != 0 );
}

//
// VT_UI8
//

int VT_UI8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart >  v2.uhVal.QuadPart ? 1 :
            v1.uhVal.QuadPart == v2.uhVal.QuadPart ? 0 :
            -1 );
}

BOOL VT_UI8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart < v2.uhVal.QuadPart );
}

BOOL VT_UI8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart <= v2.uhVal.QuadPart );

}

BOOL VT_UI8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart >= v2.uhVal.QuadPart );
}

BOOL VT_UI8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart > v2.uhVal.QuadPart );
}

BOOL VT_UI8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart == v2.uhVal.QuadPart );
}

BOOL VT_UI8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart != v2.uhVal.QuadPart );
}

BOOL VT_UI8_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uhVal.QuadPart & v2.uhVal.QuadPart) == v2.uhVal.QuadPart );
}

BOOL VT_UI8_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uhVal.QuadPart & v2.uhVal.QuadPart) != 0 );
}

//
// VT_LPSTR
//

int VT_LPSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( lstrcmpiA( v1.pszVal, v2.pszVal ) );
}

BOOL VT_LPSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = lstrcmpiA( v1.pszVal, v2.pszVal );

    return( rc < 0 );
}

BOOL VT_LPSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = lstrcmpiA( v1.pszVal, v2.pszVal );

    return( rc <= 0 );
}

BOOL VT_LPSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = lstrcmpiA( v1.pszVal, v2.pszVal );

    return( rc >= 0 );
}

BOOL VT_LPSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = lstrcmpiA( v1.pszVal, v2.pszVal );

    return( rc > 0 );
}

BOOL VT_LPSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( lstrcmpiA( v1.pszVal, v2.pszVal ) == 0 );
}

BOOL VT_LPSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( lstrcmpiA( v1.pszVal, v2.pszVal ) != 0 );
}


//
// VT_LPWSTR
//

int VT_LPWSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             v1.pwszVal,
                             -1,
                             v2.pwszVal,
                             -1 );
    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

BOOL VT_LPWSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) < 0 );
}

BOOL VT_LPWSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) <= 0 );
}

BOOL VT_LPWSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) >= 0 );
}

BOOL VT_LPWSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) > 0 );
}

BOOL VT_LPWSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) == 0 );
}

BOOL VT_LPWSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) != 0 );
}

//
// VT_BLOB
//

int VT_BLOB_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    ULONG len = v1.blob.cbSize;
    if ( v2.blob.cbSize < len )
        len = v2.blob.cbSize;

    int iCmp = memcmp( v1.blob.pBlobData,
                       v2.blob.pBlobData,
                       len );

    if ( iCmp != 0 || v1.blob.cbSize == v2.blob.cbSize )
        return( iCmp );

    if ( v1.blob.cbSize > v2.blob.cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_BLOB_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) < 0 );
}

BOOL VT_BLOB_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) <= 0 );
}

BOOL VT_BLOB_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) >= 0 );
}

BOOL VT_BLOB_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) > 0 );
}

BOOL VT_BLOB_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.blob.cbSize == v2.blob.cbSize &&
            memcmp( v1.blob.pBlobData,
                    v2.blob.pBlobData,
                    v1.blob.cbSize ) == 0 );
}

BOOL VT_BLOB_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.blob.cbSize != v2.blob.cbSize ||
            memcmp( v1.blob.pBlobData,
                      v2.blob.pBlobData,
                      v1.blob.cbSize ) != 0 );
}

//
// VT_CF
//

int VT_CF_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.pclipdata->ulClipFmt != v2.pclipdata->ulClipFmt )
    {
        return( v1.pclipdata->ulClipFmt - v2.pclipdata->ulClipFmt );
    }

    ULONG len = CBPCLIPDATA(*v1.pclipdata);

    if ( CBPCLIPDATA(*v2.pclipdata) < len )
        len = CBPCLIPDATA(*v2.pclipdata);

    int iCmp = memcmp( v1.pclipdata->pClipData,
                       v2.pclipdata->pClipData,
                       len );

    if ( iCmp != 0 || v1.pclipdata->cbSize == v2.pclipdata->cbSize )
        return( iCmp );

    if ( v1.pclipdata->cbSize > v2.pclipdata->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_CF_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) < 0 );
}

BOOL VT_CF_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) <= 0 );
}

BOOL VT_CF_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) >= 0 );
}

BOOL VT_CF_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) > 0 );
}

BOOL VT_CF_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.pclipdata->ulClipFmt == v2.pclipdata->ulClipFmt &&
            v1.pclipdata->cbSize == v2.pclipdata->cbSize &&
            memcmp( v1.pclipdata->pClipData,
                    v2.pclipdata->pClipData,
                    CBPCLIPDATA(*v1.pclipdata) ) == 0 );
}

BOOL VT_CF_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.pclipdata->ulClipFmt != v2.pclipdata->ulClipFmt ||
            v1.pclipdata->cbSize != v2.pclipdata->cbSize ||
            memcmp( v1.pclipdata->pClipData,
                    v2.pclipdata->pClipData,
                    CBPCLIPDATA(*v1.pclipdata) ) != 0 );
}

//
// VT_CLSID
//

int VT_CLSID_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) );
}

BOOL VT_CLSID_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) == 0 );
}

BOOL VT_CLSID_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) != 0 );
}

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

//
// VTP_EMPTY
//

int VTP_EMPTY_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_EMPTY_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_EMPTY_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( FALSE );
}

//
// VTP_NULL
//

int VTP_NULL_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_NULL_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_NULL_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( FALSE );
}

//
// VTP_I2
//

int VTP_I2_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) - (* (short *) pv2) );
}

BOOL VTP_I2_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) < (* (short *) pv2) );
}

BOOL VTP_I2_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) <= (* (short *) pv2) );
}

BOOL VTP_I2_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) >= (* (short *) pv2) );
}

BOOL VTP_I2_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) > (* (short *) pv2) );
}

BOOL VTP_I2_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) == (* (short *) pv2) );
}

BOOL VTP_I2_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) != (* (short *) pv2) );
}

BOOL VTP_I2_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (short *) pv1) & (* (short *) pv2)) == (* (short *) pv2) );
}

BOOL VTP_I2_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (short *) pv1) & (* (short *) pv2)) != 0 );
}

//
// VTP_I4
//

int VTP_I4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    long l1 = * (long *) pv1;
    long l2 = * (long *) pv2;

    return ( l1 > l2 ) ? 1 : ( l1 < l2 ) ? -1 : 0;
}

BOOL VTP_I4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) < (* (long *) pv2) );
}

BOOL VTP_I4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) <= (* (long *) pv2) );
}

BOOL VTP_I4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) >= (* (long *) pv2) );
}

BOOL VTP_I4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) > (* (long *) pv2) );
}

BOOL VTP_I4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) == (* (long *) pv2) );
}

BOOL VTP_I4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) != (* (long *) pv2) );
}

BOOL VTP_I4_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (long *) pv1) & (* (long *) pv2)) == (* (long *) pv2) );
}

BOOL VTP_I4_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (long *) pv1) & (* (long *) pv2)) != 0 );
}

//
// VTP_R4
//

//
// We can't use floating point in the kernel.  Luckily, it's easy to
// fake comparisons on floating point.  The format of an IEEE floating
// point number is:
//
//     <sign bit> <biased exponent> <normalized mantissa>
//
// Because the exponent is biased, after flipping the sign bit we can
// make all comparisons as if the numbers were unsigned long.
//

int VTP_R4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
#if 0
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;
    ULONG u1 = ul1 ^ R4_SignBit;
    ULONG u2 = ul2 ^ R4_SignBit;

    if ( (ul1 & ul2 & R4_SignBit) != 0 )
        return ( ( u1 > u2 ) ? -1 : ( u1 < u2 ) ?  1 : 0 );
    else
        return ( ( u1 > u2 ) ?  1 : ( u1 < u2 ) ? -1 : 0 );
#else // 0
    float f1 = * (float *) pv1;
    float f2 = * (float *) pv2;
    return ( f1 > f2 ) ? 1 : ( f1 < f2 ) ? -1 : 0;
#endif // 0
}

BOOL VTP_R4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) < 0;
}

BOOL VTP_R4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) <= 0;
}

BOOL VTP_R4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) >= 0;
}

BOOL VTP_R4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) > 0;
}

BOOL VTP_R4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) == 0;
}

BOOL VTP_R4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) != 0;
}

//
// VTP_R8
//

int VTP_R8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
#if 0
    ULONGLONG uh1 = * (ULONGLONG *) pv1;
    ULONGLONG uh2 = * (ULONGLONG *) pv2;

    if ( (uh1 & uh2 & R8_SignBit) != 0 )
        return( (uh1 ^ R8_SignBit) < (uh2 ^ R8_SignBit) ? 1 :
                (uh1 ^ R8_SignBit) == (uh2 ^ R8_SignBit) ? 0 :
                -1 );
    else
        return( (uh1 ^ R8_SignBit) > (uh2 ^ R8_SignBit) ? 1 :
                (uh1 ^ R8_SignBit) == (uh2 ^ R8_SignBit) ? 0 :
                -1 );
#else // 0
    double d1 = * (double *) pv1;
    double d2 = * (double *) pv2;
    return ( d1 > d2 ) ? 1 : ( d1 < d2 ) ? -1 : 0;
#endif // 0
}

BOOL VTP_R8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) < 0;
}

BOOL VTP_R8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) <= 0;
}

BOOL VTP_R8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) >= 0;
}

BOOL VTP_R8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) > 0;
}

BOOL VTP_R8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) == 0;
}

BOOL VTP_R8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) != 0;
}

//
// VTP_BSTR
//

int VTP_BSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    return wcscmp( pxv1, pxv2 );
}

BOOL VTP_BSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_BSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_BSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_BSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_BSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    return(  wcscmp( pxv1, pxv2 ) == 0 );
}

BOOL VTP_BSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    return(  wcscmp( pxv1, pxv2 ) != 0 );
}

//
// VTP_BOOL
//

int VTP_BOOL_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ((*(VARIANT_BOOL *) pv1) == 0)
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 0 );
        else
            return( -1 );
    else
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 1 );
        else
            return( 0 );
}

BOOL VTP_BOOL_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( ( ((*(VARIANT_BOOL *) pv1)==0) && ((*(VARIANT_BOOL *) pv2)==0) ) ||
            ( ((*(VARIANT_BOOL *) pv1)!=0) && ((*(VARIANT_BOOL *) pv2)!=0) ) );

}

BOOL VTP_BOOL_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( !VTP_BOOL_EQ( pv1, pv2 ) );
}

//
// VTP_VARIANT
//

int VTP_VARIANT_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_Compare( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_EQ( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_NE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

//
// VTP_DECIMAL
//

int VTP_DEC_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    PROPVARIANT v1;
    RtlCopyMemory( &v1, pv1, sizeof DECIMAL );
    v1.vt = VT_DECIMAL;

    PROPVARIANT v2;
    RtlCopyMemory( &v2, pv2, sizeof DECIMAL );
    v2.vt = VT_DECIMAL;

    return VT_DEC_Compare( v1, v2 );
}

BOOL VTP_DEC_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_DEC_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_DEC_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_DEC_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_DEC_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_DEC_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_I1
//

int VTP_I1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) - (*(signed char *) pv2) );
}

BOOL VTP_I1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) < (*(signed char *) pv2) );
}

BOOL VTP_I1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) <= (*(signed char *) pv2) );
}

BOOL VTP_I1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) >= (*(signed char *) pv2) );
}

BOOL VTP_I1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) > (*(signed char *) pv2) );
}

BOOL VTP_I1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) == (*(signed char *) pv2) );
}

BOOL VTP_I1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) != (*(signed char *) pv2) );
}

BOOL VTP_I1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) == (*(signed char *) pv2) );
}

BOOL VTP_I1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) != 0 );
}

//
// VTP_UI1
//

int VTP_UI1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) - (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) < (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) <= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) >= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) > (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) != (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) != 0 );
}

//
// VTP_UI2
//

int VTP_UI2_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) - (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) < (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) <= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) >= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) > (*(USHORT *) pv2) );
}

BOOL VTP_UI2_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) != (*(USHORT *) pv2) );
}

BOOL VTP_UI2_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) != 0 );
}

//
// VTP_UI4
//

int VTP_UI4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;

    return ( ul1 > ul2 ) ? 1 : ( ul1 < ul2 ) ? -1 : 0;
}

BOOL VTP_UI4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) < (*(ULONG *) pv2) );
}

BOOL VTP_UI4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) <= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) >= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) > (*(ULONG *) pv2) );
}

BOOL VTP_UI4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) != (*(ULONG *) pv2) );
}

BOOL VTP_UI4_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) != 0 );
}

//
// VTP_I8
//

int VTP_I8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >  (*(LONGLONG *) pv2) ? 1 :
            (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_I8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) < (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) <= (*(LONGLONG *) pv2) );

}

BOOL VTP_I8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >= (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) > (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) != (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) != 0 );
}

//
// VTP_UI8
//

int VTP_UI8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >  (*(ULONGLONG *) pv2) ? 1 :
            (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_UI8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) < (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) <= (*(ULONGLONG *) pv2) );

}

BOOL VTP_UI8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >= (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) > (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) != (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) != 0 );
}

//
// VTP_LPSTR
//

int VTP_LPSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return ( lstrcmpiA( (*(char **) pv1), (*(char **) pv2) ) );
}

BOOL VTP_LPSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc < 0 );
}

BOOL VTP_LPSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc <= 0 );
}

BOOL VTP_LPSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc >= 0 );
}

BOOL VTP_LPSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = lstrcmpiA( (*(char **) pv1), (*(char **) pv2) );

    return( rc > 0 );
}

BOOL VTP_LPSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( lstrcmpiA( (*(char **) pv1), (*(char **) pv2) ) == 0 );
}

BOOL VTP_LPSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( lstrcmpiA( (*(char **) pv1), (*(char **) pv2) ) != 0 );
}


//
// VTP_LPWSTR
//

int VTP_LPWSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             (*(WCHAR **) pv1),
                             -1,
                             (*(WCHAR **) pv2),
                             -1 );

    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

BOOL VTP_LPWSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_LPWSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_LPWSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_LPWSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_LPWSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_LPWSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_BLOB
//

int VTP_BLOB_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG len = (*(BLOB **) pv1)->cbSize;
    if ( (*(BLOB **) pv2)->cbSize < len )
        len = (*(BLOB **) pv2)->cbSize;

    int iCmp = memcmp( (*(BLOB **) pv1)->pBlobData,
                       (*(BLOB **) pv2)->pBlobData,
                       len );

    if ( iCmp != 0 || (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize )
        return( iCmp );

    if ( (*(BLOB **) pv1)->cbSize > (*(BLOB **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_BLOB_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_BLOB_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_BLOB_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_BLOB_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_BLOB_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize &&
            memcmp( (*(BLOB **) pv1)->pBlobData,
                    (*(BLOB **) pv2)->pBlobData,
                    (*(BLOB **) pv1)->cbSize ) == 0 );
}

BOOL VTP_BLOB_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize != (*(BLOB **) pv2)->cbSize ||
            memcmp( (*(BLOB **) pv1)->pBlobData,
                      (*(BLOB **) pv2)->pBlobData,
                      (*(BLOB **) pv1)->cbSize ) != 0 );
}

//
// VTP_CF
//

int VTP_CF_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt )
    {
        return( (* (CLIPDATA **) pv1)->ulClipFmt - (* (CLIPDATA **) pv2)->ulClipFmt );
    }

    ULONG len = CBPCLIPDATA( **(CLIPDATA **) pv1 );

    if ( CBPCLIPDATA( **(CLIPDATA **) pv2 ) < len )
        len = CBPCLIPDATA( **(CLIPDATA **) pv2 );

    int iCmp = memcmp( (* (CLIPDATA **) pv1)->pClipData,
                       (* (CLIPDATA **) pv2)->pClipData,
                       len );

    if ( iCmp != 0 || (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize)
        return( iCmp );

    if ( (* (CLIPDATA **) pv1)->cbSize > (* (CLIPDATA **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_CF_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_CF_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_CF_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_CF_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_CF_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt == (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize &&
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) == 0 );
}

BOOL VTP_CF_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize != (* (CLIPDATA **) pv2)->cbSize ||
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) != 0 );
}

//
// VTP_CLSID.  V means vector ( a pointer to a guid )
//             S meand singleton ( a pointer to a pointer to a guid )
//

int VTP_VV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) );
}

int VTP_VS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

int VTP_SV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) );
}

int VTP_SS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

BOOL VTP_SS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_SS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_VV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) == 0 );
}

BOOL VTP_VV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) != 0 );
}

BOOL VTP_VS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_VS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_SV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) == 0 );
}

BOOL VTP_SV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) != 0 );
}

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

ULONG const CComparators::_iStart = VT_EMPTY;

CComparators::SComparators const CComparators::_aVariantComparators[] = {
    // VT_EMPTY
    { VT_EMPTY_Compare, VTP_EMPTY_Compare,
      { 0,
        0,
        0,
        0,
        VT_EMPTY_EQ,
        VT_EMPTY_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_EMPTY_EQ,
        VTP_EMPTY_NE,
        0,
        0,
        0 },
    },

    // VT_NULL
    { VT_NULL_Compare, VTP_NULL_Compare,
      { 0,
        0,
        0,
        0,
        VT_NULL_EQ,
        VT_NULL_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_NULL_EQ,
        VTP_NULL_NE,
        0,
        0,
        0 },
    },

    // VT_I2
    { VT_I2_Compare, VTP_I2_Compare,
      { VT_I2_LT,
        VT_I2_LE,
        VT_I2_GT,
        VT_I2_GE,
        VT_I2_EQ,
        VT_I2_NE,
        0,
        VT_I2_AllBits,
        VT_I2_SomeBits
      },
      { VTP_I2_LT,
        VTP_I2_LE,
        VTP_I2_GT,
        VTP_I2_GE,
        VTP_I2_EQ,
        VTP_I2_NE,
        0,
        VTP_I2_AllBits,
        VTP_I2_SomeBits
      },
    },

    // VT_I4
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_R4
    { VT_R4_Compare, VTP_R4_Compare,
      { VT_R4_LT,
        VT_R4_LE,
        VT_R4_GT,
        VT_R4_GE,
        VT_R4_EQ,
        VT_R4_NE,
        0,
        0,
        0,
      },
      { VTP_R4_LT,
        VTP_R4_LE,
        VTP_R4_GT,
        VTP_R4_GE,
        VTP_R4_EQ,
        VTP_R4_NE,
        0,
        0,
        0,
      },
    },

    // VT_R8
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_CY
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        0,
        0
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        0,
        0
      },
    },

    // VT_DATE
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_BSTR
    { VT_BSTR_Compare, VTP_BSTR_Compare,
      { VT_BSTR_LT,
        VT_BSTR_LE,
        VT_BSTR_GT,
        VT_BSTR_GE,
        VT_BSTR_EQ,
        VT_BSTR_NE,
        0,
        0,
        0
      },
      { VTP_BSTR_LT,
        VTP_BSTR_LE,
        VTP_BSTR_GT,
        VTP_BSTR_GE,
        VTP_BSTR_EQ,
        VTP_BSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_DISPATCH
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_ERROR
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_BOOL
    { VT_BOOL_Compare, VTP_BOOL_Compare,
      { 0,
        0,
        0,
        0,
        VT_BOOL_EQ,
        VT_BOOL_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        VTP_BOOL_EQ,
        VTP_BOOL_NE,
        0,
        0,
        0
      },
    },

    // VT_VARIANT
    { VT_VARIANT_Compare, VTP_VARIANT_Compare,
      { VT_VARIANT_LT,
        VT_VARIANT_LE,
        VT_VARIANT_GT,
        VT_VARIANT_GE,
        VT_VARIANT_EQ,
        VT_VARIANT_NE,
        0,
        0,
        0,
      },
      { VTP_VARIANT_LT,
        VTP_VARIANT_LE,
        VTP_VARIANT_GT,
        VTP_VARIANT_GE,
        VTP_VARIANT_EQ,
        VTP_VARIANT_NE,
        0,
        0,
        0,
      },
    },

    // VT_UNKNOWN
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_DECIMAL
    { VT_DEC_Compare, VTP_DEC_Compare,
      { VT_DEC_LT,
        VT_DEC_LE,
        VT_DEC_GT,
        VT_DEC_GE,
        VT_DEC_EQ,
        VT_DEC_NE,
        0,
        0,
        0
      },
      { VTP_DEC_LT,
        VTP_DEC_LE,
        VTP_DEC_GT,
        VTP_DEC_GE,
        VTP_DEC_EQ,
        VTP_DEC_NE,
        0,
        0,
        0
      },
    },

    // VARENUM value 15 unused
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_I1
    { VT_I1_Compare, VTP_I1_Compare,
      { VT_I1_LT,
        VT_I1_LE,
        VT_I1_GT,
        VT_I1_GE,
        VT_I1_EQ,
        VT_I1_NE,
        0,
        VT_I1_AllBits,
        VT_I1_SomeBits
      },
      { VTP_I1_LT,
        VTP_I1_LE,
        VTP_I1_GT,
        VTP_I1_GE,
        VTP_I1_EQ,
        VTP_I1_NE,
        0,
        VTP_I1_AllBits,
        VTP_I1_SomeBits
      },
    },

    // VT_UI1
    { VT_UI1_Compare, VTP_UI1_Compare,
      { VT_UI1_LT,
        VT_UI1_LE,
        VT_UI1_GT,
        VT_UI1_GE,
        VT_UI1_EQ,
        VT_UI1_NE,
        0,
        VT_UI1_AllBits,
        VT_UI1_SomeBits
      },
      { VTP_UI1_LT,
        VTP_UI1_LE,
        VTP_UI1_GT,
        VTP_UI1_GE,
        VTP_UI1_EQ,
        VTP_UI1_NE,
        0,
        VTP_UI1_AllBits,
        VTP_UI1_SomeBits
      },
    },

    // VT_UI2
    { VT_UI2_Compare, VTP_UI2_Compare,
      { VT_UI2_LT,
        VT_UI2_LE,
        VT_UI2_GT,
        VT_UI2_GE,
        VT_UI2_EQ,
        VT_UI2_NE,
        0,
        VT_UI2_AllBits,
        VT_UI2_SomeBits
      },
      { VTP_UI2_LT,
        VTP_UI2_LE,
        VTP_UI2_GT,
        VTP_UI2_GE,
        VTP_UI2_EQ,
        VTP_UI2_NE,
        0,
        VTP_UI2_AllBits,
        VTP_UI2_SomeBits
      },
    },

    // VT_UI4
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_I8
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        VT_I8_AllBits,
        VT_I8_SomeBits
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        VTP_I8_AllBits,
        VTP_I8_SomeBits
      },
    },

    // VT_UI8
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        VT_UI8_AllBits,
        VT_UI8_SomeBits
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        VTP_UI8_AllBits,
        VTP_UI8_SomeBits
      },
    },

    // VT_INT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_UINT
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_VOID
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_HRESULT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_PTR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_SAFEARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_CARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_USERDEFINED
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_LPSTR
    { VT_LPSTR_Compare, VTP_LPSTR_Compare,
      { VT_LPSTR_LT,
        VT_LPSTR_LE,
        VT_LPSTR_GT,
        VT_LPSTR_GE,
        VT_LPSTR_EQ,
        VT_LPSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPSTR_LT,
        VTP_LPSTR_LE,
        VTP_LPSTR_GT,
        VTP_LPSTR_GE,
        VTP_LPSTR_EQ,
        VTP_LPSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_LPWSTR
    { VT_LPWSTR_Compare, VTP_LPWSTR_Compare,
      { VT_LPWSTR_LT,
        VT_LPWSTR_LE,
        VT_LPWSTR_GT,
        VT_LPWSTR_GE,
        VT_LPWSTR_EQ,
        VT_LPWSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPWSTR_LT,
        VTP_LPWSTR_LE,
        VTP_LPWSTR_GT,
        VTP_LPWSTR_GE,
        VTP_LPWSTR_EQ,
        VTP_LPWSTR_NE,
        0,
        0,
        0
      },
    }
};

ULONG const CComparators::_cVariantComparators =
    sizeof(CComparators::_aVariantComparators) /
    sizeof(CComparators::_aVariantComparators[0]);

ULONG const CComparators::_iStart2 = VT_FILETIME;

CComparators::SComparators const CComparators::_aVariantComparators2[] = {
    // VT_FILETIME
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        0,
        0
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        0,
        0
      },
    },

    // VT_BLOB
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_STREAM
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORAGE
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STREAMED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_BLOB_OBJECT
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_CF
    { VT_CF_Compare, VTP_CF_Compare,
      { VT_CF_LT,
        VT_CF_LE,
        VT_CF_GT,
        VT_CF_GE,
        VT_CF_EQ,
        VT_CF_NE,
        0,
        0,
        0
      },
      { VTP_CF_LT,
        VTP_CF_LE,
        VTP_CF_GT,
        VTP_CF_GE,
        VTP_CF_EQ,
        VTP_CF_NE,
        0,
        0,
        0
      },
    },

    // VT_CLSID
    { VT_CLSID_Compare, 0, // Vector special-cased in GetPointerComparator
      { 0,
        0,
        0,
        0,
        VT_CLSID_EQ,
        VT_CLSID_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        0,     // Special-cased in GetPointerRelop
        0,     // Special-cased in GetPointerRelop
        0,
        0,
        0
      },
    }
};


ULONG const CComparators::_cVariantComparators2 =
    sizeof(CComparators::_aVariantComparators2) /
    sizeof(CComparators::_aVariantComparators2[0]);

ULONG const SortDescend = 1;
ULONG const SortNullFirst = 2;


inline void ConvertArrayToVector ( PROPVARIANT const & vIn, PROPVARIANT & vOut )
{
    Assert( vIn.vt & VT_ARRAY );
    SAFEARRAY * pSa = vIn.parray;

    ULONG cDataElements = 1;

    for ( unsigned i = 0; i < pSa->cDims; i++ )
    {
        cDataElements *= pSa->rgsabound[i].cElements;
    }
    vOut.vt = (vIn.vt & VT_TYPEMASK) | VT_VECTOR;
    vOut.caub.cElems = cDataElements;
    vOut.caub.pElems = (BYTE *)pSa->pvData;
}


BYTE * _GetNth( PROPVARIANT const & v, unsigned i )
{
    Assert( isVector(v) );
    switch ( getBaseType( v ) )
    {
    case VT_I1 :        // Issue - no defined type for vector of VT_I1
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_UI1 :
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_I2 :
        return (BYTE *) & (v.cai.pElems[i]);
    case VT_UI2 :
        return (BYTE *) & (v.caui.pElems[i]);
    case VT_BOOL :
        return (BYTE *) & (v.cabool.pElems[i]);
    case VT_I4 :
    case VT_INT :
        return (BYTE *) & (v.cal.pElems[i]);
    case VT_UI4 :
    case VT_UINT :
        return (BYTE *) & (v.caul.pElems[i]);
    case VT_R4 :
        return (BYTE *) & (v.caflt.pElems[i]);
    case VT_ERROR :
        return (BYTE *) & (v.cascode.pElems[i]);
    case VT_I8 :
        return (BYTE *) & (v.cah.pElems[i]);
    case VT_UI8 :
        return (BYTE *) & (v.cauh.pElems[i]);
    case VT_R8 :
        return (BYTE *) & (v.cadbl.pElems[i]);
    case VT_CY :
        return (BYTE *) & (v.cacy.pElems[i]);
    case VT_DATE :
        return (BYTE *) & (v.cadate.pElems[i]);
    case VT_FILETIME :
        return (BYTE *) & (v.cafiletime.pElems[i]);
    case VT_CLSID :
        return (BYTE *) & (v.cauuid.pElems[i]);
    case VT_CF :
        return (BYTE *) & (v.caclipdata.pElems[i]);
    case VT_BSTR :
        return (BYTE *) & (v.cabstr.pElems[i]);
    case VT_LPSTR :
        return (BYTE *) & (v.calpstr.pElems[i]);
    case VT_LPWSTR :
        return (BYTE *) & (v.calpwstr.pElems[i]);
    case VT_VARIANT :
        return (BYTE *) & (v.capropvar.pElems[i]);
    case VT_DECIMAL :
        // NOTE: not valid in a vector, but it could occur due to the
        //       simplistic conversion of arrays to vectors.
        DECIMAL * paDec = (DECIMAL *) v.caub.pElems;
        return (BYTE *) (paDec + i);
    }

    // illegal base variant type in vector compare.
    Assert( 0 );
    return 0;
} //_GetNth

//+-------------------------------------------------------------------------
//
//  Member:     VT_VECTOR_Compare, public
//
//  Effects:    Compares two property values, intended to be called when
//              at least one of the arguments is a vector
//
//  Arguments:  [v1]   -- 1st variant to compare
//              [v2]   -- 2nd variant to compare
//
//  History:    1-May-95 dlee     Created
//
//--------------------------------------------------------------------------

int VT_VECTOR_Compare( PROPVARIANT const & v1In, PROPVARIANT const & v2In )
{
    // must be the same datatype, or just sort on type

    if ( ( v1In.vt != v2In.vt ) )
        return v1In.vt - v2In.vt;

    PROPVARIANT v1 = v1In;
    PROPVARIANT v2 = v2In;

    if ( isArray(v1In) )
    {
        Assert( isArray(v2In) );

        SAFEARRAY * pSa1 = v1In.parray;
        SAFEARRAY * pSa2 = v2In.parray;

        if (pSa1->cDims != pSa2->cDims)
            return pSa1->cDims - pSa2->cDims;

        ULONG cDataElements = 1;

        for ( unsigned i = 0; i < pSa1->cDims; i++ )
        {
            if ( pSa1->rgsabound[i].lLbound != pSa2->rgsabound[i].lLbound )
                return pSa1->rgsabound[i].lLbound - pSa2->rgsabound[i].lLbound;
            if ( pSa1->rgsabound[i].cElements != pSa2->rgsabound[i].cElements )
                return pSa1->rgsabound[i].cElements - pSa2->rgsabound[i].cElements;
            cDataElements *= pSa1->rgsabound[i].cElements;
        }

        //
        // arrays match in type, total size and dimensions.  Compare as vectors.
        //
        v1.vt = v2.vt = (v1In.vt & VT_TYPEMASK) | VT_VECTOR;
        v1.caub.cElems = v2.caub.cElems = cDataElements;
        v1.caub.pElems = (BYTE *)pSa1->pvData;
        v2.caub.pElems = (BYTE *)pSa2->pvData;
    }

    Assert( isVector(v1) );

    FPCmp cmp = VariantCompare.GetPointerComparator( v1, v2 );
    if (0 == cmp)
    {
        // Unknown property type or relation used in comparison.
        Assert(0);
        return 0;
    }

    unsigned cMin = __min( v1.cal.cElems, v2.cal.cElems );

    for ( unsigned x = 0; x < cMin; x++ )
    {
        int r = cmp( _GetNth( v1, x), _GetNth( v2, x ) );

        if (0 != r)
            return r;
    }

    // All equal so far up to the minimum cardinality of the vectors.
    // Any difference now would be due to the cardinality.

    return v1.cal.cElems - v2.cal.cElems;
} //VT_VECTOR_Compare

int VTP_VECTOR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VECTOR_Compare( ** (PROPVARIANT **) pv1,
                              ** (PROPVARIANT **) pv2 );
} //VTP_VECTOR_Compare

BOOL VT_VECTOR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) < 0;
} //VT_VECTOR_LT

BOOL VT_VECTOR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) <= 0;
} //VT_VECTOR_LE

BOOL VT_VECTOR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LE( v1, v2 );
} //VT_VECTOR_GT

BOOL VT_VECTOR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LT( v1, v2 );
} //VT_VECTOR_GE

BOOL VT_VECTOR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) == 0;
} //VT_VECTOR_EQ

BOOL VT_VECTOR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return !VT_VECTOR_EQ( v1, v2 );
} //VT_VECTOR_NE

BOOL VT_VECTOR_Common(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    // must be the same datatype and a vector or it doesn't compare.

    if ( ( v1.vt != v2.vt ) || ! isVector( v1 ) )
        return FALSE;

    // must be same cardinality, or it doesn't compare

    if ( v1.cal.cElems != v2.cal.cElems )
        return FALSE;

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    unsigned cElems = v1.cal.cElems;

    for ( unsigned x = 0; x < cElems; x++ )
    {
        if ( !cmp( _GetNth( v1, x), _GetNth( v2, x ) ) )
            return FALSE;
    }

    return TRUE;
} //VT_VECTOR_Common

BOOL VT_VECTOR_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits

BOOL VT_VECTOR_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_Any(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // return TRUE if any element in v1 holds the relation to any v2 element
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
        {
            for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
            {
                if ( cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return TRUE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( cmp( _GetNth( v1, i ), pb2 ) )
                    return TRUE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( cmp( pb1, _GetNth( v2, i ) ) )
                    return TRUE;
            }
        }
    }

    return FALSE;
} //VT_VECTOR_Any

BOOL VT_VECTOR_LT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLT );
} //VT_VECTOR_LT_Any

BOOL VT_VECTOR_LE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLE );
} //VT_VECTOR_LE_Any

BOOL VT_VECTOR_GT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGT );
} //VT_VECTOR_GT_Any

BOOL VT_VECTOR_GE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGE );
} //VT_VECTOR_GE_Any

BOOL VT_VECTOR_EQ_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PREQ );
} //VT_VECTOR_EQ_Any

BOOL VT_VECTOR_NE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRNE );
} //VT_VECTOR_NE_Any

BOOL VT_VECTOR_AllBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_Any

BOOL VT_VECTOR_SomeBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_Any

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_All(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // each element in v2 must hold the relation to each element v1
    // (not necessarily vice-versa)
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
        {
            for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
            {
                if ( ! cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return FALSE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( ! cmp( _GetNth( v1, i ), pb2 ) )
                    return FALSE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( ! cmp( pb1, _GetNth( v2, i ) ) )
                    return FALSE;
            }
        }
    }

    return TRUE;
} //VT_VECTOR_All

BOOL VT_VECTOR_LT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLT );
} //VT_VECTOR_LT_All

BOOL VT_VECTOR_LE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLE );
} //VT_VECTOR_LE_All

BOOL VT_VECTOR_GT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGT );
} //VT_VECTOR_GT_All

BOOL VT_VECTOR_GE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGE );
} //VT_VECTOR_GE_All

BOOL VT_VECTOR_EQ_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PREQ );
} //VT_VECTOR_EQ_All

BOOL VT_VECTOR_NE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRNE );
} //VT_VECTOR_NE_All

BOOL VT_VECTOR_AllBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_All

BOOL VT_VECTOR_SomeBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_All

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FRel const CComparators::_aVectorComparators[] =
{
    VT_VECTOR_LT,
    VT_VECTOR_LE,
    VT_VECTOR_GT,
    VT_VECTOR_GE,
    VT_VECTOR_EQ,
    VT_VECTOR_NE,
    0,
    VT_VECTOR_AllBits,
    VT_VECTOR_SomeBits
};

ULONG const CComparators::_cVectorComparators =
    sizeof CComparators::_aVectorComparators /
    sizeof CComparators::_aVectorComparators[0];

FRel const CComparators::_aVectorComparatorsAll[] =
{
    VT_VECTOR_LT_All,
    VT_VECTOR_LE_All,
    VT_VECTOR_GT_All,
    VT_VECTOR_GE_All,
    VT_VECTOR_EQ_All,
    VT_VECTOR_NE_All,
    0,
    VT_VECTOR_AllBits_All,
    VT_VECTOR_SomeBits_All
};

ULONG const CComparators::_cVectorComparatorsAll =
    sizeof CComparators::_aVectorComparatorsAll /
    sizeof CComparators::_aVectorComparatorsAll[0];

FRel const CComparators::_aVectorComparatorsAny[] =
{
    VT_VECTOR_LT_Any,
    VT_VECTOR_LE_Any,
    VT_VECTOR_GT_Any,
    VT_VECTOR_GE_Any,
    VT_VECTOR_EQ_Any,
    VT_VECTOR_NE_Any,
    0,
    VT_VECTOR_AllBits_Any,
    VT_VECTOR_SomeBits_Any
};

ULONG const CComparators::_cVectorComparatorsAny =
    sizeof CComparators::_aVectorComparatorsAny /
    sizeof CComparators::_aVectorComparatorsAny[0];

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FCmp CComparators::GetComparator( VARENUM vt )
{
    if ( isVectorOrArray( vt ) )
    {
        return VT_VECTOR_Compare;
    }
    else if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
    {
        return( _aVariantComparators[vt].comparator );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
    {
        return( _aVariantComparators2[vt - _iStart2].comparator );
    }
    else
    {
        // Unknown property type or relation used in comparison.
        Assert(0);
        return( 0 );
    }
} //GetComparator

FRel CComparators::GetRelop( VARENUM vt, ULONG relop )
{
    if ( ( ( isVectorOrArray( vt ) ) ||
           ( isVectorRelop( relop ) ) ) &&
         ( getBaseRelop( relop ) < _cVectorComparators ) )
    {
        if ( isRelopAny( relop ) )
            return _aVectorComparatorsAny[ getBaseRelop( relop ) ];
        else if ( isRelopAll( relop ) )
            return _aVectorComparatorsAll[ getBaseRelop( relop ) ];
        else
            return _aVectorComparators[ relop ];
    }
    else if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].relops)/
                 sizeof(_aVariantComparators[0].relops[0] ) )
    {
        return( _aVariantComparators[vt].relops[relop] );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].relops)/
                 sizeof(_aVariantComparators2[0].relops[0] ) )
    {
        return( _aVariantComparators2[vt - _iStart2].relops[relop] );
    }
    else
    {
        // Unknown property type or relation used in comparison.
        Assert( 0);
        return( 0 );
    }
} //GetRelop

FPCmp CComparators::GetPointerComparator(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2 )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
            return VTP_VV_CLSID_Compare;
        else if ( isVector( v1 ) )
            return VTP_VS_CLSID_Compare;
        else if ( isVector( v2 ) )
            return VTP_SV_CLSID_Compare;
        else
            return VTP_SS_CLSID_Compare;

        Assert( !"unanticipated clsid / vector code path" );
    }

    if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
        return( _aVariantComparators[vt].pointercomparator );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
        return( _aVariantComparators2[vt - _iStart2].pointercomparator );
    else
    {
        // Unknown property type in comparison.
        Assert( 0 );
        return( 0 );
    }
} //GetPointerComparator

FPRel CComparators::GetPointerRelop(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_VV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VV_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v1 ) )
        {
            if ( PREQ == relop )
                return VTP_VS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VS_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_SV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SV_CLSID_NE;
            else
                return 0;
        }
        else
        {
            if ( PREQ == relop )
                return VTP_SS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SS_CLSID_NE;
            else
                return 0;
        }
    }

    if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].pointerrelops)/
                 sizeof(_aVariantComparators[0].pointerrelops[0] ) )
        return( _aVariantComparators[vt].pointerrelops[relop] );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].pointerrelops)/
                 sizeof(_aVariantComparators2[0].pointerrelops[0] ) )
        return( _aVariantComparators2[vt - _iStart2].pointerrelops[relop] );
    else
    {
        // Unknown type or relation used in comparison.
        Assert( 0);
        return( 0 );
    }
} //GetPointerRelop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\capital.cpp ===
//
//
// Sapilayr TIP CCapCmdHandler implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "capital.h"


// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CCapCmdHandler 
//
// -----------------------------------------------------------------------------------------------------------

CCapCmdHandler::CCapCmdHandler(CSapiIMX *psi) 
{
    m_psi = psi;
}

CCapCmdHandler::~CCapCmdHandler( ) 
{

};

/*  --------------------------------------------------------
//    Function Name: ProcessCapCommands
//
//    Description: public functions used by command handler
//                 to handle any Capital related dictation
//                 commands.
//
// ----------------------------------------------------------*/
HRESULT   CCapCmdHandler::ProcessCapCommands(CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen )
{
    HRESULT hr = E_FAIL;
    
    if ( !m_psi )
        return E_FAIL;

    if ( (idCapCmd > CAPCOMMAND_MinIdWithText ) && (!pwszTextToCap || !ulLen))
        return E_INVALIDARG;

    WCHAR  *pwszText=NULL; 
    ESDATA esData;

    memset(&esData, 0, sizeof(ESDATA));

    if ( pwszTextToCap )
    {
        esData.pData = pwszTextToCap;
        esData.uByte = (ulLen + 1) * sizeof(WCHAR);
    }

    esData.lData1 = (LONG_PTR)idCapCmd;
    esData.lData2 = (LONG_PTR)ulLen;

    hr = m_psi->_RequestEditSession(ESCB_PROCESS_CAP_COMMANDS, TF_ES_READWRITE,  &esData);

    return hr;
}


/*  --------------------------------------------------------
//    Function Name: _ProcessCapCommands
//
//    Description:   Edit session call back funtion for 
//                   ProcessSelectionWord.
//
//                   it does real work for selection handling
// ----------------------------------------------------------*/
HRESULT CCapCmdHandler::_ProcessCapCommands(TfEditCookie ec,ITfContext *pic, CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen)
{
    HRESULT   hr = S_OK;

    // Get the Dictation Grammar
    TraceMsg(TF_GENERAL, "_ProcessCapCommands() is called");

    if ( m_psi == NULL)
        return E_FAIL;

    CComPtr<ITfRange>    cpIP;

    cpIP = m_psi->GetSavedIP();

    if ( cpIP == NULL )
    {
        // Get the current IP.
        hr = GetSelectionSimple(ec, pic, &cpIP);
    }

    // Start to a new command.
    // Clear all the information saved for the previous command handling.

    m_dstrTextToCap.Clear( );
    m_cpCapRange = cpIP;
    m_idCapCmd = idCapCmd;

    switch ( idCapCmd )
    {
    case  CAPCOMMAND_CapThat        :
    case  CAPCOMMAND_AllCapsThat    :
    case  CAPCOMMAND_NoCapsThat     :
        hr = _HandleCapsThat(ec, pic);
        break;

    case  CAPCOMMAND_CapsOn  :
        hr = _CapsOnOff(ec, pic, TRUE);
        break;
    case CAPCOMMAND_CapsOff :
        hr = _CapsOnOff(ec, pic, FALSE);
        break;

    // Below commands require pwszTextToCap contains real text to be capitalized 
    // injected to the document.

    case CAPCOMMAND_CapIt :
    case CAPCOMMAND_AllCaps :
    case CAPCOMMAND_NoCaps :
        m_dstrTextToCap.Append(pwszTextToCap);
        m_ulLen = ulLen;
        hr = _HandleCapsIt(ec, pic);
        break;

    case CAPCOMMAND_CapLetter :
        hr = _HandleCapsThat(ec, pic, towlower(pwszTextToCap[0]));
        break;

    default :
        break;
    }

    // update the saved ip so that next time the hypothesis will 
    // start from this new selection.
    m_psi->SaveLastUsedIPRange( );
    m_psi->SaveIPRange(NULL);

    return hr;
}

/*  --------------------------------------------------------------
//    Function Name: _SetNewText
//
//    Description:   Inject the new text to m_cpCapRange in
//                   the document and update necessary property
//                   data.
//
// --------------------------------------------------------------*/

HRESULT  CCapCmdHandler::_SetNewText(TfEditCookie ec,ITfContext *pic, WCHAR *pwszNewText, BOOL fSapiText) 
{
    HRESULT             hr = S_OK;
    BOOL                fInsertOk;
    CComPtr<ITfRange>   cpRange;

    if (!pwszNewText)
        return E_INVALIDARG;

    m_cpCapRange->Clone(&cpRange);

    hr = cpRange->AdjustForInsert(ec, wcslen(pwszNewText), &fInsertOk);
    if (S_OK == hr && fInsertOk)
    {
        // start a composition here if we haven't already
        m_psi->_CheckStartComposition(ec, cpRange);

        // set the text
        hr = cpRange->SetText(ec, 0, pwszNewText, -1);


        if ( fSapiText )
        {
            //
            // set attribute range 
            //
            CComPtr<ITfRange>    cpAttrRange = NULL;
            CComPtr<ITfProperty> cpProp = NULL;

            if (hr == S_OK)
            {
                hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &cpProp);
            }
            
            if (S_OK == hr)
            {
                hr = cpRange->Clone(&cpAttrRange);
            }

            if (S_OK == hr && cpAttrRange)
            {
                SetGUIDPropertyData(m_psi->_GetLibTLS( ), ec, cpProp, cpAttrRange, GUID_ATTR_SAPI_INPUT);
            }

            //
            // setup langid property
            //
            //_SetLangID(ec, pic, cpRange, langid);
        }

        if ( hr == S_OK )
        {
            cpRange->Collapse(ec, TF_ANCHOR_END);
            SetSelectionSimple(ec, pic, cpRange);
        }
    }

    return hr;
}

/*  ------------------------------------------------------------------
//    Function Name: _CapsText
//
//    Description:   Generate capitalized text based on current 
//                   Capital command id.
//        
//                   Inside this function, it will allocate memory
//                   for new generated capitaized text.
//                   Caller is responsible for release the allocated
//                   memory 
// -------------------------------------------------------------------*/
HRESULT  CCapCmdHandler::_CapsText(WCHAR **pwszNewText, WCHAR wchLetter)
{
    HRESULT   hr = S_OK;
    WCHAR     *pwszNew, *pwszTextToCap;
    ULONG     i;

    // Generate new text based on the requirement

    if ( !pwszNewText )
        return E_INVALIDARG;

    *pwszNewText = NULL;
    pwszTextToCap = (WCHAR *)m_dstrTextToCap;

    pwszNew = (WCHAR *)cicMemAlloc((m_ulLen+1)*sizeof(WCHAR));
    if ( pwszNew )
    {
        WCHAR  wch;

        switch (m_idCapCmd)
        {
        case CAPCOMMAND_CapThat     :
        case CAPCOMMAND_CapIt       :
        case CAPCOMMAND_CapLetter   :
            {
                BOOL  fFoundFirstAlpha=FALSE;

                for (i=0; i<m_ulLen; i++)
                {
                    wch = pwszTextToCap[i];

                    if ( iswalpha(wch) && !fFoundFirstAlpha )
                    {
                        if ( (wchLetter==0) && (m_idCapCmd != CAPCOMMAND_CapLetter) )
                            pwszNew[i] = towupper(wch);
                        else
                        {
                            if (wch == wchLetter)
                                pwszNew[i] = towupper(wch);
                            else
                                pwszNew[i] = wch;
                        }

                        fFoundFirstAlpha = TRUE;
                    }
                    else
                    {
                        pwszNew[i] = wch;
                        //
                        // We treat apostrophe as a normal character when handling capitalization
                        //
                        if ( (towupper(wch) == towlower(wch)) && ( wch != L'\'') && ( wch != 0x2019) )
                        {
                            // reach to a non-alpha character.
                            // now start to find first alphar for next word.
                            fFoundFirstAlpha = FALSE;
                        }
                    }
                }

                pwszNew[m_ulLen] = L'\0';
            }

            break;
                
        case CAPCOMMAND_AllCapsThat :
        case CAPCOMMAND_AllCaps     :

            for ( i=0; i<m_ulLen; i++)
            {
                wch = pwszTextToCap[i];
                if ( iswalpha(wch) )
                    pwszNew[i] = towupper(wch);
                else
                    pwszNew[i] = wch;
            }

            pwszNew[m_ulLen] = L'\0';
             
            break;

        case CAPCOMMAND_NoCapsThat :
        case CAPCOMMAND_NoCaps     :

            for ( i=0; i<m_ulLen; i++)
            {
                wch = pwszTextToCap[i];

                if ( iswalpha(wch) )
                    pwszNew[i] = towlower(wch);
                else
                    pwszNew[i] = wch;
            }

            pwszNew[m_ulLen] = L'\0';
            break;
        }

        *pwszNewText = pwszNew;
    }

    if ( *pwszNewText != NULL )
        hr = S_OK;
    else
    {
        if ( pwszNew )
            cicMemFree(pwszNew);

        hr = E_FAIL;
    }

    return hr;
}


/*  ------------------------------------------------------------------
//    Function Name: _GetCapPhrase
//
//    Description:   Generate the range to capitalize. 
//                   it could be previous dictated phrase,
//                   or current selection, 
//                   or current word around IP or before IP
//                   depends on the current text situation.
// -------------------------------------------------------------------*/
HRESULT CCapCmdHandler::_GetCapPhrase(TfEditCookie ec,ITfContext *pic, BOOL *fSapiText)
{
    HRESULT  hr = S_OK;
    CComPtr<ITfRange>  cpCapRange;
    BOOL     bSapiText = FALSE;

    if ( !m_psi ) return E_FAIL;
    
    if ( !fSapiText ) return E_INVALIDARG;

    hr = m_psi->_GetCmdThatRange(ec, pic, &cpCapRange);

    if ( hr == S_OK && cpCapRange )
    {
        m_cpCapRange = cpCapRange;

        // Set bSapiText here.
        // If the range is inside a dictated phrase, set bSapiText = TRUE;

        CComPtr<ITfProperty>    cpProp;
        CComPtr<ITfRange>       cpSapiPropRange;
        long                    l1=0, l2=0;

        hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &cpProp);

        if ( hr == S_OK )
            hr = cpProp->FindRange(ec, cpCapRange, &cpSapiPropRange, TF_ANCHOR_START);

        // Is cpRange inside cpSapiPropRange ?
        
        if ( hr == S_OK )
            hr = cpCapRange->CompareStart(ec, cpSapiPropRange,  TF_ANCHOR_START, &l1);

        if ( hr == S_OK )
            hr = cpCapRange->CompareEnd(ec, cpSapiPropRange,  TF_ANCHOR_END, &l2);

        if ( hr == S_OK && (l1>=0  && l2<=0) )
        {
            // the Range is inside SAPI input range.
            bSapiText = TRUE;
        }

        // hr could be S_FALSE, if the range is not dictated.
        // We still treat S_FALSE as S_OK in the return hr.
        if ( SUCCEEDED(hr) )
            hr = S_OK;
    }

    *fSapiText = bSapiText;

    return hr;
}


HRESULT  CCapCmdHandler::_HandleCapsThat(TfEditCookie ec,ITfContext *pic, WCHAR wchLetter)
{
    HRESULT  hr = S_OK;
    BOOL     fSapiText;

    // Get the range to capitalize

    hr = _GetCapPhrase(ec, pic, &fSapiText);

    if ( hr == S_OK ) 
    {
        CComPtr<ITfRange>   cpRangeCloned;
        BOOL     fEmpty = TRUE;

        hr = m_cpCapRange->IsEmpty(ec, &fEmpty);

        if ( hr == S_OK && !fEmpty )
        {
            hr = m_cpCapRange->Clone(&cpRangeCloned);

            // Get the text in the CapRange.
            if ( hr == S_OK )
            {
                ULONG   ucch;

                while(S_OK == hr && (S_OK == cpRangeCloned->IsEmpty(ec, &fEmpty)) && !fEmpty)
                {
                    WCHAR sz[128];

                    hr = cpRangeCloned->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);

                    if (S_OK == hr)
                    {
                        sz[ucch] = L'\0';
                        m_dstrTextToCap.Append(sz);
                    }
                }

                m_ulLen = m_dstrTextToCap.Length( );
            }

            if ( hr==S_OK && m_dstrTextToCap)
            {
                // Generate new text based on the requirement
                WCHAR   *pwszNewText;

                hr = _CapsText(&pwszNewText, wchLetter);

                if ( hr == S_OK )
                {
                    hr = _SetNewText(ec, pic, (WCHAR *)pwszNewText, fSapiText);
                    cicMemFree(pwszNewText);
                }
            }
        }
    }

    return  hr;
}

HRESULT  CCapCmdHandler::_CapsOnOff(TfEditCookie ec,ITfContext *pic, BOOL fOn)
{
    HRESULT  hr = S_OK;


    return  hr;
}

HRESULT  CCapCmdHandler::_HandleCapsIt(TfEditCookie ec,ITfContext *pic)
{
    HRESULT  hr = S_OK;

    if ( m_dstrTextToCap)
    {
        // Generate new text based on the requirement
        WCHAR   *pwszNewText;

        hr = _CapsText(&pwszNewText);

        if ( hr == S_OK )
        {
            hr = _SetNewText(ec, pic, (WCHAR *)pwszNewText, TRUE);
            cicMemFree(pwszNewText);
        }
    }

    return  hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\capital.h ===
#ifndef _CAPITAL_H
#define _CAPITAL_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

typedef enum
{
    CAPCOMMAND_NONE         =  0,
    CAPCOMMAND_CapThat      =  1,
    CAPCOMMAND_AllCapsThat  =  2,
    CAPCOMMAND_NoCapsThat   =  3,
    CAPCOMMAND_CapsOn       =  4,
    CAPCOMMAND_CapsOff      =  5,
    CAPCOMMAND_CapsLetter   =  6,

    CAPCOMMAND_MinIdWithText = 7,
    CAPCOMMAND_CapIt        =  8,
    CAPCOMMAND_AllCaps      =  9,
    CAPCOMMAND_NoCaps       =  10,
    CAPCOMMAND_CapLetter    =  11
} CAPCOMMAND_ID;

class CCapCmdHandler
{
public:
    CCapCmdHandler(CSapiIMX *psi);
    ~CCapCmdHandler( );

    HRESULT  ProcessCapCommands(CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen);
    HRESULT  _ProcessCapCommands(TfEditCookie ec,ITfContext *pic, CAPCOMMAND_ID idCapCmd, WCHAR *pwszTextToCap, ULONG ulLen);

private:
    HRESULT  _GetCapPhrase(TfEditCookie ec,ITfContext *pic, BOOL *fSapiText);

    HRESULT  _SetNewText(TfEditCookie ec,ITfContext *pic, WCHAR *pwszNewText, BOOL fSapiText); 
    HRESULT  _CapsText(WCHAR **pwszNewText, WCHAR wchLetter=0);

    HRESULT  _HandleCapsThat(TfEditCookie ec,ITfContext *pic, WCHAR wchLetter=0);
    HRESULT  _HandleCapsIt(TfEditCookie ec,ITfContext *pic);

    HRESULT  _CapsOnOff(TfEditCookie ec,ITfContext *pic, BOOL fOn);

    CSapiIMX            *m_psi;
    CComPtr<ITfRange>   m_cpCapRange;
    CAPCOMMAND_ID       m_idCapCmd;
    CSpDynamicString    m_dstrTextToCap;
    ULONG               m_ulLen;
};

#endif  // _CAPITAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\candlist.h ===
//+---------------------------------------------------------------------------
//
//  File:       candlist.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#ifndef CANDLIST_H
#define CANDLIST_H

#include "ptrary.h"
#include "mscandui.h"

class CCandidateString;
typedef HRESULT (*CANDLISTCALLBACK)(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);

//+---------------------------------------------------------------------------
//
// CCandidateString
//
//----------------------------------------------------------------------------

class CCandidateString : public   ITfCandidateString,
                                    ITfCandidateStringIcon
{
public:
    CCandidateString( ULONG nIndex, WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, 
                        ULONG ulID, HICON hIcon = NULL, WCHAR *pwzWord = NULL);
    ~CCandidateString();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCandidateString
    //
    STDMETHODIMP GetString(BSTR *pbstr);
    STDMETHODIMP GetIndex(ULONG *pnIndex);

    // ITfCandidateStringIcon
    STDMETHODIMP GetIcon(HICON *phIcon)
    {
        if (m_hIcon)
        {
            *phIcon = m_hIcon;
            return S_OK;
        }
        else
        {
            return E_NOTIMPL;
        }
    }

    STDMETHODIMP GetID(ULONG *pID);
    STDMETHODIMP GetWord(BSTR *pbstr);

    HRESULT SetReadingString(WCHAR *psz)
    {
        _pszRead = new WCHAR[wcslen(psz) + 1];
        if  (!_pszRead )
            return E_OUTOFMEMORY;
        
        StringCchCopyW(_pszRead, wcslen(psz) + 1, psz);
        return S_OK;
    }

    IUnknown *_punk;
    void *_pv;
    ULONG _nIndex;
    WCHAR *_psz;
    WCHAR *_pszRead;
    LANGID _langid;
    int _cRef;

private:
    HICON m_hIcon;
    BSTR m_bstrWord;
    ULONG m_ulID;
};

//+---------------------------------------------------------------------------
//
// CCandidateList
//
//----------------------------------------------------------------------------

class CCandidateList :  public ITfCandidateList, 
                        public ITfOptionsCandidateList
{
public:
    CCandidateList(CANDLISTCALLBACK pfnCallback, ITfContext *pic, ITfRange *pRange, CANDLISTCALLBACK pfnOptionsCallback = NULL);
    ~CCandidateList();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCandidateList
    //
    STDMETHODIMP EnumCandidates(IEnumTfCandidates **ppEnum);
    STDMETHODIMP GetCandidate(ULONG nIndex, ITfCandidateString **ppCand);
    STDMETHODIMP GetCandidateNum(ULONG *pnCnt);
    STDMETHODIMP SetResult(ULONG nIndex, TfCandidateResult imcr);

    //
    // ITfOptionsCandidateList
    //
    STDMETHODIMP EnumOptionsCandidates(IEnumTfCandidates **ppEnum);
    STDMETHODIMP GetOptionsCandidate(ULONG nIndex, ITfCandidateString **ppCand);
    STDMETHODIMP GetOptionsCandidateNum(ULONG *pnCnt);
    STDMETHODIMP SetOptionsResult(ULONG nIndex, TfCandidateResult imcr);

	// Internal

    HRESULT AddString(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID = 0, HICON hIcon = NULL);
    HRESULT AddOption(WCHAR *psz, LANGID langid, void *pv, IUnknown *punk, CCandidateString **ppCandStr, ULONG ulID = 0, HICON hIcon = NULL, WCHAR *pwzWord = NULL);
  
    ITfContext *_pic;
    ITfRange *_pRange;
    CPtrArray<CCandidateString> _rgCandStr;
    CPtrArray<CCandidateString> _rgOptionsStr;
    ITfFnReconversion *_pReconv;

    CANDLISTCALLBACK _pfnOptionsCallback;
    CANDLISTCALLBACK _pfnCallback;

    int _cRef;
};


//+---------------------------------------------------------------------------
//
// CEnumCandidates
//
//----------------------------------------------------------------------------

class CEnumCandidates : public IEnumTfCandidates
{
public:
    CEnumCandidates(CCandidateList *pList, BOOL fOptionsCandidates = FALSE);
    ~CEnumCandidates();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IEnumTfCandidates
    //
    STDMETHODIMP Clone(IEnumTfCandidates **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    CCandidateList *_pList;
    CPtrArray<CCandidateString> *_rgCandList;
    int _nCur;
    int _cRef;
};


#endif // CANDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\citn.cpp ===
#include "private.h"
#include "sapilayr.h"
#include "citn.h"
#include "xstring.h"
#include "winnls.h"
#include "wchar.h"

#define MILLION         ((LONGLONG) 1000000)
#define BILLION         ((LONGLONG) 1000000000)
#define MILLION_STR     (L"million")
#define BILLION_STR     (L"billion")


#define MANN         ((LONGLONG) 10000)
#define OKU          ((LONGLONG) 100000000)
#define CHUU         ((LONGLONG) 1000000000000)
#define MANN_STR     (L"\x4E07")
#define OKU_STR      (L"\x5104")
#define CHUU_STR     (L"\x5146")



HRESULT CSimpleITN::InterpretNumberEn
(    
    const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt
)
{
    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    int iPositive = 1; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( NEGATIVE == pFirstProp->ulId )
    {
        // There's no such thing as a negative ordinal
        SPDBG_ASSERT( fCardinal );

        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        iPositive = -1;

        pFirstProp = pFirstProp->pNextSibling;
    }

    if ( GRID_INTEGER_STANDALONE == pFirstProp->ulId )
    {
        // This is interger number
        TraceMsg(TF_GENERAL, "English Interger Number");

        SPDBG_ASSERT( pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;


        // Handle the "2.6 million" case, in which case the number
        // has already been formatted
        if ( GRID_INTEGER_MILLBILL == pFirstProp->ulId )
        {
            if ( pFirstProp->pszValue == NULL 
                 || cSize < (wcslen( pFirstProp->pszValue ) + 1) )
            {
                return E_INVALIDARG;
            }
            *pdblVal = pFirstProp->vValue.dblVal * iPositive;
            if ( iPositive < 0 )
            {
                StringCchCopyW( pszVal, cSize,  m_pwszNeg );
            }
            StringCchCatW( pszVal, cSize, pFirstProp->pszValue );

            return S_OK;
        }
        else
        {
            BOOL   fNegative;

            fNegative = (iPositive == -1);

            return InterpretIntegerEn(pFirstProp, 
                                      fCardinal, 
                                      pdblVal, 
                                      pszVal, 
                                      cSize, 
                                      fFinalDisplayFmt, 
                                      fNegative);
        }
    }
    else if ( GRID_FP_NUMBER == pFirstProp->ulId )
    {
        // This is decimal number
        TraceMsg(TF_GENERAL, "English Floating point (decimal) Number");
        SPDBG_ASSERT( pFirstProp->pFirstChild);
        pFirstProp = pFirstProp->pFirstChild;

        // todo for decimal number handling.

        return InterpretDecimalEn(pFirstProp,
                                  fCardinal,
                                  pdblVal,
                                  pszVal,
                                  cSize,
                                  fFinalDisplayFmt,
                                  (iPositive == -1) );
    }

    return S_OK;
}

HRESULT CSimpleITN::InterpretIntegerEn
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{
    HRESULT   hr=S_OK;
    LONGLONG llValue = 0;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle the digit-by-digit case
    if ( GRID_DIGIT_NUMBER == pFirstProp->ulId )
    {
        const SPPHRASEPROPERTY * pProp;
        int   iNumDigit = 0;

        // iNumDigit is 1 means the current property is ONEDIGIT
        // iNumDigit is 2 means the current property is TWODIGIT.

        // llValue = llValue * ( 10 ^ iNumDigit ) + Value in current property

        for (pProp = pFirstProp->pFirstChild; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
        {

            LONGLONG                 llValCurrent;  // current property's value
            const SPPHRASEPROPERTY  *pPropValue;

            switch ( pProp->ulId)
            {
            case  ONEDIGIT:
                {
                    ASSERT( pProp->pFirstChild );
                    pPropValue = pProp->pFirstChild;
                    ASSERT( VT_UI4 == pPropValue->vValue.vt );

                    llValCurrent = pPropValue->vValue.ulVal;
                    iNumDigit = 1;
                    TraceMsg(TF_GENERAL, "ONEDIGIT: %d", llValCurrent);

                    break;
                }

            case TWODIGIT :
                {
                    ASSERT( pProp->pFirstChild );
                    pPropValue = pProp->pFirstChild;
                    TraceMsg(TF_GENERAL, "TWODIGIT:");

                    if ( pPropValue->ulId == TENS )
                    {
                        const SPPHRASEPROPERTY *pPropOnes;

                        ASSERT(pPropValue->pFirstChild);
                        ASSERT( VT_UI4 == pPropValue->pFirstChild->vValue.vt );

                        llValCurrent = pPropValue->vValue.ulVal * pPropValue->pFirstChild->vValue.ulVal;

                        TraceMsg(TF_GENERAL, "TENS: %d", llValCurrent);

                        pPropOnes = pPropValue->pNextSibling;

                        if ( pPropOnes )
                        {
                            ASSERT(pPropOnes->pFirstChild);
                            ASSERT( VT_UI4 == pPropOnes->pFirstChild->vValue.vt );

                            llValCurrent += pPropOnes->pFirstChild->vValue.ulVal;

                            TraceMsg(TF_GENERAL, "TENS: Second: %d", pPropOnes->pFirstChild->vValue.ulVal);
                        }
                    }
                    else if ( pPropValue->ulId == TEENS )
                    {
                        ASSERT( pPropValue->pFirstChild );
                        ASSERT( VT_UI4 == pPropValue->pFirstChild->vValue.vt );

                        llValCurrent = pPropValue->pFirstChild->vValue.ulVal;

                        TraceMsg(TF_GENERAL, "One Teens, %d", llValCurrent);
                    }
                    else
                    {
                        llValCurrent = 0;
                        TraceMsg(TF_GENERAL, "Wrong ulIds");
                        ASSERT(false);
                    }
                        
                    iNumDigit = 2;

                    break;
                }

            default :
                {
                    iNumDigit = 0;
                    llValCurrent = 0;
                    TraceMsg(TF_GENERAL, "ulId error!");
                    ASSERT(false);
                }
            }

            for (int i=0; i<iNumDigit; i++)
                llValue = llValue * 10;

            llValue += llValCurrent;
            TraceMsg(TF_GENERAL, "llValue=%d", llValue);
        }
    }
    else
    {   for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
        {
            switch(pProp->ulId)
            {
            case ONES:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    llValue += ComputeNum999En( pProp->pFirstChild );
                }
                break;
            case THOUSANDS:
                {    
                    llValue += ComputeNum999En( pProp->pFirstChild ) * 1000;
                }
            break;
            case MILLIONS:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    llValue += ComputeNum999En( pProp->pFirstChild ) * (LONGLONG) 1e6;
                }
                break;
            case BILLIONS:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    llValue += ComputeNum999En( pProp->pFirstChild ) * (LONGLONG) 1e9;
                }
                break;
            case HUNDREDS:
                {
                    SPDBG_ASSERT( pProp->pFirstChild );
                    llValue += ComputeNum999En( pProp->pFirstChild ) * 100;
                }
                break;

            case TENS:
            default:
                SPDBG_ASSERT(false);
            }
        }
    }

    if ( fNegative )
        llValue *= (-1);

    *pdblVal = (DOUBLE) llValue;

    DWORD dwDisplayFlags =  (fCardinal ? 0 : DF_ORDINAL)
                            | (fFinalDisplayFmt ? DF_MILLIONBILLION : 0 );
    hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize );

    return hr;
}



HRESULT CSimpleITN::InterpretDecimalEn
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{
    HRESULT  hr = S_OK;

    const SPPHRASEPROPERTY *pPropertiesFpPart = NULL;
    const SPPHRASEPROPERTY *pPropertiesPointZero = NULL;
    const SPPHRASEPROPERTY *pPropertiesOnes = NULL;
    const SPPHRASEPROPERTY *pPropertiesZero = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    for(pPropertiesPtr=pProperties; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
    {
        if (POINT_ZERO == pPropertiesPtr->ulId )
            pPropertiesPointZero = pPropertiesPtr;
        else if ( FP_PART == pPropertiesPtr->ulId )
            pPropertiesFpPart = pPropertiesPtr;
        else if (ONES == pPropertiesPtr->ulId )
            pPropertiesOnes = pPropertiesPtr;
        else if (ZERO == pPropertiesPtr->ulId )
            pPropertiesZero = pPropertiesPtr;
    }

    // Look for optional ONES (optional because you can say 
    // "point five"
    if ( pPropertiesOnes )
    {
        SPDBG_ASSERT(pPropertiesOnes->pFirstChild);

        hr = InterpretIntegerEn( pPropertiesOnes->pFirstChild, 
                                 fCardinal,
                                 pdblVal,
                                 pszVal,
                                 cSize,
                                 fFinalDisplayFmt,
                                 FALSE);

    }
    else if (pPropertiesZero || m_nmfmtDefault.LeadingZero )
    {
        // There should be a leading zero
        StringCchCopyW( pszVal, cSize, L"0" );
    }

    SPDBG_ASSERT(pPropertiesFpPart || pPropertiesPointZero);

    // Put in a decimal separator

    // Set m_nmfmtDefault.lpDecimalSep as L'.'

    if ( m_nmfmtDefault.lpDecimalSep )
    {
        if ( (cSize - wcslen( pszVal )) < (wcslen(m_nmfmtDefault.lpDecimalSep) + 1) )
        {
            return E_INVALIDARG;
        }
        StringCchCatW( pszVal, cSize, m_nmfmtDefault.lpDecimalSep);
    }

    if ( pPropertiesFpPart )
    {
        // Deal with the FP part, which will also have been ITNed correctly

        INT  ulSize = cSize - wcslen(pszVal);

        if ( ulSize < 0 )
            return E_FAIL;

        WCHAR  *pwszFpValue = new WCHAR[ulSize+1];
        DOUBLE dblFPPart;

        if (pwszFpValue) 
        {
            hr = InterpretIntegerEn( pPropertiesFpPart->pFirstChild, 
                                 fCardinal,
                                 &dblFPPart,
                                 pwszFpValue,
                                 ulSize,
                                 fFinalDisplayFmt,
                                 FALSE);

            if ( hr == S_OK )
            {
                StringCchCatW( pszVal, cSize, pwszFpValue);
      
                for ( UINT ui=0; ui < wcslen(pwszFpValue); ui++ )
                {
                    dblFPPart /= (DOUBLE) 10;
                }
                *pdblVal += dblFPPart;
            }

            delete[] pwszFpValue;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        // "point oh": The DOUBLE is already right, just add a "0"
        if ( (cSize - wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }
        StringCchCatW( pszVal, cSize, L"0" );
    }

    // Handle the negative sign
    if ( (hr == S_OK) && fNegative)
    {
        *pdblVal = -*pdblVal;

        if ( (cSize = wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }

        hr = MakeNumberNegative( pszVal, cSize );
    }

    return hr;
}


HRESULT CSimpleITN::MakeNumberNegative( WCHAR *pwszNumber, UINT cSize  )
{
    // Create a temporary buffer with the non-negated number in it

    if ( (pwszNumber == NULL) || (cSize == 0) )
        return E_POINTER;

    WCHAR *pwszTemp = _wcsdup( pwszNumber );
    if ( !pwszTemp )
    {
        return E_OUTOFMEMORY;
    }

    switch ( m_nmfmtDefault.NegativeOrder )
    {
    case 0:
        // (1.1)
        StringCchCopyW( pwszNumber, cSize, L"(" );
        StringCchCatW( pwszNumber, cSize, pwszTemp );
        StringCchCatW( pwszNumber, cSize, L")" );
        break;

    case 1: case 2:
        // 1: -1.1  2: - 1.1
        StringCchCopyW( pwszNumber,  cSize, m_pwszNeg );
        if ( 2 == m_nmfmtDefault.NegativeOrder )
        {
            StringCchCatW( pwszNumber, cSize, L" " );
        }
        StringCchCatW( pwszNumber, cSize, pwszTemp );
        break;

    case 3: case 4:
        // 3: 1.1-  4: 1.1 -
        StringCchCopyW( pwszNumber, cSize, pwszTemp );
        if ( 4 == m_nmfmtDefault.NegativeOrder )
        {
            StringCchCatW( pwszNumber, cSize, L" " );
        }
        StringCchCatW( pwszNumber, cSize, m_pwszNeg );
        break;

    default:
        SPDBG_ASSERT( false );
        break;
    }

    free( pwszTemp );

    return S_OK;
}   /* CTestITN::MakeNumberNegative */

/***********************************************************************
* _EnsureNumberFormatDefaults 
*
*   Description:
*       This finds all of the defaults for formatting numbers for
*        this user.
*************************************************************************/
HRESULT CSimpleITN::_EnsureNumberFormatDefaults()
{
    LCID lcid = MAKELCID(m_langid, SORT_DEFAULT);

    if (m_pwszNeg != NULL) return S_OK; 

    //
    // we use ansi version so we can run on win9x too
    //
    CHAR szLocaleData[16];
    
    int iRet = GetLocaleInfoA( lcid, LOCALE_IDIGITS, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.NumDigits = atoi( szLocaleData );    
    
    iRet = GetLocaleInfoA( lcid, LOCALE_ILZERO, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    // It's always either 0 or 1
    m_nmfmtDefault.LeadingZero = atoi( szLocaleData );

    iRet = GetLocaleInfoA( lcid, LOCALE_SGROUPING, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    // It will look like single_digit;0, or else it will look like
    // 3;2;0
    UINT uiGrouping = *szLocaleData - '0';
    if ( (3 == uiGrouping) && (';' == szLocaleData[1]) && ('2' == szLocaleData[2]) )
    {
        uiGrouping = 32;   
    }
    m_nmfmtDefault.Grouping = uiGrouping;

    iRet = GetLocaleInfoA( lcid, LOCALE_INEGNUMBER, szLocaleData, ARRAYSIZE(szLocaleData) );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.NegativeOrder = atoi( szLocaleData );

    // Get the negative sign
    iRet = GetLocaleInfoA( lcid,  LOCALE_SNEGATIVESIGN, NULL, 0);
    if ( !iRet )
    {
        return E_FAIL;
    }

    CHAR szNeg[16];

    Assert(iRet < 8);

    int        iLenNeg = iRet + 1;
    m_pwszNeg = new WCHAR[ iLenNeg ];

    if ( m_pwszNeg == NULL )
    {
        return E_OUTOFMEMORY;
    }

    iRet = GetLocaleInfoA( lcid,  LOCALE_SNEGATIVESIGN, szNeg, iRet );

    StringCchCopyW(m_pwszNeg, iLenNeg, AtoW(szNeg));

    iRet = GetLocaleInfoA( lcid, LOCALE_SDECIMAL, NULL, 0);

    if ( !iRet )
        return E_FAIL;

    Assert(iRet < 16);
    
    if ( m_nmfmtDefault.lpDecimalSep )
    {
        delete[] m_nmfmtDefault.lpDecimalSep;
        m_nmfmtDefault.lpDecimalSep = NULL;
    }

    int   iDecSepLen = iRet + 1;
    m_nmfmtDefault.lpDecimalSep = new WCHAR[ iDecSepLen ];

    if ( m_nmfmtDefault.lpDecimalSep == NULL )
    {
        return E_OUTOFMEMORY;
    }

    iRet = GetLocaleInfoA( lcid,  LOCALE_SDECIMAL, szNeg, iRet );

    StringCchCopyW(m_nmfmtDefault.lpDecimalSep, iDecSepLen, AtoW(szNeg));

    iRet = GetLocaleInfoA( lcid, LOCALE_STHOUSAND, NULL, 0);

    if ( !iRet )
        return E_FAIL;

    Assert(iRet < 16);

    if ( m_nmfmtDefault.lpThousandSep )
    {
        delete[] m_nmfmtDefault.lpThousandSep;
        m_nmfmtDefault.lpThousandSep = NULL;
    }

    int   iThousSepLen = iRet + 1;
    m_nmfmtDefault.lpThousandSep = new WCHAR[ iThousSepLen ];

    if ( m_nmfmtDefault.lpThousandSep == NULL )
    {
        return E_OUTOFMEMORY;
    }

    iRet = GetLocaleInfoA( lcid,  LOCALE_STHOUSAND, szNeg, iRet );

    StringCchCopyW(m_nmfmtDefault.lpThousandSep, iThousSepLen, AtoW(szNeg));

    return iRet ? S_OK : E_FAIL;
}

/***********************************************************************
*   MakeDisplayNumber
*
*   Description:
*       Converts a DOUBLE into a displayable
*       number in the range -999,999,999,999 to +999,999,999,999.
*       cSize is the number of chars for which pwszNum has space
*       allocated.
*       If DF_UNFORMATTED is set, all other flags are ignored,
*           and the number is passed back as an optional negative
*           followed by a string of digits
*       If DF_ORDINAL is set in dwDisplayFlags, displays an
*           ordinal number (i.e. tacks on "th" or the appropriate suffix.
*       If DF_WHOLENUMBER is set, lops off the decimal separator
*           and everything after it.  If DF_WHOLENUMBER is not set,
*           then uses the uiDecimalPlaces parameter to determine
*           how many decimal places to display
*       If DF_FIXEDWIDTH is set, will display at least uiFixedWidth
*           digits; otherwise uiFixedWidth is ignored.
*       If DF_NOTHOUSANDSGROUP is set, will not do thousands
*           grouping (commas)
*************************************************************************/
HRESULT CSimpleITN::MakeDisplayNumber(DOUBLE dblNum, 
                         DWORD dwDisplayFlags,
                         UINT uiFixedWidth,
                         UINT uiDecimalPlaces,
                         WCHAR *pwszNum,
                         UINT cSize )
{
    SPDBG_ASSERT( pwszNum );
    SPDBG_ASSERT( !SPIsBadWritePtr( pwszNum, cSize ) );
    *pwszNum = 0;

    // Get the default number formatting.
    // Note that this gets called every time, since otherwise there
    // is no way to pick up changes that the user has made since
    // this process has started.
    HRESULT hr = _EnsureNumberFormatDefaults();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    // check for straight millions and straight billions
    // This is a workaround for the fact that we can't resolve the ambiguity
    // and get "two million" to go through GRID_INTEGER_MILLBILL

    if ( m_langid != 0x0411 )
    {
        if (( dwDisplayFlags & DF_WHOLENUMBER ) && ( dwDisplayFlags & DF_MILLIONBILLION ) && (dblNum > 0))
        {
            if ( 0 == (( ((LONGLONG) dblNum) % BILLION )) )
            {
                // e.g. for "five billion" get the "5" and then 
                // tack on " billion"
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) BILLION) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize );
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, L" " );
                    StringCchCatW( pwszNum, cSize, BILLION_STR );
                }
                return hr;
            }
            else if (( ((LONGLONG) dblNum) < BILLION ) && 
                    ( 0 == (( ((LONGLONG) dblNum) % MILLION )) ))
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) MILLION) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize );
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, L" " );
                    StringCchCatW( pwszNum, cSize, MILLION_STR );
                }
                    return hr;
            }
        }
    }
    else
    {
        if (( dwDisplayFlags & DF_WHOLENUMBER ) && (dblNum > 0))
        {
            if ( 0 == (( ((LONGLONG) dblNum) % CHUU )) )
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) CHUU) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize);
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, CHUU_STR );
                }
                return hr;
            }
            else if (( ((LONGLONG) dblNum) < CHUU ) && 
                    ( 0 == (( ((LONGLONG) dblNum) % OKU )) ))
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) OKU) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize);
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, OKU_STR );
                }
                    return hr;
            }
            else if (( ((LONGLONG) dblNum) < OKU ) && 
                    ( 0 == (( ((LONGLONG) dblNum) % MANN )) ))
            {
                hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) MANN) ), 
                    dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize);
                if ( SUCCEEDED( hr ) )
                {
                    StringCchCatW( pwszNum, cSize, MANN_STR );
                }
                return hr;
            }
        }
    }

    // Put in the negative sign if necessary
    if ( dblNum < 0 )
    {
        StringCchCatW( pwszNum, cSize, L"-" );

        // From now on we want to deal with the magnitude of the number
        dblNum *= -1;
    }
   
    SPDBG_ASSERT(m_langid == 0x411 ? dblNum < 1e16 : dblNum < 1e12 );

    WCHAR *pwszTemp = new WCHAR[ cSize ];
    if ( !pwszTemp )
    {
        return E_OUTOFMEMORY;
    }
    *pwszTemp = 0;

    LONGLONG llIntPart = (LONGLONG) dblNum;
    UINT64 uiDigitsLeftOfDecimal;
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        StringCchPrintfW( pwszTemp, cSize, L"%I64d", llIntPart );
        uiDigitsLeftOfDecimal = wcslen( pwszTemp );
    }
    else
    {
        StringCchPrintfW( pwszTemp, cSize, L"%.*f", uiDecimalPlaces, dblNum );
        WCHAR *pwc = wcschr( pwszTemp, L'.' );
        uiDigitsLeftOfDecimal = pwc - pwszTemp;
    }
    

    // The following handles the case where the user said something
    // like "zero zero zero three" and wants to see "0,003"
    BOOL fChangedFirstDigit = false;
    const WCHAR wcFakeFirstDigit = L'1';
    if ( !(dwDisplayFlags & DF_UNFORMATTED) && 
        (dwDisplayFlags & DF_FIXEDWIDTH) && (uiDigitsLeftOfDecimal < uiFixedWidth) )
    {
        // The following handles the case where the user wants leading 
        // zeroes displayed
        
        // Need to pad the front with zeroes
        for ( UINT ui = 0; ui < (uiFixedWidth - uiDigitsLeftOfDecimal); ui++ )
        {
            StringCchCatW( pwszNum, cSize, L"0" );
        }
        
        // HACK
        // In order to force something like "zero zero zero three" 
        // into the form "0,003", we need to make GetNumberFormat() 
        // think that the first digit is 1.
        WCHAR *pwc = wcschr( pwszNum, L'0' );
        SPDBG_ASSERT( pwc );
        *pwc = wcFakeFirstDigit;
        fChangedFirstDigit = true;
    }

    // Copy over the unformatted number after the possible negative sign
    StringCchCatW( pwszNum, cSize, pwszTemp );
    delete[] pwszTemp;

    // If we do not want to format the number, then bail here
    if ( dwDisplayFlags & DF_UNFORMATTED )
    {
        return S_OK;
    }

    // Make a copy so that we can change some fields according to the 
    // flags param
    NUMBERFMTW nmfmt = m_nmfmtDefault;

    // How many decimal places to display?
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        nmfmt.NumDigits = 0;
    }
    else
    {
        // Use the uiDecimalPlaces value to determine how
        // many to display
        nmfmt.NumDigits = uiDecimalPlaces;
    }
    
    // Leading zeroes?
    nmfmt.LeadingZero = (dwDisplayFlags & DF_LEADINGZERO) ? 1 : 0;

    // Thousands grouping?
    if ( dwDisplayFlags & DF_NOTHOUSANDSGROUP )
    {
        nmfmt.Grouping = 0;
    }

#if  0
    
    if ( m_langid == 0x411)
    {
        // Format the number string
        WCHAR *pwszFormattedNum = new WCHAR[ cSize ];
        if ( !pwszFormattedNum )
        {
            return E_OUTOFMEMORY;
        }
        *pwszFormattedNum = 0;

        int iRet;
        do
        {
        
            iRet = GetNumberFormatW( m_langid, 0, pwszNum, &nmfmt, pwszFormattedNum, cSize );
            if ( !iRet && nmfmt.NumDigits )
            {
                // Try displaying fewer digits
                nmfmt.NumDigits--;
            }
        }   while ( !iRet && nmfmt.NumDigits );
        SPDBG_ASSERT( iRet );

        // Copy the formatted number into pwszNum
        StringCchCopyW( pwszNum, cSize, pwszFormattedNum );
        delete[] pwszFormattedNum;
    }
#endif

    // This undoes the hack of changing the first digit
    if ( fChangedFirstDigit )
    {
        // We need to find the first digit and change it back to zero
        WCHAR *pwc = wcschr( pwszNum, wcFakeFirstDigit );
        SPDBG_ASSERT( pwc );
        *pwc = L'0';
    }

    if ( dwDisplayFlags & DF_ORDINAL )
    {
        SPDBG_ASSERT( dwDisplayFlags & DF_WHOLENUMBER );    // sanity

        // This is an ordinal number, tack on the appropriate suffix
        
        // The "st", "nd", "rd" endings only happen when you
        // don't have something like "twelfth"
        if ( ((llIntPart % 100) < 10) || ((llIntPart % 100) > 20) )
        {
            switch ( llIntPart % 10 )
            {
            case 1:
                StringCchCatW( pwszNum, cSize, L"st" );
                break;
            case 2:
                StringCchCatW( pwszNum, cSize, L"nd" );
                break;
            case 3:
                StringCchCatW( pwszNum, cSize, L"rd" );
                break;
            default:
                StringCchCatW( pwszNum, cSize, L"th" );
                break;
            }
        }
        else
        {
            StringCchCatW( pwszNum, cSize, L"th" );
        }
    }

    return S_OK;

}   /* MakeDisplayNumber */

/***********************************************************************
* ComputeNum999 
*
*   Description:
*       Converts a set of SPPHRASEPROPERTYs into a number in
*       [-999, 999].
*       The way these properties is structured is that the top-level 
*       properties contain the place of the number (100s, 10s, 1s)
*       by having the value 100, 10, or 1.
*       The child has the appropriate number value.
*   Return:
*       Value of the number
*************************************************************************/
ULONG CSimpleITN::ComputeNum999En(const SPPHRASEPROPERTY *pProperties )
{
    ULONG ulVal = 0;

    if ( pProperties == NULL )
        return ulVal;

    for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if ( ZERO != pProp->ulId )
        {
            SPDBG_ASSERT( pProp->pFirstChild );
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
            SPDBG_ASSERT( VT_UI4 == pProp->pFirstChild->vValue.vt );

            ulVal += pProp->pFirstChild->vValue.ulVal * pProp->vValue.ulVal;
        }
    }
    return ulVal;
}


// assume that we have only THOUSANDS(qian), HUNDREDS(bai), TENS(shi), and ONES(ge) here!!
ULONG CSimpleITN::ComputeNum9999Ch(const SPPHRASEPROPERTY *pProperties)
{
    ULONG ulVal = 0;

    if ( !pProperties )
        return ulVal;

    if (pProperties->pFirstChild)
    {
        for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
        {
            if ( 0 != pProp->ulId )
            {
                SPDBG_ASSERT( pProp->pFirstChild );
                SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
                SPDBG_ASSERT( VT_UI4 == pProp->pFirstChild->vValue.vt );

                ulVal += pProp->pFirstChild->vValue.ulVal * pProp->vValue.ulVal;
            }
        }
    }

    return ulVal;
}

ULONG CSimpleITN::ComputeNum10000Ch(const SPPHRASEPROPERTY *pProperties)
{
    ULONG  ulVal = 0;
    WCHAR * pszStopped;

    if ( !pProperties )
        return ulVal;

    ulVal = wcstol(pProperties->pszValue, &pszStopped, 10);

    return ulVal;
}


HRESULT CSimpleITN::InterpretNumberCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt)
{

    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    BOOL fNegative = FALSE; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( CHS_NEGATIVE == pFirstProp->ulId )
    {
        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        fNegative = TRUE;

        pFirstProp = pFirstProp->pNextSibling;

        TraceMsg(TF_GENERAL, "This is a minus number");
    }

    
    if ( pFirstProp->ulId == CHS_GRID_NUMBER )
    {

        TraceMsg(TF_GENERAL, "Number is interger");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretIntegerCh(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);

    }
    else if ( pFirstProp->ulId == CHS_GRID_DECIMAL )
    {
        TraceMsg(TF_GENERAL, "Number is floating pointer decimal");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretDecimalCh(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);
    }

    return hr;
}



HRESULT CSimpleITN::InterpretIntegerCh
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    __int64 ulValue = 0;
    ULONG ulLength = 0;
    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    if ( pFirstProp->ulId == CHS_DIGITS )
    {
        // This must be digit-by-digit case, specially handle it here.

        for(const SPPHRASEPROPERTY * pProp=pFirstProp; pProp; pProp=pProp->pNextSibling)
        {
            ASSERT( pProp->ulId == CHS_DIGITS );
            ASSERT( VT_UI4 == pProp->vValue.vt );
            ulValue = ulValue * 10 + pProp->vValue.ulVal;
        }
    }
    else
    {
        for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
        {
            switch(pProp->ulId)
            {
            case CHS_TENTHOUSANDS_:
                {
                    __int64 v1 = 0;
                    _ASSERT(pProp);
                    SPDBG_ASSERT(pProp);
                    v1 = (__int64) ComputeNum10000Ch(pProp);
                    ulValue += v1 * 10000;
                }
                break;
            case CHS_TENTHOUSANDS:
                {
                    __int64 v1 = 0;
                    _ASSERT(pProp->pFirstChild);
                    SPDBG_ASSERT(pProp->pFirstChild);
                    v1 = (__int64) ComputeNum9999Ch(pProp->pFirstChild);
                    ulValue += v1 * 10000;
                }
                break;
            case CHS_HUNDREDMILLIONS:
                {
                    __int64 v1 = 0;
                    _ASSERT(pProp->pFirstChild);
                    SPDBG_ASSERT(pProp->pFirstChild);
                    v1 = (__int64) ComputeNum9999Ch(pProp->pFirstChild);
                    ulValue += v1 * 100000000;
                }
                break;
            case CHS_ONES:
                {
                    __int64 v1 = 0;
                    SPDBG_ASSERT(pProp->pFirstChild);
                    v1 = (__int64) ComputeNum9999Ch(pProp->pFirstChild);
                    ulValue += v1;
                    pProp = NULL;
                }
                break;
            case CHS_ONES_THOUSANDS:
                {
                    SPDBG_ASSERT(pProp->pFirstChild);
                    ulValue += pProp->pFirstChild->vValue.ulVal;
                    pProp = NULL;
                }
                break;
            case CHS_THOUSANDS:
            case CHS_HUNDREDS:
            default:
                _ASSERT(false);
                SPDBG_ASSERT(false);
            }
        }
    }

    if ( fNegative )
       ulValue *= (-1);

    *pdblVal = (DOUBLE) ulValue;

    DWORD dwDisplayFlags =  (fCardinal ? 0 : DF_ORDINAL);

    return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize );

}


    
HRESULT CSimpleITN::InterpretDecimalCh
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    HRESULT  hr = S_OK;

    const SPPHRASEPROPERTY *pPropertiesInteger = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    pPropertiesPtr = pProperties;

    SPDBG_ASSERT( pPropertiesPtr->ulId == CHS_INTEGER);

    pPropertiesInteger = pPropertiesPtr;

    SPDBG_ASSERT(pPropertiesInteger->pFirstChild);

    hr = InterpretIntegerCh( pPropertiesInteger->pFirstChild, 
                             fCardinal,
                             pdblVal,
                             pszVal,
                             cSize,
                             fFinalDisplayFmt,
                             FALSE);
   
    if ( hr == S_OK )
    {
        // Put in a decimal separator

        if ( m_nmfmtDefault.lpDecimalSep )
        {

            if ( (cSize - wcslen( pszVal )) < (wcslen(m_nmfmtDefault.lpDecimalSep) + 1) )
            {
                return E_INVALIDARG;
            }
            StringCchCatW( pszVal, cSize, m_nmfmtDefault.lpDecimalSep);
        }

        // Deal with the FP part, which will also have been ITNed correctly

         INT  ulSize = cSize - wcslen(pszVal);

         if ( ulSize < 0 )
             return E_FAIL;

        WCHAR  *pwszFpValue = new WCHAR[ulSize+1];

        if ( pwszFpValue )
        {
            DOUBLE dblFPPart = 0;

            for(pPropertiesPtr=pPropertiesPtr->pNextSibling; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
            {
                if ( pPropertiesPtr->ulId == CHS_DIGITS )
                {
                    SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->vValue.vt );

                    dblFPPart = dblFPPart * 10 + pPropertiesPtr->vValue.ulVal;

                    StringCchCatW(pwszFpValue, ulSize + 1, pPropertiesPtr->pszValue);
                }
            }

            StringCchCatW( pszVal, cSize, pwszFpValue);
     
            for ( UINT ui=0; ui < wcslen(pwszFpValue); ui++ )
            {
                dblFPPart /= (DOUBLE) 10;
            }

            *pdblVal += dblFPPart;
            delete[] pwszFpValue;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    // Handle the negative sign
    if ( (hr == S_OK) && fNegative)
    {
        *pdblVal = -*pdblVal;

        if ( (cSize = wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }

        hr = MakeNumberNegative( pszVal, cSize );
    }

    return hr;

}

// For Japanese.

/***********************************************************************
* CSimpleITN::InterpretNumberJp *
*-----------------------------*
*   Description:
*       Interprets a number in the range -999,999,999,999 to 
*       +999,999,999,999 and sends the properties and
*       replacements to the CFGInterpreterSite as appropriate.
*       The property will be added and the pszValue will be a string 
*       with the correct display number.
*       If fCardinal is set, makes the display a cardinal number;
*       otherwise makes it an ordinal number.
*       The number will be formatted only if it was a properly-formed
*       number (not given digit by digit).
*   Result:
*************************************************************************/
HRESULT CSimpleITN::InterpretNumberJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt)
{

    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    BOOL     fNegative = FALSE; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( JPN_NEGATIVE == pFirstProp->ulId )
    {
        // There's no such thing as a negative ordinal
        SPDBG_ASSERT( fCardinal );

        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        fNegative = TRUE;

        pFirstProp = pFirstProp->pNextSibling;
    }

    if ( pFirstProp->ulId == JPN_GRID_INTEGER_STANDALONE )
    {
        TraceMsg(TF_GENERAL, "Number is Japanese Interger");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretIntegerJp(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);
    }
    else
    {
        TraceMsg(TF_GENERAL, "Number is Japanese Floating pointer number");

        SPDBG_ASSERT(pFirstProp->pFirstChild);

        pFirstProp = pFirstProp->pFirstChild;

        hr = InterpretDecimalJp(pFirstProp, 
                                fCardinal, 
                                pdblVal, 
                                pszVal, 
                                cSize, 
                                fFinalDisplayFmt, 
                                fNegative);
    }

    return hr;

}   /* CSimpleITN::InterpretNumberJp */


/***********************************************************************
* ComputeNum9999Jp *
*----------------*
*   Description:
*       Converts a set of SPPHRASEPROPERTYs into a number in
*       [-9999, 9999].
*       The way these properties is structured is that the top-level 
*       properties contain the place of the number (100s, 10s, 1s)
*       by having the value 100, 10, or 1.
*       The child has the appropriate number value.
*   Return:
*       Value of the number
*************************************************************************/
ULONG CSimpleITN::ComputeNum9999Jp(const SPPHRASEPROPERTY *pProperties )//, ULONG *pVal)
{
    ULONG ulVal = 0;

    if ( !pProperties  )
        return ulVal;

    for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if ( JPN_ZERO != pProp->ulId )
        {
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );

            ulVal += pProp->vValue.ulVal;
        }
    }
    return ulVal;
}   /* ComputeNum9999Jp */

HRESULT CSimpleITN::InterpretIntegerJp
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    HRESULT  hr = S_OK;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    LONGLONG llValue = 0;

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle the digit-by-digit case
    if ( JPN_GRID_DIGIT_NUMBER == pFirstProp->ulId )
    {
        UINT uiFixedWidth = 0;
        DOUBLE dblVal = 0;

        for(const SPPHRASEPROPERTY * pPropertiesPtr=pFirstProp->pFirstChild; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
        {
            if ( pPropertiesPtr->ulId == JPN_DIGIT )
            {
                SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->vValue.vt );
                dblVal = dblVal * 10 + pPropertiesPtr->vValue.ulVal;
                uiFixedWidth ++;
           }
        }

        if ( fNegative )
            dblVal *= (-1);

        *pdblVal = dblVal;

        DWORD dwDisplayFlags = DF_WHOLENUMBER | DF_FIXEDWIDTH | DF_NOTHOUSANDSGROUP;
        return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 
                                uiFixedWidth, 0, pszVal, MAX_PATH);
    }

    for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
    {
        switch(pProp->ulId)
        {
        case JPN_ICHIs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999Jp( pProp->pFirstChild );
            }
            break;
        case JPN_MANNs:
            {
                llValue += ComputeNum9999Jp( pProp->pFirstChild ) * 10000;
            }
            break;
        case JPN_OKUs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999Jp( pProp->pFirstChild ) * (LONGLONG) 1e8;
            }
            break;
        case JPN_CHOOs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999Jp( pProp->pFirstChild ) * (LONGLONG) 1e12;
            }
            break;
        default:
            SPDBG_ASSERT(false);
        }
    }

    if ( fNegative )
       llValue *= (-1);

    *pdblVal = (DOUBLE) llValue;

    DWORD dwDisplayFlags = (fCardinal ? 0 : DF_ORDINAL);
    //Special code to handle minus 0.
    if ((fNegative) && (*pdblVal == 0.0f))
    {
        *pszVal = L'-';
        *(pszVal+1) = 0;
        hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal+1, cSize-1);
    }
    else
    {
        hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize);
    }

    return hr;
}


    
HRESULT CSimpleITN::InterpretDecimalJp
(   const SPPHRASEPROPERTY *pProperties, 
    const bool fCardinal,
    DOUBLE *pdblVal,
    WCHAR *pszVal,
    UINT cSize,
    const bool fFinalDisplayFmt,
    BOOL  fNegative)
{

    HRESULT hr = S_OK;
    UINT  uiFixedWidth = 0;
    DWORD dwDisplayFlags = 0;
    UINT   uiDecimalPlaces = 0;
    BOOL  bOverWriteNOTHOUSANDSGROUP = FALSE;

    const SPPHRASEPROPERTY *pPropertiesInteger = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    if ( !pdblVal || !pszVal || !pProperties)
    {
        return E_POINTER;
    }

    *pszVal = 0;

    pPropertiesPtr = pProperties;

    *pdblVal = 0;

    if (m_nmfmtDefault.LeadingZero)
    {
        dwDisplayFlags |= DF_LEADINGZERO;
    }

    if ( JPN_ICHIs == pPropertiesPtr->ulId )
    {

        pPropertiesInteger = pPropertiesPtr;

        SPDBG_ASSERT(pPropertiesInteger->pFirstChild);

        hr = InterpretIntegerJp( pPropertiesInteger->pFirstChild, 
                                 fCardinal,
                                 pdblVal,
                                 pszVal,
                                 cSize,
                                 fFinalDisplayFmt,
                                 FALSE);

        if ( hr == S_OK )
        {

            dwDisplayFlags |= DF_FIXEDWIDTH;

            const WCHAR *pwc;
            for ( uiFixedWidth = 0, pwc = pszVal; *pwc; pwc++ )
            {
                if ( iswdigit( *pwc ) )
                {
                    uiFixedWidth++;
                }
            }
            if (!iswdigit( pszVal[wcslen(pszVal) - 1] ))
            {
                //Ends with Mann, Choo,..
                bOverWriteNOTHOUSANDSGROUP = TRUE;
            }

            // This needs to be here in case the user said "zero"
            dwDisplayFlags |= DF_LEADINGZERO;

            // If there is no thousands separator in its string value,
            // then leave out the thousands separator in the result
            if (m_nmfmtDefault.lpThousandSep && (NULL == wcsstr(pszVal, m_nmfmtDefault.lpThousandSep)) && !bOverWriteNOTHOUSANDSGROUP)
            {
                dwDisplayFlags |= DF_NOTHOUSANDSGROUP;
            }

            pPropertiesPtr = pPropertiesPtr->pNextSibling;
        }
    }
   
    if ( hr == S_OK )
    {
        // Deal with the FP part, which will also have been ITNed correctly

        if ( pPropertiesPtr && (JPN_FP_PART == pPropertiesPtr->ulId) ){

            DOUBLE dblFPPart = 0;
            
            uiDecimalPlaces = 0;

            for(pPropertiesPtr=pPropertiesPtr->pFirstChild; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
            {
                if ( pPropertiesPtr->ulId == JPN_DIGIT )
                {
                    SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->vValue.vt );

                    dblFPPart = dblFPPart * 10 + pPropertiesPtr->vValue.ulVal;

                    uiDecimalPlaces ++;
               }
            }

     
            for ( UINT ui=0; ui < uiDecimalPlaces; ui++ )
            {
                dblFPPart /= (DOUBLE) 10;
            }

            *pdblVal += dblFPPart;
        }
        else if ( pPropertiesPtr && (JPN_FP_PART_D == pPropertiesPtr->ulId) ){

            // The user said "point" and one digit
            SPDBG_ASSERT( VT_UI4 == pPropertiesPtr->pFirstChild->vValue.vt );
            uiDecimalPlaces = 1;
            if ( *pdblVal >= 0 )
            {
                *pdblVal += pPropertiesPtr->pFirstChild->vValue.iVal / 10.0;
            }
            else
            {
                *pdblVal -= pPropertiesPtr->pFirstChild->vValue.iVal / 10.0;
            }

        }
    }

    // Handle the negative sign
    if ( (hr == S_OK) && fNegative)
    {
        *pdblVal = -*pdblVal;

    }

    hr = MakeDisplayNumber( *pdblVal, dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pszVal, cSize);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\command.cpp ===
//
// command.cpp
// This file contains methods related to C&C grammars' commands handling.
//
//
#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "nui.h"
#include "cresstr.h"

#define LB_ID_Correction            200
#define LB_ID_Microphone            201
#define LB_ID_VoiceCmd              202

#define Select_ID_SELECT             1
#define Select_ID_DELETE             2
#define Select_ID_CORRECT            3
#define Select_ID_SELTHROUGH         4
#define Select_ID_DELTHROUGH         5
#define Select_ID_UNSELECT           6
#define Select_ID_SELECTPREV         7
#define Select_ID_SELECTNEXT         8
#define Select_ID_CORRECTPREV        9
#define Select_ID_CORRECTNEXT        10
#define Select_ID_SELSENTENCE        11
#define Select_ID_SELPARAGRAPH       12
#define Select_ID_SELWORD            13
#define Select_ID_SelectAll          14
#define Select_ID_DeletePhrase       15     // Scratch That
#define Select_ID_Convert            16
#define Select_ID_SelectThat         17
#define Select_ID_Finalize           18

#define Navigate_ID_INSERTBEFORE     20
#define Navigate_ID_INSERTAFTER      21
#define Navigate_ID_Go_To_Bottom     22
#define Navigate_ID_Go_To_Top        23
#define Navigate_ID_Move_Home        24
#define Navigate_ID_Move_End         25
        
#define Edit_ID_Undo                 30
#define Edit_ID_Cut                  31
#define Edit_ID_Copy                 32
#define Edit_ID_Paste                33

#define Keyboard_ID_Move_Up          40
#define Keyboard_ID_Move_Down        41
#define Keyboard_ID_Move_Left        42
#define Keyboard_ID_Move_Right       43
#define Keyboard_ID_Page_Up          44
#define Keyboard_ID_Page_Down        45
#define Keyboard_ID_Tab              46
#define Keyboard_ID_Enter            47
#define Keyboard_ID_Backspace        48
#define Keyboard_ID_Delete           49
#define Keyboard_ID_SpaceBar         50

#define Case_ID_CapIt                70	
#define Case_ID_AllCaps              71   
#define Case_ID_NoCaps               72
#define Case_ID_CapThat              73
#define Case_ID_AllCapsThat          74
#define Case_ID_NoCapsThat           75

//
// CSpTask::_DoCommand
//
// review: the rulename may need to be localizable?
//

HRESULT CSpTask::_DoCommand(ULONGLONG ullGramId, SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_GENERAL, "_DoCommand is called");

    if ( pPhrase->Rule.pszName )
    {
        switch (ullGramId)
        {
            case GRAM_ID_URLSPELL:
            case GRAM_ID_CCDICT:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_CCDICT");
                
                if (wcscmp(pPhrase->Rule.pszName, c_szDictTBRule) == 0)
                {
                    hr = _HandleDictCmdGrammar(pPhrase, langid);
                }
                else
                    hr = _HandleModeBiasCmd(pPhrase, langid);

                break;

            case GRAM_ID_CMDSHARED:

                TraceMsg(TF_SAPI_PERF, "Grammar is GRAM_ID_CMDSHARED");
                hr = _HandleShardCmdGrammar(pPhrase, langid);
                break;

/*            case  GRAM_ID_NUMMODE:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_NUMMODE");
                hr = _HandleNumModeGrammar(pPhrase, langid);
                break;
*/

            case GRAM_ID_TBCMD:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_TBCMD");
                hr = _HandleToolBarGrammar(pPhrase, langid);
                break;

            case GRID_INTEGER_STANDALONE:

                TraceMsg(TF_GENERAL, "Grammar is GRID_INTEGER_STANDALONE");
                hr = _HandleNumITNGrammar(pPhrase, langid);
                break;

            case GRAM_ID_SPELLING:

                TraceMsg(TF_GENERAL, "Grammar is GRAM_ID_SPELLING");
                hr = _HandleSpellGrammar(pPhrase, langid);
                break;

            default:
                break;
        }

        if (SUCCEEDED(hr) && m_pime && m_pime->IsFocusFullAware(m_pime->_tim))
        {
            // If this is a Cicero full aware application,
            // we need to finalize the composition after the text has
            // been handled ( changed ) successfully for this command.
            hr = m_pime->_FinalizeComposition();
        }

        // Feeding context to the dictation grammar if it is in diction mode.
        if ( SUCCEEDED(hr) && m_pime  && m_pime->GetDICTATIONSTAT_DictOnOff() )
           m_pime->_SetCurrentIPtoSR();

    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _ShowCommandOnBalloon
//
// Show the command text from currnet Phrase to the Balloon
//----------------------------------------------------------------------------

void CSpTask::_ShowCommandOnBalloon(SPPHRASE *pPhrase)
{

    Assert(pPhrase);


    if (m_pime->GetSpeechUIServer())
    {
        ULONG  ulStartElem, ulNumElems;
        CSpDynamicString dstr;

        ulStartElem = pPhrase->Rule.ulFirstElement;
        ulNumElems = pPhrase->Rule.ulCountOfElements;

        for (ULONG i = ulStartElem; i < ulStartElem + ulNumElems; i++ )
        {
            if (pPhrase->pElements[i].pszDisplayText)
            {
                BYTE           bAttr = 0;

                bAttr = pPhrase->pElements[i].bDisplayAttributes;
                dstr.Append(pPhrase->pElements[i].pszDisplayText);

                if (bAttr & SPAF_ONE_TRAILING_SPACE)
                {
                    dstr.Append(L" ");
                }
                else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                {
                    dstr.Append(L"  ");
                }
            }
        }

        m_pime->GetSpeechUIServer()->UpdateBalloon(TF_LB_BALLOON_RECO, (WCHAR *)dstr, -1);
    }
}

HRESULT CSpTask::_HandleModeBiasCmd(SPPHRASE *pPhrase, LANGID langid)
{

    HRESULT hr = S_OK;

    if (wcscmp(pPhrase->Rule.pszName, c_szDynUrlHist) == 0
     || wcscmp(pPhrase->Rule.pszName, c_szStaticUrlHist) == 0 
     || wcscmp(pPhrase->Rule.pszName, c_szStaticUrlSpell) == 0 )
    {
        // at this moment it's pretty simple, we just handle the first element 
        // for recognition
        //

        if ( pPhrase->pProperties && pPhrase->pProperties[0].pszValue)
        {

            if (wcscmp( pPhrase->pProperties[0].pszValue, L"dict") != 0)
            {
                hr = m_pime->InjectModebiasText(pPhrase->pProperties[0].pszValue, langid);
            }
            else
            {
                ULONG  ulStartElem, ulNumElems;
                CSpDynamicString dstr;

                ulStartElem = pPhrase->Rule.ulFirstElement;
                ulNumElems = pPhrase->Rule.ulCountOfElements;

                for (ULONG i = ulStartElem; i < ulStartElem + ulNumElems; i++ )
                {
                    if (pPhrase->pElements[i].pszDisplayText)
                    {
                        dstr.Append(pPhrase->pElements[i].pszDisplayText);
                    }
                }
                hr = m_pime->InjectModebiasText(dstr, langid);
            }
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// _HandleDictCmdGrammar
//
// Handle all the commands in grammar dictcmd.xml
//
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleDictCmdGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr=S_OK;

    Assert(pPhrase);

    
    if ( pPhrase->pProperties == NULL )
        return hr;

    if (wcscmp(pPhrase->Rule.pszName, c_szDictTBRule) == 0)
    {
        //
        // Handling the toolbar commands in Dictation mode.
        // we have at most three commands support in Dictation mode.
        // Microphone, Correction and Voice Command.
        //

        // If current toolbar doesn't contain the button you spoke, 
        // what you said would be injected to the document as a dictated text.
        //
        // such as there is no "Correction" button on the toolbar, but you said "Correction",
        // text "Correction" should be injected to the document.
        //
        BOOL   fButtonClicked = FALSE;

        if (m_pLangBarSink)
        {
            if ( pPhrase->pProperties[0].pszValue )
            {
                // update the balloon
                _ShowCommandOnBalloon(pPhrase);
                fButtonClicked = m_pLangBarSink->ProcessToolbarCmd(pPhrase->pProperties[0].pszValue);
            }
        }

        if ( fButtonClicked )
        {
            m_pime->SaveLastUsedIPRange( );
            m_pime->SaveIPRange(NULL);
        }
        else
        {
            // there is no such as button on the toolbar.
            //
            // Return FAIL so that the consequent functions would inject the 
            // the RecoResult to the document.
                        
            _UpdateBalloon(IDS_DICTATING, IDS_DICTATING_TOOLTIP);
            TraceMsg(TF_SAPI_PERF, "There is such as button on toolbar");
            hr = E_FAIL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _HandleShardCmdGrammar
//
// Handle all commands in the shared command grammar shrdcmd.xml
// shared grammar is activated in both dictatin and command modes.
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleShardCmdGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
    
    if ( pPhrase->pProperties == NULL )
        return hr;

    ULONG  idCmd;

    ASSERT( VT_UI4 == pPhrase->pProperties[0].vValue.vt );
    idCmd = (ULONG)pPhrase->pProperties[0].vValue.ulVal;

    if ( idCmd == 0 )
    {
        // This is the bogus command
        TraceMsg(TF_GENERAL, "The Bogus command is recognized!!!");
        return hr;
    }

    if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szSelword) )
    {
        // Handel "Selword" rule
        hr = _HandleSelwordCmds(pPhrase, langid, idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szSelThrough) )
    {
        // Handle "Select Through" rule.
        //
        hr = _HandleSelectThroughCmds(pPhrase, langid, idCmd);

    }
    else if (0 == wcscmp(pPhrase->Rule.pszName, c_szSelectSimple))
    {
        // Handle some simple selection commands.
        hr = _HandleSelectSimpleCmds(idCmd);
    } 
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szEditCmds))
    {
        hr = m_pime->ProcessEditCommands(idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szNavigationCmds))
    {
        hr = _HandleNavigationCmds(pPhrase, langid, idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szCasingCmds))
    {
        hr = _HandleCasingCmds(pPhrase, langid, idCmd);
    }
    else if ( 0 == wcscmp(pPhrase->Rule.pszName, c_szKeyboardCmds))
    {
        hr = _HandleKeyboardCmds(langid, idCmd);
    }

   _ShowCommandOnBalloon(pPhrase);
   return hr;
}

HRESULT CSpTask::_HandleNavigationCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{
    HRESULT  hr = S_OK;

    switch (idCmd)
    {
    case Navigate_ID_Move_Home :
        {
            WCHAR  wszKeys[2];

            wszKeys[0] = VK_HOME;
            wszKeys[1] = '\0';

            hr = m_pime->ProcessControlKeys(wszKeys, 1,langid);
            break;
        }

    case Navigate_ID_Move_End :
        {
            WCHAR  wszKeys[2];

            wszKeys[0] = VK_END;
            wszKeys[1] = '\0';

            hr = m_pime->ProcessControlKeys(wszKeys, 1,langid);
            break;
        }

    case Navigate_ID_Go_To_Bottom :

         hr = m_pime->ProcessSelectWord(NULL, 0, SELECTWORD_GOTOBOTTOM);
         break;
    case Navigate_ID_Go_To_Top :

         hr = m_pime->ProcessSelectWord(NULL, 0, SELECTWORD_GOTOTOP);
         break;

    case Navigate_ID_INSERTBEFORE :
    case Navigate_ID_INSERTAFTER :
        {
            SELECTWORD_OPERATION  sw_type;
            CSpDynamicString      dstrSelected;
            ULONG                 ulLen = 0;
            WORD                  PriLangId;

            ULONG   ulStartSelText = 0; // Start element for the selected text
            ULONG   ulNumSelText=0;     // Number of elements for the selected text.
            ULONG   ulStartElem, ulNumElems;
            ULONG   ulStartDelta=0, ulNumDelta=0;

            if ( idCmd == Navigate_ID_INSERTBEFORE )
                 sw_type = SELECTWORD_INSERTBEFORE;
            else
                 sw_type = SELECTWORD_INSERTAFTER;
          
            PriLangId = PRIMARYLANGID(langid);
 
            if ( PriLangId == LANG_ENGLISH)
            {
                ulStartDelta = 2;
                ulNumDelta = 2 ;
            }
            else if ( PriLangId == LANG_JAPANESE )
            {
                ulStartDelta = 0;
                ulNumDelta =  2;
            }
            else if (PriLangId == LANG_CHINESE)
            {
                ulStartDelta = 1;
                ulNumDelta =  2;
            }

            ulStartElem = pPhrase->Rule.ulFirstElement;
            ulNumElems = pPhrase->Rule.ulCountOfElements;

            ulStartSelText = ulStartElem + ulStartDelta;
            if (ulNumElems > ulNumDelta)
                ulNumSelText = ulNumElems - ulNumDelta;
            else 
                ulNumSelText = 0;
                  
            //
            // Get the text for the selection.
            // 
            for (ULONG i = ulStartSelText; i < ulStartSelText + ulNumSelText; i++ )
            {
                if ( pPhrase->pElements[i].pszDisplayText)
                {
                    BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;
                    dstrSelected.Append(pPhrase->pElements[i].pszDisplayText);

                    if ( i < ulStartSelText + ulNumSelText-1 )
                    {
                        if (bAttr & SPAF_ONE_TRAILING_SPACE)
                            dstrSelected.Append(L" ");
                        else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                            dstrSelected.Append(L"  ");
                    }
                }
            }
            if ( dstrSelected )
                ulLen = wcslen(dstrSelected);
                    
            hr = m_pime->ProcessSelectWord(dstrSelected, ulLen, sw_type);

            break;
        }

    default :

        break;
    }

    return hr;
}

HRESULT CSpTask::_HandleKeyboardCmds(LANGID langid, ULONG idCmd)
{
    HRESULT hr = S_OK;
    WCHAR   wszKeys[2];

    wszKeys[0] = '\0';

    switch ( idCmd )
    {
    case Keyboard_ID_Tab :
         wszKeys[0] = VK_TAB;
         break;

    case Keyboard_ID_Enter :
        wszKeys[0] =  VK_RETURN;    // { 0x0d, 0x00 }
        break;

    case Keyboard_ID_Backspace :
        wszKeys[0] = VK_BACK;
        break;

    case Keyboard_ID_Delete :
        wszKeys[0] = VK_DELETE;
        break;

    case Keyboard_ID_SpaceBar :
        wszKeys[0] = VK_SPACE;
        break;

    case Keyboard_ID_Move_Up :
         wszKeys[0] = VK_UP;
         break;

    case Keyboard_ID_Move_Down :
         wszKeys[0] = VK_DOWN;
         break;

    case Keyboard_ID_Move_Left :
         wszKeys[0] = VK_LEFT;
         break;

    case Keyboard_ID_Move_Right :
         wszKeys[0] = VK_RIGHT;
         break;

    case Keyboard_ID_Page_Up :
         wszKeys[0] = VK_PRIOR;
         break;

    case Keyboard_ID_Page_Down :
         wszKeys[0] = VK_NEXT;
         break;

    default :
         break;
    }

    if ( wszKeys[0] )
    {
        wszKeys[1] = L'\0';
        hr = m_pime->ProcessControlKeys(wszKeys, 1,langid);
    }

    return hr;
}


HRESULT CSpTask::_HandleCasingCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{
    HRESULT        hr = S_OK;
    CAPCOMMAND_ID  idCapCmd = CAPCOMMAND_NONE;

    Assert(idCmd);
    Assert(pPhrase);

    switch (idCmd)
    {
    case Case_ID_CapIt :
        idCapCmd = CAPCOMMAND_CapIt;

        break;

    case Case_ID_AllCaps :
        idCapCmd = CAPCOMMAND_AllCaps;

        break;

    case Case_ID_NoCaps :
        idCapCmd = CAPCOMMAND_NoCaps;

        break;

    case Case_ID_CapThat :
        idCapCmd = CAPCOMMAND_CapThat;

        break;

    case Case_ID_AllCapsThat :
        idCapCmd = CAPCOMMAND_AllCapsThat;

        break;

    case Case_ID_NoCapsThat :
        idCapCmd = CAPCOMMAND_NoCapsThat;

        break;
    default :
        Assert(0);
        hr = E_FAIL;
        TraceMsg(TF_GENERAL, "Got a wrong casing command!");
        return hr;
    }

    if ( idCapCmd != CAPCOMMAND_NONE )
    {
        // Capitalize command is recognized.
        CCapCmdHandler  *pCapCmdHandler; 
        pCapCmdHandler = m_pime->GetCapCmdHandler( );

        if ( pCapCmdHandler )
        {
            CSpDynamicString dstrTextToCap;
            ULONG            ulLen = 0;

            if ( idCapCmd > CAPCOMMAND_MinIdWithText )
            {
                ULONG   ulNumCmdElem = 2;
                ULONG   ulStartElem, ulNumElems;
               
                ulStartElem = pPhrase->Rule.ulFirstElement;
                ulNumElems = pPhrase->Rule.ulCountOfElements;
                //
                // the two elements are for command itself
                // 
                for (ULONG i = ulStartElem+ulNumCmdElem; i < ulStartElem + ulNumElems; i++ )
                {
                    if ( pPhrase->pElements[i].pszDisplayText)
                    {
                        BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;

                        dstrTextToCap.Append(pPhrase->pElements[i].pszDisplayText);

                        if (bAttr & SPAF_ONE_TRAILING_SPACE)
                             dstrTextToCap.Append(L" ");
                        else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                             dstrTextToCap.Append(L"  ");
                    }
                }

                if ( dstrTextToCap )
                    ulLen = wcslen(dstrTextToCap);
            }

            pCapCmdHandler->ProcessCapCommands(idCapCmd, dstrTextToCap, ulLen);
        }
    }

    return hr;
}

HRESULT CSpTask::_HandleSelectThroughCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{

    HRESULT hr = S_OK;

    // Select xxx through yyy.

    // dstrText will hold both XXX and YYY. 
    // ulLenXXX keeps the number of characters in XXX part.
    // ulLen keeps the char numbers of the whole text ( XXX + YYY )

    CSpDynamicString   dstrText;
    ULONG              ulLenXXX = 0;  
    ULONG              ulLen = 0;

    ULONG  ulStartElem, ulNumElems;
    ULONG  ulXYStartElem=0, ulXYNumElems=0;  // points to the elements including xxx through yyy.
    BOOL   fPassThrough = FALSE;             // indicates if the "Through" is reached and handled.

    SELECTWORD_OPERATION  sw_type = SELECTWORD_NONE;
    ULONG                 idCommand = 0;
    WCHAR                 *pwszThrough=NULL;


    // This rule has three properties,  the second and third properties are for "select" and "through"
    // the mapping relationship is different based on language.
    const SPPHRASEPROPERTY      *pPropertyFirst = pPhrase->pProperties;
    const SPPHRASEPROPERTY      *pPropertySecond = NULL;
    const SPPHRASEPROPERTY      *pPropertyThird = NULL;

    if ( !pPropertyFirst ) return hr;

    pPropertySecond = pPropertyFirst->pNextSibling;

    if ( !pPropertySecond )  return hr;

    pPropertyThird = pPropertySecond->pNextSibling;

    if ( !pPropertyThird ) return hr;

    ulStartElem = pPhrase->Rule.ulFirstElement;
    ulNumElems = pPhrase->Rule.ulCountOfElements;

    switch ( PRIMARYLANGID(langid) )
    {
    case LANG_ENGLISH :

            ulXYStartElem = ulStartElem + 1;
            ulXYNumElems  = ulNumElems - 1 ;
            // the second property is for "SelectWordCommand"
            // the third property is for "through"
            idCommand = pPropertySecond->vValue.ulVal;
            pwszThrough = (WCHAR *)pPropertyThird->pszValue;

            break;
    case LANG_JAPANESE :

            ulXYStartElem = ulStartElem;
            ulXYNumElems  = ulNumElems - 2 ;
            // the second property is for "through"
            // the third property is for "SelectWordCommand"
            idCommand = pPropertyThird->vValue.ulVal;
            pwszThrough = (WCHAR *)pPropertySecond->pszValue;

            break;
    case LANG_CHINESE :

            ulXYStartElem = ulStartElem + 1;
            ulXYNumElems  = ulNumElems - 1 ;
            // the second property is for "SelectWordCommand"
            // the third property is for "through"
            idCommand = pPropertySecond->vValue.ulVal;
            pwszThrough = (WCHAR *)pPropertyThird->pszValue;

            break;
    default :
            break;
    }

    switch ( idCommand )
    {
    case Select_ID_SELTHROUGH :
        sw_type = SELECTWORD_SELTHROUGH;
        break;

    case Select_ID_DELTHROUGH :
        sw_type = SELECTWORD_DELTHROUGH;
        break;
    }


    // if we cannot find "through" word, return here.
    // or there is a wrong command id.
    if ( !pwszThrough || (sw_type == SELECTWORD_NONE)) return hr;

    for  (ULONG i= ulXYStartElem; i< ulXYStartElem + ulXYNumElems; i++)
    {
        const WCHAR *pElemText;

        pElemText = pPhrase->pElements[i].pszDisplayText;

        if ( !pElemText )
            break;

        if ( 0 == _wcsicmp(pElemText, pwszThrough) )
        {
            // This element is "Through"
            BYTE  bAttrPrevElem;
            fPassThrough = TRUE;

            ulLenXXX = dstrText.Length( );
            // Remove the trail spaces from the previous element.
            if ( i>1 )
            {
                bAttrPrevElem = pPhrase->pElements[i-1].bDisplayAttributes;
                if ( bAttrPrevElem & SPAF_ONE_TRAILING_SPACE )
                    ulLenXXX -- ;
                else if (bAttrPrevElem & SPAF_TWO_TRAILING_SPACES)
                    ulLenXXX -= 2;

                dstrText.TrimToSize(ulLenXXX);
            }
        }
        else
        {
            // This is element for XXX (if fPassThrough is FALSE ) or YYY ( if fPassThrough is TRUE)
            BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;

            dstrText.Append(pPhrase->pElements[i].pszDisplayText);

            if ( i < ulNumElems-1 )
            {
                if (bAttr & SPAF_ONE_TRAILING_SPACE)
                    dstrText.Append(L" ");
                else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                    dstrText.Append(L"  ");
            }
        }
    }

    ulLen = dstrText.Length( );

    if ( dstrText && ulLenXXX > 0 && ulLen > 0 )
        hr = m_pime->ProcessSelectWord(dstrText, ulLen, sw_type, ulLenXXX);

    return hr;
}

HRESULT CSpTask::_HandleSelectSimpleCmds(ULONG idCmd)
{
    HRESULT hr = S_OK;

    // handle "SelectSimplCmds" rule.

    SELECTWORD_OPERATION sw_type = SELECTWORD_NONE;

    switch ( idCmd )
    {
    case Select_ID_UNSELECT :
        sw_type = SELECTWORD_UNSELECT;
        break;

    case Select_ID_SELECTPREV :
        sw_type = SELECTWORD_SELECTPREV;
        break;

    case Select_ID_SELECTNEXT :
        sw_type = SELECTWORD_SELECTNEXT;
        break;

    case Select_ID_CORRECTPREV :
        sw_type = SELECTWORD_CORRECTPREV;
        break;

    case Select_ID_CORRECTNEXT :
        sw_type = SELECTWORD_CORRECTNEXT;
        break;

    case Select_ID_SELSENTENCE :
        sw_type = SELECTWORD_SELSENTENCE;
        break;

    case Select_ID_SELPARAGRAPH :
        sw_type = SELECTWORD_SELPARAGRAPH;
        break;

    case Select_ID_SELWORD :
        sw_type = SELECTWORD_SELWORD;
        break;

    case Select_ID_SelectThat :
        sw_type = SELECTWORD_SELTHAT;
        break;

    case Select_ID_SelectAll :

        hr = m_pime->ProcessEditCommands(Select_ID_SelectAll);
        break;

    case Select_ID_DeletePhrase :

        // call a function to remove an entire phrase
        hr = m_pime->EraseLastPhrase();
        break;

    case Select_ID_Convert :

        hr = m_pime->CorrectThat();
        break;

    case Select_ID_Finalize :

        hr = m_pime->FinalizeAllCompositions( );
        break;

    default :
        hr = E_FAIL;
        Assert(0);
        return hr;
    }


    if ( sw_type != SELECTWORD_NONE )
        hr = m_pime->ProcessSelectWord(NULL, 0, sw_type);

    return hr;
}


HRESULT CSpTask::_HandleSelwordCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd)
{
    HRESULT   hr = S_OK;

    Assert(idCmd);

    // handle "Select Word" 
    // Get the real word/phrase which will be selected.
    // the phrase will contain following elements:
    //      
    //    <select|delete|Correct <Word0> <Word1> <word2> ...
    //
    // the first element must be gateway word.
    //
    CSpDynamicString dstrSelected;
    ULONG   ulLen = 0;
    ULONG   ulStartSelText = 0; // Start element for the selected text
    ULONG   ulNumSelText=0;     // Number of elements for the selected text.
    ULONG   ulStartElem, ulNumElems;
    ULONG   ulStartDelta=0, ulNumDelta=0;

    SELECTWORD_OPERATION  sw_type;

    switch (idCmd)
    {
    case Select_ID_SELECT :
        sw_type = SELECTWORD_SELECT;
        break;
    case Select_ID_DELETE :
        sw_type = SELECTWORD_DELETE;
        break;
    case Select_ID_CORRECT :
        sw_type = SELECTWORD_CORRECT;
        break;
    default :
        Assert(0);
        hr = E_FAIL;
        return hr;
    }

    WORD   prilangid;

    prilangid = PRIMARYLANGID(langid);

    if ((prilangid == LANG_ENGLISH) || (prilangid == LANG_CHINESE))
    {
         ulStartDelta = 1;
         ulNumDelta = 1;
    }
    else if (prilangid == LANG_JAPANESE)
    {
         ulStartDelta = 0;
         ulNumDelta = 2;
    }

    // Get the start element and number of elements for the text to select.
    ulStartElem = pPhrase->Rule.ulFirstElement;
    ulNumElems = pPhrase->Rule.ulCountOfElements;

    ulStartSelText = ulStartElem + ulStartDelta;
    if (ulNumElems > ulNumDelta)
        ulNumSelText = ulNumElems - ulNumDelta;
    else 
        ulNumSelText = 0;
                  
     //
     // Get the text for the selection.
     // 
     for (ULONG i = ulStartSelText; i < ulStartSelText + ulNumSelText; i++ )
     {
          if ( pPhrase->pElements[i].pszDisplayText)
          {
               BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;
               dstrSelected.Append(pPhrase->pElements[i].pszDisplayText);

               if ( i < ulStartSelText + ulNumSelText-1 )
               {
                    if (bAttr & SPAF_ONE_TRAILING_SPACE)
                         dstrSelected.Append(L" ");
                     else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                        dstrSelected.Append(L"  ");
               } 
          }
     }

     if ( dstrSelected )
          ulLen = wcslen(dstrSelected);

     if ( ulLen )
     {
         // check if this is "Select All" or "Select That".
         if ( sw_type == SELECTWORD_SELECT )
         {
             if ( _wcsicmp(dstrSelected, CRStr(IDS_SPCMD_SELECT_ALL) ) == 0 )
             {
                 hr = m_pime->ProcessEditCommands(Select_ID_SelectAll);
                 return hr;
             }

             if ( _wcsicmp(dstrSelected, CRStr(IDS_SPCMD_SELECT_THAT)) == 0 )
                sw_type = SELECTWORD_SELTHAT;
         }

         // redirect "Correct <TEXTBUF:That>" to a simple command "Correct That"
         if ( sw_type == SELECTWORD_CORRECT )
         {
             if ( _wcsicmp(dstrSelected, CRStr(IDS_SPCMD_SELECT_THAT)) == 0 )
             {
                hr = m_pime->CorrectThat();
                return hr;
             }
         }

         hr = m_pime->ProcessSelectWord(dstrSelected, ulLen, sw_type);
     }

     return hr;
}


/*
HRESULT CSpTask::_HandleNumModeGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    const WCHAR c_szNumeric[]       = L"number";
    const WCHAR c_sz1stDigit[]      = L"1st_digit";
    const WCHAR c_sz2ndDigit[]      = L"2nd_digit";
    const WCHAR c_sz3rdDigit[]      = L"3rd_digit";

    if (wcscmp(pPhrase->Rule.pszName, c_szNumeric) == 0)
    {
        // Mode bias support
        if (pPhrase->pProperties)
        {
            CSpDynamicString dstr;
       
           for (const SPPHRASEPROPERTY *pProp=pPhrase->pProperties; pProp != NULL; pProp = pProp->pNextSibling)
           {
               if (wcscmp(pProp->pszName, c_sz3rdDigit) == 0 ||
                   wcscmp(pProp->pszName, c_sz2ndDigit) == 0 ||
                   wcscmp(pProp->pszName, c_sz1stDigit) == 0)
               {
                    dstr.Append(pProp->pszValue);
               }
           }
           hr = m_pime->InjectText(dstr, langid);
       }
   }
                
   return hr;
}

*/
//+---------------------------------------------------------------------------
//
// _HandleToolBarGrammar
//
// Handle toolbar commands when command mode.
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleToolBarGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
                
    if (m_pLangBarSink)
    {
        // get the toolbar cmd rule name to check match
                   
        if (0 == wcscmp(pPhrase->Rule.pszName, m_pLangBarSink->GetToolbarCommandRuleName()))
        {
                        
            // update the balloon
            _ShowCommandOnBalloon(pPhrase);

            // call the handler then
            const SPPHRASEPROPERTY *pProp;

            for (pProp=pPhrase->pProperties; pProp != NULL; pProp = pProp->pNextSibling)
            {
               m_pLangBarSink->ProcessToolbarCmd(pProp->pszName);
            }
            m_pime->SaveLastUsedIPRange( );
            m_pime->SaveIPRange(NULL);
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  _HandleNumITNGrammar
//
//  Handle the number grammar.
//
//+-------------------------------------------------------------------------
HRESULT CSpTask::_HandleNumITNGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
                
    if (S_OK == _EnsureSimpleITN())
    {
        DOUBLE dblVal;
        WCHAR  wszVal[128];
                    
        hr = m_pITNFunc->InterpretNumberSimple(pPhrase->pProperties,
                      &dblVal, wszVal, ARRAYSIZE(wszVal));
        if (S_OK == hr)
        {
            int  iLen = wcslen(wszVal);
            if ( (iLen > 0) && (iLen < 127) && (wszVal[iLen-1] != L' ') )
            {
               // Add one trailing space
               wszVal[iLen] = L' ';
               wszVal[iLen + 1] = L'\0';
            }
                        
            hr = m_pime->InjectText(wszVal, langid);
        }
    }
                   
    return hr;
}

//+---------------------------------------------------------------------------
//
// _HandleSpellGrammar
//
// Handing "Spell It", "Spell That", "Spelling Mode" etc. commands
//----------------------------------------------------------------------------
HRESULT CSpTask::_HandleSpellGrammar(SPPHRASE *pPhrase, LANGID langid)
{
    HRESULT hr = S_OK;

    Assert(pPhrase);

    if (0 == wcscmp(pPhrase->Rule.pszName, c_szSpelling))
    {
        // Handel "Spell It"
        ULONG  ulStartElem, ulNumElems;
        CSpDynamicString dstr;

        ulStartElem = pPhrase->Rule.ulFirstElement;
        ulNumElems = pPhrase->Rule.ulCountOfElements;

        //
        // the first element is for the command itself
        // 
        for (ULONG i = ulStartElem+1; i < ulStartElem + ulNumElems; i++ )
        {
            if ( pPhrase->pElements[i].pszDisplayText)
            {
                dstr.Append(pPhrase->pElements[i].pszDisplayText);
                    
                //
                // only the last element needs the attribute 
                // handling
                //
                if (i == ulStartElem + ulNumElems - 1)
                {
                    BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;
                    if (bAttr & SPAF_ONE_TRAILING_SPACE)
                    {
                        dstr.Append(L" ");
                    }
                    else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                    {
                        dstr.Append(L"  ");
                    }
                }
            }
        }
                    
        hr = m_pime->ProcessSpellIt(dstr, langid);
    }
    else if (0 == wcscmp(pPhrase->Rule.pszName, c_szSpellMode))
    {
        // Handle "Spell Mode" or "Spell That"

        if (pPhrase->pProperties == NULL
           || pPhrase->pProperties[0].pszValue == NULL)
        {
            // this only happens when we hit the bogus word which
            // was added for weight modification
        }
        else if (0 == wcscmp(pPhrase->pProperties[0].pszValue, c_szSpellingMode))
        {
            // Handel "Spelling Mode"

            _SetSpellingGrammarStatus(TRUE, TRUE);
            m_cpRecoCtxt->Resume(0);

            m_pime->SaveLastUsedIPRange( );
            m_pime->SaveIPRange(NULL);

            _ShowCommandOnBalloon(pPhrase);
        }
        else if (0 == wcscmp(pPhrase->pProperties[0].pszValue, c_szSpellThat))
        {
            // Handle "Spell That"
            hr = m_pime->ProcessSpellThat( );
            _ShowCommandOnBalloon(pPhrase);
        }
    }

    return hr;
}

// 
// Hanlders for some commands in CSapiIMX
// 
// Move them from sapilayr.cpp
//


//+---------------------------------------------------------------------------
//
// CSapiIMX::EraseLastPhrase
//
// synopsis - cleans up the feedback UI
// GUID - specifies which feedback UI bar to erase
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::EraseLastPhrase(void)
{
    return _RequestEditSession(ESCB_KILLLASTPHRASE, TF_ES_READWRITE);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessEditCommands(void)
//
// Handle command keys like "Undo That", "Cut That", "Copy That", "Paste That".
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessEditCommands(LONG  idSharedCmd)
{
    HRESULT             hr = E_FAIL;

    ESDATA  esData;
    memset(&esData, 0, sizeof(ESDATA));
    esData.lData1 = (LONG_PTR)idSharedCmd;

    hr = _RequestEditSession(ESCB_PROCESS_EDIT_COMMAND, TF_ES_READWRITE, &esData);
    return hr;
}

//+---------------------------------------------------------------------------
//
// _ProcessEditCommands
//
// Edit session functions for edit commands handling
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::_ProcessEditCommands(TfEditCookie ec, ITfContext *pic, LONG  idSharedCmd)
{
    HRESULT hr = S_OK;

    if ( !pic )
        return E_INVALIDARG;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;
/*
    CComPtr<ITfRange> cpInsertionPoint;

    if ( cpInsertionPoint = GetSavedIP() )
    {
        // Determine if the saved IP was on this context.
        // if not we just ignore that

        CComPtr<ITfContext> cpic;
        hr = cpInsertionPoint->GetContext(&cpic);

        if (S_OK != hr || cpic != pic)
        {
            cpInsertionPoint.Release();
        }
    }

    if (!cpInsertionPoint)
    {
        hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);
    }
       
    if (hr == S_OK)
    {
        // finalize the previous input for now
        hr = _FinalizePrevComp(ec, pic, cpInsertionPoint);
    }
*/


    if ( hr == S_OK )
    {
        // Handle the cmd by simulating the corresponding key events.
        BYTE   vkChar = 0;

        switch ( idSharedCmd )
        {
        case Edit_ID_Undo  :
           vkChar = (BYTE)'Z';
           break;

        case Edit_ID_Cut   :
        case Edit_ID_Copy  :
            {
                CComPtr<ITfRange>  cpRange;
                _GetCmdThatRange(ec, pic, &cpRange);
                
                if ( cpRange )
                    SetSelectionSimple(ec, pic, cpRange);
   
                if (idSharedCmd == Edit_ID_Cut)
                    vkChar = (BYTE)'X';
                else
                    vkChar = (BYTE)'C';

                break;
            }

        case Edit_ID_Paste :
           vkChar = (BYTE)'V';
           break;

        case Select_ID_SelectAll :
            vkChar = (BYTE)'A';
            break;
        }

        if ( vkChar ) 
        {

            m_ulSimulatedKey = 2;   // it will simulate two key strokes.
            keybd_event((BYTE)VK_CONTROL, 0, 0, 0);
            keybd_event(vkChar, 0, 0, 0);
            keybd_event(vkChar, 0, KEYEVENTF_KEYUP, 0);
            keybd_event((BYTE)VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
        }
    }

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
            
    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessControlKeys(void)
//
// Handle command keys like "Tab" or "Enter".
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessControlKeys(WCHAR *pwszKeys, ULONG ulLen, LANGID langid)
{
    HRESULT             hr = E_FAIL;

    if ( pwszKeys == NULL ||  ulLen == 0 )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszKeys;
    esData.uByte = (ulLen+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)ulLen;
    esData.lData2 = (LONG_PTR)langid;

    hr = _RequestEditSession(ESCB_PROCESSCONTROLKEY, TF_ES_READWRITE, &esData);
    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessSpellIt(WCHAR *pwszText, LANGID langid)
//
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessSpellIt(WCHAR *pwszText, LANGID langid)
{
    if ( pwszText == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszText;
    esData.uByte = (wcslen(pwszText)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    
    return _RequestEditSession(ESCB_PROCESS_SPELL_IT, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::_ProcessSpellIt(WCHAR *pwszText, LANGID langid)
//
//  Edit Session function for ESCB_PROCESS_SPELL_IT
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessSpellIt(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid)
{
    HRESULT  hr = S_OK;

    hr = _ProcessSpelledText(ec, pic, pwszText, langid);

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::ProcessSpellThat(void)
//
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::ProcessSpellThat( )
{
    return _RequestEditSession(ESCB_PROCESS_SPELL_THAT, TF_ES_READWRITE);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::_ProcessSpellThat(void)
//
//  Edit Session function for ESCB_PROCESS_SPELL_THAT
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessSpellThat(TfEditCookie ec, ITfContext *pic)
{
    HRESULT  hr = S_OK;

    // Get the previous dictated phrase and mark it as selection.
    CComPtr<ITfRange> cpRange;

    hr = _GetCmdThatRange(ec, pic, &cpRange);
    
    if ( hr == S_OK )
        hr =SetSelectionSimple(ec, pic, cpRange);

    // Then turn on spell mode.

    if ( hr == S_OK && m_pCSpTask )
    {
        hr = m_pCSpTask->_SetSpellingGrammarStatus(TRUE, TRUE);
    }

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
            
    return hr;
}


//+---------------------------------------------------------------------------
//
// _ProcessControlKeys
//
// Real function to handle the control key commands like Tab or Enter.
// 
// It will finialize the previous composing text ( actually characters in 
// Feedback UI).
// 
// and then simulate the related key events.
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessControlKeys(TfEditCookie ec, ITfContext *pic, WCHAR *pwszKey, ULONG ulLen, LANGID langid)
{
    HRESULT hr = S_OK;

    if ( !pic  || !pwszKey || (ulLen == 0) )
        return E_INVALIDARG;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;
/*
    CComPtr<ITfRange> cpInsertionPoint;

    if ( cpInsertionPoint = GetSavedIP() )
    {
        // Determine if the saved IP was on this context.
        // if not we just ignore that

        CComPtr<ITfContext> cpic;
        hr = cpInsertionPoint->GetContext(&cpic);

        if (S_OK != hr || cpic != pic)
        {
            cpInsertionPoint.Release();
        }
    }

    if (!cpInsertionPoint)
    {
        hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);
    }
       
    if (hr == S_OK)
    {
        // finalize the previous input for now
        // 
        hr = _FinalizePrevComp(ec, pic, cpInsertionPoint);
*/

        if ( hr == S_OK )
        {
            BOOL  fHandleKeySucceed = TRUE;

            // simulate the keys.
            for (ULONG i=0; i<ulLen; i++)
            {
                if ( !HandleKey( pwszKey[i] ) )
                {
                    fHandleKeySucceed = FALSE;
                    break;
                }
            }
    
            if ( fHandleKeySucceed == FALSE )
            {
                hr = InjectText(pwszKey, langid);
            }
        }

//    }

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
            
    return hr;
}


//+---------------------------------------------------------------------------
//
// _KillLastPhrase
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_KillLastPhrase(TfEditCookie ec, ITfContext *pic)
{
    HRESULT hr = E_FAIL;

#ifdef _TRY_LATER_FOR_AIMM
    TF_STATUS   tss;
    BOOL        fCiceroNative = TRUE;
    

    hr = pic->GetStatus(&tss);
    if (S_OK == hr)
    {
       //
       // see if the client now is AIMM
       //
       if (tss.dwStaticFlags & TS_SS_TRANSITORY) 
       {
           fCiceroNative = FALSE;
       }
    }
#endif

    CComPtr<ITfRange> cpRange;

    hr = _GetCmdThatRange(ec, pic, &cpRange);

    if ( hr == S_OK && cpRange )
    {
        // found our own input and it is not empty
        _CheckStartComposition(ec, cpRange);
        hr = cpRange->SetText(ec, 0, NULL, 0);

        // trigger redrawing
        SetSelectionSimple(ec, pic, cpRange);
    }

#ifdef _TRY_LATER_FOR_AIMM
    else if (fCiceroNative == FALSE)
    {
         CComPtr<ITfRange> pRStart;
         CComPtr<ITfRange> pREnd;
         BOOL fEmpty;

         hr = pic->GetStart(&pRStart);

         if (S_OK == hr)
             hr = pic->GetEnd(&pREnd);

         if (S_OK == hr)
         {
             hr = pRStart->IsEquealStart(ec, pREnd, TF_ANCHOR_END, &fEmpty);
         }
         if (S_OK == hr && fEmpty)
         {
             // - VK_CONTROL(down) + VK_SHIFT(down) + VK_LEFT(down), then
             // - VK_LEFT(up) + VK_SHIFT(up) + VK_CONTROL(up),       then
             // - VK_DELETE(down) + VK_DELETE(up) 
             //
             keybd_event((BYTE)VK_CONTROL, 0, 0, 0);
             keybd_event((BYTE)VK_SHIFT, 0, 0, 0);
             keybd_event((BYTE)VK_LEFT, 0, 0, 0);

             keybd_event((BYTE)VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
             keybd_event((BYTE)VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
             keybd_event((BYTE)VK_LEFT, 0, KEYEVENTF_KEYUP, 0);

             keybd_event((BYTE)VK_DELETE, 0, 0, 0);
             keybd_event((BYTE)VK_DELETE, 0, KEYEVENTF_KEYUP, 0);
         }
    }
#endif //  _TRY_LATER_FOR_AIMM

    //
    // these moved from HandleRecognition  
    // 
    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
    return hr;
} 

//
// CSapiIMX::_GetCmdThatRange
//
// We have many "xxx That" commands, all these commands require to get 
// a right range. this method will supply a united way to get the right range.
//
// As a Rule, 
//
// If there is a selection before "XXX That" is recognized, we just use 
// that range. 
// If there is no selection, we will try to find the previous dictated phrase
// or a word case by case.
//
//
// ppRange will hold the returned Range interface pointer, it is caller's 
// responsibility to release the range object.
//

#define  MAX_WORD_LENGTH  32

HRESULT  CSapiIMX::_GetCmdThatRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRange)
{
    HRESULT hr = S_OK;

    Assert(pic);
    Assert(ppRange);

    CComPtr<ITfRange> cpIP;
    CComPtr<ITfRange> cpRange;
    BOOL              fEmpty = TRUE;
    BOOL              fGotRange = FALSE;

    TraceMsg(TF_GENERAL, "GetCmdThatRange is called");

    *ppRange = NULL;

    // Get the current IP.
    hr = GetSelectionSimple(ec, pic, &cpIP);

    // is ip empty or selection
    if ( hr == S_OK )
        hr = cpIP->IsEmpty(ec, &fEmpty);

    if ( hr == S_OK )
    {
        if ( !fEmpty )
        {
            // current ip is a selection, just use it.
            hr = cpIP->Clone(&cpRange);

            if ( hr == S_OK )
                fGotRange = TRUE;
        }
        else
        {
            WORD   prilangid;

            prilangid = PRIMARYLANGID(m_langid);

            if ((prilangid == LANG_CHINESE) || (prilangid == LANG_JAPANESE) || !_GetIPChangeStatus( ))
            {
                // If the lang is East Asian, we always try to get the previous dictated phrase first.
                // if lang is English, and there is no ip change since last dictated phrase,
                // we will try to get the previous dictated phrase first.
                fGotRange = _FindPrevComp(ec, pic, cpIP, &cpRange, GUID_ATTR_SAPI_INPUT);

                if ( !fGotRange )
                {
                    // With Office Auto-Correction, the static GUID_PROP_SAPI_DISPATTR property 
                    // on the auto-corrected range could be destroyed.
                    // In this case, we may want to rely on our custom property GUID_PROP_SAPIRESULTOBJECT
                    // to find the real previous dictated phrase.
                    CComPtr<ITfRange>		cpRangeTmp;
                    CComPtr<ITfProperty>	cpProp;
                    LONG					l;

                    hr = cpIP->Clone(&cpRangeTmp);
                    // shift to the previous position
                    if ( hr == S_OK )
                        hr = cpRangeTmp->ShiftStart(ec, -1, &l, NULL);
                    
                    if ( hr == S_OK )
                        hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);

                    if ( hr == S_OK)
                        hr = cpProp->FindRange(ec, cpRangeTmp, &cpRange, TF_ANCHOR_START);

                    if (hr == S_OK && cpRange)
                        hr = cpRange->IsEmpty(ec, &fEmpty);

                    fGotRange = !fEmpty;
                }
            }
        }
    }

    if ( hr == S_OK && !fGotRange )
    {
        // IP must be empty
        // There is no previous dictated phrase, or IP is moved since last dictation.
        // we try to get the word around the ip.
        long               cch=0;
        ULONG              ulch =0;
        CComPtr<ITfRange>  cpRangeTmp;
        WCHAR              pwszTextBuf[MAX_WORD_LENGTH+1];
        ULONG              ulLeft=0, ulRight=0; 

        // Find the first delimiter character in left side from the current IP.
        hr = cpIP->Clone(&cpRangeTmp);
        if ( hr == S_OK )
            hr = cpRangeTmp->ShiftStart(ec, MAX_WORD_LENGTH * (-1), &cch, NULL);

        if ( hr == S_OK && cch < 0 )
            hr = cpRangeTmp->GetText(ec, 0, pwszTextBuf, MAX_WORD_LENGTH, &ulch);

        if ( hr == S_OK && ulch > 0 )
        {
            pwszTextBuf[ulch] = L'\0';

            for ( long i=(long)ulch-1; i>=0; i-- )
            {
                WCHAR  wch;
                wch = pwszTextBuf[i];

                if ( iswpunct(wch) || iswspace(wch) )
                    break;

                ulLeft++;
            }
        }

        // Find the first delimiter character in right side from the right 

        if ( hr == S_OK && cpRangeTmp )
        {
            cpRangeTmp.Release( );
            hr = cpIP->Clone(&cpRangeTmp);
        }

        if ( hr == S_OK )
            hr = cpRangeTmp->ShiftEnd(ec, MAX_WORD_LENGTH, &cch, NULL);

        if ( hr == S_OK && cch > 0 )
            hr = cpRangeTmp->GetText(ec, 0, pwszTextBuf, MAX_WORD_LENGTH, &ulch);

        if ( hr == S_OK && ulch > 0 )
        {
            pwszTextBuf[ulch] = L'\0';

            for ( long i=0; i<(long)ulch; i++ )
            {
                WCHAR  wch;
                wch = pwszTextBuf[i];

                if ( iswpunct(wch) || iswspace(wch) )
                    break;

                ulRight++;
            }
        }

        if ( hr == S_OK )
            hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_START);

        // Move end anchor right number
        if (hr == S_OK && ulRight > 0 )
            hr = cpRangeTmp->ShiftEnd(ec, ulRight, &cch, NULL);

        // Move start anchor left number.
        if ( hr == S_OK && ulLeft > 0 )
            hr = cpRangeTmp->ShiftStart(ec, (long)ulLeft * (-1), &cch, NULL);

        if ( hr == S_OK )
        {
            hr = cpRangeTmp->Clone(&cpRange);
            fGotRange = TRUE;
        }
    }

    if ( hr == S_OK && fGotRange && cpRange )
    {
        *ppRange = cpRange;
        (*ppRange)->AddRef( );

        TraceMsg(TF_GENERAL, "Got the xxx That range!");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\citn.h ===
#ifndef CITN_H
#define CITN_H

#include "sphelper.h"

// Flags for number display
typedef enum DISPLAYFLAGS
{
    DF_UNFORMATTED      = (1L << 0),// No formatting
    DF_ORDINAL          = (1L << 1),// Ordinal number
    DF_WHOLENUMBER      = (1L << 2),// Should be displayed without decimal
    DF_FIXEDWIDTH       = (1L << 3),// Requiring a certain width
    DF_LEADINGZERO      = (1L << 4),// Presence of leading 0 of the number is between 0 and 1
    DF_NOTHOUSANDSGROUP = (1L << 5),// Do not do any thousands grouping (commas)
    DF_MILLIONBILLION   = (1L << 6) // If the number is a flat "millions" or "billions"
                                    // then display as "3 million"
}   DISPLAYFLAGS;

class CSimpleITN
{
public:

    CSimpleITN(LANGID langid)
    {
        m_langid       = langid;
        m_pwszNeg      = NULL;
    }
    ~CSimpleITN()
    {
        if (m_pwszNeg)
            delete m_pwszNeg;

        if ( m_nmfmtDefault.lpDecimalSep )
            delete[] m_nmfmtDefault.lpDecimalSep;

        if ( m_nmfmtDefault.lpThousandSep )
            delete[] m_nmfmtDefault.lpThousandSep;
    }

    HRESULT _EnsureNumberFormatDefaults(void);
    HRESULT MakeNumberNegative( WCHAR *pwszNumber, UINT cSize );
    HRESULT MakeDisplayNumber( DOUBLE dblNum, DWORD dwDisplayFlags,
                               UINT uiFixedWidth, UINT uiDecimalPlaces,
                               WCHAR *pwszNum, UINT cSize );

    HRESULT InterpretNumberSimple(const SPPHRASEPROPERTY *pProperties, 
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize)
    {
        HRESULT hr = _EnsureNumberFormatDefaults();

        if (S_OK != hr)
            return hr;
        

        hr = E_NOTIMPL;
        switch(PRIMARYLANGID(m_langid))
        {
            case LANG_ENGLISH:
                hr = InterpretNumberEn(pProperties, 
                            TRUE,
                            pdblVal,
                            pszVal,
                            cSize,
                            TRUE);
                break;
            case LANG_JAPANESE:
                hr = InterpretNumberJp(pProperties, 
                            TRUE,
                            pdblVal,
                            pszVal,
                            cSize,
                            TRUE);
                break;
            case LANG_CHINESE:
                hr = InterpretNumberCh(pProperties, 
                            TRUE,
                            pdblVal,
                            pszVal,
                            cSize,
                            TRUE);
                break;
            default:
                break;
        }
        return hr;
    }


    HRESULT InterpretNumberEn(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt);

    HRESULT InterpretIntegerEn(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    HRESULT InterpretDecimalEn(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    ULONG ComputeNum999En(const SPPHRASEPROPERTY *pProperties );


    HRESULT InterpretNumberJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt);

    HRESULT InterpretIntegerJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);
    
    HRESULT InterpretDecimalJp(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    ULONG ComputeNum9999Jp(const SPPHRASEPROPERTY *pProperties );

    HRESULT InterpretNumberCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt);

    HRESULT InterpretIntegerCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    HRESULT InterpretDecimalCh(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt,
                            BOOL  fNegative);

    ULONG ComputeNum9999Ch(const SPPHRASEPROPERTY *pProperties);
    ULONG ComputeNum10000Ch(const SPPHRASEPROPERTY *pProperties);

private:
    WCHAR       *m_pwszNeg;
    LANGID      m_langid;
    NUMBERFMTW  m_nmfmtDefault;
};


#define BILLIONS                      1
#define MILLIONS                      2
#define THOUSANDS                     3
#define HUNDREDS                      4
#define TENS                          5 
#define ONES                          6
#define TEENS                       200
#define NEGATIVE                      7
#define MILLBILL                      8
#define DIGIT                         9
#define TWODIGIT                     10
#define FP_PART                      11
#define ZERO                         12
#define POINT_ZERO                   13
#define NUMERATOR                    14
#define DENOMINATOR                  15
#define WHOLE                        16
#define ONEDIGIT                     17
#define GRID_INTEGER_99            101
#define GRID_INTEGER_999           102
#define GRID_INTEGER_MILLBILL      103
#define GRID_INTEGER_STANDALONE    104
#define GRID_INTEGER               105
#define GRID_INTEGER_NONNEG        106
#define GRID_DIGIT_NUMBER          107
#define GRID_FP_NUMBER             108
#define GRID_FP_NUMBER_NONNEG      109

// Definition for Chinese Grammar.
#define    CHS_HUNDREDMILLIONS      1
#define    CHS_TENTHOUSANDS         2
#define    CHS_TENTHOUSANDS_        3
#define    CHS_THOUSANDS            4
#define    CHS_HUNDREDS             5
#define    CHS_HUNDREDS_            6
#define    CHS_ONES                 7
#define    CHS_INTEGER              8
#define    CHS_DECIMAL              9
#define    CHS_NEGATIVE             10
#define    CHS_PERIOD               23
#define    CHS_DIGITS               24
#define    CHS_POS_OF_MINUS         27
#define    CHS_ONES_THOUSANDS       28
#define    CHS_GRID_NUMBER          1001
#define    CHS_GRID_NUMBER_MINUS    1002
#define    CHS_GRID_DECIMAL         1003
#define    CHS_GRID_NUMBER_ALL      1004

// Definition for Japanese Grammar
#define    JPN_YENs                 1
#define    JPN_CHOOs                2
#define    JPN_OKUs                 3
#define    JPN_MANNs                4
#define    JPN_SENNs                5
#define    JPN_HYAKUs               6
#define    JPN_JUUs                 7
#define    JPN_ICHIs                8
#define    JPN_NEGATIVE             9
#define    JPN_DIGIT                10
#define    JPN_FP_PART              12
#define    JPN_FP_PART_D            95
#define    JPN_ZERO                 13
#define    JPN_NUMERATOR            14
#define    JPN_DENOMINATOR          15
#define    JPN_WHOLE                16
#define    JPN_GRID_INTEGER_9999          1001
#define    JPN_GRID_INTEGER_STANDALONE    1002
#define    JPN_GRID_INTEGER               1003
#define    JPN_GRID_INTEGER_NONNEG        1004
#define    JPN_GRID_DIGIT_NUMBER          1005
#define    JPN_GRID_FP_NUMBER             1006
#define    JPN_GRID_NUMBER_ALL            1007

#endif // CITN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\correct.cpp ===
//
//
// Sapilayr TIP CCorrectionHandler implementation.
//
// Implement correction related dictation commands.
// such as 
//       Correct That
//       Recovert
//       Correction
//
//       Correct <Phrase>
//  
// Move the correction related functions to this separate class
//
//
#include "private.h"
#include "sapilayr.h"
#include "correct.h"


// -------------------------------------------------------
//
//  Implementation for CCorrectionHandler
//
// -------------------------------------------------------

CCorrectionHandler::CCorrectionHandler(CSapiIMX *psi) 
{
    m_psi = psi;
    fRestoreIP = FALSE;
}

CCorrectionHandler::~CCorrectionHandler( ) 
{

};


//
// Save the IP right before the candidate UI is opened.
//
// This IP would be restored if the candidate UI is cancelled.
// Or after the alternate text is injected when correct command requires 
// to restore this ip.
//
// Client can call _SetRestoreIPFlag( ) to indicate if it wants to restore
// the IP after a new alternate text is injected.
//
// Currently "Correct <Phrase>" command wants to restore the IP, but other
// commands "Correct That, Correction, Reconvert" don't want to restore IP.
//
// Everytime the candidate UI is closed, this IP needs to be released to avoid
// any possible memory leak.
//
HRESULT CCorrectionHandler::_SaveCorrectOrgIP(TfEditCookie ec, ITfContext *pic)
{
    CComPtr<ITfRange>   cpSel;

    HRESULT hr = GetSelectionSimple(ec, pic, (ITfRange **)&cpSel);

    if (SUCCEEDED(hr))
    {
        m_cpOrgIP.Release( );
        hr = cpSel->Clone(&m_cpOrgIP);
    }

    return hr;
}

void CCorrectionHandler::_ReleaseCorrectOrgIP( )
{
    if ( m_cpOrgIP )
    {
        // clear m_cpOrgIP so that it would not affect consequent candidate behavior
        // 
        m_cpOrgIP.Release( );
    }

    fRestoreIP = FALSE;
}

// 
// edit session callback function for RESTORE_CORRECT_ORGIP.
//
HRESULT CCorrectionHandler::_RestoreCorrectOrgIP(TfEditCookie ec, ITfContext *pic)
{
    HRESULT hr = S_OK;

    // we just want to restore the original saved IP.
    if ( m_cpOrgIP )
    {
        hr = SetSelectionSimple(ec, pic, m_cpOrgIP);
        _ReleaseCorrectOrgIP( );
    }
    
    return hr;
}

//
// Start an edit session to restore the original IP
//
//
HRESULT CCorrectionHandler::RestoreCorrectOrgIP(ITfContext *pic )
{
    HRESULT hr = E_FAIL;

    if ( !m_psi ) return E_FAIL;

    if (pic)
    {
        hr = m_psi->_RequestEditSession(ESCB_RESTORE_CORRECT_ORGIP, TF_ES_READWRITE, NULL, pic);
    }

    return hr;
}

//
// Handle Correct That, Reconvert commands
//
HRESULT CCorrectionHandler::CorrectThat()
{
    HRESULT hr = E_FAIL;

    if ( !m_psi ) return E_FAIL;

    hr = m_psi->_RequestEditSession(ESCB_RECONV_ONIP, TF_ES_READWRITE);

    return hr;
}

//
// Edit session callback function for CorrectThat.
//
HRESULT CCorrectionHandler::_CorrectThat(TfEditCookie ec, ITfContext *pic)
{
    HRESULT hr = E_FAIL;
    ITfRange *pSel = NULL;

    TraceMsg(TF_GENERAL, "_CorrectThat is called");

    if ( !m_psi ) return E_FAIL;

    if (pic)
    {
        // remove the green bar
        m_psi->_KillFeedbackUI(ec, pic, NULL);

        hr = m_psi->_GetCmdThatRange(ec, pic, &pSel);
    }
    
    if (SUCCEEDED(hr) && pSel)
    {
        hr = _ReconvertOnRange(pSel);
    }
    
    SafeRelease(pSel);

    // moved from _HandleRecognition as this is a command
    //
    m_psi->SaveLastUsedIPRange( );
    m_psi->SaveIPRange(NULL);
    return hr;
}

HRESULT  CCorrectionHandler::_SetSystemReconvFunc( )
{
    HRESULT hr = S_OK;

    if (!m_cpsysReconv)
    {
        CComPtr<ITfFunctionProvider>  cpsysFuncPrv;

        hr = (m_psi->_tim)->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, &cpsysFuncPrv);

        if (hr == S_OK)
            hr = cpsysFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&m_cpsysReconv);
    }

    return hr;
}

void     CCorrectionHandler::_ReleaseSystemReconvFunc( )
{
    if (m_cpsysReconv)
        m_cpsysReconv.Release( );
}


// 
// CCorrectionHandler::_ReconvertOnRange
// 
// Try to get the candidate UI for the given pRange if this range contains speech alternates
// data.
//
// pRange could be a selection or an IP.
//
//
HRESULT CCorrectionHandler::_ReconvertOnRange(ITfRange *pRange, BOOL  *pfConvertable)
{
    HRESULT hr = E_FAIL;
    ITfRange *pAttrRange = NULL;
    BOOL fConvertable = FALSE;

    TraceMsg(TF_GENERAL, "_ReconvertOnRange is called");

    if ( !pRange )  return E_INVALIDARG;

    hr = pRange->Clone(&pAttrRange);

    if (S_OK == hr && pAttrRange)
    {
        CComPtr<ITfRange>     cpRangeReconv;

        hr = _SetSystemReconvFunc( );    
        if ( hr == S_OK )
            hr = m_cpsysReconv->QueryRange(pAttrRange, &cpRangeReconv, &fConvertable);

        if ( (hr == S_OK) && fConvertable && cpRangeReconv)
        {
            // The text owner could be any other tips, and other tips may want to 
            // request a new R/W edit session to open reconvert UI.
            // Cicero would return E_LOCKED if other tip wants to request edit session while 
            // speech tip is under an edit session.
            //
            // To resolve this problem, speech tip just save the cpRangeReconv post a message
            // to the work window and then immediatelly end this edit session.
            //
            // When the work window receives the private message, the window procedure function 
            // will do a real reconvert work.

            m_cpCorrectRange.Release( );
            hr = cpRangeReconv->Clone(&m_cpCorrectRange);

            if ( hr == S_OK )
                PostMessage(m_psi->_GetWorkerWnd( ), WM_PRIV_DORECONVERT, 0, 0);
        }
    }

    SafeRelease(pAttrRange);

    if ( pfConvertable )
        *pfConvertable = fConvertable;

    return hr;
}

// 
// CCorrectionHandler::_DoReconvertOnRange
// 
// When WM_.... is handled, this function will be called.
// ReconvertOnRange( ) post the above private message and prepare
// all the necessary range data in the class object.
// This function will do the real reconvertion.
//
HRESULT CCorrectionHandler::_DoReconvertOnRange( )
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_GENERAL, "_DoReconvertOnRange is called");

    if ( !m_cpCorrectRange )  return hr;

    hr = _SetSystemReconvFunc( );

    if ( hr == S_OK )
        hr = m_cpsysReconv->Reconvert(m_cpCorrectRange);
    
    _ReleaseSystemReconvFunc( );

    return hr;
}

//
// Moved here from CSapiIMX
//
HRESULT CCorrectionHandler::SetReplaceSelection(ITfRange *pRange,  ULONG cchReplaceStart,  ULONG cchReplaceChars, ITfContext *pic)
{
    HRESULT hr = E_FAIL;
    ESDATA  esData;

    if ( !m_psi ) return E_FAIL;

    memset(&esData, 0, sizeof(ESDATA));

    esData.lData1 = (LONG_PTR)cchReplaceStart;
    esData.lData2 = (LONG_PTR)cchReplaceChars;
    esData.pRange = pRange;
    
    hr = m_psi->_RequestEditSession(ESCB_SETREPSELECTION, TF_ES_READWRITE, &esData, pic); 

    return hr;
}


//
//  _SetReplaceSelection
//
//  synoposis: calculate the span of text range based on the specified length of 
//             the selected alternate string (cchReplacexxx)
//             then set a selection basedon it.
//
HRESULT CCorrectionHandler::_SetReplaceSelection
(
    TfEditCookie ec, 
    ITfContext *pic,     ITfRange *pRange, 
    ULONG cchReplaceStart, 
    ULONG cchReplaceChars
)
{
    // adjust pRange here
    CComPtr<ITfProperty>    cpProp;
    CComPtr<ITfRange>       cpPropRange;
    CComPtr<ITfRange>       cpClonedPropRange;

    if ( !m_psi ) return E_FAIL;
   
    HRESULT hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);
    if (S_OK == hr)
    {
        hr = cpProp->FindRange(ec, pRange, &cpPropRange, TF_ANCHOR_START);
    }
    
    if (S_OK == hr)
    {
        hr = cpPropRange->Clone(&cpClonedPropRange);
    }
    if (S_OK == hr)
    {
        hr = cpClonedPropRange->Collapse(ec, TF_ANCHOR_START);
    }

    if (S_OK == hr)
    {
        long cch;
        cpClonedPropRange->ShiftStart(ec, cchReplaceStart, &cch, NULL);
        cpClonedPropRange->ShiftEnd(ec, cchReplaceChars, &cch, NULL);
    }

    SetSelectionSimple(ec, pic, cpClonedPropRange);

    if ( m_psi->GetDICTATIONSTAT_DictOnOff())
        m_psi->_FeedIPContextToSR(ec, pic, cpClonedPropRange); 
        
    // discurd IP
    m_psi->SaveIPRange(NULL);

    return hr;
}


//+---------------------------------------------------------------------------
//
// CCorrectionHandler::InjectAlternateText
//
//----------------------------------------------------------------------------
HRESULT CCorrectionHandler::InjectAlternateText
(
    const WCHAR *pwszResult, 
    LANGID langid, 
    ITfContext *pic,
    BOOL   bHandleLeadingSpace
)
{
    HRESULT hr = E_FAIL;

    Assert(pwszResult);
    Assert(pic);

    if ( !m_psi ) return E_FAIL;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszResult;
    esData.uByte = (wcslen(pwszResult)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    esData.fBool = bHandleLeadingSpace;

    hr = m_psi->_RequestEditSession(ESCB_PROCESS_ALTERNATE_TEXT,TF_ES_READWRITE, &esData, pic);

    return hr;
}


HRESULT CCorrectionHandler::_ProcessAlternateText(TfEditCookie ec, WCHAR *pwszText,LANGID langid, ITfContext *pic, BOOL bHandleLeadingSpace)
{
    HRESULT hr = S_OK;

    if ( !m_psi ) return E_FAIL;

    CComPtr<ITfRange>  cpRangeText;

    // Save the current selection as text range which is used
    // later to handle leading spaces.
    //
    if ( bHandleLeadingSpace )
    {
        CComPtr<ITfRange>  cpSelection;

        hr = GetSelectionSimple(ec, pic, &cpSelection);

        if ( hr == S_OK && cpSelection )
            hr = cpSelection->Clone(&cpRangeText);
    }

    if ( hr == S_OK )
        hr = m_psi->_ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, TRUE);

    if ( hr == S_OK && bHandleLeadingSpace && pwszText && cpRangeText)
    {
        // If the first element is updated by the alternate phrase
        // speech tip needs to check if this new alternate wants to 
        // consume the leading space or if extra space is required to add
        // between this phrase and previous phrase.
        // 
        BOOL   bConsumeLeadingSpace = FALSE;
        WCHAR  wchFirstChar = pwszText[0];

        if ( iswcntrl(wchFirstChar) || iswpunct(wchFirstChar) )
            bConsumeLeadingSpace = TRUE;

        if ( hr == S_OK)
            hr = m_psi->_ProcessLeadingSpaces(ec, pic, cpRangeText, bConsumeLeadingSpace, langid, FALSE); 
    }

    if ( fRestoreIP )
        _RestoreCorrectOrgIP(ec, pic);
    else
        _ReleaseCorrectOrgIP( );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\correct.h ===
#ifndef _CORRECTION_H
#define _CORRECTION_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

class __declspec(novtable) CCorrectionHandler
{
public:
    CCorrectionHandler(CSapiIMX *psi);
    virtual ~CCorrectionHandler( );

    HRESULT InjectAlternateText(const WCHAR *pwszResult, LANGID langid, ITfContext *pic, BOOL bHandleLeadingSpace=FALSE);
    HRESULT _ProcessAlternateText(TfEditCookie ec, WCHAR *pwszText,LANGID langid, ITfContext *pic, BOOL bHandleLeadingSpace=FALSE);

    HRESULT CorrectThat();
    HRESULT _CorrectThat(TfEditCookie ec, ITfContext *pic);

    HRESULT _ReconvertOnRange(ITfRange *pRange, BOOL  *pfConvertable = NULL);
    HRESULT _DoReconvertOnRange( );

    HRESULT SetReplaceSelection(ITfRange *pRange,  ULONG cchReplaceStart,  ULONG cchReplaceChars, ITfContext *pic);
    HRESULT _SetReplaceSelection(TfEditCookie ec,  ITfContext *pic,  ITfRange *pRange,  ULONG cchReplaceStart,  ULONG cchReplaceChars);

    HRESULT _SaveCorrectOrgIP(TfEditCookie ec, ITfContext *pic);
    HRESULT _RestoreCorrectOrgIP(TfEditCookie ec, ITfContext *pic);
    void    _ReleaseCorrectOrgIP( );

    HRESULT RestoreCorrectOrgIP(ITfContext *pic);

    void    _SetRestoreIPFlag( BOOL fRestore )  {  fRestoreIP = fRestore; };

    HRESULT  _SetSystemReconvFunc( );
    void     _ReleaseSystemReconvFunc( );

private:

    CSapiIMX            *m_psi;
    CComPtr<ITfRange>   m_cpOrgIP;
    BOOL                fRestoreIP;  
                                     // indicates if need to restore IP 
                                     // after an alternate text is injected
                                     // to the doc.

                                     // If no alternate text is injected and the
                                     // candidate UI window is cancelled, it is always
                                     // to restore IP.

    CComPtr<ITfRange>   m_cpCorrectRange;  // the range to be corrected.
    CComPtr<ITfFnReconversion>    m_cpsysReconv;  //The system Reconverston function object.

    
};

#endif  // _CORRECTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\correctionimx.cpp ===
//
// correctionimx.cpp
//
#include "private.h"

#ifdef SUPPORT_INTERNAL_WIDGET

#include "globals.h"
#include "timsink.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "spdebug.h"
#include "sphelper.h"
#include "mscandui.h"
#include "computil.h"
#include "ids.h"
#include "cicspres.h"
#include <conio.h>

#define WM_USERLBUTTONDOWN  WM_USER+10000        // Replacement for LBUTTONDOWN to fix raid 8828.

LPCTSTR  g_lpszClassName = TEXT("CorrectionWidget");

// BUGBUG - Pixel values currently. Need to take account of screen DPI.
const ULONG g_uWidgetWidth              = 11;
const ULONG g_uWidgetHeight             = 11;
const ULONG g_uActualWidgetHeight       = 7;
const ULONG g_uExpandedWidgetWidth      = 20;
const ULONG g_uExpandedWidgetHeight     = 16;
const ULONG g_uExpandedWidgetXOffset    = g_uExpandedWidgetWidth - (g_uExpandedWidgetWidth - g_uWidgetWidth)/2;
const ULONG g_uWidgetYOffset            = 0;    // Position expanded widget just touching actual edge of correction list when it's above widget.
const ULONG g_uExpandedWidgetYOffset    = 0;    // Position expanded widget just touching actual edge of correction list when it's above widget.
												// ** These NEED to match the icons and each other to avoid misbehavors. **
												// Small widget MUST be entirely enclosed by large widget.
const ULONG g_cSloppySelection          = 3;

const ULONG g_uTimerLength              = 2500; // Time before the widget starts fading out.
const ULONG g_uTimerFade                = 10;   // Time between alpha decrements for fadeout.
const ULONG g_uAlphaFade                = 4;    // Alpha fade decrement every 10ms for fadeout effect.
const ULONG g_uAlpha                    = 216;  // Should be multiples of g_uAlphaFade
const ULONG g_uAlphaLarge               = 255;  // Can be anything.
const ULONG g_uAlphaInvisible           = 5;    // Needs to be sufficiently non zero that when combined with above, still receives mouse events.
                                                // Can be 4 minimum when combined with alpha 255 for 24/32 bit color mode.
                                                // Needs to be at least 5 when in 16 bit color mode.

const ULONG g_uTimerSloppyMouseLeave    = 500;  // Time after mouse leave correction window that it resizes small.

/****************************************************************************
* CCorrectionIMX::CCorrectionIMX *
*--------------------------------*
*   Description:
*       Constructor for Correction 1Tip.
*     
*   Returns: 
*       None.
*     
*   Args: 
*       None
*
**************************************************************** agarside ***/

CCorrectionIMX::CCorrectionIMX()  : m_dwEditCookie(0),
                                    m_dwLayoutCookie(0),
                                    m_dwThreadFocusCookie(0),
                                    m_dwKeyTraceCookie(0),
                                    m_fExpanded(FALSE),
                                    m_hWnd(NULL),
                                    m_hIconInvoke(NULL),
                                    m_hIconInvokeLarge(NULL),
                                    m_hIconInvokeClose(NULL),
                                    m_eWindowState(WINDOW_HIDE),
                                    m_fDisplayAlternatesMyself(FALSE),
                                    m_fCandidateOpen(FALSE),
                                    m_fKeyDown(FALSE),
                                    m_hAtom(0)
{
    SPDBG_FUNC("CCorrectionIMX::CCorrectionIMX");
    memset(&m_rcSelection, 0, sizeof(m_rcSelection));
}

/****************************************************************************
* CCorrectionIMX::~CCorrectionIMX *
*---------------------------------*
*   Description:
*       Destructor for Correction Tip
*     
*   Returns: 
*       None.
*     
**************************************************************** agarside ***/

CCorrectionIMX::~CCorrectionIMX()
{
    SPDBG_FUNC("CCorrectionIMX::~CCorrectionIMX");
    if (m_hWnd)
    {
        DestroyWindow(m_hWnd);
    }
    if (m_hIconInvoke)
    {
        DestroyIcon(m_hIconInvoke);
        m_hIconInvoke = NULL;
    }
    if (m_hIconInvokeLarge)
    {
        DestroyIcon(m_hIconInvokeLarge);
        m_hIconInvokeLarge = NULL;
    }
    if (m_hIconInvokeClose)
    {
        DestroyIcon(m_hIconInvokeClose);
        m_hIconInvokeClose = NULL;
    }
}

/****************************************************************************
* CCorrectionIMX::FinalConstruct *
*--------------------------------*
*   Description:
*       Preliminary initialization of the object.
*       Creates window class and hidden window for message pump.
*       Loads icon resources.
*     
*   Returns: HRESULT 
*     S_OK  - Everything succeeded.
*     Otherwise, appropriate error code.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::FinalConstruct()
{
    SPDBG_FUNC("CCorrectionIMX::FinalConstruct");
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        m_hIconInvoke      = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_INVOKE), IMAGE_ICON, g_uWidgetWidth, g_uWidgetHeight, 0);
        ASSERT("Failed to create small invocation icon." && m_hIconInvoke);
        if (!m_hIconInvoke)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_hIconInvokeLarge = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_INVOKE), IMAGE_ICON, g_uExpandedWidgetWidth, g_uExpandedWidgetHeight, 0);
        ASSERT("Failed to create large invocation icon." && m_hIconInvokeLarge);
        if (!m_hIconInvokeLarge)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_hIconInvokeClose = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_INVOKECLOSE), IMAGE_ICON, g_uExpandedWidgetWidth, g_uExpandedWidgetHeight, 0);
        ASSERT("Failed to create large invocation icon." && m_hIconInvokeClose);
        if (!m_hIconInvokeClose)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!CicLoadStringWrapW(g_hInst, IDS_DELETESELECTION, m_wszDelete, ARRAYSIZE(m_wszDelete))
        {
            hr = E_OUTOFMEMORY;
        }
        if (!CicLoadStringWrapW(g_hInst, IDS_ADDTODICTIONARYPREFIX, m_wszAddPrefix, ARRAYSIZE(m_wszAddPrefix))
        {
            hr = E_OUTOFMEMORY;
        }
        if (!CicLoadStringWrapW(g_hInst, IDS_ADDTODICTIONARYPOSTFIX, m_wszAddPostfix, ARRAYSIZE(m_wszAddPostfix))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::LazyInitializeWindow *
*--------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::LazyInitializeWindow()
{
    SPDBG_FUNC("CCorrectionIMX::LazyInitializeWindow");
    HRESULT hr = S_OK;

    if (m_hWnd)
    {
        return S_OK;
    }

    WNDCLASSEX wndClass;
    memset(&wndClass, 0, sizeof(wndClass));
    wndClass.cbSize = sizeof(wndClass);
    wndClass.style = CS_HREDRAW | CS_VREDRAW;
    wndClass.lpszClassName = g_lpszClassName;
    wndClass.hInstance = _Module.GetModuleInstance();
    wndClass.lpfnWndProc = WndProc;
    wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
    ATOM hAtom;
    if ((hAtom = RegisterClassEx(&wndClass)) == 0)
    {
        ASSERT("Failed to register window class." && FALSE);
    }
    if (SUCCEEDED(hr))
    {
        m_hAtom = hAtom;
        m_hWnd = CreateWindowEx(WS_EX_TOPMOST | WS_EX_NOACTIVATE | WS_EX_LAYERED, g_lpszClassName, g_lpszClassName, WS_POPUP | WS_DISABLED, 0, 0, g_uWidgetWidth, g_uWidgetHeight, NULL, NULL, _Module.GetModuleInstance(), this);
        ASSERT("Failed to create hidden window." && m_hWnd);
        if (!m_hWnd)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::DrawWidget *
*----------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     BYTE uAlpha
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::DrawWidget(BYTE uAlpha)
{
    SPDBG_FUNC("CCorrectionIMX::DrawWidget");
    HRESULT hr = S_OK;
    
    typedef struct _RGBALPHA {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbAlpha;
    } RGBALPHA;
    
    HDC         hdcScreen = NULL;
    HDC         hdcLayered = NULL;
    RECT        rcWindow;
    SIZE        size;
    BITMAPINFO  BitmapInfo;
    HBITMAP     hBitmapMem = NULL;
    HBITMAP     hBitmapOld = NULL;
    void        *pDIBits;
    int         i;
    int         j;
    POINT       ptSrc;
    POINT       ptDst;
    BLENDFUNCTION Blend;
    BOOL        bRet;
    RGBALPHA    *ppxl;
    
    GetWindowRect( m_hWnd, &rcWindow );
    size.cx = rcWindow.right - rcWindow.left;
    size.cy = rcWindow.bottom - rcWindow.top;
    
    hdcScreen = GetDC( NULL );
    if (hdcScreen == NULL) 
    {
        return E_FAIL;
    }
    
    hdcLayered = CreateCompatibleDC( hdcScreen );
    if (hdcLayered == NULL) 
    {
        ReleaseDC( NULL, hdcScreen );
        return E_FAIL;
    }
    
    // create bitmap
    BitmapInfo.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    BitmapInfo.bmiHeader.biWidth         = size.cx;
    BitmapInfo.bmiHeader.biHeight        = size.cy;
    BitmapInfo.bmiHeader.biPlanes        = 1;
    BitmapInfo.bmiHeader.biBitCount      = 8 * sizeof(_RGBALPHA);
    BitmapInfo.bmiHeader.biCompression   = BI_RGB;
    BitmapInfo.bmiHeader.biSizeImage     = 0;
    BitmapInfo.bmiHeader.biXPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biYPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biClrUsed       = 0;
    BitmapInfo.bmiHeader.biClrImportant  = 0;
    
    hBitmapMem = CreateDIBSection( hdcScreen, &BitmapInfo, DIB_RGB_COLORS, &pDIBits, NULL, 0 );
    if (pDIBits == NULL) 
    {
        ReleaseDC( NULL, hdcScreen );
        DeleteDC( hdcLayered );
        return E_FAIL;
    }
    
    ICONINFO iconInfo;
    if (m_fExpanded)
    {
        if (m_eWindowState == WINDOW_LARGE)
        {
            bRet = GetIconInfo(m_hIconInvokeLarge, &iconInfo);
        }
        else
        {
            bRet = GetIconInfo(m_hIconInvokeClose, &iconInfo);
        }
    }
    else
    {
        bRet = GetIconInfo(m_hIconInvoke, &iconInfo);
    }
    if (bRet)
    {
        BITMAP bm, bmMask;
        GetObject(iconInfo.hbmColor, sizeof(bm), &bm);
        GetObject(iconInfo.hbmMask, sizeof(bmMask), &bmMask);
        if (bm.bmPlanes==1 && bmMask.bmBitsPixel==1 && bmMask.bmPlanes==1) 
        {
            ASSERT(bm.bmWidth == size.cx);
            ASSERT(bm.bmHeight == size.cy);
            // Copy icon into layered window.
            GetDIBits(hdcScreen, iconInfo.hbmColor, 0, g_uExpandedWidgetHeight, pDIBits, &BitmapInfo, DIB_RGB_COLORS);
            
            UINT uiNumberBytesMask = bmMask.bmHeight * bmMask.bmWidthBytes;
            BYTE *bitmapBytesMask = new BYTE[uiNumberBytesMask];
            if (bitmapBytesMask == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(bitmapBytesMask, 0, uiNumberBytesMask);
                int cBytes = GetBitmapBits(iconInfo.hbmMask,uiNumberBytesMask,bitmapBytesMask);
                ASSERT(cBytes == uiNumberBytesMask);
                if (bRet)
                {
                    for (i = 0; i < size.cy; i++) 
                    {
                        ppxl = (RGBALPHA *)pDIBits + ((size.cy - i - 1) * size.cx);
                        for (j = 0; j < size.cx; j++)
                        {
                            if ( (bitmapBytesMask[i * bmMask.bmWidthBytes + j/8] >> (7 - (j % 8)))&1)
                            {
                                ppxl->rgbRed   = 0;
                                ppxl->rgbBlue  = 0;
                                ppxl->rgbGreen = 0;
                                ppxl->rgbAlpha = g_uAlphaInvisible;
                            }
                            else
                            {
                                ppxl->rgbAlpha = 255;
                            }
                            ppxl++;
                        }
                    }
                }
                delete [] bitmapBytesMask;
            }            
        }
        else
        {
            ASSERT("Correction icon is an invalid bitmap format." && FALSE);
        }
        bRet = DeleteObject (iconInfo.hbmColor); 
        iconInfo.hbmColor=NULL;
        ASSERT(bRet);
        bRet = DeleteObject (iconInfo.hbmMask); 
        iconInfo.hbmMask=NULL;
        ASSERT(bRet);
    }
    
    if (SUCCEEDED(hr))
    {
        ptSrc.x = 0;
        ptSrc.y = 0;
        ptDst.x = rcWindow.left;
        ptDst.y = rcWindow.top;
        Blend.BlendOp             = AC_SRC_OVER;
        Blend.BlendFlags          = 0;
        Blend.SourceConstantAlpha = uAlpha;
        Blend.AlphaFormat         = AC_SRC_ALPHA;
        
        hBitmapOld = (HBITMAP)SelectObject( hdcLayered, hBitmapMem );
        
        bRet = UpdateLayeredWindow(m_hWnd, hdcScreen, &ptDst, &size, hdcLayered, &ptSrc, 0, &Blend, ULW_ALPHA );
        if (!bRet)
        {
            DWORD dw = GetLastError();
        }
        
        SelectObject( hdcLayered, hBitmapOld );
    }
    
    // done
    
    ReleaseDC( NULL, hdcScreen );
    DeleteDC( hdcLayered );
    DeleteObject( hBitmapMem );
    
    return hr;
}

/****************************************************************************
* CCorrectionIMX::Activate *
*--------------------------*
*   Description:
*       Called when Cicero is initialized on a thread.
*       Allows us to initialize any Cicero related objects at this point.     
*
*   Returns: STDAPI 
*       S_OK - Everything successfully initialized.
*       Otherwise, appropriate error code.
*
*   Args: 
*     ITfThreadMgr *ptim
*       Pointer to the thread input manager object for the thread.
*     TfClientId tid
*       Text frameworks client ID for thread.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    HRESULT hr = S_OK;
    SPDBG_FUNC("CCorrectionIMX::Activate");

    ASSERT(m_cptim == NULL);

#if 0
    hr = m_cptim.CoCreateInstance(CLSID_TF_ThreadMgr);

    // Activate the thread manager
    if (S_OK == hr)
    {
        hr = m_cptim->Activate(&m_tid);
    }
#else
    m_cptim = ptim;
#endif

    m_ptimEventSink = new CThreadMgrEventSink(DIMCallback, ICCallback, this);
    if (m_ptimEventSink == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_ptimEventSink->_Advise(m_cptim);
    }

    CComPtr<ITfSource> cpSource;
    if (SUCCEEDED(hr))
    {
        hr = m_cptim->QueryInterface(IID_ITfSource, (void **)&cpSource);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpSource->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &m_dwThreadFocusCookie);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpSource->AdviseSink(IID_ITfKeyTraceEventSink, (ITfKeyTraceEventSink *)this, &m_dwKeyTraceCookie);
    }

    if (SUCCEEDED(hr))
    {
        m_ptimEventSink->_InitDIMs(TRUE);
    }
    CComPtr<ITfFunctionProvider> cpSysFuncPrv;
    if (SUCCEEDED(hr))
    {
        hr = m_cptim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, &cpSysFuncPrv);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpSysFuncPrv->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&m_cpSysReconv);
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::Deactivate *
*----------------------------*
*   Description:
*       Called when the Cicero thread manager is closing down on a thread.
*       Tip is required to deactivate and release all objects.
*       Guaranteed to be called if we were ever activated except if a 
*       catastrophic failure has already occurred.
*
*   Returns: STDAPI 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::Deactivate()
{
    SPDBG_FUNC("CCorrectionIMX::Deactivate");
    HRESULT hr = S_OK;

    if (m_ptimEventSink)
    {
        hr = m_ptimEventSink->_InitDIMs(FALSE);
        if (SUCCEEDED(hr))
        {
            hr = m_ptimEventSink->_Unadvise();
        }
        delete m_ptimEventSink;
        m_ptimEventSink = NULL;
    }
    CComPtr<ITfSource> cpSource;
    if (m_cptim && m_cptim->QueryInterface(IID_ITfSource, (void **)&cpSource) == S_OK)
    {
        cpSource->UnadviseSink(m_dwThreadFocusCookie);
        cpSource->UnadviseSink(m_dwKeyTraceCookie);
    }
    m_cpRangeReconv = NULL;
    m_cpRangeUser = NULL;
    m_cpRangeWord = NULL;
    m_cpSysReconv = NULL;

    // m_cptim->Deactivate();
    m_cptim.Release();

    if (m_hAtom)
    {
        UnregisterClass((LPCTSTR)m_hAtom, _Module.GetModuleInstance());
    }
    m_hAtom = NULL;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnSetThreadFocus *
*----------------------------------*
*   Description:
*       Called by Cicero when our thread gets focus.
*       We do nothing here.
*
*   Returns: STDAPI 
*
*   Args: 
*     void
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnSetThreadFocus(void)
{
    SPDBG_FUNC("CCorrectionIMX::OnSetThreadFocus");
    HRESULT hr = S_OK;

    // We do nothing here.

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnKillThreadFocus *
*-----------------------------------*
*   Description:
*       Called by Cicero when our thread gets focus.
*       We use this to intelligently hide the widget when the app loses focus.
*
*   Returns: STDAPI 
*
*   Args: 
*     void
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnKillThreadFocus(void)
{
    SPDBG_FUNC("CCorrectionIMX::OnKillThreadFocus");
    HRESULT hr = S_OK;

    // When we lose focus, we must hide the widget.
    hr = Show(WINDOW_HIDE);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnKeyTraceDown *
*--------------------------------*
*   Description:
*
*   Returns: STDAPI 
*
*   Args: 
*     WPARAM wParam
*     LPARAM lParam
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnKeyTraceDown(WPARAM wParam,LPARAM lParam)
{
    SPDBG_FUNC("CCorrectionIMX::OnKeyTraceDown");
    HRESULT hr = S_OK;

    m_fKeyDown = TRUE;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnKeyTraceUp *
*------------------------------*
*   Description:
*
*   Returns: STDAPI 
*
*   Args: 
*     WPARAM wParam
*     LPARAM lParam
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnKeyTraceUp(WPARAM wParam,LPARAM lParam)
{
    SPDBG_FUNC("CCorrectionIMX::OnKeyTraceUp");
    HRESULT hr = S_OK;

    m_fKeyDown = FALSE;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnLayoutChange *
*--------------------------------*
*   Description:
*       Called by Cicero when the document is resized and/or moved provided Cicero
*       application correctly handles this. This allows us to update the location
*       of the widget to match the new location of the associated selection.
*
*   Returns: STDAPI 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     ITfContext *pic
*       Pointer to the input context which was affected.
*     TfLayoutCode lcode
*       Flag - one of CREATE, CHANGE, DESTROY. We do not currently use this.
*     ITfContextView *pView
*       Pointer to the context view affected.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnLayoutChange(ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView)
{
    SPDBG_FUNC("CCorrectionIMX::OnLayoutChange");
    HRESULT hr = S_OK;
	BOOL fInWriteSession = FALSE;
	CEditSession *pes = NULL;

    if (m_cpRangeReconv == NULL)
    {
        return S_OK;
    }

	// ignore events made by client tip
	pic->InWriteSession( m_tid, &fInWriteSession );
	if (fInWriteSession) 
    {
		return S_OK;
	}

	// we only care about the active view
	if (!IsActiveView( pic, (ITfContextView *)pView )) 
    {
		return S_OK;
	}

	pes = new CEditSession( EditSessionCallback );
	// move candidate window
	if (pes) 
    {
		pes->_state.u      = ESCB_RESETTARGETPOS;
		pes->_state.pv     = this;
		pes->_state.wParam = 0;
		pes->_state.pRange = NULL;
		pes->_state.pic    = pic;

		pic->RequestEditSession( m_tid, pes, TF_ES_READ | TF_ES_SYNC, &hr );

		pes->Release();
	}
    else
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::IsCandidateObjectOpen *
*---------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*       Appropriate error code.
*
*   Args: 
*     BOOL *fOpen
*       TRUE if candidate object is open.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::IsCandidateObjectOpen(ITfContext *pic, BOOL *fOpen)
{
    SPDBG_FUNC("CCorrectionIMX::IsCandidateObjectOpen");

    HRESULT hr = S_OK;
    CComPtr<ITfCompartmentMgr> cpCompMgr;
    CComPtr<ITfCompartment>  cpComp;
    CComPtr<ITfContext> cpICTop;
    CComPtr<ITfDocumentMgr> cpDim;
    CComVariant cpVarCandOpen;

    // Default to candidate UI not open in case of failure.
    *fOpen = FALSE;

    cpVarCandOpen.lVal = 0;
    hr = pic->GetDocumentMgr(&cpDim);
    if (SUCCEEDED(hr) && cpDim)
    {
        // Could shortcut check here if cpICTop and pic are the same object (check IUnknowns).
        hr = cpDim->GetTop(&cpICTop);
    }
    if (SUCCEEDED(hr) && cpICTop)
    {
        hr = cpICTop->QueryInterface(&cpCompMgr);
    }
    if (SUCCEEDED(hr) && cpCompMgr)
    {
        hr = cpCompMgr->GetCompartment(GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXT, &cpComp);
    }
    if (SUCCEEDED(hr) && cpComp)
    {
        hr = cpComp->GetValue(&cpVarCandOpen);
        // If the Top IC has this set to one, then this IC was created by the candidate UI object and hence we
        // do *not* want to display the widget.
    }
    if (SUCCEEDED(hr))
    {
        *fOpen = (cpVarCandOpen.lVal == 1);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::OnEndEdit *
*---------------------------*
*   Description:
*       Called when something causes submission of an edit to the input context.
*
*   Returns: STDAPI 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     ITfContext *pic
*       Input context affected.
*     TfEditCookie ecReadOnly
*       Read only cookie for immediate use.
*     ITfEditRecord *pEditRecord
*       Pointer to object allowing the details of the edit to be investigated.
*       We use this solely to find out if the selection changed since we do not need
*       to take action based on anything else.
*
**************************************************************** agarside ***/

STDAPI CCorrectionIMX::OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    SPDBG_FUNC("CCorrectionIMX::OnEndEdit");
    HRESULT hr = S_OK;
    CComPtr<ITfRange> cpRangeUser;
    CComPtr<ITfRange> cpRangeWord;
    CComPtr<ITfRange> cpRangeReconv;
    CComPtr<ITfContextView> cpView;
    BOOL fHideWidget = TRUE;
    BOOL fSelectionChanged = FALSE;
    BOOL fCandOpen = FALSE;
    BOOL fHasFocus = TRUE; // If we fail focus check in any way, assume does have focus.

    m_fDisplayAlternatesMyself = FALSE;

    hr = pic->GetActiveView(&cpView);
    if (SUCCEEDED(hr))
    {
        HWND hWnd;
        hr = cpView->GetWnd(&hWnd);
        if (hWnd == GetFocus())
        {
            fHasFocus = TRUE;
        }
    }

    if (fHasFocus && !m_fCandidateOpen)
    {
        // Candidate list is open. We do not want to display correction widget.
        pEditRecord->GetSelectionStatus(&fSelectionChanged);
        // if (fSelectionChanged) // This is FALSE when IP first put into RichEdit stage! RE also claims IP is at end of previous utterance :-(.
        {
            // Get user selection.
            BOOL fEmpty = FALSE;
            hr = GetSelectionSimple(ecReadOnly, pic, &cpRangeUser);
            if (SUCCEEDED(hr))
            {
                // Check it isn't empty. If it is empty we want to hide the widget.
                hr = cpRangeUser->IsEmpty(ecReadOnly, &fEmpty);
            }
            if (SUCCEEDED(hr) && fEmpty && !m_fKeyDown)
            {
                BOOL fMatch = FALSE;
                if (m_cpRangeUser)
                {
                    cpRangeUser->IsEqualStart(ecReadOnly, m_cpRangeUser, TF_ANCHOR_START, &fMatch);
                    if (!fMatch)
                    {
                        // Check end point.
                        cpRangeUser->IsEqualStart(ecReadOnly, m_cpRangeUser, TF_ANCHOR_END, &fMatch);
                    }
                }
                if (!fMatch)
                {
                    // Find word range (using white space delimiters upto 20 characters either side).
                    FindWordRange(ecReadOnly, cpRangeUser, &cpRangeWord);
                }
            }
            if (!fEmpty)
            {
                cpRangeWord = cpRangeUser;
            }
            if (SUCCEEDED(hr) && cpRangeWord && (!fEmpty || !m_fKeyDown))
            {
                // Get reconversion range.
                BOOL fConvertable = FALSE;
                hr = m_cpSysReconv->QueryRange(cpRangeWord, &cpRangeReconv, &fConvertable);
                // Will validly fail if there is no alternates - e.g. partial words or typed text.
                hr = S_OK;

                BOOL fMatch = FALSE;
                if (SUCCEEDED(hr) && fConvertable)
                {
                    hr = DoesUserSelectionMatchReconversion(ecReadOnly, cpRangeWord, cpRangeReconv, &fMatch);
                    // May not be convertable or ranges may not match.
                }
                if (SUCCEEDED(hr) && fMatch)
                {
                    fHideWidget = FALSE;
                    // Convertable and ranges do match.
                }
                else
                {
                    if (fEmpty)
                    {
                        cpRangeReconv = NULL;
                        cpRangeReconv = cpRangeWord;
                        fHideWidget = FALSE;
                        m_fDisplayAlternatesMyself = TRUE;
                    }
                    else
                    {
                        // Find word range (using white space delimiters upto 20 characters either side).
                        CComPtr<ITfRange> cpRangeWordTmp;
                        CComPtr<ITfRange> cpRangeClone;
                        hr = cpRangeWord->Clone(&cpRangeClone);
                        if (SUCCEEDED(hr))
                        {
                            hr = cpRangeClone->Collapse(ecReadOnly, TF_ANCHOR_START);
                        }
                        if (SUCCEEDED(hr))
                        {
                            LONG pcch = 0;
                            hr = cpRangeClone->ShiftStart(ecReadOnly, 1, &pcch, NULL);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = FindWordRange(ecReadOnly, cpRangeClone, &cpRangeWordTmp);
                        }
                        if (cpRangeWordTmp)
                        {
                            fMatch = FALSE;
                            hr = DoesUserSelectionMatchReconversion(ecReadOnly, cpRangeWord, cpRangeWordTmp, &fMatch);
                        }
                        if (SUCCEEDED(hr) && cpRangeWordTmp && fMatch)
                        {
                            cpRangeReconv = NULL;
                            cpRangeReconv = cpRangeWord;
                            fHideWidget = FALSE;
                            m_fDisplayAlternatesMyself = TRUE;
                        }
                    }
                }
            }
        }
    }

    if (m_fCandidateOpen || !fHasFocus)
    {
        SPDBG_REPORT_ON_FAIL(hr);
        return hr;
    }

    if (fHideWidget)
    {
        m_cpRangeReconv = NULL;
        if (cpRangeUser)
        {
            m_cpRangeUser = NULL;
            m_cpRangeUser = cpRangeUser;
        }
        if (cpRangeWord)
        {
            m_cpRangeWord = NULL;
            m_cpRangeWord = cpRangeWord;
        }
        Show(WINDOW_HIDE);
    }
    else
    {
        m_cpRangeUser = NULL;
        m_cpRangeUser = cpRangeUser;
        m_cpRangeWord = NULL;
        m_cpRangeWord = cpRangeWord;
        m_cpRangeReconv = NULL;
        m_cpRangeReconv = cpRangeReconv;
        m_cpic = pic;

        // Update selection screen coordinates to match user selection (not reconversion range).
        hr = UpdateWidgetLocation(ecReadOnly);
        if (SUCCEEDED(hr))
        {
            Show(WINDOW_SMALLSHOW);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

// PRIVATE FUNCTIONS

/****************************************************************************
* CCorrectionIMX::CompareRange *
*------------------------------*
*   Description:
*       Compare two ranges and set a boolean value TRUE if they match.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ecReadOnly
*       Edit cookie.
*     ITfRange *pRange1
*       First range.
*     ITfRange *pRange2
*       Second range.
*     BOOL *fIdentical
*       Boolean return value. TRUE = ranges match.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::CompareRange(TfEditCookie ecReadOnly, ITfRange *pRange1, ITfRange *pRange2, BOOL *fIdentical)
{
    SPDBG_FUNC("CCorrectionIMX::CompareRange");
    HRESULT hr = S_OK;
    LONG lStartResult = -1, lEndResult = -1;
    *fIdentical = FALSE;

    hr = pRange1->CompareStart(ecReadOnly, pRange2, TF_ANCHOR_START, &lStartResult);
    if (SUCCEEDED(hr))
    {
        hr = pRange1->CompareEnd(ecReadOnly, pRange2, TF_ANCHOR_END, &lEndResult);
    }
    if (SUCCEEDED(hr) && lStartResult == 0 && lEndResult == 0)
    {
        *fIdentical = TRUE;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::FindWordRange *
*-------------------------------*
*   Description:
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ecReadOnly
*       Edit cookie.
*     ITfRange *pRangeIP
*		Range of the IP (zero length)
*     ITfRange *ppRangeWord
*		Returned range of the word found by simple word breaking algorithm.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::FindWordRange(TfEditCookie ecReadOnly, ITfRange *pRangeIP, ITfRange **ppRangeWord)
{
    SPDBG_FUNC("CCorectionIMX::FindWordRange");
    HRESULT hr = S_OK;
    CComPtr<ITfRangeACP> cpRangeIPACP;
    LONG cchStart = 0, cchEnd = 0, iStart = 0, iEnd = 0;
    ULONG cchTotal = 0;
    WCHAR wzText[41];

    *ppRangeWord = NULL;

    if (SUCCEEDED(hr))
    {
        hr = pRangeIP->QueryInterface(IID_ITfRangeACP, (void **)&cpRangeIPACP);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpRangeIPACP->ShiftStart(ecReadOnly, -20, &cchStart, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpRangeIPACP->ShiftEnd(ecReadOnly, 20, &cchEnd, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpRangeIPACP->GetText(ecReadOnly, 0, wzText, 40, &cchTotal);
    }
    wzText[cchTotal] = 0;

    if (SUCCEEDED(hr))
    {
        iStart = abs(cchStart);
        while (iStart >= 0)
        {
            iStart --;
            if (wzText[iStart] < 'A' ||
                wzText[iStart] > 'z' ||
                (wzText[iStart] > 'Z' && wzText[iStart] < 'a') )
            {
                break;
            }
        }
        iStart ++;
        if (iStart == abs(cchStart))
        {
            // Special case - do not show widget on IP when IP at start of the word.
            return S_OK;
        }

        iEnd = abs(cchStart);
        while (iEnd < (LONG)cchTotal)
        {
            if (wzText[iEnd] < 'A' ||
                wzText[iEnd] > 'z' ||
                (wzText[iEnd] > 'Z' && wzText[iEnd] < 'a') )
            {
                break;
            }
            iEnd ++;
        }
        if (iEnd == abs(cchStart))
        {
            return S_OK;
        }

        LONG cchTemp;
        if (iStart > 0)
        {
            hr = cpRangeIPACP->ShiftStart(ecReadOnly, iStart, &cchTemp, NULL);
        }
        if (SUCCEEDED(hr))
        {
            if (iEnd < (LONG)cchTotal)
            {
                hr = cpRangeIPACP->ShiftEnd(ecReadOnly, iEnd - cchTotal, &cchTemp, NULL);
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = pRangeIP->Clone(ppRangeWord);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::DoesUserSelectionMatchReconversion *
*----------------------------------------------------*
*   Description:
*       Compares the user selection to the reconversion range returned by the tip.
*       Need to match up exactly barring a small amount of white space at start and end.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ecReadOnly
*       Edit cookie.
*     ITfRange *pRangeUser
*       User selection range.
*     BOOL *fMatch
*       Boolean return value for whether they match or not.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::DoesUserSelectionMatchReconversion(TfEditCookie ecReadOnly, ITfRange *pRangeUser, ITfRange *pRangeReconv, BOOL *fMatch)
{
    SPDBG_FUNC("CCorrectionIMX::DoesUserSelectionMatchReconversion");
    HRESULT hr = S_OK;
    CComPtr<ITfRangeACP> cpRangeUserACP, cpReconvACP;
    CComPtr<ITfRange> cpRangeClone;

    *fMatch = FALSE;

    hr = pRangeUser->QueryInterface(IID_ITfRangeACP, (void **)&cpRangeUserACP);
    if (SUCCEEDED(hr))
    {
        hr = pRangeReconv->QueryInterface(IID_ITfRangeACP, (void **)&cpReconvACP);
    }

    if (cpRangeUserACP && cpReconvACP)
    {
        while (TRUE)
        {
            LONG iStartSelection, iStartReconv, iEndSelection, iEndReconv;
            ULONG startchars, endchars;
            LONG cch;
            WCHAR starttext[g_cSloppySelection+1], endtext[g_cSloppySelection+1];

            // Get start indexs and end offsets.
            cpRangeUserACP->GetExtent(&iStartSelection, &iEndSelection);
            cpReconvACP->GetExtent(&iStartReconv, &iEndReconv);
            // Convert end character positions to absolute values.
            iEndSelection += iStartSelection;
            iEndReconv += iStartReconv;

            if (abs(iStartSelection-iStartReconv) > g_cSloppySelection || 
                abs(iEndSelection-iEndReconv) > g_cSloppySelection)
            {
                // Two much of a mismatch between selection and reconversion range.
                // Do not display widget.
                break;
            }
            if (abs(iStartSelection-iStartReconv) == 0 &&
                abs(iEndSelection - iEndReconv) == 0)
            {
                // Shortcut check.
                *fMatch = TRUE;
                break;
            }

            if (iStartSelection<iStartReconv)
            {
                hr = cpRangeUserACP->GetText(ecReadOnly, 0, starttext, abs(iStartSelection-iStartReconv), &startchars);
            }
            else
            {
                hr = cpReconvACP->GetText(ecReadOnly, 0, starttext, abs(iStartSelection-iStartReconv), &startchars);
            }
            starttext[startchars] = 0;
            if (SUCCEEDED(hr))
            {
                if (iEndSelection<iEndReconv)
                {
                    hr = pRangeReconv->Clone(&cpRangeClone);
                    if (SUCCEEDED(hr))
                    {
                        hr = cpRangeClone->ShiftStart(ecReadOnly, iEndSelection-iStartReconv, &cch, NULL);
                    }
                }
                else
                {
                    hr = pRangeUser->Clone(&cpRangeClone);
                    if (SUCCEEDED(hr))
                    {
                        hr = cpRangeClone->ShiftStart(ecReadOnly, iEndReconv-iStartSelection, &cch, NULL);
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                hr = cpRangeClone->GetText(ecReadOnly, 0, endtext, abs(iEndSelection-iEndReconv), &endchars);
                endtext[endchars] = 0;

                UINT i;
                if (iStartSelection != iStartReconv)
                {
                    for (i = 0; i < (UINT)abs(iStartReconv-iStartSelection); i++)
                    {
                        if (starttext[i] != L' ')
                        {
                            break;
                        }
                    }
                    if (i != (UINT)abs(iStartReconv-iStartSelection))
                    {
                        break;
                    }
                }
                if (iEndSelection != iEndReconv)
                {
                    for (i = 0; i < (UINT)abs(iEndReconv-iEndSelection); i++)
                    {
                        if (endtext[i] != L' ' && endtext[i] != 13)
                        {
                            // 13 is found when selection hits end of richedit contents.
                            // Range is 1 longer than it should be and contains a carriage return.
                            break;
                        }
                    }
                    if (i != (UINT)abs(iEndReconv-iEndSelection))
                    {
                        break;
                    }
                }

                *fMatch = TRUE;
                break;
            }
            // We failed. We need to exit the loop now.
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::GetReconversion *
*---------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     TfEditCookie ec
*     ITfCandidateList** ppCandList
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::GetReconversion(TfEditCookie ec, ITfCandidateList** ppCandList)
{
    SPDBG_FUNC("CCorrectionIMX::GetReconversion");
    HRESULT hr = E_NOTIMPL;

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::Show *
*----------------------*
*   Description:
*       Shows / hides / and resizes / repositions correction widget window as
*       requested.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     WINDOWSTATE eWindowState
*       One of 5 enumerations stating requested action.
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::Show(WINDOWSTATE eWindowState)
{
    SPDBG_FUNC("CCorrectionIMX::Show");
    HRESULT hr = S_OK;

    m_eWindowState = eWindowState;

    // First update the expanded state flag.
    switch (m_eWindowState)
    {
        case WINDOW_HIDE:
        case WINDOW_SMALL:
        case WINDOW_SMALLSHOW:
        {
            m_fExpanded = FALSE;
            break;
        }
        case WINDOW_LARGE:
        case WINDOW_LARGECLOSE:
        {
            m_fExpanded = TRUE;
            break;
        }
        case WINDOW_REFRESH:
        {
            break;
        }
        default:
        {
            ASSERT("Reached default in CCorrectionIMX::Show" && FALSE);
        }
    }

    // Need to ensure we delete hRgn3 in all cases below where we do not pass it to SetWindowRgn.
    UINT uTop         = m_rcSelection.top + g_uWidgetYOffset; //( m_rcSelection.top + m_rcSelection.bottom - g_uWidgetHeight ) / 2;
    UINT uTopExpanded = m_rcSelection.top + g_uExpandedWidgetYOffset; //( m_rcSelection.top + m_rcSelection.bottom - g_uExpandedWidgetHeight ) / 2;
    if (SUCCEEDED(hr))
    {
        // Now show/hide the window as requested.
        switch (m_eWindowState)
        {
            case WINDOW_HIDE:
            {
                KillTimer(m_hWnd, ID_HIDETIMER);
                KillTimer(m_hWnd, ID_FADETIMER);
                ShowWindow(m_hWnd, SW_HIDE);
                break;
            }
            case WINDOW_SMALLSHOW:
            {
                if (!m_hWnd)
                {
                    LazyInitializeWindow();
                }
                KillTimer(m_hWnd, ID_FADETIMER);
                SetTimer(m_hWnd, ID_HIDETIMER, g_uTimerLength, NULL);
                // Should be same as WINDOW_SMALL
                SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uWidgetWidth, uTop, g_uWidgetWidth, g_uWidgetHeight, SWP_NOACTIVATE);
                // Now show the window in new location.
                ShowWindow(m_hWnd, SW_SHOWNA);
                DrawWidget(g_uAlpha);
                break;
            }
            case WINDOW_SMALL:
            {
                KillTimer(m_hWnd, ID_FADETIMER);
                SetTimer(m_hWnd, ID_HIDETIMER, g_uTimerLength, NULL);
                // Resize and reposition window.
                SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uWidgetWidth, uTop, g_uWidgetWidth, g_uWidgetHeight, SWP_NOACTIVATE);
                // Now we can switch to TRUE layered window drawing.
                DrawWidget(g_uAlpha);
                break;
            }
            case WINDOW_LARGE:
            case WINDOW_LARGECLOSE:
            {
                KillTimer(m_hWnd, ID_FADETIMER);
                KillTimer(m_hWnd, ID_HIDETIMER);
                // Resize and reposition window.
                SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uExpandedWidgetWidth, uTopExpanded, g_uExpandedWidgetWidth, g_uExpandedWidgetHeight, SWP_NOACTIVATE);
                DrawWidget(g_uAlphaLarge);
                break;
            }
            case WINDOW_REFRESH:
            {
                KillTimer(m_hWnd, ID_FADETIMER);
                // Do not kill hide timer here - the window has moved is all that is happening.
                if (m_fExpanded)
                {
                    SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uExpandedWidgetWidth, uTopExpanded, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
                }
                else
                {
                    SetWindowPos(m_hWnd, HWND_TOPMOST, m_rcSelection.left - g_uWidgetWidth, uTop, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
                }
                break;
            }
            default:
            {
                ASSERT("Reached default in CCorrectionIMX::Show" && FALSE);
                break;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::WndProc *
*-------------------------*
*   Description:
*       Windows message handling procedure for hidden window.
*
*   Returns: LRESULT CALLBACK 
*       Appropriate return values based on Windows message received.
*
*   Args: 
*     HWND hWnd
*       Handle to hidden window.
*     UINT uMsg
*       Message number.
*     WPARAM wParam
*       Message data.
*     LPARAM lParam
*       Message data.
*
**************************************************************** agarside ***/
/* static */

LRESULT CALLBACK CCorrectionIMX::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC("CCorrectionIMX::WndProc");
    static CCorrectionIMX *_this = NULL;

    switch (uMsg)
    {
        case WM_TIMER:
        {
            if (wParam == ID_HIDETIMER)
            {
                KillTimer(_this->m_hWnd, ID_HIDETIMER);
                _this->m_uAlpha = g_uAlpha;
                SetTimer(_this->m_hWnd, ID_FADETIMER, g_uTimerFade, NULL);
            }
            if (wParam == ID_FADETIMER)
            {
                _this->m_uAlpha -= g_uAlphaFade;
                if (_this->m_uAlpha <= 0)
                {
                    KillTimer(_this->m_hWnd, ID_FADETIMER);
                    _this->Show(WINDOW_HIDE);
                }
                else
                {
                    _this->DrawWidget((BYTE)_this->m_uAlpha);
                }
            }
            if (wParam == ID_MOUSELEAVETIMER)
            {
                POINT pt;
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                LPARAM lP = MAKELPARAM(pt.x, pt.y);
                PostMessage(hWnd, WM_MOUSEMOVE, 0, lP);
            }
            break;
        }
        case WM_SETCURSOR:
        {
            if (HIWORD(lParam) == WM_LBUTTONDOWN)
            {
                PostMessage(hWnd, WM_USERLBUTTONDOWN, 0, 0);
                return 1;
            }
            if (HIWORD(lParam) == WM_MOUSEMOVE)
            {
                POINT pt;
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                LPARAM lP = MAKELPARAM(pt.x, pt.y);
                PostMessage(hWnd, WM_MOUSEMOVE, 0, lP);
            }
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return 1;
        }
        case WM_NCCREATE:
        {
            _this = (CCorrectionIMX *)(((CREATESTRUCT *)lParam)->lpCreateParams);
            return 1;
        }
        case WM_MOUSEACTIVATE:
        {
            // We are interested in the mouse click but don't want to activate.
            return MA_NOACTIVATE;
        }
        case WM_MOUSEMOVE:
        {
            ::KillTimer(hWnd, ID_MOUSELEAVETIMER);
            int xPos = LOWORD(lParam); 
            int yPos = HIWORD(lParam); 
            if (!_this->m_fExpanded)
            {
                if (xPos > 0 && yPos > 0 && xPos < g_uWidgetWidth && yPos < g_uWidgetHeight)
                {
                    _this->Show(WINDOW_LARGE);
                    ::SetTimer(hWnd, ID_MOUSELEAVETIMER, g_uTimerSloppyMouseLeave, NULL);
                }
            }
            else
            {
                if (xPos < 0 || yPos < 0 || xPos >= g_uExpandedWidgetWidth || yPos >= g_uExpandedWidgetHeight)
                {
                    if (_this->m_eWindowState != WINDOW_LARGECLOSE)
                    {
                        _this->Show(WINDOW_SMALL);
                    }
                }
                else
                {
                    ::SetTimer(hWnd, ID_MOUSELEAVETIMER, g_uTimerSloppyMouseLeave, NULL);
                }
            }
            return 1;
        }
        case WM_USERLBUTTONDOWN:
        {
            HRESULT hr = S_OK;
            CEditSession *pes;

            // Is it within our window if we are the small widget?
            if (_this->m_fExpanded)
            {
                // Need to call this first, but it will reset the m_fExpanded flag.
                if (_this->m_eWindowState == WINDOW_LARGE)
                {
                    _this->Show(WINDOW_LARGECLOSE);

                    if (_this->m_cpRangeReconv)
                    {
                        if (!_this->m_fDisplayAlternatesMyself)
                        {
                            hr = _this->m_cpSysReconv->Reconvert(_this->m_cpRangeReconv);
                        }
                        else
                        {
                            pes = new CEditSession( EditSessionCallback );
                            if (pes) 
                            {
                                pes->_state.u      = ESCB_RECONVERTMYSELF;
                                pes->_state.pv     = _this;
                                pes->_state.wParam = 0;
                                pes->_state.pRange = _this->m_cpRangeReconv;
                                pes->_state.pic    = _this->GetIC();

                                pes->_state.pic->RequestEditSession( _this->GetId(), pes, TF_ES_ASYNC | TF_ES_READWRITE, &hr);

                                pes->Release();
                            }
                        }
                    }
                }
                else
                {
                    // Send escape character which by design, causes candidate UI to close :-).
                    INPUT escape[2];
                    escape[0].type = INPUT_KEYBOARD;
                    escape[0].ki.wVk = 0;
                    escape[0].ki.wScan = 27;
                    escape[0].ki.dwFlags = KEYEVENTF_UNICODE;
                    escape[1] = escape[0];
                    escape[1].ki.dwFlags = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;
                    SendInput(2, escape, sizeof(escape[0]));
                }
            }
            else
            {
                return DefWindowProc(hWnd, uMsg, wParam, lParam);
            }

            return 1;
        }
    }
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

/****************************************************************************
* CCorrectionIMX::UpdateWidgetLocation *
*--------------------------------------*
*   Description:
*       Queries Cicero for the location of the selected text in order to
*       position the widget appropriately. The selection is adjusted when the
*       last the right edge of the document and the selection ends just to the
*       left of the next word on the next line of the document. In this case,
*       we want to display the widget at the right side of the document on the
*       first line so we remove all trailing spaces to find this position.
*
*   Returns: HRESULT
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     void
*
**************************************************************** agarside ***/
HRESULT CCorrectionIMX::UpdateWidgetLocation(TfEditCookie ec)
{
    SPDBG_FUNC("CCorrectionIMX::UpdateWidgetLocation");
    HRESULT hr = S_OK;
    if (m_cpRangeWord)
    {
        CComPtr<ITfRange> cpCollapsedRange;
        hr = m_cpRangeWord->Clone(&cpCollapsedRange);
        if (SUCCEEDED(hr))
        {
            hr = cpCollapsedRange->Collapse(ec, TF_ANCHOR_START);
        }
        BOOL fClipped = FALSE;
        if (SUCCEEDED(hr))
        {
            hr = GetTextExtInActiveView(ec, cpCollapsedRange, &m_rcSelection, &fClipped);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
/****************************************************************************
* CCorrectionIMX::EditSessionCallback *
*-------------------------------------*
*   Description:
*       Called by Cicero when a request for an edit session has been granted.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     TfEditCookie ec
*       Appropriate edit cookie as requested.
*     CEditSession *pes
*       Object containing data and pointers supplied when edit session was requested.
*
**************************************************************** agarside ***/
/* static */

HRESULT CCorrectionIMX::EditSessionCallback(TfEditCookie ec, CEditSession *pes)
{
    SPDBG_FUNC("CCorrectionIMX::EditSessionCallback");
    HRESULT hr = S_OK;
    CCorrectionIMX *_this = (CCorrectionIMX *)pes->_state.pv;
    
    switch (pes->_state.u)
    {
        case ESCB_RESETTARGETPOS: 
        {
            if (_this->m_cpRangeWord)
            {
                // Find new location of selection (range)
                hr = _this->UpdateWidgetLocation(ec);
                if (SUCCEEDED(hr))
                {
                    // Reposition correction widget without resizing.
                    hr = _this->Show(WINDOW_REFRESH);
                }
            }
            break;
        }

        case ESCB_RECONVERTMYSELF:
        {
            CComPtr<ITfCandidateList> cpCandList;
            WCHAR wzText[MAX_PATH];
            WCHAR wzWord[MAX_PATH];
            WCHAR *wzTmp;
            ULONG cchTotal;
            LANGID langid = GetUserDefaultLangID(); // BUGBUG - How should we get this value?

            CCandidateList *pCandList = new CCandidateList(CCorrectionIMX::SetResult, pes->_state.pic, pes->_state.pRange, CCorrectionIMX::SetOptionResult);
            if (NULL == pCandList)
            {
                hr = E_OUTOFMEMORY;
            }
            if (SUCCEEDED(hr))
            {
                hr = SetSelectionSimple(ec, pes->_state.pic, pes->_state.pRange);
            }
            if (SUCCEEDED(hr))
            {
                cchTotal = 0;
                hr = pes->_state.pRange->GetText(ec, 0, wzText, ARRAYSIZE(wzText)-1, &cchTotal);
                wzText[cchTotal] = 0;

                // Space strip word without altering contents of wzText as we use this later on.
                wzTmp = wzText;
                while (*wzTmp == ' ')
                {
                    wzTmp++;
                    cchTotal--;
                }
                wcscpy(wzWord, wzTmp);

                while (cchTotal > 1 && wzWord[cchTotal-1] == ' ')
                {
                    cchTotal--;
                    wzWord[cchTotal] = 0;
                }
            }
            if (SUCCEEDED(hr))
            {
                if (cchTotal > 0)
                {
                    // Toggle case of first letter.
                    WCHAR wzTmp[2];
                    wzTmp[0] = wzText[0];
                    wzTmp[1] = 0;
                    _wcslwr(wzTmp);
                    if (wzTmp[0] == wzText[0])
                    {
                        _wcsupr(wzTmp);
                    }
                    
                    if (SUCCEEDED(hr) && wzText[0] != wzTmp[0])
                    {
                        wzText[0] = wzTmp[0];
                        hr = pCandList->AddString(wzText, langid, (void **)_this, NULL, NULL, 0);
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                HRESULT tmpHr = _this->IsWordInDictionary(wzWord);
                if ( tmpHr == S_FALSE )
                {
                    CComBSTR cpbstr;
                    cpbstr.Append(_this->m_wszAddPrefix);
                    cpbstr.Append(wzWord);
                    cpbstr.Append(_this->m_wszAddPostfix);
                    hr = pCandList->AddOption(cpbstr, langid, (void **)_this, NULL, NULL, 0, NULL, wzWord);
                }
            }
            if (SUCCEEDED(hr))
            {
                HICON hDeleteIcon = LoadIcon(GetSpgrmrInstance(), MAKEINTRESOURCE(IDI_SPTIP_DELETEICON));
                                             
                hr = pCandList->AddOption(_this->m_wszDelete, langid, (void **)_this, NULL, NULL, 2, hDeleteIcon, NULL);
            }
            if (SUCCEEDED(hr))
            {
                hr = pCandList->QueryInterface(IID_ITfCandidateList, (void **)&cpCandList);
            }
            if (SUCCEEDED(hr))
            {
                hr = _this->ShowCandidateList(ec, pes->_state.pic, pes->_state.pRange, cpCandList);
            }
            if (pCandList)
            {
                pCandList->Release();
            }
            break;
        }
        case ESCB_INJECTALTERNATETEXT:
        {
            CComPtr<ITfRange> cpInsertionPoint;

            hr = GetSelectionSimple(ec, pes->_state.pic, &cpInsertionPoint);
            cpInsertionPoint->SetText(ec, 0, (BSTR)pes->_state.wParam, -1);

            cpInsertionPoint->Collapse(ec, TF_ANCHOR_END);
            SetSelectionSimple(ec, pes->_state.pic, cpInsertionPoint);

            SysFreeString((BSTR)pes->_state.wParam);
            break;
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::IsWordInDictionary *
*------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     WCHAR *pwzWord
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::IsWordInDictionary(WCHAR *pwzWord)
{
    SPDBG_FUNC("CCorrectionIMX::IsWordInDictionary");
    HRESULT hr = S_OK;

	// here we should query the speech user dictionary.
    if (!m_cpLexicon)
    {
        hr = m_cpLexicon.CoCreateInstance(CLSID_SpLexicon);
    }
    if (SUCCEEDED(hr) && m_cpLexicon)
    {
        SPWORDPRONUNCIATIONLIST spwordpronlist; 
        memset(&spwordpronlist, 0, sizeof(spwordpronlist)); 

        // Find out status of word in lexicon.
        hr = m_cpLexicon->GetPronunciations(pwzWord, 0x409, eLEXTYPE_USER | eLEXTYPE_APP, &spwordpronlist);

        if (hr == SPERR_NOT_IN_LEX)
        {
            hr = S_FALSE;
        }
        else if (hr == SP_WORD_EXISTS_WITHOUT_PRONUNCIATION)
        {
			hr = S_OK;
		}

        //free all the buffers
        CoTaskMemFree(spwordpronlist.pvBuffer);
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::AddWordToDictionary *
*-------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     WCHAR *pwzWord
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::AddWordToDictionary(WCHAR *pwzWord)
{
    SPDBG_FUNC("CCorrectionIMX::AddWordToDictionary");
    HRESULT hr = S_OK;

	if (m_cpLexicon) 
    {
        // Add in unknown pronciation.
        hr = m_cpLexicon->AddPronunciation(pwzWord, 0x409, SPPS_Unknown, NULL);
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::RemoveWordFromDictionary *
*------------------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     WCHAR *pwzWord
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::RemoveWordFromDictionary(WCHAR *pwzWord)
{
    SPDBG_FUNC("CCorrectionIMX::RemoveWordFromDictionary");
    HRESULT hr = S_OK;

	if (m_cpLexicon) 
    {
        // Since the last paremeter is NULL here, all instances of the word are removed.
    	hr = m_cpLexicon->RemovePronunciation(pwzWord, 0x409, SPPS_Unknown, NULL);

        // IGNORE ERRORS DELIBERATELY HERE.
        ASSERT("Unexpected error trying to clear word in user lexicon." && (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX));
        hr = S_OK;
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::ShowCandidateList *
*-----------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     TfEditCookie ec
*     ITfContext *pic
*     ITfRange *pRange
*     ITfCandidateList *pCandList
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList)
{
    SPDBG_FUNC("CCorrectionIMX::ShowCandidateList");
    HRESULT hr = S_OK;
    CComPtr<ITfDocumentMgr> cpdim;

    // Create candidate object if necessary. Use previously created object if we have it.
    if (m_cpCandUIEx == NULL)
    {
        hr = m_cpCandUIEx.CoCreateInstance(CLSID_TFCandidateUI);
    }
    if (SUCCEEDED(hr))
    {
        hr = pic->GetDocumentMgr(&cpdim);
    }
    if (SUCCEEDED(hr))
    {
        m_cpCandUIEx->SetClientId(GetId());
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpCandUIEx->SetCandidateList(pCandList);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpCandUIEx->OpenCandidateUI(NULL, cpdim, ec, pRange);
    }

    return S_OK;
}

/****************************************************************************
* CCorrectionIMX::SetResult *
*---------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     ITfContext *pic
*     ITfRange *pRange
*     CCandidateString *pCand
*     TfCandidateResult imcr
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    SPDBG_FUNC("CCorrectionIMX::SetResult");
    BSTR bstr;
    CCorrectionIMX *_this = (CCorrectionIMX *)pCand->_pv;
    HRESULT hr = S_OK;
	CEditSession *pes = NULL;

    if (imcr == CAND_FINALIZED)
    {
        ULONG ulID = 0;

        pCand->GetID(&ulID);
        switch (ulID)
        {
            case 0: // Reverse capitalized choice.
            {
                pCand->GetString(&bstr);
                pes = new CEditSession( EditSessionCallback );
                if (pes) 
                {
                    pes->_state.u      = ESCB_INJECTALTERNATETEXT;
                    pes->_state.pv     = _this;
                    pes->_state.wParam = (WPARAM)bstr;
                    pes->_state.pRange = pRange;
                    pes->_state.pic    = pic;
                    pic->RequestEditSession( _this->GetId(), pes, TF_ES_ASYNC | TF_ES_READWRITE, &hr);
                    pes->Release();
                    hr = S_OK;
                    // Do not return errors from this function or Cicero will disable the tip.
                }
                // Do not call SysFreeString - called inside edit session.
                break;
            }
            // BUGBUG - Need to handle words starting with non-alphabetic characters better.
        }
    }

    // close candidate UI if it's still there
    if (imcr == CAND_FINALIZED || imcr == CAND_CANCELED)
    {
        if (_this->m_cpCandUIEx)
        {
            _this->m_cpCandUIEx->CloseCandidateUI();
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::SetOptionResult *
*---------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     ITfContext *pic
*     ITfRange *pRange
*     CCandidateString *pCand
*     TfCandidateResult imcr
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::SetOptionResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    SPDBG_FUNC("CCorrectionIMX::SetOptionResult");
    BSTR bstr;
    CCorrectionIMX *_this = (CCorrectionIMX *)pCand->_pv;
    HRESULT hr = S_OK;
	CEditSession *pes = NULL;

    if (imcr == CAND_FINALIZED)
    {
        ULONG ulID = 0;

        pCand->GetID(&ulID);
        switch (ulID)
        {
            case 0: // Add to dictinary...
            {
                if (SUCCEEDED(pCand->GetWord(&bstr)))
                {
                    _this->AddWordToDictionary(bstr);
                    SysFreeString(bstr);
                }
                break;
            }

#ifdef ENABLEDELETE
            case 1: // Delete from dictinary...
            {
                if (SUCCEEDED(pCand->GetWord(&bstr)))
                {
                    _this->RemoveWordFromDictionary(bstr);
                    SysFreeString(bstr);
                }
                break;
#endif

            case 2: // Delete
            {
                bstr = SysAllocString(L"");
                pes = new CEditSession( EditSessionCallback );
                if (pes) 
                {
                    pes->_state.u      = ESCB_INJECTALTERNATETEXT;
                    pes->_state.pv     = _this;
                    pes->_state.wParam = (WPARAM)bstr;
                    pes->_state.pRange = pRange;
                    pes->_state.pic    = pic;
                    pic->RequestEditSession( _this->GetId(), pes, TF_ES_ASYNC | TF_ES_READWRITE, &hr);
                    pes->Release();
                    hr = S_OK;
                }
                break;
            }
        }
    }

    // close candidate UI if it's still there
    if (imcr == CAND_FINALIZED || imcr == CAND_CANCELED)
    {
        if (_this->m_cpCandUIEx)
        {
            _this->m_cpCandUIEx->CloseCandidateUI();
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::ICCallback *
*----------------------------*
*   Description:
*       Called by Cicero when changes happen to the DIM with focus.
*       We need to listen to this so we can hide the widget on a focus change within an app. 
*       (e.g. two instances of Microsoft Word windows)
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     UINT uCode
*       Code specifying change to IC.
*     ITfDicumentMgr *pdim
*     ITfDicumentMgr *pdimPrevFocus
*     void *pv
*
**************************************************************** agarside ***/
/* static */

HRESULT CCorrectionIMX::DIMCallback(UINT uCode, ITfDocumentMgr *pdim, ITfDocumentMgr *pdimPrevFocus, void *pv)
{
    SPDBG_FUNC("CCorrectionIMX::DIMCallback");
    HRESULT hr = S_OK;
    CCorrectionIMX *_this = (CCorrectionIMX *)pv;
    CComPtr<ITfSource> cpSource;

    switch (uCode)
    {
        case TIM_CODE_SETFOCUS:
        {
            hr = _this->Show(WINDOW_HIDE);
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::ICCallback *
*----------------------------*
*   Description:
*       Called by Cicero when changes happen to an input context.
*       We need to listen to this so we can hook up to edit and layout changes.
*
*   Returns: HRESULT 
*       S_OK  - Everything succeeded.
*       Otherwise, appropriate error code.
*
*   Args: 
*     UINT uCode
*       Code specifying change to IC.
*     ITfContext *pic
*       Interface for the affected IC.
*     void *pv
*       Pointer for change - specific data.
*       We don't use this.
*
**************************************************************** agarside ***/
/* static */

HRESULT CCorrectionIMX::ICCallback(UINT uCode, ITfContext *pic, void *pv)
{
    SPDBG_FUNC("CCorrectionIMX::ICCallback");
    HRESULT hr = S_OK;
    CCorrectionIMX *_this = (CCorrectionIMX *)pv;
    CComPtr<ITfSource> cpSource;
    CICPriv *priv = NULL;

    switch (uCode)
    {
        case TIM_CODE_INITIC:
        {
            if ((priv = GetInputContextPriv(_this->GetId(), pic)) == NULL)
			{
               break;
			}
			_this->InitICPriv(_this->GetId(), priv, pic);

            _this->IsCandidateObjectOpen(pic, &_this->m_fCandidateOpen);
            if (_this->m_fCandidateOpen)
            {
                _this->Show(WINDOW_LARGECLOSE);
            }
            break;
        }

        case TIM_CODE_UNINITIC:
        {
            if ((priv = GetInputContextPriv(_this->GetId(), pic)) == NULL)
			{
                break;
			}
			_this->DeleteICPriv(priv, pic);

            BOOL fOpen;
            _this->IsCandidateObjectOpen(pic, &fOpen);
            if (fOpen)
            {
                _this->m_fCandidateOpen = FALSE;
                // If widget is in LARGECLOSE state, must close it here.
                _this->Show(WINDOW_HIDE);
            }
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCorrectionIMX::InitICPriv *
*----------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     TfClientId tid
*     CICPriv *priv
*     ITfContext *pic
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::InitICPriv(TfClientId tid, CICPriv *priv, ITfContext *pic)
{
    CComPtr<ITfSource> cpSource;
	HRESULT hr = S_OK;

    priv->_tid = tid;
    priv->_pic = pic; // not AddRef'd, this struct is contained in life of the pic

    hr = pic->QueryInterface(IID_ITfSource, (void **)&cpSource);
    if (cpSource)
    {
        hr = cpSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &priv->m_dwEditCookie);
        if (SUCCEEDED(hr))
        {
            hr = cpSource->AdviseSink(IID_ITfTextLayoutSink, (ITfTextLayoutSink *)this, &priv->m_dwLayoutCookie);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
	return hr;
}

/****************************************************************************
* CCorrectionIMX::DeleteICPriv *
*------------------------------*
*   Description:
*
*   Returns: HRESULT 
*
*   Args: 
*     CICPriv *picp
*     ITfContext *pic
*
**************************************************************** agarside ***/

HRESULT CCorrectionIMX::DeleteICPriv(CICPriv *picp, ITfContext *pic)
{
    CComPtr<ITfSource> cpSource;
	HRESULT hr = S_OK;

    if (!picp)
	{
        return E_FAIL;
	}

    hr = pic->QueryInterface(IID_ITfSource, (void **)&cpSource);
	if (SUCCEEDED(hr))
    {
        cpSource->UnadviseSink(picp->m_dwEditCookie);
        cpSource->UnadviseSink(picp->m_dwLayoutCookie);
    }

    // we MUST clear out the private data before cicero is free 
    // to release the ic
    ClearCompartment(GetId(), pic, GUID_IC_PRIVATE, FALSE);

    SPDBG_REPORT_ON_FAIL(hr);
	return hr;
}

//+---------------------------------------------------------------------------
//
// CreateInstance
//
// This is our internal object creator.  We only call this method
// when creating a wrapper for a specific tip, or when an app
// uses TF_CreateThreadMgr.  Never from CoCreateInstance.
//----------------------------------------------------------------------------

/* static */
HRESULT 
CCorrectionIMX::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return _CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
}

#endif // SUPPORT_INTERNAL_WIDGET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\correctionimx.h ===
//
// correctionimx.h
//

#pragma once

#include "timsink.h"
#include "mscandui.h"
#include "globals.h"


#define ESCB_RESETTARGETPOS         1
#define ESCB_RECONVERTMYSELF        3
#define ESCB_INJECTALTERNATETEXT    4

enum WINDOWSTATE
{
    WINDOW_HIDE      = 0,
        // Hides the correction widget window.
    WINDOW_SMALL     = 1,
        // Resizes the correction widget window to small.
    WINDOW_SMALLSHOW = 2,
        // Shows the correction widget window in its initial small state.
    WINDOW_LARGE     = 3,
        // Resizes the correction widget window to its large size.
    WINDOW_REFRESH   = 4,
        // Moves the correction widget to a new location but does not change its size.
    WINDOW_LARGECLOSE = 5
        // Resizes the correction widget window to its large size and displays close icon.
};

#ifdef SUPPORT_INTERNAL_WIDGET
class CCorrectionIMX : 
                 public ITfTextInputProcessor,
                 public ITfTextEditSink,
                 public ITfTextLayoutSink,
                 public ITfThreadFocusSink,
                 public ITfKeyTraceEventSink,
                 public CComObjectRoot,
                 public CComCoClass<CCorrectionIMX, &CLSID_CorrectionIMX>
{
public:
    CCorrectionIMX();
    ~CCorrectionIMX();

    STDMETHODIMP FinalConstruct(void);

    BEGIN_COM_MAP(CCorrectionIMX)
        COM_INTERFACE_ENTRY(ITfTextInputProcessor)
        COM_INTERFACE_ENTRY(ITfTextEditSink)
        COM_INTERFACE_ENTRY(ITfTextLayoutSink)
        COM_INTERFACE_ENTRY(ITfThreadFocusSink)
        COM_INTERFACE_ENTRY(ITfKeyTraceEventSink)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CCorrectionIMX)

    DECLARE_REGISTRY_RESOURCE(IDR_CORRECTIONIMX)

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    //
    // ITfTextInputProcessor
    //
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfTextLayoutSink
    STDMETHODIMP OnLayoutChange( ITfContext *pic, TfLayoutCode lcode, ITfContextView *pView );

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus(void);
    STDMETHODIMP OnKillThreadFocus(void);

    // ITfKeyTraceEventSink
    STDMETHODIMP OnKeyTraceDown(WPARAM wParam,LPARAM lParam);
    STDMETHODIMP OnKeyTraceUp(WPARAM wParam,LPARAM lParam);

    TfClientId GetId(void) { return m_tid; }
    ITfContext *GetIC(void) { return m_cpic; }

    CComPtr<ITfThreadMgr> m_cptim;

private:
    // Internal functions
	HRESULT InitICPriv(TfClientId tid, CICPriv *priv, ITfContext *pic);
	HRESULT DeleteICPriv(CICPriv *picp, ITfContext *pic);

    HRESULT GetReconversion(TfEditCookie ec, ITfCandidateList** ppCandList);
    static HRESULT SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);
    static HRESULT SetOptionResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);
    HRESULT ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList);

    HRESULT IsWordInDictionary(WCHAR *pwzWord);
    HRESULT AddWordToDictionary(WCHAR *pwzWord);
    HRESULT RemoveWordFromDictionary(WCHAR *pwzWord);

    HRESULT IsCandidateObjectOpen(ITfContext *pic, BOOL *fOpen);
    HRESULT CompareRange(TfEditCookie ecReadOnly, ITfRange *pRange1, ITfRange *pRange2, BOOL *fIdentical);
    HRESULT FindWordRange(TfEditCookie ecReadOnly, ITfRange *pRangeIP, ITfRange **pRangeWord);
    HRESULT DoesUserSelectionMatchReconversion(TfEditCookie ecReadOnly, ITfRange *pRangeUser, ITfRange *pRangeReconv, BOOL *fMatch);

    HRESULT UpdateWidgetLocation(TfEditCookie ec);
    HRESULT Show(WINDOWSTATE eWindowState);
    HRESULT DrawWidget(BYTE uAlpha);
    HRESULT LazyInitializeWindow(void);

    static HRESULT ICCallback(UINT uCode, ITfContext *pic, void *pv);
    static HRESULT DIMCallback(UINT uCode, ITfDocumentMgr *pdim, ITfDocumentMgr *pdimPrevFocus, void *pv);
    static HRESULT EditSessionCallback(TfEditCookie ec, CEditSession *pes);

    static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    CComPtr<ITfRange> m_cpRangeReconv;
    CComPtr<ITfRange> m_cpRangeUser;
    CComPtr<ITfRange> m_cpRangeWord;
    CComPtr<ITfCandidateUI> m_cpCandUIEx;
    CComPtr<ITfFnReconversion> m_cpSysReconv;

    CComPtr<ITfContext> m_cpic;
    TfClientId          m_tid;

    CThreadMgrEventSink *m_ptimEventSink;

    WCHAR m_wszDelete[MAX_PATH];
    WCHAR m_wszAddPrefix[MAX_PATH];
    WCHAR m_wszAddPostfix[MAX_PATH];

    DWORD m_dwLayoutCookie;
    DWORD m_dwEditCookie;
    DWORD m_dwThreadFocusCookie;
    DWORD m_dwKeyTraceCookie;
    BOOL m_fExpanded;
    RECT m_rcSelection;
    BOOL m_fDisplayAlternatesMyself;

    HWND m_hWnd;

    HICON m_hIconInvoke;
    HICON m_hIconInvokeLarge;
    HICON m_hIconInvokeClose;

    WINDOWSTATE m_eWindowState;
    UINT m_uAlpha;

    CComPtr<ISpLexicon> m_cpLexicon;

    BOOL m_fCandidateOpen;
    BOOL m_fKeyDown;

    ATOM m_hAtom;
};
#endif // SUPPORT_INTERNAL_WIDGET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "SPTIP"
#define SZ_MODULE       "SPTIP"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\cutil.h ===
// cutil.h
//
// file to put misc utility classes implementation
//
#ifndef CUTIL_H
#define CUTIL_H

#include "private.h"
#include "regimx.h"

class CDocStatus
{
public:
    CDocStatus(ITfContext *pic)
    {
        cpic = pic;
    }
    
    BOOL IsReadOnly()
    {
        TF_STATUS ts;
        HRESULT hr = cpic->GetStatus(&ts);
        if (S_OK == hr)
        {
            if (TF_SD_READONLY & ts.dwDynamicFlags)
                return TRUE;
        }
        return FALSE;
    }

private:
    CComPtr<ITfContext> cpic;
};

class __declspec(novtable)  CLangProfileUtil : public ITfFnLangProfileUtil
{
public:
    CLangProfileUtil() 
    {
         m_fProfileInit = FALSE; 
         m_langidDefault = 0xFFFF;
         m_uiUseSAPIForLangDetection = 0;
    }

    virtual ~CLangProfileUtil();

    // ITfFnLangProfileUtil method
    STDMETHODIMP RegisterActiveProfiles(void);
    STDMETHODIMP IsProfileAvailableForLang(LANGID langid, BOOL *pfAvailable);

    // ITfFunction method
    STDMETHODIMP GetDisplayName(BSTR *pbstrName);

    // private APIs
    HRESULT _EnsureProfiles(BOOL fRegister, BOOL *pfEnabled = NULL);
    HRESULT _RegisterAProfile(HINSTANCE hInst, REFCLSID rclsid, const REGTIPLANGPROFILE *plp);
    HRESULT _GetProfileLangID(LANGID *plangid);
    static const REGTIPLANGPROFILE *_GetSPTIPProfileForLang(LANGID langid);
    virtual BOOL    _DictationEnabled(LANGID *plangidRequested = NULL);
    BOOL    _IsDictationActiveForLang(LANGID langidReq);
    BOOL    _IsDictationEnabledForLang(LANGID langidReq, BOOL fUseDefault = FALSE);
    BOOL    _IsDictationEnabledForLangSAPI(LANGID langidReq, BOOL fUseDefault);
    LONG    _IsDictationEnabledForLangInReg(LANGID langidReq, BOOL fUseDefault, BOOL *pfEnabled);

    BOOL    _IsAnyProfileEnabled();
    BOOL    _fUseSAPIForLanguageDetection(void);
    BOOL    _fUserRemovedProfile(void);
    BOOL    _fUserInitializedProfile(void);
    BOOL    _SetUserInitializedProfile(void);

    void    _ResetDefaultLang() {m_langidDefault = 0xFFFF; }
    LANGID _GetLangIdFromRecognizerToken(HKEY hkeyToken);

    CComPtr<ITfInputProcessorProfiles>     m_cpProfileMgr;

    typedef struct {
        DWORD langid;
        DWORD dwStat;
        DWORD lidOverRidden;
    } LANGPROFILESTAT ;

    BOOL    m_fProfileInit;
    LANGID  m_langidDefault;
    UINT    m_uiUseSAPIForLangDetection;
    
    //
    // this is an array of installed recognizers in their langid
    //
    CStructArray<LANGID>             m_langidRecognizers;
};


typedef enum
{
    DA_COLOR_AWARE,
    DA_COLOR_UNAWARE
} ColorType;

class __declspec(novtable)  CColorUtil
{

public:


    CColorUtil() {m_cBitsPixelScreen = 0; m_fHighContrast =0;}
    COLORREF col( int r1, COLORREF col1, int r2, COLORREF col2 )
    {
        int sum = r1 + r2;

        Assert( sum == 10 || sum == 100 || sum == 1000 );
        int r = (r1 * GetRValue(col1) + r2 * GetRValue(col2) + sum/2) / sum;
        int g = (r1 * GetGValue(col1) + r2 * GetGValue(col2) + sum/2) / sum;
        int b = (r1 * GetBValue(col1) + r2 * GetBValue(col2) + sum/2) / sum;
        return RGB( r, g, b );

    }
    COLORREF GetNewLookColor(ColorType ct = DA_COLOR_AWARE)
    {
        InitColorInfo();

        COLORREF cr;
        if (m_cBitsPixelScreen < 8 || m_fHighContrast == TRUE)
        {
            cr = GetSysColor( COLOR_HIGHLIGHT );
        }
        else if (ct == DA_COLOR_AWARE)
        {
            cr = col( 50, GetSysColor( COLOR_HIGHLIGHT ), 
                      50, GetSysColor( COLOR_WINDOW ) );
        }
        else 
        {
            cr = col( 80, GetSysColor( COLOR_INFOBK ), 
                      20, GetSysColor(COLOR_3DSHADOW) );
        }
        return cr;
    }

    void InitColorInfo(void)
    {
        // do nothing if it's initialized already
        if (m_cBitsPixelScreen) return;

        HIGHCONTRAST hicntr = {0};
        HDC hDC = CreateDC("DISPLAY", NULL, NULL, NULL);
    
        // device caps
        m_cBitsPixelScreen = GetDeviceCaps( hDC, BITSPIXEL );
    
        // system paramater info
        hicntr.cbSize = sizeof(HIGHCONTRAST);
        SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hicntr, 0 );
    
        m_fHighContrast = ((hicntr.dwFlags & HCF_HIGHCONTRASTON) != 0);
    
    
        DeleteDC( hDC );
    }

    COLORREF GetTextColor()
    {
        return m_fHighContrast ? GetSysColor(COLOR_HIGHLIGHTTEXT) : GetSysColor(COLOR_WINDOWTEXT);
    }

private:
    int  m_cBitsPixelScreen;
    BOOL m_fHighContrast;
};

extern const GUID c_guidProfileBogus;

extern const GUID c_guidProfile0 ;
extern const GUID c_guidProfile1 ;
extern const GUID c_guidProfile2 ;

extern const REGTIPLANGPROFILE c_rgProfiles[];

#endif // CUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\cutil.cpp ===
// cutil.cpp
//
// file to put misc utility classes implementation
//
#include "private.h"
#include "sapilayr.h"
#include "sphelper.h"
#include "xstring.h"
#include "cregkey.h"
#include "ctflbui.h"
#include "nui.h"


const GUID c_guidProfileBogus = { /* 09ea4e4b-46ce-4469-b450-0de76a435bbb */
    0x09ea4e4b,
    0x46ce,
    0x4469,
    {0xb4, 0x50, 0x0d, 0xe7, 0x6a, 0x43, 0x5b, 0xbb}
  };


/* a5239e24-2bcf-4915-9c5c-fd50c0f69db2 */
const CLSID CLSID_MSLBUI = { 
    0xa5239e24,
    0x2bcf,
    0x4915,
    {0x9c, 0x5c, 0xfd, 0x50, 0xc0, 0xf6, 0x9d, 0xb2}
  };

// const GUID c_guidProfile0 = { /* 55122b58-15bb-11d4-bd48-00105a2799b5 */
//    0x55122b58,
//    0x15bb,
//    0x11d4,
//    {0xbd, 0x48, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
//  };
// const GUID c_guidProfile1 = { /* 55122b59-15bb-11d4-bd48-00105a2799b5 */
//    0x55122b59,
//    0x15bb,
//    0x11d4,
//    {0xbd, 0x48, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
//  };
// const GUID c_guidProfile2 = { /* 55122b5a-15bb-11d4-bd48-00105a2799b5 */
//    0x55122b5a,
//    0x15bb,
//    0x11d4,
//    {0xbd, 0x48, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
//  };

#ifndef USE_SAPI_FOR_LANGDETECTION
static const char c_szSpeechRecognizersKey[] = "Software\\Microsoft\\Speech\\Recognizers";
static const char c_szSpeechRecognizersTokensKey[] = "Software\\Microsoft\\Speech\\Recognizers\\Tokens";
static const char c_szDefault[] =    "DefaultTokenId";

static const char c_szAttribute[]  = "Attributes";
static const char c_szLanguage[]   = "Language";

static const char c_szUseSAPIForLang[] = "UseSAPIForLang";
#endif

static const char c_szProfileRemoved[] = "ProfileRemoved";
static const char c_szProfileInitialized[] = "ProfileInitialized";

_inline BOOL _IsCompatibleLangid(LANGID langidReq, LANGID langidCmp)
{
    if (PRIMARYLANGID(langidReq) == LANG_CHINESE)
    {
        return langidReq == langidCmp;
    }
    else
    {
        return PRIMARYLANGID(langidReq) == PRIMARYLANGID(langidCmp);
    }
}

void _RegisterOrUnRegisterMslbui(BOOL fRegister)
{
    // we just assume the dll is copied to system32
    TCHAR szMslbui[MAX_PATH];
    int cch = GetSystemDirectory(szMslbui, ARRAYSIZE(szMslbui));

    if (!cch)
    {
        return;
    }

    // GetSystemDirectory appends no '\' unless the system
    // directory is the root, such like "c:\"
    if (cch != 3)
    {
        StringCchCat(szMslbui, ARRAYSIZE(szMslbui), TEXT("\\"));
    }
    StringCchCat(szMslbui, ARRAYSIZE(szMslbui), TEXT("mslbui.dll"));

    if (fRegister)
    {
        // load mslbui.dll and register it 
        TF_RegisterLangBarAddIn(CLSID_MSLBUI, AtoW(szMslbui), TF_RLBAI_CURRENTUSER | TF_RLBAI_ENABLE);

    }
    else
    {
        TF_UnregisterLangBarAddIn(CLSID_MSLBUI, TF_RLBAI_CURRENTUSER);
    }
}

//+---------------------------------------------------------------------------
//
// dtor
//
//
//---------------------------------------------------------------------------+
CLangProfileUtil::~CLangProfileUtil()
{
    if (m_langidRecognizers.Count() > 0)
        m_langidRecognizers.Clear();
}

//+---------------------------------------------------------------------------
//
// _RegisterProfiles
//
// synopsis: a rough equivalent of RegisterTIP lib function, only different in
//           trying to cache the profile manager & the category manager
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::_RegisterAProfile(HINSTANCE hInst, REFCLSID rclsid, const REGTIPLANGPROFILE *plp)
{
    Assert(plp);

    HRESULT hr = S_OK;
    // ensure profile manager
    if (!m_cpProfileMgr)
    {
        hr = TF_CreateInputProcessorProfiles(&m_cpProfileMgr);
    }
    
    // register the clsid
    if (S_OK == hr)
    {
        hr = m_cpProfileMgr->Register(rclsid);
    }
    
    if (S_OK == hr)
    {
        WCHAR wszFilePath[MAX_PATH];
        WCHAR *pv = &wszFilePath[0];

        wszFilePath[0] = L'\0';

        if (wcslen(plp->szIconFile))
        {
            char szFilePath[MAX_PATH];
            WCHAR *pvCur;

            ::GetModuleFileName(hInst, szFilePath, ARRAYSIZE(szFilePath));
            StringCchCopyW(wszFilePath, ARRAYSIZE(wszFilePath), AtoW(szFilePath));

            pv = pvCur = &wszFilePath[0];
            while (*pvCur)
            { 
                if (*pvCur == L'\\')
                    pv = pvCur + 1;
                pvCur++;
            }
            *pv = L'\0';
        }
        StringCchCatW(wszFilePath, ARRAYSIZE(wszFilePath), plp->szIconFile);
        
        hr = m_cpProfileMgr->AddLanguageProfile(rclsid,  
                             plp->langid,  *plp->pguidProfile,  plp->szProfile, 
                             wcslen(plp->szProfile), wszFilePath, wcslen(wszFilePath),
                             plp->uIconIndex);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// RegisterActiveProfiles(void)
//
// synopsis
//
//
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::RegisterActiveProfiles(void)
{
    if (_fUserRemovedProfile())
    {
        // remove mslbui when not one speech profile is enabled
        if (!_IsAnyProfileEnabled())
            _RegisterOrUnRegisterMslbui(FALSE);

        return S_FALSE;
    }

    _SetUserInitializedProfile();

    BOOL fEnabled;
    HRESULT hr = _EnsureProfiles(TRUE, &fEnabled);

    // if the speech TIP profile is correctly registered,
    // then we're OK to register the persist UI (mslbui.dll)
    //
    if (S_OK == hr && fEnabled)
        _RegisterOrUnRegisterMslbui(TRUE);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// IsProfileAvailableForLang(LANGID langid, BOOL *pfAvailable)
//
// synopsis
//
//
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::IsProfileAvailableForLang(LANGID langid, BOOL *pfAvailable)
{
    if (pfAvailable)
    {
        *pfAvailable = _IsDictationEnabledForLang(langid);
        return S_OK;
    }
    else
        return E_INVALIDARG;
}

//+---------------------------------------------------------------------------
//
//  GetDisplayName(BSTR *pbstrName)
//
//  synopsis
//
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Register Active profiles for SPTIP");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

HRESULT CLangProfileUtil::_EnsureProfiles(BOOL fRegister, BOOL *pfEnabled)
{
    HRESULT hr = S_OK;
    
    if (pfEnabled)
        *pfEnabled = FALSE;

    if (fRegister)
    {
        m_langidRecognizers.Clear();
    }

    if (!m_cpProfileMgr || fRegister)
    {
        if (!m_cpProfileMgr)
        {
            hr = TF_CreateInputProcessorProfiles(&m_cpProfileMgr);
        }
        if (fRegister)
        {
            // if this is a first time initialization, 
            // obtain the list of all languages
            //
            if (S_OK == hr)
            {
                LANGID *pLangIds;
                ULONG  ulCount;
                // plangid will be assigned cotaskmemalloc'd memory
                //
                hr =  m_cpProfileMgr->GetLanguageList(&pLangIds, &ulCount);
                if (S_OK == hr)
                {
                    for (UINT i = 0; i < ulCount; i++)
                    {
                        // here we register profiles
                        // if SR engines are available
                        //
                        BOOL fEnable = FALSE;
                        if (_IsDictationEnabledForLang(pLangIds[i]))
                        {
                            fEnable = TRUE;

                            if (pfEnabled)
                                *pfEnabled = TRUE;
                        } 
                            
                        hr = m_cpProfileMgr->EnableLanguageProfile(
                                                          CLSID_SapiLayr,
                                                          pLangIds[i],
                                                          c_guidProfileBogus,
                                                          fEnable);
                    } // for
                    
                    CoTaskMemFree(pLangIds);
                }
            }
        } // fRegister
    }
    return hr;
}

BOOL CLangProfileUtil::_IsAnyProfileEnabled()
{
    HRESULT hr = S_OK;

    if (!m_cpProfileMgr)
    {
        hr = TF_CreateInputProcessorProfiles(&m_cpProfileMgr);
    }

    LANGID *pLangIds;
    ULONG  ulCount;
    BOOL fEnable = FALSE;

    if (S_OK == hr)
    {
        //
        // plangid will be assigned cotaskmemalloc'd memory
        //
        hr =  m_cpProfileMgr->GetLanguageList(&pLangIds, &ulCount);
    }

    if (S_OK == hr)
    {
        for (UINT i = 0; i < ulCount; i++)
        {
            hr = m_cpProfileMgr->IsEnabledLanguageProfile(CLSID_SapiLayr,
                                                          pLangIds[i],
                                                          c_guidProfileBogus,
                                                          &fEnable);

            if (S_OK == hr && fEnable)
                break;
        }

        CoTaskMemFree(pLangIds);
    }

    return fEnable;
}


//+---------------------------------------------------------------------------
//
//  _GetProfileLangID
//
// synopsis: handle language profiles
//
//---------------------------------------------------------------------------+
HRESULT CLangProfileUtil::_GetProfileLangID(LANGID *plangid)
{
    HRESULT hr = S_OK;
    
    Assert(plangid);

    hr = _EnsureProfiles(FALSE);

    if (hr == S_OK)
    {
        hr = m_cpProfileMgr->GetCurrentLanguage(plangid);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  _DictationEnabled
//
//  synopsis: 
//
//---------------------------------------------------------------------------+
BOOL CLangProfileUtil::_DictationEnabled(LANGID *plangidRequested)
{
    BOOL fret = FALSE;
    LANGID langidReq = (LANGID)-1;

    HRESULT hr = _GetProfileLangID(&langidReq);
    if (S_OK == hr)
    {
        if (plangidRequested)
            *plangidRequested = langidReq;

        fret = _IsDictationActiveForLang(langidReq);
    }

    return fret;
}

//
// _IsDictationActiveForLang
//
// synopsis: see if the default SR engine is capable for
//           the specified language
//
BOOL CLangProfileUtil::_IsDictationActiveForLang(LANGID langidReq)
{
    return _IsDictationEnabledForLang(langidReq, TRUE);
}

BOOL CLangProfileUtil::_IsDictationEnabledForLang(LANGID langidReq, BOOL fUseDefault)
{
    //
    // try reg first and if it's not compatible try SAPI
    // 
    BOOL fEnabled = FALSE;
    if (_fUseSAPIForLanguageDetection() == FALSE
       && ERROR_SUCCESS == 
        _IsDictationEnabledForLangInReg(langidReq, fUseDefault, &fEnabled))
    {
        return fEnabled;
    }
    return _IsDictationEnabledForLangSAPI(langidReq, fUseDefault);
}

BOOL CLangProfileUtil::_IsDictationEnabledForLangSAPI(LANGID langidReq, BOOL fUseDefault)
{
    BOOL   fEnabled = FALSE;

    WCHAR * pszDefaultTokenId = NULL;

    HRESULT   hr = S_OK;

    if (fUseDefault)
    {
        if (langidReq == m_langidDefault)
            return TRUE;

        SpGetDefaultTokenIdFromCategoryId(SPCAT_RECOGNIZERS, &pszDefaultTokenId);
    }
    CComPtr<IEnumSpObjectTokens> cpEnum;

    if (S_OK == hr)
    {
        char  szLang[MAX_PATH];
        WCHAR wsz[MAX_PATH];

        StringCchPrintfA(szLang, ARRAYSIZE(szLang), "Language=%x", langidReq);
        MultiByteToWideChar(CP_ACP, NULL, szLang, -1, wsz, ARRAYSIZE(wsz));
        hr = SpEnumTokens(SPCAT_RECOGNIZERS, wsz, NULL, &cpEnum);
    }

    while (!fEnabled && S_OK == hr)
    {
        CComPtr<ISpObjectToken> cpToken;
        WCHAR * pszTokenId = NULL;

        hr = cpEnum->Next(1, &cpToken, NULL);

        if (S_OK == hr)
        {
            hr = cpToken->GetId(&pszTokenId);
        }

        if (S_OK == hr)
        {
            Assert(!fUseDefault || pszDefaultTokenId);

            if (!fUseDefault || wcscmp(pszDefaultTokenId, pszTokenId) == 0)
                fEnabled = TRUE;
        }

        if (pszTokenId)
        {
            CoTaskMemFree(pszTokenId);
        }
    }

    if (pszDefaultTokenId)
    {
        CoTaskMemFree(pszDefaultTokenId);
    }

    if (fUseDefault && fEnabled)
    {
        m_langidDefault = langidReq;
    }

    return fEnabled;
}

const TCHAR c_szDefaultDefaultToken[] = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers\\Tokens\\MSASREnglish");

const TCHAR c_szDefaultDefaultTokenJpn[] = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers\\Tokens\\MSASRJapanese");

const TCHAR c_szDefaultDefaultTokenChs[] = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers\\Tokens\\MSASRChinese");


LONG CLangProfileUtil::_IsDictationEnabledForLangInReg(LANGID langidReq, BOOL fUseDefault, BOOL *pfEnabled)
{
    LONG lret = ERROR_SUCCESS;
    // 
    // fUseDefault == TRUE, just see if the current default recognizer
    // matches with the requested langid
    //
    if (fUseDefault)
    { 
        if( m_langidDefault == 0xFFFF)
        {
            char szRegkeyDefaultToken[MAX_PATH];
            CMyRegKey regkey;

            lret = regkey.Open(HKEY_CURRENT_USER, 
                               c_szSpeechRecognizersKey, 
                               KEY_READ);

            if (ERROR_SUCCESS == lret)
            {
                // first obtain the regkey to look at for default token
                lret = regkey.QueryValueCch(szRegkeyDefaultToken, c_szDefault, ARRAYSIZE(szRegkeyDefaultToken));
                regkey.Close();
            }
            else
            {
                if (PRIMARYLANGID(langidReq) == LANG_JAPANESE)
                {
                    StringCchCopy(szRegkeyDefaultToken, ARRAYSIZE(szRegkeyDefaultToken), c_szDefaultDefaultTokenJpn);
                }
                else if (langidReq == 0x804) // CHS
                {
                    StringCchCopy(szRegkeyDefaultToken, ARRAYSIZE(szRegkeyDefaultToken), c_szDefaultDefaultTokenChs);
                }
                else 
                {
                    StringCchCopy(szRegkeyDefaultToken, ARRAYSIZE(szRegkeyDefaultToken), c_szDefaultDefaultToken);
                }
                lret = ERROR_SUCCESS;
            }


            // then get the attribute / language
            if (ERROR_SUCCESS == lret)
            {
                char *psz = szRegkeyDefaultToken;

                //
                // eliminate "KKEY_LOCAL_MACHINE"
                //
                while(*psz && *psz != '\\')
                    psz++;

                if (*psz == '\\')
                {
                    psz++;
           
                    //
                    // open speech/recognizers/tokens key
                    //
                    lret = regkey.Open(HKEY_LOCAL_MACHINE, psz, KEY_READ);
                }
                else
                    m_langidDefault = 0x0000;
            }
        
            if (ERROR_SUCCESS == lret)
            {
                m_langidDefault = _GetLangIdFromRecognizerToken(regkey.m_hKey);
            }
        }
        *pfEnabled = _IsCompatibleLangid(langidReq, m_langidDefault);
        return lret;
    }

    //
    // this is fUseDefault == FALSE case. We want to see
    // if any installed recognizer can satisfy the langid requested.
    //
    if (m_langidRecognizers.Count() == 0)
    {
        CMyRegKey regkey;
        char      szRecognizerName[MAX_PATH];
        lret =  regkey.Open(HKEY_LOCAL_MACHINE, 
                                      c_szSpeechRecognizersTokensKey, 
                                      KEY_READ);

        if(ERROR_SUCCESS == lret)
        {
            CMyRegKey regkeyReco;
            DWORD dwIndex = 0;

            while (ERROR_SUCCESS == 
                   regkey.EnumKey(dwIndex, szRecognizerName, ARRAYSIZE(szRecognizerName)))
            {
                lret = regkeyReco.Open(regkey.m_hKey, szRecognizerName, KEY_READ);
                if (ERROR_SUCCESS == lret)
                { 
                    LANGID langid=_GetLangIdFromRecognizerToken(regkeyReco.m_hKey);
                    if (langid)
                    {
                        LANGID *pl = m_langidRecognizers.Append(1);
                        if (pl)
                            *pl = langid;
                    }
                    regkeyReco.Close();
                }
                dwIndex++;
            }
        }
    }

    BOOL fEnabled = FALSE;

    for (int i = 0 ; i < m_langidRecognizers.Count(); i++)
    {
        LANGID *p= m_langidRecognizers.GetPtr(i);

        if (p)
        {
            if (_IsCompatibleLangid(langidReq, *p))
            {
                fEnabled = TRUE;
                break;
            }
        }
    }
    *pfEnabled = fEnabled;

    return lret;
}

LANGID CLangProfileUtil::_GetLangIdFromRecognizerToken(HKEY hkeyToken)
{
    LANGID      langid = 0;
    char  szLang[MAX_PATH];
    CMyRegKey regkeyAttr;

    LONG lret = regkeyAttr.Open(hkeyToken, c_szAttribute, KEY_READ);
    if (ERROR_SUCCESS == lret)
    {
        lret = regkeyAttr.QueryValueCch(szLang, c_szLanguage, ARRAYSIZE(szLang));
    }
    if (ERROR_SUCCESS == lret)
    {   
        char *psz = szLang;
        while(*psz && *psz != ';')
        {
            langid = langid << 4;

            if (*psz >= 'a' && *psz <= 'f')
            {
                *psz -= ('a' - 'A');
            }

            if (*psz >= 'A' && *psz <= 'F')
            {
                langid += *psz - 'A' + 10;
            }
            else if (*psz >= '0' && *psz <= '9') 
            {
                langid += *psz - '0';
            }
            psz++;
        }
    }
    return langid;
}

BOOL  CLangProfileUtil::_fUseSAPIForLanguageDetection(void)
{
    if (m_uiUseSAPIForLangDetection == 0)
    {
        CMyRegKey regkey;
        if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ))
        {
            DWORD dw;
            if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szUseSAPIForLang))
            {
                m_uiUseSAPIForLangDetection = dw;
            }
        }

        if (m_uiUseSAPIForLangDetection == 0)
        {
            m_uiUseSAPIForLangDetection = 1;
        }
    }
    return m_uiUseSAPIForLangDetection == 2 ? TRUE : FALSE;
}


BOOL CLangProfileUtil::_fUserRemovedProfile(void)
{
    BOOL bret = FALSE;

    CMyRegKey regkey;

    if (ERROR_SUCCESS == regkey.Open(HKEY_CURRENT_USER, c_szSapilayrKey, KEY_READ))
    {
        DWORD dw;
        if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szProfileRemoved))
        {
            bret = dw > 0 ? TRUE : FALSE;
        }
    }
    return bret;
}

BOOL CLangProfileUtil::_fUserInitializedProfile(void)
{
    BOOL bret = FALSE;

    CMyRegKey regkey;

    if (ERROR_SUCCESS == regkey.Open(HKEY_CURRENT_USER, c_szSapilayrKey, KEY_READ))
    {
        DWORD dw;
        if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szProfileInitialized))
        {
            bret = dw > 0 ? TRUE : FALSE;
        }
    }
    return bret;
}

BOOL CLangProfileUtil::_SetUserInitializedProfile(void)
{
    CMyRegKey regkey;

    if (ERROR_SUCCESS == regkey.Create(HKEY_CURRENT_USER, c_szSapilayrKey))
    {
        DWORD dw = 0x0001;
        if (ERROR_SUCCESS==regkey.SetValue(dw, c_szProfileInitialized))
        {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\dictation.cpp ===
//
// Dictation.cpp
//
// This file contains functions related to dictation mode handling.
//
//
// They are moved from sapilayr.cpp


#include "private.h"
#include "globals.h"
#include "sapilayr.h"

const GUID *s_KnownModeBias[] =
{
    &GUID_MODEBIAS_NUMERIC
};


//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectText
//
// synopsis - recieve text from ISpTask and insert it to the current selection
//
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::InjectText(const WCHAR *pwszRecognized, LANGID langid, ITfContext *pic)
{
    if ( pwszRecognized == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszRecognized;
    esData.uByte = (wcslen(pwszRecognized)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;

    return _RequestEditSession(ESCB_PROCESSTEXT, TF_ES_READWRITE, &esData, pic);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectTextWithoutOwnerID
//
// synopsis - inject text to the clients doc same way InjectText does but 
//            with GUID_PROP_TEXTOWNER cleared out
//
//
//----------------------------------------------------------------------------
HRESULT 
CSapiIMX::InjectTextWithoutOwnerID(const WCHAR *pwszRecognized, LANGID langid)
{
    if ( pwszRecognized == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszRecognized;
    esData.uByte = (wcslen(pwszRecognized)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    
    return _RequestEditSession(ESCB_PROCESSTEXT_NO_OWNERID, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::HRESULT InjectSpelledText
//
// synopsis - inject spelled text to the clients doc 
//
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::InjectSpelledText(WCHAR *pwszText, LANGID langid, BOOL fOwnerId)
{
    if ( pwszText == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszText;
    esData.uByte = (wcslen(pwszText)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;
    esData.fBool = fOwnerId;
    
    return _RequestEditSession(ESCB_INJECT_SPELL_TEXT, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectModebiasText
//
// synopsis - recieve ModeBias text from ISpTask and insert it to the current 
// selection
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::InjectModebiasText(const WCHAR *pwszRecognized, LANGID langid)
{
    if ( pwszRecognized == NULL )
        return E_INVALIDARG;

    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)pwszRecognized;
    esData.uByte = (wcslen(pwszRecognized)+1) * sizeof(WCHAR);
    esData.lData1 = (LONG_PTR)langid;

    return _RequestEditSession(ESCB_PROCESS_MODEBIAS_TEXT, TF_ES_READWRITE, &esData);
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::_ProcessModebiasText
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessModebiasText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *picCaller)
{
    HRESULT hr = E_FAIL;

    ITfContext *pic = NULL;

    if (!picCaller)
    {
        GetFocusIC(&pic);
    }
    else
    {
        pic = picCaller;
    }

    hr = _ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, FALSE);

    if (picCaller == NULL)
    {
        SafeRelease(pic);
    }

    // Before we clear the saved ip range, we need to treat this current ip as last
    // saved ip range if current ip is selected by end user

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);

    return hr;
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::InjectFeedbackUI
//
// synopsis - insert dotted bar to a doc for the length of cch
//
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::InjectFeedbackUI(const GUID attr, LONG cch)
{
    ESDATA  esData;

    memset(&esData, 0, sizeof(ESDATA));
    esData.pData = (void *)&attr;
    esData.uByte = sizeof(GUID);
    esData.lData1 = (LONG_PTR)cch;
    
    return _RequestEditSession(ESCB_FEEDBACKUI, TF_ES_READWRITE, &esData);
}

//+---------------------------------------------------------------------------
//
// CSapiIMX::EraseFeedbackUI
//
// synopsis - cleans up the feedback UI
// GUID - specifies which feedback UI bar to erase
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::EraseFeedbackUI()
{
    if ( S_OK == IsActiveThread())
    {
        return _RequestEditSession(ESCB_KILLFEEDBACKUI, TF_ES_ASYNC|TF_ES_READWRITE, NULL);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::__AddFeedbackUI
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_AddFeedbackUI(TfEditCookie ec, ColorType ct, LONG cch)
{
    HRESULT hr = E_FAIL;
	ITfContext *pic;

    //
    // distinguish unaware applications from cicero aware apps
    //
    GUID attr = ((ct == DA_COLOR_AWARE) ? GUID_ATTR_SAPI_GREENBAR : GUID_ATTR_SAPI_GREENBAR2);
    
    if (cch > 0)
    {
        WCHAR *pwsz = (WCHAR *)cicMemAlloc((cch + 1)*sizeof(WCHAR));
        if (pwsz)
        {
            for (int i = 0; i < cch; i++ )
                pwsz[i] = L'.';
              
            pwsz[i] = L'\0';

            if (GetFocusIC(&pic))
            {
                // When add feedback UI, we should not change current doc's reco result property store
                // so set fPreserveResult as TRUE.
                // Only when the final text is injected to the document, the property store will be 
                // updated.

                hr =  _ProcessTextInternal(ec, pwsz, attr, GetUserDefaultLangID(), pic, TRUE);
                SafeRelease(pic);
			}
            cicMemFree(pwsz);
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::_ProcessText
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *picCaller)
{
    HRESULT hr = E_FAIL;

    ITfContext *pic = NULL;

    if (!picCaller)
	{
        GetFocusIC(&pic);
    }
    else
    {
        pic = picCaller;
    }

    hr = _ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, FALSE);

    if (picCaller == NULL)
    {
        SafeRelease(pic);
    }
	return hr;
}

//+--------------------------------------------------------------------------+
//
// CSapiIMX::_ProcessTextInternal
//
// common lower level routine for injecting text to docuement
//
//+--------------------------------------------------------------------------+
HRESULT CSapiIMX::_ProcessTextInternal(TfEditCookie ec, WCHAR *pwszText, GUID input_attr, LANGID langid, ITfContext *pic, BOOL fPreserveResult, BOOL fSpelling)
{
    HRESULT       hr = E_FAIL;

    if (pic)
    {
        BOOL       fPureCiceroIC;

        fPureCiceroIC = _IsPureCiceroIC(pic);

        CDocStatus ds(pic);
        if (ds.IsReadOnly())
           return S_OK;

        _fEditing = TRUE;

        // here we compare if the current selection is
        // equal to the saved IP range. If they are equal,
        // it means that the user has not moved the IP since
        // the first hypothesis arrived. In this case we'll
        // update the selection after injecting text, and
        // invalidate the saved IP.
        //
        BOOL         fIPIsSelection = FALSE; // by default
        CComPtr<ITfRange> cpInsertionPoint;

        if ( cpInsertionPoint = GetSavedIP( ) )
        {
            // this is trying to determine
            // if the saved IP was on this context.
            // if not we just ignore that

            CComPtr<ITfContext> cpic;
            hr = cpInsertionPoint->GetContext(&cpic);

            if (S_OK != hr || cpic != pic)
            {
                cpInsertionPoint.Release();
            }
        }

        if (cpInsertionPoint)
        {
            CComPtr<ITfRange> cpSelection;
            hr = GetSelectionSimple(ec, pic, &cpSelection);
            if (SUCCEEDED(hr))
            {
                hr = cpSelection->IsEqualStart(ec, cpInsertionPoint, TF_ANCHOR_START, &fIPIsSelection);
            }
        }
        else
        {
            // if there is no saved IP, selection is an IP
            fIPIsSelection = TRUE;
            hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);
        }
       
        if (hr == S_OK)
        {
            // finalize the previous input for now
            // if this is either feedback UI or alternate selection
            // no need to finalize
            // 
            // Only for AIMM app or CUAS app,
            // finalize the previous dictated phrase here.
            //
            // For full Cicero aware app, it is better to finalize the composition
            // after this dictated text is injected to the document.
            //
            if (!fPureCiceroIC && !fPreserveResult 
                && IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
            {
                _FinalizePrevComp(ec, pic, cpInsertionPoint);
            }
            
            ITfProperty  *pProp = NULL;
            
            // now inject text
            if (SUCCEEDED(hr))
            {
                // Just check with the app in case it wants to modify 
                // the range. 
                //

                BOOL fInsertOk;
                hr = cpInsertionPoint->AdjustForInsert(ec, wcslen(pwszText), &fInsertOk);
                if (S_OK == hr && fInsertOk)
                {
                    // start a composition here if we haven't already
                    _CheckStartComposition(ec, cpInsertionPoint);

                    // protect the reco property while we modify the text
                    // memo: we might want to preserve the original property instead
                    //       of the current property for LM lattice info We'll check 
                    //       back this later (RTM)
                    //
                    m_fAcceptRecoResultTextUpdates = fPreserveResult;

                    CRecoResultWrap *pRecoWrapOrg = NULL;
                    ITfRange        *pPropRange = NULL;
                    ITfProperty     *pProp_SAPIRESULT = NULL;

                    if (fPreserveResult == TRUE)
                    {
                        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &pProp_SAPIRESULT)))
                        {
                            // save out the result data
                            //
                            hr = _PreserveResult(ec, cpInsertionPoint, pProp_SAPIRESULT, &pRecoWrapOrg, &pPropRange);
                        }
                        if (S_OK != hr)
                            pRecoWrapOrg = NULL;
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        // set the text
 
                        hr = cpInsertionPoint->SetText(ec, 0, pwszText, -1);

                        // prwOrg holds a prop data if not NULL
                        if (S_OK == hr && fPreserveResult == TRUE && pPropRange)
                        {
                            hr = _RestoreResult(ec, pPropRange, pProp_SAPIRESULT, pRecoWrapOrg);
                        }
                    }

                    SafeReleaseClear(pPropRange);
                    SafeReleaseClear(pProp_SAPIRESULT);
                    SafeRelease(pRecoWrapOrg);  

                    m_fAcceptRecoResultTextUpdates = FALSE;


                }
            }
            
            //
            // set attribute range, use custom prop to mark speech text
            //
            if (SUCCEEDED(hr))
            {
                if (IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
                {
                    hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &pProp);
                }
                else
                {
                    hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);
                 }
            }

            ITfRange *pAttrRange = NULL;
            if (S_OK == hr)
            {
                // when we insert feedback UI text, we expect the prop
                // range (attribute range) to be extended.
                // if we are attaching our custom GUID_PROP_SAPI_DISPATTR
                // property, we'll attach it phrase by phrase
                //
                if (!IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
                {
                    hr = _FindPropRange(ec, pProp, cpInsertionPoint, 
                                   &pAttrRange, input_attr, TRUE);
                }
                //
                // findproprange can return S_FALSE when there's no property yet
                //
                if (SUCCEEDED(hr) && !pAttrRange)
                {
                    hr = cpInsertionPoint->Clone(&pAttrRange);
                }
            }

            if (S_OK == hr && pAttrRange)
            {
                SetGUIDPropertyData(&_libTLS, ec, pProp, pAttrRange, input_attr);
            }

            //
            // one more prop stuff for text owner id to fix
            // problem with Japanese spelling
            //
            if (S_OK == hr && fSpelling && !_MasterLMEnabled())
            {
                CComPtr<ITfProperty> cpPropTextOwner;

                hr = pic->GetProperty(GUID_PROP_TEXTOWNER, &cpPropTextOwner);
                if (S_OK == hr)
                {
                    SetGUIDPropertyData(&_libTLS, ec, cpPropTextOwner, pAttrRange, GUID_NULL);
                }
            }

            SafeRelease(pAttrRange);
            SafeRelease(pProp);

            //
            // setup langid property
            //
            _SetLangID(ec, pic, cpInsertionPoint, langid);

            // move the caret
            if (fIPIsSelection)
            {
                cpInsertionPoint->Collapse(ec, TF_ANCHOR_END);
                SetSelectionSimple(ec, pic, cpInsertionPoint);
            }

            // Finalize the composition object here for Cicero aware app.
            if ((hr == S_OK) && fPureCiceroIC  
                && IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT))
            {
                _KillFocusRange(ec, pic, NULL, _tid);
            }
        }
       
        // If candidate UI is open, we need to close it now.
        CloseCandUI( );
            
        _fEditing = FALSE;

    }

    // Finally, notify stage process if we are the stage speech tip instance.
    if (m_fStageTip && IsEqualGUID(input_attr, GUID_ATTR_SAPI_INPUT) && fPreserveResult == FALSE)
    {
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_STAGEDICTATION, 1, FALSE);
    }


    return hr;
}

//  
// _ProcessSpelledText
// 
// Call back function for edit session ESCB_INJECT_SPELL_TEXT
//
//
HRESULT CSapiIMX::_ProcessSpelledText(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid, BOOL fOwnerId)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpTextRange;
    CComPtr<ITfRange>   cpCurIP;

    if ( !pic || !pwszText )
        return E_INVALIDARG;
    
    // Keep the current range.
    cpCurIP = GetSavedIP( );

    if ( !cpCurIP )
        GetSelectionSimple(ec, pic, &cpCurIP);

    // We want to clone current ip so that it would not be changed 
    // after _ProcessTextInternal( ) is called.
    //
    if ( cpCurIP )
        cpCurIP->Clone(&cpTextRange);

    if ( !cpTextRange ) return E_FAIL;

    // check if the current selection or empty ip is inside a middle of English word. for English only.
    BOOL      fStartAnchorInMidWord = FALSE;   // Check if the start anchor of pTextRange is in a middle of word
    BOOL      fEndAnchorInMidWord  =  FALSE;   // Check if the end anchor of pTextRange is in a middle of word.

    // When fStartAnchorInMidWord is TRUE, we don't add extra space between this text range and the previous range.
    // When fEndAnchoInMidWord is TRUE, we remove the trailing space in this text range.

    if ( langid == 0x0409 )
    {
        WCHAR               szSurrounding[3]=L"  ";
        LONG                cch;
        CComPtr<ITfRange>   cpClonedRange;

        hr = cpTextRange->Clone(&cpClonedRange);

        if ( hr == S_OK )
            hr = cpClonedRange->Collapse(ec, TF_ANCHOR_START);

        if ( hr == S_OK )
            hr = cpClonedRange->ShiftStart(ec, -1, &cch, NULL);

        if (hr == S_OK && cch != 0)
            hr = cpClonedRange->ShiftEnd(ec, 1, &cch, NULL);

        if ( hr == S_OK && cch != 0 )
            hr = cpClonedRange->GetText(ec, 0, szSurrounding, 2, (ULONG *)&cch);

        if ( hr == S_OK && cch > 0 )
        {
            if ( iswalnum(szSurrounding[0]) && iswalnum(szSurrounding[1]))
                fStartAnchorInMidWord = TRUE;
        }

        szSurrounding[0] = szSurrounding[1]=L' ';
        cpClonedRange.Release( );

        hr = cpTextRange->Clone(&cpClonedRange);

        if ( hr == S_OK )
            hr = cpClonedRange->Collapse(ec, TF_ANCHOR_END);

        if ( hr == S_OK )
            hr = cpClonedRange->ShiftStart(ec, -1, &cch, NULL);

        if (hr == S_OK && cch != 0)
            hr = cpClonedRange->ShiftEnd(ec, 1, &cch, NULL);

        if ( hr == S_OK && cch != 0 )
            hr = cpClonedRange->GetText(ec, 0, szSurrounding, 2, (ULONG *)&cch);

        if ( hr == S_OK && cch == 2 )
        {
            if ( iswalnum(szSurrounding[0]) && iswalnum(szSurrounding[1]) )
                fEndAnchorInMidWord = TRUE;
        }
    }

    // Inject text with or without owner id according to fOwnerId parameter
    // this is a final text injection, we don't want to preserve the speech property data
    // possible divided or shrinked by this text injection.
    //
    hr = _ProcessTextInternal(ec, pwszText, GUID_ATTR_SAPI_INPUT, langid, pic, FALSE, !fOwnerId);

    if ( hr == S_OK  && !fOwnerId)
    {
        BOOL  fConsumeLeadSpaces = FALSE;
        ULONG ulNumTrailSpace = 0;

        if ( iswcntrl(pwszText[0]) || iswpunct(pwszText[0]) )
            fConsumeLeadSpaces = TRUE;

        for ( LONG i=wcslen(pwszText)-1; i > 0; i-- )
        {
            if ( pwszText[i] == L' ' )
                ulNumTrailSpace++;
            else
                break;
        }

        hr = _ProcessSpaces(ec, pic, cpTextRange, fConsumeLeadSpaces, ulNumTrailSpace, langid, fStartAnchorInMidWord, fEndAnchorInMidWord);
    }

    return hr;
}

//
// Handle the spaces after the recogized text is injected to the document.
//
// The handling includes below cases:
//
//    Consume the leading spaces.
//    Remove the possible spaces after the injected text.  English Only
//    Add a space before the injected text if necessary.  English Only.
//
HRESULT CSapiIMX::HandleSpaces(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements, ITfRange *pTextRange, LANGID langid)
{
    HRESULT hr = E_FAIL;

    if (pResult && pTextRange)
    {
        BOOL        fConsumeLeadSpaces = FALSE;
        ULONG       ulNumTrailSpace = 0;
        SPPHRASE    *pPhrase = NULL;

        // Check if the first element of the pResult wants to consume the leading spaces 
        // (the trailing spaces in the last phrase) in the documenet.
        //
        // If the disp attrib bit is set as SPAF_CONSUME_LEADING_SPACES, means it wants to consume
        // all the leading spaces in the document.
        //

        hr = S_OK;

        if ( _NeedRemovingSpaceForPunctation( ) )
        {
            hr = pResult->GetPhrase(&pPhrase);

            if ( hr == S_OK )
            {
                ULONG cElements = 0;
                BYTE  bDispAttr;

                cElements = pPhrase->Rule.ulCountOfElements;

                if ( cElements >= (ulStartElement + ulNumElements) )
                {
                    bDispAttr = pPhrase->pElements[ulStartElement].bDisplayAttributes;

                    if ( bDispAttr & SPAF_CONSUME_LEADING_SPACES )
                        fConsumeLeadSpaces = TRUE;

                    bDispAttr = pPhrase->pElements[ulStartElement + ulNumElements - 1].bDisplayAttributes;
                    if ( bDispAttr & SPAF_ONE_TRAILING_SPACE )
                        ulNumTrailSpace = 1;
                    else if ( bDispAttr & SPAF_TWO_TRAILING_SPACES )
                        ulNumTrailSpace = 2;
                }
            }

            if (pPhrase)
                CoTaskMemFree(pPhrase);
        }

        if ( hr == S_OK )
        {
            ESDATA  esData;

            memset(&esData, 0, sizeof(ESDATA));
            esData.lData1 = (LONG_PTR)langid;
            esData.lData2 = (LONG_PTR)ulNumTrailSpace;
            esData.fBool  = fConsumeLeadSpaces;
            esData.pRange = pTextRange;

            hr = _RequestEditSession(ESCB_HANDLESPACES, TF_ES_READWRITE, &esData);
        }
    }

    return hr;
}

//
// CSapiIMX::AttachResult
//
// attaches the result object and keep it *alive*
// until the property is discarded
//
HRESULT CSapiIMX::AttachResult(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements)
{
    HRESULT hr = E_FAIL;

    if (pResult)
    {
        ESDATA  esData;
        
        memset(&esData, 0, sizeof(ESDATA));

        esData.lData1 = (LONG_PTR)ulStartElement;
        esData.lData2 = (LONG_PTR)ulNumElements;
        esData.pUnk = (IUnknown *)pResult;

        hr = _RequestEditSession(ESCB_ATTACHRECORESULTOBJ, TF_ES_READWRITE, &esData);
    }

    return hr;
}



//
//  CSapiIMX::_GetSpaceRangeBeyondText
//
//  Get space range beyond the injected text in the document.
//  fBefore is TRUE, Get the space range to contain spaces between 
//                   the previous word and start anchor of the TextRange.
//  fBefore is FALSE,Get space range to contains spaces  between 
//                   the end anchor of the TextRange and next word.
//
//  pulNum  receives the real space number.
//  pfRealTextBeyond indicates if there is real text before or after the text range.
//
//  Caller is responsible to release *ppSpaceRange.
//
HRESULT CSapiIMX::_GetSpaceRangeBeyondText(TfEditCookie ec, ITfRange *pTextRange, BOOL fBefore, ITfRange  **ppSpaceRange, BOOL *pfRealTextBeyond)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpSpaceRange;
    LONG                cch;

    if ( !pTextRange || !ppSpaceRange )
        return E_INVALIDARG;

    *ppSpaceRange = NULL;

    if ( pfRealTextBeyond )
        *pfRealTextBeyond = FALSE;

    hr = pTextRange->Clone(&cpSpaceRange);

    if ( hr == S_OK )
    {
        hr = cpSpaceRange->Collapse(ec, fBefore ? TF_ANCHOR_START  :  TF_ANCHOR_END);
    }

    if ( hr == S_OK )
    {
        if ( fBefore )
            hr = cpSpaceRange->ShiftStart(ec, MAX_CHARS_FOR_BEYONDSPACE * (-1), &cch, NULL);
        else
            hr = cpSpaceRange->ShiftEnd(ec, MAX_CHARS_FOR_BEYONDSPACE, &cch, NULL);
    }

    if ( (hr == S_OK)  && (cch != 0 ) )
    {
        // There are more characters beyond the text range.
        // Determine the real number of spaces in the guessed range.
        //
        // if fBefore TRUE, search the number from end to start anchor.
        // if fBefore FASLE, search the number from start to end anchor.

        WCHAR *pwsz = NULL;
        LONG   lSize = cch;
        LONG   lNumSpaces = 0;
            
        if (cch < 0)
            lSize = cch * (-1);

        pwsz = new WCHAR[lSize + 1];
        if ( pwsz )
        {
            hr = cpSpaceRange->GetText(ec, 0, pwsz, lSize, (ULONG *)&cch);
            if ( hr == S_OK)
            {
                pwsz[cch] = L'\0';

                // calculate the number of trailing or prefix spaces in this range.
                BOOL    bSearchDone = FALSE;
                ULONG   iStart;

                if ( fBefore )
                    iStart = cch - 1;  // Start from the end anchor to Start Anchor.
                else
                    iStart = 0;        // Start from Start Anchor to End Anchor.

                while ( !bSearchDone )
                {
                    if ((pwsz[iStart] != L' ') && (pwsz[iStart] != L'\t'))
                    {
                        bSearchDone = TRUE;

                        if ( pwsz[iStart] > 0x20 && pfRealTextBeyond)
                            *pfRealTextBeyond = TRUE;

                        break;
                    }
                    else
                        lNumSpaces ++;

                    if ( fBefore )
                    {
                        if ( (long)iStart <= 0 )
                            bSearchDone = TRUE;
                        else
                            iStart --;
                    }
                    else
                    {
                        if ( iStart >= (ULONG)cch - 1 )
                            bSearchDone = TRUE;
                        else
                            iStart ++;
                    }
                }
            }

            delete[] pwsz;

            if ( (hr == S_OK) && (lNumSpaces > 0))
            {
                // Shift the range to cover only spaces.
                LONG   NonSpaceNum;
                NonSpaceNum = cch - lNumSpaces;

                if ( fBefore )
                    hr = cpSpaceRange->ShiftStart(ec, NonSpaceNum, &cch, NULL);
                else
                    hr = cpSpaceRange->ShiftEnd(ec, NonSpaceNum * (-1), &cch, NULL);

                // Return this cpSpaceRange to the caller.
                // Caller is responsible for releasing this object.

                if ( hr == S_OK )
                    hr = cpSpaceRange->Clone(ppSpaceRange);
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
// CSapiIMX::_ProcessTrailingSpace
//
// If the next phrase wants to consume leading space,
// we want to remove all the trailing spaces in this text range and the spaces
// between this range and next text range.
// This is for all languages.
//
HRESULT CSapiIMX::_ProcessTrailingSpace(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, ULONG ulNumTrailSpace)
{
    HRESULT                 hr = S_OK;
    CComPtr<ITfRange>       cpNextRange;
    CComPtr<ITfRange>       cpSpaceRange;    // Space Range between this range and next text range.
    BOOL                    fHasNextText = FALSE;
    CComPtr<ITfRange>       cpTrailSpaceRange;
    LONG                    cch;

    if ( !pTextRange )
        return E_INVALIDARG;

    hr = pTextRange->Clone(&cpTrailSpaceRange);

    if (hr == S_OK)
        hr = cpTrailSpaceRange->Collapse(ec, TF_ANCHOR_END);

    // Generate the real Trailing Space Range
    if (hr == S_OK && ulNumTrailSpace > 0)
        hr = cpTrailSpaceRange->ShiftStart(ec, (LONG)ulNumTrailSpace * (-1), &cch, NULL);

    // Get the spaces between this range and possible next text range.
    if ( hr == S_OK )
        hr = _GetSpaceRangeBeyondText(ec, pTextRange, FALSE, &cpSpaceRange);

    // if we found the space range, the trailing space range should also include this range.
    if ( hr == S_OK && cpSpaceRange )
        hr = cpTrailSpaceRange->ShiftEndToRange(ec, cpSpaceRange, TF_ANCHOR_END);

    // Determine if there is Next Text range after this cpTrailSpaceRange.
    if (hr == S_OK)
    {
        hr = cpTrailSpaceRange->Clone(&cpNextRange);

        if ( hr == S_OK )
            hr = cpNextRange->Collapse(ec, TF_ANCHOR_END);

        cch = 0;
        if ( hr == S_OK )
            hr = cpNextRange->ShiftEnd(ec, 1, &cch, NULL);

        if ( hr == S_OK && cch != 0 )
            fHasNextText = TRUE;
    }

    if (hr == S_OK && fHasNextText && cpNextRange)
    {
        BOOL    fNextRangeConsumeSpace = FALSE;
        BOOL    fAddOneSpace = FALSE;  // this is only for Hyphen handling, 
                                       // if it is TRUE, a trailing space is required 
                                       // to append.
                                       // so that new text could be like A - B.
        WCHAR   wszText[4];

        hr = cpNextRange->GetText(ec, 0, wszText, 1, (ULONG *)&cch);

        if ((hr == S_OK) && ( iswcntrl(wszText[0]) || iswpunct(wszText[0]) ))
        {
            // if the character is a control character or punctuation character,
            // it means it want to consume the previous spaces.
            fNextRangeConsumeSpace = TRUE;

            if ((wszText[0] == L'-') || (wszText[0] == 0x2013)) // Specially handle Hyphen character.
            {
                // If the next text is "-xxx", there should be no space between 
                // this range and next range.

                // If the next text is "- xxx", there should be a space between 
                // this range and next range, the text would be: "nnn - xxx"
                HRESULT          hret;

                hret = cpNextRange->ShiftEnd(ec, 1, &cch, NULL);

                if ( hret == S_OK && cch > 0 )
                {
                    hret = cpNextRange->GetText(ec, 0, wszText, 2, (ULONG *)&cch);

                    if ( hret == S_OK && cch == 2  && wszText[1] == L' ')
                        fAddOneSpace = TRUE;
                }
            }
        }

        if ( fNextRangeConsumeSpace )
        {
            _CheckStartComposition(ec, cpTrailSpaceRange);
            if ( !fAddOneSpace )
                hr = cpTrailSpaceRange->SetText(ec, 0, NULL, 0);
            else
                hr = cpTrailSpaceRange->SetText(ec, 0, L" ", 1);
        }
    }

    return hr;
}

//
// CSapiIMX::_ProcessLeadingSpaces
//
// If this phrase wants to consume leading spaces, all the spaces before this phrase
// must be removed.
// if the phrase doesn't want to consume leading spaces, and there is no space between
// this phrase and previous phrase for English case, leading space is required to add 
// between these two phrases.
//
HRESULT CSapiIMX::_ProcessLeadingSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, LANGID langid, BOOL fStartInMidWord)
{
    HRESULT  hr = S_OK;

    if (!pTextRange || !pic)
        return E_INVALIDARG;

    // Handle Consuming leading Spaces.
    if (fConsumeLeadSpaces )
    {
        CComPtr<ITfRange> cpLeadSpaceRange;

        hr = _GetSpaceRangeBeyondText(ec, pTextRange, TRUE, &cpLeadSpaceRange);
        if ( hr == S_OK  && cpLeadSpaceRange )
        {
            // Kill all the trailing spaces in the range.
            // start a composition here if we haven't already
            _CheckStartComposition(ec, cpLeadSpaceRange);
            hr = cpLeadSpaceRange->SetText(ec, 0, NULL, 0);
        }
    }

    // Specially handle some other space cases for English
    if ((hr == S_OK) && (langid == 0x0409))
    {
        // If this phrase doesn't consume the leading space, and 
        // there is no any spaces between this text range and a real previous text word.
        // we need to add one space here.

        // if this is a spelled text, and the start anchor of selection or ip is inside
        // of a word, don't add extra leading space.
        //
        if ( hr == S_OK && !fConsumeLeadSpaces && !fStartInMidWord)
        {
            CComPtr<ITfRange> cpLeadSpaceRange;
            BOOL              fRealTextInPreviousWord = FALSE;

            hr = _GetSpaceRangeBeyondText(ec, pTextRange, TRUE, &cpLeadSpaceRange,&fRealTextInPreviousWord);

            if ( hr == S_OK && !cpLeadSpaceRange  && fRealTextInPreviousWord )
            {
                //
                // Specially handle the hyphen case for bug 468907
                //
                // if the previous text is "x-", this  text is "y", 
                // the final text should be like "x-y".
                // we should not add one space in this case.
                //
                // if the previous text is "x -", the final text would be "x - y"
                // the extra space is necessary.

                BOOL   fAddExtraSpace = TRUE;
                CComPtr<ITfRange>   cpPrevTextRange;
                WCHAR               wszTrailTextInPrevRange[3];
                LONG                cch;
                
                // Since previous text range does exist,  ( fRealTextInPreviousWord is TRUE).
                // and there is no space between this range and previous range.
                // we can just rely on pTextRange to shift to previous range and get 
                // its trail characters. ( last two characters, saved in wszTrailTextInPrevRange).

                hr = pTextRange->Clone(&cpPrevTextRange);

                if ( hr == S_OK )
                    hr = cpPrevTextRange->Collapse(ec, TF_ANCHOR_START);

                if ( hr == S_OK )
                    hr = cpPrevTextRange->ShiftStart(ec, -2, &cch, NULL);

                if ( hr == S_OK )
                    hr = cpPrevTextRange->GetText(ec, 0, wszTrailTextInPrevRange, 2, (ULONG *)&cch);

                if ( hr == S_OK && cch == 2 )
                {
                    if ( (wszTrailTextInPrevRange[0] != L' ') && 
                         ((wszTrailTextInPrevRange[1] == L'-') || (wszTrailTextInPrevRange[1] == 0x2013)) )
                        fAddExtraSpace = FALSE;
                }

                if ( fAddExtraSpace )
                {
                    hr = pTextRange->Clone(&cpLeadSpaceRange);

                    if ( hr == S_OK )
                        hr = cpLeadSpaceRange->Collapse(ec, TF_ANCHOR_START);

                    if ( hr == S_OK )
                    {
                        // Insert one Space to this new empty range.
                        _CheckStartComposition(ec, cpLeadSpaceRange);
                        hr = cpLeadSpaceRange->SetText(ec, 0, L" ", 1);
                    }
                }
            }
        }
    }

    return hr;
}


//
//  CSapiIMX::_ProcessSpaces
//
//  Edit session callback function for ESCB_HANDLESPACES.
//
//
HRESULT CSapiIMX::_ProcessSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, ULONG ulNumTrailSpace, LANGID langid, BOOL fStartInMidWord, BOOL fEndInMidWord )
{
    HRESULT  hr = S_OK;

    if (!pTextRange || !pic)
        return E_INVALIDARG;

    hr = _ProcessLeadingSpaces(ec, pic, pTextRange,fConsumeLeadSpaces, langid, fStartInMidWord);

    // Specially handle some other space cases for English
    if ((hr == S_OK) && (langid == 0x0409))
    {
        // Remove all the unnecessary spaces between this text range and next word.
        CComPtr<ITfRange>  cpTrailSpaceRange;

        hr = _GetSpaceRangeBeyondText(ec, pTextRange, FALSE, &cpTrailSpaceRange);
        if ( hr == S_OK && cpTrailSpaceRange )
        {
            _CheckStartComposition(ec, cpTrailSpaceRange);
            hr = cpTrailSpaceRange->SetText(ec, 0, NULL, 0);
        }
    }

    if ( (hr == S_OK) && fEndInMidWord )
    {
        // This is spelled text.
        // EndAnchor is in middle of a word.
        // we just want to remove the trail spaces injected in this text range.

        if ( ulNumTrailSpace )
        {
            CComPtr<ITfRange>       cpTrailSpaceRange;
            LONG                    cch;

            hr = pTextRange->Clone(&cpTrailSpaceRange);

            if (hr == S_OK)
                hr = cpTrailSpaceRange->Collapse(ec, TF_ANCHOR_END);

            // Generate the real Trailing Space Range
            if (hr == S_OK)
                hr = cpTrailSpaceRange->ShiftStart(ec, (LONG)ulNumTrailSpace * (-1), &cch, NULL);

            if ( hr == S_OK && cch != 0 )
            {
                // Remove the spaces.
                _CheckStartComposition(ec, cpTrailSpaceRange);
                hr = cpTrailSpaceRange->SetText(ec, 0, NULL, 0);
            }

            if ( hr == S_OK )
                ulNumTrailSpace = 0;
        }
       
    }

    // If the next phrase wants to consume leading space,
    // we want to remove all the trailing spaces in this text range.
    // This is for all languages.

    if ( hr == S_OK )
        hr = _ProcessTrailingSpace(ec, pic, pTextRange, ulNumTrailSpace);

    return hr;
}

//
// CSapiIMX::_ProcessRecoObject
//
//
HRESULT CSapiIMX::_ProcessRecoObject(TfEditCookie ec, ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements)
{
    HRESULT hr;
    ITfContext *pic;
    CComPtr<ITfRange> cpInsertionPoint;

    if (!GetFocusIC(&pic))
    {
        return E_OUTOFMEMORY;
    }

    _fEditing = TRUE;
    if (cpInsertionPoint = GetSavedIP())
    {
        // this is trying to determine
        // if the saved IP was on this context.
        // if not we just ignore that
        CComPtr<ITfContext> cpic;
  
        hr = cpInsertionPoint->GetContext(&cpic);
        if (S_OK != hr || cpic != pic)
        {
            cpInsertionPoint.Release();
        }
    }
    // find range to attach property
    if (!cpInsertionPoint)
    {
        CComPtr<ITfRange> cpSelection;
        if (GetSelectionSimple(ec, pic, &cpSelection) == S_OK)
        {
            cpInsertionPoint = cpSelection; // comptr addrefs
        }
    }
   
    if (cpInsertionPoint)
    {
        CComPtr<ITfRange> cpRange;
        
        BOOL fPrSize = _FindPrevComp(ec, pic, cpInsertionPoint, &cpRange, GUID_ATTR_SAPI_INPUT);

        if (!fPrSize)
        {
            hr = E_FAIL; // we may need to assert here?
            goto pr_exit;
        }
        
            
        CComPtr<ITfProperty> cpProp;

        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp)))
        {
            CComPtr<ITfPropertyStore> cpResultStore;
        
            CPropStoreRecoResultObject *prps = new CPropStoreRecoResultObject(this, cpRange);

            if (!prps)
            {
                hr = E_OUTOFMEMORY;
                goto pr_exit;
            }
            
            // determine whether this partial result has an ITN
            SPPHRASE *pPhrase;
            ULONG     ulNumOfITN = 0;
            hr = pResult->GetPhrase(&pPhrase);
            if (S_OK == hr)
            {
                const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
                for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
                {
                    // review: we need to verify if this is really a correct way to determine
                    // whether the ITN fits in the partial result
                    //
                    if (pRep->ulFirstElement >= ulStartElement 
                    && (pRep->ulFirstElement + pRep->ulCountOfElements) <= (ulStartElement + ulNumElements))
                    {
                        ulNumOfITN ++;
                    }
                    pRep++;
                }
                ::CoTaskMemFree(pPhrase);
            }
            
            CRecoResultWrap *prw = new CRecoResultWrap(this, ulStartElement, ulNumElements, ulNumOfITN);
            if (prw)
            {
                hr = prw->Init(pResult);
            }
            else
                hr = E_OUTOFMEMORY;

            // set up the result data
            if (S_OK == hr)
            {
                // save text
                CComPtr<ITfRange> cpRangeTemp;

                hr = cpRange->Clone(&cpRangeTemp);
                if (S_OK == hr)
                {
                    long cch;
                    TF_HALTCOND hc;
                    WCHAR *psz;

                    hc.pHaltRange = cpRange;
                    hc.aHaltPos = TF_ANCHOR_END;
                    hc.dwFlags = 0;
                    cpRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc);
                    psz = new WCHAR[cch+1];

                    if (psz)
                    {
                        if ( S_OK == cpRange->GetText(ec, 0, psz, cch, (ULONG *)&cch))
                        {
                            prw->m_bstrCurrentText = SysAllocString(psz);
                            delete[] psz;
                        }
                    }
                } 

                // Init the ITN Show State list in reco wrapper.

                prw->_InitITNShowState(TRUE, 0, 0);

                hr = prps->_InitFromResultWrap(prw); // this addref's
            }

            // get ITfPropertyStore interface
            if (SUCCEEDED(hr))
            {
                hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)&cpResultStore);
                SafeRelease(prps);
            }


            // set the property store for this range property
            if (hr == S_OK)
            {
                hr = cpProp->SetValueStore(ec, cpRange, cpResultStore);
            }
            
            if (_MasterLMEnabled())
            {
                // set up the LM lattice store, only if reco result is given
                // 
                CComPtr<ITfProperty> cpLMProp;

                if ( S_OK == hr &&
                SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LMLATTICE, &cpLMProp)))
                {
                    CPropStoreLMLattice *prpsLMLattice = new CPropStoreLMLattice(this);
                    CComPtr<ITfPropertyStore> cpLatticeStore;

                    if (prpsLMLattice && prw)
                    {
                        hr = prpsLMLattice->_InitFromResultWrap(prw);
                    }
                    else
                        hr = E_OUTOFMEMORY;
        
                    if (S_OK == hr)
                    {
                        hr = prpsLMLattice->QueryInterface(IID_ITfPropertyStore, (void **)&cpLatticeStore);
                    }
        
                    if (S_OK == hr)
                    {
                        hr = cpLMProp->SetValueStore(ec, cpRange, cpLatticeStore);
                    }
                    SafeRelease(prpsLMLattice);
                }
            }
            SafeRelease(prw);
        }
    }

pr_exit:
    _fEditing = FALSE;
    pic->Release();

    return hr;
}

HRESULT CSapiIMX::_PreserveResult(TfEditCookie ec, ITfRange *pRange, ITfProperty *pProp, CRecoResultWrap **ppRecoWrap, ITfRange **ppPropRange)
{
    HRESULT hr;
    ITfRange *pPropRange;
    CComPtr<IUnknown> cpunk;
    
    Assert(ppPropRange);

    hr = pProp->FindRange(ec, pRange, &pPropRange, TF_ANCHOR_START);
    // retrieve the result data and addref it
    //
    if (SUCCEEDED(hr) && pPropRange)
    {
        hr = GetUnknownPropertyData(ec, pProp, pPropRange, &cpunk); 
        *ppPropRange = pPropRange;
        // would be released at the caller
        // pPropRange->Release();

        // get the result object, cpunk points to our wrapper object
        CComPtr<IServiceProvider> cpServicePrv;
        CComPtr<ISpRecoResult>    cpResult;
        CRecoResultWrap *pRecoWrapOrg = NULL;

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
        }
        // get result object
        if (S_OK == hr)
        {
            hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);
        }

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pRecoWrapOrg);
        }

        // Now Create a new RecoResult Wrapper based on the org wrapper's data.
        // Clone a new RecoWrapper.

        if ( S_OK == hr )
        {
            CRecoResultWrap *pRecoWrapNew = NULL;
            ULONG           ulStartElement, ulNumElements, ulNumOfITN;

            ulStartElement = pRecoWrapOrg->GetStart( );
            ulNumElements = pRecoWrapOrg->GetNumElements( );
            ulNumOfITN = pRecoWrapOrg->m_ulNumOfITN;

            pRecoWrapNew = new CRecoResultWrap(this, ulStartElement, ulNumElements, ulNumOfITN);

            if ( pRecoWrapNew )
            {
                // Init from RecoResult SR object
                hr = pRecoWrapNew->Init(cpResult);

                if ( S_OK == hr )
                {
                    pRecoWrapNew->SetOffsetDelta( pRecoWrapOrg->_GetOffsetDelta( ) );
                    pRecoWrapNew->SetCharsInTrail( pRecoWrapOrg->GetCharsInTrail( ) );
                    pRecoWrapNew->SetTrailSpaceRemoved( pRecoWrapOrg->GetTrailSpaceRemoved( ) );
                    pRecoWrapNew->m_bstrCurrentText = SysAllocString((WCHAR *)pRecoWrapOrg->m_bstrCurrentText);

                    // Update ITN show-state list .

                    if ( ulNumOfITN > 0 )
                    {
                        SPITNSHOWSTATE  *pITNShowStateOrg;

                        for ( ULONG  iIndex=0; iIndex<ulNumOfITN; iIndex ++ )
                        {
                            pITNShowStateOrg = pRecoWrapOrg->m_rgITNShowState.GetPtr(iIndex);

                            if ( pITNShowStateOrg)
                            {
                                ULONG     ulITNStart;
                                ULONG     ulITNNumElem;
                                BOOL      fITNShown;

                                ulITNStart = pITNShowStateOrg->ulITNStart;
                                ulITNNumElem = pITNShowStateOrg->ulITNNumElem;
                                fITNShown = pITNShowStateOrg->fITNShown;

                                pRecoWrapNew->_InitITNShowState(fITNShown, ulITNStart, ulITNNumElem );
                                             
                            }
                        } // for
                    } // if

                    // Update Offset List
                    if ( pRecoWrapOrg->IsElementOffsetIntialized( ) )
                    {
                        ULONG  ulOffsetNum;
                        ULONG  i;
                        ULONG  ulOffset;

                        ulOffsetNum = pRecoWrapOrg->GetNumElements( ) + 1;

                        for ( i=0; i < ulOffsetNum; i ++ )
                        {
                            ulOffset = pRecoWrapOrg->_GetElementOffsetCch(ulStartElement + i );
                            pRecoWrapNew->_SetElementNewOffset(ulStartElement + i, ulOffset);
                        }
                    }
                }

                SafeRelease(pRecoWrapOrg);

                if ( ppRecoWrap )
                    *ppRecoWrap = pRecoWrapNew;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CSapiIMX::_RestoreResult(TfEditCookie ec, ITfRange *pPropRange, ITfProperty *pProp, CRecoResultWrap *pRecoWrap)
{
    Assert(m_pCSpTask);
        
    CPropStoreRecoResultObject *prps = new CPropStoreRecoResultObject(this, pPropRange);

    HRESULT hr;
    if (prps)
    {
        ITfPropertyStore *pps;
        // restore the result object
        prps->_InitFromResultWrap(pRecoWrap);

        // get ITfPropertyStore interface
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)&pps);

        prps->Release();
    
        // re-set the property store for this range property
        if (hr == S_OK)
        {
            hr = pProp->SetValueStore(ec, pPropRange, pps);
            pps->Release();
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


HRESULT CSapiIMX::_FinalizePrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
//
//  the following code assumes single IP with no simaltanious SR going on
//  we always remove the feedback UI and focus range everytime we receive
//  SR result - mainly for demonstration purpose 
//
{
    // kill the Feedback UI for the entire document
    HRESULT hr = _KillFeedbackUI(ec, pic,  NULL);
    
    // also clear the focus range and its display attribute
    if (SUCCEEDED(hr))
    {
        hr = _KillFocusRange(ec, pic, NULL, _tid);
    }
    
    return hr;
}

//
// bogus: very similar to Finalize prev comp. Consolidate this!
//
//
BOOL CSapiIMX::_FindPrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRangeOut, GUID input_attr)
{
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp;
    LONG l;
    BOOL fEmpty;
    BOOL fRet = FALSE;

    // usual stuff
    pRange->Clone(&pRangeTmp);
    
    // set size to 0
    pRangeTmp->Collapse(ec, TF_ANCHOR_START);

    // shift to the previous position
    pRangeTmp->ShiftStart(ec, -1, &l, NULL);

    ITfRange *pAttrRange;

    ITfProperty *pProp = NULL;
    if (SUCCEEDED(pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &pProp)))
    {
        hr = _FindPropRange(ec, pProp, pRangeTmp, &pAttrRange, input_attr);

        if (S_OK == hr && pAttrRange)
        {
            TfGuidAtom attr;
            if (SUCCEEDED(GetGUIDPropertyData(ec, pProp, pAttrRange, &attr)))
            {
                if (IsEqualTFGUIDATOM(&_libTLS, attr, input_attr))
                {
                    hr = pAttrRange->Clone(ppRangeOut);
                }
            }
            pAttrRange->Release();
        }
        pProp->Release();
    }

    pRangeTmp->Release();
    
    if (SUCCEEDED(hr) && *ppRangeOut)
    {
        (*ppRangeOut)->IsEmpty(ec, &fEmpty);
        fRet = !fEmpty;
    }

    return fRet;
}
//
// CSapiIMX::_SetLangID
//
// synopsis - set langid for the given text range 
//
HRESULT CSapiIMX::_SetLangID(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID langid)
{
    BOOL fEmpty;
    HRESULT hr = E_FAIL;

    pRange->IsEmpty(ec, &fEmpty);

    if (!fEmpty)
    {
        //
        // make langid prop
        //
        ITfProperty *pProp = NULL;

        // set the attrib info
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
        {
            hr = SetLangIdPropertyData(ec, pProp, pRange, langid);
            pProp->Release();
        }
    }

    return hr;
}

//
// CSapiIMX::_FindPropRange
//
//
HRESULT CSapiIMX::_FindPropRange(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, ITfRange **ppAttrRange, GUID input_attr, BOOL fExtend)
{
    // set the attrib info
    ITfRange *pAttrRange = NULL;
    ITfRange *pRangeTmp;
    TfGuidAtom guidAttr = TF_INVALID_GUIDATOM;
    HRESULT hr;
//    LONG l;

    // set the attrib info
    pRange->Clone(&pRangeTmp);

// There is no need to shiftstart to the left again when this function is called.
// This function is called in two different places, one in FindPrevComp( ) and the  
// other is in ProcessTextInternal( ).  FindPrevComp( ) has already shift the start
// anchor to left by 1 already, we don't want to shift again, otherwise, if the phrase
// contains only one char, it will not find the right prev-composition string.
// In function ProcessTextInternal( ), shift start anchor to left is not really required.
// 
// Remove the below two lines will fix cicero bug 3646 & 3649
//     
    
//    pRangeTmp->Collapse(ec, TF_ANCHOR_START);
//    pRangeTmp->ShiftStart(ec, -1, &l, NULL);

    hr = pProp->FindRange(ec, pRangeTmp, &pAttrRange, TF_ANCHOR_START);

    if (S_OK == hr && pAttrRange)
    {
        hr = GetGUIDPropertyData(ec, pProp, pAttrRange, &guidAttr);
    }

    if (SUCCEEDED(hr))
    {
        if (!IsEqualTFGUIDATOM(&_libTLS, guidAttr, input_attr))
        {
            SafeReleaseClear(pAttrRange);
        }
    }

    if (fExtend)
    {
        if (pAttrRange)
        {
           pAttrRange->ShiftEndToRange(ec, pRange, TF_ANCHOR_END);
        }
    }

    *ppAttrRange = pAttrRange;
 
    SafeRelease(pRangeTmp);

    return hr;
}


HRESULT CSapiIMX::_DetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    BOOL    fDetected;
    HRESULT hr = _KillOrDetectFeedbackUI(ec, pic, pRange, &fDetected);
    if (S_OK == hr)
    {
        if (fDetected)
        {
            hr = _RequestEditSession(ESCB_KILLFEEDBACKUI, TF_ES_ASYNC|TF_ES_READWRITE, NULL);
        }
        
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// _KillFeedbackUI
//
// get rid of the green/red bar thing within the given range
//
//----------------------------------------------------------------------------+

HRESULT CSapiIMX::_KillFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    return _KillOrDetectFeedbackUI(ec, pic, pRange, NULL);
}

HRESULT CSapiIMX::_KillOrDetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL * pfDetection)
{
    HRESULT hr;
    ITfProperty *pProp = NULL;
    ITfRange *pAttrRange = NULL;
    IEnumTfRanges *pEnumPr;

    if (pfDetection)
        *pfDetection = FALSE;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;
    
    if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
    {
        hr = pProp->EnumRanges(ec, &pEnumPr, pRange);
        if (SUCCEEDED(hr)) 
        {
            TfGuidAtom guidAttr;
            while( pEnumPr->Next(1, &pAttrRange, NULL) == S_OK )
            {
                if (SUCCEEDED(GetAttrPropertyData(ec, pProp, pAttrRange, &guidAttr)))
                {

                    if ( IsEqualTFGUIDATOM(&_libTLS, guidAttr, GUID_ATTR_SAPI_GREENBAR) ||  IsEqualTFGUIDATOM(&_libTLS, guidAttr, GUID_ATTR_SAPI_GREENBAR2)
                       )
                    {

                        if (pfDetection == NULL)
                        {
                            // we're not detecting the feedback UI
                            // kill this guy
                            ITfRange *pSel;
                            if (SUCCEEDED(pAttrRange->Clone(&pSel)))
                            {
                                // Because we didn't change the speech property data while 
                                // feedback text were injected.
                                //
                                // Now, when the feedback is killed, we don't want to affect
                                // the original speech property data either.
                                // 
                                // set the below flag to prevent the speech property data updated
                                // similar way as in feedback UI injection handling
                                //

                                m_fAcceptRecoResultTextUpdates = TRUE;
                                pSel->SetText(ec, 0, NULL, 0);
                               
                                // CUAS application will not update the composition
                                // while the feedback text is removed based on msctfime
                                // current text update checking logic.
                                //
                                // Call SetSection( ) to forcelly update the edit record 
                                // of the selection status, and then make sure CUAS 
                                // update composition string successfully.
                                // 
                                if ( !_IsPureCiceroIC(pic) )
                                   SetSelectionSimple(ec, pic, pSel);

                                pSel->Release();
                                m_fAcceptRecoResultTextUpdates = FALSE;

                            }
                        }
                        else
                        {
                            *pfDetection = TRUE;
                        }
                    }
                }

                pAttrRange->Release();
            }

            pEnumPr->Release();
        }
        pProp->Release();
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// MakeResultString
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid, CSpTask *pCSpTask)
{
    TraceMsg(TF_GENERAL, "MakeResultString is Called");

    HRESULT hr = S_OK;

    if (pCSpTask != NULL)
    {
        AbortString(ec, pic, pCSpTask);
    }
    _KillFocusRange(ec, pic, NULL, tid);

    return hr;
}

//+---------------------------------------------------------------------------
//
// AbortString
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::AbortString(TfEditCookie ec, ITfContext *pic, CSpTask *pCSpTask)
{
    // We may consider not to kill the entire feedback UI
    // because SR happens at background and there can be multi-
    // range dictation going at once but for now, we just kill
    // them all for safety. Later on, we'll re-visit this
    // CSpTask::_StopInput kill the feedback UI.
    //
    Assert(pCSpTask);
    pCSpTask->_StopInput();
    _KillFeedbackUI(ec, pic, NULL);

    return S_OK;
}

HRESULT CSapiIMX::_FinalizeComposition()
{
    return _RequestEditSession(ESCB_FINALIZECOMP, TF_ES_READWRITE);
}

HRESULT CSapiIMX::FinalizeAllCompositions( )
{
    return _RequestEditSession(ESCB_FINALIZE_ALL_COMPS, TF_ES_READWRITE);
}

HRESULT CSapiIMX::_FinalizeAllCompositions(TfEditCookie ec, ITfContext *pic )
{
    HRESULT hr = E_FAIL;
    IEnumITfCompositionView *pEnumComp = NULL;
    ITfContextComposition *picc = NULL;
    ITfCompositionView *pCompositionView;
    ITfComposition *pComposition;
    CLSID clsid;
    CICPriv *picp;
    BOOL     fHasOtherComp = FALSE; // When there is composition which is initialized and started
                                    // by other tips, ( especially by Keyboard tips), this variable 
                                    // set to TRUE
    //
    // clear any sptip compositions over the range
    //

    if (pic->QueryInterface(IID_ITfContextComposition, (void **)&picc) != S_OK)
        goto Exit;

    if (picc->FindComposition(ec, NULL, &pEnumComp) != S_OK)
        goto Exit;

    picp = GetInputContextPriv(_tid, pic);

    while (pEnumComp->Next(1, &pCompositionView, NULL) == S_OK)
    {
        if (pCompositionView->GetOwnerClsid(&clsid) != S_OK)
            goto NextComp;

        if (!IsEqualCLSID(clsid, CLSID_SapiLayr))
        {
            fHasOtherComp = TRUE;
            goto NextComp;
        }

        if (pCompositionView->QueryInterface(IID_ITfComposition, (void **)&pComposition) != S_OK)
            goto NextComp;

        // found a composition, terminate it
        pComposition->EndComposition(ec);
        pComposition->Release();

        if (picp != NULL)
        {
            picp->_ReleaseComposition();
        }

NextComp:
        pCompositionView->Release();
    }

    SafeRelease(picp);

    if ( fHasOtherComp )
    {
        // Simulate VK_RETURN to terminate composition started by other tips.
        HandleKey( VK_RETURN );
    }

    hr = S_OK;

Exit:
    SafeRelease(picc);
    SafeRelease(pEnumComp);

    SaveLastUsedIPRange( );
    SaveIPRange(NULL);
    
    return hr;
}


//+---------------------------------------------------------------------------
//
// SaveCurrentIP
//
// synopsis: this is for recognition handler CSpTask to call when
//           The first hypothesis arrives
//
//+---------------------------------------------------------------------------
void CSapiIMX::SaveCurrentIP(TfEditCookie ec, ITfContext *pic)
{
    CComPtr<ITfRange>   cpSel;
    
    HRESULT hr = GetSelectionSimple(ec, pic, (ITfRange **)&cpSel); 
    
   
    if (SUCCEEDED(hr))
    {
        SaveIPRange(cpSel);
    }
}

//+---------------------------------------------------------------------------
//
// _SyncModeBiasWithSelection
//
// synopsis: obtain a read cookie to process selection API
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_SyncModeBiasWithSelection(ITfContext *pic)
{
    return _RequestEditSession(ESCB_SYNCMBWITHSEL, TF_ES_READ|TF_ES_ASYNC, NULL, pic);
}

HRESULT CSapiIMX::_SyncModeBiasWithSelectionCallback(TfEditCookie ec, ITfContext *pic)
{
    ITfRange *sel;

    if (S_OK == GetSelectionSimple(ec, pic, &sel))
    {
        SyncWithCurrentModeBias(ec, sel, pic);
        sel->Release();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetRangeText
//
// synopsis: obtain a read cookie to process selection API
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_GetRangeText(ITfRange *pRange, DWORD dwFlgs, WCHAR *psz, ULONG *pulcch)
{
    HRESULT hr = E_FAIL;
    
    Assert(pulcch);
    Assert(psz);
    Assert(pRange);

    CComPtr<ITfContext> cpic;
    
    hr = pRange->GetContext(&cpic);
    
    if (S_OK == hr)
    {
        CSapiEditSession *pes = new CSapiEditSession(this, cpic);

        if (pes)
        {
            ULONG  ulInitSize;

            ulInitSize = *pulcch;

            pes->_SetEditSessionData(ESCB_GETRANGETEXT, NULL, (UINT)(ulInitSize+1) * sizeof(WCHAR), (LONG_PTR)dwFlgs, (LONG_PTR)*pulcch);
            pes->_SetRange(pRange);

            cpic->RequestEditSession(_tid, pes, TF_ES_READ | TF_ES_SYNC, &hr);

            if ( SUCCEEDED(hr) )
            {
                ULONG   ulNewSize;

                ulNewSize = (ULONG)pes->_GetRetData( );
                if ( ulNewSize > 0 && ulNewSize <= ulInitSize && pes->_GetPtrData( ) != NULL)
                {
                    wcsncpy(psz, (WCHAR *)pes->_GetPtrData( ), ulNewSize);
                    psz[ulNewSize] = L'\0';
                }

                *pulcch = ulNewSize;
            }

            pes->Release( );
        }
    } 

    return hr;
}

//+---------------------------------------------------------------------------
//
//    _IsRangeEmpty
//
//    synopsis: 
//
//---------------------------------------------------------------------------+
BOOL CSapiIMX::_IsRangeEmpty(ITfRange *pRange)
{
    CComPtr<ITfContext> cpic;
    BOOL fEmpty = FALSE;

    pRange->GetContext(&cpic);
    
    if ( cpic )
    {
        _RequestEditSession(ESCB_ISRANGEEMPTY, TF_ES_READ|TF_ES_SYNC, NULL, cpic, (LONG_PTR *)&fEmpty);
    }
    
    return fEmpty;
}


HRESULT CSapiIMX::_HandleHypothesis(CSpEvent &event)
{
    HRESULT hr = E_FAIL;


    m_ulHypothesisNum ++;
    if ( (m_ulHypothesisNum % 3) != 1 )
    {
        TraceMsg(TF_SAPI_PERF, "Discarded hypothesis %i.", m_ulHypothesisNum % 3);
        return S_OK;
    }

    // if it is under hypothesis processing, don't start a new edit session.
    if ( m_IsInHypoProcessing ) 
    {
        TraceMsg(TF_SAPI_PERF, "It is under process for previous hypothesis");
        return S_OK;
    }

    m_IsInHypoProcessing = TRUE;

    ISpRecoResult *pResult = event.RecoResult();
    if (pResult)
    {
        ESDATA  esData;

        memset(&esData, 0, sizeof(ESDATA));
        esData.pUnk = (IUnknown *)pResult;

        // Require it to be asynchronous to guarantee we don't get called before we have had change
        // to process any final recognition events from SAPI. Otherwise the hypothesis gets injected
        // immediately and then the final recognition tries to remove it which fails.

        hr = _RequestEditSession(ESCB_HANDLEHYPOTHESIS, TF_ES_ASYNC | TF_ES_READWRITE, &esData);
    }

    if ( FAILED(hr) )
    {
        // Set flag to indicate hypothesis processing is finished.
        m_IsInHypoProcessing = FALSE;
    }

    // When hr is succeeded, including TF_S_ASYNC, the edit session function will be called, and
    // it will set the flag when the edit session function exits.

    return hr;
}

void CSapiIMX::_HandleHypothesis(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec)
{

    // if there is a selection, do not inject
    // feedback UI
    //
    // save the current IP if we haven't done so
    if (m_pCSpTask->_GotReco())
    {
        // Optimization and bugfix. We already have a reco and hence have no need to update
        // the feedback bar. AND if we do, it gets left in the document at dictation off and
        // voice commands since it gets altered immediately before an attempt to remove it which
        // then silently fails.

        // Set flag to indicate hypothesis processing is finished.
        m_IsInHypoProcessing = FALSE;
        return;
    }
    
    Assert(pic);

    CComPtr<ITfRange> cpRange = GetSavedIP();

    if (cpRange)
    {
        CComPtr<ITfContext> cpic;
        if (S_OK == cpRange->GetContext(&cpic))
        {
            if (cpic != pic)
               cpRange.Release();  // this will set NULL to cpRange
        }
    }
    
    if ( !cpRange )
    {
        SaveCurrentIP(ec, pic);
        cpRange = GetSavedIP();
    }

        
    SPPHRASE *pPhrase = NULL;

    HRESULT hr = pResult->GetPhrase(&pPhrase);
    if (SUCCEEDED(hr) && pPhrase )
    {
        BOOL fEmpty = FALSE;
        if ( cpRange )
            cpRange->IsEmpty(ec, &fEmpty);

        if (cpRange && fEmpty && pPhrase->ullGrammarID == GRAM_ID_DICT)
        {
            CSpDynamicString dstr;
            hr = pResult->GetText( SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstr, NULL ); 
            if (S_OK == hr)
            {
                int cch = wcslen(dstr);
                BOOL fAware =  IsFocusFullAware(_tim);
                if ( cch > (int)m_ulHypothesisLen )
                {
                    _AddFeedbackUI(ec, 
                                   fAware ? DA_COLOR_AWARE : DA_COLOR_UNAWARE,
                                   5);
                    m_ulHypothesisLen = cch;
                }
            }
        }
        CoTaskMemFree(pPhrase);
    }

    // Set flag to indicate hypothesis processing is finished.
    m_IsInHypoProcessing = FALSE;
}


HRESULT CSapiIMX::_HandleFalseRecognition(void)
{
    m_ulHypothesisLen = 0;
    m_ulHypothesisNum = 0;

    return S_OK;
}

HRESULT CSapiIMX::_HandleRecognition(CSpEvent &event, ULONGLONG *pullGramID)
{
    HRESULT hr = S_OK;

    m_ulHypothesisLen = 0;
    m_ulHypothesisNum = 0;

    ISpRecoResult *pResult = event.RecoResult();
    if (pResult)
    {
        SPPHRASE *pPhrase = NULL;

        hr = pResult->GetPhrase(&pPhrase);
        if (S_OK == hr)
        {
            BOOL        fCommand = FALSE;
            ULONGLONG   ullGramId;
            BOOL        fInjectToDoc = TRUE;

            ullGramId = pPhrase->ullGrammarID;

            if ( ullGramId != GRAM_ID_DICT && ullGramId != GRAM_ID_SPELLING )
            {
                // This is a C&C grammar.
                fCommand = TRUE;
            }
            else if ( ullGramId == GRAM_ID_SPELLING )
            {
                const WCHAR  *pwszName;

                pwszName = pPhrase->Rule.pszName;

                if ( pwszName )
                {
                    if (0 == wcscmp(pwszName, c_szSpelling))
                        fCommand = TRUE;
                    else if ( 0 == wcscmp(pwszName, c_szSpellMode) )
                    {
                        fCommand = TRUE;
                        ullGramId = 0;  // return 0 to fool the handler for SPEI_RECOGNITION
                                        // so that it will not call _SetSpellingGrammarStatus(FALSE);
                    }
                }
            }

            if (pullGramID)
                *pullGramID = ullGramId;

            if ( fCommand == TRUE)
            {
                // If we got the final recognition before a SOUND_END event we should remove the
                // feedback here otherwise it can and is left in the document.
                EraseFeedbackUI(); // Ignore HRESULT for better failure behavior.

                // If candidate UI is open, we need to close it now. This means a voice command (such as scratch that)
                // will cause the candidate UI to close if open.
                CloseCandUI( );

                // we process this reco synchronously
                // _DoCommand internal will start edit session if necessary
                hr = m_pCSpTask->_DoCommand(pPhrase->ullGrammarID, pPhrase, pPhrase->LangID);

                if ( SUCCEEDED(hr) )
                {
                    // if the Command hanlder handles the command successfully, we don't
                    // inject the result to the document.
                    // otherwise, we just inject the text to the document.

                    fInjectToDoc = FALSE;
                }
            }

            if ( fInjectToDoc )
            {
                ESDATA  esData;

                memset(&esData, 0, sizeof(ESDATA));

                esData.pUnk = (IUnknown *)pResult;
                hr = _RequestEditSession(ESCB_HANDLERECOGNITION, TF_ES_READWRITE, &esData);
            }
            CoTaskMemFree(pPhrase);
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    return hr;
}

void CSapiIMX::_HandleRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec)
{
    _KillFeedbackUI(ec, pic, NULL);
    m_pCSpTask->_OnSpEventRecognition(pResult, pic, ec);

    // Before we clear the saved ip range, we need to treat this current ip as last 
    // saved ip range if current ip is selected by end user
    SaveLastUsedIPRange( );

    // clear the saved IP range
    SaveIPRange(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\editsess.h ===
// editsess.h
//
// Edit Session classes declaration
//
#ifndef EDITSESS_H
#define EDITSESS_H

#include "private.h"
#include "sapilayr.h"
#include "playback.h"
#include "fnrecon.h"
#include "propstor.h"
#include "selword.h"

class CSapiIMX;
class CPlayBack;
class CFnReconversion;
class CPropStoreRecoResultObject;
class CPropStoreLMLattice;
class CSelectWord;

//
// Caller puts all the Edit Session in-paramaters to this structure and pass to _RequestEditSession( ).
//
typedef struct _ESData
{
    void     *pData;     // pData pointer to memory.  its size is uByte of bytes.
    UINT      uByte;     // 
    LONG_PTR  lData1;    // m_lData1 and m_lData2 contain constant data.
    LONG_PTR  lData2;    
    BOOL      fBool;
    ITfRange  *pRange;
    IUnknown  *pUnk;
}  ESDATA;

//
// This is a base class for Sptip edit sessions.
// We don't want to inherit the class from CEditSession in inc\editcb.h which doesn't correctly handle some COM pointer
// and /or allocated memeory pointer.

// We don't change the code in lib\editcb.cpp, since it is used by other TIPs.
//

class CEditSessionBase : public ITfEditSession
{
public:
    CEditSessionBase(ITfContext *pContext);
    virtual ~CEditSessionBase();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfEditSession
    virtual STDMETHODIMP DoEditSession(TfEditCookie ec) = 0;

    HRESULT _SetEditSessionData(UINT m_idEditSession, void *pData, UINT uBytes, LONG_PTR lData1 = 0, LONG_PTR lData2=0, BOOL fBool = FALSE);

    void  _SetRange(ITfRange *pRange) {  m_cpRange = pRange; }
    void  _SetUnk(IUnknown *punk)     { m_cpunk = punk; }

    ITfRange *_GetRange( )   { return m_cpRange; }
    IUnknown *_GetUnk( )     { return m_cpunk; }
    void     *_GetPtrData( ) { return m_pData; }
    LONG_PTR  _GetData1( )   { return m_lData1; }
    LONG_PTR  _GetData2( )   { return m_lData2; }
    BOOL      _GetBool( )    { return m_fBool; }

    LONG_PTR  _GetRetData( ) { return m_lRetData; }
    IUnknown *_GetRetUnknown( )
    { 
        IUnknown *pUnk = NULL;

        pUnk = m_cpRetUnk;

        if ( pUnk )
            pUnk->AddRef( );

        return pUnk;
    }

    UINT                m_idEditSession;
    CComPtr<ITfContext> m_cpic;

    // Keep the return data for this edit session.
    LONG_PTR            m_lRetData;
    CComPtr<IUnknown>   m_cpRetUnk;

private:
    // Data passed by caller to request a edit session.
    void               *m_pData;     // pData pointer to memory.  its size is uByte of bytes.
    LONG_PTR            m_lData1;    // m_lData1 and m_lData2 contain constant data.
    LONG_PTR            m_lData2;    
    BOOL                m_fBool;
    CComPtr<ITfRange>   m_cpRange;
    CComPtr<IUnknown>   m_cpunk;     // keep any COM pointer.

    LONG _cRef;     // COM ref count
};

//
// Edit Session for CSapiIMX.
//
class CSapiEditSession : public CEditSessionBase
{
public:
    CSapiEditSession(CSapiIMX *pimx, ITfContext *pContext);
    virtual ~CSapiEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CSapiIMX           *m_pimx;            
};

//
// Edit Session for CSelectWord:  Selection related commands
//
class CSelWordEditSession : public CSapiEditSession
{
public:
    CSelWordEditSession(CSapiIMX *pimx, CSelectWord *pSelWord, ITfContext *pContext);
    virtual ~CSelWordEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

    void _SetUnk2(IUnknown *cpunk)  { m_cpunk2 = cpunk; };
    IUnknown *_GetUnk2( ) { return m_cpunk2; };

    LONG_PTR _GetLenXXX( )  { return m_ulLenXXX; }
    void  _SetLenXXX( LONG_PTR ulLenXXX ) { m_ulLenXXX = ulLenXXX; }
    
private:

    CComPtr<IUnknown>     m_cpunk2;
    LONG_PTR              m_ulLenXXX;   // the charnum of XXX part for "Select XXX through YYY" command.
    CSelectWord           *m_pSelWord;
};

//
// Edit Session for PlayBack
//
class CPlayBackEditSession : public CEditSessionBase
{
public:
    CPlayBackEditSession(CSapiPlayBack *pPlayBack, ITfContext *pContext);
    virtual ~CPlayBackEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CSapiPlayBack           *m_pPlayBack;            
};


//
// Edit Session for Reconversion
//
class CFnRecvEditSession : public CEditSessionBase
{
public:
    CFnRecvEditSession(CFnReconversion *pFnRecv, ITfRange *pRange, ITfContext *pContext);
    virtual ~CFnRecvEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CFnReconversion           *m_pFnRecv;            
};

//
// Edit Session for CPropStoreRecoResultObject
//
class CPSRecoEditSession : public CEditSessionBase
{
public:
    CPSRecoEditSession(CPropStoreRecoResultObject *pPropStoreReco, ITfRange *pRange, ITfContext *pContext);
    virtual ~CPSRecoEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CPropStoreRecoResultObject   *m_pPropStoreReco;            
};


//
// Edit Session for CPropStoreLMLattice
//
class CPSLMEditSession : public CEditSessionBase
{
public:
    CPSLMEditSession(CPropStoreLMLattice *pPropStoreLM, ITfRange *pRange, ITfContext *pContext);
    virtual ~CPSLMEditSession( );

    STDMETHODIMP DoEditSession(TfEditCookie ec); 

private:
 
    CPropStoreLMLattice           *m_pPropStoreLM;            
};

#endif // EDITSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\editsess.cpp ===
//
//
// Sapilayr Edit Sessions implementation.
//
//
#include "private.h"
#include "sapilayr.h"

//
// CEditSessionBase
//

CEditSessionBase::CEditSessionBase(ITfContext *pContext)
{
    _cRef = 1;
    m_cpic = pContext;
    m_pData = NULL;
    m_lData1 = 0;
    m_lData2 = 0;
    m_fBool  = FALSE;
    m_lRetData = 0;
}
    

CEditSessionBase::~CEditSessionBase()
{
    if (m_pData)
        cicMemFree(m_pData);  
}

// IUnknown
HRESULT CEditSessionBase::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;
     *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession))
    {
        *ppvObj = SAFECAST(this, CEditSessionBase *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEditSessionBase::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CEditSessionBase::Release(void)
{
    LONG cr = --_cRef;

    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//
// Set input data memeber and m_idEditSession.
//
HRESULT CEditSessionBase::_SetEditSessionData(UINT idEditSession, void *pData, UINT uByte, LONG_PTR lData1, LONG_PTR lData2, BOOL fBool)
{
    HRESULT  hr = S_OK;

    if ( uByte )
    {
        m_pData = cicMemAlloc(uByte);

        if ( m_pData )
        {
            if ( pData )
                memcpy(m_pData, pData, uByte);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    if ( hr == S_OK )
    {
        m_idEditSession = idEditSession;
        m_lData1 = lData1;
        m_lData2 = lData2;
        m_fBool  = fBool;
    }

    return hr;
}


//
//  CSapiEditSession
//
//
CSapiEditSession::CSapiEditSession(CSapiIMX *pimx, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pimx = pimx;
    pimx->AddRef( );
}

CSapiEditSession::~CSapiEditSession( ) 
{
    m_pimx->Release( );
}

//
//  Do the real Edit Session handling for CSapiIMX
//
HRESULT CSapiEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pimx);

    switch(m_idEditSession)
    {
        case ESCB_FINALIZECOMP:
            hr = m_pimx->_KillFocusRange(ec, m_cpic, NULL, m_pimx->_GetId( ) );
            break;

        case ESCB_FINALIZE_ALL_COMPS :
            hr = m_pimx->_FinalizeAllCompositions(ec, m_cpic);
            break;

        case ESCB_FEEDBACKUI:

            hr = m_pimx->_AddFeedbackUI(ec, m_pimx->IsFocusFullAware(m_pimx->_tim)
                                            ? DA_COLOR_AWARE : DA_COLOR_UNAWARE,
                                            (LONG)_GetData1( ));

            break;

        case ESCB_KILLFEEDBACKUI:
            hr = m_pimx->_KillFeedbackUI(ec, m_cpic, _GetRange( ));
            break;

        case ESCB_DETECTFEEDBACKUI:
            hr = m_pimx->_DetectFeedbackUI(ec, m_cpic, _GetRange( ));
            break;

        case ESCB_KILLLASTPHRASE:
            hr = m_pimx->_KillLastPhrase(ec, m_cpic);
            break;

        case ESCB_FEEDCURRENTIP:
            hr = m_pimx->_InternalFeedCurrentIPtoSR(ec, m_cpic);
            break;

        case ESCB_PROCESSCONTROLKEY:
            hr = m_pimx->_ProcessControlKeys(ec, m_cpic, (WCHAR *)_GetPtrData( ), (ULONG)_GetData1( ), (LANGID)_GetData2( ));
            break;
        case ESCB_PROCESS_EDIT_COMMAND :
            hr = m_pimx->_ProcessEditCommands(ec, m_cpic, (ULONG)_GetData1( ));
            break;

        case ESCB_PROCESS_SPELL_THAT :
            hr = m_pimx->_ProcessSpellThat(ec, m_cpic);
            break;

        case ESCB_PROCESS_SPELL_IT :
            hr = m_pimx->_ProcessSpellIt(ec, m_cpic, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ));
            break;

        case ESCB_TTS_PLAY :
            hr = m_pimx->_TtsPlay(ec, m_cpic);
            break;

        case ESCB_PROCESS_CAP_COMMANDS :
            if ( m_pimx->GetCapCmdHandler( ))
            {
                CCapCmdHandler  *pCapCmdHandler;

                pCapCmdHandler = m_pimx->GetCapCmdHandler( );
               
                hr = pCapCmdHandler->_ProcessCapCommands(ec, 
                                     m_cpic, 
                                     (CAPCOMMAND_ID)_GetData1( ),
                                     (WCHAR *)_GetPtrData( ), 
                                     (ULONG)_GetData2( )
                                     );

            }

            break;


        case ESCB_SETREPSELECTION:
            // Set the selection which covers the parent phrase range to be replaced by an alternate.
            if (m_cpic && _GetRange( )) 
            {
                // adjust selection based on the length of the alternates and the start position in the parent phrase.
                hr = m_pimx->_SetReplaceSelection(ec, m_cpic, _GetRange( ), (ULONG)_GetData1( ), (ULONG)_GetData2( ));
            }
            break;

        case ESCB_PROCESS_ALTERNATE_TEXT:
            // We have already set the right selection before this function is called.
            hr = m_pimx->_ProcessAlternateText(ec,(WCHAR *)_GetPtrData( ),(LANGID)_GetData1( ), m_cpic, _GetBool( ));
            break;

        case ESCB_RESTORE_CORRECT_ORGIP :
            hr = m_pimx->_RestoreCorrectOrgIP(ec, m_cpic);
            break;

        case ESCB_PROCESSTEXT:
            hr = m_pimx->_ProcessText(ec, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ), m_cpic);

            break;

/*  we don't use this editsession, it is replaced by ESCB_INJECT_SPELL_TEXT
        case ESCB_PROCESSTEXT_NO_OWNERID:
            if (m_cpic) 
            {
                hr = m_pimx->_ProcessTextInternal(ec, 
                           (WCHAR *)_GetPtrData( ), GUID_ATTR_SAPI_INPUT, 
                           (LANGID)_GetData1( ), m_cpic, 
                           FALSE, TRUE);
            }
            break;
*/

        case ESCB_INJECT_SPELL_TEXT :
            hr = m_pimx->_ProcessSpelledText(ec, m_cpic, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ), _GetBool());
            break;

        case ESCB_PROCESS_MODEBIAS_TEXT :
            hr = m_pimx->_ProcessModebiasText(ec, (WCHAR *)_GetPtrData( ), (LANGID)_GetData1( ), m_cpic); 
            break;

        case ESCB_ATTACHRECORESULTOBJ:

            //  m_cpunk contains the pointer to ISpRecoResult object
            hr = m_pimx->_ProcessRecoObject(ec, (ISpRecoResult *)_GetUnk( ), (ULONG)_GetData1( ), (ULONG)_GetData2( ));
            break;

        case ESCB_HANDLESPACES:
            if (_GetRange( ) && m_cpic)
                hr = m_pimx->_ProcessSpaces( ec, 
                                             m_cpic,
                                             _GetRange( ), 
                                             _GetBool( ), 
                                             (ULONG)_GetData2( ), 
                                             (LANGID)_GetData1( ));
            break;
            
        case ESCB_COMPLETE:
            hr = m_pimx->MakeResultString(ec, m_cpic, _GetRange( ), m_pimx->_tid, m_pimx->m_pCSpTask);
            break;

        case ESCB_ABORT:
            hr = m_pimx->AbortString(ec, m_cpic, m_pimx->m_pCSpTask);
            break;

        case ESCB_RECONV_ONIP:
            hr = m_pimx->_CorrectThat(ec, m_cpic);
            break;
            
        case ESCB_UPDATEFILTERSTR:
            hr = m_pimx->_SetFilteringString(ec, (ITfCandidateUI *)_GetUnk( ), m_cpic);
            break;
            
        case ESCB_SYNCMBWITHSEL:
            hr = m_pimx->_SyncModeBiasWithSelectionCallback(ec, m_cpic);
            break;
        
        case ESCB_GETRANGETEXT:

            WCHAR  *pText;
            ULONG  ulSize;
 
            pText = (WCHAR *)_GetPtrData( );
            ulSize = (ULONG)_GetData2( );

            hr =  _GetRange( )->GetText(ec, (ULONG)_GetData1( ), pText, ulSize, (ULONG *)&m_lRetData);
            break;

        case ESCB_ISRANGEEMPTY:
            hr =  _GetRange( )->IsEmpty(ec, (BOOL *)&m_lRetData);
            break;

        case ESCB_HANDLE_ADDDELETE_WORD:
            hr =  m_pimx->_HandleAddDeleteWord(ec, m_cpic);
            break;

        case ESCB_HANDLE_LEARNFROMDOC:
            hr =  m_pimx->_HandleLearnFromDoc(ec, m_cpic, (ITfDocumentMgr *)_GetUnk( ));
            break;

        case ESCB_LEARNDOC_NEXTRANGE:
            hr =  m_pimx->_HandleNextRange(ec, (ULONG)_GetData1( ));
            break;

        case ESCB_HANDLERECOGNITION:
            m_pimx->_HandleRecognition((ISpRecoResult *)_GetUnk( ), m_cpic, ec);
            break; 
            
        case ESCB_HANDLEHYPOTHESIS:
            m_pimx->_HandleHypothesis((ISpRecoResult *)_GetUnk( ), m_cpic, ec);
            break;

        case ESCB_SAVECURIP_ADDDELETEUI:
            hr = m_pimx->_SaveCurIPAndHandleAddDeleteUI(ec, m_cpic);
            break;

        case ESCB_HANDLE_MOUSESINK:

            hr = m_pimx->_HandleMouseSink(ec, (ULONG)_GetData1(), (ULONG)_GetData2(), _GetBool());
            break;

        default:
            Assert(0);
            break;
    }

    return hr;
}


//
//  CSelWordEditSession
//
CSelWordEditSession::CSelWordEditSession(CSapiIMX *pimx, CSelectWord *pSelWord, ITfContext *pContext) : CSapiEditSession(pimx, pContext)
{
    m_pSelWord = pSelWord;
}
    
CSelWordEditSession::~CSelWordEditSession( )
{
}

//
// Real Edit Session handling for Selection related commands.
//
HRESULT CSelWordEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pSelWord);

    switch(m_idEditSession)
    {
        case ESCB_UPDATE_TEXT_BUFFER :
            hr = m_pSelWord->_UpdateTextBuffer(ec, m_cpic, (ISpRecoContext *)_GetUnk(), (ISpRecoGrammar *)_GetUnk2() );
            break;

        case ESCB_PROCESSSELECTWORD :
            hr = m_pSelWord->_HandleSelectWord(ec, m_cpic, (WCHAR *)_GetPtrData( ),(ULONG)_GetData1( ),(SELECTWORD_OPERATION)_GetData2( ), (ULONG)_GetLenXXX( ) );
            break;

        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CPlayBackEditSession
//
//
CPlayBackEditSession::CPlayBackEditSession(CSapiPlayBack *pPlayBack, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pPlayBack = pPlayBack;
    m_pPlayBack->AddRef( );
}
    
CPlayBackEditSession::~CPlayBackEditSession( )
{
    m_pPlayBack->Release( );
}

//
// Real Edit Session handling for PlayBack.
//
HRESULT CPlayBackEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pPlayBack);

    switch(m_idEditSession)
    {
        case ESCB_PLAYBK_PLAYSND:
            return m_pPlayBack->_PlaySound(ec, _GetRange( ) );

        case ESCB_PLAYBK_PLAYSNDSELECTION:
            return m_pPlayBack->_PlaySoundSelection(ec, m_cpic);

        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CFnRecvEditSession
//
CFnRecvEditSession::CFnRecvEditSession(CFnReconversion *pFnRecv, ITfRange *pRange, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pFnRecv = pFnRecv;
    m_pFnRecv->AddRef( );
    _SetRange(pRange);
}
    
CFnRecvEditSession::~CFnRecvEditSession( )
{
    m_pFnRecv->Release( );
}

//
// Real Edit Session for Reconvertion.
//
HRESULT CFnRecvEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pFnRecv);

    switch(m_idEditSession)
    {
        case ESCB_RECONV_QUERYRECONV:
            return m_pFnRecv->_QueryReconversion(ec, m_cpic, _GetRange( ), (ITfRange **)&m_cpRetUnk);

        case ESCB_RECONV_GETRECONV:
            return m_pFnRecv->_GetReconversion(ec, m_cpic, _GetRange( ), (ITfCandidateList **)&m_cpRetUnk, TRUE);

        case ESCB_RECONV_RECONV:
            return m_pFnRecv->_Reconvert(ec, m_cpic, _GetRange( ), (BOOL *)&m_lRetData);

        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CPSRecoEditSession
//
CPSRecoEditSession::CPSRecoEditSession(CPropStoreRecoResultObject *pPropStoreReco, ITfRange *pRange, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pPropStoreReco = pPropStoreReco;
    m_pPropStoreReco->AddRef( );
    _SetRange(pRange);
}
    
CPSRecoEditSession::~CPSRecoEditSession( )
{
    m_pPropStoreReco->Release( );
}

//
// Real Edit Session handling for RecoResult Property Store
//
HRESULT CPSRecoEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pPropStoreReco);

    switch(m_idEditSession)
    {
        case ESCB_PROP_DIVIDE:
            hr = m_pPropStoreReco->_Divide(ec,_GetRange( ),(ITfRange *)_GetUnk( ),(ITfPropertyStore **)&m_cpRetUnk);
            break;

        case ESCB_PROP_SHRINK:
            hr = m_pPropStoreReco->_Shrink(ec,_GetRange( ), (BOOL *)&m_lRetData);
            break;

        case ESCB_PROP_TEXTUPDATE:
            hr = m_pPropStoreReco->_OnTextUpdated(ec, (DWORD)_GetData1( ), _GetRange( ), (BOOL *)&m_lRetData);

            break;
 
        default:
            Assert(0);
            break;
    }

    return hr;
}

//
//  CPSLMEditSession
//
CPSLMEditSession::CPSLMEditSession(CPropStoreLMLattice *pPropStoreLM, ITfRange *pRange, ITfContext *pContext) : CEditSessionBase(pContext)
{
    m_pPropStoreLM = pPropStoreLM;
    m_pPropStoreLM->AddRef( );
    _SetRange(pRange);
}
    
CPSLMEditSession::~CPSLMEditSession( )
{
    m_pPropStoreLM->Release( );
}

// 
// Real edit session for Language Model Property Store.
//
HRESULT CPSLMEditSession::DoEditSession(TfEditCookie ec)
{
    HRESULT hr = S_OK;

    Assert(m_pPropStoreLM);

    switch(m_idEditSession)
    {
        case ESCB_PROP_DIVIDE:
            hr = m_pPropStoreLM->_Divide(ec,_GetRange( ),(ITfRange *)_GetUnk( ), (ITfPropertyStore **)&m_cpRetUnk);
            break;

        default:
            Assert(0);
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\dictctxt.h ===
//
// dictation context class implementation
//
//
#ifndef _DICTCTXT_H_
#define _DICTCTXT_H_

class CDictContext 
{
public:
    CDictContext(ITfContext *pic, ITfRange *pRange);
    ~CDictContext();

    HRESULT InitializeContext(TfEditCookie ecReadOnly);
    HRESULT FeedContextToGrammar(ISpRecoGrammar *pGram);
private:
    CComPtr<ITfContext> m_cpic;
    CComPtr<ITfRange>   m_cpRange;
    WCHAR              *m_pszText;
    ULONG               m_ulStartIP;
    ULONG               m_ulCchToFeed;
    ULONG               m_ulSel;
};

#define CCH_FEED_PREIP    20
#define CCH_FEED_POSTIP   20

#endif //__DICTCTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\dictctxt.cpp ===
//
// class implementation of CDictContext 
//
// [2/15/00] created
//
#include "private.h"
#include "globals.h"
#include "dictctxt.h"

//
// ctor/dtor
//
CDictContext::CDictContext(ITfContext *pic, ITfRange *pRange)
{
    Assert(pic);
    Assert(pRange);
    
    m_cpic      = pic;
    m_cpRange   = pRange;
    m_pszText   = NULL;
    m_ulSel     = m_ulStartIP = m_ulCchToFeed = 0;
}

CDictContext::~CDictContext()
{
    if (m_pszText)
    {
        cicMemFree(m_pszText);
    }
}

//
// InitializeContext
//
// synopsis: Get Text around an IP and setup character positions
//
HRESULT CDictContext::InitializeContext(TfEditCookie ecReadOnly)
{
    CComPtr<ITfRange> cpRangeCloned;
    CComPtr<ITfRange> cpRangeEndSel;

    HRESULT hr = m_cpRange->Clone(&cpRangeEndSel);

    if (S_OK == hr)
    {
        // create a range to hold the position of current selection
        hr = cpRangeEndSel->Collapse(ecReadOnly, TF_ANCHOR_END); 
    }
    
    if (S_OK == hr)
    {
        hr = m_cpRange->Clone(&cpRangeCloned);
    }

    if (S_OK == hr)
    {
        // we don't want to go beyond an embedded object
        // (this is assuming that hc is const, which it should be)
        TF_HALTCOND hc = {0};
        hc.dwFlags = TF_HF_OBJECT;

        ULONG ulcch    = 0;
        
        hr = cpRangeCloned->Collapse(ecReadOnly, TF_ANCHOR_START);
        if (S_OK == hr)
        {
            TF_HALTCOND hc2 = {0};
            hc2.pHaltRange = cpRangeEndSel;
            hc2.aHaltPos   = TF_ANCHOR_END;
            //
            // get the # of characters in selection
            //
            long cch = 0;
            hr = cpRangeCloned->ShiftEnd(ecReadOnly, CCH_FEED_POSTIP, &cch, &hc2);
            if (S_OK == hr)
            {
                m_ulSel = ulcch = cch;
            }
        }

        if (S_OK == hr)
        {
            long cch;

            Assert(ulcch <= CCH_FEED_POSTIP);

            hr = cpRangeCloned->ShiftEnd(ecReadOnly, CCH_FEED_POSTIP-ulcch, &cch, &hc);
            if (S_OK == hr)
            {
                ulcch += cch;
            }
        }
        
        if (S_OK == hr)
        {
            long cch;
            // Get the offset of IP
            hr = cpRangeCloned->ShiftStart(ecReadOnly, -CCH_FEED_PREIP, &cch, &hc);
            if (S_OK == hr)
            {
                m_ulStartIP = -cch;
                ulcch += -cch;
            }
        }
        
        if (S_OK == hr)
        {
            if (m_pszText)
            {
                cicMemFree(m_pszText);
            }
            
            // could make it smarter to alloc mem that is absolutely needed?
            m_pszText = (WCHAR *)cicMemAlloc((ulcch + 1)*sizeof(WCHAR));

            if (!m_pszText)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = cpRangeCloned->GetText(ecReadOnly, 0, m_pszText, ulcch, &ulcch);

                // if we can't get text beyond the IP, it is not worth feeding this context
                if (S_OK != hr || ulcch < m_ulStartIP)
                {
                    m_ulCchToFeed = 0;
                    hr = E_FAIL;
                }
                else
                {
                    m_ulCchToFeed = ulcch;
                }
            }
        }
    }
    return hr;
}


//
// FeedContextToGrammar
//
// synopsis: feed this IP context to the given grammar
//
HRESULT CDictContext::FeedContextToGrammar(ISpRecoGrammar *pGram)
{
    HRESULT hr = E_FAIL;
    Assert(pGram);
    
    SPTEXTSELECTIONINFO tsi = {0};

    tsi.ulStartActiveOffset  = 0;
    tsi.cchActiveChars = m_ulCchToFeed;
    tsi.ulStartSelection = m_ulStartIP;
    tsi.cchSelection     = m_ulSel; 

    WCHAR *pMemText = (WCHAR *)cicMemAlloc((m_ulCchToFeed+2)*sizeof(WCHAR));

    if (pMemText)
    {
        if (m_ulCchToFeed > 0 && m_pszText)
            wcsncpy(pMemText, m_pszText, m_ulCchToFeed);

        pMemText[m_ulCchToFeed] = L'\0';
        pMemText[m_ulCchToFeed+1] = L'\0';
#ifdef DEBUG
        {
            TraceMsg(TF_GENERAL, "For SetWordSequenceData: Text=\"%S\" cchActiveChars=%d tsi.ulStartSelection=%d, cchSelection=%d",pMemText,tsi.cchActiveChars, tsi.ulStartSelection, tsi.cchSelection);
        }
#endif
        hr = pGram->SetWordSequenceData(pMemText, m_ulCchToFeed + 2, &tsi);

/*  According to billro, the below code is not necessary.

#ifdef DEBUG
            {
                TraceMsg(TF_GENERAL, "For SetTextSelection: tsi.ulStartSelection = %d",tsi.ulStartSelection);
            }
#endif

            // so Fil told me we need to call SetTextSelection again
            if (S_OK == hr)
                hr = pGram->SetTextSelection(&tsi);
*/

        cicMemFree(pMemText);
    }
    
    return  hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\fnrecon.cpp ===
//
// reconv.cpp
//

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "fnrecon.h"
#include "immxutil.h"
#include "candlist.h"
#include "propstor.h"
#include "catutil.h"
#include "osver.h"
#include "mui.h"
#include "tsattrs.h"
#include "cregkey.h"
#include <htmlhelp.h>
#include "TabletTip_i.c"
#include "spgrmr.h"

HRESULT   HandlePhraseElement( CSpDynamicString *pDstr, const WCHAR  *pwszTextThis, BYTE  bAttrThis, BYTE bAttrPrev, ULONG  *pulOffsetThis);

//////////////////////////////////////////////////////////////////////////////
//
// CSapiAlternativeList
//
//////////////////////////////////////////////////////////////////////////////

// ctor/dtor
CSapiAlternativeList::CSapiAlternativeList(LANGID langid, ITfRange *pRange, ULONG  ulMaxCandChars)
{
    m_nItem = 0;
    m_ulStart = 0;
    m_ulcElem = 0;
    m_cAlt = 0;
    m_ppAlt = NULL;
    m_langid = langid;
    m_cpRange = pRange;
    m_fFirstAltInCandidate = FALSE;
    m_fNoAlternate = FALSE;
    m_iFakeAlternate = NO_FAKEALT;
    m_MaxCandChars = ulMaxCandChars;
    m_ulIndexSelect = 0;
}

CSapiAlternativeList::~CSapiAlternativeList()
{
    UINT i;
    for (i = 0; i < m_cAlt; i++)
    {
        if (NULL != m_ppAlt[i])
        {
            m_ppAlt[i]->Release();
        }
    }
    if (m_prgLMAlternates)
    {
        int nItem = m_prgLMAlternates->Count();
        for (i = 0; i < (UINT)nItem; i++)
        {
           CLMAlternates *plmalt = m_prgLMAlternates->Get(i);

           if (plmalt)
               delete plmalt;
       }
       delete m_prgLMAlternates;
   }
   if (m_ppAlt)
       cicMemFree(m_ppAlt);
       
   if (m_rgElemUsed.Count())
   {
       for ( i=0; i<(UINT)m_rgElemUsed.Count(); i++)
       {
           SPELEMENTUSED *pElemUsed;

           pElemUsed = m_rgElemUsed.GetPtr(i);

           if ( pElemUsed && pElemUsed->pwszAltText)
           {
               cicMemFree(pElemUsed->pwszAltText);
               pElemUsed->pwszAltText = NULL;
           }
       }
       m_rgElemUsed.Clear();
   }

}

//
//  AddLMAlternates
//
HRESULT CSapiAlternativeList::AddLMAlternates(CLMAlternates *pLMAlt)
{
    HRESULT hr = E_FAIL;
    BOOL fFoundADup = FALSE;
    if (!pLMAlt)
        return E_INVALIDARG;

    if (!m_prgLMAlternates)
    {
        m_prgLMAlternates =  new CPtrArray<CLMAlternates>;
    }

    if (m_prgLMAlternates)
    {
        int iIdx = m_prgLMAlternates->Count();
        
        // need to find a dup
        for (int i = 0; i < iIdx && !fFoundADup ; i++)
        {
            CLMAlternates *plma = m_prgLMAlternates->Get(i);
            if (plma)
            {
                WCHAR *pszStored = new WCHAR[plma->GetLen()+1];
                WCHAR *pszAdding = new WCHAR[pLMAlt->GetLen()+1];
                
                if (pszStored && pszAdding)
                {

                    plma->GetString(pszStored, plma->GetLen()+1);
                    pLMAlt->GetString(pszAdding, pLMAlt->GetLen()+1);

                    if (!wcscmp(pszAdding, pszStored))
                    {
                        fFoundADup = TRUE;
                    }
                }

                if (pszStored) 
                    delete[] pszStored;

                if (pszAdding) 
                    delete[] pszAdding;
            }
        }
    
        if (!fFoundADup && pLMAlt)
        {
            if (!m_prgLMAlternates->Insert(iIdx, 1))
                return E_OUTOFMEMORY;

            m_prgLMAlternates->Set(iIdx, pLMAlt);
            hr = S_OK;
        }
    }
    return hr;
}

// SetPhraseAlt
//
// synopsis: receive an alternates list as a param and copy the alternates
//           to the array which this class internally maintains.
//           Additionally, a pointer to the reco result wrapper
//           is maintained per CSapiAlternativeList class instance.
//
// params    pResWrap - a pointer to the wrapper object
//           ppAlt - a pointer to the array of phrases that the callar has alloced
//           cAlt - is passed in with the # of real SAPI alternates
//           ulStart - index to the start element in the parent phrase
//           culElem - # of minimum elements used (will get replaced) in the parent phrase.
//
HRESULT CSapiAlternativeList::SetPhraseAlt(CRecoResultWrap *pResWrap, ISpPhraseAlt **ppAlt, ULONG cAlt, ULONG ulStart, ULONG ulcElem, WCHAR *pwszParent)
{
    // setup the info for used elements in parent phrase
    // these are useful for the 0 index (ITN) alternate

    HRESULT  hr = S_OK;
    SPPHRASE *pParentPhrase = NULL;
    CSpDynamicString dstr;

    if ( !pResWrap || !ppAlt || !pwszParent )
        return E_INVALIDARG;

    m_ulStart = ulStart;
    m_ulcElem = ulcElem;



    m_fFirstAltInCandidate = FALSE;  
    m_fNoAlternate = FALSE;
    m_iFakeAlternate = NO_FAKEALT;
    
    // alloc the struct for the used element info
    m_rgElemUsed.Append(cAlt);

    for ( int i=0; i<m_rgElemUsed.Count( ); i++)
    {
        SPELEMENTUSED *pElemUsed;
        if ( pElemUsed = m_rgElemUsed.GetPtr(i))
        {
            pElemUsed->pwszAltText = NULL;
        }
    }

    // comptr releases on the previous object
    // at this indirection
    //
    Assert(pResWrap);
    
    m_cpwrp = pResWrap;
    
    if (m_ppAlt)
    {
        for (UINT i = 0; i < m_cAlt; i++)
        {
            if (NULL != m_ppAlt[i])
            {
                m_ppAlt[i]->Release();
            }
        }
        cicMemFree(m_ppAlt);
        m_ppAlt = NULL;
    }

    m_ppAlt = (ISpPhraseAlt **)cicMemAlloc(sizeof(*ppAlt)*cAlt);
    if (!m_ppAlt)
        return E_OUTOFMEMORY;
    
    Assert(ppAlt);

#ifdef DONTUSE

    // Get the current select text in parent phrase.
    CComPtr<IServiceProvider> cpServicePrv;
    CComPtr<ISpRecoResult>    cpResult;

    hr = m_cpwrp->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);

    if ( S_OK == hr )
        hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);

    if (S_OK == hr)
    {
        CSpDynamicString dstrReplace;

        cpResult->GetPhrase(&pParentPhrase);
 
        for (ULONG i = m_ulStart; i < m_ulStart + m_ulcElem; i++ )
        {
            BOOL      fInsideITN;
            ULONG     ulITNStart, ulITNNumElem;
               
            fInsideITN = m_cpwrp->_CheckITNForElement(pParentPhrase, i, &ulITNStart, &ulITNNumElem, (CSpDynamicString *)&dstrReplace);

            if ( fInsideITN )
            {
                // This element is inside an ITN range.
                if ( i == (ulITNStart + ulITNNumElem - 1) )
                {
                    // This is the last element of the new ITN.
                    // we need to add the replace text to the dstr string 
                    // so that next non-ITN element will get correct offset.

                    dstr.Append( (WCHAR *)dstrReplace );
                }
            }
            else
            {
                if (pParentPhrase->pElements[i].pszDisplayText)
                {
                    const WCHAR   *pwszTextThis;
                    BYTE           bAttrThis = 0;
                    BYTE           bAttrPrev = 0;

                    pwszTextThis = pParentPhrase->pElements[i].pszDisplayText;
                    bAttrThis = pParentPhrase->pElements[i].bDisplayAttributes;

                    if ( i > m_ulStart )
                        bAttrPrev = pParentPhrase->pElements[i-1].bDisplayAttributes;

                    HandlePhraseElement( (CSpDynamicString *)&dstr, pwszTextThis, bAttrThis, bAttrPrev,NULL);
                }
            }
        } // for 

        pwszParent = (WCHAR *)dstr;

        if (pParentPhrase)
            CoTaskMemFree(pParentPhrase); 
    }
#endif
            
    UINT j=0;

    if ( pwszParent )
    {
        ULONG     ulRecoWrpStart, ulRecoWrpNumElements;
        WCHAR    *pwszFakeAlt = NULL;  // This is for Capitalized string for parent phrase.

        if ( iswalpha(pwszParent[0]) )
        {
            int   iStrLen = wcslen(pwszParent); 
            
            pwszFakeAlt = (WCHAR *)cicMemAlloc((iStrLen+1) * sizeof(WCHAR));

            if ( pwszFakeAlt )
            {
                WCHAR  wch;

                wch = pwszParent[0];
                StringCchCopyW(pwszFakeAlt, iStrLen+1,  pwszParent);

                if ( iswlower(wch) )
                    pwszFakeAlt[0] = towupper(wch);
                else
                    pwszFakeAlt[0] = towlower(wch);

                int iLen = wcslen(pwszFakeAlt);

                if ( (iLen > 0) &&  (pwszFakeAlt[iLen-1] < 0x20) )
                    pwszFakeAlt[iLen-1] = L'\0';
            }
        }

        ulRecoWrpStart = pResWrap->GetStart( );
        ulRecoWrpNumElements = pResWrap->GetNumElements( );

        ULONG     ValidParentStart, ValidParentEnd;   // Point to the valid parent element range which could be matched by 
                                                      // the alternative phrase.

        int       ShiftDelta = 2;     // We just want to shift the valid parent element range by ShiftDelta elements from current
                                      // start and end element in parent phrase.

                                      // ie,  ulStart - 3,  ulEnd + 3,   if they are in the valid range of the reco wrapper.   

        ValidParentStart = ulRecoWrpStart;
        if ( ((int)ulStart - ShiftDelta) > (int)ulRecoWrpStart )
            ValidParentStart = ulStart - ShiftDelta;

        ValidParentEnd = ulRecoWrpStart + ulRecoWrpNumElements  - 1;
        if ( ((int)ulStart + (int)ulcElem -1 + ShiftDelta) < (int)ValidParentEnd )
            ValidParentEnd = ulStart + ulcElem - 1 + ShiftDelta;

        CComPtr<ISpRecoResult>    cpResult;
        pResWrap->GetResult(&cpResult);
        cpResult->GetPhrase(&pParentPhrase);

        for (UINT i = 0; (i < cAlt) && (j < cAlt) && *ppAlt; i++, ppAlt++)
        {
            SPPHRASE *pPhrases = NULL;
            ULONG     ulcElements = 0;
            ULONG     ulParentStart     = 0;
            ULONG     ulcParentElements  = 0;
            ULONG     ulLeadSpaceRemoved = 0;

            // Assume the first alt phrase is exactly same as the parent phrase.
            // practically it is true so far.
            // if it is not true in the future, we may need to change logical here!!!

            (*ppAlt)->GetPhrase(&pPhrases);
            (*ppAlt)->GetAltInfo(NULL, &ulParentStart, &ulcParentElements, &ulcElements);

            if ( (ulParentStart >= ValidParentStart) && ( ulParentStart+ulcParentElements -1 <= ValidParentEnd) )
            {
                WCHAR *pwszAlt = (WCHAR *)cicMemAllocClear((m_MaxCandChars+1)*sizeof(WCHAR));

                if ( !pwszAlt )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                BOOL    fAddToCandidateList = FALSE;
                BOOL    fControlCharsInAltPhrase = FALSE;

                // Add code to skip start and end elements which are the same as parent phrase's elements.
                UINT    ulSkipStartWords = 0;
                UINT    ulSkipEndWords = 0;

                for (UINT k = ulParentStart; k < ulStart; k++)
                {
                    if (_wcsicmp(pPhrases->pElements[k].pszDisplayText, pParentPhrase->pElements[k].pszDisplayText) == 0)
                    {
                        // Matching pre-word in alternate. This is redundant.
                        ulSkipStartWords ++;
                    }
                    else
                    {
                        // Do not match. Stop processing.
                        break;
                    }
                }

                for (UINT k = ulParentStart + ulcParentElements - 1; k >= ulStart + ulcElem ; k--)
                {
                    // Count backwards in alternate phrase.
                    UINT l = ulParentStart + ulcElements - ((ulParentStart + ulcParentElements) - k);
                    if (_wcsicmp(pPhrases->pElements[l].pszDisplayText, pParentPhrase->pElements[k].pszDisplayText) == 0)
                    {
                        ulSkipEndWords ++;
                    }
                    else
                    {
                        // Do not match. Stop processing.
                        break;
                    }
                }

                ulParentStart += ulSkipStartWords;
                ulcElements -= ulSkipStartWords + ulSkipEndWords;
                ulcParentElements -= ulSkipStartWords + ulSkipEndWords;

                hr = GetAlternativeText(*ppAlt, pPhrases, (i ==0 ? TRUE : FALSE), ulParentStart, ulcElements, pwszAlt, m_MaxCandChars, &ulLeadSpaceRemoved);

                if ( S_OK == hr )
                {
                    for ( ULONG iIndex =0; iIndex < wcslen(pwszAlt); iIndex++ )
                    {
                        if ( pwszAlt[iIndex] < 0x20 )
                        {
                            fControlCharsInAltPhrase = TRUE;
                            break;
                        }
                    }
                }

                BOOL   fNotDupAlt = TRUE;
                
                if ( S_OK == hr && pwszAlt )
                {
                    fNotDupAlt = _wcsicmp(pwszAlt, pwszParent);
                    if ( fNotDupAlt && (j>0) )
                    {
                        SPELEMENTUSED *pElemUsed;

                        for (UINT x=0; x<j; x++ )
                        {
                            if ( pElemUsed = m_rgElemUsed.GetPtr(x))
                                fNotDupAlt = _wcsicmp(pwszAlt, pElemUsed->pwszAltText);

                            if ( !fNotDupAlt )
                                break;
                        }
                    }
                }

                if ((S_OK == hr) && !fControlCharsInAltPhrase && (pwszAlt[0] != L'\0') && fNotDupAlt)
                {
                    // This is different item from the parent, it should be inserted to the canidate list.
                    // initialize the AltCached item

                    if ( (i > 0) || (pResWrap->_RangeHasITN(ulParentStart, ulcParentElements) > 0 ) )
                    {

                        SPELEMENTUSED *pElemUsed;
                        if ( pElemUsed = m_rgElemUsed.GetPtr(j))
                        {
                            pElemUsed->ulParentStart = ulParentStart;
                            pElemUsed->ulcParentElements = ulcParentElements;
                            pElemUsed->ulcElements = ulcElements;
                            pElemUsed->pwszAltText = pwszAlt;
                            pElemUsed->ulLeadSpaceRemoved = ulLeadSpaceRemoved;

                            m_ppAlt[j] = *ppAlt;
                            m_ppAlt[j]->AddRef();
                            j ++;

                            if ( i == 0 )
                            {
                                // The first Alt phrase is also in the canidate list. the selectedd range must contain ITN.
                                m_fFirstAltInCandidate = TRUE;
                            }

                            fAddToCandidateList = TRUE;
                        }
                    }
                }

                if ( fAddToCandidateList == FALSE )
                {
                    // Same string. or GetAlternativeText returns Error.
                    // don't insert it into the candidate list.

                    // Release the alloced memory 
                    cicMemFree(pwszAlt);
                }

                // Handle Faked Alternate
                if ((i == 0) && (pwszFakeAlt != NULL))
                {
                    // This is the parent phrase, Only the first character is capitalized.
                    SPELEMENTUSED *pElemUsed;
                    if ( pElemUsed = m_rgElemUsed.GetPtr(j))
                    {
                        pElemUsed->ulParentStart = ulParentStart;
                        pElemUsed->ulcParentElements = ulcParentElements;
                        pElemUsed->ulcElements = ulcElements;
                        pElemUsed->pwszAltText = pwszFakeAlt;
                        pElemUsed->ulLeadSpaceRemoved = 0;

                        m_iFakeAlternate = j;
                                        
                        m_ppAlt[j] = *ppAlt;
                        m_ppAlt[j]->AddRef();
                        j ++;
                    }
                }
            }

            if (pPhrases)
                 CoTaskMemFree( pPhrases ); 
        }

        if (pParentPhrase)
        {
            CoTaskMemFree(pParentPhrase); 
        }

        if ( pwszFakeAlt && (m_iFakeAlternate == NO_FAKEALT) )
            cicMemFree(pwszFakeAlt);
    }

    m_cAlt = j;

    if ( S_OK == hr )
    {
        if ( m_cAlt == 0 )
        {
            // There is no available Alternate.
            // Just show string "No Alternate" in the candidate window.
            m_fNoAlternate = TRUE;

            SPELEMENTUSED *pElemUsed;
            WCHAR  *pwszNoAlt=(WCHAR *)cicMemAllocClear(m_MaxCandChars*sizeof(WCHAR));

            if ( (pElemUsed = m_rgElemUsed.GetPtr(0)) && pwszNoAlt )
            {
                pElemUsed->ulParentStart = m_ulStart;
                pElemUsed->ulcParentElements = m_ulcElem;
                pElemUsed->ulcElements = m_ulcElem;
                pElemUsed->ulLeadSpaceRemoved = 0;

                CicLoadStringWrapW(g_hInst, IDS_NO_ALTERNATE, pwszNoAlt, m_MaxCandChars);

                pElemUsed->pwszAltText = pwszNoAlt;

                CComPtr<IServiceProvider> cpServicePrv;
                CComPtr<ISpRecoResult>    cpResult;

                hr = m_cpwrp->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
    
                if ( S_OK == hr )
                    hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);

                if ( (hr == S_OK) && cpResult ) 
                {
                    m_ppAlt[0] = (ISpPhraseAlt *)(ISpRecoResult *)cpResult;
                    m_ppAlt[0]->AddRef();
                }

                m_cAlt = 1;
            }
        }
    }
    else
    {
        // Release all the allocated memeory and AltCached Items in this function.
        UINT i;
        if (m_ppAlt)
        {
            for (i = 0; i < m_cAlt; i++)
            {
                m_ppAlt[i]->Release();
                m_ppAlt[i] = NULL;
            }
            cicMemFree(m_ppAlt);
            m_ppAlt = NULL;
        }
       
        if (m_rgElemUsed.Count())
        {
            for ( i=0; i<(UINT)m_rgElemUsed.Count(); i++)
            {
                SPELEMENTUSED *pElemUsed;

                pElemUsed = m_rgElemUsed.GetPtr(i);

                if ( pElemUsed && pElemUsed->pwszAltText)
                {
                    cicMemFree(pElemUsed->pwszAltText);
                    pElemUsed->pwszAltText = NULL;
                }
            }

            m_rgElemUsed.Clear();
        }

        m_cAlt = 0;
    }

    return hr;
}

//    GetNumItem
//
//
int CSapiAlternativeList::GetNumItem(void)
{
    if (!m_nItem)
        m_nItem = m_cAlt;
        
    if ( m_prgLMAlternates )
    {
        return m_nItem + m_prgLMAlternates->Count();
    }
    else
        return m_nItem;
}


HRESULT CSapiAlternativeList::_ProcessTrailingSpaces(SPPHRASE *pPhrases, ULONG  ulNextElem, WCHAR *pwszAlt)
{
    HRESULT  hr = S_OK;
    ULONG    ulSize;
    BOOL     fRemoveTrail;

    if ( !pwszAlt || !pPhrases)
        return E_INVALIDARG;

    if ( ulNextElem >= pPhrases->Rule.ulCountOfElements)
    {
        // NextElement is not a valid element
        return hr;
    }

    if ( pPhrases->pElements[ulNextElem].bDisplayAttributes & SPAF_CONSUME_LEADING_SPACES )
        fRemoveTrail = TRUE;
    else
        fRemoveTrail = FALSE;

    if ( !fRemoveTrail )
        return hr;

    ulSize = wcslen(pwszAlt);

    for ( ULONG i=ulSize; i>0; i-- )
    {
        if ( (pwszAlt[i-1] != L' ') && (pwszAlt[i-1] != L'\t') )
            break;

        pwszAlt[i-1] = L'\0';
    }

    return hr;
}

HRESULT CSapiAlternativeList::GetAlternativeText(ISpPhraseAlt *pAlt,SPPHRASE *pPhrases, BOOL  fFirstAlt, ULONG  ulStartElem, ULONG ulNumElems, WCHAR *pwszAlt, int cchAlt, ULONG *pulLeadSpaceRemoved)
{
    HRESULT hr = S_OK;
    CSpDynamicString sds;
    ULONG   ulLeadSpaceRemoved = 0;

    if ( !pPhrases  || !pwszAlt || !cchAlt || !pulLeadSpaceRemoved)
        return E_INVALIDARG;

    if ( !pAlt )
        return E_INVALIDARG;

    // We assume the first phrase in the AltPhrase list is exactly same as the parent phrase.
    // Specially handle it when it contains ITN.

    if ((m_cpwrp->m_ulNumOfITN > 0) && fFirstAlt)
    {
        // the ITN is always index 0
        //
        CSpDynamicString dstr;
        //
        // this seems confusing but fITNShown indicates whether the ITN
        // is displayed on the doc. 

        // We no longer use fITNShown to inidicates the ITN show state.
        // Because there are may be more  ITNs in one phrase, and every ITN may have 
        // different show state on the doc.
        // Now we use an ITNSHOWSTATE list to keep the display state for individual ITN.

        // So we have to include non-ITN in the alternates if the ITN is on the doc,
        // and include the ITN  in the alternates if the non-ITN is on the doc.
        //
                
        ULONG ulRepCount = 0;

        if (pPhrases->Rule.ulCountOfElements > 0)
        {
            for (UINT i = 0; i < pPhrases->Rule.ulCountOfElements; i++ )
            {
                if (i >= ulStartElem && i < ulStartElem + ulNumElems)
                {
                    ULONG  ulITNStart, ulITNNumElem;
                    BOOL   fITNShown = FALSE;
                    BOOL   fInsideITN = FALSE;

                    // Check to see if this element is inside an ITN,
                    // and if this ITN is shown up in the current Doc.

                    for ( ulRepCount=0; ulRepCount<pPhrases->cReplacements; ulRepCount++)
                    {

                        ulITNStart = pPhrases->pReplacements[ulRepCount].ulFirstElement;
                        ulITNNumElem = pPhrases->pReplacements[ulRepCount].ulCountOfElements;
    
                        if ( (i == ulITNStart) && ((i + ulITNNumElem) <= pPhrases->Rule.ulCountOfElements))
                        {
                            // This element is in an ITN.

                            fInsideITN = TRUE;

                            // check if this ITN is shown as ITN in current DOC

                            for ( ULONG iIndex=0; iIndex < m_cpwrp->m_ulNumOfITN; iIndex ++ )
                            {
                                SPITNSHOWSTATE  *pITNShowState;

                                pITNShowState = m_cpwrp->m_rgITNShowState.GetPtr(iIndex);
                                if ( pITNShowState )
                                {
                                    if ( (pITNShowState->ulITNStart == ulITNStart)
                                        && (pITNShowState->ulITNNumElem == ulITNNumElem) )
                                    {
                                        fITNShown = pITNShowState->fITNShown;
                                        break;
                                    }
                                }
                            }

                            break;
                        }
                    }

                    // use ITN version for an alternate when it is not shown in the parent
                    BOOL fUseITN = fInsideITN && !fITNShown;
                            
                    if ( fUseITN && (ulRepCount < pPhrases->cReplacements) )
                    {
                        sds.Append(pPhrases->pReplacements[ulRepCount].pszReplacementText);
                        i += pPhrases->pReplacements[ulRepCount].ulCountOfElements - 1;

                        if (pPhrases->pReplacements[ulRepCount].bDisplayAttributes & SPAF_ONE_TRAILING_SPACE)
                        {
                            sds.Append(L" ");
                        }
                        else if (pPhrases->pReplacements[ulRepCount].bDisplayAttributes & SPAF_TWO_TRAILING_SPACES)
                        {
                            sds.Append(L"  ");
                        }
  
                    }
                    else
                    {
                        const WCHAR   *pwszTextThis;
                        BYTE           bAttrThis = 0;
                        BYTE           bAttrPrev = 0;

                        pwszTextThis = pPhrases->pElements[i].pszDisplayText;
                        bAttrThis = pPhrases->pElements[i].bDisplayAttributes;

                        if ( i > m_ulStart )
                            bAttrPrev = pPhrases->pElements[i-1].bDisplayAttributes;

                        HandlePhraseElement( (CSpDynamicString *)&sds, pwszTextThis, bAttrThis, bAttrPrev,NULL);
                    }
                }
            }
        }
    }
    else
    {
        // This is not the first Altphrase.
        // Or even if it is the first Altphrase, but there is no ITN in this phrase
        ULONG     ulcElements = 0;
        ULONG     ulParentStart     = 0;
        ULONG     ulcParentElements  = 0;

        if (pPhrases->Rule.ulCountOfElements > 0)
        {
            //
            // If the start element is not the first element in parent phrase, 
            // and it has SPAF_CONSUME_LEADING_SPACES attr in parent phrase,
            // but this start element doesn't have SPAF_CONSUME_LEADING_SPACES in
            // the alternate phrase, 
            // in this case, we need to add leading space in this alternate text.
            // the number of spaces can be found from previous element's attribute,
            // or the replacement's attribute if the previous phrase is displayed with
            // replacement text.
            // 
            // Example here, if you dictate: "this is a test, this is good example."
            //
            // element test has one trail space.
            // element "," has SPAF_CONSUME_LEADING_SPACES.
            //
            // When you select "," to get alternate, the alternate could be "of,", "to,"
            // in the alternate phrase, the start element doesn't have SPAF_CONSUME_LEADING_SPACES
            // attr. in this case, the alternate text needs to add one space, so the text would be " of,"
            // " to,". otherwise, when user selects this alternate, the new text would be like
            // "this is a testof,....".  ( there is no space between test and of ).
            //

            if ( ulStartElem > m_cpwrp->GetStart( ) )
            {
                BYTE  bAttrParent, bAttrPrevParent;
                BYTE  bAttrAlternate;
                ULONG ulPrevSpace = 0;
                
                bAttrParent = m_cpwrp->_GetElementDispAttribute(ulStartElem);
                bAttrPrevParent = m_cpwrp->_GetElementDispAttribute(ulStartElem - 1);

                bAttrAlternate = pPhrases->pElements[ulStartElem].bDisplayAttributes;

                if ( bAttrPrevParent & SPAF_ONE_TRAILING_SPACE )
                    ulPrevSpace = 1;
                else if ( bAttrPrevParent & SPAF_TWO_TRAILING_SPACES )
                    ulPrevSpace = 2;

                if ( (bAttrParent & SPAF_CONSUME_LEADING_SPACES)  &&
                     !(bAttrAlternate & SPAF_CONSUME_LEADING_SPACES) &&
                     ulPrevSpace > 0)
                {
                    // Add the required spaces for the previous element
                    // which was removed before when parent phrase showed up.
                    sds.Append( (ulPrevSpace == 1 ? L" " :  L"  ") );
                }

                if ( !(bAttrParent & SPAF_CONSUME_LEADING_SPACES) &&
                     (bAttrAlternate & SPAF_CONSUME_LEADING_SPACES) &&
                     ulPrevSpace > 0 )
                {
                    // the previous element's trailing space needs to be
                    // removed if it is selected.
                    ulLeadSpaceRemoved = ulPrevSpace;
                }
            }
/*
// This code block tries to get Non-ITN form text for the alternate.
// Yakima engine changed design to require ITN form text must be shown up in 
// candidate window.
//
// So this part of code is replaced by the below code block.
//
            for (UINT i = 0; i < pPhrases->Rule.ulCountOfElements; i++ )
            {
                if (i >= ulStartElem && i < ulStartElem + ulNumElems)
                {
                    const WCHAR   *pwszTextThis;
                    BYTE           bAttrThis = 0;
                    BYTE           bAttrPrev = 0;

                    pwszTextThis = pPhrases->pElements[i].pszDisplayText;
                    bAttrThis = pPhrases->pElements[i].bDisplayAttributes;

                    if ( i > ulParentStart )
                        bAttrPrev = pPhrases->pElements[i-1].bDisplayAttributes;

                    HandlePhraseElement( (CSpDynamicString *)&sds, pwszTextThis, bAttrThis, bAttrPrev,NULL);
                }
            }
*/
            BYTE                bAttr = 0;
            CSpDynamicString    sdsAltText;

            if ( pAlt->GetText(ulStartElem, ulNumElems, TRUE, &sdsAltText, &bAttr) == S_OK )
            {
                if (bAttr & SPAF_ONE_TRAILING_SPACE)
                {
                    sdsAltText.Append(L" ");
                }
                else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                {
                    sdsAltText.Append(L"  ");
                }
            }

            if ( sdsAltText )
                sds.Append(sdsAltText);
        }
    }

    if (sds)
    {
        _ProcessTrailingSpaces(pPhrases, ulStartElem + ulNumElems, (WCHAR *)sds);

        int    TextLen;

        TextLen = wcslen( (WCHAR *)sds);        
        if (TextLen > cchAlt )
        {
            // There is not enough buffer to hold this alternate text.
            // Set the first element as NULL to indicate this situation.
            pwszAlt[0] = L'\0';
        }
        else
        {
            // The passed buffer can hold all the alternate text.
            wcsncpy(pwszAlt, sds, TextLen);
            pwszAlt[TextLen] = L'\0';
        }
    }

    if ( pulLeadSpaceRemoved )
        *pulLeadSpaceRemoved = ulLeadSpaceRemoved;

    return hr;
}

HRESULT CSapiAlternativeList::GetProbability(int nId, int * pnPrb)
{
    HRESULT hr = E_INVALIDARG;
    //
    // bogus for now
    //
    if(pnPrb && nId >= 0)
    {
        if ( nId < m_nItem)
        {
            *pnPrb = 10 - nId;
        }
        else if ( m_prgLMAlternates 
               && (nId - m_nItem) < m_prgLMAlternates->Count())
        {
            // we'll be able to get something from LM
            // but not normalized for now anyway
            *pnPrb = 1;
        }
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CSapiAlternativeList::GetCachedAltInfo
(
    ULONG nId,
    ULONG *pulParentStart, 
    ULONG *pulcParentElements, 
    ULONG *pulcElements,
    WCHAR **ppwszText,
    ULONG *pulLeadSpaceRemoved
)
{
    if (nId < m_cAlt)
    {
        SPELEMENTUSED *pElemUsed;
        if ( pElemUsed = m_rgElemUsed.GetPtr(nId))
        {
            if (pulParentStart) 
                *pulParentStart = pElemUsed->ulParentStart;
            if (pulcParentElements) 
                *pulcParentElements = pElemUsed->ulcParentElements;
            if (pulcElements)
                *pulcElements = pElemUsed->ulcElements;
            if ( ppwszText)
                *ppwszText = pElemUsed->pwszAltText;
            if (pulLeadSpaceRemoved )
                *pulLeadSpaceRemoved = pElemUsed->ulLeadSpaceRemoved;
        }
    }
    
    return S_OK;
}

void CSapiAlternativeList::_Commit(ULONG nIdx, ISpRecoResult *pRecoResult)
{

    if ((m_iFakeAlternate != NO_FAKEALT) && (m_iFakeAlternate == (int)nIdx))
    {
        // This is for Faked Alternate.
        // Don't change any thing.
        // just return here.

        return;
    }

    if (m_cpwrp->m_ulNumOfITN > 0)
    {
        // if we now have the ITN shown as the recognized text, it's swapped with non-ITN
        // if we have non-ITN shown as the recognized text, it's swapped with the ITN

        // We should change the show state only for the replaced range, 
        // ( not for all the phrase if uses doesn't select the whole phrase.

        if ((nIdx == 0)  && _IsFirstAltInCandidate() )
        {
            // the ITN alternate has been chosen.
            //

            // we need to invert the show state for all the ITN inside the selection range.

            m_cpwrp->_InvertITNShowStateForRange(m_ulStart, m_ulcElem);

            // we don't have to commit this to SR engine but
            // we need to recalculate the character offsets for 
            // SR elements using the current pharse (set NULL)
            //
            m_cpwrp->_SetElementOffsetCch(NULL);
            return;
        }
    }
    
    // if a non-SR candidate (such as LM's) is chosen, 
    // nIdx would be >= m_cAlt and we don't have to 
    // tell SR about that.
    if(nIdx < m_cAlt)
    {

        // Need to update the real ITN show state list 
        // and then save the real text and get the offset for 
        // all the elements.

        HRESULT hr = m_cpwrp->_UpdateStateWithAltPhrase(m_ppAlt[nIdx]); 

        if ( S_OK == hr )
        {
      
            // Offset value should be based on ITN display status.
            // revise character offsets using the alternate phrase
            m_cpwrp->_SetElementOffsetCch(m_ppAlt[nIdx]);
        }

        if (S_OK == hr)
        {
            hr = m_ppAlt[nIdx]->Commit();
        }

        // we need to invalidate the result object too
        if (S_OK == hr)
        {
            hr = m_cpwrp->Init(pRecoResult);
        } 
    }
}

//+---------------------------------------------------------------------------
//
//    _GetUIFont()
//
//    synopsis: get appropriate logfont based on 
//              the current langid assigned to the alternativelist
//
//    return : TRUE if there's a specific logfont to the langid
//             FALSE if no logfont data is available for the langid
//
//+---------------------------------------------------------------------------
BOOL CSapiAlternativeList::_GetUIFont(BOOL  fVerticalWriting, LOGFONTW *plf)
{
    // other languages will follow later
    //
    const WCHAR c_szFontJPW2K[] = L"Microsoft Sans Serif";
    const WCHAR c_szFontJPOTHER[] = L"MS P Gothic";
    const WCHAR c_szFontJPNVert[] = L"@MS Gothic";
    const WCHAR c_szFontJPNVertWin9x[] =  L"@\xFF2D\xFF33 \xFF30\x30B4\x30B7\x30C3\x30AF"; // @MS P Gothic
    const WCHAR c_szFontCHS[] = L"SimSum";
    const WCHAR c_szFontCHSVert[] = L"@SimSun";
    const WCHAR c_szFontCHSVertLoc[] = L"@\x5b8b\x4f53";

    Assert(plf);

    int iDpi = 96;
    int iPoint = 0;

    HDC hdc = CreateIC("DISPLAY", NULL, NULL, NULL);
    if (hdc)
    {
        iDpi = GetDeviceCaps(hdc, LOGPIXELSY);
        DeleteDC(hdc);
    }
    else
        goto err_exit;



    switch(PRIMARYLANGID(m_langid))
    {
        case LANG_JAPANESE:
            iPoint = 12; // Satori uses 12 point font

            if ( !fVerticalWriting )
            {
                wcsncpy(plf->lfFaceName, 
                        IsOnNT5() ? c_szFontJPW2K : c_szFontJPOTHER,
                        ARRAYSIZE(plf->lfFaceName));
            }
            else
            {
                wcsncpy(plf->lfFaceName, 
                        IsOn98() ? c_szFontJPNVertWin9x : c_szFontJPNVert,
                        ARRAYSIZE(plf->lfFaceName));
            }

            // don't bother to call GetLocaleInfo() for now
            plf->lfCharSet = SHIFTJIS_CHARSET; 
            break;

        case LANG_CHINESE:

            iPoint = 9; 

            if ( !fVerticalWriting )
            {
                wcsncpy(plf->lfFaceName, c_szFontCHS, ARRAYSIZE(plf->lfFaceName));
            }
            else
            {
                wcsncpy(plf->lfFaceName, 
                        IsOnNT5() ? c_szFontCHSVert : c_szFontCHSVertLoc, 
                        ARRAYSIZE(plf->lfFaceName));
            }

            // don't bother to call GetLocaleInfo() for now
            plf->lfCharSet = GB2312_CHARSET; 
            break;

       default:
            break;

    }

    if (iPoint > 0)
        plf->lfHeight = -iPoint * iDpi / 72; 

err_exit:
      
    return iPoint > 0;
}
//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunction::CFunction(CSapiIMX *pImx)
{
    m_pImx = pImx;

    if (m_pImx)
       m_pImx->AddRef();

    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunction::~CFunction()
{
    SafeRelease(m_pImx);
}

//+---------------------------------------------------------------------------
//
// CFunction::GetFocusedTarget
//
//----------------------------------------------------------------------------

BOOL CFunction::GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp)
{
    ITfRange *pRangeTmp = NULL;
    ITfRange *pRangeTmp2 = NULL;
    IEnumTfRanges *pEnumTrack = NULL;
    BOOL bRet = FALSE;

    BOOL fWholeDoc = FALSE;

    if (!pRange)
    {
        fWholeDoc = TRUE;

        if (FAILED(GetRangeForWholeDoc(ec, pic, &pRange)))
            return FALSE;
    }

    if (bAdjust)
    {
        //
        // multi owner and PF_FOCUS range support.
        //

        if (FAILED(AdjustRangeByTextOwner(ec, pic,
                                          pRange, 
                                          &pRangeTmp2,
                                          CLSID_SapiLayr))) 
            goto Exit;

        GUID rgGuid[2];
        rgGuid[0] = GUID_ATTR_SAPI_INPUT;
        rgGuid[1] = GUID_ATTR_SAPI_GREENBAR;

        if (FAILED(AdjustRangeByAttribute(m_pImx->_GetLibTLS(),
                                          ec, pic,
                                          pRangeTmp2, 
                                          &pRangeTmp,
                                          rgGuid, ARRAYSIZE(rgGuid)))) 
            goto Exit;
    }
    else
    {
        pRange->Clone(&pRangeTmp);
    }

    ITfRange *pPropRange;
    ITfReadOnlyProperty *pProp;
    //
    // check if there is an intersection of PF_FOCUS range and owned range.
    // if there is no such range, we return FALSE.
    //
    if (FAILED(EnumTrackTextAndFocus(ec, pic, pRangeTmp, &pProp, &pEnumTrack)))
        goto Exit;

    while(pEnumTrack->Next(1, &pPropRange,  0) == S_OK)
    {
        if (IsOwnerAndFocus(m_pImx->_GetLibTLS(), ec, CLSID_SapiLayr, pProp, pPropRange))
            bRet = TRUE;

        pPropRange->Release();
    }

    pProp->Release();

    if (bRet)
    {
        *ppRangeTmp = pRangeTmp;
        (*ppRangeTmp)->AddRef();
    }

Exit:
    SafeRelease(pEnumTrack);
    SafeRelease(pRangeTmp);
    SafeRelease(pRangeTmp2);
    if (fWholeDoc)
        pRange->Release();
    return bRet;
}

HRESULT CFunction::_GetLangIdFromRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID *plangid)
{
    HRESULT hr;
    ITfProperty *pProp;
    LANGID langid;

    // get langid from the given range
    if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
    {
        GetLangIdPropertyData(ec, pProp, pRange, &langid);
        pProp->Release();
    }
     
    if (SUCCEEDED(hr) && plangid)
         *plangid = langid;
     
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnReconversion))
    {
        *ppvObj = SAFECAST(this, CFnReconversion *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnReconversion::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDAPI_(ULONG) CFnReconversion::Release()
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnReconversion::CFnReconversion(CSapiIMX *psi) : CFunction(psi) , CMasterLMWrap(psi), CBestPropRange( )
{
    m_psal = NULL;
    
    // initialize with the current profile langid
    m_langid = m_pImx->GetLangID();

//    m_MaxCandChars = 0;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnReconversion::~CFnReconversion()
{
    if (m_psal)
    {
        delete m_psal;
    }
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Reconversion");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::QueryRange
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::QueryRange(ITfRange *pRange, ITfRange **ppRange, BOOL *pfConvertable)
{
    CFnRecvEditSession *pes;
    CComPtr<ITfContext> cpic;
    HRESULT hr = E_FAIL;

    if (ppRange == NULL || pfConvertable == NULL || pRange == NULL)
        return E_INVALIDARG;

    *ppRange = NULL;
    *pfConvertable = FALSE;
    
    // call MasterLM when it's available
    //
    _EnsureMasterLM(m_langid);
    if (m_cpMasterLM)
    {
        hr = m_cpMasterLM->QueryRange( pRange, ppRange, pfConvertable );
        
        return  hr;
    }

    if (SUCCEEDED(pRange->GetContext(&cpic)))
    {
        hr = E_OUTOFMEMORY;

        if (pes = new CFnRecvEditSession(this, pRange, cpic))
        {
            pes->_SetEditSessionData(ESCB_RECONV_QUERYRECONV,NULL, 0);
          
            cpic->RequestEditSession(m_pImx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

            if ( SUCCEEDED(hr) )
                *ppRange = (ITfRange *)pes->_GetRetUnknown( );

            pes->Release();
        }

        *pfConvertable = (hr == S_OK);
        if (hr == S_FALSE)
        {
            hr = S_OK;
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// CFnReconversion::GetReconversion
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList)
{
    CFnRecvEditSession *pes;
    ITfContext *pic;
    HRESULT hr = E_FAIL;
    
    // Call master LM when it's available!
    // 
    //
    Assert(pRange);

    _EnsureMasterLM(m_langid);
    if (m_cpMasterLM)
    {
        return m_cpMasterLM->GetReconversion( pRange, ppCandList);
    }

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    hr = E_OUTOFMEMORY;

    if (pes = new CFnRecvEditSession(this, pRange,pic) )
    {
        pes->_SetEditSessionData(ESCB_RECONV_GETRECONV,NULL, 0); 
        pic->RequestEditSession(m_pImx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

        if (SUCCEEDED(hr))
            *ppCandList = (ITfCandidateList *)pes->_GetRetUnknown( );

        pes->Release();
    }

    pic->Release();

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_QueryReconversion
//
//----------------------------------------------------------------------------
HRESULT CFnReconversion::_QueryReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange)
{
    Assert(pic);
    Assert(pRange);
    Assert(ppNewRange);
    Assert(*ppNewRange == NULL);
    
    
    CComPtr<ITfProperty>    cpProp ;
    HRESULT hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);

    if (SUCCEEDED(hr) && cpProp)
    {
        CComPtr<ITfRange> cpBestPropRange;
        if (S_OK == hr)
        {
            hr = _ComputeBestFitPropRange(ec, cpProp, pRange, &cpBestPropRange, NULL, NULL);
        }
        // adjust start element and num elements
        if (S_OK == hr)
        {
            if (ppNewRange)
            {
                // TODO: this adjustment has to be done per element not phrase
                *ppNewRange = cpBestPropRange;
                (*ppNewRange)->AddRef();
            }
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// CFnReconversion::_GetSapilayrEngineInstance
//
//----------------------------------------------------------------------------
HRESULT CFnReconversion::_GetSapilayrEngineInstance(ISpRecognizer **ppRecoEngine)
{
#ifdef _WIN64
    return E_NOTIMPL;
#else
    HRESULT hr = E_FAIL;
    CComPtr<ITfFnGetSAPIObject>  cpGetSAPI;

    // we shouldn't release this until we terminate ourselves
    // so we don't use comptr here
    hr = m_pImx->GetFunction(GUID_NULL, IID_ITfFnGetSAPIObject, (IUnknown **)&cpGetSAPI);

    if (S_OK == hr)
    {
        hr = cpGetSAPI->Get(GETIF_RECOGNIZERNOINIT, (IUnknown **)ppRecoEngine);
    }

    return hr;
#endif
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_GetReconversion
//
//----------------------------------------------------------------------------
HRESULT CFnReconversion::_GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList, BOOL fDisableEngine /*=FALSE*/)
{
    WCHAR *pszText = NULL;
    CCandidateList *pCandList  = NULL;
    CComPtr<ITfProperty>    cpProp;
    HRESULT hr;
    BOOL fEmpty;

    if(!pRange)
        return E_FAIL;
    
    Assert(m_pImx);
    ULONG        cAlt = m_pImx->_GetMaxAlternates();
    

    if (pRange->IsEmpty(ec, &fEmpty) != S_OK || fEmpty)
        return E_FAIL;

    // GUID_PROP_SAPIRESULTOBJECT really gets us
    // a wrapper object of ISpRecoResult
    // 
    hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);
    if (S_OK != hr)
        return  S_FALSE;

    // try to reuse the candidate object if user opens it twice
    // on the same range using the same function instance
    //
    if (m_psal && m_psal->IsSameRange(pRange, ec))
    {
        CComPtr<ITfRange> cpPropRangeTemp;
        hr = cpProp->FindRange(ec, pRange, &cpPropRangeTemp, TF_ANCHOR_START);

        if (S_OK == hr)
            hr = GetCandidateForRange(m_psal, pic, pRange, ppCandList) ;
    }
    else
    {
        // get langid from the range property
        LANGID langid;
        if (FAILED(_GetLangIdFromRange(ec, pic, pRange, &langid)) || (langid == 0))
        {
            langid = GetUserDefaultLangID();
        }

        _SetCurrentLangID(langid);

        if (m_psal)
        {
            delete m_psal;
            m_psal = NULL;
        }

        CSapiAlternativeList *psal = new CSapiAlternativeList(langid, pRange, _GetMaxCandidateChars( ));

        if (psal)
        {
            m_psal = psal;
        }

        if (SUCCEEDED(hr) && cpProp && psal)
        {
            CComPtr<ITfRange>       cpPropRange;
            hr = cpProp->FindRange(ec, pRange, &cpPropRange, TF_ANCHOR_START);
    
            CComPtr<IUnknown> cpunk;
    
            // this punk points to the wrapper
            if (S_OK == hr)
                hr = GetUnknownPropertyData(ec, cpProp, cpPropRange, &cpunk);

            if ((hr == S_OK) && cpunk)
            {

                CSpTask *psp;
            
                hr = m_pImx->GetSpeechTask(&psp);
                if (SUCCEEDED(hr))
                {
                    CRecoResultWrap *pResWrap;
                    hr = cpunk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pResWrap);
                    if (S_OK == hr)
                    {
                        CComPtr<ITfRange> cpBestPropRange;
                        ISpPhraseAlt **ppAlt = (ISpPhraseAlt **)cicMemAlloc(cAlt*sizeof(ISpPhraseAlt *));
                        if (!ppAlt)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            ULONG ulStart, ulcElem;
                            hr = _ComputeBestFitPropRange(ec, cpProp, pRange, &cpBestPropRange, &ulStart, &ulcElem);
                            if (S_OK == hr)
                            {
                                m_cpRecoResult.Release();

                                CComPtr<ISpRecognizer> cpEngine;
                                _GetSapilayrEngineInstance(&cpEngine);

                                if (fDisableEngine && cpEngine)
                                {
                                    // We stop the engine deliberately here (whether active or not - cannot afford to check as
                                    // we may get blocked by SAPI). This forces the engine into a synchronization since the audio
                                    // stops and we are guaranteed to be able to display the candidate list object 
                                    // This particular scenario (fDisableEngine == TRUE) occurs with a Word right-click context
                                    // request for alternates. The normal 'display alternates list' scenario is handled in the
                                    // _Reconvert() call since it requires the engine to be re-enabled after the alternates list
                                    // is display to avoid it blocking until the engine hears silence.
                                    cpEngine->SetRecoState(SPRST_INACTIVE_WITH_PURGE);
                                }

                                hr = psp->GetAlternates(pResWrap, ulStart, ulcElem, ppAlt, &cAlt, &m_cpRecoResult);

                                if (fDisableEngine && cpEngine)
                                {
                                    // If the microphone is supposed to be open, we now restart the engine. 
                                    if (m_pImx->GetOnOff())
                                    {
                                        // We need to restart the engine now that we are fully initialized.
                                        cpEngine->SetRecoState(SPRST_ACTIVE);
                                    }
                                }
                            }

                            if ( S_OK == hr )
                            {
                                // Before we call SetPhraseAlt( ), we need to get the current parent text covered
                                // by cpBestPropRange.
                                WCHAR  *pwszParent = NULL;
                                CComPtr<ITfRange> cpParentRange;
                                long   cchChunck = 128;

                                hr = cpBestPropRange->Clone(&cpParentRange);
                                if ( S_OK == hr )
                                {
                                    long cch;
                                    int  iNumOfChunck=1;
                                   
                                    pwszParent = (WCHAR *) cicMemAllocClear((cchChunck+1) * sizeof(WCHAR) );

                                    if ( pwszParent )
                                    {
                                        hr = cpParentRange->GetText(ec, TF_TF_MOVESTART, pwszParent, (ULONG)cchChunck, (ULONG *)&cch);

                                        if ( (S_OK == hr) && ( cch > 0 ) )
                                            pwszParent[cch] = L'\0';
                                    }
                                    else
                                        hr = E_OUTOFMEMORY;

                                    while ( (S_OK == hr) && (cch == cchChunck))
                                    {
                                        long  iNewSize;

                                        iNewSize = ((iNumOfChunck+1) * cchChunck + 1 ) * sizeof(WCHAR);

                                        pwszParent = (WCHAR *)cicMemReAlloc(pwszParent, iNewSize);

                                        if ( pwszParent )
                                        {
                                            WCHAR  *pwszNewPosition;

                                            pwszNewPosition = pwszParent + iNumOfChunck * cchChunck;
                                            hr = cpParentRange->GetText(ec, TF_TF_MOVESTART, pwszNewPosition, (ULONG)cchChunck, (ULONG *)&cch);

                                            if ( (S_OK == hr) && ( cch > 0 ) )
                                                pwszNewPosition[cch] = L'\0';
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }

                                        iNumOfChunck ++;
                                    }
                                }

                                
                                if (S_OK == hr)
                                {
    
                                   // this is to store the obtained alternate phrases
                                    // to CSapiAlternativeList class instance
                                    // 
                                    hr = psal->SetPhraseAlt(pResWrap, ppAlt, cAlt, ulStart, ulcElem, pwszParent);
                                }

                                if ( pwszParent )
                                    cicMemFree(pwszParent);

                            }
                            if ((hr == S_OK) && ppAlt)
                            {
                                for (UINT i = 0; i < cAlt; i++)
                                {
                                    if (NULL != ppAlt[i])
                                    {
                                        ppAlt[i]->Release();
                                        ppAlt[i] = NULL;
                                    }
                                }
                            }

                            if ( ppAlt )
                                cicMemFree(ppAlt);
                        }
                        
                        pResWrap->Release();
    
                        // get this alternative list processed by external LM
                        //
                        if (S_OK == hr)
                        {
                            Assert(cpBestPropRange);

                            hr = GetCandidateForRange(psal, pic, cpBestPropRange, ppCandList) ;
                        }
                    }
                    psp->Release();
                }
            }
        }
    } 

    return hr;
}

HRESULT CFnReconversion::GetCandidateForRange(CSapiAlternativeList *psal, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList) 
{
    Assert(psal);

    if ( !psal || !pic || !pRange || !ppCandList )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    int nItem = psal->GetNumItem();
    WCHAR *pwszAlt = NULL;

    CCandidateList *pCandList = new CCandidateList(SetResult, pic, pRange, SetOption);

    if (!pCandList)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        int nPrb;

        for (int i = 0; SUCCEEDED(hr) && i < nItem ; i++)
        {
            psal->GetCachedAltInfo(i, NULL, NULL,NULL, &pwszAlt);

            if ( pwszAlt )
            {
                hr = psal->GetProbability(i, &nPrb);

                if (SUCCEEDED(hr))
                {
                    // note CSapiAlternateveList has exactly same life span as CFnReconversion
                    pCandList->AddString(pwszAlt, m_langid, psal, this, NULL);
                }
            }
        }

        // Add menu options here.
        HICON hIcon = NULL;
        WCHAR wzTmp[MAX_PATH];

        wzTmp[0] = 0;
        CicLoadStringWrapW(g_hInst, IDS_REPLAY, wzTmp, MAX_PATH);
        if (wzTmp[0] != 0)
        {
            hIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSPLAY), IMAGE_ICON, 16, 16,  0);
            pCandList->AddOption(wzTmp, m_langid, NULL, this, NULL, OPTION_REPLAY, hIcon ? hIcon : NULL, NULL);
        }

        wzTmp[0] = 0;
        CicLoadStringWrapW(g_hInst, IDS_DELETE, wzTmp, MAX_PATH);
        if (wzTmp[0] != 0)
        {
            hIcon = (HICON)LoadImage(g_hInstSpgrmr,
                                     MAKEINTRESOURCE(IDI_SPTIP_DELETEICON),
                                     IMAGE_ICON, 16, 16,  0);
            pCandList->AddOption(wzTmp, m_langid, NULL, this, NULL, OPTION_DELETE, hIcon ? hIcon : NULL, NULL);
        }

        if (GetSystemMetrics(SM_TABLETPC) > 0)
        {
            BOOL fDisplayRedo = TRUE;
            DWORD dw = 0;
            CMyRegKey regkey;
   
            if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ ) )
            {
                if (ERROR_SUCCESS == regkey.QueryValue(dw, TEXT("DisableRewrite")))
                {
                    if (dw == 1)
                    {
                        fDisplayRedo = FALSE;
                    }
                }
            }

            if (fDisplayRedo)
            {
                wzTmp[0] = 0;
                CicLoadStringWrapW(g_hInst, IDS_REDO, wzTmp, MAX_PATH);
                if (wzTmp[0] != 0)
                {
                    pCandList->AddOption(wzTmp, m_langid, NULL, this, NULL, OPTION_REDO, NULL, NULL);
                }
            }
        }

        hr = pCandList->QueryInterface(IID_ITfCandidateList, (void **)ppCandList);
        pCandList->Release();
    }
    
    return hr;
}
//+---------------------------------------------------------------------------
//
// CFnReconversion::Reconvert
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::Reconvert(ITfRange *pRange)
{
    CFnRecvEditSession *pes;
    ITfContext *pic;
    HRESULT hr = E_FAIL;
    
    Assert(pRange);

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    hr = E_OUTOFMEMORY;

    if (pes = new CFnRecvEditSession(this, pRange, pic))
    {
        BOOL  fCallLMReconvert = FALSE;

        pes->_SetEditSessionData(ESCB_RECONV_RECONV, NULL, 0);
        pic->RequestEditSession(m_pImx->_GetId(), pes, TF_ES_READWRITE | TF_ES_ASYNC, &hr);

        if ( SUCCEEDED(hr) )
            fCallLMReconvert = (BOOL)pes->_GetRetData( );

        if (hr == S_OK && fCallLMReconvert)
        {
            // need to call LM reconvert
            Assert(m_cpMasterLM != NULL);
            hr = m_cpMasterLM->Reconvert(pRange);
        }

        pes->Release();        
    }

    pic->Release();

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_Reconvert
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::_Reconvert(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL *pfCallLMReconvert)
{
    ITfCandidateList *pCandList;
    HRESULT hr;
    CSpTask *psp = NULL;
            
    // Call master LM when it's available!
    //
    // For voice playback, we need to do a little more.
    // we have to call QueryRange first and determine the
    // length of playback here.
    //
    *pfCallLMReconvert = FALSE;

    _EnsureMasterLM(m_langid);
    if (m_cpMasterLM)
    {
        // playback the whole range for now
        //
        CComPtr<ITfProperty> cpProp;
        hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);
        if (S_OK == hr)
        {
            CComPtr<ITfRange>     cpPropRange;
            CComPtr<IUnknown>     cpunk;
            hr = cpProp->FindRange(ec, pRange, &cpPropRange, TF_ANCHOR_START);
            
            if (S_OK == hr)
            {
                hr = GetUnknownPropertyData(ec, cpProp, cpPropRange, &cpunk);
            }
            if (S_OK == hr)
            {
                CRecoResultWrap *pwrap = (CRecoResultWrap *)(void *)cpunk;
                pwrap->_SpeakAudio(0, 0);
            }
        }

        // after exiting this edit session, caller needs to call m_cpMasterLM->Reconvert
        *pfCallLMReconvert = TRUE;
        return S_OK;
    }

    CComPtr<ISpRecognizer> cpEngine;
    _GetSapilayrEngineInstance(&cpEngine);

    if (cpEngine)
    {
        // We stop the engine deliberately here (whether active or not - cannot afford to check as
        // we may get blocked by SAPI). This forces the engine into a synchronization since the audio
        // stops and we are guaranteed to be able to display the candidate list object 
        cpEngine->SetRecoState(SPRST_INACTIVE_WITH_PURGE);

    }

    if (S_OK != (hr = _GetReconversion(ec, pic, pRange, &pCandList)))
        return hr;
        
    // voice playback

    if ( m_pImx->_EnablePlaybackWhileCandUIOpen( ) )
    {
        if (m_psal)
            m_psal->_Speak();
    }

    hr = ShowCandidateList(ec, pic, pRange, pCandList);

    if (cpEngine)
    {
        // If the microphone is supposed to be open, we now restart the engine. 
        if (m_pImx->GetOnOff())
        {
            // We need to restart the engine now that we are fully initialized.
            cpEngine->SetRecoState(SPRST_ACTIVE);
        }
    }

    pCandList->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::ShowCandidateList
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList)
{
    // Determine if current range is vertical writing
    CComPtr<ITfReadOnlyProperty>  cpProperty;
    VARIANT  var;
    BOOL     fVertical = FALSE;
    ULONG    lDirection = 0;

    if ( pic->GetAppProperty(TSATTRID_Text_VerticalWriting, &cpProperty) == S_OK )
    {
        if (cpProperty->GetValue(ec, pRange, &var) == S_OK )
        {
            fVertical = var.boolVal;
        }
    }

    // Get the current text orientation.
    cpProperty.Release( );
    if ( pic->GetAppProperty(TSATTRID_Text_Orientation, &cpProperty) == S_OK )
    {
        if (cpProperty->GetValue(ec, pRange, &var) == S_OK )
        {
            lDirection = var.lVal;
        }
    }

    // During the speech tip activation time, we just want to create candidateui object once for perf improvement.
    if ( m_pImx->_pCandUIEx == NULL )
    {
       CoCreateInstance(CLSID_TFCandidateUI, NULL, CLSCTX_INPROC_SERVER, IID_ITfCandidateUI, (void**)&m_pImx->_pCandUIEx);
    }

    if ( m_pImx->_pCandUIEx )
    {
        ITfDocumentMgr *pdim;
        if (SUCCEEDED(m_pImx->GetFocusDIM(&pdim)))
        {
            
            m_pImx->_pCandUIEx->SetClientId(m_pImx->_GetId());

            ITfCandUIAutoFilterEventSink *pCuiFes = new CCandUIFilterEventSink(this, pic, m_pImx->_pCandUIEx);
            CComPtr<ITfCandUIFnAutoFilter> cpFnFilter;

            if (S_OK == m_pImx->_pCandUIEx->GetFunction(IID_ITfCandUIFnAutoFilter, (IUnknown **)&cpFnFilter))
            {
                cpFnFilter->Advise(pCuiFes);
                cpFnFilter->Enable(TRUE);

            }

            //
            // set the right font size for Japanese and Chinese case
            //
            CComPtr<ITfCandUICandString>       cpITfCandUIObj;
            if (S_OK == m_pImx->_pCandUIEx->GetUIObject(IID_ITfCandUICandString, (IUnknown **)&cpITfCandUIObj))
            {
                Assert(m_psal); // this shouldn't fail

                if (m_psal)
                {
                    LOGFONTW lf = {0};
                    if (m_psal->_GetUIFont(fVertical, &lf))
                    {
                        cpITfCandUIObj->SetFont(&lf);
                    }
                }
            }

            //
            // Set the candidate Ui window's style.
            // 
            // Speech TIP always uses drop-down candidat window.
            //
            CComPtr<ITfCandUIFnUIConfig>  cpFnUIConfig;

            if (S_OK == m_pImx->_pCandUIEx->GetFunction(IID_ITfCandUIFnUIConfig, (IUnknown **)&cpFnUIConfig))
            {
                CANDUISTYLE  style;

                style = CANDUISTY_LIST;
                cpFnUIConfig->SetUIStyle(pic, style);
            }

            // 
            // Set the candidate UI window's direction.
            //

            CComPtr<ITfCandUICandWindow> cpUICandWnd;

            if ( S_OK == m_pImx->_pCandUIEx->GetUIObject(IID_ITfCandUICandWindow, (IUnknown **)&cpUICandWnd) )
            {
                CANDUIUIDIRECTION       dwOption = CANDUIDIR_TOPTOBOTTOM;

                switch ( lDirection )
                {
                case  900 : // Text direction Bottom to Top
                    dwOption = CANDUIDIR_LEFTTORIGHT;
                    break;

                case 1800 : // Text direction Right to Left.
                    dwOption = CANDUIDIR_BOTTOMTOTOP;
                    break;

                case 2700 : // Text direction Top to Bottom.
                    dwOption = dwOption = CANDUIDIR_RIGHTTOLEFT;
                    break;

                default :
                    dwOption = CANDUIDIR_TOPTOBOTTOM;
                    break;
                }

                cpUICandWnd->SetUIDirection(dwOption);

            }

            m_pImx->_pCandUIEx->SetCandidateList(pCandList);

            // Before Open Candidate UI window, we want to save the current IP

            m_pImx->_SaveCorrectOrgIP(ec, pic);

            m_pImx->_pCandUIEx->OpenCandidateUI(NULL, pdim, ec, pRange);

            pCuiFes->Release();
            pdim->Release();
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::SetResult
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    BSTR bstr;
    HRESULT hr = S_OK;
    CFnReconversion *pReconv = (CFnReconversion *)(pCand->_punk);

    if ((imcr == CAND_FINALIZED) || (imcr == CAND_SELECTED))
    {
        pCand->GetString(&bstr);

        // TODO: here we have to re-calc the range based on the strart element points 
        //       which are indicated from AltInfo.
        ULONG     ulParentStart     = 0;
        ULONG     ulcParentElements  = 0;
        ULONG     ulIndex           = 0;
        ULONG     cchParentStart    = 0;
        ULONG     cchParentReplace  = 0;

        BOOL      fNoAlternate = FALSE;
        
        CSapiAlternativeList *psal = (CSapiAlternativeList *)pCand->_pv;
        
        pCand->GetIndex(&ulIndex);
        
        if (psal)
        {
            CRecoResultWrap *cpRecoWrap;
            ULONG            ulStartElement;
            ULONG            ulLeadSpaceRemoved = 0;

            // save current selection index.

            psal->_SaveCurrentSelectionIndex(ulIndex);

            cpRecoWrap = psal->GetResultWrap();
            ulStartElement = cpRecoWrap->GetStart( );

            psal->GetCachedAltInfo(ulIndex, &ulParentStart, &ulcParentElements,  NULL, NULL, &ulLeadSpaceRemoved);
        
            cchParentStart   = cpRecoWrap->_GetElementOffsetCch(ulParentStart);
            cchParentReplace = cpRecoWrap->_GetElementOffsetCch(ulParentStart + ulcParentElements) - cchParentStart;

            cchParentStart = cchParentStart - cpRecoWrap->_GetElementOffsetCch(ulStartElement) + cpRecoWrap->_GetOffsetDelta( );

            if ( ulLeadSpaceRemoved > 0  && cchParentStart > ulLeadSpaceRemoved)
            {
                cchParentStart -= ulLeadSpaceRemoved;
                cchParentReplace += ulLeadSpaceRemoved;
            }

            fNoAlternate = psal->_IsNoAlternate( );

            if ( !fNoAlternate )
            {
                hr = pReconv->m_pImx->SetReplaceSelection(pRange, cchParentStart,  cchParentReplace, pic);

                if ( (SUCCEEDED(hr))  && (imcr == CAND_FINALIZED) )
                {
                    if ( ulParentStart + ulcParentElements == ulStartElement + cpRecoWrap->GetNumElements( ) )
                    {
                        // The parent selection contains the last element.
                        // if its trailing spaces were removed before, we also want to 
                        // remove the same number of trailing spaces in the new alternative text.

                        // We already considered this case during _Commit( ).
                        // We just need to update the result text which wil be injected.

                        ULONG  ulTSRemoved;

                        ulTSRemoved = cpRecoWrap->GetTrailSpaceRemoved( );

                        if ( ulTSRemoved > 0 )
                        {
                            ULONG   ulTextLen;
                            ULONG   ulRemovedNew = 0;
                        
                            ulTextLen = wcslen(bstr);

                            for ( ULONG i=ulTextLen-1; (int)i>=0 && ulRemovedNew <= ulTSRemoved;  i-- )
                            {
                                if ( bstr[i] == L' ' )
                                {
                                    bstr[i] = L'\0';
                                    ulRemovedNew ++;
                                }
                                else
                                    break;
                            }

                            if ( ulRemovedNew < ulTSRemoved )
                                cpRecoWrap->SetTrailSpaceRemoved( ulRemovedNew );
                        }
                    }

                    pReconv->_Commit(pCand);

                    // If the first element in this RecoWrap is updated by the new alternate
                    // speech tip needs to check if this new alternate wants to 
                    // consume the leading space or if extra space is required to add
                    // between this phrase and previous phrase.
                    // 
                    BOOL   bHandleLeadingSpace = (ulParentStart == ulStartElement) ? TRUE : FALSE;
                    hr = pReconv->m_pImx->InjectAlternateText(bstr, pReconv->m_langid, pic, bHandleLeadingSpace);

                    //
                    // Update the Selection grammar's text buffer.
                    //
                    if ( SUCCEEDED(hr) && pReconv->m_pImx )
                    {
                        CSpTask     *psp = NULL;
                        (pReconv->m_pImx)->GetSpeechTask(&psp);

                        if ( psp )
                        {
                            hr = psp->_UpdateSelectGramTextBufWhenStatusChanged( );
                            psp->Release( );
                        }
                    }
                    //
                }
            }
        }

        SysFreeString(bstr);        
      
        
    }
    // close candidate UI if it's still there
    if (imcr == CAND_FINALIZED || imcr == CAND_CANCELED)
    {
        // Just close the candidate UI, don't release the object, so that the object keeps alive while the 
        // speech tip is activated, this is for performance improvement.
        pReconv->m_pImx->CloseCandUI( );

        if ( imcr == CAND_CANCELED )
        {
            // Just release the stored IP to avoid memory leak.
            // Don't restore it according to the new spec so that
            // user can continue to dictate new text over the selection.
            //

            // If we find this is not a good Usuability,
            // we can change it back to the original behavior.
            pReconv->m_pImx->_ReleaseCorrectOrgIP( );
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::GetTabletTip
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::GetTabletTip(void)
{
    HRESULT hr = S_OK;
    CComPtr<IUnknown> cpunk;
    
    if (m_cpTabletTip)
    {
        m_cpTabletTip = NULL; // Releases our reference.
    }
    
    hr = CoCreateInstance(CLSID_UIHost, NULL, CLSCTX_LOCAL_SERVER, IID_IUnknown, (void **) &cpunk);
    
    if (SUCCEEDED(hr))
    {
        hr = cpunk->QueryInterface(IID_ITipWindow, (void **) &m_cpTabletTip);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::SetOption
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::SetOption(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr)
{
    HRESULT hr = S_OK;
    CFnReconversion *pReconv = (CFnReconversion *)(pCand->_punk);

    if (imcr == CAND_FINALIZED)
    {
        ULONG ulID = 0;

        pCand->GetID(&ulID);
        switch (ulID)
        {
            case OPTION_REPLAY:
            {
                // Replay audio. Do not close candidate list.
                CSapiAlternativeList  *psal;
                psal = pReconv->GetCSapiAlternativeList( );
                if ( psal )
                {
                   psal->_Speak( );
                }
                break;
            }

            case OPTION_DELETE: // Delete from dictinary...
            {
                // Close candidate UI.
                pReconv->m_pImx->_pCandUIEx->CloseCandidateUI();

                // Delete the current selection in the document.
                pReconv->m_pImx->HandleKey(VK_DELETE);

                break;
            }

            case OPTION_REDO: // Tablet PC specific option.
            {
                // Close candidate UI.
                pReconv->m_pImx->_pCandUIEx->CloseCandidateUI();

                if (pReconv->m_cpTabletTip == NULL)
                {
                    pReconv->GetTabletTip();
                }
                if (pReconv->m_cpTabletTip)
                {
                    hr = pReconv->m_cpTabletTip->ShowWnd(VARIANT_TRUE);
                    if (FAILED(hr))
                    {
                        // Reget TabletTip and try a second time in case the previous instance was killed.
                        hr = pReconv->GetTabletTip();
                        if (SUCCEEDED(hr))
                        {
                            hr = pReconv->m_cpTabletTip->ShowWnd(VARIANT_TRUE);
                        }
                    }
                }

                break;
            }
        }
    }

    // close candidate UI if it's still there
    if (imcr == CAND_CANCELED)
    {
        if (pReconv->m_pImx->_pCandUIEx)
        {
            pReconv->m_pImx->_pCandUIEx->CloseCandidateUI();
        }
    }
    return hr;
}

//
// _Commit
//
// synopisis: accept the candidate string as the final selection and
//            let SR know the decision has been made
//
void CFnReconversion::_Commit(CCandidateString *pcand)
{
    ULONG nIdx;
    Assert(pcand);

    if (S_OK == pcand->GetIndex(&nIdx))
    {
        // let CSapiAlternativeList class do the real work
        if (m_psal)
            m_psal->_Commit(nIdx, m_cpRecoResult);

        // we no longer need to hold the reco result
        m_cpRecoResult.Release();
    }
}

ULONG  CBestPropRange::_GetMaxCandidateChars( )
{
    if ( m_MaxCandChars == 0 )
    {
        // it is not initialized
        CMyRegKey regkey;
        DWORD     dw = MAX_CANDIDATE_CHARS;

        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ))
        {
            regkey.QueryValue(dw, c_szMaxCandChars);
        }

        if ( (dw > MAX_CANDIDATE_CHARS) || (dw == 0) )
            dw = MAX_CANDIDATE_CHARS;

        m_MaxCandChars = dw;
    }

    return m_MaxCandChars;
}



//
// FindVisiblePropertyRange
//
// Searches for a property range, skipping over any "empty" (containing only hidden text)
// property spans along the way.
//
// We can encounter hidden property spans (zero-length from a tip's point of view) if the
// user marks some dictated text as hidden in word.
HRESULT FindVisiblePropertyRange(TfEditCookie ec, ITfProperty *pProperty, ITfRange *pTestRange, ITfRange **ppPropertyRange)
{
    BOOL fEmpty;
    HRESULT hr;

    while (TRUE)
    {
        hr = pProperty->FindRange(ec, pTestRange, ppPropertyRange, TF_ANCHOR_START);

        if (hr != S_OK)
            break;

        if ((*ppPropertyRange)->IsEmpty(ec, &fEmpty) != S_OK)
        {
            hr = E_FAIL;
            break;
        }

        if (!fEmpty)
            break;

        // found an empty property span
        // this means it contains only hidden text, so skip it
        if (pTestRange->ShiftStartToRange(ec, *ppPropertyRange, TF_ANCHOR_END) != S_OK)
        {
            hr = E_FAIL;
            break;
        }

        (*ppPropertyRange)->Release();
    }

    if (hr != S_OK)
    {
        *ppPropertyRange = NULL;
    }

    return hr;
}

//
//    _ComputeBestFitPropRange
//
//    synopsis: returns the range that includes at least one SPPHRASE element
//              which also includes the specified (incoming) range
//              *pulStart should include the start element used in the reco result
//              *pulcElem should include the # of elements used
//
HRESULT CBestPropRange::_ComputeBestFitPropRange
(
    TfEditCookie ec, 
    ITfProperty *pProp, 
    ITfRange *pRangeIn, 
    ITfRange **ppBestPropRange, 
    ULONG *pulStart, 
    ULONG *pulcElem
)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITfRange> cpPropRange ;
    CComPtr<IUnknown> cpunk;
    ULONG ucch;

    BOOL    fBeyondPropRange = FALSE;


    TraceMsg(TF_GENERAL, "_ComputeBestFitPropRange is called");

    // find the reco result with a span that includes the given range
    Assert(pProp);
    Assert(pRangeIn);

    CComPtr<ITfRange> cpRange ;
    hr = pRangeIn->Clone(&cpRange);
    if (S_OK == hr)
    {
        hr = FindVisiblePropertyRange(ec, pProp, cpRange, &cpPropRange);
    }

    if ( hr == S_FALSE ) 
    {
        // if this is not a selection and the IP is at the last position of this region, we just try to reconvert on the possible previous 
        // dictated phrase.
        BOOL   fTryPreviousPhrase = FALSE;
        BOOL   fEmpty = FALSE;

        // Add code here to check it meets the condition.

        if ( S_OK == cpRange->IsEmpty(ec, &fEmpty) && fEmpty )
        {
            CComPtr<ITfRange> cpRangeTmp;

            if ( S_OK == cpRange->Clone(&cpRangeTmp) )
            {
                LONG  cch = 0;
                if ( (S_OK == cpRangeTmp->ShiftStart(ec, 1, &cch, NULL)) && (cch < 1) )
                {
                    // it is at the end of a region or entire document.
                    fTryPreviousPhrase = TRUE;
                }
            }
        }

        if ( fTryPreviousPhrase )
        {
            LONG  cch;

            hr = cpRange->ShiftStart(ec,  -1, &cch,  NULL);

            if ( hr == S_OK )
            {
                hr = cpRange->Collapse(ec, TF_ANCHOR_START);
            }

            if ( hr == S_OK )
            {
                hr = FindVisiblePropertyRange(ec, pProp, cpRange, &cpPropRange);
            }
        }
    }

    // get a wrapper for the prop range
    if (S_OK == hr)
    {    
        hr = GetUnknownPropertyData(ec, pProp, cpPropRange, &cpunk);
    }
    if ((hr == S_OK) && cpunk)
    {
        // first calculate the # of chars upto the start anchor of the given range
        //
        CComPtr<ITfRange>       cpClonedPropRange;
        if (S_OK == hr)
        {
            hr = cpPropRange->Clone(&cpClonedPropRange);
        }
            
        if (S_OK == hr)
        {
            hr = cpClonedPropRange->ShiftEndToRange(ec, cpRange, TF_ANCHOR_START);
        }
        
        ULONG ulCchToSelection = 0;
        ULONG ulCchInSelection = 0;
        BOOL fEmpty;
        if (S_OK == hr)
        {
            CSpDynamicString dstr;
            while(S_OK == hr && (S_OK == cpClonedPropRange->IsEmpty(ec, &fEmpty)) && !fEmpty)
            {
                WCHAR sz[64];

                hr = cpClonedPropRange->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);
                if (S_OK == hr)
                {
                    sz[ucch] = L'\0';
                    dstr.Append(sz);
                }
            }
            ulCchToSelection = dstr.Length();
        }

        // then  calc the # of chars upto the end anchor of the given range
        if(S_OK == hr)
        {
            hr = cpRange->IsEmpty(ec, &fEmpty);
            if (S_OK == hr && !fEmpty)
            {
                CComPtr<ITfRange> cpClonedGivenRange;
                hr = cpRange->Clone(&cpClonedGivenRange);
                // compare the end of the given range and proprange,
                // if the given range goes beyond proprange, snap it
                // within the proprange
                if (S_OK == hr)
                {
                    LONG lResult;
                    hr = cpClonedGivenRange->CompareEnd(ec, cpPropRange, TF_ANCHOR_END, &lResult);
                    if (S_OK == hr && lResult > 0)
                    {
                        // the end of the given range is beyond the proprange
                        // we need to snap it before getting text
                        hr = cpClonedGivenRange->ShiftEndToRange(ec, cpPropRange, TF_ANCHOR_END);

                        fBeyondPropRange = TRUE;

                    }
                    // now we get the text we use to calc the # of elements
                    CSpDynamicString dstr;
                    while(S_OK == hr && (S_OK == cpClonedGivenRange->IsEmpty(ec, &fEmpty)) && !fEmpty)
                    {
                        WCHAR sz[64];
                        hr = cpClonedGivenRange->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);
                        if (S_OK == hr)
                        {
                            sz[ucch] = L'\0';
                            dstr.Append(sz);
                        }
                    }
                    ulCchInSelection = dstr.Length();

                    // If there are some spaces in the beginning of the selection,
                    // we need to shift the start of the selection to the next non-space character.

                    if ( ulCchInSelection > 0 )
                    {
                        WCHAR   *pStr;

                        pStr = (WCHAR *)dstr;

                        while ( (*pStr == L' ') || (*pStr == L'\t'))
                        {
                            ulCchInSelection --;
                            ulCchToSelection ++;
                            pStr ++;
                        }

                        if ( *pStr == L'\0' )
                        {
                            // This selection contains only spaces. no other non-space character.
                            // we don't want to get alternate for this selection.
                            // just return here.

                            if (ppBestPropRange != NULL )
                                *ppBestPropRange = NULL;

                            if ( pulStart != NULL )
                                *pulStart = 0;

                            if (pulcElem != NULL )
                                *pulcElem = 0;

                            return S_FALSE;
                        }

                    }
                    
                }
            }
        }
            
        // get the result object cpunk points to our wrapper object
        CComPtr<IServiceProvider> cpServicePrv;
        CComPtr<ISpRecoResult>    cpResult;
        SPPHRASE *pPhrases = NULL;
        CRecoResultWrap *pResWrap = NULL;

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
        }
        // get result object 
        if (S_OK == hr)
        {
            hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpResult);
        }

        // now we can see how many elements we can use
        if (S_OK == hr)
        {
            hr = cpResult->GetPhrase(&pPhrases);
        }

        if (S_OK == hr)
        {
            hr = cpunk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pResWrap); 
        }

        if (S_OK == hr && pPhrases)
        {
            // calc the start anchor of the new range
#ifdef NOUSEELEMENTOFFSET                
            CSpDynamicString dstr;
#endif
            long cchToElem_i = 0;
            long cchAfterElem_i = 0;
            BOOL  fStartFound = FALSE;
            ULONG i;
            ULONG ulNumElements;
            
            CComPtr<ITfRange> cpNewRange;
            hr = cpRange->Clone(&cpNewRange);

            if ( fBeyondPropRange )
            {
                hr = cpNewRange->ShiftEndToRange(ec, cpPropRange, TF_ANCHOR_END);
            }

            if ( ulCchInSelection > _GetMaxCandidateChars( ) )
            {
                // If the selection has more than MaxCandidate Chars, we need to shift the range end
                // to left so that it contains at most MaxCandidate Chars in the selection.
                long cch;

                cch = (long)_GetMaxCandidateChars( ) - (long)ulCchInSelection;
                ulCchInSelection = _GetMaxCandidateChars( );
                cpNewRange->ShiftEnd(ec, cch, &cch, NULL);
            }

            ulNumElements = pResWrap->GetNumElements();
           
            // get start element and # of elements via wrapper object
            if ((S_OK == hr)  && ulNumElements > 0 )
            {
                ULONG  ulStart;
                ULONG  ulEnd;
                ULONG  ulOffsetStart;
                ULONG  ulDelta;

                ulStart = pResWrap->GetStart();
                ulEnd = ulStart + pResWrap->GetNumElements() - 1;

                ulDelta = pResWrap->_GetOffsetDelta( );
                ulOffsetStart = pResWrap->_GetElementOffsetCch(ulStart);

                for (i = ulStart; i <= ulEnd; i++ )
                {
#ifdef NOUSEELEMENTOFFSET                
                    //  CleanupConsider: replace this logic with pResWrap->GetElementOffsets(i)
                    //  where we cache the calculated offsets
                    //
                    if (pPhrases->pElements[i].pszDisplayText)
                    {
                        cchToElem_i = dstr.Length();

                        dstr.Append(pPhrases->pElements[i].pszDisplayText);
                    
                    
                        if (pPhrases->pElements[i].bDisplayAttributes & SPAF_ONE_TRAILING_SPACE)
                        {
                            dstr.Append(L" ");
                        }
                        else if (pPhrases->pElements[i].bDisplayAttributes & SPAF_TWO_TRAILING_SPACES)
                        {
                            dstr.Append(L"  ");
                        }
                        cchAfterElem_i = dstr.Length();
                    }
                    else
                        break;
#else    
                    // when i < # of elements, it's guaranteed that we have n = i + 1
                    //
                    cchToElem_i = pResWrap->_GetElementOffsetCch(i) - ulOffsetStart + ulDelta;
                    cchAfterElem_i = pResWrap->_GetElementOffsetCch(i+1) - ulOffsetStart + ulDelta;
#endif                 

                    if ( ulCchInSelection == 0 )
                    {
                        // we need to specially handle this case that no character is in selection
                        // user just puts a cursor right before a character.

                        // We just want to find out which element would contain this IP.
                        // and then shift anchors to this element's start and end position.

                        if ( (ULONG)cchAfterElem_i  > ulCchToSelection )
                        {
                            // This element is the right element to contain this IP.
                            long cch;

                            // this is usually reverse shifting
                            // Shift the start anchor to this element's start position.

                            cpNewRange->ShiftStart(ec, cchToElem_i - ulCchToSelection, &cch, NULL);

                    
                            // store the starting element used

                            TraceMsg(TF_GENERAL, "Start element = %d", i);
                        
                            if (pulStart)
                            {
                                *pulStart = i;
                            }

                            // Shift the end anchor to this element's end position.
                            cpNewRange->ShiftEnd(ec, 
                                              cchAfterElem_i - ulCchToSelection, 
                                              &cch, NULL);


                            TraceMsg(TF_GENERAL, "End Element = %d", i);
                           
                            break;
                        }
                    }
                    else
                    {
                        // 1) shift the start anchor of prop range based on the element offsets of 
                        //    the result object, comparing it with the start anchor (ulCchToSelection) 
                        //    of the given range 
                        //    - choose the start elements that is right before the start anchor.
                        //
                        if ((ULONG)cchAfterElem_i > ulCchToSelection && !fStartFound) 
                        {
                            long cch;
                            // this is usually reverse shifting
                            cpNewRange->ShiftStart(ec, cchToElem_i - ulCchToSelection, &cch, NULL);

                    
                            // store the starting element used

                            TraceMsg(TF_GENERAL, "Start element = %d", i);
                        
                            if (pulStart)
                            {
                                *pulStart = i;
                            }
                            fStartFound = TRUE;
                        }
                        // 2) shift the end anchor of prop range based on the the element offset 
                        //    and the # of elements of result object,
                        //    comparing it with the end anchor of the given range (ulCchToSelection+ulCchInSelection)
                        //    - the element so the span ends right after the end anchor of the given range.
                        //
                        if ((ULONG)cchAfterElem_i >= ulCchToSelection + ulCchInSelection)
                        {
                            long cch;

                            if ( ulCchInSelection >= _GetMaxCandidateChars( ) )
                            {
                                // The selection contains MaxCand chars, we should make sure the char number
                                // in new proprange less than MaxCand.

                                if ( (ULONG)cchAfterElem_i > ulCchToSelection + ulCchInSelection )
                                {
                                    // if keeping this element, the total char number will larger than MaxCand.
                                    // So use the previous element as the last element.
                                    if ( i > ulStart )   // This conditon should always be true.
                                    {
                                        i--;
                                        cchAfterElem_i = pResWrap->_GetElementOffsetCch(i+1) - ulOffsetStart + ulDelta;
                                    }
                                }
                            }

                            cpNewRange->ShiftEnd(ec, 
                                              cchAfterElem_i - (ulCchToSelection + ulCchInSelection), 
                                              &cch, NULL);

                            TraceMsg(TF_GENERAL, "End Element = %d", i);

                            break;
                        }
                    }
                }
                if (pulcElem && pulStart)
                {
                   // we need to check if the current selection contains any ITN range.
                   // If it contains ITN range, we need to change the start and num of elements if
                   // the start element or end element is inside an ITN range.

                    BOOL  fInsideITN;
                    ULONG ulITNStart, ulITNNumElem;
                    ULONG ulEndElem;

                    ulEndElem = i;  // Current end element

                    if ( i > ulEnd )
                        ulEndElem = ulEnd;

                    fInsideITN = pResWrap->_CheckITNForElement(NULL, *pulStart, &ulITNStart, &ulITNNumElem, NULL );

                    if ( fInsideITN && (ulITNStart < *pulStart) )
                        *pulStart = ulITNStart;

                    fInsideITN = pResWrap->_CheckITNForElement(NULL, ulEndElem, &ulITNStart, &ulITNNumElem, NULL );

                    if ( fInsideITN && ulEndElem < (ulITNStart + ulITNNumElem - 1) )
                        ulEndElem = ulITNStart + ulITNNumElem - 1;

                    *pulcElem = ulEndElem - *pulStart + 1;

                    TraceMsg(TF_GENERAL, "Final Best Range: start=%d num=%d", *pulStart, *pulcElem);
 
                }
       
            }
            CoTaskMemFree( pPhrases );

            if ( ulNumElements > 0 )
            {
                Assert(cpNewRange);
                Assert(ppBestPropRange);
                *ppBestPropRange = cpNewRange;        

                (*ppBestPropRange)->AddRef();
            }
            else
                hr = S_FALSE;
        }
        SafeRelease(pResWrap);
    }
    return hr;
}

//
//
// CCandUIFilterEventSink
//
//
STDMETHODIMP CCandUIFilterEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfCandUIAutoFilterEventSink))
    {
        *ppvObj = SAFECAST(this, CCandUIFilterEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCandUIFilterEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCandUIFilterEventSink::Release(void)
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

HRESULT CCandUIFilterEventSink::OnFilterEvent(CANDUIFILTEREVENT ev)
{
    HRESULT hr = S_OK;
    
    // Temporally comment out the below code to fix bug 4777.
    //
    // To fully support the specification of filter feature, we need to change more code
    // in SetFilterString( ) to use the correct parent range in current document so that the filter
    // string is injected to a correct position.
    // 
    // We also want to change code to restore the original document text when the canidate UI is 
    // cancelled.
    //
    //

//    if (ev == CANDUIFEV_UPDATED)
    if ( ev == CANDUIFEV_NONMATCH )
    {
        // When we got non-matching notification, we need to inject the previous filter string to the document.
        if (m_pfnReconv)
        {
            Assert(m_pfnReconv);
            Assert(m_pfnReconv->m_pImx);
            
            ESDATA  esData;

            memset(&esData, 0, sizeof(ESDATA));
            esData.pUnk = (IUnknown *)m_pCandUI;
            m_pfnReconv->m_pImx->_RequestEditSession(ESCB_UPDATEFILTERSTR,TF_ES_READWRITE, &esData, m_pic);
        }
    }

    return hr; // looks like S_OK is expected anyways
}

/*   this filter event is no longer used.

HRESULT CCandUIFilterEventSink::OnAddCharToFilterStringEvent(CANDUIFILTEREVENT ev, WCHAR  wch, int nItemVisible, BOOL *bEten)
{

    HRESULT hr = S_OK;

    if ( (bEten == NULL) ||  (ev != CANDUIFEV_ADDCHARTOFILTER))
        return E_INVALIDARG;

    *bEten = FALSE;

    if ( nItemVisible == 0 )
    {
        if ( (wch <= L'9')  && (wch >= L'1') )
        {
            // we need to select the speified candidate text.
            // if candidate UI is open, we need to select the right alternate.

            if ( m_pCandUI )
            {
                ULONG   ulIndex;

                ulIndex = wch - L'0';

                m_pCandUI->ProcessCommand(CANDUICMD_SELECTLINE, ulIndex);
            }
            *bEten = TRUE;
        }
        else if ( wch == L' ' )
        {
            if ( m_pCandUI )
            {
                m_pCandUI->ProcessCommand(CANDUICMD_MOVESELNEXT, 0);
            }
            *bEten = TRUE;
        }

    }
    return hr;

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\fnrecon.h ===
//
// fnrecon.h
//

#ifndef FNRECON_H
#define FNRECON_H

#include "private.h"
#include "ctffunc.h"
#include "sapilayr.h"
#include "candlist.h"
#include "mscandui.h"
#include "ptrary.h"
#include "lmobj.h"
#include "propstor.h"
#include "strary.h"
#include "TabletTip.h"

#define OPTION_REPLAY 0
#define OPTION_DELETE 1
#define OPTION_REDO   2

class CSapiIMX;
class CCandUIFilterEventSink;
class CCandUIExtButtonEventSink;
class CSapiAlternativeList ;

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

class CFunction
{
public:
    CFunction(CSapiIMX *pImx);
    ~CFunction();

protected:
    BOOL GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp);

    HRESULT _GetLangIdFromRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID *plangid);

friend CSapiIMX;
    CSapiIMX    *m_pImx;
    long        m_cRef;
};

//
// The member functions in this class are extracted from CFnReconversion,
// We create this new class for a separate functionality that computes best prop range
// for the given selected range.
// This Class could be inherited by CFnReconversion and CSapiPlayBack.
//
class __declspec(novtable) CBestPropRange  
{

public:
    CBestPropRange( )
    {
        m_MaxCandChars = 0;
    }

    ~CBestPropRange( )
    {  
    }

    HRESULT _ComputeBestFitPropRange(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, ITfRange **ppBestPropRange, ULONG *pulStart,  ULONG *pulcElem);    
    ULONG   _GetMaxCandidateChars( );

private:
    ULONG          m_MaxCandChars;
};


class CFnReconversion : public ITfFnReconversion,
                        public CFunction,
                        public CMasterLMWrap,
                        public CBestPropRange
{
public:
    CFnReconversion(CSapiIMX *psi);
    ~CFnReconversion();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnReconversion
    //
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable);
    STDMETHODIMP GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList);
    STDMETHODIMP Reconvert(ITfRange *pRange);
    
    static HRESULT SetResult(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);
    static HRESULT SetOption(ITfContext *pic, ITfRange *pRange, CCandidateString *pCand, TfCandidateResult imcr);

    HRESULT _Reconvert(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL *pfCallLMReconvert);

    HRESULT _GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList, BOOL fDisableEngine = FALSE);

    HRESULT _QueryReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange);
    
    void _SetCurrentLangID(LANGID langid) { m_langid = langid;}
    
    HRESULT GetCandidateForRange(CSapiAlternativeList *psal, ITfContext *pic, ITfRange *pRange, ITfCandidateList **ppCandList) ;

    void _Commit(CCandidateString *pcand);

    CSapiAlternativeList  *GetCSapiAlternativeList(  )  { return m_psal; }

    HRESULT CFnReconversion::_GetSapilayrEngineInstance(ISpRecognizer **ppRecoEngine);

    friend CCandUIFilterEventSink;
    friend CCandUIExtButtonEventSink;

    // TABLET PC
    HRESULT GetTabletTip(void);
    CComPtr<ITipWindow>     m_cpTabletTip;

private:
    HRESULT ShowCandidateList(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfCandidateList *pCandList);
    
    LANGID         m_langid;
    CSapiAlternativeList  *m_psal;

    CComPtr<ISpRecoResult>  m_cpRecoResult;

};


class CCandUIFilterEventSink : public ITfCandUIAutoFilterEventSink
{
public:
    CCandUIFilterEventSink(CFnReconversion *pfnReconv, ITfContext *pic, ITfCandidateUI *pCandUI)
    {
        m_pic = pic;
        m_pic->AddRef();
        m_pfnReconv = pfnReconv;
        m_pfnReconv->AddRef();

        m_pCandUI = pCandUI;
        m_cRef = 1;
    }

    ~CCandUIFilterEventSink()
    {
        SafeRelease(m_pic);
        SafeRelease(m_pfnReconv);
    }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfCandUIAutoFilterEventSink
    //
    STDMETHODIMP OnFilterEvent(CANDUIFILTEREVENT ev);
//    STDMETHODIMP OnAddCharToFilterStringEvent(CANDUIFILTEREVENT ev, WCHAR  wch, int nItemVisible, BOOL *bEten);
    
    ITfContext *m_pic;
private:
    CFnReconversion *m_pfnReconv;
    ITfCandidateUI  *m_pCandUI;
    
    long     m_cRef;
};

class CSapiAlternativeList
{
public:
    CSapiAlternativeList(LANGID langid, ITfRange *pRange, ULONG  ulMaxCandChars);
    ~CSapiAlternativeList();
    
    int GetNumItem();

    HRESULT SetPhraseAlt(CRecoResultWrap *pResWrap, ISpPhraseAlt **ppAlt, ULONG cAlt, ULONG ulStart, ULONG ulcElem, WCHAR  *pwszParent);
    HRESULT GetCachedAltInfo(ULONG nId, ULONG *pulParentStart, ULONG *pulcParentElements, ULONG *pulcElements, WCHAR **ppwszText, ULONG *pulLeadSpaceRemoved=NULL);

    HRESULT GetAlternativeText(ISpPhraseAlt *pAlt, SPPHRASE *pPhrases, BOOL  fFirstAlt, ULONG  ulStartElem, ULONG ulNumElems, WCHAR *pwszAlt, int cchAlt, ULONG *pulLeadSpaceRemoved);
    HRESULT GetProbability(int nId, int * nProb);
    
    HRESULT AddLMAlternates(CLMAlternates *pLMAlt);
    
    BOOL    IsSameRange(ITfRange *pRange, TfEditCookie ec)
    {
        Assert(m_cpRange);
        BOOL fEq = FALSE;
        
        HRESULT hr = pRange->IsEqualStart(ec,
                                          m_cpRange,
                                          TF_ANCHOR_START,
                                          &fEq);
        if (S_OK == hr )
        {
            if (fEq)
            {
                hr =  pRange->IsEqualEnd(ec,
                                         m_cpRange,
                                         TF_ANCHOR_END,
                                         &fEq);
            }
        }
        return S_OK == hr && fEq;
    }
    
    void _Commit(ULONG nIdx, ISpRecoResult *pRecoResult);

    // Keep the current selection index
    //
    void _SaveCurrentSelectionIndex(ULONG  ulIndexSelect)
    {
        m_ulIndexSelect = ulIndexSelect;
    }

    void _Speak(void)
    {
        if( m_cpwrp )
        {
            ULONG   ulParentStart=0, ulParentNumElems=0;

            if ( S_OK == GetCachedAltInfo(m_ulIndexSelect, &ulParentStart, &ulParentNumElems, NULL, NULL) )
            {
                m_cpwrp->_SpeakAudio(ulParentStart, ulParentNumElems);
            }
        }
    }
    
    HRESULT _ProcessTrailingSpaces(SPPHRASE *pPhrases, ULONG  ulNextElem, WCHAR *pwszAlt);

    CRecoResultWrap *GetResultWrap() { return m_cpwrp; }
    
    BOOL _GetUIFont(BOOL  fVerticalWriting, LOGFONTW * plf);

    BOOL _IsFirstAltInCandidate( ) { return m_fFirstAltInCandidate; }
    BOOL _IsNoAlternate( ) { return m_fNoAlternate; }

    int  _GetFakeAltIndex( ) { return m_iFakeAlternate; }
   
private:
    int   m_nItem;
    ULONG m_ulStart;
    ULONG m_ulcElem;

    ISpPhraseAlt         **m_ppAlt;
    ULONG                  m_cAlt;
    CComPtr<ITfRange>      m_cpRange;

    CPtrArray<CLMAlternates> *m_prgLMAlternates;
    typedef struct
    {
        ULONG     ulParentStart;
        ULONG     ulcParentElements;
        ULONG     ulcElements;
        ULONG     ulLeadSpaceRemoved;   // the number of leading space to remove.
        WCHAR     *pwszAltText;
    } SPELEMENTUSED;
    CStructArray<SPELEMENTUSED> m_rgElemUsed;
    
    LANGID                   m_langid;
    CComPtr<CRecoResultWrap> m_cpwrp;

    BOOL                     m_fFirstAltInCandidate; 
    BOOL                     m_fNoAlternate;

    int                      m_iFakeAlternate;

    ULONG                    m_MaxCandChars;
    ULONG                    m_ulIndexSelect;  // keep the index of the current selection in the candidate Window.
};


#define    NO_FAKEALT       -1

#endif // FNRECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\hwxink.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#define iverbInkRecog 351
#define iverbInkAlternates 352

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/


#ifndef __HWXInk_h__
#define __HWXInk_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITfRange_FWD_DEFINED__
#define __ITfRange_FWD_DEFINED__
typedef interface ITfRange ITfRange;
#endif 	/* __ITfRange_FWD_DEFINED__ */

#ifndef __IInk_FWD_DEFINED__
#define __IInk_FWD_DEFINED__
typedef interface IInk IInk;
#endif 	/* __IInk_FWD_DEFINED__ */


#ifndef __ILineInfo_FWD_DEFINED__
#define __ILineInfo_FWD_DEFINED__
typedef interface ILineInfo ILineInfo;
#endif 	/* __ILineInfo_FWD_DEFINED__ */

#ifndef __IThorFnConversion_FWD_DEFINED__
#define __IThorFnConversion_FWD_DEFINED__
typedef interface IThorFnConversion IThorFnConversion;
#endif 	/* __IThorFnConversion_FWD_DEFINED__ */

#ifndef __Ink_FWD_DEFINED__
#define __Ink_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ink Ink;
#else
typedef struct Ink Ink;
#endif /* __cplusplus */

#endif 	/* __Ink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_HWXInk_0000 */
/* [local] */ 

typedef struct  tagINKMETRIC
    {
    UINT iHeight;
    UINT iFontAscent;
    UINT iFontDescent;
    UINT iWeight;
    BOOL fFontHDC;
    DWORD dwAmbientProps;
    COLORREF color;
    BOOL fItalic;
    UINT nItalicPitch;
    DWORD dwReserved;
    }	INKMETRIC;

typedef struct  tagSTROKEHEADER
    {
    UINT cByteCount;
    UINT cByteOffset;
    DWORD dwFlags;
    RECT rectBounds;
    }	STROKEHEADER;

typedef struct  tagSTROKE
    {
    UINT cPoints;
    BOOL fUpStroke;
    POINT __RPC_FAR *pPoints;
    UINT __RPC_FAR *pPressure;
    UINT __RPC_FAR *pTime;
    UINT __RPC_FAR *pAngle;
    }	STROKE;

typedef struct  tagSTROKELIST
    {
    UINT cStrokes;
    STROKE __RPC_FAR *pStrokes;
    }	STROKELIST;


enum __MIDL___MIDL_itf_HWXInk_0000_0001
    {	LOSSY	= 0x1,
	LOSSLESS	= 0x2,
	XYPOINTS	= 0x4,
	PRESSURE	= 0x8,
	TIME	= 0x10,
	ANGLE	= 0x20
    };


extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_s_ifspec;

#ifndef __IInk_INTERFACE_DEFINED__
#define __IInk_INTERFACE_DEFINED__

/* interface IInk */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IInk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03F8E511-43A1-11D3-8BB6-0080C7D6BAD5")
    IInk : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInk __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInk __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInk __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInk __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInk __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IInkVtbl;

    interface IInk
    {
        CONST_VTBL struct IInkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInk_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInk_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInk_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInk_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInk_INTERFACE_DEFINED__ */


#ifndef __ILineInfo_INTERFACE_DEFINED__
#define __ILineInfo_INTERFACE_DEFINED__

/* interface ILineInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILineInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C1C5AD5-F22F-4DE4-B453-A2CC482E7C33")
    ILineInfo : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInkExtent( 
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TopCandidates( 
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recognize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPoints( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILineInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILineInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILineInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInkExtent )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TopCandidates )( 
            ILineInfo __RPC_FAR * This,
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Recognize )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPoints )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight);
        
        END_INTERFACE
    } ILineInfoVtbl;

    interface ILineInfo
    {
        CONST_VTBL struct ILineInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILineInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILineInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILineInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILineInfo_SetFormat(This,pim)	\
    (This)->lpVtbl -> SetFormat(This,pim)

#define ILineInfo_GetFormat(This,pim)	\
    (This)->lpVtbl -> GetFormat(This,pim)

#define ILineInfo_GetInkExtent(This,pim,pnWidth)	\
    (This)->lpVtbl -> GetInkExtent(This,pim,pnWidth)

#define ILineInfo_TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)	\
    (This)->lpVtbl -> TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)

#define ILineInfo_Recognize(This)	\
    (This)->lpVtbl -> Recognize(This)

#define ILineInfo_SetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> SetStroke(This,iStroke,pStroke)

#define ILineInfo_GetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> GetStroke(This,iStroke,pStroke)

#define ILineInfo_AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)	\
    (This)->lpVtbl -> AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetInkExtent_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim,
    UINT __RPC_FAR *pnWidth);


void __RPC_STUB ILineInfo_GetInkExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_TopCandidates_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT nCandidateNum,
    BSTR __RPC_FAR *pbstrRecogWord,
    UINT __RPC_FAR *pcchRecogWord,
    LONG fAllowRecog,
    LONG fForceRecog);


void __RPC_STUB ILineInfo_TopCandidates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_Recognize_Proxy( 
    ILineInfo __RPC_FAR * This);


void __RPC_STUB ILineInfo_Recognize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_SetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_GetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_AddPoints_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke,
    BOOL fUpStroke,
    UINT nFrameHeight);


void __RPC_STUB ILineInfo_AddPoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILineInfo_INTERFACE_DEFINED__ */

#ifndef __IThorFnConversion_INTERFACE_DEFINED__
#define __IThorFnConversion_INTERFACE_DEFINED__

/* interface IThorFnConversion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IThorFnConversion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62130000-ED22-4015-B038-A04CD0866E69")
    IThorFnConversion : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Convert( 
            /* [in] */ ITfRange __RPC_FAR *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThorFnConversionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IThorFnConversion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IThorFnConversion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )( 
            IThorFnConversion __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryRange )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Convert )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange);
        
        END_INTERFACE
    } IThorFnConversionVtbl;

    interface IThorFnConversion
    {
        CONST_VTBL struct IThorFnConversionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThorFnConversion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThorFnConversion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThorFnConversion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThorFnConversion_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define IThorFnConversion_QueryRange(This,pRange,ppNewRange,pfConvertable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfConvertable)

#define IThorFnConversion_Convert(This,pRange)	\
    (This)->lpVtbl -> Convert(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IThorFnConversion_QueryRange_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange,
    /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
    /* [out] */ BOOL __RPC_FAR *pfConvertable);


void __RPC_STUB IThorFnConversion_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThorFnConversion_Convert_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange);


void __RPC_STUB IThorFnConversion_Convert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IThorFnConversion_INTERFACE_DEFINED__ */

#ifndef __HWXINKLib_LIBRARY_DEFINED__
#define __HWXINKLib_LIBRARY_DEFINED__

/* library HWXINKLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HWXINKLib;

EXTERN_C const CLSID CLSID_Ink;

#ifdef __cplusplus

class DECLSPEC_UUID("13DE4A42-8D21-4C8E-BF9C-8F69CB068FCA")
Ink;
#endif
#endif /* __HWXINKLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\icpriv.h ===
//
// icpriv.h
//

#pragma once


//
// Input Context private data storage
// < would be the place to store C&C grammar >
//
class CICPriv : public IUnknown
{
public:
    CICPriv (ITfContext *pic)
    {
        _pic = pic;
        _cRefCompositions = 0;
        _cRef = 1;
    }

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    void _AddRefComposition() { _cRefCompositions++; }
    void _ReleaseComposition() 
    { 
        if ( _cRefCompositions > 0)
            _cRefCompositions--; 
    }

    LONG _GetCompositionCount() { return _cRefCompositions; }

    CTextEventSink *m_pTextEvent;
    TfClientId _tid;
    ITfContext *_pic; // not AddRef'd!
    DWORD m_dwEditCookie;
    DWORD m_dwLayoutCookie;
    LONG _cRefCompositions;
    LONG _cRef;
};

CICPriv *GetInputContextPriv(TfClientId tid, ITfContext *pic);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\ids.h ===
// IDs and flags defined for SAPI TFX

#ifndef IDS_H

#define IDS_H

#define ESCB_PROCESSTEXT  0
#define ESCB_ATTACHAUDIO  1
#define ESCB_ATTACHRESULT 2
#define ESCB_FEEDBACKUI   3
#define ESCB_KILLFEEDBACKUI   4
#define ESCB_KILLLASTPHRASE   5

#define ESCB_MAKERESULTSTRING           6
#define ESCB_CONVERT      7
#define ESCB_REVERT       8
#define ESCB_ABORT        9
#define ESCB_COMPLETE    10
#define ESCB_PROCESS_ALTERNATE_TEXT   11
#define ESCB_ATTACHRECORESULTOBJ      12
#define ESCB_SYNCMBWITHSEL            13
#define ESCB_GETRANGETEXT             14
#define ESCB_ISRANGEEMPTY             15
#define ESCB_HANDLEHYPOTHESIS         16
#define ESCB_HANDLERECOGNITION        17
#define ESCB_HANDLESPACES             18
#define ESCB_DETECTFEEDBACKUI         19

#define ESCB_PLAYBK_PLAYSND           20
#define ESCB_RECONV_QUERYRECONV       21
#define ESCB_RECONV_GETRECONV         22
#define ESCB_RECONV_RECONV            23
#define ESCB_PLAYBK_PLAYSNDSELECTION  24
#define ESCB_RECONV_ONIP              25
#define ESCB_FINALIZECOMP             26
#define ESCB_PROCESSTEXT_NO_OWNERID   27
#define ESCB_FINALIZE_ALL_COMPS       28

#define ESCB_UPDATEFILTERSTR          30

#define ESCB_PROP_DIVIDE              40
#define ESCB_PROP_TEXTUPDATE          41
#define ESCB_PROP_SHRINK              42

#define ESCB_HANDLE_ADDDELETE_WORD    50
#define ESCB_HANDLE_LEARNFROMDOC      51
#define ESCB_LEARNDOC_NEXTRANGE       52


#define ESCB_PROCESSCONTROLKEY        60
#define ESCB_FEEDCURRENTIP            61

#define ESCB_SETREPSELECTION          70
#define ESCB_SAVECURIP_ADDDELETEUI    71

#define ESCB_PROCESSSELECTWORD        80
#define ESCB_UPDATE_TEXT_BUFFER       81
#define ESCB_PROCESS_CAP_COMMANDS     82

#define ESCB_TTS_PLAY                 90

#define ESCB_RESTORE_CORRECT_ORGIP    100
#define ESCB_PROCESS_EDIT_COMMAND     110
#define ESCB_PROCESS_SPELL_THAT       111
#define ESCB_PROCESS_SPELL_IT         112
#define ESCB_PROCESS_MODEBIAS_TEXT    113

#define ESCB_INJECT_SPELL_TEXT        120
#define ESCB_HANDLE_MOUSESINK         121

// status flags
#define SAPILAYR_STAT_GETAUDIO 0x0100
#define SAPILAYR_STAT_DICTON   0x0200
#define SAPILAYR_STAT_PLAYBACK 0x0400
#define SAPILAYR_STAT_WHATEVER 0x0800

// res ids
#define ID_ICON_DICTON         1
#define ID_ICON_DICTOFF        2
#define ID_ICON_AUDIOON        3
#define ID_ICON_AUDIOOFF       4
#define ID_ICON_CFGMENU        5
#define ID_ICON_MICROPHONE     6
#define ID_ICON_COMMANDING     7
#define ID_ICON_DICTATION      8
#define ID_ICON_TTSPLAY        9
#define ID_ICON_TTSSTOP        10
#define ID_ICON_TTSPAUSE       11
#define ID_ICON_MIC_PROPPAGE   12

// grammar ids
#define GRAM_ID_DICT           1 // general dictation grammar id
#define GRAM_ID_CCDICT         2 // dictation command grammar id
#define GRAM_ID_NUMMODE        3 // mode bias grammar id
#define GRAM_ID_TBCMD          4 // grammar id for toolbar C&C
#define GRAM_ID_SPELLING       5 // grammar id for spelling
#define GRAM_ID_CMDSHARED      6 // grammar id for shared commands available for both Dictation and command mode.
#define GRAM_ID_SLEEP          7 // dynamical grammar for "Go to Sleep" and "Wakeup"

#define GRAM_ID_URLSPELL       8 // grammar id for spelling used in url mode

#define RULE_ID_TBCMD          10 // grammar rule id for toolbar
#define RULE_ID_URLHIST        11 // grammar rule id for url history

// string ids


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
#define IDS_CMD_FILE           100
#define IDS_NUMMODE_CMD_FILE   101
#define IDS_SHARDCMD_FILE      102

#define IDS_INT_NONE           200
#define IDS_INT_NOISE          201
#define IDS_INT_NOSIGNAL       202
#define IDS_INT_TOOLOUD        203
#define IDS_INT_TOOQUIET       204
#define IDS_INT_TOOFAST        205
#define IDS_INT_TOOSLOW        206

#define IDS_INTTOOLTIP_NONE           210
#define IDS_INTTOOLTIP_NOISE          211
#define IDS_INTTOOLTIP_NOSIGNAL       212
#define IDS_INTTOOLTIP_TOOLOUD        213
#define IDS_INTTOOLTIP_TOOQUIET       214
#define IDS_INTTOOLTIP_TOOFAST        215
#define IDS_INTTOOLTIP_TOOSLOW        216
#define IDS_DICTATING                 217
#define IDS_DICTATING_TOOLTIP         218

#define IDS_UI_TRAINING        300
#define IDS_UI_ADDDELETE       301

// menu strings
#define IDS_MIC_DIS_DICTCMD    390 
#define IDS_MIC_OPTIONS        400
#define IDS_MIC_TRAINING       401
#define IDS_MIC_ADDDELETE      402
#define IDS_MIC_CURRENTUSER    403
#define IDS_MIC_SAVEDATA       404


#define IDS_NUI_CFGMENU_TOOLTIP     405
#define IDS_NUI_CFGMENU_TEXT        406
#define IDS_NUI_BALLOON_TOOLTIP     407
#define IDS_NUI_BALLOON_TEXT        408
#define IDS_NUI_MICROPHONE_TOOLTIP  409
#define IDS_NUI_MICROPHONE_TEXT     410
#define IDS_NUI_COMMANDING_TOOLTIP  411
#define IDS_NUI_COMMANDING_TEXT     412
#define IDS_NUI_DICTATION_TOOLTIP   413
#define IDS_NUI_DICTATION_TEXT      414
#define IDS_NUI_STARTINGSPEECH      415
#define IDS_NUI_BEGINDICTATION      416
#define IDS_NUI_BEGINVOICECMD       417

#define IDS_MIC_SHOWBALLOON         420
#define IDS_MIC_CUASSTATUS          421

#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
#define IDS_NUI_MICROPHONE_ON_TOOLTIP  430
#define IDS_NUI_MICROPHONE_OFF_TOOLTIP  431
#endif

#define IDS_NUI_TTSPLAY_TOOLTIP     450
#define IDS_NUI_TTSPLAY_TEXT        451
#define IDS_NUI_TTSSTOP_TOOLTIP     452
#define IDS_NUI_TTSSTOP_TEXT        453
#define IDS_NUI_TTSPAUSE_TOOLTIP    454
#define IDS_NUI_TTSPAUSE_TEXT       455
#define IDS_NUI_TTSRESUME_TOOLTIP   456
#define IDS_NUI_TTSRESUME_TEXT      457

#define IDS_NO_ALTERNATE            500

#define IDS_DEFAULT_PROFILE         600

#define IDS_LISTENING                       700
#define IDS_LISTENING_TOOLTIP               701
#define IDS_BALLOON_DICTAT_PAUSED           702
#define IDS_BALLOON_TOOLTIP_IP_INSIDE_WORD  703
#define IDS_BALLOON_TOOLTIP_TYPING          704

#define IDS_CANDBTN_HELP_TOOLTIP            720               
#define IDS_CANDBTN_DELETE_TOOLTIP          721
#define IDS_CANDBTN_PREVIOUS_TOOLTIP        722
#define IDS_CANDBTN_NEXT_TOOLTIP            723 
#define IDS_CANDBTN_PLAY_TOOLTIP            724  

#define IDS_GO_TO_SLEEP                     750
#define IDS_WAKE_UP                         751

#define IDS_PROPERTYPAGE_TITLE          760
#define IDS_HELPFILESpPropPage          761
#define IDS_DOCSTRINGSpPropPage         762

#define IDS_SPCMD_SELECT_ALL            800
#define IDS_SPCMD_SELECT_THAT           801

#define IDS_REPLAY                      810
#define IDS_DELETE                      811
#define IDS_REDO                        812

#define IDS_CUAS_RESTART_TITLE          850
#define IDS_CUAS_RESTART_CUASON         851
#define IDS_CUAS_RESTART_CUASOFF        852

// widget
#define IDS_PROJNAME                    900
#define IDI_INVOKE                      902
#define IDS_ADDTODICTIONARYPREFIX       902
#define ID_HIDETIMER                    903
#define IDS_ADDTODICTIONARYPOSTFIX      903
#define ID_FADETIMER                    904
#define IDS_DELETESELECTION             904
#define ID_MOUSELEAVETIMER              905

#define IDI_DELETEICON                  911
#define IDI_INVOKECLOSE                 913
// cfgs
#define ID_DICTATION_COMMAND_CFG       200
#define ID_NUMMODE_COMMAND_CFG         201
#define ID_SPELLING_TOPIC_CFG          202 
#define ID_SHAREDCMD_CFG               203

// timer ID
#define TIMER_ID_OPENCLOSE     101
#define TIMER_ID_CHARTYPED     102


// menu IDs
#define IDM_MIC_ONOFF                  1
#define IDM_MIC_OPTIONS                2
#define IDM_MIC_SHAREDENGINE           3
#define IDM_MIC_INPROCENGINE           4
#define IDM_MIC_TRAINING               5
#define IDM_MIC_ADDDELETE              6
#define IDM_MIC_CURRENTUSER            8
#define IDM_MIC_SAVEDATA               9
#define IDM_MIC_SHOWBALLOON            10
#define IDM_MIC_DIS_DICTCMD            11
#define IDM_MIC_CUASSTATUS             12


#define IDM_MIC_USERSTART            100
#define IDM_MIC_USEREND              200

// private messages
#define WM_PRIV_FEEDCONTEXT      WM_APP+0
#define WM_PRIV_LBARSETFOCUS     WM_APP+1
#define WM_PRIV_SPEECHOPTION     WM_APP+2
#define WM_PRIV_ONSETTHREADFOCUS WM_APP+3
#define WM_PRIV_SPEECHOPENCLOSE  WM_APP+4
#define WM_PRIV_OPTIONS          WM_APP+5
#define WM_PRIV_ADDDELETE        WM_APP+6
#define WM_PRIV_DORECONVERT      WM_APP+7

// lbarsystemmenuitem
#define IDM_CUSTOM_MENU_START       7000

// Dialog ID
#define IDD_OPEN_ADD_DELETE         1000
#define IDD_PROPERTY_PAGE           1001
#define IDD_PP_DIALOG_ADVANCE       1002
#define IDD_PP_DIALOG_BUTTON_SET    1003

// Item Id in the property page dialog

#define IDC_GP_VOICE_COMMANDS       2000
#define IDC_GP_MODE_BUTTONS         2001

#define IDC_PP_SHOW_BALLOON         2010
#define IDC_PP_LMA                  2011
#define IDC_PP_HIGH_CONFIDENCE      2012
#define IDC_PP_SAVE_SPDATA          2013
#define IDC_PP_REMOVE_SPACE         2014
#define IDC_PP_DIS_DICT_TYPING      2015
#define IDC_PP_PLAYBACK             2016
#define IDC_PP_DICT_CANDUI_OPEN     2017
#define IDC_PP_DICTCMDS             2018
#define IDC_PP_ASSIGN_BUTTON        2019

#define IDC_PP_BUTTON_MB_SETTING    2020

#define IDC_PP_BUTTON_ADVANCE       2030
#define IDC_PP_BUTTON_LANGBAR       2031
#define IDC_PP_BUTTON_SPCPL         2032

#define IDC_DESCRIPT_TEXT           (-1)

// For voice command Setting dialog

#define IDC_GP_ADVANCE_SET          2100

#define IDC_PP_SELECTION_CMD        2110
#define IDC_PP_NAVIGATION_CMD       2111
#define IDC_PP_CASING_CMD           2112
#define IDC_PP_EDITING_CMD          2113
#define IDC_PP_KEYBOARD_CMD         2114
#define IDC_PP_LANGBAR_CMD          2115
#define IDC_PP_TTS_CMD              2116

//#define IDC_PP_MAXNUM_ALTERNATES    2118
//#define IDC_PP_MAXCHARS_ALTERNATE   2119

#define IDC_PP_DICTATION_CMB        2200
#define IDC_PP_COMMAND_CMB          2201

// Candidate UI Buttons ID

#define ID_CANDBTN_HELP             100
#define ID_CANDBTN_DELETE           101
//#define ID_CANDBTN_PREVIOUS         102
//#define ID_CANDBTN_NEXT             103
#define ID_CANDBTN_PLAY             104

#endif // IDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "osver.h"
#include "mui.h"

DECLARE_OSVER();

//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 1)
        goto Exit;

    fRet = TFInitLib();
    InitOSVer();

Exit:
    LeaveCriticalSection(GetServerCritSec());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process deattach, like
// FreeLibrary calls.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 0)
        goto Exit;

    TFUninitLib();
    MuiFlushDlls(g_hInst);

Exit:
    LeaveCriticalSection(GetServerCritSec());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "initguid.h"
#include "mscandui.h"
#include "globals.h"

HINSTANCE g_hInst = NULL;
HINSTANCE g_hInstSpgrmr = NULL;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

DWORD g_dwTlsIndex = -1;

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

//custom property:a414addd-3982-40d5-a664-d4f5de039305 
const GUID GUID_PROP_SAPIRESULTOBJECT = {
    0xa414addd,
    0x3982,
    0x40d5,
    { 0xa6, 0x64, 0xd4, 0xf5, 0xde, 0x03, 0x93, 0x05}
};


/* 46b283a4-4a22-4ced-8ff4-7814cac68e3c */
const GUID GUID_PROP_SAPI_DISPATTR = {
    0x46b283a4,
    0x4a22,
    0x4ced,
    {0x8f, 0xf4, 0x78, 0x14, 0xca, 0xc6, 0x8e, 0x3c}
  };

/* 48a9d381-06eb-4839-a50b-19703269587a */
const GUID GUID_ATTR_SAPI_INPUT = { 
    0x48a9d381,
    0x06eb,
    0x4839,
    {0xa5, 0x0b, 0x19, 0x70, 0x32, 0x69, 0x58, 0x7a}
  };
  
const GUID GUID_ATTR_SAPI_GREENBAR = {
    0x82e6d2c0,
    0x6028,
    0x11d3,
    {0xb5, 0xd6, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}
};

const GUID GUID_ATTR_SAPI_GREENBAR2 = {
    0xc3a9e2e8,
    0x738c,
    0x48e0,
    {0xac, 0xc8, 0x43, 0xee, 0xfa, 0xbf, 0x83, 0xc8}
};

const GUID GUID_ATTR_SAPI_REDBAR = {
    0xb1ec93ca,
    0x6028,
    0x11d3,
    {0xb5, 0xd6, 0x00, 0xc0, 0x4f, 0xc3, 0x24, 0xa1}
};

const GUID GUID_ATTR_SAPI_SELECTION = { 
    0xb3c0ef25,
    0xa12f,
    0x4b0e,
    {0xa9, 0x8f, 0x11, 0x63, 0x11, 0xb3, 0xd6, 0x81}
};

/* A91DF761-C6F0-4E12-922A-7E24BFEBFF20 */
const GUID GUID_IC_PRIVATE = { 
    0xA91DF761,
    0xC6F0,
    0x4E12,
    {0x92, 0x2A, 0x7E, 0x24, 0xBF, 0xEB, 0xFF, 0x20}
  };

/* 536402D1-26EA-4024-B890-1004CAE3C1BE */
const GUID GUID_COMPARTMENT_SPEECHPRIV_REFCNT = {
    0x536402D1,
    0x26EA,
    0x4024,
    {0xB8, 0x90, 0x10, 0x04, 0xCA, 0xE3, 0xC1, 0xBE}
};

/* 2f1e5e65-67db-4dbd-b793-7d8d07df248c */
const GUID GUID_COMPARTMENT_SPEECH_LEARNDOC = {
    0x2f1e5e65,
    0x67db,
    0x4dbd,
    {0xb7, 0x93, 0x7d, 0x8d, 0x07, 0xdf, 0x24, 0x8c }
};

/* cd7e8074-9ef6-4298-b76e-bfa9aca40e3b */
const GUID GUID_COMPARTMENT_TTS_STATUS = {
    0xcd7e8074,
    0x9ef6,
    0x4298,
    {0xb7, 0x6e, 0xbf, 0xa9, 0xac, 0xa4, 0x0e, 0x3b}
};

/* e9cee003-2d38-42da-8cb5-e16c3483f8c4 */
const GUID GUID_HOTKEY_TTS_PLAY_STOP = {
    0xe9cee003,
    0x2d38,
    0x42da,
    {0x8c, 0xb5, 0xe1, 0x6c, 0x34, 0x83, 0xf8, 0xc4}
};

/* 1dcadf31-a8e7-49eb-a255-512c9fa9365b */
const GUID GUID_HOTKEY_MODE_DICTATION = {
    0x1dcadf31,
    0xa8e7,
    0x49eb,
    {0xa2, 0x55, 0x51, 0x2c, 0x9f, 0xa9, 0x36, 0x5b}
};

/* a41656ec-a369-4aec-a5bc-769c3d32ccaf */
const GUID GUID_HOTKEY_MODE_COMMAND = {
    0xa41656ec,
    0xa369,
    0x4aec,
    {0xa5, 0xbc, 0x76, 0x9c, 0x3d, 0x32, 0xcc, 0xaf}
};

/* c1a1554f-b715-48e1-921f-716fd7332ce9 */
const GUID GUID_COMPARTMENT_SHARED_BLN_TEXT = {
    0xc1a1554f,
    0xb715,
    0x48e1,
    {0x92, 0x1f, 0x71, 0x6f, 0xd7, 0x33, 0x2c, 0xe9}
};

/* 574e41bb-1bf4-4630-95dd-b143372ac8d0 */
const GUID  GUID_COMPARTMENT_SPEECHUISHOWN = {
    0x574e41bb,
    0x1bf4,
    0x4630,
    {0x95, 0xdd, 0xb1, 0x43, 0x37, 0x2a, 0xc8, 0xd0}
  };

// TABLETPC

/* e7912cf8-5f71-4483-bcb8-fd87de9168e3 */
const GUID GUID_COMPARTMENT_SPEECH_STAGE =       { 
    0xe7912cf8, 
    0x5f71, 
    0x4483, 
    {0xbc, 0xb8, 0xfd, 0x87, 0xde, 0x91, 0x68, 0xe3 } 
};

/* 8d5ee345-e891-4184-8baf-e201c8c6903a */
const GUID GUID_COMPARTMENT_SPEECH_STAGECHANGE = { 
    0x8d5ee345, 
    0xe891, 
    0x4184, 
    {0x8b, 0xaf, 0xe2, 0x01, 0xc8, 0xc6, 0x90, 0x3a } 
};

// {B2B398FC-35AC-4cec-9BE8-F4EFD1738CF3}
const GUID GUID_COMPARTMENT_SPEECH_STAGEDICTATION = {
    0xb2b398fc, 
    0x35ac, 
    0x4cec, 
    {0x9b, 0xe8, 0xf4, 0xef, 0xd1, 0x73, 0x8c, 0xf3 } 
};

// {054AAE20-4BEA-4347-8A35-64A533254A9D}
const GUID CLSID_UIHost = {
    0x054AAE20,
    0x4BEA,
    0x4347,
    { 0x8A,0x35,0x64,0xA5,0x33,0x25,0x4A,0x9D }
};
// END TABLETPC

/* 772ce27f-8c06-4170-a75a-dd4c3103cce2 */
const GUID GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE = {
    0x772ce27f,
    0x8c06,
    0x4170,
    {0xa7, 0x5a, 0xdd, 0x4c, 0x31, 0x03, 0xcc, 0xe2}
};

/* E7BA80B1-71E6-4EF0-A429-2599A25973FA */
const GUID CLSID_SpPropertyPage = {
    0xE7BA80B1,
    0x71E6,
    0x4EF0,
    {0xA4, 0x29, 0x25, 0x99, 0xA2, 0x59, 0x73, 0xFA}
};


// widget stuff

// {8613E14C-D0C0-4161-AC0F-1DD2563286BC}
const CLSID CLSID_CorrectionIMX = 
{ 0x8613e14c, 0xd0c0, 0x4161, { 0xac, 0xf, 0x1d, 0xd2, 0x56, 0x32, 0x86, 0xbc } };

// miscs
const LARGE_INTEGER c_li0 = { 0, 0 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\keyevent.cpp ===
//
//
// Sapilayr TIP Key event related functions.
//
//
#include "private.h"
#include "sapilayr.h"
#include "nui.h"
#include "keyevent.h"
#include "cregkey.h"

//
// hot key for TTS Play/Stop.
const KESPRESERVEDKEY g_prekeyList[] =
{
    { &GUID_HOTKEY_TTS_PLAY_STOP,    { 'S',  TF_MOD_WIN },   L"TTS Speech" },
    { NULL,  { 0,    0}, NULL }
};

KESPRESERVEDKEY g_prekeyList_Mode[] = 
{
    { &GUID_HOTKEY_MODE_DICTATION, {VK_F11 , 0}, L"Dictation Button" },
    { &GUID_HOTKEY_MODE_COMMAND,   {VK_F12 , 0}, L"Command Button" },
    { NULL,  { 0,    0}, NULL }
};


//+---------------------------------------------------------------------------
//
// CSptipKeyEventSink::RegisterEx:   Registr the special speech mode buttons.
//
//----------------------------------------------------------------------------

HRESULT CSptipKeyEventSink::_RegisterEx(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey)
{
    HRESULT hr;
    ITfKeystrokeMgr_P *pKeyMgr;

    if (FAILED(ptim->QueryInterface(IID_ITfKeystrokeMgr_P, (void **)&pKeyMgr)))
        return E_FAIL;

    hr = E_FAIL;

    while (pprekey->pguid)
    {
        if (FAILED(pKeyMgr->PreserveKeyEx(tid, 
                                        *pprekey->pguid,
                                        &pprekey->tfpk,
                                        pprekey->psz,
                                        wcslen(pprekey->psz),
                                        TF_PKEX_SYSHOTKEY | TF_PKEX_NONEEDDIM)))
            goto Exit;

        pprekey++;
    }

    ptim->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(pKeyMgr);
    return hr;
}


HRESULT CSapiIMX::_PreKeyEventCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv)
{
    CSapiIMX *_this = (CSapiIMX *)pv;
    CSpeechUIServer *pSpeechUIServer;
    BOOL            fButtonEnable;

    TraceMsg(TF_SPBUTTON, "_PreKeyEventCallback is called");

    *pfEaten = FALSE;
    if (_this == NULL)
        return S_OK;

    pSpeechUIServer = _this->GetSpeechUIServer( );

    if (!pSpeechUIServer)
        return S_OK;

    fButtonEnable = pSpeechUIServer->GetTtsButtonStatus( );

    if (IsEqualGUID(rguid, GUID_HOTKEY_TTS_PLAY_STOP))
    {
        if ( fButtonEnable )
        {
            _this->_HandleEventOnPlayButton( );
            *pfEaten = TRUE;
        }
    }
    else if ( IsEqualGUID(rguid, GUID_HOTKEY_MODE_DICTATION) ||
              IsEqualGUID(rguid, GUID_HOTKEY_MODE_COMMAND) )
    {
        if ( _this->_IsModeKeysEnabled( ) )
            *pfEaten = TRUE;
        else
            *pfEaten = FALSE;
    }

    TraceMsg(TF_SPBUTTON, "_PreKeyEventCallback fEaten=%d", *pfEaten);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _KeyEventCallback
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::_KeyEventCallback(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv)
{
    CSapiIMX *pimx;
    HRESULT hr = S_OK;
    CSapiIMX *_this = (CSapiIMX *)pv;

    *pfEaten = FALSE;

    Assert(uCode != KES_CODE_FOCUS); // we should never get this callback because we shouldn't take the keyboard focus

    if (!(uCode & KES_CODE_KEYDOWN))
        return S_OK; // only want key downs

    if (pic == NULL) // no focus ic?
        return S_OK;

    pimx = (CSapiIMX *)pv;

    *pfEaten = TRUE;

    switch (wParam & 0xFF)
    {
        case VK_F8:
        if (!(uCode & KES_CODE_TEST))
        {
            CSapiPlayBack *ppb;
            if (ppb = new CSapiPlayBack(pimx))
            {
                CPlayBackEditSession *pes;
                if (pes = new CPlayBackEditSession(ppb, pic))
                {
                    pes->_SetEditSessionData(ESCB_PLAYBK_PLAYSNDSELECTION, NULL, 0);
                  
                    pic->RequestEditSession(_this->_tid, pes, TF_ES_READ | TF_ES_SYNC, &hr);
                    pes->Release();
                }
                ppb->Release();
            }
        }
        break;
        case VK_ESCAPE:
        if (!(uCode & KES_CODE_TEST))
        {
            if (_this->m_pCSpTask)
                hr = _this->m_pCSpTask->_StopInput();
        }
        *pfEaten = FALSE;
        break;
        default:
        *pfEaten = FALSE;

#ifdef LONGHORN
        //
        // For english composition scenario, I'm trying to see if this works. 
        // Note that this is not the final design to support typing while
        // composing dictation. m_pMouseSink != NULL only when composition
        // is active so I'm overriding it as a flag. 
        //
        if (_this->GetLangID() == 0x0409)
        {
            if ((BYTE)wParam != VK_LEFT && (BYTE)wParam != VK_RIGHT 
            && (isprint((BYTE)wParam) 
                || (VK_OEM_1 <= (BYTE)wParam && (BYTE)wParam < VK_OEM_8)) 
            && _this->m_pMouseSink)
            {
                WCHAR wc[3];
                BYTE keystate[256];

                if (GetKeyboardState(keystate))
                {
                    if (ToUnicodeEx(wParam,(UINT)lParam, keystate, wc,
                                ARRAYSIZE(wc), 0, GetKeyboardLayout(NULL)) > 0)
                    {

                        *pfEaten = TRUE; // want this key only if there is 
                                         // a printable character

                        if (!(uCode & KES_CODE_TEST))
                        {
                            // we don't handle deadkeys here for now
                            wc[1] = L'\0';
                            // call InjectSpelledText() with fOwnerId == TRUE
                            hr = _this->InjectSpelledText(wc, _this->GetLangID(), TRUE);
                        }
                    }
                }
            }
        }
        break;
#endif
    }
  
    return hr;
}


//
//  ITfKeyTraceEventSink method functions.
//
//
STDAPI CSapiIMX::OnKeyTraceUp(WPARAM wParam,LPARAM lParam)
{
    // We just check KeyDown, ignore KeyUp event.
    // so just return S_OK immediately.

    TraceMsg(TF_SPBUTTON, "OnKeyTraceUp is called");

    UNREFERENCED_PARAMETER(lParam);
    HandleModeKeyEvent( (DWORD)wParam, FALSE);

    return S_OK;
}

//
// Take use this method to detect if user is typing 
//
// if it is typing, disable dictation rule temporally.
//
STDAPI CSapiIMX::OnKeyTraceDown(WPARAM wParam,LPARAM lParam)
{
    BOOL   fDictOn;

    TraceMsg(TF_SPBUTTON, "OnKeyTraceDown is called, wParam=%x", wParam);

    if ( HandleModeKeyEvent((DWORD)wParam, TRUE ))
    {
        // if the mode key is pressed, don't disable dictation as usual.
        return S_OK;
    }

    fDictOn = (GetOnOff( ) && GetDICTATIONSTAT_DictOnOff( ));

    if (fDictOn && !m_ulSimulatedKey && m_pCSpTask && 
        S_OK == IsActiveThread()) // Only want this to happen on the active thread which could be the stage.
    {
        // User is typing.
        //
        // Temporally disable Dictation if Dictation Mode is ON
        //

        if ( _NeedDisableDictationWhileTyping( ) )
        {
		    if ( _GetNumCharTyped( ) == 0 )
		    {
                m_pCSpTask->_SetDictRecoCtxtState(FALSE);
                m_pCSpTask->_SetRecognizerInterest(0);
                m_pCSpTask->_UpdateBalloon(IDS_BALLOON_DICTAT_PAUSED, IDS_BALLOON_TOOLTIP_TYPING);
	        }
            // 
            // and then start a timer to watch for the end of typing.
            //
            _SetCharTypeTimer( );
        }
    }

    if ( m_ulSimulatedKey > 0 )
        m_ulSimulatedKey --;

    return S_OK;
}


// +--------------------------------------------------------------------------
// HandleModeKeySettingChange
//
//   When any mode button setting is changed, such as mode button's
//   enable/disable status change, virtual keys for dictation and command
//   are changed, this function will respond for this change.
//
// ---------------------------------------------------------------------------
void CSapiIMX::HandleModeKeySettingChange(BOOL  fSetttingChanged )
{
    BOOL  fModeKeyEnabled = _IsModeKeysEnabled( );
    DWORD dwDictVirtKey = _GetDictationButton( );
    DWORD dwCommandVirtKey = _GetCommandButton( );

    if ( !fSetttingChanged || !_pkes )  return;

    // mode button setting is changed.

    // unregister the hotkey first if the keys were registered before.
    if ( m_fModeKeyRegistered )
    {
        _pkes->_Unregister(_tim, _tid, (const KESPRESERVEDKEY *)g_prekeyList_Mode);
        m_fModeKeyRegistered = FALSE;
    }

    // Update the virtual keys in g_prekeyList_Mode
    g_prekeyList_Mode[0].tfpk.uVKey = (UINT)dwDictVirtKey;
    g_prekeyList_Mode[1].tfpk.uVKey = (UINT)dwCommandVirtKey;

    // register hotkeys again based on the mode button enable status setting
    if ( fModeKeyEnabled )
    {
        _pkes->_RegisterEx(_tim, _tid, (const KESPRESERVEDKEY *)g_prekeyList_Mode);
        m_fModeKeyRegistered = TRUE;
    }
}

// +--------------------------------------------------------------------------
// HandleModeKeyEvent
//
//   dwModeKey to indicate which mode key is process.
//   fDown to indicate if the button is down or up
//
// Return TRUE means this key is a correct mode key and processed sucessfully
// otherwisze, the keyevent is not handled correctly or not a mode key.
// ---------------------------------------------------------------------------
BOOL  CSapiIMX::HandleModeKeyEvent(DWORD   dwModeKey,  BOOL fDown)
{
    BOOL    fRet=FALSE;
    BOOL    fModeKeyEnabled;
    DWORD   DictVirtKey, CommandVirtKey;

    fModeKeyEnabled = _IsModeKeysEnabled( );
    DictVirtKey = _GetDictationButton( );
    CommandVirtKey = _GetCommandButton( );

    if ( fModeKeyEnabled && ((dwModeKey == DictVirtKey) || (dwModeKey == CommandVirtKey)) )
    {
        if ( !m_pSpButtonControl )
            m_pSpButtonControl = new SpButtonControl(this);

        if ( m_pSpButtonControl )
        {
            // GetMessageTime( ) will return the real time when
            // KEYDOWN and KEYUP event was generated.
            UINT   uTimeKey=(UINT)GetMessageTime( );

            if ( dwModeKey == DictVirtKey )
                m_pSpButtonControl->SetDictationButton(fDown,uTimeKey);
            else
                m_pSpButtonControl->SetCommandingButton(fDown, uTimeKey);

            fRet = TRUE;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\lbarsink.cpp ===
#include "private.h"
#include "sapilayr.h"
#include "globals.h"
#include "lbarsink.h"
#include "immxutil.h"
#include "mui.h"
#include "slbarid.h"
#include "nui.h"


//////////////////////////////////////////////////////////////////////////////
//
// CLangBarSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarEventSink))
    {
        *ppvObj = SAFECAST(this, ITfLangBarEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLangBarSink::AddRef()
{
    return ++m_cRef;
}

STDAPI_(ULONG) CLangBarSink::Release()
{
    m_cRef--;
    Assert(m_cRef >= 0);

    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarSink::CLangBarSink(CSpTask  *pSpTask) 
{
    Dbg_MemSetThisName(TEXT("CLangBarSink"));

    Assert(pSpTask);

    m_pSpTask = pSpTask;
    m_pSpTask->AddRef();
    
    m_nNumItem  = 0;
    m_fInitSink = FALSE;
    m_fPosted  = FALSE;
    m_fGrammarBuiltOut = FALSE;
    
    m_hDynRule = NULL;

    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarSink::~CLangBarSink()
{
    if (m_cplbm)
    {
        m_cplbm->UnadviseEventSink(m_dwlbimCookie);
    }
    _UninitItemList();
    SafeRelease(m_pSpTask);
}


//+---------------------------------------------------------------------------
//
// SetFocus
//
//----------------------------------------------------------------------------

HRESULT  CLangBarSink::OnSetFocus(DWORD dwThreadId)
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::OnSetFocus, dwThreadId=%d",dwThreadId); 

    if (m_fPosted == TRUE) return S_OK;

    HWND hwnd = m_pSpTask->GetTip()->_GetWorkerWnd();
    if (hwnd)
    {
        PostMessage(hwnd, WM_PRIV_LBARSETFOCUS, 0, 0);
        m_fPosted = TRUE;
    }
    return S_OK;
}
HRESULT CLangBarSink::_OnSetFocus()
{

    HRESULT hr = S_OK;
    CSapiIMX *pime = m_pSpTask->GetTip();

    TraceMsg(TF_LB_SINK, "LBSINK: _OnSetFocus is called back");
 
    if ( !pime )
        return E_FAIL;

    // this _tim check is needed because on Win98 the worker window's
    // winproc may get called after the window is destroyed.
    // In theory we should be ok since we destory the window which calls
    // _OnSetFocus() via private message before we release tim
    //
    if (pime->_tim &&
        pime->IsActiveThread() == S_OK)
    {
        // do we have to do anything?
        hr = _InitItemList();
        BOOL    fCmdOn;

        fCmdOn = pime->GetOnOff( ) && pime->GetDICTATIONSTAT_CommandingOnOff( );

        // the dynamic toolbar grammar is available only for Voice command mode.
        if ( fCmdOn && pime->_LanguageBarCmdEnabled( ))
        {
            if (hr==S_OK && !m_fGrammarBuiltOut && pime->_IsDictationActiveForLang(GetPlatformResourceLangID()))
            {
                // build C/C grammar
                hr = _BuildGrammar();
                _ActivateGrammar(TRUE);
            }
        }
    }
    m_fPosted = FALSE;
    return hr;
}

//+---------------------------------------------------------------------------
//
// ThreadTerminate
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::OnThreadTerminate(DWORD dwThreadId)
{
    //
    // check if the thread is us, release the dynamic grammar object
    // via sptask
    // 
    _UninitItemList();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnThreadItemChange
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::OnThreadItemChange(DWORD dwThreadId)
{
    //PerfConsider: This is called many times when assembly changes
    //         This will be corrected in the future but for now
    //         we re-initialize unnecessary things again/again.

    // check if the thread is us, 
    // to un-initialize the grammar then rebuild the one

    TraceMsg(TF_LB_SINK, "CLangBarSink::OnThreadItemChange, dwThreadId=%d", dwThreadId);

    _UninitItemList();
    
    OnSetFocus(dwThreadId);
    
    // call sptask to rebuild grammar here
    
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::Init()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::Init is called");

    HRESULT hr = _EnsureLangBarMgrs();
   
    if (!m_fInitSink)
    {
        // the sink leaks if we call this twice
        if (S_OK == hr)
        {
            hr = m_cplbm->AdviseEventSink(this, NULL, 0, &m_dwlbimCookie);
        }
        m_fInitSink = TRUE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// Uninit
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::Uninit()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::Uninit is called");
    if (m_cplbm)
    {
        m_cplbm->UnadviseEventSink(m_dwlbimCookie);
        m_cplbm.Release();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _EnsureLangBarMgrs
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_EnsureLangBarMgrs()
{
    HRESULT hr = S_OK;
    
    TraceMsg(TF_LB_SINK, "CLangBarSink::_EnsureLangBarMgrs is called");

    if (!m_cplbm)
    {
        hr = TF_CreateLangBarMgr(&m_cplbm);
    }

    if (S_OK == hr && !m_cplbim)
    {
        DWORD dw;
        hr = m_cplbm->GetThreadLangBarItemMgr(GetCurrentThreadId(), &m_cplbim, &dw);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _AddLBarItem
//
//----------------------------------------------------------------------------

void CLangBarSink::_AddLBarItem(ITfLangBarItem *plbItem)
{
    if (plbItem)
    {
        int nCnt = m_rgItem.Count();
        if (m_rgItem.Insert(nCnt, 1))
        {
            plbItem->AddRef();
            m_rgItem.Set(nCnt, plbItem);
            m_nNumItem++;
        } 
    } 
}

//+---------------------------------------------------------------------------
//
// _InitItemList
//
//----------------------------------------------------------------------------

HRESULT CLangBarSink::_InitItemList()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::_InitItemList is called");

    if (0 != m_nNumItem)   
    {
        TraceMsg(TF_LB_SINK, "m_nNumItem=%d, Don't continue InitItemList",m_nNumItem);
        return S_OK;
    }
    
    HRESULT hr = E_FAIL;
    CComPtr<IEnumTfLangBarItems> cpEnum;

    Assert(m_cplbim);

    if (SUCCEEDED(hr = m_cplbim->EnumItems(&cpEnum)))
    {
        ITfLangBarItem * plbi;
        while (S_OK == cpEnum->Next(1, &plbi, NULL))
        {
            hr = S_OK; // OK if there's at least one
            DWORD dwStatus;
            plbi->GetStatus(&dwStatus);
        
            // add buttons that are not diabled or hidden
            if ((dwStatus & (TF_LBI_STATUS_HIDDEN|TF_LBI_STATUS_DISABLED))==0)
            {
                _AddLBarItem(plbi);
            }
            plbi->Release();
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _UninitItemList
//
//----------------------------------------------------------------------------

void CLangBarSink::_UninitItemList()
{
    TraceMsg(TF_LB_SINK, "CLangBarSink::_UninitItemList is called");

    if (int nCnt = m_rgItem.Count())
    {
        int i = 0;
        while (i < nCnt)
        {
            ITfLangBarItem * plbi = m_rgItem.Get(i);
            if (plbi)
                plbi->Release();
            i++;
        }
        m_rgItem.Clear();
    }
    
    m_nNumItem = 0;
    _UnloadGrammar();
}


//+---------------------------------------------------------------------------
// 
//    _BuildGrammar
//
//     synopsis: build a C&C grammar based on text labels of langbar
//               items
//
//     BuildGrammar( ) works only when the mode is in Voice command mode.
//
//     we have make sure only when voice command is ON and dictation command 
//     is enabled, this function is called.
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_BuildGrammar()
{
    HRESULT hr = E_FAIL;
    // get sptask and create a grammar

    TraceMsg(TF_LB_SINK, "_BuildGrammar is called");
    if (m_pSpTask)
    {
        CComPtr<ISpRecoContext> cpReco;
        
        // get the grammar loaded to the dictation reco context
        // 
        // it will use the Voice command mode recon context.

        hr = m_pSpTask->GetRecoContextForCommand(&cpReco);

        TraceMsg(TF_LB_SINK, "TBarGrammar: GetRecoContextForCommand, hr=%x", hr);

        if (S_OK == hr)
        {
            // we don't need to re-create grammar object
            if (!m_cpSpGrammar)
            {
                hr = cpReco->CreateGrammar(GRAM_ID_TBCMD, &m_cpSpGrammar);

                TraceMsg(TF_LB_SINK, "TBarGrammar: Create TOOLBar Grammar");
            }
        }
        if (S_OK == hr)  
        {
            hr = m_cpSpGrammar->ResetGrammar(GetPlatformResourceLangID());
            TraceMsg(TF_LB_SINK, "TBarGrammar: ResetGrammar");
        }
        if (S_OK == hr)
        {
            // get the rule handle
            m_cpSpGrammar->GetRule(GetToolbarCommandRuleName(), RULE_ID_TBCMD, SPRAF_TopLevel|SPRAF_Active|SPRAF_Dynamic, TRUE, &m_hDynRule);
            TraceMsg(TF_LB_SINK, "TBarGrammar:Get Rule Handle");
            
            // then activate the rule
        }
        
        if (S_OK == hr)
        {
            // enumerate all the buttons,
            // see if they are either ITfLangBarItemBitmapButton
            // or ITfLangBarItemButton, that have OnClick method on them
            BSTR bstr;
            int nBtns = m_rgItem.Count();

            for (int i = 0; i < nBtns; i++)
            {
                GUID guidItem;

                if (_GetButtonText(i, &bstr, &guidItem) && bstr)
                {
                    // item and property 
                    // the item can include optional string (?please etc)
                    // if (_IsItemEnabledForCommand(guidItem))

                    if ( !IsEqualGUID(guidItem, GUID_LBI_SAPILAYR_COMMANDING) )
                    {
                        SPPROPERTYINFO pi = {0};
                        pi.pszName = bstr;
                        m_cpSpGrammar->AddWordTransition(m_hDynRule, NULL, bstr, L" ", SPWT_LEXICAL, (float)1.01, &pi);

                        TraceMsg(TF_LB_SINK, "TBarGrammar: button %S added to grammar", bstr);
                    }

                    SysFreeString(bstr);
                }
            }
            //
            // add a bogus string that has significant weight so we out weight
            // others
            //
            SPPROPERTYINFO pi = {0};
            const WCHAR c_szBogus[] = L"zhoulotskunosprok";

            pi.pszName = c_szBogus;
            m_cpSpGrammar->AddWordTransition(m_hDynRule, NULL, c_szBogus, L" ", SPWT_LEXICAL, (float)1000.01, &pi);

            TraceMsg(TF_LB_SINK, "TBarGrammar: start commit ...");
            m_cpSpGrammar->Commit(0);
            TraceMsg(TF_LB_SINK, "TBarGrammar:Done commit ...");

            m_fGrammarBuiltOut = TRUE;
        }
    }

    TraceMsg(TF_LB_SINK, "_BuildGrammar is done!!!!");

    return hr;
}

//+---------------------------------------------------------------------------
//
//     _UnloadGrammar
//
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_UnloadGrammar()
{
    // clear the rule
    HRESULT hr = S_OK;

    TraceMsg(TF_LB_SINK, "CLangBarSink::_UnloadGrammar is called");

    if (m_cpSpGrammar)
    {
        hr = _ActivateGrammar(FALSE);
        if (S_OK == hr)
        {
            hr = m_cpSpGrammar->ClearRule(m_hDynRule);

            if ( hr == S_OK )
                m_fGrammarBuiltOut = FALSE; // Next time, the grammar needs to be rebuilt.
        }
    }


    return hr;
}

//+---------------------------------------------------------------------------
//
//    _ActivateGrammar
//
//     synopsis:
//
//----------------------------------------------------------------------------
HRESULT CLangBarSink::_ActivateGrammar(BOOL fActive)
{
    HRESULT hr =  S_OK;

    TraceMsg(TF_LB_SINK, "TBarGrammar: ActivateGrammar=%d", fActive);
           
    if (m_cpSpGrammar)
    {
        m_cpSpGrammar->SetRuleState(GetToolbarCommandRuleName(), NULL, fActive ? SPRS_ACTIVE : SPRS_INACTIVE);
    }

    TraceMsg(TF_LB_SINK, "TBarGrammar: ActivateGrammar is done");

    return hr;
}

//+---------------------------------------------------------------------------
//
//     ProcessToolBarCommand
//
//     When return value is TRUE, there is corresponding button on the toolbar
//     otherwise the return value is FALSE
//----------------------------------------------------------------------------
BOOL CLangBarSink::ProcessToolbarCmd(const WCHAR *szProperty)
{
    BOOL  fRet=FALSE;

    Assert(szProperty);

    // go through items in the array and call onclick method
    // if there is a match
    if (szProperty)
    {
        int nBtns = m_rgItem.Count();

        for (int i = 0; i < nBtns; i++)
        {
            BSTR bstr;
            if (_GetButtonText(i, &bstr, NULL) && bstr)
            {
                if (0 == wcscmp(szProperty, bstr))
                {
                    HRESULT hr = E_FAIL;

                    CComPtr<ITfLangBarItemButton>       cplbiBtn ;
                    CComPtr<ITfLangBarItemBitmapButton> cplbiBmpBtn ;
                    POINT pt = {0, 0};
                    ITfLangBarItem * plbi = m_rgItem.Get(i);
                    if (plbi)
                    {
                        hr = plbi->QueryInterface(IID_ITfLangBarItemButton, (void **)&cplbiBtn);
#ifndef TOOLBAR_CMD_FOR_MENUS
                        // this code removes the toolbar command from thoese
                        // items with menus

                        TF_LANGBARITEMINFO info;
                        if (S_OK == hr)
                        {
                            hr = plbi->GetInfo(&info);
                        }
                        if (info.dwStyle & TF_LBI_STYLE_BTN_MENU)
                        {
                            // do not click on buttons with menu items
                            // since we don't hanle commands for the items
                        }
                        else
#endif
                        if (S_OK == hr)
                        {
                            // is it OK to call OnClick without specifying rect?
                            hr = cplbiBtn->OnClick(TF_LBI_CLK_LEFT, pt, NULL);

                            // OnClick would start a new edit session for some buttons, such
                            // as "Correction"
                            //
                            // The return value could be TS_S_ASYNC or S_OK depends on how
                            // the application grants the edit request.
                            //
                            // We need to check if the hr value is successful.
                            // not only S_OK.

                            if ( SUCCEEDED(hr) )
                                fRet = TRUE;
                        }
#ifdef TOOLBAR_CMD_FOR_MENUS 
                        TF_LANGBARITEMINFO info;
                        RECT rc = {0};
                        if (S_OK == hr)
                        {
                            hr = plbi->GetInfo(&info);
                        }
                        if (S_OK == hr)
                        {
                            hr = m_cplbim->GetItemFloatingRect(0, info.guidItem, &rc);
                        }

                        if (S_OK == hr)
                        {
                            HWND hwnd = FindWindow(NULL, TF_FLOATINGLANGBAR_WNDTITLEA);
                            if (hwnd)
                            {
                                DWORD  dw;
                                POINT poi;
 
                                poi.x =  (rc.right + rc.left)/2,
                                poi.y =  (rc.top + rc.bottom)/2,
 
                                ::ScreenToClient(hwnd, &poi);
 
                                dw = MAKELONG(LOWORD(poi.x), LOWORD(poi.y));
                                
                                PostMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, dw);
                                PostMessage(hwnd, WM_LBUTTONUP, 0, dw);
                           }
                        }
#endif
                    }

                    if (!cplbiBtn)
                    {
                        hr = plbi->QueryInterface(IID_ITfLangBarItemBitmapButton, (void **)&cplbiBmpBtn);
                        if (S_OK == hr)
                        {
                            hr = cplbiBtn->OnClick(TF_LBI_CLK_LEFT, pt, NULL);

                            if ( S_OK == hr )
                                fRet = TRUE;
                        }
                    }
                    break;
                } // if (0 == wcscmpi(szProperty, bstr))
                
                SysFreeString(bstr);
            } // if (_GetButtonText(i, bstr))
            
        } // for
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//    GetButtonText
//
//----------------------------------------------------------------------------
BOOL CLangBarSink::_GetButtonText(int iBtn, BSTR *pbstr, GUID *pguid)
{
    HRESULT hr = E_FAIL;

    CComPtr<ITfLangBarItemButton>       cplbiBtn ;
    CComPtr<ITfLangBarItemBitmapButton> cplbiBmpBtn ;
    
    Assert(iBtn < m_rgItem.Count());
    Assert(pbstr);
    *pbstr = NULL;

    ITfLangBarItem * plbi = m_rgItem.Get(iBtn);


    if (plbi)
    {
        hr = plbi->QueryInterface(IID_ITfLangBarItemButton, (void **)&cplbiBtn);
        if (S_OK == hr)
        {
            hr = cplbiBtn->GetTooltipString(pbstr);
        }
    }
    // only in case when the button does not have a
    // regular interface we'd qi for bitmapbutton
    if (!cplbiBtn)
    {
        hr = plbi->QueryInterface(IID_ITfLangBarItemBitmapButton, (void **)&cplbiBmpBtn);
        if (S_OK == hr)
        {
            hr = cplbiBmpBtn->GetTooltipString(pbstr);
        }
    }

    TF_LANGBARITEMINFO Info = {0};

    if (S_OK == hr)
    {
        hr = plbi->GetInfo(&Info);
    }

    if (S_OK == hr)
    {
        if (pguid)
        {
            memcpy(pguid, &(Info.guidItem), sizeof(GUID));
        }

        if (Info.dwStyle & TF_LBI_STYLE_BTN_MENU)
        {
            // do not create commands for buttons with menu items
            // since we don't hanle commands for the items
            hr = S_FALSE;
        }
    }

    if (S_OK != hr && *pbstr)
    {
        // avoid mem leak
        SysFreeString(*pbstr);
    }
    
    return S_OK == hr;
}

//+---------------------------------------------------------------------------
//
// OnModalInput
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::OnModalInput(DWORD dwThreadId, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// ShowFloating
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::ShowFloating(DWORD dwFlags)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetItemFloatingRect
//
//----------------------------------------------------------------------------

STDAPI CLangBarSink::GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\keyevent.h ===
#ifndef _KEYEVENT_H
#define _KEYEVENT_H

#include "sapilayr.h"
#include "kes.h"

class CSapiIMX;
class CSpTask;

#define TF_MOD_WIN                          0x00010000

extern const KESPRESERVEDKEY g_prekeyList[];
extern KESPRESERVEDKEY g_prekeyList_Mode[];

// Speech tip itself Keyevent sink class derived from the basic CKeyEventSink

class CSptipKeyEventSink : public CKeyEventSink
{
public:

    CSptipKeyEventSink (KESCALLBACK pfnCallback, void *pv) : CKeyEventSink(pfnCallback, pv)
    {
    }

    CSptipKeyEventSink(KESCALLBACK pfnCallback, KESPREKEYCALLBACK pfnPrekeyCallback, void *pv) : CKeyEventSink(pfnCallback, pfnPrekeyCallback, pv)
    {

    }

    ~CSptipKeyEventSink() 
    { 
    }

    HRESULT _RegisterEx(ITfThreadMgr *ptim, TfClientId tid, const KESPRESERVEDKEY *pprekey);
};

#endif  // _KEYEVENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\lbarsink.h ===
#ifndef _LBARSINK_H_
#define _LBARSINK_H_

#include "private.h"
#include "sapilayr.h"
#include "ptrary.h"

extern const GUID GUID_LBI_SAPILAYR_MICROPHONE;
extern const GUID GUID_LBI_SAPILAYR_COMMANDING;

//////////////////////////////////////////////////////////////////////////////
//
// CLangBarSink
//
//////////////////////////////////////////////////////////////////////////////
class CSapiIMX;
class CSpTask;
class CLangBarSink:  public ITfLangBarEventSink
{
public:
    CLangBarSink(CSpTask *pSpTask);
    ~CLangBarSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfLangBarEventSink
    //
    STDMETHODIMP OnSetFocus(DWORD dwThreadId);
    STDMETHODIMP OnThreadTerminate(DWORD dwThreadId);
    STDMETHODIMP OnThreadItemChange(DWORD dwThreadId);
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP OnModalInput(DWORD dwThreadId, UINT uMsg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP ShowFloating(DWORD dwFlags);
    STDMETHODIMP GetItemFloatingRect(DWORD dwThreadId, REFGUID rguid, RECT *prc);

    // public methods
    HRESULT Init();
    HRESULT Uninit();
    WCHAR * GetToolbarCommandRuleName() {return L"TBRule";}
    BOOL    ProcessToolbarCmd(const WCHAR *szProperty);
    HRESULT   _OnSetFocus();
    BOOL _IsItemEnabledForCommand(REFGUID rguidItem)
    {
        if (IsEqualGUID(GUID_TFCAT_TIP_SPEECH, rguidItem))
            return FALSE;
        
        return TRUE;
    }

    BOOL  _IsTBGrammarBuiltOut( ) { return m_fGrammarBuiltOut; }
    HRESULT  _ActivateGrammar(BOOL fActive);

private:
    HRESULT  _InitItemList();
    void     _UninitItemList();

    HRESULT  _BuildGrammar();
    HRESULT  _UnloadGrammar();


    HRESULT _EnsureLangBarMgrs();
    
    void _AddLBarItem(ITfLangBarItem *plbItem);

    BOOL _GetButtonText(int iBtn, BSTR *pbstr, GUID *pguid);

    DWORD    m_dwlbimCookie;

    CComPtr<ITfLangBarMgr>         m_cplbm;
    CComPtr<ITfLangBarItemMgr>     m_cplbim;
    CComPtr<ISpRecoGrammar>        m_cpSpGrammar;
    SPSTATEHANDLE                  m_hDynRule;

    CPtrArray<ITfLangBarItem> m_rgItem;
    int                    m_nNumItem;
    BOOL                   m_fInitSink;
    CSpTask               *m_pSpTask;
    BOOL                   m_fPosted ;
    BOOL                   m_fGrammarBuiltOut;   // Is the grammar built out since last time button list was changed?

    int m_cRef;
};

#endif _LBARSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\learndoc.h ===
#ifndef _LEARNDOC_H
#define _LEARNDOC_H

#include "sapilayr.h"

class CSapiIMX;
class CSpTask;

#define SIZE_DOCUMENT_BLOCK   256 
#define SIZE_FIRST_BLOCK      64 

// This structure will keep the feed state for specified dim.
typedef struct _DimRef
{
    ITfDocumentMgr  *pDim;
    BOOL             _fFeed;
}  DIMREF;

class __declspec(novtable) CLearnFromDoc 
{
public:
    CLearnFromDoc(CSapiIMX *psi);
    virtual ~CLearnFromDoc( );

    BOOL  GetLearnFromDoc( ) { return _fLearnFromDoc; }
    void  UpdateLearnDocState( );

    HRESULT HandleLearnFromDoc(ITfDocumentMgr *pDim = NULL);

    ULONG _GetDocBlockSize( );

    HRESULT _HandleLearnFromDoc(TfEditCookie ec,ITfContext *pic, ITfDocumentMgr *pDim);
    HRESULT _GetNextRangeEditSession( );
    HRESULT _HandleNextRange(TfEditCookie ec, ULONG cchSizeRange);
    HRESULT _GetNextRangeContent(TfEditCookie ec, ULONG cchSizeRange);
    HRESULT _FeedContentRangeToSR( );
    HRESULT _UpdateRecoContextInterestSet(BOOL fLearnFromDoc );

    BOOL    _HasMoreContent( )  {  return _fMoreContent; }

    HRESULT _AddDimToList(ITfDocumentMgr  *pDim, BOOL fFed );
    HRESULT _RemoveDimFromList(ITfDocumentMgr  *pDim);
    HRESULT _SetDimFeedState(ITfDocumentMgr  *pDim, BOOL fFed );
    HRESULT _IsDimAlreadyFed(ITfDocumentMgr  *pDim, BOOL *fFeed);
    HRESULT _ClearDimList( );
    HRESULT _ResetDimListFeedState( );

private:

    CSapiIMX     *m_psi;
    WCHAR        *m_pwszDocBlock;
    ULONG         _cchBlockSize;
    ULONG         _cchContent;   // size of the real document block content in WCHAR.

    CComPtr<ITfRange>         _cpStartRange;  // This is for Cicero App's Doc Content Range.

    BOOL                      _fMoreContent;
    ITfContext               *_pic;
    CSpTask                  *_pCSpTask;
// PerfConsider: we may need to change this CPtrArray to CPtrStruct.
    CPtrArray<DIMREF>         _rgDim;
    BOOL                      _fLearnFromDoc;
};

#endif  // _LEARNDOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\learndoc.cpp ===
//
//
// Sapilayr TIP CLearnFromDoc implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "learndoc.h"

#include "cregkey.h"

// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CLeanrFromDoc
//
// -----------------------------------------------------------------------------------------------------------

CLearnFromDoc::CLearnFromDoc(CSapiIMX *psi) 
{
    m_psi = psi;
    m_pwszDocBlock = NULL;
    _pic = NULL;
    _pCSpTask = NULL;
    _cpStartRange = NULL;
    _cchBlockSize = -1;
    _fMoreContent = FALSE;
    _fLearnFromDoc = FALSE;
}

CLearnFromDoc::~CLearnFromDoc( ) 
{
    if ( m_pwszDocBlock )
        cicMemFree(m_pwszDocBlock);

    _ClearDimList( );
};


void  CLearnFromDoc::UpdateLearnDocState( )
{
    DWORD  dw;

    GetCompartmentDWORD(m_psi->_tim, GUID_COMPARTMENT_SPEECH_LEARNDOC, &dw, FALSE);

    if ( dw != 0 )
        _fLearnFromDoc = TRUE;
    else
        _fLearnFromDoc = FALSE;

    if ( _fLearnFromDoc == FALSE )
    {
        if ( m_pwszDocBlock )
        {
            cicMemFree(m_pwszDocBlock);
            m_pwszDocBlock = NULL;
        }
        _UpdateRecoContextInterestSet(FALSE);
        _ResetDimListFeedState( );
    }
}

ULONG CLearnFromDoc::_GetDocBlockSize( )
{
    if (_cchBlockSize == (ULONG)-1)
    {
        CMyRegKey regkey;
        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szSapilayrKey, KEY_READ))
        {
            DWORD dw;
            if (ERROR_SUCCESS==regkey.QueryValue(dw, c_szDocBlockSize))
            {
                _cchBlockSize = dw;
            }
        }

        if (_cchBlockSize == (ULONG)-1)
        {
            _cchBlockSize = SIZE_DOCUMENT_BLOCK;
        }

        if ( _cchBlockSize < SIZE_FIRST_BLOCK )
            _cchBlockSize = SIZE_FIRST_BLOCK;  // the first block size is the minimize size.
    }
    return _cchBlockSize;
}


HRESULT   CLearnFromDoc::HandleLearnFromDoc(ITfDocumentMgr *pDim )
{
    HRESULT  hr = S_OK;
    CComPtr<ITfContext> cpic=NULL;
    ITfDocumentMgr *dim;

    if ( !m_psi )
        return E_FAIL;

    if ( m_psi->GetFocusIC(&cpic) && (GetLearnFromDoc( ) == TRUE))
    {
        if ( !pDim )
        {
            // Try to get the Dim from current focused IC.
            hr = cpic->GetDocumentMgr(&dim);
        }
        else
        {
            dim = pDim;
            dim->AddRef( );
        }

        if ( !dim )
            hr = E_FAIL;

        if ( S_OK == hr ) 
        {   
            // Check to see if this doc has already been fed to SR LM engine.
            BOOL fFedAlready = FALSE;
            hr = _IsDimAlreadyFed(dim, &fFedAlready);

            if ( (S_OK == hr) && !fFedAlready )
            {
                // Check to if the current doc is ReadOnly or not.
                TF_STATUS  docStatus;
                hr = cpic->GetStatus(&docStatus);

                if ( S_OK == hr && !(docStatus.dwStaticFlags & TF_SD_READONLY) )
                {
                    ESDATA  esData;

                    memset(&esData, 0, sizeof(ESDATA));
                    esData.pUnk = (IUnknown *)dim;
                    hr = m_psi->_RequestEditSession(ESCB_HANDLE_LEARNFROMDOC,TF_ES_READ, &esData, cpic);
                }
            }

            dim->Release();
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// CSapiIMX::_HandleLearnFromDoc
//
// Let the speech engine learn from existing document content and have 
// more accurate dictation recognition.
// This function will be called when user clicks the speech language bar menu 
// and select Learn From Document... item.
//
//---------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_HandleLearnFromDoc(TfEditCookie ec,ITfContext *pic, ITfDocumentMgr *pDim )
{
   
    HRESULT   hr = S_OK;
    ULONG     cchBlock;
    BOOL      fFeedAlready;

    // Get the Dictation Grammar

    TraceMsg(TF_GENERAL, "_HandleLearnFromDoc() is called");

    if ( m_psi == NULL)
        return E_FAIL;

    if ( !pDim  || !pic )
        return E_INVALIDARG;

    _pic = pic;

    m_psi->GetSpeechTask(&_pCSpTask, FALSE); 

    if ( _pCSpTask == NULL )
    {
        // _sptask is not yet initialized, just return.
        TraceMsg(TF_GENERAL, "_HandleLearnFromDoc: _pCspTask is NULL");
        goto CleanUp;
    }
    
    cchBlock = _GetDocBlockSize( );

    if ( m_pwszDocBlock == NULL)
    {
        m_pwszDocBlock = (WCHAR *) cicMemAlloc( (cchBlock+1)*sizeof(WCHAR)  );
        if (m_pwszDocBlock == NULL)
        {
            TraceMsg(TF_GENERAL, "_HandleLearnFromDoc: m_pwszDocBlock Out of Memory");
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }
    }

    fFeedAlready = FALSE;

    hr = _IsDimAlreadyFed(pDim, &fFeedAlready);

    if ( (hr != S_OK) || fFeedAlready )
    {
        // This DIM has already been fed to SR Engine.
        // or we got problem to get the feed state for this dim.
        // stop here.
        goto CleanUp;
    }

    // Get the range for the document.
    _cpStartRange.Release( );
    hr = _pic->GetStart(ec, &_cpStartRange);
    if ((hr != S_OK) || (_cpStartRange == NULL))
    {
        TraceMsg(TF_GENERAL, "_HandleLearnFromDoc: _cpStartRange is NULL");
        goto CleanUp;
    }
    
    // Change the sptask interersting setting

    _UpdateRecoContextInterestSet(TRUE);

    // This is the first range of the document. just small size of block.
    hr = _GetNextRangeContent(ec, SIZE_FIRST_BLOCK);

        // Feed to SR Engine.
   if ( (hr == S_OK) && _fMoreContent)
   {
       hr = _FeedContentRangeToSR( );
       if ( hr == S_OK)
       {
           _SetDimFeedState(pDim, TRUE);
       }
       else
           _fMoreContent = FALSE;
    }

CleanUp:
    return hr;
}


//+---------------------------------------------------------------------------
//
//    _GetNextRangeContent
//
//    Get the Next Range (block) of document content. 
//    
//    update the flag to indicate if there is effective content
//    
//   ec:             EditCookie
//   cchSizeRange:   Required block size
//  
//             At the first time, we just feed a very small size of charcters
//             to the Engine so that it will not interfere with current dictation
//             handling of engine.
// 
//             After we get the ADAPTATION notification from Engine, we will feed 
//             normal size of block ( specified in registry ) to engine.
//
//---------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_GetNextRangeContent(TfEditCookie ec, ULONG cchSizeRange)
{

    HRESULT  hr = S_OK;
    LONG     lShift = 0;
        
    TraceMsg(TF_GENERAL, "_GetNextRangeContent is Called");

    if ( m_pwszDocBlock == NULL)
    {
        m_pwszDocBlock = (WCHAR *) cicMemAlloc( (_cchBlockSize+1)*sizeof(WCHAR));
    	if (m_pwszDocBlock == NULL)
    	{
    		TraceMsg(TF_GENERAL, "_GetNextRangeContent: m_pwszDocBlock Out of Memory");
    		hr = E_OUTOFMEMORY;
    		return hr;
    	}
   }
            
    // assume there is no more content.
    _fMoreContent = FALSE;

    // This is Cicero App's Document,  we use Cicero interfaces to get the whole document.
    // We already get the cpStartRange.

    hr = _cpStartRange->GetText(ec, TF_TF_MOVESTART | TF_TF_IGNOREEND, m_pwszDocBlock, cchSizeRange, &_cchContent );

    if ( hr!= S_OK )  goto CleanUp;

    // If the last character is not a word-break char for English case, 
    // we don't want to keep this half word for this chunk text, it will go to next
    // chunk. 

    // we just want to shift back some charaters to hit a word-breaker.

    WORD    prilangid;

    prilangid = PRIMARYLANGID(m_psi->GetLangID( ));


    if ( prilangid != LANG_JAPANESE && prilangid != LANG_CHINESE )
    {
        if ( _cchContent > 0 )
        {
            while ( _cchContent > 0  )
            {
                if ( iswalpha(m_pwszDocBlock[_cchContent-1]) )
                {
                    m_pwszDocBlock[_cchContent-1] = L'\0';
                    lShift ++;
                    _cchContent--;
                }
                else
                    break;
            }

            if ( lShift > 0 )
            {
                lShift *= ( -1 );

                long  cch;
                _cpStartRange->ShiftEnd(ec, lShift, &cch, NULL);
            }
        }
    }

    TraceMsg(TF_GENERAL, "Text Content in Cicero Doc Buffer  _cchContent=%d---------------->", _cchContent);
#ifdef DEBUG
    {
        ULONG x;
        for (x=0; x<_cchContent; x++)
        {
            char szbuf[4];
            szbuf[0] = (char)(m_pwszDocBlock[x]);
            szbuf[1] = '\0';
            OutputDebugString(szbuf);
        }
        OutputDebugString("\n");
    }
#endif
    TraceMsg(TF_GENERAL, "Text Content in CiceroDoc Over -------------------!");

    if ( _cchContent > 0  || lShift > 0)
        // There is more content.
        _fMoreContent = TRUE;
    else
        _fMoreContent = FALSE;

CleanUp:

    return hr;
}

//+---------------------------------------------------------------------------
//
//    _FeedContentRangeToSR
//
//    Feed the current Range (block) of document content to the SR Engine. 
//
//---------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_FeedContentRangeToSR( )
{
    HRESULT  hr = S_OK;
    WCHAR    *pCoMemText;
    CComPtr<ISpRecoContext>  cpRecoCtxt;

    TraceMsg(TF_GENERAL, "_FeedContentRangeToSR( ) is called");

    hr = _pCSpTask->GetSAPIInterface(IID_ISpRecoContext, (void **)&cpRecoCtxt );

    if ( (hr != S_OK) || (cpRecoCtxt == NULL) )
        return E_FAIL;

    // Feed this block of document content to speech dictation.
    if ( (_cchContent > 0) && (m_pwszDocBlock != NULL))
    {
        pCoMemText = (WCHAR *)CoTaskMemAlloc((_cchContent+1)*sizeof(WCHAR));

        if ( pCoMemText )
        {
            wcsncpy(pCoMemText, m_pwszDocBlock, _cchContent);
            pCoMemText[_cchContent] = L'\0';

            hr = cpRecoCtxt->SetAdaptationData(pCoMemText, _cchContent);

            if ( hr != S_OK)
                TraceMsg(TF_GENERAL, "_FeedContentRangeToSR: SetAdaptationData Failed");
        }
    }

    return hr;
}

HRESULT CLearnFromDoc::_GetNextRangeEditSession( )
{
    HRESULT  hr = S_OK;
    ESDATA   esData;

    Assert(m_psi);
    memset(&esData, 0, sizeof(ESDATA));
    esData.lData1 = (LONG_PTR)_cchBlockSize;
    hr = m_psi->_RequestEditSession(ESCB_LEARNDOC_NEXTRANGE, TF_ES_READ, &esData, _pic);

    return hr;
}

//+---------------------------------------------------------------------------
//
//    _HandleNextRange
//
//    Handle the Next Range (block) of document content, get and feed it and 
//    then update the status.
//
//   ec:             EditCookie
//   cchSizeRange:   Required block size
//
//---------------------------------------------------------------------------+
HRESULT CLearnFromDoc::_HandleNextRange(TfEditCookie ec, ULONG cchSizeRange)
{
    HRESULT  hr = S_OK;

    hr = _GetNextRangeContent(ec, cchSizeRange);

    if ( hr == S_OK  && _fMoreContent)
    {
        // This next range contains valid content, feed it to SR Engine.
        hr = _FeedContentRangeToSR( );
    }

    if ( (hr != S_OK) || !_fMoreContent )
    {
        // Error happened or no more content, update the interest set.
       hr = _UpdateRecoContextInterestSet(FALSE);
    }

    return hr;
}


//+-----------------------------------------------------------------------------------------
//
//    _UpdateRecoContextInterestSet
//
//    Update the RecoContext's interested notification event setting
//
//    if fLearnFromDoc is TRUE, we are interested in getting notification of SPEI_ADAPTATION
//    if fLearnFromDoc is FALSE, we are not interested in that notification
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_UpdateRecoContextInterestSet( BOOL fLearnFromDoc )
{

    HRESULT   hr = S_OK;
    CComPtr<ISpRecoContext>  cpRecoCtxt;
    ULONGLONG ulInterest = SPFEI(SPEI_SOUND_START) | 
                                 SPFEI(SPEI_SOUND_END) | 
                                 SPFEI(SPEI_PHRASE_START) |
                                 SPFEI(SPEI_RECOGNITION) | 
                                 SPFEI(SPEI_RECO_OTHER_CONTEXT) | 
                                 SPFEI(SPEI_HYPOTHESIS) | 
                                 SPFEI(SPEI_INTERFERENCE) |
                                 SPFEI(SPEI_FALSE_RECOGNITION);
    if ( _pCSpTask == NULL )
        return hr;

    hr = _pCSpTask->GetSAPIInterface(IID_ISpRecoContext, (void **)&cpRecoCtxt );

    if ( (hr != S_OK) || (cpRecoCtxt == NULL) )
        return E_FAIL;

    if ( fLearnFromDoc )
        ulInterest |= SPFEI(SPEI_ADAPTATION);
    else
        ulInterest &= ~(SPFEI(SPEI_ADAPTATION));

    hr = cpRecoCtxt->SetInterest(ulInterest, ulInterest);
    return hr;
}

//+-----------------------------------------------------------------------------------------
//
//    _AddDimToList
//
//    Add a DIM to the dim list, and set the feed state  
//
//    This function would be called by TIM_CODE_INITDIM callback.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_AddDimToList(ITfDocumentMgr  *pDim, BOOL fFed )
{

    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    BOOL     bFound;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_AddDimToList is called");

    if ( !pDim )
        return E_INVALIDARG;

    // Check to see if this dim is already added.
    bFound = FALSE;
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            bFound = TRUE;
            TraceMsg(TF_GENERAL, "This dim has already been added to the dim list");
            break;
        }
    }

    if (bFound)
    {
        // Set the state.
        dimRef->_fFeed = fFed;
    }
    else
    {
        dimRef = (DIMREF   *)cicMemAllocClear(sizeof(DIMREF));
        if ( dimRef == NULL)
            return E_OUTOFMEMORY;

        dimRef->_fFeed = fFed;
        dimRef->pDim = pDim;

        if (!_rgDim.Insert(nCnt, 1))
        {
            cicMemFree(dimRef);
            return E_OUTOFMEMORY;
        }
         
        pDim->AddRef( );
        _rgDim.Set(nCnt, dimRef);
    }

    return hr;

}

//+-----------------------------------------------------------------------------------------
//
//    _RemoveDimFromList
//
//    Remove a DIM from the internal dim list, and release the DIM itself.   
//
//    This function would be called by TIM_CODE_UNINITDIM callback.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_RemoveDimFromList(ITfDocumentMgr  *pDim)
{
    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_RemoveDimFromList is called");

    if ( pDim == NULL)
        return E_INVALIDARG;

    // Check to see if this dim is already added.
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            // free the DIM.
            (dimRef->pDim)->Release( );
            dimRef->pDim = NULL;

            // Remove it from the list
            _rgDim.Remove(i, 1);

            // Remove the structure itself.
            cicMemFree(dimRef);

            break;
        }
    }

    return hr;
}

//+-----------------------------------------------------------------------------------------
//
//    _SetDimFeedState
//
//    Set the feed state for the specified DIM.   
//
//    fFed is TRUE means this DIM is already fed to the Engine.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_SetDimFeedState(ITfDocumentMgr  *pDim, BOOL fFed )
{

    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_SetDimFeedState is called");

    if ( pDim == NULL)
        return E_INVALIDARG;

    // Check to see if this dim is already added.
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            // Set the feed state for this DIM.
            dimRef->_fFeed = fFed;
            break;
        }
    }

    return hr;

}

//+-----------------------------------------------------------------------------------------
//
//    _IsDimAlreadyFed
//
//    Check to see if the dim is already fed to the Engine.   
//
//-------------------------------------------------------------------------------------------+

HRESULT    CLearnFromDoc::_IsDimAlreadyFed(ITfDocumentMgr  *pDim, BOOL  *fFeed)
{

    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_IsDimAlreadyFed is called");

    if ( (pDim == NULL) || (fFeed == NULL))
        return E_INVALIDARG;

    *fFeed = FALSE;

    // Check to see if this dim is already added.
    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        if ( dimRef->pDim == pDim )
        {
            // Get the feed state for this DIM.
            *fFeed = dimRef->_fFeed;
            TraceMsg(TF_GENERAL, "IsDimAlreadyFed: pDim=%x, fFeed=%s", (UINT_PTR)pDim,  *fFeed ? "TRUE":"FALSE");
            break;
        }
    }
       
    return hr;

}

// CleanUpConsider: above _IsDimAlreadyFed and _SetDimFeedState have similar code, we may supply a new internal base function, and let 
// above two functions call it with different param set.


//+-----------------------------------------------------------------------------------------
//
//    _ClearDimList
//
//    Release all the DIMs in the DIM List, and clear the list itself. 
//
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_ClearDimList( )
{
    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_ClearDimList is called");

    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        // free the DIM.
        if ( dimRef->pDim)
        {
           (dimRef->pDim)->Release( );
           dimRef->pDim = NULL;
        }

        // Remove it from the list
        _rgDim.Remove(i, 1);

        // Remove the structure itself.
        cicMemFree(dimRef);
    }

    return hr;
}

//+-----------------------------------------------------------------------------------------
//
//    _ResetDimListFeedState
//
//    set feed state for all the dims in internal dim list as FALSE 
//
//    This function would be called when user turns off the Learn from Doc.
//
//-------------------------------------------------------------------------------------------+

HRESULT CLearnFromDoc::_ResetDimListFeedState( )
{
    HRESULT  hr = S_OK;
    int      nCnt = _rgDim.Count();
    int      i;
    DIMREF   *dimRef;

    TraceMsg(TF_GENERAL, "_ResetDimListFeedState is called");

    for (i=0; i < nCnt; i++)
    {
        dimRef = (DIMREF   *)_rgDim.Get(i);

        // Set the feed state for this DIM as FALSE
        dimRef->_fFeed = FALSE;
    }

    return hr;

}


// CleanUpConsider: above _ClearDimList and _ResetDimListFeedState have similar code, we may supply a new internal base function, and let 
// above two functions call it with different param set.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\lmlattic.h ===
//
//	LM Lattice Object class definition
//

#ifndef LMLATTIC_H
#define LMLATTIC_H


//
// CLMLattice
//
//
class CLMLattice : public ITfLMLattice
{
public:
    // ctor / dtor
	CLMLattice(CSapiIMX *p_tip, IUnknown *pResWrap);
	~CLMLattice();

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
	// ITfLMLattice
    STDMETHODIMP QueryType(REFGUID refguidType, BOOL *pfSupported);
    STDMETHODIMP EnumLatticeElements( DWORD dwFrameStart,
                                      REFGUID refguidType,
                                      IEnumTfLatticeElements **ppEnum);

private:
    CComPtr<IUnknown>    m_cpResWrap;
    ULONG m_ulStartSRElement;
    ULONG m_ulNumSRElements;
    CSapiIMX  *m_pTip;
	LONG m_cRef;
};

//
// CEnumLatticeElements
//
class CEnumLatticeElements : public IEnumTfLatticeElements, 
                             public CStructArray<TF_LMLATTELEMENT>
{
public:
    // ctor / dtor
	CEnumLatticeElements(DWORD dwFrameStart);
	~CEnumLatticeElements();

	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// ITfEnumLatticeElements
    STDMETHODIMP Clone(IEnumTfLatticeElements **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, TF_LMLATTELEMENT *rgsElements, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);
	
    // internal APIs
    HRESULT  _InitFromPhrase 
    ( 
        SPPHRASE *pPhrase,       // pointer to a phrase object
        ULONG ulStartElem,        // start/num elements used in this phrase
        ULONG ulNumElem           // for this lattice
    );

    ULONG _Find(DWORD dwFrame, ULONG *pul);
private:

	DWORD m_dwFrameStart;
	ULONG m_ulCur;
	ULONG m_ulTotal;

	LONG m_cRef;
};


#endif // LMLATTIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\lmlattic.cpp ===
//
// lmlattice.cpp
//
// implelementation of ITfLMLattice object, IEnumTfLatticeElements object
//

#include "private.h"
#include "sapilayr.h"
#include "lmlattic.h"

//
// CLMLattice
//
//

// ctor / dtor
CLMLattice::CLMLattice(CSapiIMX *p_tip, IUnknown *pResWrap)
{
    m_cpResWrap = pResWrap;
    m_pTip = p_tip;
    if (m_pTip)
    {
        m_pTip->AddRef();
    }
    m_cRef = 1;
}

CLMLattice::~CLMLattice()
{
    if (m_pTip)
    {
        m_pTip->Release();
    }
}

// IUnknown
HRESULT CLMLattice::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    Assert(ppvObj);
    
    if (IsEqualIID(riid, IID_IUnknown)
    ||  IsEqualIID(riid, IID_ITfLMLattice))
    {
        *ppvObj = this;
        hr = S_OK;
        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

ULONG CLMLattice::AddRef(void)
{
    this->m_cRef++;
    return this->m_cRef;
}

ULONG CLMLattice::Release(void)
{
    this->m_cRef--;
    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;
    return 0;
}

// ITfLMLattice
HRESULT CLMLattice::QueryType(REFGUID refguidType, BOOL *pfSupported)
{
    HRESULT hr = E_INVALIDARG;

    if (pfSupported)
    {
         *pfSupported = IsEqualGUID(refguidType, GUID_LMLATTICE_VER1_0);
         if (*pfSupported)
             hr = S_OK;
    }
    return hr;
}

HRESULT CLMLattice::EnumLatticeElements( DWORD dwFrameStart, REFGUID refguidType, IEnumTfLatticeElements **ppEnum)
{
    if (!ppEnum)
       return E_INVALIDARG;
       
    *ppEnum = NULL;
       
    if (!IsEqualGUID(refguidType, GUID_LMLATTICE_VER1_0))
       return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    // get alternates and cache the returned cotaskmem
    ULONG ulcMaxAlt = m_pTip->_GetMaxAlternates();
    ISpPhraseAlt **ppAlt = NULL;
 
    CComPtr<IServiceProvider> cpServicePrv;
    CComPtr<ISpRecoResult> cpRecoResult;
    CRecoResultWrap *pWrap = NULL;
    ULONG    ulStartInWrp, ulNumInWrp;
    
    //  QI the service provider first then get to the sapi interface
    //
    hr = m_cpResWrap->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
 
    if (SUCCEEDED(hr))
    {
        hr = m_cpResWrap->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pWrap);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpRecoResult);
    }


    ulStartInWrp = pWrap->GetStart();
    ulNumInWrp = pWrap->GetNumElements();

    if ( SUCCEEDED(hr))
    {
        // Get the Alternates for current RecoResult.
        ppAlt = (ISpPhraseAlt **)cicMemAlloc(ulcMaxAlt * sizeof(ISpPhraseAlt *));
        if (ppAlt)
        {
            hr = cpRecoResult->GetAlternates(
                                    ulStartInWrp, 
                                    ulNumInWrp, 
                                    ulcMaxAlt, 
                                    ppAlt,          /* [out] ISpPhraseAlt **ppPhrases, */
                                    &ulcMaxAlt      /* [out] ULONG *pcPhrasesReturned */
                                 );
        }
        else
            hr = E_OUTOFMEMORY;
 
    }
    
    // OK now create an instance of enumerator
    CEnumLatticeElements *pEnumLE = NULL;

    if ( SUCCEEDED(hr) )
    {
        pEnumLE = new CEnumLatticeElements(dwFrameStart);

        if (!pEnumLE)
           hr = E_OUTOFMEMORY;

        if (S_OK == hr)
        {
            for ( ULONG i=0; i<ulcMaxAlt; i++)
            {
                SPPHRASE *pPhrase = NULL;
                ULONG     ulStart, ulNum;
                ULONG     ulStartInPar, ulNumInParent;

                ppAlt[i]->GetPhrase(&pPhrase);
                ppAlt[i]->GetAltInfo(NULL, &ulStartInPar, &ulNumInParent, &ulNum);

                if ( (ulStartInPar >= ulStartInWrp) && (ulStartInPar+ulNumInParent <= ulStartInWrp+ulNumInWrp) )
                {
                    // This is a valid alternate
                    if( SUCCEEDED(hr) )
                    {
                        ulStart = ulStartInPar;
                        hr = pEnumLE->_InitFromPhrase(pPhrase, ulStart, ulNum);
                    }
                }

                if (pPhrase)
                {
                    CoTaskMemFree(pPhrase);
                }
            }
        }
    }
        
    if (S_OK == hr)
    {
        hr = pEnumLE->QueryInterface(IID_IEnumTfLatticeElements, (void **)ppEnum);
    }
    
    SafeRelease(pEnumLE);

    if ( ppAlt )
    {
        // Release references to alternate phrases.
        for (int i = 0; i < (int)ulcMaxAlt; i++)
        {
            if (NULL != (ppAlt)[i])
            {
                ((ppAlt)[i])->Release();
            }
        }

        cicMemFree(ppAlt);
    }

    return hr;
}

//
// CEnumLatticeElements
//
//

// ctor / dtor
CEnumLatticeElements::CEnumLatticeElements(DWORD dwFrameStart)
{
	m_dwFrameStart = dwFrameStart;
	m_ulCur = (ULONG)-1;
	m_ulTotal = 0;

	m_cRef = 1;
}

CEnumLatticeElements::~CEnumLatticeElements()
{
    // clean up the lattice elements here
    int  ulCount;
    TF_LMLATTELEMENT * pLE;

    ulCount = (int) Count( );

    TraceMsg(TF_GENERAL, "CEnumLatticeElements::~CEnumLatticeElements: ulCount=%d", ulCount);

    if (ulCount)
    {
        for (int i = 0; i < ulCount; i++)
        {
            pLE = GetPtr(i);
            if ( pLE && pLE->bstrText)
            {
                ::SysFreeString(pLE->bstrText);
                pLE->bstrText=0;
            }
        }
    }
}

// IUnknown
HRESULT CEnumLatticeElements::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    Assert(ppvObj);
    
    if (IsEqualIID(riid, IID_IUnknown)
    ||  IsEqualIID(riid, IID_IEnumTfLatticeElements))
    {
        *ppvObj = this;
        hr = S_OK;
        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

ULONG CEnumLatticeElements::AddRef(void)
{
    this->m_cRef++;
    return this->m_cRef;
}

ULONG CEnumLatticeElements::Release(void)
{
    this->m_cRef--;
    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;
    return 0;
}

// ITfEnumLatticeElements
HRESULT CEnumLatticeElements::Clone(IEnumTfLatticeElements **ppEnum)
{
    HRESULT hr = E_INVALIDARG;
    if (ppEnum)
    {
        CEnumLatticeElements *pele = new CEnumLatticeElements(m_dwFrameStart);

        if ( !pele )
           return E_OUTOFMEMORY;

        if (pele->Append(Count()))
        {
            for (int i = 0; i < Count(); i++)
            {
                *(pele->GetPtr(i)) = *GetPtr(i);
                Assert((pele->GetPtr(i))->bstrText);
                (pele->GetPtr(i))->bstrText = SysAllocString(GetPtr(i)->bstrText);

            }
            
	        pele->m_dwFrameStart = m_dwFrameStart;
            hr = pele->QueryInterface(IID_IEnumTfLatticeElements, (void **)ppEnum);
        }
        else
        {
            delete pele;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
HRESULT CEnumLatticeElements::Next(ULONG ulCount, TF_LMLATTELEMENT *rgsElements, ULONG *pcFetched)
{
    if (ulCount == 0 
        || rgsElements == NULL
        || pcFetched   == NULL
    )
        return E_INVALIDARG;
        
    // find the start position
    if (m_dwFrameStart == -1)
    {
        m_ulCur = m_dwFrameStart = 0;
    }
    else
    {
        if (m_ulCur == (ULONG)-1)
        {
            _Find(m_dwFrameStart, &m_ulCur);
        }
    }
    
    if (m_ulCur >= m_ulTotal)
    {
        // no more elements but OK
        *pcFetched = 0;
    }
    else
    {
        // something to return
        for (ULONG ul = m_ulCur; 
             ul < m_ulTotal && ul - m_ulCur < ulCount; 
             ul++)
        {
            rgsElements[ul-m_ulCur] = *GetPtr(ul);
        }
        *pcFetched = ul - m_ulCur;
    }

    return S_OK;
}

HRESULT CEnumLatticeElements::Reset()
{
    m_ulCur = (ULONG)-1;
    return S_OK;
}

HRESULT CEnumLatticeElements::Skip(ULONG ulCount)
{
    // find the start position
    if (m_dwFrameStart == -1)
    {
        m_ulCur = m_dwFrameStart = 0;
    }
    else
    {
        if (m_ulCur == (ULONG)-1)
        {
            _Find(m_dwFrameStart, &m_ulCur);
        }
    }
    
    m_ulCur += ulCount;
    
    if (m_ulCur > m_ulTotal)
        m_ulCur = m_ulTotal;

    return E_NOTIMPL;
}

//
// internal APIs
//

HRESULT  CEnumLatticeElements::_InitFromPhrase
(
    SPPHRASE *pPhrase, 
    ULONG ulStartElem, 
    ULONG ulNumElem
)
{
    Assert(pPhrase);

    if ( pPhrase == NULL)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    // allocate the initial slots
    if (!Append(ulNumElem))
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (S_OK == hr)
    {
        long   lEndElem;
        long   indexOrgList;
        long   indexNewList;

        lEndElem = min(pPhrase->Rule.ulCountOfElements, ulStartElem + ulNumElem);
        lEndElem --; // Real position ( offset from 0 ) for the last element

        indexNewList = Count( ) - 1;
        indexOrgList = indexNewList - ulNumElem;

        m_ulTotal += ulNumElem;

        TraceMsg(TF_GENERAL, "_InitFromPhrase: m_ulTotal=%d", m_ulTotal);

        // FutureConsider: ITN has to be considered here!
        for (long i=lEndElem; i>=(long)ulStartElem; i--)
        {
            TF_LMLATTELEMENT * pLE;

            // Compare all the elements in the Org list from End to start 
            // with this new element's dwFrameStart,  
            // If dwFrameStart of the element in Org list is larger than(or equal to)
            // this element's dwFrameStart, just move the org element
            // to the current available position in the new list.

            // until we find an element in the org list whose dwFrameStart is less than 
            // this element's dwFrameStart. we need to move this element to the 
            // new current available item in the new list.

            // Current available position in the new list is from End to Start.

            while ( (indexOrgList >=0) && (indexNewList >=0) && (S_OK == hr) )
            {
                pLE = GetPtr(indexOrgList);
                if (pLE)
                {
                    if ( pLE->dwFrameStart >= pPhrase->pElements[i].ulAudioTimeOffset )
                    {
                        // Move this Org element to a new postion in new List.
                        TF_LMLATTELEMENT * pNewLE;

                        pNewLE = GetPtr(indexNewList);
                        if ( pNewLE)
                        {
                            pNewLE->dwFrameStart = pLE->dwFrameStart;
                            pNewLE->dwFrameLen = pLE->dwFrameLen;
                            pNewLE->dwFlags = pLE->dwFlags;
                            pNewLE->iCost = pLE->iCost;
                            pNewLE->bstrText = pLE->bstrText;

                            pLE->dwFrameStart = 0;
                            pLE->dwFrameLen = 0;
                            pLE->dwFlags = 0;
                            pLE->iCost = 0;
                            pLE->bstrText = 0;
                        }

                        // update the index position in both org and new list
                        indexNewList --;
                        indexOrgList --;
                    }
                    else
                    {
                        // current element from this phrase should be moved to the new list
                        break;
                    }
                }
                else
                { 
                    TraceMsg(TF_GENERAL, "CEnumLatticeElements::_InitFromPhrase: pLE is NULL");
                    hr = E_FAIL;
                    break;
                }
            }  //while


            if ( (S_OK == hr) && (indexNewList >=0) )
            {
                pLE = GetPtr(indexNewList);
                if (pLE)
                {
                    pLE->dwFrameStart = pPhrase->pElements[i].ulAudioTimeOffset;
                    pLE->dwFrameLen   = pPhrase->pElements[i].ulAudioSizeTime;

                    pLE->dwFlags      = 0; // for now
                    pLE->iCost        = pPhrase->pElements[i].ActualConfidence;
                
                    pLE->bstrText     = SysAllocString(pPhrase->pElements[i].pszDisplayText);

                    TraceMsg(TF_GENERAL, "i=%d, dwFramStart=%d bstrText=%S", i, pLE->dwFrameStart, pLE->bstrText); 

                    indexNewList--;
                }
            }

        }  // for
    }  // if

    return hr;
}

//
// _Find()
//
// slightly modified version of array find
//
ULONG CEnumLatticeElements::_Find(DWORD dwFrame, ULONG *pul)
{
    int iMatch = -1;
    int iMid = -1;
    int iMin = 0;
    int iMax = _cElems;

    while(iMin < iMax)
    {
        iMid = (iMin + iMax) / 2;
        DWORD dwCur = GetPtr(iMid)->dwFrameStart;
        if (dwFrame < dwCur)
        {
            iMax = iMid;
        }
        else if (dwFrame > dwCur)
        {
            iMin = iMid + 1;
        }
        else
        {
            iMatch = iMid;
            break;
        }
    }

    if (pul)
    {
        if ((iMatch == -1) && (iMid >= 0))
        {
            if (dwFrame < GetPtr(iMid)->dwFrameStart)
                iMid--;
        }
        *pul = iMid;
    }
    return iMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "ciccs.h"

extern HINSTANCE g_hInst;
extern HINSTANCE g_hInstSpgrmr;
extern DWORD g_dwTlsIndex;
extern const GUID GUID_PROP_SAPI_DISPATTR;
extern const GUID GUID_PROP_SAPIRESULTOBJECT; // ISpRecoResult object
extern const GUID GUID_ATTR_SAPI_INPUT;
extern const GUID GUID_ATTR_SAPI_GREENBAR;
extern const GUID GUID_ATTR_SAPI_GREENBAR2;
extern const GUID GUID_ATTR_SAPI_REDBAR;
extern const GUID GUID_ATTR_SAPI_SELECTION;
extern const GUID GUID_IC_PRIVATE;
extern const GUID GUID_COMPARTMENT_SPEECHPRIV_REFCNT;
extern const GUID GUID_COMPARTMENT_SPEECH_LEARNDOC;
extern const GUID GUID_COMPARTMENT_TTS_STATUS;
extern const GUID GUID_COMPARTMENT_SHARED_BLN_TEXT;
extern const GUID GUID_COMPARTMENT_SPEECHUISHOWN;
extern const GUID GUID_COMPARTMENT_SPEECH_STAGE;
extern const GUID GUID_COMPARTMENT_SPEECH_STAGECHANGE;
extern const GUID GUID_COMPARTMENT_SPEECH_STAGEDICTATION;
extern const GUID CLSID_UIHost;
extern const GUID GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE;
extern const GUID CLSID_SpPropertyPage;
extern const LARGE_INTEGER c_li0;

extern const GUID GUID_HOTKEY_TTS_PLAY_STOP;
extern const GUID GUID_HOTKEY_MODE_DICTATION;
extern const GUID GUID_HOTKEY_MODE_COMMAND;

extern CCicCriticalSectionStatic g_cs;

// tablet stuff
extern const CLSID CLSID_CorrectionIMX;
extern const GUID GUID_IC_PRIVATE;

const TCHAR c_szStatusWndClass[] = TEXT("SapiLayrStatusWndClass");
const TCHAR c_szStatusWndName[] = TEXT("SapiLayer");
const TCHAR c_szWorkerWndClass[]   = TEXT("SapiTipWorkerClassV1.0");

const TCHAR c_szSapilayrKey[]      = TEXT("SOFTWARE\\Microsoft\\CTF\\Sapilayr\\");
const TCHAR c_szDocBlockSize[]     = TEXT("docblocksize");
const TCHAR c_szMaxCandChars[]     = TEXT("MaxCandChars");

// Rule and property values in shrdcmd.xml
const WCHAR c_szSelword[]       = L"selword";
const WCHAR c_szSelThrough[]    = L"SelectThrough";
const WCHAR c_szSelectSimple[]  = L"SelectSimpleCmds";
const WCHAR c_szEditCmds[]      = L"EditCmds";
const WCHAR c_szNavigationCmds[]= L"NavigationCmds";
const WCHAR c_szCasingCmds[]    = L"CasingCmds";
const WCHAR c_szKeyboardCmds[]  = L"KeyboardCmds";

// Rule and property values in spell.xml
const WCHAR c_szSpelling[]      = L"spelling";
const WCHAR c_szSpellMode[]     = L"spellmode";
const WCHAR c_szSpellThat[]     = L"spellthat";
const WCHAR c_szSpellingMode[]  = L"spellingmode";

// Rule and property values in dictcmd.xml
const WCHAR c_szDictTBRule[]    = L"ToolbarCmd";  // Diction toolbar command rule name in dictcmd.xml
const WCHAR c_szDynUrlHist[]    = L"UrlDynHistory";  // modebias command for Url History
const WCHAR c_szStaticUrlHist[] = L"UrlHistory";
const WCHAR c_szStaticUrlSpell[] = L"UrlSpelling";

const WCHAR c_szHttp[]          = L"http";
const WCHAR c_szDot[]           = L"dot";
const WCHAR c_szSlash[]         = L"slash";
const WCHAR c_szColon[]         = L"colon";
const WCHAR c_szTilda[]         = L"tilda";
const WCHAR c_szWWWDot[]        = L"www dot";
const WCHAR c_szDotCom[]        = L"dot com";
const WCHAR c_szDotHtml[]        = L"dot html";
const WCHAR c_szDotExe[]        = L"dot exe";
const WCHAR c_szWWW[]           = L"www";
const WCHAR c_szCom[]           = L"com";
const WCHAR c_szHtml[]          = L"html";
const WCHAR c_szExe[]          =  L"exe";

const WCHAR c_szHttpSla2[]         = L"http://";
const WCHAR c_szSymDot[]           = L".";
const WCHAR c_szSymSlash[]         = L"/";
const WCHAR c_szSymColon[]         = L":";
const WCHAR c_szSymTilda[]         = L"~";
const WCHAR c_szSymWWWDot[]        = L"www.";
const WCHAR c_szSymDotCom[]        = L".com";
const WCHAR c_szSymDotExe[]        = L".exe";
const WCHAR c_szSymDotHtml[]       = L".html";

#define    MAX_CANDIDATE_CHARS    128
#define    MAX_ALTERNATES_NUM     20


// global typedef
typedef struct {
    GUID guidFormatId;
}SRPROPHEADER;

//
// per thread information.
//
class CSpeechUIServer;
typedef struct {
    CSpeechUIServer *psus;
}SPTIPTHREAD;

SPTIPTHREAD *GetSPTIPTHREAD();
void FreeSPTIPTHREAD();
void UninitProcess();
void LoadSpgrmrModule();

#define    TF_SAPI_PERF   0x00010000     // for SAPI perf tracing
#define    TF_LB_SINK     0x00020000     // for Language Bar sink related code tracing
#define    TF_SPBUTTON    0x00040000     // for speech button & mode change tracing.

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\lmobj.h ===
//
//    lmobj.h
//
//    LMOBJ class definition

#ifndef LMOBJ_H
#define LMOBJ_H

#include "private.h"
#include "sapilayr.h"
#include "candlist.h"
#include "ptrary.h"
#include "initguid.h"
//#include "msime.h"
#include "fnrecon.h"

#if  0
class CSapiAlternativeList;

class CLMObject
{
public:
    CLMObject() { m_pFELang = 0; }
    ~CLMObject();
    
    HRESULT InitLM();

    HRESULT AddHomonymsToAlternates(CSapiAlternativeList *pAlternates);
#ifdef LATER
    HRESULT FilterAlternates(CSapiAlternativeList *pAlternates);
#endif
    BOOL    InitOK (void) { return m_fInitOK; }

private:
    IFELanguage              *m_pFELang;
    BOOL                     m_fInitOK;
};

#endif  // if 0

//
// LMAlternates
//
// right now this is nothing more than a wrapper object of
// a single unicode string, but this may need to accomodate
// SRPHRASE objects in the future.
//
class CLMAlternates
{
public:
    ~CLMAlternates()
    {
        if (m_szAlternates)
        {
            delete[] m_szAlternates;
        }
    }

    HRESULT SetString(WCHAR *psz, int cch)
    {
        if (psz)
        {
            if (m_szAlternates)
            {
                delete[] m_szAlternates;
            }
            m_szAlternates = new WCHAR[cch+1];
            if (m_szAlternates)
            {
                wcsncpy(m_szAlternates, psz, cch);
                m_szAlternates[cch] = L'\0';
                
                m_cch = min(cch, (int)wcslen(m_szAlternates));

                return S_OK;
            }
        }
        return E_INVALIDARG;
    }
    HRESULT GetString(WCHAR *psz, int cch)
    {
        if (m_szAlternates && psz)
        {
            wcsncpy(psz, m_szAlternates, cch);        
            return S_OK;
        }
        return E_FAIL;
    }
    
    int GetLen() {return m_cch;}
    
private:
    WCHAR *m_szAlternates;
    int    m_cch;
};


class CSapiIMX;
class CMasterLMWrap
{
public:
    CMasterLMWrap(CSapiIMX *psi) 
    {
        m_langidMasterLM = (LANGID)-1;
        m_fLMInited      = FALSE;
        m_psi            = psi;
    }
    
    void _EnsureMasterLM(LANGID langidRequested);
    
protected: 
    LANGID                    m_langidMasterLM;
    CComPtr<ITfFnLMProcessor> m_cpMasterLM;
    BOOL                      m_fLMInited;
    CSapiIMX                  *m_psi;
};
#endif // LMOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\lmobj.cpp ===
//
// LMOBJ.CPP
//
// implements a wrapper for external LM that we use for
// pre-processing SR lattice
//
//

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "fnrecon.h"
//#include "lmobj.h"
//#include "catutil.h"

//
// CMasterLMWrap implementation
//

//+---------------------------------------------------------------------------
//
// CMasterLMWrap::_EnsureMasterLM
//
//----------------------------------------------------------------------------
void CMasterLMWrap::_EnsureMasterLM(LANGID langidRequested)
{
    // langidRequested is given based on langid of reconversion range
    // m_langidMasterLM is based on the last master LMTIP we worked with
    //
    if (TRUE == m_fLMInited)
        return;
    
    if (!m_psi->_MasterLMEnabled())
        return;

    if ( !m_cpMasterLM || m_langidMasterLM != langidRequested )
    {
        m_cpMasterLM.Release();
    
        CComPtr<IEnumGUID>            cpEnum;
        HRESULT hr = LibEnumItemsInCategory(m_psi->_GetLibTLS(), GUID_TFCAT_TIP_MASTERLM, &cpEnum);   
        if (S_OK == hr)
        {
            GUID guidLMTIP;
            BOOL    fLangOK = FALSE;
            while(cpEnum->Next(1, &guidLMTIP, NULL) == S_OK && !fLangOK)
            {
                ITfFunctionProvider           *pFuncPrv = NULL;

                // check if the TIP can accomodate the language
                Assert(m_psi->_tim);
                hr = m_psi->_tim->GetFunctionProvider(guidLMTIP, &pFuncPrv);
                if (S_OK == hr)
                {
                    CComPtr<IUnknown>             cpunk;
                    CComPtr<ITfFnLMProcessor>     cpLMTIP;
                    hr = pFuncPrv->GetFunction(GUID_NULL, IID_ITfFnLMProcessor, &cpunk);
                    if (S_OK == hr)
                    {
                        hr = cpunk->QueryInterface(IID_ITfFnLMProcessor, (void **)&cpLMTIP);
                    }
                    
                    if (S_OK == hr)
                    {
                        hr = cpLMTIP->QueryLangID(langidRequested, &fLangOK);
                    }
                    
                    if (fLangOK == TRUE)
                    {
                        m_cpMasterLM = cpLMTIP;
                        m_langidMasterLM = langidRequested;
                    }
                    
                    SafeReleaseClear(pFuncPrv);
                } // if S_OK == GetFunctionProvider()
                
            } // while next
            
        } // if LibEnumItemsInCategory() == S_OK
        m_fLMInited = TRUE;
    } // if !m_cpMasterLM
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\nui.cpp ===
//
// nui.cpp
//

#include "private.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "xstring.h"
#include "nui.h"
#include "ids.h"
#include "cicspres.h"
#include "cresstr.h"
#include "slbarid.h"
#include "ptrary.h"
#include "ctffunc.h"


/* ad8d338b-fb07-4e06-8d5b-911baad9eeb3 */
const IID IID_PRIV_CSPEECHUISERVER = { 
    0xad8d338b,
    0xfb07,
    0x4e06,
    {0x8d, 0x5b, 0x91, 0x1b, 0xaa, 0xd9, 0xee, 0xb3}
  };

/* e49d6ff3-1fff-43ba-b835-3a122e98a1c9 */
const GUID GUID_LBI_SAPILAYR_MICROPHONE = { 
    0xe49d6ff3,
    0x1fff,
    0x43ba,
    {0xb8, 0x35, 0x3a, 0x12, 0x2e, 0x98, 0xa1, 0xc9}
  };

/* 3f9ea2e3-75d6-4879-86c2-2bcc2b6fa46e */
const GUID GUID_LBI_SAPILAYR_BALLOON = { 
    0x3f9ea2e3,
    0x75d6,
    0x4879,
    {0x86, 0xc2, 0x2b, 0xcc, 0x2b, 0x6f, 0xa4, 0x6e}
  };

/* 17f9fa7f-a9ed-47b5-8bcd-eebb94b2e6ca */
const GUID GUID_LBI_SAPILAYR_COMMANDING = { 
    0x17f9fa7f,
    0xa9ed,
    0x47b5,
    {0x8b, 0xcd, 0xee, 0xbb, 0x94, 0xb2, 0xe6, 0xca}
  };

/* 49261a4a-87df-47fc-8a68-6ea07ba82a87 */
const GUID GUID_LBI_SAPILAYR_DICTATION = { 
    0x49261a4a,
    0x87df,
    0x47fc,
    {0x8a, 0x68, 0x6e, 0xa0, 0x7b, 0xa8, 0x2a, 0x87}
  };

/* 791b4403-0cda-4fe1-b748-517d049fde08 */
const GUID GUID_LBI_SAPILAYR_TTS_PLAY_STOP = {
    0x791b4403,
    0x0cda,
    0x4fe1,
    {0xb7, 0x48, 0x51, 0x7d, 0x04, 0x9f, 0xde, 0x08}
  };

/* e6fbfc9d-a2e0-4203-a27b-af2353e6a44e */
const GUID GUID_LBI_SAPILAYR_TTS_PAUSE_RESUME = {
    0xe6fbfc9d,
    0xa2e0,
    0x4203,
    {0xa2, 0x7b, 0xaf, 0x23, 0x53, 0xe6, 0xa4, 0x4e}
  };

CPtrArray<SPTIPTHREAD> *g_rgstt = NULL;



//+---------------------------------------------------------------------------
//
// GetSPTIPTHREAD
//
//----------------------------------------------------------------------------

SPTIPTHREAD *GetSPTIPTHREAD()
{
    SPTIPTHREAD *pstt;

    if (g_dwTlsIndex == (DWORD)-1)
        return NULL;

    pstt = (SPTIPTHREAD *)TlsGetValue(g_dwTlsIndex);
    if (!pstt)
    {
        pstt = (SPTIPTHREAD *)cicMemAllocClear(sizeof(SPTIPTHREAD));
        if (!TlsSetValue(g_dwTlsIndex, pstt))
        {
            cicMemFree(pstt);
            pstt = NULL;
        }

        EnterCriticalSection(g_cs);

        if (!g_rgstt)
            g_rgstt = new CPtrArray<SPTIPTHREAD>;
        
        if (g_rgstt)
        {
            if (g_rgstt->Insert(0, 1))
            {
                g_rgstt->Set(0, pstt);
            }
            else
            {
                TlsSetValue(g_dwTlsIndex, NULL);
                cicMemFree(pstt);
                pstt = NULL;
            }
        }

        LeaveCriticalSection(g_cs);
    }

    return pstt;
}

//+---------------------------------------------------------------------------
//
// FreeSPTIPTHREAD
//
//----------------------------------------------------------------------------

void FreeSPTIPTHREAD()
{
    SPTIPTHREAD *pstt;

    if (g_dwTlsIndex == (DWORD)-1)
        return;

    pstt = (SPTIPTHREAD *)TlsGetValue(g_dwTlsIndex);
    if (pstt)
    {
        EnterCriticalSection(g_cs);

        if (g_rgstt)
        {
            int nCnt = g_rgstt->Count();
            while (nCnt)
            {
                nCnt--;
                if (g_rgstt->Get(nCnt) == pstt)
                {
                    g_rgstt->Remove(nCnt, 1);
                    break;
                }
            }
        }

        LeaveCriticalSection(g_cs);

        cicMemFree(pstt);
        TlsSetValue(g_dwTlsIndex, NULL);
    }

    return;
}

//+---------------------------------------------------------------------------
//
// UninitProcess()
//
//+---------------------------------------------------------------------------

void UninitProcess()
{
    //
    // FreeSPTIPTHREAD2() removes psfn from PtrArray.
    //
    if (g_rgstt)
    {
        while(g_rgstt->Count())
        {
            SPTIPTHREAD *pstt = g_rgstt->Get(0);
            g_rgstt->Remove(0, 1);
            cicMemFree(pstt);
        }
        delete g_rgstt;
        g_rgstt = NULL;
    }

    //
    // Free speech grammar resource module(SPGRMR.DLL)
    //
    if (g_hInstSpgrmr)
    {
        FreeLibrary(g_hInstSpgrmr);
    }

    //
    // Free XP SP1 resource module(XPSP1RES.DLL) if it is loaded.
    //
    FreeCicResInstance();
}

//+---------------------------------------------------------------------------
//
// LoadSpgrmrModule()
//
//+---------------------------------------------------------------------------

void LoadSpgrmrModule()
{
    if (!g_hInstSpgrmr)
    {
        TCHAR szSpgrmrPath[MAX_PATH + 32];

        if (GetWindowsDirectory(szSpgrmrPath, MAX_PATH))
        {
            StringCchCat(szSpgrmrPath,
                         ARRAYSIZE(szSpgrmrPath),
                         TEXT("\\IME\\SPGRMR.DLL"));

            g_hInstSpgrmr = LoadLibrary(szSpgrmrPath);
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CSpeechUIServer
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// PostCreateInstance
//
//----------------------------------------------------------------------------

void CSpeechUIServer::PostCreateInstance(REFIID riid, void *pvObj)
{
    if (IsEqualGUID(riid, IID_ITfSpeechUIServer))
    {
        ((CSpeechUIServer *)pvObj)->_EnsureSpeechProfile();
    }
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSpeechUIServer::CSpeechUIServer()
{
    _SetThis(this);

    _tim = NULL;
    _lbim = NULL;
    _fShown = FALSE;
    m_fCommandingReady  = FALSE;
}


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSpeechUIServer::~CSpeechUIServer()
{
    if (_fShown)
        ShowUI(FALSE);

    if (_pCes)
    {
        _pCes->_Unadvise();
        SafeReleaseClear(_pCes);
    }

    SafeRelease(_plbiMicrophone);
    SafeRelease(_plbiCfgMenuButton);
    SafeRelease(_plbiBalloon);
    SafeRelease(_plbiDictation);
    SafeRelease(_plbiCommanding);
    SafeRelease(_plbiTtsPlayStop);
    SafeRelease(_plbiTtsPauseResume);
    SafeRelease(_tim);
    SafeRelease(_lbim);

    GlobalDeleteAtom(m_hAtom);

    _SetThis(NULL);
}

//+---------------------------------------------------------------------------
//
// Initialize
//
//----------------------------------------------------------------------------

STDAPI CSpeechUIServer::Initialize()
{
    HRESULT hr;
    if (_tim)
        return S_OK;

    if (FAILED(hr = TF_CreateThreadMgr(&_tim)))
        return hr;

    if (FAILED(hr = GetService(_tim, 
                               IID_ITfLangBarItemMgr, 
                               (IUnknown **)&_lbim)))
        return hr;

    if (!(_pCes = new CCompartmentEventSink(_CompEventSinkCallback, this)))
    {
        return E_OUTOFMEMORY;
    }

    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, TRUE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, FALSE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, TRUE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, TRUE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SHARED_BLN_TEXT, TRUE); 
    _pCes->_Advise(_tim, GUID_COMPARTMENT_TTS_STATUS, FALSE);
    //TABLETPC
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGE, FALSE);
    _pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, TRUE);

    // SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, 7, TRUE);

    // this is for TABLET
    DWORD  dw = 0;
    GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
    m_fStageVisible = dw ? TRUE : FALSE;
    m_fStageTip = FALSE;

    return S_OK;
}

// internal API specially added for ctfmon
extern "C" 
HRESULT WINAPI TF_CreateLangProfileUtil(ITfFnLangProfileUtil **ppFnLangUtil);
extern "C" HRESULT WINAPI TF_InvalidAssemblyListCacheIfExist();

void CSpeechUIServer::_EnsureSpeechProfile()
{
    CLangProfileUtil *pCLangUtil = NULL;
    CSapiIMX         *pimx;

    
    if (pimx = GetIMX())
    {
        pCLangUtil = SAFECAST(pimx, CLangProfileUtil *);
        pCLangUtil->AddRef();
    }
    else
    {
        // ref gets added by the API
        TF_CreateLangProfileUtil((ITfFnLangProfileUtil **)&pCLangUtil);
    }

    if (pCLangUtil)
    {
        // do this only once when profiles are not populated for the user
        if(!pCLangUtil->_fUserInitializedProfile())
        {
            if (S_OK == pCLangUtil->RegisterActiveProfiles())
                TF_InvalidAssemblyListCacheIfExist();
        }
    }

    SafeRelease(pCLangUtil);

}

//+---------------------------------------------------------------------------
//
// ShowUI
//
//----------------------------------------------------------------------------
STDAPI CSpeechUIServer::ShowUI(BOOL fShow)
{
    DWORD dwDictState = GetDictStatus();

    if (fShow)
    {
        BOOL fOn = GetOnOff();
        BOOL fDisabled = GetDisabled();
#ifdef TF_DISABLE_SPEECH
        BOOL fDictationDisabled = GetDictationDisabled();
        BOOL fCommandingDisabled = GetCommandingDisabled();
#endif

        SetCompartmentDWORD(0, _tim,
                            GUID_COMPARTMENT_SPEECHUISHOWN,
                            TF_SPEECHUI_SHOWN,
                            FALSE);

        AddItemMicrophone();
        DisableItemMicrophone(fDisabled);
        if (_pimx)
        {
            AddItemCfgMenuButton();
            DisableItemCfgMenuButton(fDisabled);

            if (!fDisabled)
            {
                SetCfgMenu(TRUE);
            }
        }

        if (fOn)
        {
            DWORD dwUIState = GetUIStatus();

            if (!(dwUIState & TF_DISABLE_BALLOON))
            {
                AddItemBalloon();
                DisableItemBalloon(fDisabled);
            }
            else
                RemoveItemBalloon();
    
            AddItemCommanding();
            AddItemDictation();
            DisableItemCommanding(fDisabled || fCommandingDisabled);
            DisableItemDictation(fDisabled || fDictationDisabled || !(dwDictState & TF_DICTATION_ENABLED));
            ToggleItemCommanding((dwDictState & TF_COMMANDING_ON) ? TRUE : FALSE);
            ToggleItemDictation((dwDictState & TF_DICTATION_ON) ? TRUE : FALSE);
        }
        else
        {
            RemoveItemBalloon();
            RemoveItemCommanding();
            RemoveItemDictation();
        }

#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
        _ToggleMicrophone(fOn);
#else
        ToggleItemMicrophone(fOn);
#endif

        // Handle TTS Play & Stop Buttons
        BOOL fTTSButtonEnable; 

        AddItemTtsPlayStop( );
        AddItemTtsPauseResume( );

        fTTSButtonEnable = GetTtsButtonStatus();

        DisableItemTtsPlayStop( !fTTSButtonEnable );
        DisableItemTtsPauseResume( !fTTSButtonEnable );

        if ( fTTSButtonEnable )
        {
            BOOL fTTSPlayOn;
            BOOL fTTSPauseOn;

            fTTSPlayOn = GetTtsPlayOnOff( );
            ToggleItemTtsPlayStop(fTTSPlayOn);
            fTTSPauseOn = GetTtsPauseOnOff( );
            ToggleItemTtsPauseResume(fTTSPauseOn);
        }
    }
    else
    {
        RemoveItemMicrophone();
        SetCfgMenu(FALSE);

        RemoveItemCfgMenuButton();
        RemoveItemBalloon();
        RemoveItemCommanding();
        RemoveItemDictation();
        RemoveItemTtsPlayStop( );
        RemoveItemTtsPauseResume( );

        SetCompartmentDWORD(0, _tim,
                            GUID_COMPARTMENT_SPEECHUISHOWN,
                            0, FALSE);
    }

    _fShown = fShow;
    return S_OK;
}
//+---------------------------------------------------------------------------
//
// UpdateBalloon
//
//----------------------------------------------------------------------------

STDAPI CSpeechUIServer::UpdateBalloon(TfLBBalloonStyle style,
                                      const WCHAR *pch,
                                      ULONG cch)
{
     UpdateBalloonAndTooltip(style, pch, cch, NULL, 0);
     return S_OK;
}

//
// UpdateBalloonAndTooltip (internal method)
//
//
//
HRESULT CSpeechUIServer::UpdateBalloonAndTooltip
(
    TfLBBalloonStyle style, 
    const WCHAR *pch, 
    ULONG cch,
    const WCHAR *pchTooltip,
    ULONG cchTooltip
)
{
        // check if it has same style and string already
    if ((_plbiBalloon && _plbiBalloon->NeedUpdate(style, pch)) || GetSystemMetrics(SM_TABLETPC) > 0)
    {
          
        // we don't pick up out proc tooltip 
        if (pchTooltip && _plbiBalloon)
            _plbiBalloon->SetToolTip((WCHAR *)pchTooltip);

        // this is a private channel for non-cicero UI plugin
        // they pick up this global compartment notification,
        // and store the string for displaying what's set to 
        // any of the balloon objects in the system by Cicero apps. 
        // it should be deleted right after sent to non-cicero threads
        // to avoid ref count management
        //
        if (m_hAtom) 
        {
            GlobalDeleteAtom(m_hAtom);
        }

        m_hAtom = GlobalAddAtomW(pch);
        if (m_hAtom && _tim)
        {
            DWORD  dw;

            dw = m_hAtom + (style << 16);
            SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SHARED_BLN_TEXT, dw, TRUE);
        }
         
    }

    return S_OK;
}

HRESULT CSpeechUIServer::SetBalloonSAPIInitFlag(BOOL fSet)
{
    HRESULT hr = E_FAIL;

    if (_plbiBalloon)
    {
        _plbiBalloon->SetToFireInitializeSAPI(fSet);

        hr = S_OK;
    }

    return hr;
}

#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
//
// ToggleMicrophone (internal method)
//
// synopsis: toggle microphone button and set tooltip accordingly
//
HRESULT CSpeechUIServer::_ToggleMicrophone(BOOL fOn)
{
    if (!_plbiMicrophone)
        return E_FAIL;


    static WCHAR s_szTooltipOff[MAX_PATH] = {0};
    static WCHAR s_szTooltipOn[MAX_PATH] = {0};

    if (!s_szTooltipOff[0])
    {
        CicLoadStringWrapW(g_hInst, IDS_NUI_MICROPHONE_ON_TOOLTIP,
                                    s_szTooltipOff,
                                    ARRAYSIZE(s_szTooltipOff));
    }
    if (!s_szTooltipOn[0])
    {
         CicLoadStringWrapW(g_hInst,  IDS_NUI_MICROPHONE_OFF_TOOLTIP,
                                      s_szTooltipOn,
                                      ARRAYSIZE(s_szTooltipOn));
    }

    WCHAR szMicTooltip[MAX_PATH];

    StringCchCopyW(szMicTooltip, ARRAYSIZE(szMicTooltip), fOn ? s_szTooltipOn : s_szTooltipOff);

    _plbiMicrophone->SetToolTip((WCHAR *)szMicTooltip);

    _plbiMicrophone->SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, fOn); 
    if (_plbiMicrophone->GetSink())
       _plbiMicrophone->GetSink()->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}
#endif

//----------------------------------------------------------------------------
//
// _CompEventSinkCallback (static)
//
//----------------------------------------------------------------------------
HRESULT CSpeechUIServer::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CSpeechUIServer *_this = (CSpeechUIServer *)pv;

    if ((IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE)) ||
        (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_DISABLED)) ||
        (IsEqualGUID(rguid, GUID_COMPARTMENT_TTS_STATUS)))
    {
        if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
        {
           TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_OPENCLOSE to be handled in NUI");
        }

        _this->ShowUI(_this->_fShown);

        if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
        {
           TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_OPENCLOSE is handled in NUI ::ShowUI");
        }

        return S_OK;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_GLOBALSTATE))
    {
        HRESULT hr = S_OK;
        BOOL fFocus;
        if ( (S_OK == _this->_tim->IsThreadFocus(&fFocus) && fFocus) ||
              S_OK == _this->IsActiveThread())
        {
            // We switch states immediately if we have focus or we are the active thread.
            // This allows the stage speech tip instance to turn on/off dictation at the correct time
            // and allows other speech tip instances to turn on C&C only if they have focus (since the
            // stage application does not care about focus-based C&C).
            DWORD dwLocal, dwGlobal;
            GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
            GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
            dwGlobal = dwGlobal & (TF_DICTATION_ON + TF_COMMANDING_ON);
            if ( (dwLocal&(TF_DICTATION_ON + TF_COMMANDING_ON)) != dwGlobal)
            {
                dwLocal = (dwLocal & ~(TF_DICTATION_ON + TF_COMMANDING_ON)) + dwGlobal;
                SetCompartmentDWORD(0, _this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwLocal, FALSE);
            }
        }
        _this->ShowUI(_this->_fShown);
        return hr;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_UI_STATUS))
    {
        DWORD dwDictState = _this->GetDictStatus();
        BOOL fOn = _this->GetOnOff();
        DWORD dwUIState = _this->GetUIStatus();

        if (fOn &&
            (dwDictState  & (TF_DICTATION_ENABLED | TF_COMMANDING_ENABLED)) &&
            !(dwUIState & TF_DISABLE_BALLOON))
        {
            BOOL fDisabled = _this->GetDisabled();
            _this->AddItemBalloon();
            _this->DisableItemBalloon(fDisabled);
        }
        else
            _this->RemoveItemBalloon();

        if (fOn && !(dwUIState & TF_DISABLE_BALLOON))
        {
            // when balloon is shown and
            // for the first time commanding is set on, 
            // we show "Begin Voice Command" as a hint
            // that now user can start speaking
            //
            if (!_this->m_fCommandingReady &&
               (dwDictState & TF_COMMANDING_ON))
            {
                
                WCHAR sz[128];
                sz[0] = '\0';
                CicLoadStringWrapW(g_hInst, IDS_NUI_BEGINVOICECMD, sz, ARRAYSIZE(sz));
       
                _this->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                _this->m_fCommandingReady = TRUE;
            }
        }
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SHARED_BLN_TEXT))
    {
        if (_this->_plbiBalloon&&
           !(TF_LBI_STATUS_HIDDEN & _this->_plbiBalloon->GetStatusInternal()))
        {
            DWORD   dw;

            if (SUCCEEDED(GetCompartmentDWORD(_this->_tim, rguid, &dw, TRUE)))
            {
                ATOM hAtom = (WORD)dw & 0xffff;
                WCHAR szAtom[MAX_PATH] = {0};
                TfLBBalloonStyle     style;

                style = (TfLBBalloonStyle) (dw >> 16);

                GlobalGetAtomNameW(hAtom, szAtom, ARRAYSIZE(szAtom));

                _this->_plbiBalloon->Set(style, szAtom);

                if (_this->_plbiBalloon->GetSink())
                {
                    _this->_plbiBalloon->GetSink()->OnUpdate(TF_LBI_BALLOON);
                }
            }
        }
    }
// TABLETPC
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGE))
    {
		_this->m_fStageTip = TRUE;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGECHANGE))
    {
        HRESULT hr = S_OK;
        DWORD dw;

        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
		_this->m_fStageVisible = dw ? TRUE:FALSE;
    }
// TABLETPC
    return S_FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemMicrophone
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemMicrophone::CLBarItemMicrophone(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemMicrophone"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_MICROPHONE,
                 TF_LBI_STYLE_HIDDENSTATUSCONTROL 
               | TF_LBI_STYLE_BTN_TOGGLE 
               | TF_LBI_STYLE_SHOWNINTRAY, 
                SORT_MICROPHONE,
                CRStr(IDS_NUI_MICROPHONE_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_MICROPHONE_TOOLTIP));
    SetText(CRStr(IDS_NUI_MICROPHONE_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemMicrophone::~CLBarItemMicrophone()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemMicrophone::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    TraceMsg(TF_SAPI_PERF, "Microphone::GetIcon is called");
    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_MICROPHONE));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemMicrophone::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
     TraceMsg(TF_SAPI_PERF, "Microphone button is hit");
     return ToggleCompartmentDWORD(0,
                                   _psus->GetTIM(),
                                   GUID_COMPARTMENT_SPEECH_OPENCLOSE, 
                                   TRUE);
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCfgmenuButton
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemCfgMenuButton::CLBarItemCfgMenuButton(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemCfgMenuButton"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_CFGMENUBUTTON,
                TF_LBI_STYLE_BTN_MENU,
                SORT_CFGMENUBUTTON,
                CRStr(IDS_NUI_CFGMENU_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_CFGMENU_TOOLTIP));
    SetText(CRStr(IDS_NUI_CFGMENU_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemCfgMenuButton::~CLBarItemCfgMenuButton()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_CFGMENU));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::InitMenu(ITfMenu *pMenu)
{
    UINT nTipCurMenuID = IDM_CUSTOM_MENU_START;
    _InsertCustomMenus(pMenu, &nTipCurMenuID);
    
    CSapiIMX::_SysLBarCallback(IDSLB_INITMENU, _psus->GetIMX(), pMenu, 0);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCfgMenuButton::OnMenuSelect(UINT uID)
{
    HRESULT hr;

    if (uID >= IDM_CUSTOM_MENU_START)
        hr =  CLBarItemSystemButtonBase::OnMenuSelect(uID);
    else
        hr = CSapiIMX::_SysLBarCallback(IDSLB_ONMENUSELECT, _psus->GetIMX(), NULL, uID);
    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemBalloon::CLBarItemBalloon(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemBalloon"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_BALLOON,
                0, 
                SORT_BALLOON,
                CRStr(IDS_NUI_BALLOON_TEXT));

    SIZE size;
    size.cx = 100;
    size.cy = 16;
    SetPreferedSize(&size);
    SetToolTip(CRStr(IDS_NUI_BALLOON_TOOLTIP));

    // by default Balloon is hidden.
    // SetStatusInternal(TF_LBI_STATUS_HIDDEN);

    m_fFireInitializeSapi = FALSE;

}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemBalloon::~CLBarItemBalloon()
{
    if (_bstrText)
        SysFreeString(_bstrText);
}

//+---------------------------------------------------------------------------
//
// GetBalloonInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemBalloon::GetBalloonInfo(TF_LBBALLOONINFO *pInfo)
{
    pInfo->style = _style;
    pInfo->bstrText = SysAllocString(_bstrText);

    //
    // If the flag is set, we're asked to fire an event to set
    // a timer to start SAPI intialization
    //
    if (m_fFireInitializeSapi)
    {
        // turns the flag off
        SetToFireInitializeSAPI(FALSE);

        TraceMsg(TF_SAPI_PERF, "GetBalloonInfo is called");

        CSapiIMX *pimx = _psus->GetIMX();
        if (pimx)
        {
            pimx->_EnsureWorkerWnd();

            SetTimer(pimx->_GetWorkerWnd(), TIMER_ID_OPENCLOSE, 100, NULL);
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Set
//
//----------------------------------------------------------------------------

void CLBarItemBalloon::Set(TfLBBalloonStyle style, const WCHAR *psz) 
{
    if (_bstrText)
        SysFreeString(_bstrText);

    _bstrText = SysAllocString(psz);
    if (_bstrText)
    {
        SetToolTip(_bstrText);
    }

    _style = style;

}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDictation
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemDictation::CLBarItemDictation(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemDictation"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_DICTATION,
                TF_LBI_STYLE_BTN_TOGGLE, 
                SORT_DICTATION,
                CRStr(IDS_NUI_DICTATION_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_DICTATION_TOOLTIP));
    SetText(CRStr(IDS_NUI_DICTATION_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemDictation::~CLBarItemDictation()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemDictation::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_DICTATION));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemDictation::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    _psus->SetDictStatus();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCommanding
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemCommanding::CLBarItemCommanding(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemCommanding"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_COMMANDING,
                TF_LBI_STYLE_BTN_TOGGLE, 
                SORT_COMMANDING,
                CRStr(IDS_NUI_COMMANDING_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_COMMANDING_TOOLTIP));
    SetText(CRStr(IDS_NUI_COMMANDING_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemCommanding::~CLBarItemCommanding()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemCommanding::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_COMMANDING));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemCommanding::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    _psus->SetCmdStatus();
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPlayStop
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemTtsPlayStop::CLBarItemTtsPlayStop(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemTtsPlayStop"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_TTS_PLAY_STOP,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_HIDDENBYDEFAULT, 
                SORT_TTSPLAYSTOP,
                CRStr(IDS_NUI_TTSPLAY_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_TTSPLAY_TOOLTIP));
    SetText(CRStr(IDS_NUI_TTSPLAY_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemTtsPlayStop::~CLBarItemTtsPlayStop()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemTtsPlayStop::GetIcon(HICON *phIcon)
{
    BOOL     fTTSPlayOn;

    if (!phIcon)
        return E_INVALIDARG;

    if (!_psus)  return E_FAIL;

    fTTSPlayOn = _psus->GetTtsPlayOnOff( );

    if ( fTTSPlayOn )
    {
        *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSSTOP));
    }
    else
    {
        *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSPLAY));
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemTtsPlayStop::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    HRESULT                 hr = S_OK;
    CSapiIMX                *pimx;

    if ( _psus == NULL)  return E_FAIL;

    pimx = _psus->GetIMX();

    if ( pimx )
    {
        hr = pimx->_HandleEventOnPlayButton( );
    }

    return hr;
}

// +-------------------------------------------------------------------------
//
// UpdateStatus
//
//      Update the text, tooltips, and icons based on current Play/Stop 
//      button's status.
// +-------------------------------------------------------------------------

HRESULT CLBarItemTtsPlayStop::UpdateStatus( )
{
    HRESULT  hr = S_OK;
    BOOL     fTTSPlayOn;

    if (!_psus)  return E_FAIL;

    fTTSPlayOn = _psus->GetTtsPlayOnOff( );

    if ( fTTSPlayOn )  // Toggled status
    {
        SetToolTip(CRStr(IDS_NUI_TTSSTOP_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSSTOP_TEXT));
    }
    else
    {
        SetToolTip(CRStr(IDS_NUI_TTSPLAY_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSPLAY_TEXT));
    }

    if ( GetSink( ) )
        GetSink( )->OnUpdate(TF_LBI_ICON | TF_LBI_TEXT | TF_LBI_TOOLTIP);

    // Update the toolbar command grammar to use the new tooltip text
    // Speak Text  or  Stop speaking

    CSapiIMX   *pImx;

    pImx = _psus->GetIMX( );

    if ( pImx)
    {
        CSpTask           *psp;

        pImx->GetSpeechTask(&psp);
        if (psp)
        {
            if ( psp->m_pLangBarSink )
                (psp->m_pLangBarSink)->OnThreadItemChange(0);

            psp->Release();
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPauseResume
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemTtsPauseResume::CLBarItemTtsPauseResume(CSpeechUIServer *psus)
{
    Dbg_MemSetThisName(TEXT("CLBarItemTtsPauseResume"));

    _psus = psus;
    InitNuiInfo(CLSID_SYSTEMLANGBARITEM_SPEECH, 
                GUID_LBI_SAPILAYR_TTS_PAUSE_RESUME,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_HIDDENBYDEFAULT, 
                SORT_TTSPAUSERESUME,
                CRStr(IDS_NUI_TTSPAUSE_TOOLTIP));

    SetToolTip(CRStr(IDS_NUI_TTSPAUSE_TOOLTIP));
    SetText(CRStr(IDS_NUI_TTSPAUSE_TEXT));
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemTtsPauseResume::~CLBarItemTtsPauseResume()
{
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemTtsPauseResume::GetIcon(HICON *phIcon)
{
    if (!phIcon)
        return E_INVALIDARG;

    *phIcon = LoadSmIcon(g_hInst, MAKEINTRESOURCE(ID_ICON_TTSPAUSE));

    return S_OK;

}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CLBarItemTtsPauseResume::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    HRESULT                 hr = S_OK;
    CSapiIMX                *pimx;

    if ( _psus == NULL)  return E_FAIL;

    pimx = _psus->GetIMX();

    if (pimx)
    {
        hr = pimx->_HandleEventOnPauseButton( );
    }

    return hr;
}

// +-------------------------------------------------------------------------
//
// UpdateStatus
//
//     Update text, tooltips, icons for Pause/Resume buttons
//     based on current status.
// +-------------------------------------------------------------------------

HRESULT CLBarItemTtsPauseResume::UpdateStatus( )
{
    HRESULT  hr = S_OK;
    BOOL     fTTSPauseOn;

    if (!_psus)  return E_FAIL;

    fTTSPauseOn = _psus->GetTtsPauseOnOff( );

    if ( fTTSPauseOn )  // Toggled status
    {
        SetToolTip(CRStr(IDS_NUI_TTSRESUME_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSRESUME_TEXT));
    }
    else
    {
        SetToolTip(CRStr(IDS_NUI_TTSPAUSE_TOOLTIP));
        SetText(CRStr(IDS_NUI_TTSPAUSE_TEXT));
    }

    if ( GetSink( ) )
        GetSink( )->OnUpdate(TF_LBI_TEXT | TF_LBI_TOOLTIP);

    // Update the toolbar command grammar to use the new tooltip text
    // Pause Speaking  or  Resume speaking

    CSapiIMX   *pImx;

    pImx = _psus->GetIMX( );

    if ( pImx)
    {
        CSpTask           *psp;

        pImx->GetSpeechTask(&psp);
        if (psp)
        {
            if ( psp->m_pLangBarSink )
                (psp->m_pLangBarSink)->OnThreadItemChange(0);

            psp->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\miscfunc.cpp ===
//
//
// Sapilayr TIP Misc function impl.
//
//
#include "private.h"
#include "sapilayr.h"
#include "nui.h"
#include "miscfunc.h"

//////////////////////////////////////////////////////////////////////////////
//
// CGetSAPIObject
//
//////////////////////////////////////////////////////////////////////////////

//
// ctor / dtor
//

CGetSAPIObject::CGetSAPIObject(CSapiIMX *psi)
{
    m_psi = psi;
    m_psi->AddRef();
    m_psi->GetFocusIC(&m_cpIC); // AddRef in the call
    m_cRef = 1; 
}

CGetSAPIObject::~CGetSAPIObject()
{
    if (m_psi)
        m_psi->Release();
}

//
// IUnknown
//
STDMETHODIMP CGetSAPIObject::QueryInterface(REFGUID riid, LPVOID *ppvObj)
{
    Assert(ppvObj);
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnGetSAPIObject))
    {
        *ppvObj = SAFECAST(this, CGetSAPIObject *);
    }
    
    if (*ppvObj)
    {
       AddRef();
       return S_OK;
   }
   
   return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CGetSAPIObject::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CGetSAPIObject::Release(void)
{
    long cr;
    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);
    
    if (cr == 0)
    {
        delete this;
    }
    return cr;
}

//
// ITfFunction
//
STDMETHODIMP CGetSAPIObject::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Get SAPI objects");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

// 
// ITfFnGetSAPIObject
//

static const struct {
    TfSapiObject sObj;
    const GUID  *riid; 
    BOOL        fInit;
} SapiInterfaceTbl[] =
{
    {GETIF_RESMGR                , &IID_ISpResourceManager, TRUE },

    {GETIF_RECOCONTEXT           , &IID_ISpRecoContext,  TRUE},

    {GETIF_RECOGNIZER            , &IID_ISpRecognizer,  TRUE},
    {GETIF_VOICE                 , &IID_ISpVoice,  TRUE},
    {GETIF_DICTGRAM              , &IID_ISpRecoGrammar,  TRUE},
    {GETIF_RECOGNIZERNOINIT      , &IID_ISpRecognizer,  FALSE},

};

STDMETHODIMP CGetSAPIObject::Get(TfSapiObject sObj, IUnknown **ppunk)
{
    HRESULT hr = S_FALSE;

    //
    // sObj is an index to SapiInterfaceTbl[]
    //
    Assert(GETIF_RESMGR == 0);

    if (ppunk)
        *ppunk = NULL;

    if(sObj < ARRAYSIZE(SapiInterfaceTbl))
    {
        CSpTask *psptask = NULL;
        if (S_OK == m_psi->GetSpeechTask(&psptask, SapiInterfaceTbl[sObj].fInit))
        {
            hr = psptask->GetSAPIInterface(*(SapiInterfaceTbl[sObj].riid), (void **)ppunk);
        }
        SafeRelease(psptask);
    }
    return hr;
}


// 
// IsSupported() (internal) 
//               returns S_OK when the passed in IID is supported, 
//               otherwise returns S_FALSE
//
//
HRESULT CGetSAPIObject::IsSupported(REFIID riid, TfSapiObject *psObj)
{
    HRESULT hr = S_FALSE;

    Assert(psObj);

    for (int i = 0; i < ARRAYSIZE(SapiInterfaceTbl); i++)
    {
        Assert(i == SapiInterfaceTbl[i].sObj);

        if (IsEqualGUID(*SapiInterfaceTbl[i].riid, riid))
        {
            *psObj = SapiInterfaceTbl[i].sObj;
            hr = S_OK;

            break;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnBalloon
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnBalloon::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnBalloon))
    {
        *ppvObj = SAFECAST(this, CFnBalloon *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnBalloon::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnBalloon::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnBalloon::CFnBalloon(CSapiIMX *psi) : CFunction(psi)
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnBalloon::~CFnBalloon()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnBalloon::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Speech Conversion");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnBalloon::UpdateBalloon
//
//----------------------------------------------------------------------------

STDAPI CFnBalloon::UpdateBalloon(TfLBBalloonStyle style, const WCHAR *pch, ULONG cch)
{
    HRESULT hr = S_OK;
    if (!m_pImx->GetSpeechUIServer())
        return hr;

    m_pImx->GetSpeechUIServer()->UpdateBalloon(style, pch, cch);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnAbort))
    {
        *ppvObj = SAFECAST(this, CFnAbort *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnAbort::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnAbort::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnAbort::CFnAbort(CSapiIMX *psi) : CFunction(psi)
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnAbort::~CFnAbort()
{
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnAbort::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"Speech Abort Pending Conversion");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnAbort::Abort
//
//----------------------------------------------------------------------------

HRESULT CFnAbort::Abort(ITfContext *pctxt)
{
    HRESULT hr;

    Assert(m_pImx);
    Assert(pctxt);

    // put up the hour glass
    HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = m_pImx->_RequestEditSession(ESCB_ABORT,TF_ES_READWRITE | TF_ES_SYNC, NULL, pctxt);

    if (hCur)
       SetCursor(hCur);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  CFnConfigure::Show
//
//----------------------------------------------------------------------------
STDMETHODIMP CFnConfigure::Show(HWND hwndParent, LANGID langid, REFGUID rguidProfile)
{
    m_psi->_InvokeSpeakerOptions( TRUE );

    return S_OK;
};


//+---------------------------------------------------------------------------
//
//  CFnPropertyUIStatus implementation
//
//----------------------------------------------------------------------------

//
// IUnknown
//
STDMETHODIMP CFnPropertyUIStatus::QueryInterface(REFGUID riid, LPVOID *ppvObj)
{
    Assert(ppvObj);
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnPropertyUIStatus))
    {
        *ppvObj = SAFECAST(this, CFnPropertyUIStatus *);
    }

    if (*ppvObj)
    {
       AddRef();
       return S_OK;
   }

   return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CFnPropertyUIStatus::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFnPropertyUIStatus::Release(void)
{
    long cr;
    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }
    return cr;
}

STDMETHODIMP CFnPropertyUIStatus::GetStatus(REFGUID refguidProp, DWORD *pdw)
{
    HRESULT hr = S_FALSE;

    if (pdw)
    {
        *pdw = 0;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr) &&
        IsEqualGUID(refguidProp, GUID_PROP_SAPIRESULTOBJECT))
    {
        *pdw |= m_psi->_SerializeEnabled() ? 
                       TF_PROPUI_STATUS_SAVETOFILE : 0;
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\nui.h ===
//
// nui.h
//

#ifndef NUI_H
#define NUI_H

#include "private.h"
#include "nuibase.h"
#include "timsink.h"
#include "sysbtn.h"

#define SORT_MICROPHONE      100
#define SORT_DICTATION       300
#define SORT_COMMANDING      400
#define SORT_BALLOON         500
#define SORT_TTSPLAYSTOP     510
#define SORT_TTSPAUSERESUME  520
#define SORT_CFGMENUBUTTON   600

// If Enable bit is 1, Show active buttons, 
// If it is 0, Gray the buttons.

// If Toggled bit is 1, show stop or resume buttons respectively.
// If it is 0, show play or pause buttons respectively.
#define TF_TTS_PLAY_STOP_TOGGLED     0x0001   
#define TF_TTS_PAUSE_RESUME_TOGGLED  0x0002

#define TF_TTS_BUTTON_ENABLE         0x0008

extern const IID IID_PRIV_CSPEECHUISERVER;
extern const GUID GUID_LBI_SAPILAYR_MICROPHONE;
extern const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON;
extern const GUID GUID_LBI_SAPILAYR_BALLOON;

class CSapiIMX;
class CLBarItemMicrophone;
class CLBarItemCfgMenuButton;
class CLBarItemBalloon;
class CLBarItemCommanding;
class CLBarItemDictation;
class CLBarItemSystemButtonBase;
class CLBarItemTtsPlayStop;
class CLBarItemTtsPauseResume;


#define ADDREMOVEITEMFUNCDEF(item_name)              \
    void AddItem ## item_name ## ();                 \
    void RemoveItem ## item_name ## ();              \
    void DisableItem ## item_name ## (BOOL fDisable);

#define ADDREMOVEITEMFUNC(item_name)                                          \
    __inline void CSpeechUIServer::AddItem ## item_name ## ()                 \
    {                                                                         \
        if (!_plbi ## item_name ## )                                          \
            _plbi ## item_name ##  = new CLBarItem ## item_name ## (this);    \
        if (_plbi ## item_name ## )                                           \
            _lbim->AddItem(_plbi ## item_name ## );                           \
    }                                                                         \
                                                                              \
    __inline void CSpeechUIServer::RemoveItem ## item_name ## ()              \
    {                                                                         \
        if (_plbi ## item_name ## )                                           \
            _lbim->RemoveItem(_plbi ## item_name ## );                        \
    }                                                                         \
                                                                              \
    __inline void CSpeechUIServer::DisableItem ## item_name ## (BOOL fDisable) \
    {                                                                         \
    if (!_plbi ## item_name ## )                                              \
        return;                                                               \
    _plbi ## item_name ## ->SetOrClearStatus(TF_LBI_STATUS_DISABLED,          \
                                             fDisable);                       \
    if (_plbi ## item_name ## ->GetSink())                                    \
       _plbi ## item_name ## ->GetSink()->OnUpdate(TF_LBI_STATUS);            \
    }

#define TOGGLEITEMFUNCDEF(item_name)                                          \
    void ToggleItem ## item_name ## (BOOL fOn);

#define TOGGLEITEMFUNC(item_name)                                             \
    __inline void CSpeechUIServer::ToggleItem ## item_name ## (BOOL fOn)      \
    {                                                                         \
    if (!_plbi ## item_name ## )                                              \
        return;                                                               \
    _plbi ## item_name ## ->SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, fOn); \
    if (_plbi ## item_name ## ->GetSink())                                    \
       _plbi ## item_name ## ->GetSink()->OnUpdate(TF_LBI_STATUS);            \
    }


//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPlayStop
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemTtsPlayStop : public CLBarItemButtonBase
{
public:
    CLBarItemTtsPlayStop(CSpeechUIServer *psus);
    ~CLBarItemTtsPlayStop();

    STDMETHODIMP GetIcon(HICON *phIcon);

    HRESULT   UpdateStatus( );

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemTtsPauseResume
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemTtsPauseResume : public CLBarItemButtonBase
{
public:
    CLBarItemTtsPauseResume(CSpeechUIServer *psus);
    ~CLBarItemTtsPauseResume();

    STDMETHODIMP GetIcon(HICON *phIcon);

    HRESULT   UpdateStatus( );

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};


//////////////////////////////////////////////////////////////////////////////
//
// CSpeechUIServer
//
//////////////////////////////////////////////////////////////////////////////

class CSpeechUIServer : public ITfSpeechUIServer,
                        public CComObjectRoot_CreateSingletonInstance_Verify<CSpeechUIServer>
{
public:
    CSpeechUIServer();
    ~CSpeechUIServer();

    BEGIN_COM_MAP_IMMX(CSpeechUIServer)
        COM_INTERFACE_ENTRY_IID(IID_PRIV_CSPEECHUISERVER, CSpeechUIServer)
        COM_INTERFACE_ENTRY(ITfSpeechUIServer)
    END_COM_MAP_IMMX()

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj) { return TRUE; }
    static void PostCreateInstance(REFIID riid, void *pvObj);

    //
    // ITfSpeechUIServer
    //
    STDMETHODIMP Initialize();
    STDMETHODIMP ShowUI(BOOL fShow);
    STDMETHODIMP UpdateBalloon(TfLBBalloonStyle style,
                               const WCHAR *pch,
                               ULONG cch);

    //
    // internal API
    //
    void _EnsureSpeechProfile();

    HRESULT UpdateBalloonAndTooltip
    (
        TfLBBalloonStyle style, 
        const WCHAR *pch, 
        ULONG cch,
        const WCHAR *pchTooltip,
        ULONG cchTooltip
    );

    static CSpeechUIServer *_GetThis() 
    { 
        SPTIPTHREAD *pstt = GetSPTIPTHREAD();
        if (!pstt)
            return NULL;

        return pstt->psus;
    }

    static BOOL _SetThis(CSpeechUIServer *_this)
    { 
        SPTIPTHREAD *ptt = GetSPTIPTHREAD();
        if (!ptt)
            return FALSE;

        ptt->psus = _this;
        return TRUE;
    }

    BOOL GetOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw, TRUE);
        return dw ? TRUE : FALSE;
    }

#ifdef TF_DISABLE_SPEECH
    BOOL GetDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_SPEECH) ? TRUE : FALSE;
    }

    BOOL GetDictationDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_DICTATION) ? TRUE : FALSE;
    }

    BOOL GetCommandingDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_COMMANDING) ? TRUE : FALSE;
    }
#else
    BOOL GetDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return dw  ? TRUE : FALSE;
    }
#endif

    DWORD GetUIStatus()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw, TRUE);
        return dw;
        
    }

    DWORD GetDictStatus()
    {
        DWORD dwLocal, dwGlobal;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
		dwLocal = (dwLocal & (TF_DICTATION_ENABLED | TF_COMMANDING_ENABLED)) + 
			 (dwGlobal & (TF_DICTATION_ON | TF_COMMANDING_ON));
        return dwLocal;
       
    }

    void SetDictStatus()
    {
        DWORD  dwGlobal=0;
        DWORD  dwNewState;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);

        dwNewState = dwGlobal ^ TF_DICTATION_ON;

        if ( dwNewState | TF_DICTATION_ON )
            dwNewState &= ~TF_COMMANDING_ON;  // it is not possible that both Dication On and Command On

        SetCompartmentDWORD(0, 
                            _tim, 
                            GUID_COMPARTMENT_SPEECH_GLOBALSTATE, 
                            dwNewState,
                            TRUE);
    }

    void SetCmdStatus()
    {
        DWORD  dwGlobal=0;
        DWORD  dwNewState;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);

        dwNewState = dwGlobal ^ TF_COMMANDING_ON;

        if ( dwNewState | TF_COMMANDING_ON )
            dwNewState &= ~TF_DICTATION_ON;

        SetCompartmentDWORD(0, 
                            _tim, 
                            GUID_COMPARTMENT_SPEECH_GLOBALSTATE, 
                            dwNewState,
                            TRUE);
    }

    void SetCfgMenu(BOOL fReady)
    {
        DWORD dw;
        HRESULT hr = GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_CFGMENU, &dw, FALSE);
        if (S_OK == hr)
        {
            BOOL  fReadyNow = (dw > 0);
            if (fReadyNow == fReady)
                return;
        }
        SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_CFGMENU, fReady, FALSE);
    }

    BOOL GetTtsPlayOnOff(  )
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        return (dw & TF_TTS_PLAY_STOP_TOGGLED ? TRUE : FALSE);
    }

    void SetTtsPlayOnOff( BOOL  fOn )
    {
        DWORD    dw;
        HRESULT  hr = S_OK;
        BOOL     fEnabled;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        fEnabled = ( dw & TF_TTS_BUTTON_ENABLE) ? TRUE : FALSE;
        if ( fEnabled )
        {
            dw = (dw & ~TF_TTS_PLAY_STOP_TOGGLED) | (fOn ? TF_TTS_PLAY_STOP_TOGGLED : 0 );

            hr = SetCompartmentDWORD(0, 
                                    _tim, 
                                    GUID_COMPARTMENT_TTS_STATUS, 
                                    dw,
                                    FALSE);
            if ( hr == S_OK )
            {
                // update the icon, text, tooltip for Play/Stop botton.
                if ( _plbiTtsPlayStop )
                    _plbiTtsPlayStop->UpdateStatus( );
            }
        }
    }

    BOOL GetTtsPauseOnOff(  )
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        return (dw & TF_TTS_PAUSE_RESUME_TOGGLED ? TRUE : FALSE);
    }

    void SetTtsPauseOnOff( BOOL  fOn )
    {
        DWORD    dw;
        HRESULT  hr;
        BOOL     fEnabled;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        fEnabled = ( dw & TF_TTS_BUTTON_ENABLE) ? TRUE : FALSE;
        if ( fEnabled )
        {
            
            dw = (dw & ~TF_TTS_PAUSE_RESUME_TOGGLED) | (fOn ? TF_TTS_PAUSE_RESUME_TOGGLED : 0);

            hr = SetCompartmentDWORD(0, 
                                    _tim, 
                                    GUID_COMPARTMENT_TTS_STATUS, 
                                    dw,
                                    FALSE);
            if ( hr == S_OK )
            {
                // update the icon, text, tooltip for Pause/Resume botton.
                if ( _plbiTtsPauseResume )
                    _plbiTtsPauseResume->UpdateStatus( );
            }
        }
    }

    BOOL GetTtsButtonStatus(  )
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        return (dw & TF_TTS_BUTTON_ENABLE ?  TRUE : FALSE );
    }

    void SetTtsButtonStatus( BOOL  fEnable )
    {
        DWORD  dw;

        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        dw = (dw & ~TF_TTS_BUTTON_ENABLE) | (fEnable ? TF_TTS_BUTTON_ENABLE : 0);
        SetCompartmentDWORD(0, 
                            _tim, 
                            GUID_COMPARTMENT_TTS_STATUS, 
                            dw,
                            FALSE);
    }

    void SetIMX(CSapiIMX *pimx)
    {
        _pimx = pimx;
    }

    // TABLETPC
    HRESULT IsActiveThread()
    {
        if (m_fStageTip)
        {
            // To avoid a race condition with no immediately available solution, we are now active only when the stage is visible.
            if (m_fStageVisible)
            {
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }
        else if (m_fStageVisible)
        {
            // Stage is visible. We are always inactive since we are not the stage.
            return S_FALSE;
        }
        else
        {
            // Stage is not visible. We're active if we have focus as normal Cicero.
            BOOL fThreadFocus = FALSE;
            HRESULT hr = S_OK;
            hr = _tim->IsThreadFocus(&fThreadFocus);
            hr = (S_OK == hr) ? ( (fThreadFocus) ? S_OK : S_FALSE ) : hr;
            return hr;
        }
    }

    ITfThreadMgr *GetTIM() {return _tim;}
    CSapiIMX *GetIMX() {return _pimx;}

    HRESULT SetBalloonSAPIInitFlag(BOOL fSet);
   
private:
    ADDREMOVEITEMFUNCDEF(Microphone)
    ADDREMOVEITEMFUNCDEF(CfgMenuButton)
    ADDREMOVEITEMFUNCDEF(Balloon)
    ADDREMOVEITEMFUNCDEF(Commanding)
    ADDREMOVEITEMFUNCDEF(Dictation)
    ADDREMOVEITEMFUNCDEF(TtsPlayStop)
    ADDREMOVEITEMFUNCDEF(TtsPauseResume)
#ifdef CHANGE_MIC_TOOLTIP_ONTHEFLY
    HRESULT  _ToggleMicrophone(BOOL fOn);
#else
        TOGGLEITEMFUNCDEF(Microphone);
#endif
    TOGGLEITEMFUNCDEF(Commanding);
    TOGGLEITEMFUNCDEF(Dictation);
    TOGGLEITEMFUNCDEF(TtsPlayStop);
    TOGGLEITEMFUNCDEF(TtsPauseResume);

    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);

    ITfThreadMgr *_tim;
    ITfLangBarItemMgr *_lbim;
    CSapiIMX *_pimx;
    BOOL _fShown;
    BOOL m_fCommandingReady;
    // TABLET
    BOOL m_fStageTip;
    BOOL m_fStageVisible;
    DWORD  m_cRef;

    CLBarItemMicrophone    *_plbiMicrophone;
    CLBarItemCfgMenuButton *_plbiCfgMenuButton;
    CLBarItemBalloon       *_plbiBalloon;
    CLBarItemCommanding    *_plbiCommanding;
    CLBarItemDictation     *_plbiDictation;
    CLBarItemTtsPlayStop     *_plbiTtsPlayStop;
    CLBarItemTtsPauseResume  *_plbiTtsPauseResume;

    ATOM                   m_hAtom;

    CCompartmentEventSink *_pCes;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemMicrophone
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemMicrophone : public CLBarItemButtonBase
{
public:
    CLBarItemMicrophone(CSpeechUIServer *psus);
    ~CLBarItemMicrophone();

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCfgMenuButton
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemCfgMenuButton : public CLBarItemSystemButtonBase
{
public:
    CLBarItemCfgMenuButton(CSpeechUIServer *psus);
    ~CLBarItemCfgMenuButton();

    //
    // ITfNotifyUI
    //
    STDMETHODIMP GetIcon(HICON *phIcon);

    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT uID);

private:
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemBalloon : public CLBarItemBalloonBase
{
public:
    CLBarItemBalloon(CSpeechUIServer *psus);
    ~CLBarItemBalloon();

    STDMETHODIMP GetBalloonInfo(TF_LBBALLOONINFO *pInfo);
    void Set(TfLBBalloonStyle style, const WCHAR *psz);

    BOOL NeedUpdate(TfLBBalloonStyle style, const WCHAR *psz)
    {
        return  (!_bstrText || _style != style || wcscmp(_bstrText, psz) != 0);
    }
    void SetToFireInitializeSAPI(BOOL fSet)
    {
        m_fFireInitializeSapi = fSet;
    }

    TfLBBalloonStyle GetStyle(void)
    {
        return _style;
    }
    void SetStyle(TfLBBalloonStyle style)
    {
        _style = style;
    }

private:
    BSTR _bstrText;
    TfLBBalloonStyle _style;

    CSpeechUIServer *_psus;
    BOOL    m_fFireInitializeSapi;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemDictation
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemDictation : public CLBarItemButtonBase
{
public:
    CLBarItemDictation(CSpeechUIServer *psus);
    ~CLBarItemDictation();

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemCommanding
//
//////////////////////////////////////////////////////////////////////////////

class CLBarItemCommanding : public CLBarItemButtonBase
{
public:
    CLBarItemCommanding(CSpeechUIServer *psus);
    ~CLBarItemCommanding();

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    CSpeechUIServer *_psus;
};

ADDREMOVEITEMFUNC(Microphone)
ADDREMOVEITEMFUNC(CfgMenuButton)
ADDREMOVEITEMFUNC(Balloon)
ADDREMOVEITEMFUNC(Commanding)
ADDREMOVEITEMFUNC(Dictation)
ADDREMOVEITEMFUNC(TtsPlayStop)
ADDREMOVEITEMFUNC(TtsPauseResume)

#ifndef CHANGE_MIC_TOOLTIP_ONTHEFLY
TOGGLEITEMFUNC(Microphone);
#endif
TOGGLEITEMFUNC(Commanding);
TOGGLEITEMFUNC(Dictation);
TOGGLEITEMFUNC(TtsPlayStop);
TOGGLEITEMFUNC(TtsPauseResume);


#endif // NUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\miscfunc.h ===
#ifndef _MISCFUNC_H
#define _MISCFUNC_H
#include "sapilayr.h"

class CSapiIMX;

//////////////////////////////////////////////////////////////////////////////
//
// CGetSAPIObject
//
//////////////////////////////////////////////////////////////////////////////

class CGetSAPIObject : public ITfFnGetSAPIObject
{
public:
    CGetSAPIObject(CSapiIMX *psi);
    ~CGetSAPIObject();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFGUID riid, LPVOID *ppobj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    // ITfFnGetSAPIObject
    STDMETHODIMP Get(TfSapiObject sObj, IUnknown **ppunk); 

    // internal API IsSupported()
    HRESULT IsSupported(REFIID riid, TfSapiObject *psObj);

private:
    CSapiIMX           *m_psi;
    CComPtr<ITfContext> m_cpIC;
    LONG       m_cRef;

};

//////////////////////////////////////////////////////////////////////////////
//
// CFnBalloon
//
//////////////////////////////////////////////////////////////////////////////

class CFnBalloon : public ITfFnBalloon,
                      public CFunction
{
public:
    CFnBalloon(CSapiIMX *psi);
    ~CFnBalloon();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnBalloon
    //
    STDMETHODIMP UpdateBalloon(TfLBBalloonStyle style, const WCHAR *pch, ULONG cch);

private:
    long _cRef;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnAbort
//
//////////////////////////////////////////////////////////////////////////////

class CFnAbort : public ITfFnAbort,
                 public CFunction
{
public:
    CFnAbort(CSapiIMX *psi);
    ~CFnAbort();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFGUID riid, LPVOID *ppobj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    // ITfFnAbort
    STDMETHODIMP Abort(ITfContext *pic);

private:
    CSapiIMX   *m_psi;
    LONG       _cRef;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnConfigure
//
// synopsis: implements ITfFnConfigure
//
//////////////////////////////////////////////////////////////////////////////

class __declspec(novtable) CFnConfigure : public ITfFnConfigure
{
public:
    CFnConfigure(CSapiIMX *psi) {m_psi = psi;}
    ~CFnConfigure() {}

    // ITfFunction method
    STDMETHODIMP GetDisplayName(BSTR *pbstrName)
    {
        HRESULT hr = E_INVALIDARG;

        if (pbstrName)
        {
            *pbstrName = SysAllocString(L"Show configuration UI for SR");
            if (!*pbstrName)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
        return hr;
    }


    // ITfFnConfigure methods
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile);

    CSapiIMX *m_psi;

};

class CFnPropertyUIStatus : public ITfFnPropertyUIStatus
{
public:
    CFnPropertyUIStatus(CSapiIMX *psi) {m_psi = psi; m_cRef = 1;}
    ~CFnPropertyUIStatus() {}

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction method
    STDMETHODIMP GetDisplayName(BSTR *pbstrName)
    {
        HRESULT hr = E_INVALIDARG;

        if (pbstrName)
        {
            *pbstrName = SysAllocString(L"Get UI setting status of SPTIP");
            if (!*pbstrName)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
        return hr;
    }


    // ITfFnPropertyUIStatus methods
    STDMETHODIMP GetStatus(REFGUID refguidProp, DWORD *pdw);
    

    STDMETHODIMP SetStatus(REFGUID refguidProp, DWORD dw)
    {
        return E_NOTIMPL;
    }

    CSapiIMX *m_psi;
    LONG       m_cRef;
};

#endif // ndef _MISCFUNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\playback.cpp ===
//
// Audio playback function impl.
//
//
#include "private.h"
#include "sapilayr.h"
#include "playback.h"
#include "immxutil.h"
#include "propstor.h"
#include "hwxink.h"

//
// ctor/dtor
//

CSapiPlayBack::CSapiPlayBack(CSapiIMX *psi)
{
    m_psi = psi;
    m_pIC = NULL;
    m_cRef = 1;
}

CSapiPlayBack::~CSapiPlayBack()
{
    SafeRelease(m_pIC);
}

//
// IUnknown
//

STDMETHODIMP CSapiPlayBack::QueryInterface(REFGUID riid, LPVOID *ppvObj)
{
    Assert(ppvObj);
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnPlayBack))
    {
        *ppvObj = SAFECAST(this, CSapiPlayBack *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSapiPlayBack::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSapiPlayBack::Release(void)
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
// ITfFunction
//

STDMETHODIMP CSapiPlayBack::GetDisplayName(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrName)
    {
        *pbstrName = SysAllocString(L"PlayBack Voice");
        if (!*pbstrName)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSapiPlayBack::IsEnabled(BOOL *pfEnable)
{
    *pfEnable = TRUE;
    return S_OK;
}
//
// CSapiPlayBack::FindSoundRange
//
// synopsis - finds matching range with sound data for the given 
//            text range
//            callar is responsible for releasing the returned range object
//
HRESULT 
CSapiPlayBack::FindSoundRange(TfEditCookie ec, ITfRange *pRange, ITfProperty **ppProp, ITfRange **ppPropRange, ITfRange **ppSndRange)
{
    
    ITfProperty *pProp = NULL;
    ITfRange *pPropRange = NULL;

    Assert(pRange);
    *ppProp = NULL;

    HRESULT hr = m_pIC->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &pProp);
    
    if (SUCCEEDED(hr) && pProp)
    {
        ITfRange *pRangeSize0;

        pRange->Clone(&pRangeSize0);
        pRangeSize0->Collapse(ec, TF_ANCHOR_START); // findrange would fail if this failed
        hr = pProp->FindRange(ec, pRangeSize0, &pPropRange, TF_ANCHOR_START);

        pRangeSize0->Release();
        *ppProp = pProp;
        pProp->AddRef();
    }
    
    if (SUCCEEDED(hr) && pPropRange)
    {
        ITfRange *pRangeForSound;
        hr = pPropRange->Clone(&pRangeForSound);
        if (ppSndRange && SUCCEEDED(hr))
        {
            hr = pRangeForSound->Clone(ppSndRange);
            pRangeForSound->Release();
        }
        if (ppPropRange && pPropRange && SUCCEEDED(hr))
        {
            hr = pPropRange->Clone(ppPropRange);
        }

        SafeRelease(pPropRange);
    }
    else
    {
        if (ppPropRange)
            *ppPropRange = NULL;
            
        if (ppSndRange)
            *ppSndRange = NULL;
    }

    SafeRelease(pProp);
    
    return hr;
}

// ITfFnPlayBack
//
//
STDAPI CSapiPlayBack::QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfPlayable)
{
    //
    // always ok because of TTS.
    //
    if (ppNewRange)
    {
         pRange->Clone(ppNewRange);
    }
    *pfPlayable = TRUE;
    return S_OK;
}

// ITfFnPlayBack
//
// play the audio stream attached to the range 
// TODO: use TTS if:
//       1) the given range has less text
//       then the stream prop
//       2) the audio property is not found
//
STDAPI CSapiPlayBack::Play(ITfRange *pRange)
{
    HRESULT hr = E_OUTOFMEMORY;

    if ( !m_psi ) 
        return E_FAIL;

    SafeRelease(m_pIC);
    m_psi->GetFocusIC(&m_pIC);

    if (m_pIC)
    {
        CPlayBackEditSession  *pes;

        if (pes = new CPlayBackEditSession(this, m_pIC))
        {
            pes->_SetEditSessionData(ESCB_PLAYBK_PLAYSND, NULL, 0);
            pes->_SetRange(pRange);

            m_pIC->RequestEditSession(m_psi->_GetId(), pes, TF_ES_READ /*| TF_ES_SYNC */, &hr);
            pes->Release();
        }
    }

    return hr;
}

HRESULT CSapiPlayBack::_PlaySound(TfEditCookie ec, ITfRange *pRange)
{
    HRESULT     hr = S_OK; 
    LONG        l;
    ITfRange    *pRangeForSound = NULL;
    ITfRange    *pRangeCurrent = NULL;
    BOOL        fEmpty;
    ULONG       ulStart, ulcElem;
    
    // playback one phrase for no selection
    pRange->IsEmpty(ec, &fEmpty);
    if (fEmpty)
    {
        ITfProperty *pProp = NULL;
        hr = FindSoundRange(ec, pRange, &pProp, NULL, &pRangeForSound);
        if (SUCCEEDED(hr) && pRangeForSound)
        {
            pRange->ShiftStartToRange(ec, pRangeForSound, TF_ANCHOR_START);
            pRange->ShiftEndToRange(ec, pRangeForSound, TF_ANCHOR_END);
            pRangeForSound->Release();
        }
        SafeReleaseClear(pProp);
    }
    // setting up a range object on our own
    
    hr = pRange->Clone(&pRangeCurrent);

    while(SUCCEEDED(hr) && pRangeCurrent->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        ITfProperty *pProp = NULL;
        // get the first dictated range

        CDictRange   *pDictRange = new CDictRange( );

        if ( pDictRange )
        {
            hr = pDictRange->Initialize(ec, m_pIC, pRangeCurrent);

            if ( SUCCEEDED(hr) && pDictRange->IsDictRangeFound( ))
            {
                // Found a dictated range.
                pRangeForSound = pDictRange->GetDictRange( );
                ulStart = pDictRange->GetStartElem( );
                ulcElem = pDictRange->GetNumElem( );
                pProp = pDictRange->GetProp( );

                // if start anchor of pRangeForSound is larger than start anchor of pRangeCurrent,
                // we need to send the text between these two anchors to spVoice first.

                hr = pRangeCurrent->CompareStart(ec, pRangeForSound, TF_ANCHOR_START, &l);

                if ( SUCCEEDED(hr) && l < 0 )
                {
                    CComPtr<ITfRange>  cpRangeText;
                
                    hr = pRangeCurrent->Clone(&cpRangeText);

                    if ( SUCCEEDED(hr) )
                    {
                        hr = cpRangeText->ShiftEndToRange(ec, pRangeForSound, TF_ANCHOR_START);
                    }

                    if ( SUCCEEDED(hr) )
                        hr = PlayTextData(ec, cpRangeText);
                }

                // Then play the audio data.

                if (SUCCEEDED(hr) )
                {
                    hr = PlayAudioData(ec, pRangeForSound, pProp, ulStart, ulcElem);
                }

            }
            else
            {
                // There is no dictated phrase in this range.
                // just speak all the rest text at once.
                SafeRelease(pRangeForSound);
                hr = pRangeCurrent->Clone(&pRangeForSound);

                if ( SUCCEEDED(hr) )
                    hr = PlayTextData(ec, pRangeCurrent);
            }

            SafeReleaseClear(pProp);

            // next range
            pRangeCurrent->ShiftStartToRange(ec, pRangeForSound, TF_ANCHOR_END);
            pRangeForSound->Release();

            delete  pDictRange;
        }
        else
            hr = E_OUTOFMEMORY;

    }  // end of while

    SafeRelease(pRangeCurrent);

    return hr;
}

//
//  CSapiPlayBack::PlayTextData
//
//  Playing the text by default voice
//
//  This is for Non-Dictated text.  pRangeText contains all the Non-Dictated text

const GUID GUID_TS_SERVICE_DATAOBJECT={0x6086fbb5, 0xe225, 0x46ce, {0xa7, 0x70, 0xc1, 0xbb, 0xd3, 0xe0, 0x5d, 0x7b}};
const IID IID_ILineInfo = {0x9C1C5AD5,0xF22F,0x4DE4,{0xB4,0x53,0xA2,0xCC,0x48,0x2E,0x7C,0x33}};

HRESULT CSapiPlayBack::GetInkObjectText(TfEditCookie ec, ITfRange *pRange, BSTR *pbstrWord,UINT *pcchWord)
{
    HRESULT               hr = S_OK;
    CComPtr<IDataObject>  cpDataObject;
    CComPtr<ILineInfo>    cpLineInfo;

    if ( !pRange || !pbstrWord || !pcchWord )
        return E_FAIL;

    *pbstrWord = NULL;
    *pcchWord = 0;

    hr = pRange->GetEmbedded(ec, 
                             GUID_TS_SERVICE_DATAOBJECT, 
                             IID_IDataObject,
                             (IUnknown **)&cpDataObject);
    if ( hr == S_OK )
    {
        hr = cpDataObject->QueryInterface(IID_ILineInfo, (void **)&cpLineInfo);
    }

    if ( hr == S_OK  && cpLineInfo)
    {
        hr = cpLineInfo->TopCandidates(0, pbstrWord, pcchWord, 0, 0);
    }
    else
    {
        // it doesn't support ILineInfoi or IDataObject. 
        // But it is not an error, the code should not terminate here.
        hr = S_OK;
    }


    return hr;
}


HRESULT CSapiPlayBack::PlayTextData(TfEditCookie ec, ITfRange *pRangeText)
{
    HRESULT           hr = S_OK;
    CComPtr<ITfRange> cpRangeCloned;
    BOOL              fEmpty = TRUE;
    CSpDynamicString  dstrText;
    CSpTask          *psp;
    WCHAR             sz[128];
    ULONG             iIndex = 0;
    ULONG             ucch;

    if ( m_psi == NULL ) return E_FAIL;

    if ( !pRangeText ) return E_INVALIDARG;

    hr = pRangeText->Clone(&cpRangeCloned);

    // Get the text from the pRangeCloned
    while(S_OK == hr && (S_OK == cpRangeCloned->IsEmpty(ec, &fEmpty)) && !fEmpty)
    {
        WCHAR                 szEach[2];
        BOOL                  fHitInkObject = FALSE;
        BSTR                  bstr = NULL;

        fHitInkObject = FALSE;
        hr = cpRangeCloned->GetText(ec, TF_TF_MOVESTART, szEach, ARRAYSIZE(szEach)-1, &ucch);
        if (S_OK == hr && ucch > 0)
        {
            szEach[ucch] = L'\0';
            if ( szEach[0] == TF_CHAR_EMBEDDED )
            {
                // This is an embedded object.
                // Check to see if it is Ink Object. currently we support only Inkobject TTSed
                CComPtr<ITfRange>     cpRangeTmp;

                // Shift the start anchor back by 1 char.
                hr = cpRangeCloned->Clone(&cpRangeTmp);

                if ( hr == S_OK )
                {
                    LONG   cch;
                    hr = cpRangeTmp->ShiftStart(ec, -1, &cch, 0 );
                }

                if ( hr == S_OK )
                    hr = GetInkObjectText(ec, cpRangeTmp, &bstr,(UINT *)&ucch);

                if ( hr == S_OK  && ucch > 0  && bstr)
                    fHitInkObject = TRUE;
            }

            if ( fHitInkObject)
            {
                // Fill the previous text to dstrText.
                if ( iIndex > 0 )
                {
                    sz[iIndex] = L'\0';
                    dstrText.Append(sz);
                    iIndex = 0;
                }

                // Fill this Ink Object text
                dstrText.Append(bstr);
                SysFreeString(bstr);
            }
            else
            {
                if ( iIndex >= ARRAYSIZE(sz)-1 )
                {
                    sz[ARRAYSIZE(sz)-1] = L'\0';
                    dstrText.Append(sz);
                    iIndex=0;
                }

                sz[iIndex] = szEach[0];
                iIndex ++;
            }
        }
        else
        {
            // hr is not S_OK or ucch is zero.
            // we just want to exit here.
            TraceMsg(TF_GENERAL, "PlayTextData: ucch=%d", ucch);

            break;
        }
    }

    // Fill the last run of text.
    if ( iIndex > 0 )
    {
        sz[iIndex] = L'\0';
        dstrText.Append(sz);
        iIndex = 0;
    }

    // Play the text through TTS service.
    if ((hr == S_OK) && dstrText)
    {
        hr = m_psi->GetSpeechTask(&psp);
        if (hr == S_OK)
        {
            hr = psp->_SpeakText((WCHAR *)dstrText);
            psp->Release();
        }
    }

    return hr;
}

//
//  CSapiPlayBack::PlayAudioData
// 
//  Playing the sound by Aduio Data
// 
//  This is for Dictated text.  pRangeAudio keeps the dictated text range.

HRESULT CSapiPlayBack::PlayAudioData(TfEditCookie ec, ITfRange *pRangeAudio, ITfProperty *pProp, ULONG ulStart, ULONG ulcElem )
{
    HRESULT           hr = S_OK;
    CSpTask          *psp;
    VARIANT           var;

    if ( m_psi == NULL )  return E_FAIL;

    if ( !pRangeAudio  || !pProp ) return E_INVALIDARG;

    hr = pProp->GetValue(ec, pRangeAudio, &var);
            
    if (S_OK == hr)
    {
        Assert(var.vt == VT_UNKNOWN);
        IUnknown *punk = var.punkVal;
        if (punk)
        {
            // get the wrapper object
            CRecoResultWrap *pWrap;
                    
            hr = punk->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pWrap);
            if (S_OK == hr)
            {
               // hr = pWrap->_SpeakAudio(0,0); // better calculate the length accurately
                CComPtr<ISpRecoResult> cpResult;

                hr = pWrap->GetResult(&cpResult);

                if (S_OK == hr)
                {
                    CComPtr<ISpStreamFormat> cpStream;

                    if ((ulStart == 0) && (ulcElem == 0))
                    {
                        // We don't set the start element and number of elems.
                        // it must be for the whole recoWrap.
                        ulStart = pWrap->GetStart();
                        ulcElem = pWrap->GetNumElements();
                    }

                    hr = cpResult->GetAudio(ulStart, ulcElem, &cpStream);

                    if ( S_OK == hr )
                    {
                        hr = m_psi->GetSpeechTask(&psp);
                        if (SUCCEEDED(hr))
                        {
                            hr = psp->_SpeakAudio(cpStream);
                            psp->Release();
                        }
                    }
                }

                pWrap->Release();
            }
            punk->Release();
        }
    }

    return hr;
}

//
// CSapiPlayBack::GetDataID
//
// This method is incomplete for now, until we figure out
// the usage of dataid
//
HRESULT CSapiPlayBack::GetDataID(BSTR bstrCandXml, int nId, GUID *pguidData)
{
    // 1) parse the list and find RANGEDATA
    IXMLDOMNodeList *pNList   = NULL;
    IXMLDOMElement  *pElm = NULL;
    IXMLDOMNode *pNode;
    VARIANT_BOOL bSuccessful;

    HRESULT hr = EnsureIXMLDoc();

    if (SUCCEEDED(hr))
    {
        hr = m_pIXMLDoc->loadXML(bstrCandXml, &bSuccessful);
    }   
    
    // get <RANGEDATA> element
    if (SUCCEEDED(hr) && bSuccessful)
    {
        BSTR bstrRange    = SysAllocString(L"RANGEDATA");
        if (bstrRange)
        {
            hr = m_pIXMLDoc->getElementsByTagName(bstrRange, &pNList);
            SysFreeString(bstrRange);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    
    if (SUCCEEDED(hr) && pNList)
    {
        if (pNList->nextNode(&pNode) == S_OK)
            hr = pNode->QueryInterface(IID_IXMLDOMElement,(void **)&pElm);
            
        pNList->Release();
    }
    // then <MICROSOFTSPEECH> ...
    if (SUCCEEDED(hr) && pElm)
    {
        BSTR bstrSpchPriv = SysAllocString(L"MICROSOFTSPEECH");
        if (bstrSpchPriv)
        {
            hr = pElm->getElementsByTagName(bstrSpchPriv, &pNList);
            SysFreeString(bstrSpchPriv);
        }
        else
            hr = E_OUTOFMEMORY;
            
        pElm->Release();
    }
    
    if (SUCCEEDED(hr) && pNList)
    {
        if (pNList->nextNode(&pNode) == S_OK)
            hr = pNode->QueryInterface(IID_IXMLDOMElement,(void **)&pElm);
        
        pNList->Release();
    }
    
    // <DATAID>
    // right now assuming the speech element
    // is put at the level of <rangedata>
    // ignoring nId here
    if (SUCCEEDED(hr) && pElm)
    {
        BSTR bstrDataId = SysAllocString(L"DATAID");
        if (bstrDataId)
        {
            hr = pElm->getElementsByTagName(bstrDataId, &pNList);
            SysFreeString(bstrDataId);
        }
        else
            hr = E_OUTOFMEMORY;
            
        pElm->Release();
    }
    // impl later...
    // so, here we'll get the real dataid and be done
    
    if (SUCCEEDED(hr) && pNList)
    {
        pNList->Release();
    }
    
    return hr;
}

HRESULT CSapiPlayBack::_PlaySoundSelection(TfEditCookie ec, ITfContext *pic)
{
    ITfRange *pSelection;
    HRESULT hr = E_FAIL;

    if (GetSelectionSimple(ec, pic, &pSelection) == S_OK)
    {
        hr = _PlaySound(ec, pSelection);
        pSelection->Release();
    }
    return hr;

}

HRESULT CSapiPlayBack::EnsureIXMLDoc(void)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pIXMLDocument;
    if (!m_pIXMLDoc)
    {
        if (SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IXMLDOMDocument,
                           (void **) &pIXMLDocument)))
        {
            m_pIXMLDoc = pIXMLDocument;
        }
    }

    return hr;    
}

//
// Implementation for Class CDictRange
//
//

//
// ctor/dtor
//
CDictRange::CDictRange( )  : CBestPropRange( )
{
    m_fFoundDictRange = FALSE;
    m_pProp = NULL;
    m_pDictatRange = NULL;
    m_ulStart = 0;
    m_ulcElem = 0;
}


CDictRange::~CDictRange( )
{
    SafeRelease(m_pProp);
    SafeRelease(m_pDictatRange);
}


ITfProperty *CDictRange::GetProp( )      
{
    if ( m_pProp )
        m_pProp->AddRef( );

    return m_pProp; 
}

ITfRange  *CDictRange::GetDictRange( ) 
{ 
    if ( m_pDictatRange )
        m_pDictatRange->AddRef( );

    return m_pDictatRange; 
}
 

HRESULT  CDictRange::_GetOverlapRange(TfEditCookie ec, ITfRange *pRange1, ITfRange *pRange2, ITfRange **ppOverlapRange)
{
    HRESULT  hr = E_FAIL;
    LONG     l1=0;    
    LONG     l2=0;

    CComPtr<ITfRange>   cpRangeOverlap;

    if ( !pRange1 || !pRange2 || !ppOverlapRange  )
        return E_INVALIDARG;

    *ppOverlapRange = NULL;

    // Get the overlapping part of pRange and cpPropRange, and then calculate the 
    // best matched propRange.

    hr = pRange1->Clone( &cpRangeOverlap );
                
    if ( SUCCEEDED(hr) )
        hr = pRange1->CompareStart(ec, pRange2, TF_ANCHOR_START, &l1);

    if ( SUCCEEDED(hr) && l1 < 0 )
    {
        // Start anchor of pRange1 is before the start anchor of the
        // pRange2.
        hr = cpRangeOverlap->ShiftStartToRange(ec, pRange2, TF_ANCHOR_START);
    }

    if ( SUCCEEDED(hr) )
        hr = cpRangeOverlap->CompareEnd(ec, pRange2, TF_ANCHOR_END, &l2);

    if ( SUCCEEDED(hr) && l2 > 0)
    {
        // End anchor of cpRangeOverlap is after the end anchor of the pRange2.
        hr = cpRangeOverlap->ShiftEndToRange(ec, pRange2, TF_ANCHOR_END);
    }

    if ( SUCCEEDED(hr) )
        hr = cpRangeOverlap->Clone(ppOverlapRange);

    return hr;
}

//
// CDictRange::Initialize
//
// synopsis - Get the necessary input parameters, (ec, pic, and pRange), 
//            and then search the first dictated range inside the given range. 
//            if it finds the first dictated range, update the related 
//            data memebers.
//  
//            if it doesn't find any dictated range, mark as not found.
//
HRESULT CDictRange::Initialize(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    CComPtr<ITfRange>    cpPropRange = NULL;
    HRESULT              hr;

    m_fFoundDictRange = FALSE;
    m_pProp = NULL;
    m_pDictatRange = NULL;
    m_ulStart = 0;
    m_ulcElem = 0;

    if ( !pic || !pRange )  return E_INVALIDARG;

    hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &m_pProp);
    
    if ( SUCCEEDED(hr) && m_pProp)
    {
        CComPtr<ITfRange> cpRangeCurrent;
        LONG    cch;
        
        hr = pRange->Clone(&cpRangeCurrent);
        
        if ( SUCCEEDED(hr) )
        {
            hr = cpRangeCurrent->Collapse(ec, TF_ANCHOR_START); 
        }

        while ( SUCCEEDED(hr) && !m_fFoundDictRange )
        {
            cpPropRange.Release( );
            hr = m_pProp->FindRange(ec, cpRangeCurrent, &cpPropRange, TF_ANCHOR_START);

            if ( SUCCEEDED(hr) && cpPropRange )
            {
                // Found the first Dictated phrase.
                CComPtr<ITfRange>   cpRangeOverlap;

                // Get the overlapping part of pRange and cpPropRange, and then calculate the 
                // best matched propRange.

                hr = _GetOverlapRange(ec, pRange, cpPropRange, &cpRangeOverlap);

                if ( SUCCEEDED(hr) )
                {
                    // Calculate the best matched propRange and ulStart, ulcElem.
                    cpPropRange.Release( );
                    hr = _ComputeBestFitPropRange(ec, m_pProp, cpRangeOverlap, &cpPropRange, &m_ulStart, &m_ulcElem);
                }

                if (SUCCEEDED(hr) && (m_ulcElem > 0))
                {
                    m_fFoundDictRange = TRUE;
                }
            }

            if ( SUCCEEDED(hr) && !m_fFoundDictRange)
            {
                // cpRangeCurrent shift forward one character. and try again.

                hr = cpRangeCurrent->ShiftStart(ec, 1, &cch, NULL);

                if ( SUCCEEDED(hr) && (cch==0))
                {
                    // Hit a region or the end of doc.
                    // check to see if there is more region.
                    BOOL    fNoRegion = TRUE;
                    
                    hr = cpRangeCurrent->ShiftStartRegion(ec, TF_SD_FORWARD, &fNoRegion);

                    if ( fNoRegion )
                    {
                        TraceMsg(TF_GENERAL, "Reach to end of doc");
                        break;
                    }
                    else
                        TraceMsg(TF_GENERAL, "Shift over to another region!");
                }
                
                if ( SUCCEEDED(hr) )
                {
                    // check to see if cpRangeCurrent is beyond of the pRange.
                    hr = pRange->CompareEnd(ec, cpRangeCurrent, TF_ANCHOR_END, &cch);

                    if ( SUCCEEDED(hr) && cch <= 0 )
                    {
                        // cpRangeCurrent Now is beyond of specified range, exit while statement.
                        TraceMsg(TF_GENERAL, "reach to the end of original range");

                        break;
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr) && cpPropRange && m_fFoundDictRange)
    {
        hr = cpPropRange->Clone(&m_pDictatRange);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\playback.h ===
//
// Audio playback function obj class definition
//
//

#ifndef _PLAYBACK_H
#define _PLAYBACK_H 

#include "fnrecon.h"

class CSapiIMX;
class CBestPropRange;

class CDictRange : public CBestPropRange
{
public:
    CDictRange( );
    ~CDictRange( );

    HRESULT Initialize(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);

    BOOL    IsDictRangeFound( )  { return m_fFoundDictRange; }
    BOOL    GetStartElem( )      { return m_ulStart; }
    BOOL    GetNumElem( )        { return m_ulcElem; }

    ITfProperty *GetProp( );      
    ITfRange    *GetDictRange( ); 
    
private:

    HRESULT  _GetOverlapRange(TfEditCookie ec, ITfRange *pRange1, ITfRange *pRange2, ITfRange **ppOverlapRange);

    BOOL                  m_fFoundDictRange;
    ITfProperty          *m_pProp;
    ITfRange             *m_pDictatRange;
    ULONG                 m_ulStart;
    ULONG                 m_ulcElem;
};

class CSapiPlayBack : public ITfFnPlayBack
{
public:
    CSapiPlayBack(CSapiIMX *psi);
    ~CSapiPlayBack();
    
    // iunknown
    //
    STDMETHODIMP QueryInterface(REFGUID riid, LPVOID *ppobj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    // ITfFnPlayBack
    //
    
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfPlayable);
    STDMETHODIMP Play(ITfRange *pRange);

    HRESULT _PlaySound(TfEditCookie ec, ITfRange *pRange);
    HRESULT _PlaySoundSelection(TfEditCookie ec, ITfContext *pic);
    
private:
    HRESULT EnsureIXMLDoc(void);
    HRESULT GetDataID(BSTR bstrCAndXml, int nId, GUID *pguidData);
    HRESULT FindSoundRange(TfEditCookie ec, ITfRange *pRange, ITfProperty **ppProp, ITfRange **ppPropRange, ITfRange **ppSndRange);

    HRESULT PlayTextData(TfEditCookie ec, ITfRange *pRangeText);
    HRESULT PlayAudioData(TfEditCookie ec, ITfRange *pRangeAudio, ITfProperty *pProp, ULONG ulStart, ULONG ulcElem);
    HRESULT GetInkObjectText(TfEditCookie ec, ITfRange *pRange, BSTR *pbstrWord,UINT *pcchWord);

    IXMLDOMDocument *m_pIXMLDoc;
    CSapiIMX    *m_psi;
    ITfContext *m_pIC;
    LONG       m_cRef;
};

#endif // ndef _PLAYBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for sapilayr project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <windows.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h> 

//#include <windowsx.h>
#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include <servprov.h>
#include "combase.h"
#include "msctfp.h"
#include "ctffunc.h"
#include "ctfspui.h"
#include "helpers.h"
#include <tchar.h>
#ifdef __cplusplus
#include <sapi.h>
#include <atlbase.h>
#include <sphelper.h>
#endif // __cplusplus
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\proppage.cpp ===
// PropPage.cpp : Implementation of CSpPropertyPage
#include "private.h"

#include "globals.h"
#include "PropPage.h"
#include "commctrl.h"
#include "cregkey.h"
#include "cresstr.h"
#include "cicspres.h"

extern HRESULT _SetGlobalCompDWORD(REFGUID rguid, DWORD   dw);
extern HRESULT _GetGlobalCompDWORD(REFGUID rguid, DWORD  *pdw);

// only used for dialogs, not the class factory!
CComModule _Module;

//
//  Context Help Ids.
//

static int aSptipPropIds[] =
{
    IDC_PP_ASSIGN_BUTTON,       IDH_PP_ASSIGN_BUTTON,
    IDC_PP_BUTTON_MB_SETTING,   IDH_PP_BUTTON_MB_SETTING,
    IDC_PP_SHOW_BALLOON,        IDH_PP_SHOW_BALLOON,
    IDC_PP_LMA,                 IDH_PP_LMA,
    IDC_PP_HIGH_CONFIDENCE,     IDH_PP_HIGH_CONFIDENCE,
    IDC_PP_SAVE_SPDATA,         IDH_PP_SAVE_SPDATA,
    IDC_PP_REMOVE_SPACE,        IDH_PP_REMOVE_SPACE,
    IDC_PP_DIS_DICT_TYPING,     IDH_PP_DIS_DICT_TYPING,
    IDC_PP_PLAYBACK,            IDH_PP_PLAYBACK,
    IDC_PP_DICT_CANDUI_OPEN,    IDH_PP_DICT_CANDUI_OPEN,
    IDC_PP_BUTTON_ADVANCE,      IDH_PP_BUTTON_ADVANCE,
    IDC_PP_BUTTON_SPCPL,        IDH_PP_BUTTON_SPCPL,
    IDC_PP_BUTTON_LANGBAR,      IDH_PP_BUTTON_LANGBAR,
    IDC_PP_DICTCMDS,            IDH_PP_DICTCMDS,
    0, 0
};


static int aSptipVoiceDlgIds[] =
{
    IDC_PP_SELECTION_CMD,       IDH_PP_SELECTION_CMD,
    IDC_PP_NAVIGATION_CMD,      IDH_PP_NAVIGATION_CMD,
    IDC_PP_CASING_CMD,          IDH_PP_CASING_CMD,
    IDC_PP_EDITING_CMD,         IDH_PP_EDITING_CMD,
    IDC_PP_KEYBOARD_CMD,        IDH_PP_KEYBOARD_CMD,
    IDC_PP_TTS_CMD,             IDH_PP_TTS_CMD,
    IDC_PP_LANGBAR_CMD,         IDH_PP_LANGBAR_CMD,
    0, 0
};

static int aSptipButtonDlgIds[] =
{
    IDC_PP_DICTATION_CMB,       IDH_PP_DICTATION_CMB,
    IDC_PP_COMMAND_CMB,         IDH_PP_COMMAND_CMB,
    0, 0
};


#ifdef USE_IPROPERTYPAGE

/////////////////////////////////////////////////////////////////////////////
// CSpPropertyPage

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::CSpPropertyPage
//
//  Description:    Constructor: initializes member variables
//
//////////////////////////////////////////////////////////////////////////////

CSpPropertyPage::CSpPropertyPage() : m_hWndParent(NULL)
{
	m_dwTitleID = IDS_PROPERTYPAGE_TITLE;
	m_dwHelpFileID = IDS_HELPFILESpPropPage;
	m_dwDocStringID = IDS_DOCSTRINGSpPropPage;

    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
    m_SpAdvanceSet = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::~CSpPropertyPage
//
//  Description:    Destructor: clean up the array of CSpListenerItems
//
//////////////////////////////////////////////////////////////////////////////

CSpPropertyPage::~CSpPropertyPage()
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);

    if ( m_SpAdvanceSet )
        delete m_SpAdvanceSet;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::Activate
//
//  Description:    Initializes the property page:
//                      - calls Activate on the base class
//                      - initializes the common controls
//                      - initializes the property page dialog
//
//  Parameters:     hWndParent - handle to parent (host) window
//                  prc - RECT of the parent
//                  bModal - modality of the window
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSpPropertyPage::Activate(
    HWND hWndParent,
    LPCRECT prc,
    BOOL bModal)
{

    InitCommonControls();

    Assert(hWndParent != NULL);

    m_hWndParent = hWndParent;

    HRESULT hr = PPBaseClass::Activate(hWndParent, prc, bModal);

    hr = InitPropertyPage();

    if (SUCCEEDED(hr))
    {
        SetDirty(FALSE);
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::Apply
//
//  Description:    Calls CommitChanges and if SUCCEEDED sets the dirty bit
//
//  Parameters:     none
//
//  Return Values:  S_OK, E_FAIL
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSpPropertyPage::Apply(void)
{

    HRESULT hr = S_OK; 

    if ( IsPageDirty( ) != S_OK ) return hr;

    // change the registry settings here. !!!
    Assert(m_SpPropItemsServer);
    m_SpPropItemsServer->_SavePropData( );

    // Notify all the Cicero Applications of these registry settings change.

    if ( SUCCEEDED(hr) )
    {
        hr = _SetGlobalCompDWORD(GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE, 1);
    }

    if (SUCCEEDED(hr))
    {
        SetDirty(FALSE);
    }
    
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::InitPropertyPage
//
//  Description:    Initializes the property page:
//                      - initializes the listview
//                      - loads the listener info into the listview
//
//  Parameters:     none
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

HRESULT CSpPropertyPage::InitPropertyPage()
{
    HRESULT  hr = S_OK;

    // Add some initialization code here.
    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer;

    if ( !m_SpPropItemsServer )
        return E_FAIL;

    if ( !m_IdCtrlPropMap )
    {
        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,            fEdit

            {IDC_PP_SELECTION_CMD,      PropId_Cmd_Select_Correct,  FALSE},
            {IDC_PP_NAVIGATION_CMD,     PropId_Cmd_Navigation,      FALSE},
            {IDC_PP_CASING_CMD,         PropId_Cmd_Casing,          FALSE},
            {IDC_PP_EDITING_CMD,        PropId_Cmd_Editing,         FALSE},
            {IDC_PP_KEYBOARD_CMD,       PropId_Cmd_Keyboard,        FALSE},
            {IDC_PP_LANGBAR_CMD,        PropId_Cmd_Language_Bar,    FALSE},
            {IDC_PP_TTS_CMD,            PropId_Cmd_TTS,             FALSE},
            {IDC_PP_DISABLE_DICTCMD,    PropId_Cmd_DisDict,         FALSE},
            {IDC_PP_ASSIGN_BUTTON,      PropId_Mode_Button,         FALSE},   
            { 0,                        PropId_Max_Item_Id,         FALSE }

        };

        DWORD   dwPropItems = 0;

        while (IdCtrlPropMap[dwPropItems].idCtrl != 0 )
              dwPropItems ++;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i].fEdit = IdCtrlPropMap[i].fEdit;
            m_IdCtrlPropMap[i].idCtrl= IdCtrlPropMap[i].idCtrl;
            m_IdCtrlPropMap[i].idPropItem = IdCtrlPropMap[i].idPropItem;
        }

        m_dwNumCtrls = dwPropItems;
    }


    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        BOOL          fEditControl;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        fEditControl = m_IdCtrlPropMap[i].fEdit;

        // BugBug:  There is no edit control in current property page.
        // all the edit controls are moved to advanced setting dialog.
        // temporally keep the code here, but after we finish the code for the 
        // advcanced setting dialog, please optimize code here.
        //
        if ( fEditControl )
        {
            SetDlgItemInt(idCtrl, (UINT)m_SpPropItemsServer->_GetPropData(idPropItem));
        }
        else
        {
            BOOL    fEnable;
            LPARAM  bst_Status;

            fEnable = (BOOL)m_SpPropItemsServer->_GetPropData(idPropItem);

            bst_Status = fEnable ? BST_CHECKED : BST_UNCHECKED;

            SendDlgItemMessage(idCtrl, BM_SETCHECK, bst_Status);
        }
    }

    // Specially handle the Mode button settings.

    if (! m_SpPropItemsServer->_GetPropData(PropId_Mode_Button) )
    {
        ::EnableWindow(GetDlgItem(IDC_PP_BUTTON_MB_SETTING), FALSE);
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::OnCheckButtonSetting
//
//  Description:    Handle all the change in the checked buttons related to   
//                  speech tip setting. the status is Enable/Disable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSpPropertyPage::OnCheckButtonSetting(WORD wNotifyCode,WORD wID,HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    BOOL            fChecked = FALSE;
    BOOL            fEnable = FALSE;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    // Find the prop item ID associated with this checked box button.
    for ( DWORD i=0; i<m_dwNumCtrls; i++)
    {
        if ( m_IdCtrlPropMap[i].idCtrl == wID )
        {
            idPropItem = m_IdCtrlPropMap[i].idPropItem;
            break;
        }
    }

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( wNotifyCode != BN_CLICKED )
        return hr;

    if ( ::SendMessage(hWndCtl, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
        fChecked = TRUE;

    fEnable = fChecked;

    m_SpPropItemsServer->_SetPropData(idPropItem, fEnable);

    // Specially hanlde Mode Buttons.

    if ( wID == IDC_PP_ASSIGN_BUTTON )
    {
        ::EnableWindow(GetDlgItem(IDC_PP_BUTTON_MB_SETTING), fEnable);
    }

    SetDirty(TRUE);

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//
//  CSpPropertyPage::OnPushButtonClicked
//
//  Description:    When the pushbutton is pressed in this page, this function   
//                  will be called to open corresponding dialog.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSpPropertyPage::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{

    HRESULT hr = S_OK;

    switch (wID)
    {
    case IDC_PP_BUTTON_ADVANCE :

        if (m_SpAdvanceSet)
        {
            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        m_SpAdvanceSet = (CSpAdvanceSetting *) new CSpAdvanceSetting( );

        if ( m_SpAdvanceSet )
        {
            int nRetCode;

            nRetCode = m_SpAdvanceSet->DoModal(m_hWndParent, (LPARAM)m_SpPropItemsServer);

            if ( nRetCode == IDOK )
                SetDirty(TRUE);

            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        break;

    case IDC_PP_BUTTON_LANGBAR :
        {
            TCHAR szCmdLine[MAX_PATH];
            TCHAR szInputPath[MAX_PATH];
            int cch = GetSystemDirectory(szInputPath, ARRAYSIZE(szInputPath));

            if (cch > 0)
            {
                // GetSystemDirectory appends no '\' unless the system
                // directory is the root, such like "c:\"
                if (cch != 3)
                    StringCchCat(szInputPath, ARRAYSIZE(szInputPath),TEXT("\\"));

                StringCchCat(szInputPath, ARRAYSIZE(szInputPath), TEXT("input.dll"));

                StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("rundll32 shell32.dll,Control_RunDLL \"%s\""),szInputPath);

                // start Language Bar control panel applet
                RunCPLSetting(szCmdLine);
            }

            break;
        }

    case IDC_PP_BUTTON_MB_SETTING :
        break;

    default :

        Assert(0);
        break;
    }
    
    return hr;
}

#endif // USE_IPROPERTYPAGE

//
//
// CSpAdvanceSetting
//

CSpAdvanceSetting::CSpAdvanceSetting()
{
//	m_dwTitleID = IDS_PROPERTYPAGE_TITLE;
//	m_dwHelpFileID = IDS_HELPFILESpPropPage;
//	m_dwDocStringID = IDS_DOCSTRINGSpPropPage;

    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
}


CSpAdvanceSetting::~CSpAdvanceSetting( )
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);
}

LRESULT CSpAdvanceSetting::OnInitAdvanceDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{

    Assert(lParam);
    m_SpPropBaseServer = (CSpPropItemsServer *)lParam;

    // Add some initialization code here.
    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer(m_SpPropBaseServer, PropId_MinId_InVoiceCmd, PropId_MaxId_InVoiceCmd);

    if ( !m_SpPropItemsServer )
        return FALSE;

    if ( !m_IdCtrlPropMap )
    {
        // Please make sure the array items are sorted by control id, and make sure the control id are sequent number,
        // so that we can use it to map to an index in the array easily.
        //

        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,            fEdit

            {IDC_PP_SELECTION_CMD,      PropId_Cmd_Select_Correct,  FALSE},
            {IDC_PP_NAVIGATION_CMD,     PropId_Cmd_Navigation,      FALSE},
            {IDC_PP_CASING_CMD,         PropId_Cmd_Casing,          FALSE},
            {IDC_PP_EDITING_CMD,        PropId_Cmd_Editing,         FALSE},
            {IDC_PP_KEYBOARD_CMD,       PropId_Cmd_Keyboard,        FALSE},
            {IDC_PP_LANGBAR_CMD,        PropId_Cmd_Language_Bar,    FALSE},
//            {IDC_PP_TTS_CMD,            PropId_Cmd_TTS,             FALSE},

//            {IDC_PP_MAXNUM_ALTERNATES,  PropId_Max_Alternates,      TRUE},
//            {IDC_PP_MAXCHARS_ALTERNATE, PropId_MaxChar_Cand,        TRUE},
            { 0,                        PropId_Max_Item_Id,         FALSE }

        };

        DWORD   dwPropItems = ARRAYSIZE(IdCtrlPropMap) - 1;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i] = IdCtrlPropMap[i];
        }

        m_dwNumCtrls = dwPropItems;
    }


    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        BOOL          fEditControl;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        fEditControl = m_IdCtrlPropMap[i].fEdit;

        if ( fEditControl )
        {
            SetDlgItemInt(idCtrl, (UINT)m_SpPropItemsServer->_GetPropData(idPropItem));
        }
        else
        {
            BOOL    fEnable;
            LPARAM  bst_Status;

            fEnable = (BOOL)m_SpPropItemsServer->_GetPropData(idPropItem);

            bst_Status = fEnable ? BST_CHECKED : BST_UNCHECKED;

            SendDlgItemMessage(idCtrl, BM_SETCHECK, bst_Status);
        }
    }

    return TRUE;  
}

LRESULT CSpAdvanceSetting::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case  WM_HELP  :

        ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 c_szHelpFile,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aSptipVoiceDlgIds );
        break;

    case  WM_CONTEXTMENU  :      // right mouse click

        ::WinHelp(  (HWND)wParam,
                 c_szHelpFile,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aSptipVoiceDlgIds );
        break;

    default :
        break;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSpAdvanceSetting::OnCheckButtonSetting
//
//  Description:    Handle all the change in the checked buttons in the Advanced
//                  setting dialog. the status is Enable/Disable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

LRESULT CSpAdvanceSetting::OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    BOOL            fChecked = FALSE;
    BOOL            fEnable = FALSE;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    // Find the prop item ID associated with this checked box button.
    Assert( wID >= IDC_PP_SELECTION_CMD );
    idPropItem = m_IdCtrlPropMap[wID - IDC_PP_SELECTION_CMD].idPropItem;

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( wNotifyCode != BN_CLICKED )
        return hr;

    if ( ::SendMessage(hWndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED )
        fChecked = TRUE;

    fEnable = fChecked;

    m_SpPropItemsServer->_SetPropData(idPropItem, fEnable);

    return hr;
}

/*

//////////////////////////////////////////////////////////////////////////////
//
//  CSpAdvanceSetting::OnEditControlSetting
//
//  Description:    Handle all the change in the edit controls related to   
//                  speech tip setting. the value is editable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

LRESULT CSpAdvanceSetting::OnEditControlSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    ULONG           ulValue = 0;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    Assert( wID >= IDC_PP_SHOW_BALLOON );
    idPropItem = m_IdCtrlPropMap[wID - IDC_PP_SHOW_BALLOON].idPropItem;

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( wNotifyCode != EN_CHANGE )
        return hr;

    ulValue = (ULONG) GetDlgItemInt(wID);

    m_SpPropItemsServer->_SetPropData(idPropItem, ulValue);

    // Enable OK button due to EditBox value change.
    ::EnableWindow(GetDlgItem(IDOK), TRUE);

    return hr;
}

*/

//////////////////////////////////////////////////////////////////////////////
//
//  CSpAdvanceSetting::IsItemStatusChanged
//
//  Description:    Check to see if some items' status have been changed
//                  since the dialog open.
//
//  Return Values:  S_OK
//
////////////////////////////////////////////////////////////////////////////// 
BOOL    CSpAdvanceSetting::IsItemStatusChanged( )
{
    BOOL   fChanged = FALSE;

    // Comparing the current item status with the base server's item status 
    // to determine if there is any item changed

    if ( m_SpPropItemsServer  && m_SpPropBaseServer)
    {
        DWORD   idPropItem;
        DWORD   dwOrgData, dwCurData;

        for (idPropItem = (DWORD)PropId_MinId_InVoiceCmd; idPropItem <= (DWORD)PropId_MaxId_InVoiceCmd; idPropItem++ )
        {
            dwCurData = m_SpPropItemsServer->_GetPropData((PROP_ITEM_ID)idPropItem);
            dwOrgData = m_SpPropBaseServer->_GetPropData((PROP_ITEM_ID)idPropItem);

            if ( dwCurData != dwOrgData )
            {
                fChanged = TRUE;
                break;
            }
        }
    }

    return fChanged;
}

LRESULT CSpAdvanceSetting::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT  hr=S_OK;
    int      nRetCode;

    Assert(m_SpPropItemsServer);
    Assert(m_SpPropBaseServer);
    Assert(m_IdCtrlPropMap);

    if ( wID != IDOK && wID != IDCANCEL )
        return E_FAIL;

    nRetCode = FALSE;   // Means no item changed

    if ( wID == IDOK && IsItemStatusChanged( ))
    {
        //Merge back all the change to the base property server.
        m_SpPropBaseServer->_MergeDataFromServer(m_SpPropItemsServer, PropId_MinId_InVoiceCmd, PropId_MaxId_InVoiceCmd);
        nRetCode = TRUE;
    }

    EndDialog(nRetCode);
    return hr;
}


//
//
// CSpModeButtonSetting
//

KEYNAME_VK_MAP  pName_VK_Table[] = {
        { TEXT("F1"),       VK_F1      },
        { TEXT("F2"),       VK_F2      },
        { TEXT("F3"),       VK_F3      },
        { TEXT("F4"),       VK_F4      },
        { TEXT("F5"),       VK_F5      },
        { TEXT("F6"),       VK_F6      },
        { TEXT("F7"),       VK_F7      },
        { TEXT("F8"),       VK_F8      },
        { TEXT("F9"),       VK_F9      },
        { TEXT("F10"),      VK_F10     },
        { TEXT("F11"),      VK_F11     },
        { TEXT("F12"),      VK_F12     },
        { TEXT("Space"),    VK_SPACE   },
        { TEXT("Esc"),      VK_ESCAPE  },
        { TEXT("PgUp"),     VK_PRIOR   },
        { TEXT("PgDn"),     VK_NEXT    },
        { TEXT("Home"),     VK_HOME    },
        { TEXT("End"),      VK_END     },
        { TEXT("Left"),     VK_LEFT    },
        { TEXT("Right"),    VK_RIGHT   },
        { TEXT("Up"),       VK_UP      },
        { TEXT("Down"),     VK_DOWN    },
        { TEXT("Insert"),   VK_INSERT  },
        { TEXT("Delete"),   VK_DELETE  },
        { TEXT("+"),        VK_ADD     },
        { TEXT("-"),        VK_SUBTRACT },
        { TEXT("/"),        VK_DIVIDE   },
        { TEXT("*"),        VK_MULTIPLY },
        { TEXT("Enter"),    VK_RETURN   },
        { TEXT("Tab"),      VK_TAB      },
        { TEXT("Pause"),    VK_PAUSE    },
        { TEXT("ScrollLock"), VK_SCROLL },
        { TEXT("NumLock"),    VK_NUMLOCK  },
};

CSpModeButtonSetting::CSpModeButtonSetting()
{
//	m_dwTitleID = IDS_PROPERTYPAGE_TITLE;
//	m_dwHelpFileID = IDS_HELPFILESpPropPage;
//	m_dwDocStringID = IDS_DOCSTRINGSpPropPage;

    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
}


CSpModeButtonSetting::~CSpModeButtonSetting( )
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);
}

LRESULT CSpModeButtonSetting::OnInitModeButtonDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{

    Assert(lParam);
    m_SpPropBaseServer = (CSpPropItemsServer *)lParam;

    // Add some initialization code here.
    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer(m_SpPropBaseServer, PropId_MinId_InModeButton, PropId_MaxId_InModeButton);

    if ( !m_SpPropItemsServer )
        return FALSE;

    if ( !m_IdCtrlPropMap )
    {
        // Please make sure the array items are sorted by control id, and make sure the control id are sequent number,
        // so that we can use it to map to an index in the array easily.
        //
        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,        fEdit
            {IDC_PP_DICTATION_CMB,      PropId_Dictation_Key,    FALSE },
            {IDC_PP_COMMAND_CMB,        PropId_Command_Key,      FALSE },
            { 0,                        PropId_Max_Item_Id,      FALSE }
        };

        DWORD   dwPropItems = ARRAYSIZE(IdCtrlPropMap) - 1;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i] = IdCtrlPropMap[i];
        }

        m_dwNumCtrls = dwPropItems;
    }

    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        DWORD         dwPropData;
        HWND          hCombBox;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        dwPropData = m_SpPropItemsServer->_GetPropData(idPropItem);

        hCombBox = GetDlgItem(idCtrl);

        if ( hCombBox )
        {
            int iIndex, iIndexDef = CB_ERR;  // CB_ERR is -1

            // Initialize the list box items
            for ( int j = 0; j < ARRAYSIZE(pName_VK_Table); j++ )
            {
                iIndex = (int)::SendMessage(hCombBox, CB_ADDSTRING, 0, (LPARAM)pName_VK_Table[j].pKeyName);
                ::SendMessage(hCombBox, CB_SETITEMDATA, iIndex, (LPARAM)(void*)&pName_VK_Table[j]);

                if ( pName_VK_Table[j].wVKey == dwPropData )
                    iIndexDef = j;
            }

            // Set the current selection based on property item data.
            if ( iIndexDef != CB_ERR )
                ::SendMessage(hCombBox, CB_SETCURSEL, iIndexDef, 0 );
        }
    }

    return TRUE;  
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSpModeButtonSetting::OnCombBoxSetting
//
//  Description:    Handle all the change in the CombBox controls related to   
//                  mode button setting. 
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

LRESULT CSpModeButtonSetting::OnCombBoxSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    KEYNAME_VK_MAP  *pCurKeyData;
    int             iIndex;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    if ( wNotifyCode != CBN_SELCHANGE )
        return hr;

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    Assert(wID >= IDC_PP_DICTATION_CMB);
    idPropItem = m_IdCtrlPropMap[wID - IDC_PP_DICTATION_CMB].idPropItem;

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    iIndex = (int)::SendMessage(hWndCtl, CB_GETCURSEL, 0, 0);
    pCurKeyData = (KEYNAME_VK_MAP *)::SendMessage(hWndCtl, CB_GETITEMDATA, iIndex, 0);

    if ( pCurKeyData )
    {
        m_SpPropItemsServer->_SetPropData(idPropItem, pCurKeyData->wVKey);
    }

    return hr;
}

LRESULT CSpModeButtonSetting::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled )
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case  WM_HELP  :
	
        ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 c_szHelpFile,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aSptipButtonDlgIds );
        break;

    case WM_CONTEXTMENU  :      // right mouse click

        ::WinHelp((HWND)wParam,
                 c_szHelpFile,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aSptipButtonDlgIds );
        break;

    default:
        break;
    }


    return hr;
}


LRESULT CSpModeButtonSetting::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled)
{
    HRESULT  hr=S_OK;
    int      nRetCode;

    Assert(m_SpPropItemsServer);
    Assert(m_SpPropBaseServer);
    Assert(m_IdCtrlPropMap);

    if ( wID != IDOK && wID != IDCANCEL )
        return E_FAIL;

    nRetCode = wID;

    if ( wID == IDOK )
    {
        //Merge back all the change to the base property server.
        m_SpPropBaseServer->_MergeDataFromServer(m_SpPropItemsServer, PropId_MinId_InModeButton, PropId_MaxId_InModeButton);
    }

    EndDialog(nRetCode);
    return hr;
}

//
//
//  Class CSptipPropertyPage
//
//

CSptipPropertyPage::CSptipPropertyPage ( WORD wDlgId, BOOL fLaunchFromInputCpl )
{
    m_wDlgId = wDlgId;
    m_SpPropItemsServer = NULL;
    m_dwNumCtrls = 0;
    m_IdCtrlPropMap = NULL;
    m_SpAdvanceSet = NULL;
    m_SpModeBtnSet = NULL;
    m_hDlg = NULL;
    m_fLaunchFromInputCpl = fLaunchFromInputCpl;
}

CSptipPropertyPage::~CSptipPropertyPage ( )
{
    if ( m_SpPropItemsServer )
        delete m_SpPropItemsServer;

    if ( m_IdCtrlPropMap )
        cicMemFree(m_IdCtrlPropMap);

    if ( m_SpAdvanceSet )
        delete m_SpAdvanceSet;

    if ( m_SpModeBtnSet )
        delete m_SpModeBtnSet;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::SetDirty
//
//  Description:    When there is any setting changed in the property page   
//                  by user, this function is called to notify the property 
//                  sheet of the status change. Property sheet will activate
//                  Apply button.
//
//  Return Values:  NONE
//
//////////////////////////////////////////////////////////////////////////////
void  CSptipPropertyPage::SetDirty(BOOL fDirty)
{
    HWND hwndParent = ::GetParent( m_hDlg );
    m_fIsDirty = fDirty;
    ::SendMessage( hwndParent, m_fIsDirty ? PSM_CHANGED : PSM_UNCHANGED, (WPARAM)(m_hDlg), 0 );
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnCheckButtonSetting
//
//  Description:    Handle all the change in the checked buttons related to   
//                  speech tip setting. the status is Enable/Disable.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSptipPropertyPage::OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
    HRESULT         hr = S_OK;
    BOOL            fChecked = FALSE;
    BOOL            fEnable = FALSE;
    PROP_ITEM_ID    idPropItem = PropId_Max_Item_Id;  // means not initialized

    Assert(m_SpPropItemsServer);
    Assert(m_IdCtrlPropMap);

    if ( wNotifyCode != BN_CLICKED )
        return hr;

    // Find the prop item ID associated with this checked box button.
    for ( DWORD i=0; i<m_dwNumCtrls; i++)
    {
        if ( m_IdCtrlPropMap[i].idCtrl == wID )
        {
            idPropItem = m_IdCtrlPropMap[i].idPropItem;
            break;
        }
    }

    if ( idPropItem >= PropId_Max_Item_Id )
    {
        // we don't find the control ID from our list, this is not possible, some thing wrong already.
        // exit here.
        return E_FAIL;
    }

    if ( ::SendMessage(hWndCtl, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
        fChecked = TRUE;

    // Specially handle "Show Balloon" item.

    if ( wID == IDC_PP_SHOW_BALLOON )
        fEnable = !fChecked;
    else
        fEnable = fChecked;

    m_SpPropItemsServer->_SetPropData(idPropItem, fEnable);

    // Specially hanlde Mode Buttons.

    if ( wID == IDC_PP_ASSIGN_BUTTON )
    {
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_PP_BUTTON_MB_SETTING), fEnable);
    }

    SetDirty(TRUE);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnPushButtonClicked
//
//  Description:    When pushed button is pressed, this function is called
//                  to respond it.   
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////

const TCHAR c_szcplsKey[]    = TEXT("software\\microsoft\\windows\\currentversion\\control panel\\cpls");

LRESULT CSptipPropertyPage::OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
    HRESULT hr = S_OK;

    switch (wID)
    {
    case IDC_PP_BUTTON_ADVANCE :

        if (m_SpAdvanceSet)
        {
            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        m_SpAdvanceSet = (CSpAdvanceSetting *) new CSpAdvanceSetting( );

        if ( m_SpAdvanceSet )
        {
            int nRetCode;

            nRetCode = m_SpAdvanceSet->DoModalW(m_hDlg, (LPARAM)m_SpPropItemsServer);

            if ( nRetCode == TRUE)
                SetDirty(TRUE);

            delete m_SpAdvanceSet;
            m_SpAdvanceSet = NULL;
        }

        break;

    case IDC_PP_BUTTON_LANGBAR :
        {
            TCHAR szCmdLine[MAX_PATH];
            TCHAR szInputPath[MAX_PATH];
            int cch = GetSystemDirectory(szInputPath, ARRAYSIZE(szInputPath));

            if (cch > 0)
            {
                // GetSystemDirectory appends no '\' unless the system
                // directory is the root, such like "c:\"
                if (cch != 3)
                    StringCchCat(szInputPath,ARRAYSIZE(szInputPath),TEXT("\\"));

                StringCchCat(szInputPath, ARRAYSIZE(szInputPath), TEXT("input.dll"));

                StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("rundll32 shell32.dll,Control_RunDLL \"%s\""),szInputPath);

                // start Language Bar control panel applet
                RunCPLSetting(szCmdLine);
            }

            break;
        }

    case IDC_PP_BUTTON_SPCPL :
        {
            // these have to be Ansi based, as we support non-NT
            TCHAR szCplPath[MAX_PATH];
            TCHAR szCmdLine[MAX_PATH];
            CMyRegKey regkey;

            szCplPath[0] = TEXT('\0');
            if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szcplsKey, KEY_READ))
            {
                LONG lret;
                
                lret = regkey.QueryValueCch(szCplPath, TEXT("Speech"), ARRAYSIZE(szCplPath));
            }

            if ( szCplPath[0] )
            {
                StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("rundll32 shell32.dll,Control_RunDLL \"%s\""),szCplPath);

                // start speech control panel applet
                RunCPLSetting(szCmdLine);
            }

            break;
        }

    case IDC_PP_BUTTON_MB_SETTING :
        if (m_SpModeBtnSet)
        {
            delete m_SpModeBtnSet;
            m_SpModeBtnSet = NULL;
        }

        m_SpModeBtnSet = (CSpModeButtonSetting *) new CSpModeButtonSetting( );

        if ( m_SpModeBtnSet )
        {
            int nRetCode;
            DWORD   dwDictOrg,  dwCommandOrg;
            DWORD   dwDictNew,  dwCommandNew;

            dwDictOrg = m_SpPropItemsServer->_GetPropData(PropId_Dictation_Key);
            dwCommandOrg = m_SpPropItemsServer->_GetPropData(PropId_Command_Key);

            nRetCode = m_SpModeBtnSet->DoModalW(m_hDlg, (LPARAM)m_SpPropItemsServer);

            dwDictNew = m_SpPropItemsServer->_GetPropData(PropId_Dictation_Key);
            dwCommandNew = m_SpPropItemsServer->_GetPropData(PropId_Command_Key);

            if ( (dwDictNew != dwDictOrg) || (dwCommandNew != dwCommandOrg) )
                SetDirty(TRUE);

            delete m_SpModeBtnSet;
            m_SpModeBtnSet = NULL;
        }

        break;

    default :

        Assert(0);
        break;
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnInitSptipPropPageDialog
//
//  Description:    This function responds to the WM_INITDIALOG message
//                  Getting the initial value for all the property items,
//                  and show the correct status in the related control items.   
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSptipPropertyPage::OnInitSptipPropPageDialog(HWND hDlg )
{
    HRESULT  hr=S_OK;

    m_hDlg = hDlg;

    if ( !m_SpPropItemsServer )
        m_SpPropItemsServer = (CSpPropItemsServer *) new CSpPropItemsServer;

    if ( !m_SpPropItemsServer )
        return E_FAIL;

    if ( !m_IdCtrlPropMap )
    {
        CONTROL_PROP_MAP IdCtrlPropMap[] =
        {
            //    idCtrl,                     idPropItem,            fEdit
            {IDC_PP_SHOW_BALLOON,       PropId_Hide_Balloon,        FALSE},
            {IDC_PP_LMA,                PropId_Support_LMA,         FALSE},    
            {IDC_PP_HIGH_CONFIDENCE,    PropId_High_Confidence,     FALSE},    
            {IDC_PP_SAVE_SPDATA,        PropId_Save_Speech_Data,    FALSE},
            {IDC_PP_REMOVE_SPACE,       PropId_Remove_Space,        FALSE},    
            {IDC_PP_DIS_DICT_TYPING,    PropId_DisDict_Typing,      FALSE},    
            {IDC_PP_PLAYBACK,           PropId_PlayBack,            FALSE},    
            {IDC_PP_DICT_CANDUI_OPEN,   PropId_Dict_CandOpen,       FALSE},    
            {IDC_PP_DICTCMDS,           PropId_Cmd_DictMode,        FALSE},
            {IDC_PP_ASSIGN_BUTTON,      PropId_Mode_Button,         FALSE},   
            { 0,                        PropId_Max_Item_Id,         FALSE }

        };

        DWORD   dwPropItems = ARRAYSIZE(IdCtrlPropMap) -1 ;

        m_IdCtrlPropMap = (CONTROL_PROP_MAP  *)cicMemAlloc(dwPropItems * sizeof(CONTROL_PROP_MAP));

        if ( m_IdCtrlPropMap == NULL )
            return E_OUTOFMEMORY;

        for ( DWORD i=0; i<dwPropItems; i++)
        {
            m_IdCtrlPropMap[i] = IdCtrlPropMap[i];
        }

        m_dwNumCtrls = dwPropItems;
    }


    for (DWORD i=0; i<m_dwNumCtrls; i++ )
    {
        WORD          idCtrl;
        PROP_ITEM_ID  idPropItem;
        BOOL          fEditControl;

        idCtrl = m_IdCtrlPropMap[i].idCtrl;
        idPropItem = m_IdCtrlPropMap[i].idPropItem;
        fEditControl = m_IdCtrlPropMap[i].fEdit;

        // BugBug:  There is no edit control in current property page.
        // all the edit controls are moved to advanced setting dialog.
        // temporally keep the code here, but after we finish the code for the 
        // advcanced setting dialog, please optimize code here.
        //
        if ( fEditControl )
        {
            ::SetDlgItemInt(m_hDlg, idCtrl, (UINT)m_SpPropItemsServer->_GetPropData(idPropItem), TRUE);
        }
        else
        {
            BOOL    fEnable;
            LPARAM  bst_Status;

            fEnable = (BOOL)m_SpPropItemsServer->_GetPropData(idPropItem);

            // Specially handle "Show Balloon" button.
            // Since internally we have "Hide_Balloon" property, it should be oppsite to 
            // to the check status of the button.

            if ( idPropItem == PropId_Hide_Balloon )
                bst_Status = fEnable ? BST_UNCHECKED : BST_CHECKED;
            else
                bst_Status = fEnable ? BST_CHECKED : BST_UNCHECKED;
            
            ::SendDlgItemMessage(m_hDlg, idCtrl, BM_SETCHECK, bst_Status, 0);
        }
    }

    // Specially handle the Mode button settings.

    if (! m_SpPropItemsServer->_GetPropData(PropId_Mode_Button) )
    {
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_PP_BUTTON_MB_SETTING), FALSE);
    }

    // if the property page is launched from input cpl, we don't want to show 
    // language bar buttons in this page.

    if ( m_fLaunchFromInputCpl )
    {
        ::ShowWindow(::GetDlgItem(m_hDlg, IDC_PP_BUTTON_LANGBAR), SW_HIDE);
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::OnApply
//
//  Description:    When Apply or OK button is clicked, this function will
//                  check if there is any item status change, if changed,
//                  save the data to the persistent storage, and notify 
//                  Cicero application to update their status.
//
//  Return Values:  S_OK
//
//////////////////////////////////////////////////////////////////////////////
LRESULT CSptipPropertyPage::OnApply( ) 
{
    HRESULT hr = S_OK; 

    if ( !IsPageDirty( ) ) return hr;

    // change the registry settings here. !!!
    Assert(m_SpPropItemsServer);
    m_SpPropItemsServer->_SavePropData( );

    // Notify all the Cicero Applications of these registry settings change.

    if ( SUCCEEDED(hr) )
    {
        hr = _SetGlobalCompDWORD(GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE, 1);
    }

    if (SUCCEEDED(hr))
    {
        SetDirty(FALSE);
    }
    
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSptipPropertyPage::SpPropertyPageProc
//
//  Description:    Message handling procedure callback function for 
//                  the dialog.
//
//  Return Values:  required value per message.
//
//////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CSptipPropertyPage::SpPropertyPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT iRet = 0;
    CSptipPropertyPage *pSpProp = (CSptipPropertyPage *)::GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGEW *pPropSheetPage =  (PROPSHEETPAGEW *)(lParam);

            Assert(pPropSheetPage);

            ::SetWindowLongPtr(hDlg, GWLP_USERDATA, pPropSheetPage->lParam);
            pSpProp = (CSptipPropertyPage *)(pPropSheetPage->lParam);

            if ( pSpProp )
               pSpProp->OnInitSptipPropPageDialog(hDlg);

            iRet = TRUE;

            break;
        }

    case WM_NOTIFY:

        Assert(pSpProp);
        switch (((NMHDR*)lParam)->code)
        {
        case PSN_APPLY:

            pSpProp->OnApply();
            break;

        case PSN_QUERYCANCEL:  // user clicks the Cancel button

            //pSpProp->OnCancel();
            break;
        }
        break;

    case  WM_HELP  :
	
        WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 c_szHelpFile,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aSptipPropIds );
        break;

    case  WM_CONTEXTMENU  :      // right mouse click
    
        WinHelp( (HWND)wParam,
                 c_szHelpFile,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aSptipPropIds );
        break;
    
    case ( WM_COMMAND ) :
        {
            Assert(pSpProp);

            switch (LOWORD(wParam))
            {
            case IDC_PP_SHOW_BALLOON        :
            case IDC_PP_LMA                 :       
            case IDC_PP_HIGH_CONFIDENCE     :           
            case IDC_PP_SAVE_SPDATA         :          
            case IDC_PP_REMOVE_SPACE        :         
            case IDC_PP_DIS_DICT_TYPING     :          
            case IDC_PP_PLAYBACK            :              
            case IDC_PP_DICT_CANDUI_OPEN    :
            case IDC_PP_DICTCMDS            :
            case IDC_PP_ASSIGN_BUTTON       :
                
                if ( pSpProp )
                   pSpProp->OnCheckButtonSetting( HIWORD(wParam), LOWORD(wParam), (HWND)lParam );
                break;

            case IDC_PP_BUTTON_MB_SETTING   :
            case IDC_PP_BUTTON_ADVANCE      :
            case IDC_PP_BUTTON_LANGBAR      :
            case IDC_PP_BUTTON_SPCPL        :
                
                if ( pSpProp )
                   pSpProp->OnPushButtonClicked( HIWORD(wParam), LOWORD(wParam), (HWND)lParam );

                break;

            default :
                iRet = 0;
            }

            iRet = TRUE;
            break;
        }

    case  WM_DESTROY :
        {
            Assert(pSpProp);

            if ( pSpProp )
                delete pSpProp;

            break;
        }
    }

    return (iRet);
}

//
// CSapiIMX::InvokeSpeakerOptions 
//
//
void CSapiIMX::_InvokeSpeakerOptions( BOOL fLaunchFromInputCpl )
{
    PROPSHEETHEADERW psh;
    HPROPSHEETPAGE  phPages[2];

    // check if this proppage has already shown up and got focus.

    HWND    hWndFore;

    hWndFore = ::GetForegroundWindow( );

    if ( hWndFore )
    {
        WCHAR   wszTextTitle[MAX_PATH];

        GetWindowTextW(hWndFore, wszTextTitle, ARRAYSIZE(wszTextTitle));

        if ( wcscmp(wszTextTitle, CRStr(IDS_PROPERTYPAGE_TITLE)) == 0 )
        {
            // the proppage has beeb shown and got focus.
            // don't show it again.

            return;
        }
    }
       
    ::InitCommonControls( );

    // Initialize the property sheet header.
    psh.dwSize = sizeof(PROPSHEETHEADERW);
    psh.dwFlags = 0;
    psh.hwndParent = ::GetActiveWindow( );
    psh.hInstance = GetCicResInstance(g_hInst, IDS_PROPERTYPAGE_TITLE);
    psh.pszCaption = MAKEINTRESOURCEW(IDS_PROPERTYPAGE_TITLE);
    psh.nStartPage = 0;
    psh.phpage = phPages;
    psh.nPages = 0;

    // Add one page for now.
    // extendable for the future.

    CSptipPropertyPage  *pSpProp = (CSptipPropertyPage *) new CSptipPropertyPage(IDD_PROPERTY_PAGE, fLaunchFromInputCpl);

    if ( pSpProp )
    {
        PROPSHEETPAGEW   psp;

        psp.dwSize = sizeof(PROPSHEETPAGEW);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = GetCicResInstance(g_hInst, pSpProp->GetDlgResId());
        psp.pszTemplate = MAKEINTRESOURCEW( pSpProp->GetDlgResId( ) );
        psp.pfnDlgProc = pSpProp->GetDlgProc( );
        psp.lParam = (LPARAM) pSpProp;

        phPages[psh.nPages] = ::CreatePropertySheetPageW(&psp);

        if (phPages[psh.nPages])
            psh.nPages ++;
    }

    // If there is at least one page exists, create the property sheet.
    //
    if ( psh.nPages > 0 )
        ::PropertySheetW(&psh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\propitem.h ===
//
#ifndef _PROPITEM_H
#define  _PROPITEM_H

const TCHAR c_szNumAlt[]           = TEXT("NumAlt");
const TCHAR c_szMasterLM[]         = TEXT("MasterLM");
const TCHAR c_szCtxtFeed[]         = TEXT("ContextFeed");
const TCHAR c_szEnableLMA[]        = TEXT("EnableLMA");
const TCHAR c_szSerialize[]        = TEXT("Serialize");
const TCHAR c_szDictModebias[]     = TEXT("DictModebias");

// const TCHAR c_szDocBlockSize[]     = TEXT("docblocksize");
// const TCHAR c_szMaxCandChars[]     = TEXT("MaxCandChars");

const TCHAR c_szDictCmd[]          = TEXT("DictationCommands"); // Enable / Disbale commands in Dictation mode
const TCHAR c_szKeyboardCmd[]      = TEXT("KeyboardCmd");
const TCHAR c_szSelectCmd[]        = TEXT("SelectCmd");
const TCHAR c_szNavigateCmd[]      = TEXT("NavigateCmd");
const TCHAR c_szCaseCmd[]          = TEXT("CasingCmd");
const TCHAR c_szEditCmd[]          = TEXT("EditCmd");
const TCHAR c_szLangBarCmd[]       = TEXT("LangBarCmd");
const TCHAR c_szTTSCmd[]           = TEXT("TTSCmd");
 
const TCHAR c_szModeButton[]       = TEXT("ModeButton");
const TCHAR c_szDictKey[]          = TEXT("DictationKey");
const TCHAR c_szCmdKey[]           = TEXT("CommandKey");

const TCHAR c_szHighConf[]         = TEXT("HighConfidenceForShortWord");
const TCHAR c_szRemoveSpace[]      = TEXT("RemoveSpaceForSymbol");
const TCHAR c_szDisDictTyping[]    = TEXT("DisableDictTyping");
const TCHAR c_szPlayBack[]         = TEXT("PlayBackCandUI");
const TCHAR c_szDictCandOpen[]     = TEXT("DictCandOpen");
                                          
#define  UNINIT_VALUE    0xffff

// 
// Take use of the below enum type as a common status type to replace 
// the many previous similar enum types for different individual items, 
// such as KEYCMD,  LMSTAT, GSTAT, DICTCMD, etc.
// 
typedef enum
{
    PROP_UNINITIALIZED  = 0x0,
    PROP_ENABLED        = 0x1,   
    PROP_DISABLED       = 0x2    
} PROP_STATUS;

typedef enum
{
    PropId_Min_Item_Id          = 0,

    // Property Items in the top property page.
    PropId_Min_InPropPage       = 0,
    PropId_Hide_Balloon         = 0,            // Enable/Disable hiding speech balloon
    PropId_Support_LMA          = 1,            // Enable/Disable LMA Support
    PropId_High_Confidence      = 2,            // Require High Confidence for short words
    PropId_Save_Speech_Data     = 3,            // Enable/Disable Save Speech Data 
    PropId_Remove_Space         = 4,            // Enable removing whitespace for punctations
    PropId_DisDict_Typing       = 5,            // Support disabling dictation while typing
    PropId_PlayBack             = 6,            // Enable playback audio while candidate UI is to open.
    PropId_Dict_CandOpen        = 7,            // Allow dictation while candidate UI is open.
    PropId_Cmd_DictMode         = 8,            // Enable/Disable all commands in dictation mode
    PropId_Mode_Button          = 9,            // Enable/Disable Mode Buttons
    PropId_MaxId_InPropPage     = 9,

    // Property Items in the voice command setting dialog
    PropId_MinId_InVoiceCmd     = 10,
    PropId_Cmd_Select_Correct   = 10,             // Enable/Disable Selection commands
    PropId_Cmd_Navigation       = 11,            // Enalbe/Disable Navigation commands
    PropId_Cmd_Casing           = 12,            // Enable/Disable Casing Commands
    PropId_Cmd_Editing          = 13,            // Enable/Disable Editing Commands
    PropId_Cmd_Keyboard         = 14,            // Enable/Disable Keyboard simulation commands
    PropId_Cmd_TTS              = 15,            // Enable/Disable TTS commands
    PropId_Cmd_Language_Bar     = 16,            // Enable/Disalbe Langauge Bar commands
    PropId_MaxId_InVoiceCmd     = 16,

    // Property Items in the Mode button setting dialog
    PropId_MinId_InModeButton   = 17,
    PropId_Dictation_Key        = 17,           // Virtual key for Dictation Key
    PropId_Command_Key          = 18,           // Virtual key for Command Key
    PropId_MaxId_InModeButton   = 18,

    // Property items which are not configurable through property page.
    PropId_Max_Alternates       = 19,           // Maximum number of alternates
    PropId_MaxChar_Cand         = 20,           // Maximum number of candidate characters
    PropId_Context_Feeding      = 21,            // Enable/Disable Context Feeding
    PropId_Dict_ModeBias        = 22,            // Enable/Disable Dictation while ModeBias
    PropId_LM_Master_Cand       = 23,            // Enable/Disable Master LM for candidates

    PropId_Max_Item_Id          = 24

} PROP_ITEM_ID;


typedef struct _Prop_Item
{
    PROP_ITEM_ID       idPropItem;
    const TCHAR       *lpszValueName;

    GUID               *pguidComp;
    DWORD              dwMaskBit;
    BOOL               fIsStatus;      // TRUE means this is Enable/Disable item
                                       // FALSE means this is a value item, DWORD
    union 
    {
        DWORD          dwDefault;
        PROP_STATUS    psDefault;
    };

}  PROP_ITEM;


class _declspec(novtable) CPropItem
{
public: 
    CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, PROP_STATUS psDefault);
    CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, DWORD       dwDefault);
    CPropItem(PROP_ITEM_ID idPropItem, GUID *pguidComp, DWORD  dwMaskBit,   PROP_STATUS  psDefault);
    CPropItem(CPropItem *pItem);
    ~CPropItem( );

    BOOL  GetPropStatus(BOOL fForceFromReg=FALSE);
    DWORD GetPropValue(BOOL fForceFromReg=FALSE );

    void SetPropStatus(BOOL fEnable);
    void SetPropValue(DWORD dwValue);

    void SavePropData( );
    void SaveDefaultRegValue( );

    BOOL IsStatusPropItem( ) { return m_fIsStatus; }
    PROP_ITEM_ID GetPropItemId( ) {  return m_PropItemId; }

    BOOL IsGlobalCompartPropItem( )  { return ((m_pguidComp && !m_lpszValueName) ? TRUE : FALSE); }

    TCHAR  *GetRegValue( )  { return m_lpszValueName; }
    GUID   *GetCompGuid( )  { return m_pguidComp; }
    DWORD  GetMaskBit( )    { return m_dwMaskBit; }

    PROP_STATUS  GetPropDefaultStatus( ) { return  m_psDefault; }
    DWORD        GetPropDefaultValue( )  { return m_dwDefault; }
    
private:

    HRESULT   _GetRegValue(HKEY  hRootKey, DWORD  *dwValue);
    void      _SetRegValue(HKEY  hRootKey, DWORD  dwValue);

    PROP_ITEM_ID   m_PropItemId;
    TCHAR         *m_lpszValueName;
    GUID          *m_pguidComp;
    DWORD          m_dwMaskBit;
    BOOL           m_fIsStatus;  // TRUE means this prop keeps bool (Enable/Disable).
                                 // FALSE means this prop keeps raw data (ulong).
    union 
    {
        DWORD        m_dwDefault;
        PROP_STATUS  m_psDefault;
    };

    union 
    {
        DWORD        m_dwValue;
        PROP_STATUS  m_psStatus;
    };
};

        
class __declspec(novtable) CSpPropItemsServer
{
public:
    CSpPropItemsServer( );
    CSpPropItemsServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax);
    ~CSpPropItemsServer( );

    CPropItem  *_GetPropItem(PROP_ITEM_ID idPropItem);
    DWORD   _GetPropData(PROP_ITEM_ID idPropItem, BOOL fForceFromReg=FALSE );
    DWORD   _GetPropDefaultData(PROP_ITEM_ID idPropItem);
    void    _SetPropData(PROP_ITEM_ID idPropItem, DWORD dwData);
    
    void    _SavePropData(  );
    void    _SaveDefaultData( );

    DWORD   _GetNumPropItems( ) { return m_dwNumOfItems; }
    HRESULT _MergeDataFromServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax);

private:

    HRESULT      _Initialize( );

    CPropItem    **m_PropItems;
    BOOL         m_fInitialized;
    DWORD        m_dwNumOfItems;
};

// 
// This is a server wrap derived by CSapiIMX.
//
class __declspec(novtable) CSpPropItemsServerWrap : public CSpPropItemsServer
{
public:
    CSpPropItemsServerWrap( )
    {
#if 0
        for (DWORD i=0; i<(DWORD)PropId_Max_Item_Id; i++)
            m_bChanged[i] = FALSE;
#else
        memset(m_bChanged, 0, sizeof(m_bChanged));
#endif    
    };

    ~CSpPropItemsServerWrap( ){ };

    ULONG   _GetMaxAlternates( );
    ULONG   _GetMaxCandidateChars( );

    BOOL    _MasterLMEnabled( ) { return (BOOL)_GetPropData(PropId_LM_Master_Cand); }

    BOOL    _ContextFeedEnabled( ) { return (BOOL)_GetPropData(PropId_Context_Feeding); }

    BOOL    _IsModeBiasDictationEnabled( ) { return (BOOL) _GetPropData(PropId_Dict_ModeBias); }

    BOOL    _SerializeEnabled( ) { return (BOOL) _GetPropData(PropId_Save_Speech_Data);}

    BOOL    _LMASupportEnabled( ) { return (BOOL) _GetPropData(PropId_Support_LMA); }

    BOOL    _RequireHighConfidenceForShorWord( ) { return (BOOL) _GetPropData(PropId_High_Confidence); }

    BOOL    _NeedRemovingSpaceForPunctation( ) {  return (BOOL) _GetPropData(PropId_Remove_Space);}

    BOOL    _NeedDisableDictationWhileTyping( ) {  return (BOOL) _GetPropData(PropId_DisDict_Typing); }

    BOOL    _EnablePlaybackWhileCandUIOpen( ) {return (BOOL) _GetPropData(PropId_PlayBack); }

    BOOL    _AllowDictationWhileCandOpen( ) { return (BOOL) _GetPropData(PropId_Dict_CandOpen); }

    BOOL    _SelectCorrectCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Select_Correct); }

    BOOL    _NavigationCmdEnabled( ) { return (BOOL) _GetPropData(PropId_Cmd_Navigation); }

    BOOL    _CasingCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Casing); }

    BOOL    _EditingCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Editing); }

    BOOL    _KeyboardCmdEnabled( ) { return (BOOL) _GetPropData(PropId_Cmd_Keyboard); }

    BOOL    _TTSCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_TTS); }

    BOOL    _LanguageBarCmdEnabled( )  { return (BOOL) _GetPropData(PropId_Cmd_Language_Bar); }

    BOOL    _AllDictCmdsDisabled( ) { return !(BOOL) _GetPropData(PropId_Cmd_DictMode); }

    BOOL    _AllCmdsEnabled( );  
    BOOL    _AllCmdsDisabled( );
    void    _RenewAllPropDataFromReg( );

    BOOL    _IsModeKeysEnabled( ) { return (BOOL) _GetPropData(PropId_Mode_Button); }

    DWORD   _GetDictationButton( ) { return _GetPropData(PropId_Dictation_Key); }

    DWORD   _GetCommandButton( ) { return _GetPropData(PropId_Command_Key); }

    BOOL    _IsPropItemChangedSinceLastRenew(PROP_ITEM_ID idPropItem)  { return m_bChanged[(DWORD)idPropItem]; }

private:

    BOOL    m_bChanged[(DWORD)PropId_Max_Item_Id];  // indicates if the items have been changed since last
                                                    // renew from Registry.
};
#endif // _PROPITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\proppage.h ===
#ifndef _PROPPAGE_H
#define _PROPPAGE_H

#include "Sapilayr.h"   
#ifdef USE_IPROPERTYPAGE
#include "atlctl.h"
#endif // USE_IPROPERTYPAGE
#include "sptiphlp.h"
extern CComModule _Module;
#include "atlwin.h"

typedef struct _ControlID_PropID_Mapping
{
    WORD            idCtrl;
    PROP_ITEM_ID    idPropItem;
    BOOL            fEdit;     // TRUE means this is a edit control
                               // FALS means this is a check control
}  CONTROL_PROP_MAP;

typedef struct _KeyName_VK_Map
{
    LPCTSTR        pKeyName;
    WORD           wVKey;
}  KEYNAME_VK_MAP;

class CSpAdvanceSetting;
class CSpModeButtonSetting;

#ifdef USE_IPROPERTYPAGE

/////////////////////////////////////////////////////////////////////////////
// CSpPropertyPage
class  CSpPropertyPage :// public IPropertyPage,
                        public CComObjectRoot,
                        public CComCoClass<CSpPropertyPage, &CLSID_SpPropertyPage>,
                        public IPropertyPageImpl<CSpPropertyPage>,
                        public CDialogImpl<CSpPropertyPage>
{
public:
	CSpPropertyPage();
	~CSpPropertyPage();

    enum {IDD = IDD_PROPERTY_PAGE};

    typedef IPropertyPageImpl<CSpPropertyPage> PPBaseClass;

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpPropertyPage) 
	    COM_INTERFACE_ENTRY(IPropertyPage)
    END_COM_MAP()

    IMMX_DECLARE_REGISTRY_RESOURCE(IDR_PROPERTY_PAGE)

    BEGIN_MSG_MAP(CSpPropertyPage)
        COMMAND_ID_HANDLER(IDC_PP_SELECTION_CMD,        OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_NAVIGATION_CMD,       OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_CASING_CMD,           OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_EDITING_CMD,          OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_KEYBOARD_CMD,         OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_LANGBAR_CMD,          OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_TTS_CMD,              OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_DISABLE_DICTCMD,      OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_ASSIGN_BUTTON,        OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_BUTTON_MB_SETTING,    OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDC_PP_BUTTON_ADVANCE,       OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDC_PP_BUTTON_LANGBAR,       OnPushButtonClicked)

        CHAIN_MSG_MAP(IPropertyPageImpl<CSpPropertyPage>)
    END_MSG_MAP()

//-- Methods

    STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc,BOOL bModal);

	STDMETHOD(Apply)(void);

    LRESULT OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);

private:

//-- Methods
    
    HRESULT InitPropertyPage();

//-- Members

    // GUI stuff
    HWND                            m_hWndParent;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;
    CSpAdvanceSetting              *m_SpAdvanceSet;
};

#endif // USE_IPROPERTYPAGE

static TCHAR c_szHelpFile[]    = TEXT("input.hlp");

// Class for the Advanced setting dialog
                        
class CSpAdvanceSetting : public CDialogImpl<CSpAdvanceSetting>
{
public:

    CSpAdvanceSetting( );
    ~CSpAdvanceSetting( );

    enum {IDD = IDD_PP_DIALOG_ADVANCE};

    BEGIN_MSG_MAP(CSpAdvanceSetting)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitAdvanceDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
        MESSAGE_HANDLER(WM_HELP, OnContextHelp)

        COMMAND_ID_HANDLER(IDC_PP_SELECTION_CMD,        OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_NAVIGATION_CMD,       OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_CASING_CMD,           OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_EDITING_CMD,          OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_KEYBOARD_CMD,         OnCheckButtonSetting)
        COMMAND_ID_HANDLER(IDC_PP_LANGBAR_CMD,          OnCheckButtonSetting)
//        COMMAND_ID_HANDLER(IDC_PP_TTS_CMD,              OnCheckButtonSetting)

/*
        COMMAND_ID_HANDLER(IDC_PP_MAXCHARS_ALTERNATE,   OnEditControlSetting)
        COMMAND_ID_HANDLER(IDC_PP_MAXNUM_ALTERNATES,    OnEditControlSetting)
*/
        COMMAND_ID_HANDLER(IDOK,                        OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDCANCEL,                    OnPushButtonClicked)

    END_MSG_MAP()

    INT_PTR DoModalW(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
    {
        ATLASSERT(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImpl<CSpAdvanceSetting> *)this);
        return ::DialogBoxParamW(GetCicResInstance(g_hInst, CSpAdvanceSetting::IDD),
                    MAKEINTRESOURCEW(CSpAdvanceSetting::IDD),
                    hWndParent, (DLGPROC)CSpAdvanceSetting::StartDialogProc, dwInitParam);
    }


    LRESULT OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
//    LRESULT OnEditControlSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);

    LRESULT OnInitAdvanceDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );
    LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );

    BOOL    IsItemStatusChanged( );

private:

    CSpPropItemsServer             *m_SpPropBaseServer;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;

};

// Class for the Mode Button Setting dialog
                        
class CSpModeButtonSetting : public CDialogImpl<CSpModeButtonSetting>
{
public:

    CSpModeButtonSetting( );
    ~CSpModeButtonSetting( );

    enum {IDD = IDD_PP_DIALOG_BUTTON_SET};

    BEGIN_MSG_MAP(CSpModeButtonSetting)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitModeButtonDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
        MESSAGE_HANDLER(WM_HELP, OnContextHelp)

        COMMAND_ID_HANDLER(IDC_PP_DICTATION_CMB,        OnCombBoxSetting)
        COMMAND_ID_HANDLER(IDC_PP_COMMAND_CMB,          OnCombBoxSetting)

        COMMAND_ID_HANDLER(IDOK,                        OnPushButtonClicked)
        COMMAND_ID_HANDLER(IDCANCEL,                    OnPushButtonClicked)
	
    END_MSG_MAP()

    INT_PTR DoModalW(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
    {
        ATLASSERT(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImpl<CSpModeButtonSetting> *)this);
        return ::DialogBoxParamW(GetCicResInstance(g_hInst, CSpModeButtonSetting::IDD),
                    MAKEINTRESOURCEW(CSpModeButtonSetting::IDD),
                    hWndParent, (DLGPROC)CSpModeButtonSetting::StartDialogProc, dwInitParam);
    }

    LRESULT OnCombBoxSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl,BOOL& bHandled);

    LRESULT OnInitModeButtonDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );
    LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,BOOL& bHandled );

private:

    CSpPropItemsServer             *m_SpPropBaseServer;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;
};

class CSptipPropertyPage 
{
public:

    CSptipPropertyPage ( WORD wDlgId, BOOL fLaunchFromInputCpl );
    ~CSptipPropertyPage ( );

    static INT_PTR CALLBACK SpPropertyPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    LRESULT OnCheckButtonSetting(WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnPushButtonClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnApply( );

    LRESULT OnInitSptipPropPageDialog( HWND hDlg );

    WORD    GetDlgResId( ) { return m_wDlgId; }
    DLGPROC GetDlgProc( )  { return (DLGPROC) SpPropertyPageProc; }

    BOOL    IsPageDirty( ) { return m_fIsDirty; }
    void    SetDirty( BOOL fDirty ); 

private:

//-- Members

    WORD                            m_wDlgId;
    HWND                            m_hDlg;
    CSpPropItemsServer             *m_SpPropItemsServer;
    DWORD                           m_dwNumCtrls;
    CONTROL_PROP_MAP               *m_IdCtrlPropMap;
    CSpAdvanceSetting              *m_SpAdvanceSet;
    CSpModeButtonSetting           *m_SpModeBtnSet;
    BOOL                            m_fIsDirty;
    BOOL                            m_fLaunchFromInputCpl;   // indicates if the property page is launched from input cpl.
};

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\propitem.cpp ===
// This is implementation for CSpPropItemsServer

#include "private.h"
#include "globals.h"
#include "propitem.h"
#include "cregkey.h"

extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

// Common functions about Setting /Getting global compartment values.

HRESULT _SetGlobalCompDWORD(REFGUID rguid, DWORD   dw)
{
    HRESULT hr = S_OK;

    CComPtr<ITfCompartmentMgr>  cpGlobalCompMgr;
    CComPtr<ITfCompartment>     cpComp;
    VARIANT                     var;

    hr = TF_GetGlobalCompartment(&cpGlobalCompMgr);

    if ( hr == S_OK )
        hr = cpGlobalCompMgr->GetCompartment(rguid, &cpComp);

    if ( hr == S_OK )
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = cpComp->SetValue(0, &var);
    }

    return hr;
}

HRESULT _GetGlobalCompDWORD(REFGUID rguid, DWORD  *pdw)
{
    HRESULT hr = S_OK;

    CComPtr<ITfCompartmentMgr>  cpGlobalCompMgr;
    CComPtr<ITfCompartment>     cpComp;
    VARIANT                     var;

    hr = TF_GetGlobalCompartment(&cpGlobalCompMgr);

    if ( hr == S_OK )
        hr = cpGlobalCompMgr->GetCompartment(rguid, &cpComp);

    if ( hr == S_OK )
        hr = cpComp->GetValue(&var);

    if ( hr == S_OK)
    {
        Assert(var.vt == VT_I4);
        *pdw = var.lVal;
    }

    return hr;
}

//
// ctor
//


CPropItem::CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, PROP_STATUS psDefault)
{
    int    iLen = lstrlen(lpszValueName);
    m_lpszValueName = (LPTSTR)cicMemAlloc((iLen+1) * sizeof(TCHAR));
    if ( m_lpszValueName )
    {
        StringCchCopy(m_lpszValueName, iLen+1, lpszValueName);
    }
    m_psDefault = psDefault;
    m_psStatus = PROP_UNINITIALIZED;
    m_fIsStatus = TRUE;
    m_PropItemId = idPropItem;

    m_pguidComp = NULL;
    m_dwMaskBit = 0;
}

CPropItem::CPropItem(PROP_ITEM_ID idPropItem, LPCTSTR lpszValueName, DWORD  dwDefault)
{
    int    iLen = lstrlen(lpszValueName);
    
    m_lpszValueName = (LPTSTR)cicMemAlloc((iLen+1) * sizeof(TCHAR));
    if ( m_lpszValueName )
    {
        StringCchCopy(m_lpszValueName,iLen+1, lpszValueName);
    }

    m_dwDefault = dwDefault;
    m_dwValue = UNINIT_VALUE;
    m_fIsStatus = FALSE;
    m_PropItemId = idPropItem;

    m_pguidComp = NULL;
    m_dwMaskBit = 0;
}

CPropItem::CPropItem(PROP_ITEM_ID idPropItem, GUID *pguidComp, DWORD  dwMaskBit,   PROP_STATUS  psDefault)
{
    m_lpszValueName = NULL;
    m_psDefault = psDefault;
    m_psStatus = PROP_UNINITIALIZED;
    m_fIsStatus = TRUE;
    m_PropItemId = idPropItem;

    m_pguidComp = (GUID *) cicMemAlloc(sizeof(GUID));

    if ( m_pguidComp && pguidComp)
        CopyMemory(m_pguidComp, pguidComp, sizeof(GUID));

    m_dwMaskBit = dwMaskBit;
}


CPropItem::CPropItem(CPropItem *pItem)
{
    Assert(pItem);

    m_PropItemId = pItem->GetPropItemId( );
    m_fIsStatus = pItem->IsStatusPropItem( );

    if ( pItem->IsGlobalCompartPropItem( ) )
    {
        // This is a Global compartment property item.
        m_lpszValueName = NULL;

        m_pguidComp = (GUID *) cicMemAlloc(sizeof(GUID));

        if (m_pguidComp)
            CopyMemory(m_pguidComp, pItem->GetCompGuid( ), sizeof(GUID));

        m_dwMaskBit = pItem->GetMaskBit( );
    }
    else
    {
        // This is a registry value property item.
        m_pguidComp = NULL;
        m_dwMaskBit = 0;

        TCHAR   *pItemRegValue;

        pItemRegValue = pItem->GetRegValue( );

        Assert(pItemRegValue);

        int iStrLen;

        iStrLen = lstrlen(pItemRegValue);

        m_lpszValueName = (LPTSTR)cicMemAlloc((iStrLen+1) * sizeof(TCHAR));
        if ( m_lpszValueName )
        {
            StringCchCopy(m_lpszValueName, iStrLen+1, pItemRegValue);
        }
    }

    if ( m_fIsStatus )
    {
        m_psDefault = pItem->GetPropDefaultStatus( );
        m_psStatus  = pItem->GetPropStatus( ) ? PROP_ENABLED : PROP_DISABLED;
    }
    else
    {
        m_dwDefault = pItem->GetPropDefaultValue( );
        m_dwValue   = pItem->GetPropValue( );
    }
}

CPropItem::~CPropItem( )
{
    if ( m_lpszValueName )
        cicMemFree(m_lpszValueName);

    if ( m_pguidComp )
        cicMemFree(m_pguidComp);
}

//
// Common method functions to get and set values from /to registry
//
HRESULT  CPropItem::_GetRegValue(HKEY  hRootKey, DWORD  *pdwValue)
{
    HRESULT  hr=S_FALSE;

    Assert(hRootKey);
    Assert(pdwValue);

    if ( IsGlobalCompartPropItem( ) ) return S_FALSE;

    CMyRegKey regkey;
    DWORD     dw;

    hr = regkey.Open(hRootKey, c_szSapilayrKey, KEY_READ);
    if (S_OK == hr )
    {
        if (ERROR_SUCCESS==regkey.QueryValue(dw, m_lpszValueName))
           *pdwValue = dw;
        else
            hr = S_FALSE;
    }

    return hr;
}
    
void  CPropItem::_SetRegValue(HKEY  hRootKey, DWORD  dwValue)
{
    Assert(hRootKey);

    if ( IsGlobalCompartPropItem( ) )
        return;

    // Registry setting
    CMyRegKey regkey;
    if (S_OK == regkey.Create(hRootKey, c_szSapilayrKey))
    {
        regkey.SetValue(dwValue, m_lpszValueName); 
    }
}


BOOL  CPropItem::GetPropStatus(BOOL fForceFromReg )
{

    // Cleanup: if we can introuce two separate derived classes for status property and value property,
    // there is no need to check m_fIsStatus this way.
    //
    // Compiler will detect any potential wrong code.
    if ( !m_fIsStatus )
        return FALSE;

    if (fForceFromReg || (m_psStatus == PROP_UNINITIALIZED) )
    {
        DWORD dw;

        if ( IsGlobalCompartPropItem( ) )
        {
            if ( S_OK == _GetGlobalCompDWORD(*m_pguidComp, &dw) )
                m_psStatus = (dw & m_dwMaskBit) ? PROP_ENABLED : PROP_DISABLED;
        }
        else
        {
            // This is Registry setting
            if ( (S_OK == _GetRegValue(HKEY_CURRENT_USER, &dw)) ||
                 (S_OK == _GetRegValue(HKEY_LOCAL_MACHINE, &dw)) )
            {
                m_psStatus = (dw > 0) ? PROP_ENABLED : PROP_DISABLED;
            }
        }


        if (m_psStatus == PROP_UNINITIALIZED)
            m_psStatus  = m_psDefault; 
    }

    return PROP_ENABLED == m_psStatus;
}

DWORD CPropItem::GetPropValue(BOOL fForceFromReg )
{
    if ( m_fIsStatus )
        return UNINIT_VALUE;

    if (fForceFromReg || (m_dwValue == UNINIT_VALUE) )
    {
        if ( (S_OK != _GetRegValue(HKEY_CURRENT_USER, &m_dwValue)) &&
             (S_OK != _GetRegValue(HKEY_LOCAL_MACHINE,&m_dwValue)) )
        {
            m_dwValue  = m_dwDefault; 
        }
    }

    return m_dwValue;
}

void CPropItem::SetPropStatus(BOOL fEnable)
{
    if ( m_fIsStatus )
        m_psStatus = fEnable ? PROP_ENABLED : PROP_DISABLED;
}

void CPropItem::SetPropValue(DWORD dwValue )
{
    if ( !m_fIsStatus )
        m_dwValue = dwValue;
}

void CPropItem::SaveDefaultRegValue( )
{
    if ( IsGlobalCompartPropItem( ) )
        return;
    
    DWORD  dw;

    if ( m_fIsStatus )
        dw = (m_psDefault == PROP_ENABLED ? 1 : 0 );
    else
        dw = m_dwDefault;

    _SetRegValue(HKEY_LOCAL_MACHINE, dw);
}

void CPropItem::SavePropData( )
{
    DWORD  dw;

    if ( m_fIsStatus )
        dw = (DWORD)GetPropStatus( );
    else
        dw = GetPropValue( );

    if ( IsGlobalCompartPropItem( ) )
    {
        // Global compartment setting
        if ( m_pguidComp && m_dwMaskBit )
        {
            DWORD dwComp;

            _GetGlobalCompDWORD(*m_pguidComp, &dwComp);

            if ( dw )
                dwComp |= m_dwMaskBit;
            else
                dwComp &= ~m_dwMaskBit;

            _SetGlobalCompDWORD(*m_pguidComp, dwComp);
        }
    }
    else 
    {
        // Registry setting
        _SetRegValue(HKEY_CURRENT_USER, dw);
    }
}

//
// CSpPropItemsServer
//
CSpPropItemsServer::CSpPropItemsServer( )
{
    m_fInitialized = FALSE;
    m_PropItems = NULL;

}


CSpPropItemsServer::CSpPropItemsServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax)
{
    Assert(pItemBaseServer);
    m_dwNumOfItems = 0;
    m_fInitialized = FALSE;

    m_PropItems = (CPropItem **) cicMemAlloc(((DWORD)idPropMax - (DWORD)idPropMin + 1) * sizeof(CPropItem  *));

    if ( m_PropItems )
    {
        DWORD  dwPropItemId;

        for (dwPropItemId=(DWORD)idPropMin; dwPropItemId<= (DWORD)idPropMax; dwPropItemId ++ )
        {
            // Find the propitem from the Base Server
            CPropItem  *pItem;

            pItem = pItemBaseServer->_GetPropItem((PROP_ITEM_ID)dwPropItemId);
            if ( pItem )
            {
                m_PropItems[m_dwNumOfItems] = (CPropItem *) new CPropItem(pItem);

                if ( m_PropItems[m_dwNumOfItems] )
                    m_dwNumOfItems ++;
            }
        }

        if ( m_dwNumOfItems > 0 )
            m_fInitialized = TRUE;
        else
            cicMemFree(m_PropItems);
    }
}

CSpPropItemsServer::~CSpPropItemsServer( )
{
    if ( m_PropItems )
    {
        Assert(m_dwNumOfItems);

        DWORD i;

        for ( i=0; i< m_dwNumOfItems; i++)
        {
            if ( m_PropItems[i] )
                delete m_PropItems[i];
        }

        cicMemFree(m_PropItems);
    }
}

LPCTSTR pszGetSystemMetricsKey = _T("System\\WPA\\TabletPC");
LPCTSTR pszGSMRegValue = _T("Installed");

HRESULT CSpPropItemsServer::_Initialize( )
{
    HRESULT  hr = S_OK;
    
    if ( m_fInitialized )
        return hr;

    m_dwNumOfItems = (DWORD) PropId_Max_Item_Id;

    m_PropItems = (CPropItem **) cicMemAlloc(m_dwNumOfItems * sizeof(CPropItem  *));

    if ( m_PropItems )
    {
        // Initializing the settings for all the items

        // If we add new more item later, please update this array value as well.
        PROP_ITEM  PropItems[ ] = {

            // Items in top property page
          {PropId_Cmd_Select_Correct,   c_szSelectCmd,      NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Navigation,       c_szNavigateCmd,    NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Casing,           c_szCaseCmd,        NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Editing,          c_szEditCmd,        NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Keyboard,         c_szKeyboardCmd,    NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_TTS,              c_szTTSCmd,         NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_Language_Bar,     c_szLangBarCmd,     NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Cmd_DictMode,         c_szDictCmd,        NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Mode_Button,          c_szModeButton,     NULL, 0, TRUE,   PROP_DISABLED   },

          // Items in Advanced Setting dialog
          {PropId_Hide_Balloon,         NULL, (GUID *)&GUID_COMPARTMENT_SPEECH_UI_STATUS,TF_DISABLE_BALLOON,TRUE,PROP_DISABLED},
          {PropId_Support_LMA,          c_szEnableLMA,      NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_High_Confidence,      c_szHighConf,       NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Save_Speech_Data,     c_szSerialize,      NULL, 0, TRUE,   PROP_DISABLED   },
          {PropId_Remove_Space,         c_szRemoveSpace,    NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_DisDict_Typing,       c_szDisDictTyping,  NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_PlayBack,             c_szPlayBack,       NULL, 0, TRUE,   PROP_DISABLED   },
          {PropId_Dict_CandOpen,        c_szDictCandOpen,   NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Max_Alternates,       c_szNumAlt,         NULL, 0, FALSE,  9               },
          {PropId_MaxChar_Cand,         c_szMaxCandChars,   NULL, 0, FALSE,  128             },

          // Items in ModeButton Setting dialog
          {PropId_Dictation_Key,        c_szDictKey,        NULL, 0, FALSE,  VK_F11          },
          {PropId_Command_Key,          c_szCmdKey,         NULL, 0, FALSE,  VK_F12          },

          // Items not in any property page and dialogs
          {PropId_Context_Feeding,      c_szCtxtFeed,       NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_Dict_ModeBias,        c_szDictModebias,   NULL, 0, TRUE,   PROP_ENABLED    },
          {PropId_LM_Master_Cand,       c_szMasterLM,       NULL, 0, TRUE,   PROP_DISABLED   },
        };

        DWORD  i;

        CMyRegKey regkey;
        DWORD dwInstalled = 0;
        BOOL fIsTabletPC = FALSE; // Default to false.

        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, pszGetSystemMetricsKey, KEY_READ))
        {
            if (ERROR_SUCCESS == regkey.QueryValue(dwInstalled, pszGSMRegValue))
            {
                fIsTabletPC = ( dwInstalled != 0 );
                // Only set fIsTabletPC to TRUE when key exists and contains non-zero.
            }
        }

        for ( i=0; i< m_dwNumOfItems; i++ )
        {
            PROP_ITEM_ID  PropId;

            PropId = PropItems[i].idPropItem;

            // Tablet PC has different default value for some of the propitems.
            if (fIsTabletPC)
            {
                switch (PropId)
                {
                case PropId_Cmd_DictMode :
                case PropId_DisDict_Typing :
                    PropItems[i].psDefault = PROP_DISABLED;
                    break;

                case PropId_Max_Alternates :
                    PropItems[i].dwDefault = 6;
                    break;

                default:
                    // keep the same setting for other items.
                    break;
                }
            }

            if ( PropItems[i].pguidComp )
            {
                // This is global compartment setting
                m_PropItems[i] = (CPropItem *)new CPropItem(PropId, PropItems[i].pguidComp, PropItems[i].dwMaskBit, PropItems[i].psDefault);
            }
            else
            {
                if ( PropItems[i].fIsStatus )
                    m_PropItems[i] = (CPropItem *)new CPropItem(PropId, PropItems[i].lpszValueName, PropItems[i].psDefault);
                else
                    m_PropItems[i] = (CPropItem *)new CPropItem(PropId, PropItems[i].lpszValueName, PropItems[i].dwDefault);
            }

            if ( !m_PropItems[i] )
            {
                hr = E_OUTOFMEMORY;

                // Release the allocated memory

                for ( ; i> 0; i-- )
                {
                    if ( m_PropItems[i-1] )
                        delete m_PropItems[i-1];
                }

                cicMemFree(m_PropItems);
                break;
            }
        }

        if ( hr == S_OK )
            m_fInitialized = TRUE;
    }


    if ( m_fInitialized )
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}


CPropItem  *CSpPropItemsServer::_GetPropItem(PROP_ITEM_ID idPropItem)
{
    CPropItem    *pItem = NULL;

    if ( !m_fInitialized )
        _Initialize( );

    if ( m_fInitialized )
    {
        for ( DWORD i=0; i< m_dwNumOfItems; i++)
        {
            if ( m_PropItems[i] && (idPropItem == m_PropItems[i]->GetPropItemId( )) )
            {
                // Found it.
                pItem = m_PropItems[i];
                break;
            }
        }
    }

    return pItem;
}

DWORD CSpPropItemsServer::_GetPropData(PROP_ITEM_ID idPropItem, BOOL fForceFromReg )
{
    DWORD         dwRet = 0;
    CPropItem    *pItem = NULL;

    pItem = _GetPropItem(idPropItem);

    if ( pItem )
    {
        if ( pItem->IsStatusPropItem( ) )
            dwRet = pItem->GetPropStatus(fForceFromReg);
        else
            dwRet = pItem->GetPropValue(fForceFromReg);
    }

    return dwRet;
}

DWORD CSpPropItemsServer::_GetPropDefaultData(PROP_ITEM_ID idPropItem )
{
    DWORD         dwRet = 0;
    CPropItem    *pItem = NULL;

    pItem = _GetPropItem(idPropItem);

    if ( pItem )
    {
        if ( pItem->IsStatusPropItem( ) )
            dwRet = pItem->GetPropDefaultStatus( );
        else
            dwRet = pItem->GetPropDefaultValue( );
    }

    return dwRet;
}
void  CSpPropItemsServer::_SetPropData(PROP_ITEM_ID idPropItem, DWORD dwData )
{
    Assert(m_fInitialized);
    Assert(m_PropItems);

    CPropItem    *pItem = NULL;

    pItem = _GetPropItem(idPropItem);

    if ( pItem )
    {
        if ( pItem->IsStatusPropItem( ) )
            pItem->SetPropStatus((BOOL)dwData);
        else
            pItem->SetPropValue(dwData);
    }
}

//
// Save all the property data managed by this server to registry or global compartment
//
// when Apply or OK buttons on the property page is pressed, 
// this function will be called.
//
void  CSpPropItemsServer::_SavePropData( )
{
    Assert(m_fInitialized);
    Assert(m_PropItems);

    CPropItem    *pItem = NULL;

    for ( DWORD i=0; i<m_dwNumOfItems; i++ )
    {
        pItem = m_PropItems[i];

        if ( pItem )
        {
            pItem->SavePropData( );
        }
    }
}

//
//
// Save all the default value to HKLM registry
// Self-Registration will call this method to set default value for all the properties.
//
//
void CSpPropItemsServer::_SaveDefaultData( )
{
    if ( !m_fInitialized )
        _Initialize( );

    if ( m_fInitialized && m_PropItems )
    {
        CPropItem    *pItem = NULL;

        for ( DWORD i=0; i<m_dwNumOfItems; i++ )
        {
            pItem = m_PropItems[i];

            if ( pItem )
                pItem->SaveDefaultRegValue( );
        }
    }
}

//
// Merge some prop data form other items server
//
// When a property item data is changed in Advanced or Mode button dialog, since these dialogs have 
// their own property server, all these changes need to be merged back to the base property server,
// so that they can be saved to the registry when user click "Apply" or "OK" in the top property page.
//

HRESULT CSpPropItemsServer::_MergeDataFromServer(CSpPropItemsServer *pItemBaseServer, PROP_ITEM_ID idPropMin, PROP_ITEM_ID idPropMax)
{
    HRESULT  hr = S_OK;

    Assert(pItemBaseServer);

    DWORD  dwData, idPropItem;

    for ( idPropItem=(DWORD)idPropMin; idPropItem<= (DWORD)idPropMax; idPropItem++)
    {
        dwData =  pItemBaseServer->_GetPropData((PROP_ITEM_ID)idPropItem);
        _SetPropData((PROP_ITEM_ID)idPropItem, dwData);
    }

    return hr;
}

//
//
// CSpPropItemsServerWrap
//

//
// Update our internal data members from Registry.
//
// When sapilayr TIP gets notified of the change of the registry value,
// it will call this method to renew its internal data with new registry data.
//
void    CSpPropItemsServerWrap::_RenewAllPropDataFromReg( )
{
    DWORD  dwPropItem;

    for (dwPropItem=(DWORD)PropId_Min_Item_Id; dwPropItem < (DWORD)PropId_Max_Item_Id; dwPropItem ++ )
    {
        DWORD  dwOldValue, dwNewValue;

        dwOldValue = _GetPropData((PROP_ITEM_ID)dwPropItem, FALSE);

        // Update the value by forcelly getting it from registry.
        dwNewValue = _GetPropData((PROP_ITEM_ID)dwPropItem, TRUE);
        m_bChanged[dwPropItem] = (dwOldValue != dwNewValue ? TRUE : FALSE);
    }
}

//
//
//
//
ULONG CSpPropItemsServerWrap::_GetMaxAlternates( )
{
    ULONG  ulMaxAlts;

    ulMaxAlts = _GetPropData(PropId_Max_Alternates);

    if ( ulMaxAlts > MAX_ALTERNATES_NUM || ulMaxAlts == 0 )
        ulMaxAlts = MAX_ALTERNATES_NUM;

    return ulMaxAlts;
}


//
// ULONG  CBestPropRange::_GetMaxCandidateChars( )
//
//
ULONG  CSpPropItemsServerWrap::_GetMaxCandidateChars( )
{
    ULONG ulMaxCandChars;

    ulMaxCandChars = _GetPropData(PropId_MaxChar_Cand);

    if ( ulMaxCandChars > MAX_CANDIDATE_CHARS || ulMaxCandChars == 0 )
        ulMaxCandChars = MAX_CANDIDATE_CHARS;

    return ulMaxCandChars;
}

BOOL    CSpPropItemsServerWrap::_AllCmdsEnabled( )
{
    BOOL  fEnable;

    fEnable = _SelectCorrectCmdEnabled( ) &&
              _NavigationCmdEnabled( ) &&
              _CasingCmdEnabled( ) &&
              _EditingCmdEnabled( ) &&
              _KeyboardCmdEnabled( ) &&
              _TTSCmdEnabled( ) &&
              _LanguageBarCmdEnabled( );

    return fEnable;
}


BOOL CSpPropItemsServerWrap::_AllCmdsDisabled( )
{
    BOOL  fDisable;

    fDisable = !_SelectCorrectCmdEnabled( ) &&
               !_NavigationCmdEnabled( ) &&
               !_CasingCmdEnabled( ) &&
               !_EditingCmdEnabled( ) &&
               !_KeyboardCmdEnabled( ) &&
               !_TTSCmdEnabled( ) &&
               !_LanguageBarCmdEnabled( );

    return fDisable;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\recosleep.h ===
// RecoSleep.h : implement "Go to Sleep" and "Wakeup" commands.

#ifndef RECO_SLEEP_H
#define RECO_SLEEP_H

#include "private.h"
#include "sapilayr.h"
#include "sapi.h"

class CSpTask;
class CRecoSleepClass
{
public:

    CRecoSleepClass(CSpTask *pSpTask ); 
    ~CRecoSleepClass( );

    HRESULT InitRecoSleepClass( );
    HRESULT ProcessSleepGrammar( SPPHRASE *pPhrase );

    static void NotifyCallback(WPARAM wParam, LPARAM lParam );

    BOOL   IsInSleep( )  { return  m_fSleeping; }

private:
    
    CSpTask                *m_pSpTask;
    CComPtr<ISpRecognizer>  m_cpRecoEngine;
    CComPtr<ISpRecoContext> m_cpRecoContext;
    CComPtr<ISpRecoGrammar> m_cpSleepGrammar;

    WCHAR                   m_wszRule[MAX_PATH];
    WCHAR                   m_wszSleep[MAX_PATH];
    WCHAR                   m_wszWakeup[MAX_PATH];
    BOOL                    m_fSleeping;

    SPSTATEHANDLE           m_hSleepRule;
    BOOL                    m_Initialized;
};

#endif  // RECO_SLEEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\propstor.cpp ===
//
// property store class implementation
//

// includes
#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "propstor.h"
#include "ids.h"
#include "cicspres.h"
#include "lmlattic.h"

#ifdef DEBUG

#include "wchar.h"

void DebugPrintOut(WCHAR   *pwszStrName, WCHAR  *pwszStr)
{

    WCHAR   wszBuf[80];
    int     iLen, i, j;

    TraceMsg(TF_GENERAL, "the value of %S is", pwszStrName );

    iLen = wcslen(pwszStr);

    j = 0;
    for ( i=0; i<iLen; i++)
    {
        if ( (pwszStr[i] < 0x80) && pwszStr[i] > 0x1f )
        {
            wszBuf[j] = pwszStr[i];
            j ++;
        }
        else
        {
            WCHAR  buf[8];

            StringCchPrintfW(buf, ARRAYSIZE(buf), L" %4X ", (int)pwszStr[i] );

            for ( int x=0; x< (int)wcslen(buf); x++)
            {
                wszBuf[j] = buf[x];
                j++;
            }
        }
    }

    wszBuf[j] = L'\0';

    TraceMsg(TF_GENERAL, "%S", wszBuf);
}
#endif

// ------------------------------------------------------------------------------------------------------------
//  This is a global or standalone function which will be called by CRecoResultWrap and CSapiAlternativeList
//
//  This function receives the phrase text buffer, this element's display text and display attribute, and 
//  previous element's display attribute.
//
//  On Exit, it will update the phrase text buffer to append this element's text, and return the real offset
//  length value for this element.
//
// -------------------------------------------------------------------------------------------------------------

HRESULT   HandlePhraseElement( CSpDynamicString *pDstr, const WCHAR  *pwszTextThis, BYTE  bAttrThis, BYTE bAttrPrev, ULONG  *pulOffsetThis)
{
    HRESULT  hr=S_OK;

    ULONG  ulPrevLen;

    if ( !pDstr || !pwszTextThis )
        return E_INVALIDARG;

    ulPrevLen = pDstr->Length( );

    if ( (ulPrevLen > 0) && (bAttrThis & SPAF_CONSUME_LEADING_SPACES) )
    {
       // This element wants to remove the trailing spaces of the previous element.
        ULONG  ulPrevTrailing = 0;

        if ( bAttrPrev &  SPAF_ONE_TRAILING_SPACE )
            ulPrevTrailing = 1;
        else if ( bAttrPrev & SPAF_TWO_TRAILING_SPACES )
            ulPrevTrailing = 2;

        if ( ulPrevLen >= ulPrevTrailing )
        {
            ulPrevLen = ulPrevLen - ulPrevTrailing;
            pDstr->TrimToSize(ulPrevLen);
        }
    }

    if ( pulOffsetThis )
        *pulOffsetThis = ulPrevLen;
      
    pDstr->Append(pwszTextThis);
          
    if (bAttrThis & SPAF_ONE_TRAILING_SPACE)
    {
        pDstr->Append(L" ");
    }
    else if (bAttrThis & SPAF_TWO_TRAILING_SPACES)
    {
        pDstr->Append(L"  ");
    }
    
    return hr;
}

//
// CRecoResult implementation
//

// ctor

CRecoResultWrap::CRecoResultWrap(CSapiIMX *pimx, ULONG ulStartElement, ULONG ulNumElements, ULONG ulNumOfITN) 
{
    m_cRef = 1;
    m_ulStartElement = ulStartElement;
    m_ulNumElements = ulNumElements;
    
    // ITN is shown by default if the reco result has it
    // the shown status can change after user goes through
    // correction UI
    //

    m_ulNumOfITN = ulNumOfITN;

    m_pimx = pimx;

    m_pulElementOffsets = NULL;
    m_bstrCurrentText   = NULL;   

    m_OffsetDelta = 0;
    m_ulCharsInTrail = 0;
    m_ulTrailSpaceRemoved = 0;
    m_pSerializedRecoResult = NULL;

#ifdef DEBUG
    static DWORD s_dbg_Id = 0;
    m_dbg_dwId = s_dbg_Id++;
#endif // DEBUG
}

CRecoResultWrap::~CRecoResultWrap()  
{
    if (m_pulElementOffsets)
        delete[] m_pulElementOffsets;

    if (m_bstrCurrentText)
        SysFreeString(m_bstrCurrentText);

    if (m_rgITNShowState.Count())
        m_rgITNShowState.Clear();

    if (m_pSerializedRecoResult)
    {
        CoTaskMemFree(m_pSerializedRecoResult);
    }
}

//
// Init function
//
HRESULT CRecoResultWrap::Init(ISpRecoResult *pRecoResult)
{
    // serialize the given reco result and keep the cotaskmem
    if (m_pSerializedRecoResult != NULL)
    {
        CoTaskMemFree(m_pSerializedRecoResult);
    }
    
    Assert(pRecoResult);

    return pRecoResult->Serialize(&m_pSerializedRecoResult);
}

//
// GetResult
//
HRESULT CRecoResultWrap::GetResult(ISpRecoResult **ppResult)
{
    if ( m_pSerializedRecoResult == NULL)
        return E_PENDING;

    // this is a tricky part, we need to access ISpRecoContext
    // and don't want to hold onto it. We get it via CSapiIMX
    // instance which must be always available during session
    //
    Assert(m_pimx);

    CComPtr<ISpRecoContext> cpRecoCtxt;

    //
    // GetFunction ensures SAPI is initialized
    //
    HRESULT hr = m_pimx->GetFunction(GUID_NULL, IID_ISpRecoContext, (IUnknown **)&cpRecoCtxt);
    if (S_OK == hr)
    {
        hr = cpRecoCtxt->DeserializeResult(m_pSerializedRecoResult, ppResult);
    }

    //
    // callar is resposible to release this result object
    //
    return hr;
}

//
// IUnknown
//
STDMETHODIMP CRecoResultWrap::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    Assert(ppvObj);
    
    if (IsEqualIID(riid, IID_IUnknown)
    ||  IsEqualIID(riid, IID_PRIV_RESULTWRAP)
    ||  IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = this;
        hr = S_OK;
        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CRecoResultWrap::AddRef(void)
{
    this->m_cRef++;
    return this->m_cRef;
}

STDMETHODIMP_(ULONG) CRecoResultWrap::Release(void)
{
    this->m_cRef--;
    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;
    return 0;
}

// IServiceProvider
//
STDMETHODIMP CRecoResultWrap::QueryService(REFGUID guidService,  REFIID riid,  void** ppv)
{
    HRESULT hr = S_OK;
    Assert(ppv);
    
    if (!IsEqualIID(guidService, GUID_NULL))
    {
        hr =  E_FAIL;
    }
    
    if (SUCCEEDED(hr))
    {
        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppv = this;
            hr = S_OK;
            this->m_cRef++;
        }
        else if (IsEqualIID(riid, IID_ISpRecoResult))
        {
            CComPtr<ISpRecoResult> cpResult;

            hr = GetResult(&cpResult);
            if (S_OK == hr)
            {
                hr = cpResult->QueryInterface(riid, ppv);
            }
        }
        else
        {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}


//
// Clone this RecoResultWrap object.
//
HRESULT CRecoResultWrap::Clone(CRecoResultWrap **ppRw)
{
    HRESULT                 hr = S_OK;
    CRecoResultWrap         *prw;
    CComPtr<ISpRecoResult>  cpResult;
    ULONG                   iIndex;

    if ( !ppRw ) return E_INVALIDARG;

    *ppRw = NULL;
         
    prw = new CRecoResultWrap(m_pimx, m_ulStartElement, m_ulNumElements, m_ulNumOfITN);
    if ( prw )
    {
        hr = GetResult(&cpResult);

        if (S_OK == hr)
        {
            hr = prw->Init(cpResult);
        }

        if (S_OK == hr)
        {
            prw->SetOffsetDelta(m_OffsetDelta);
            prw->SetCharsInTrail(m_ulCharsInTrail);
            prw->SetTrailSpaceRemoved( m_ulTrailSpaceRemoved );
            prw->m_bstrCurrentText = SysAllocString((WCHAR *)m_bstrCurrentText);

            // Update ITN show-state list .

            if ( m_ulNumOfITN > 0 )
            {
                SPITNSHOWSTATE  *pITNShowState;

                for (iIndex=0; iIndex<m_ulNumOfITN; iIndex ++ )
                {
                    pITNShowState = m_rgITNShowState.GetPtr(iIndex);

                    if ( pITNShowState)
                    {
                        prw->_InitITNShowState(
                                     pITNShowState->fITNShown, 
                                     pITNShowState->ulITNStart, 
                                     pITNShowState->ulITNNumElem);
                    }
                } // for
            } // if

            // Update the Offset list for the second range.

            if (m_pulElementOffsets)
            {
                ULONG  ulOffset;
                ULONG  ulNumOffset;

                ulNumOffset = m_ulStartElement+m_ulNumElements;

                for ( iIndex=0; iIndex <= ulNumOffset; iIndex ++ )
                {
                    ulOffset = m_pulElementOffsets[iIndex];
                    prw->_SetElementNewOffset(iIndex, ulOffset);
                }
            }
        }

        if ( S_OK == hr )
        {
           // Return this prw to the caller.
            *ppRw = prw;
        }
        else 
        {
            // Something wrong when update the data members.
            // Release the newly created object.
            delete prw;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
//   _SpeakAudio()
//
//   synopsis: playback audio based on the elements used in this result object
//
HRESULT CRecoResultWrap::_SpeakAudio(ULONG ulStart, ULONG ulcElem)
{
    HRESULT hr = E_FAIL;
    CComPtr<ISpRecoResult> cpResult;

    hr = GetResult(&cpResult);

    if (S_OK == hr)
    {
        if (ulcElem == 0)
        {
            ulStart = GetStart();
            ulcElem = GetNumElements();
        }
        hr = cpResult->SpeakAudio( ulStart, ulcElem, SPF_ASYNC, NULL);
    }
    return hr;
}

//
//    _SetElementOffset(ULONG  ulElement, ULONG ulNewOffset);
//
//    This function is to update the offset for some element.
//    It is used after property divide or shrink, some element's
//    length is changed ( by removing trailing spaces etc.).
//

HRESULT  CRecoResultWrap::_SetElementNewOffset(ULONG  ulElement, ULONG ulNewOffset)
{
    HRESULT  hr = S_OK;

    
    if ((ulElement > m_ulStartElement + m_ulNumElements) || (ulElement < m_ulStartElement))
    {
        // This ulElement is not a valid element.
        hr = E_INVALIDARG;
        return hr;
    }

    if (!m_pulElementOffsets)
    {
        m_pulElementOffsets = new ULONG[m_ulStartElement+m_ulNumElements+1];
  
        if ( !m_pulElementOffsets )
            return E_OUTOFMEMORY;
        else
           for ( ULONG i=0; i<m_ulStartElement+m_ulNumElements+1; i++ )
                 m_pulElementOffsets[i] = -1;
    }

    m_pulElementOffsets[ulElement] = ulNewOffset;

    return hr;
}


//
//    _GetElementOffsetCch
//
//    synopsis: returns the start cch of the given SPPHRASEELEMENT
//
ULONG   CRecoResultWrap::_GetElementOffsetCch(ULONG ulElement)
{
    ULONG ulOffset = 0;
    
    if (ulElement > m_ulStartElement + m_ulNumElements)
    {
         Assert(m_ulNumElements > 0);
         ulElement = m_ulStartElement + m_ulNumElements;
    }
    else if (ulElement < m_ulStartElement)
    {
        ulElement = m_ulStartElement;
    }
    
    if (!m_pulElementOffsets)
    {
        _SetElementOffsetCch(NULL);
    }

    // m_pulElement could be null at memory stressed situation
    if ( m_pulElementOffsets )
    {
        ulOffset = m_pulElementOffsets[ulElement];
    }

    return ulOffset;
}

//
//    _SetElementOffsetCch
//
//    synopsis:  
//
//
//  Before this function is called, we have to make sure that all the internal ITN show-state list 
//  has already been updated for the current phrase.
//
//  So here we just relay on the correct ITN information to get the right real text string for 
//  current phrase and the offsets of all elemenets in this phrase.

void   CRecoResultWrap::_SetElementOffsetCch(ISpPhraseAlt *pAlt)
{
    if (m_pulElementOffsets)
    {
        delete[] m_pulElementOffsets;

        m_pulElementOffsets = NULL;
    }
        
    SPPHRASE *pPhrase = NULL;
    HRESULT  hr       = S_OK;

    CComPtr<ISpPhrase> cpPhrase;

    if (pAlt)
    {
       cpPhrase = pAlt;
    }
    else
    {
        CComPtr<ISpRecoResult> cpResult;
        hr = GetResult(&cpResult);

        //
        // we're called for initialization, use current parent pharse object
        //
        cpPhrase = cpResult;
    }

    if (S_OK == hr)
    {
        _UpdateInternalText(cpPhrase);
        
        hr = cpPhrase->GetPhrase(&pPhrase);
    }

    ULONG cElements = 0;
    if (S_OK == hr && pPhrase)
    {
        cElements = pPhrase->Rule.ulCountOfElements;

        // the last colmun (+1) shows offset for the end of the last element

        if ( m_pulElementOffsets )
            delete[] m_pulElementOffsets;

        m_pulElementOffsets = new ULONG[cElements+1]; 
    
        if (cElements > 0 && m_pulElementOffsets)
        {
            CSpDynamicString dstr;
            CSpDynamicString dstrReplace;
        
             
            for (ULONG i = 0; i < cElements; i++ )
            {
                BOOL      fInsideITN;
                ULONG     ulITNStart, ulITNNumElem;
                
                fInsideITN = _CheckITNForElement(pPhrase, i, &ulITNStart, &ulITNNumElem, (CSpDynamicString *)&dstrReplace);

                if ( fInsideITN )
                {
                    m_pulElementOffsets[i] = dstr.Length();

                    // This element is inside an ITN range.
                    if ( i == (ulITNStart + ulITNNumElem - 1) )
                    {
                        // This is the last element of the new ITN.
                        // we need to add the replace text to the dstr string 
                        // so that next non-ITN element will get correct offset.

                        dstr.Append( (WCHAR *)dstrReplace );
                    }
                }
                else
                {
                    if (pPhrase->pElements[i].pszDisplayText)
                    {
                        // get cch up to this element. 
                        // the offset is 0 for elem 0
                        //
                        const WCHAR   *pwszTextThis;
                        BYTE           bAttrThis = 0;
                        BYTE           bAttrPrev = 0;
                        ULONG          ulOffset = 0;

                        pwszTextThis = pPhrase->pElements[i].pszDisplayText;
                        bAttrThis = pPhrase->pElements[i].bDisplayAttributes;

                        if ( i > 0 )
                            bAttrPrev = pPhrase->pElements[i-1].bDisplayAttributes;

                        HandlePhraseElement( (CSpDynamicString *)&dstr, pwszTextThis, bAttrThis, bAttrPrev,&ulOffset);
                        m_pulElementOffsets[i] = ulOffset;
                    }
                }
            } // for 
            
            // store the last columun
            m_pulElementOffsets[cElements] = dstr.Length() - m_ulTrailSpaceRemoved;

        } // if m_pulElementOffsets
    }
    
    if (pPhrase)
        ::CoTaskMemFree(pPhrase);
}

//
// _UpdateInternalText()
//
// synopsis: this function updates the internal bstr that covers
//           parent phrase wrapped by our own result object, based on 
//           the given phrase object and our internal pointer to
//           the starting element and # of element
//
// perf after beta1: consolidate this with _SetElementOffsetCch()
//
//
void CRecoResultWrap::_UpdateInternalText(ISpPhrase *pSpPhrase)
{
    CSpDynamicString dstrReplace;
    CSpDynamicString dstr;
    CSpDynamicString dstrDelta, dstrTrail;
    ULONG            ulLenCurText = 0;

    if ( m_bstrCurrentText )
    {
        ulLenCurText = wcslen(m_bstrCurrentText);

        if ( m_OffsetDelta > 0 &&  m_OffsetDelta <= ulLenCurText )
        {
            dstrDelta.Append(m_bstrCurrentText, m_OffsetDelta);
        }

        if ( m_ulCharsInTrail > 0  && m_ulCharsInTrail <= ulLenCurText )
        {
            WCHAR   *pwszTrail;

            pwszTrail = m_bstrCurrentText + ulLenCurText - m_ulCharsInTrail ;
            dstrTrail.Append(pwszTrail, m_ulCharsInTrail);
        }
    }
    else
    {
        // m_bstrCurrentText doesn't exist, but m_OffsetDelta or m_ulCharsInTrail
        // is not 0, sounds it is not a possible case.

        // But for safety sake, we just still keep the same number of spaces.

        if ( m_OffsetDelta > 0 )
        {
           for (ULONG i=0; i<m_OffsetDelta; i++)
               dstrDelta.Append(L" ");
        }

        if ( m_ulCharsInTrail > 0 )
        {
           for (ULONG i=0; i<m_ulCharsInTrail; i++)
               dstrTrail.Append(L" ");
        }
    }

    if ( m_ulNumElements == 0 )
    {
        // There is no valid element in this range.
        //
        // Just keep the delta string and Trailing string if they are existing.

        if ( m_OffsetDelta > 0 )
            dstr.Append( (WCHAR *)dstrDelta );

        if ( m_ulCharsInTrail > 0)
            dstr.Append((WCHAR *)dstrTrail);

        if ( m_bstrCurrentText )
            SysFreeString(m_bstrCurrentText);

        m_bstrCurrentText = SysAllocString((WCHAR *)dstr);

        return;
    }
    

    if ( pSpPhrase == NULL )
        return;

    // We cannot call pPhrase->GetText( ) to get the real phrase text, because GetText(  ) 
    // assumes all the ITN range have the same show-state, ( ITN or NON_ITN).
    // But there are some cases like some ITN shown as ITN, some other ITN ranges shown as normal 
    // text after user selects a candidate.
    // 

    // When the reco wrapper is first generated right after the text is recognized by SR engine,
    // we can call GetText(  ) to get the real text of the phrase.
    //
    // After that, user may change it by selecting alternative text.
    
    dstr.Clear( );

    if(m_OffsetDelta > 0)
    {
        // There are some characters which are not part of any elements in the range begining.
        // we need to keep these characters.

        dstr.Append((WCHAR *)dstrDelta);
    }
     
    if (m_bstrCurrentText) 
    {
       SysFreeString(m_bstrCurrentText);
       m_bstrCurrentText = NULL;
    }

    SPPHRASE *pPhrase = NULL;

    pSpPhrase->GetPhrase(&pPhrase);

    for (ULONG i = m_ulStartElement; i < m_ulStartElement + m_ulNumElements; i++ )
    {
        BOOL      fInsideITN;
        ULONG     ulITNStart, ulITNNumElem;
                
        fInsideITN = _CheckITNForElement(pPhrase, i, &ulITNStart, &ulITNNumElem, (CSpDynamicString *)&dstrReplace);

        if ( fInsideITN )
        {
            // This element is inside an ITN range.
            if ( i == (ulITNStart + ulITNNumElem - 1) )
            {
                // This is the last element of the new ITN.
                // we need to add the replace text to the dstr string 
                // so that next non-ITN element will get correct offset.

                dstr.Append( (WCHAR *)dstrReplace );
            }
        }
        else
        {
            if (pPhrase->pElements[i].pszDisplayText)
            {
                const WCHAR   *pwszTextThis;
                BYTE           bAttrThis = 0;
                BYTE           bAttrPrev = 0;

                pwszTextThis = pPhrase->pElements[i].pszDisplayText;
                bAttrThis = pPhrase->pElements[i].bDisplayAttributes;

                if ( i > m_ulStartElement )
                    bAttrPrev = pPhrase->pElements[i-1].bDisplayAttributes;

                HandlePhraseElement( (CSpDynamicString *)&dstr, pwszTextThis, bAttrThis, bAttrPrev,NULL);
            }
        }
    } // for 
            
    if ( m_ulCharsInTrail > 0)
        dstr.Append((WCHAR *)dstrTrail);

    // If there were some trail spaces removed, we also need to remove the same number of spaces when
    // we try to get the new phrase text.

    if ( m_ulTrailSpaceRemoved > 0 )
    {
        ULONG   ulNewRemoved = 0;
        WCHAR   *pwszNewText = (WCHAR *)dstr;

        ulLenCurText = wcslen(pwszNewText);
        
        for (ULONG i=ulLenCurText-1; ((long)i>0) && (ulNewRemoved <= m_ulTrailSpaceRemoved); i-- )
        {
            if ( pwszNewText[i] == L' ' )
            {
                pwszNewText[i] = L'\0';
                ulNewRemoved ++;
            }
            else
                break;
        }

        m_ulTrailSpaceRemoved = ulNewRemoved;
    }

    // store the last columun
    m_bstrCurrentText = SysAllocString((WCHAR *)dstr);

    if ( pPhrase )
        ::CoTaskMemFree(pPhrase);
        
}

BOOL CRecoResultWrap::_CanIgnoreChange(ULONG ich, WCHAR *pszChange, int cch)
{
    // see if the given text is within tolerable range
    
    BOOL bret = FALSE;
    WCHAR *pszCurrentText = NULL;
    
    // set up an offset to the current face text
    if (m_bstrCurrentText)
    {
        if (ich < SysStringLen(m_bstrCurrentText))
        {
            pszCurrentText = m_bstrCurrentText;
            pszCurrentText += ich;
        }
    }
    // 1) compare it ignoring the case
    if (pszCurrentText)
    {
        int i = _wcsnicmp(pszCurrentText, pszChange, cch);
        if (i == 0)
        {
           bret = TRUE;
        }
    }
    return bret;
}

//------------------------------------------------------------------------------------------//
//
//  CRecoResultWrap::_RangeHasITN
//
//  Determine if the partial of phrase between ulStart Element and ulStart+ulcElement -1 
//  has ITN.
//
//  return the ITN number,  or 0 if there is no ITN.
//
//------------------------------------------------------------------------------------------//

ULONG  CRecoResultWrap::_RangeHasITN(ULONG  ulStartElement, ULONG  ulNumElements)
{
    ULONG   ulNumOfITN = 0;
    CComPtr<ISpRecoResult> cpResult;
    HRESULT  hr;

    hr = GetResult(&cpResult);

    // determine whether this partial result has an ITN
    SPPHRASE *pPhrase;
    if (S_OK == hr)
        hr = cpResult->GetPhrase(&pPhrase);

    if (S_OK == hr)
    {
        const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
        for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
        {
            // review: we need to verify if this is really a correct way to determine
            // whether the ITN fits in the partial result
            //
            if (pRep->ulFirstElement >= ulStartElement
                && (pRep->ulFirstElement + pRep->ulCountOfElements) <= (ulStartElement + ulNumElements))
            {
                ulNumOfITN ++;
            }
            pRep++;
        }
        ::CoTaskMemFree(pPhrase);
    }

    return ulNumOfITN;
}

// -----------------------------------------------------------------------------------------
//  CRecoResultWrap::_InitITNShowState
//
//  It will initialize show-state for the given ITN  or all the ITNs in this recowrap.
//
//  Normally this function will be called after the reco wrapper is genertaed.
//
//  When the reco wrap is first generated after a text is recognized by SR engine, all the 
//  ITNs in this reco wrap have the same showstate, it is convinent to set the show state
//  for all the ITNs at one time. in this case, caller could just set both ulITNStart and 
//  ulITNNumElements as 0.
//
//  When the new reco wrap is generated by property divide, shrink or deserialized from
//  IStream, or after an alternative text is selected from candidate window, we cannot 
//  assume all the ITNs in the reco wrapper have the same show state. In this case, 
//  caller can initialize the show state one ITN by one ITN, it can set ulITNStart and 
//  ulITNNumElements to identify this ITN.
//
// ------------------------------------------------------------------------------------------

HRESULT  CRecoResultWrap::_InitITNShowState(BOOL  fITNShown, ULONG ulITNStart, ULONG ulITNNumElements )
{

    HRESULT   hr = S_OK;
    ULONG     ulNumOfITN = 0;
    SPPHRASE *pPhrase;

    TraceMsg(TF_GENERAL, "CRecoResultWrap::_InitITNShowState is called");

    if ( m_ulNumOfITN == 0 ) 
    {
        // There is no ITN in this reco wrapper, just return here.
        TraceMsg(TF_GENERAL, "There is no ITN");
        return hr;
    }

    // The list of SPITNSHOWSTATE is already generated, we just need to set the value for 
    // every structure member.

    if ( (ulITNStart == 0 ) && (ulITNNumElements == 0 ) )
    {
        // All the ITNs in this Reco wrapper have the same show status.
        // we will calculate the every ITN start and end elements based 
        // on current reco result phrase.

        // We want to alloc the structure list.

        if ( m_rgITNShowState.Count( ) )
            m_rgITNShowState.Clear( );

        m_rgITNShowState.Append(m_ulNumOfITN);


        CComPtr<ISpRecoResult> cpResult;

        hr = GetResult(&cpResult);
        if (S_OK == hr)
        {
            hr = cpResult->GetPhrase(&pPhrase);
        }

        if (S_OK == hr)
        {
            const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
            for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
            {
                if (pRep->ulFirstElement >= m_ulStartElement
                    && (pRep->ulFirstElement + pRep->ulCountOfElements) <= (m_ulStartElement + m_ulNumElements))
                {
                    // Get an ITN

                    SPITNSHOWSTATE  *pITNShowState;

                    if ( pITNShowState = m_rgITNShowState.GetPtr(ulNumOfITN))
                    {
                        pITNShowState->ulITNStart = pRep->ulFirstElement;
                        pITNShowState->ulITNNumElem = pRep->ulCountOfElements;
                        pITNShowState->fITNShown = fITNShown;
                    }

                    ulNumOfITN ++;

                    if ( ulNumOfITN > m_ulNumOfITN )
                    {
                        // Something wrong, return here to avoid AV
                        break;
                    }
                }
                pRep++;
            }
            ::CoTaskMemFree(pPhrase);
        }
    }
    else
    {
        // Set the display status for given ITN.
        // Check to see if this is a valid ITN.
        if ( ulITNNumElements > 0 )
        {
            ULONG   ulIndex = 0;
            SPITNSHOWSTATE  *pITNShowState = NULL;

            ulIndex = m_rgITNShowState.Count( );

            m_rgITNShowState.Append(1);

            if ( pITNShowState = m_rgITNShowState.GetPtr(ulIndex))
            {
                pITNShowState->ulITNStart = ulITNStart;
                pITNShowState->ulITNNumElem = ulITNNumElements;
                pITNShowState->fITNShown = fITNShown;
            }
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------------------
//  CRecoResultWrap::_InvertITNShowStateForRange
//
//  Invert the show state for all the ITNs in the give range ( ulStartElement, to ulNumElements)
//
//  
// --------------------------------------------------------------------------------------------

HRESULT  CRecoResultWrap::_InvertITNShowStateForRange( ULONG  ulStartElement,  ULONG ulNumElements )
{
    HRESULT  hr = S_OK;

    TraceMsg(TF_GENERAL,"CRecoResultWrap::_InvertITNShowStateForRange is called, ulStartElement=%d ulNumElements=%d", ulStartElement,ulNumElements); 
    if ( m_ulNumOfITN > 0  && ulNumElements > 0 )
    {
        //
        // check to see if there is any ITN inside the given range.
        //
        ULONG   ulIndex = 0;

        for ( ulIndex=0; ulIndex < m_ulNumOfITN; ulIndex ++ )
        {
            SPITNSHOWSTATE  *pITNShowState;
            if ( pITNShowState = m_rgITNShowState.GetPtr(ulIndex))
            {
                if ((pITNShowState->ulITNStart >= ulStartElement) && 
                    (pITNShowState->ulITNStart + pITNShowState->ulITNNumElem <= ulStartElement + ulNumElements))
                {
                    // This ITN is inside the given range, just invert the show state.
                    pITNShowState->fITNShown = !pITNShowState->fITNShown;
                }
            }
        }
    }

    return hr;
}


// --------------------------------------------------------------------------------------------------
//
//  CRecoResultWrap::_UpdateStateWithAltPhrase
//
//  When an Alt phrase is going to used to replace current parent phrase, this method function
//  will update related memeber data, like m_ulNumOfITN, m_ulNumElements, ITN show state list.
//
// ---------------------------------------------------------------------------------------------------

HRESULT  CRecoResultWrap::_UpdateStateWithAltPhrase( ISpPhraseAlt  *pSpPhraseAlt )
{

    // This code is moved from UpdateInternalText( ).
    // This part code in UpdateInternalText( ) is used only by SetResult( ) when select an alternative from
    // candidate list.
    HRESULT hr = S_OK;
    ULONG ulParentStart;
    ULONG cElements;
    ULONG cElementsInParent;

    CComPtr<ISpPhraseAlt> cpAlt;

    TraceMsg(TF_GENERAL,"CRecoResultWrap::_UpdateStateWithAltPhrase is called");

    if ( pSpPhraseAlt == NULL )
        return E_INVALIDARG;

    cpAlt=pSpPhraseAlt;

    hr = cpAlt->GetAltInfo(NULL, &ulParentStart, &cElementsInParent, &cElements);

    if (S_OK == hr)
    {

        SPITNSHOWSTATE  *pOrgITNShowState = NULL;

        // case:  there is ITN number change.
        //    
        //        there is element number change.

        Assert(ulParentStart >= m_ulStartElement);
        Assert(ulParentStart+cElementsInParent <= m_ulStartElement+m_ulNumElements);

        TraceMsg(TF_GENERAL, "Original Num of ITNs =%d", m_ulNumOfITN);

        if ( cElements != cElementsInParent )
        {
            // There is element number change.
            // we need to update the start position for all the ITNs which are not in the selection range.

            for ( ULONG uIndex=0; uIndex < m_ulNumOfITN; uIndex ++)
            {
                SPITNSHOWSTATE *pITNShowState;

                pITNShowState = m_rgITNShowState.GetPtr(uIndex);

                if ( pITNShowState && pITNShowState->ulITNStart >= (ulParentStart + cElementsInParent) )
                {
                    long  newStart;

                    newStart = (long)pITNShowState->ulITNStart + (long)(cElements - cElementsInParent);

                    pITNShowState->ulITNStart = (ULONG)newStart;
                }
            }

            // set the new element number to reco wrapper.

            long lNewNumElements = (long)m_ulNumElements + (long)(cElements - cElementsInParent);
            m_ulNumElements = (ULONG)lNewNumElements;

        }

        if ( m_ulNumOfITN > 0 )
        {
            pOrgITNShowState = (SPITNSHOWSTATE  *) cicMemAllocClear( m_ulNumOfITN * sizeof(SPITNSHOWSTATE) );

            if ( pOrgITNShowState )
            {
                for (ULONG  i=0; i< m_ulNumOfITN; i++ )
                {
                    SPITNSHOWSTATE *pITNShowState;

                    pITNShowState = m_rgITNShowState.GetPtr(i);
                    
                    pOrgITNShowState[i].ulITNStart = pITNShowState->ulITNStart;
                    pOrgITNShowState[i].ulITNNumElem = pITNShowState->ulITNNumElem;
                    pOrgITNShowState[i].fITNShown = pITNShowState->fITNShown;
                }
            }
            else
                hr = E_OUTOFMEMORY;
                    
        }

        if ( m_rgITNShowState.Count( ) )
            m_rgITNShowState.Clear( );

        // Generate a new ITN list for new phrase.
        if ( hr == S_OK )
        {
            SPPHRASE *pPhrase;
            hr = cpAlt->GetPhrase(&pPhrase);

            if (S_OK == hr)
            {
                const SPPHRASEREPLACEMENT *pRep = pPhrase->pReplacements;
                ULONG ulNumOfITN = 0;

                for (ULONG ul = 0; ul < pPhrase->cReplacements; ul++)
                {
                    ULONG ulITNStart, ulITNNumElem;
                    BOOL  fITNShown = FALSE;

                    ulITNStart = pRep->ulFirstElement;
                    ulITNNumElem = pRep->ulCountOfElements;

                    if ( (ulITNStart >= m_ulStartElement)
                        && ((ulITNStart + ulITNNumElem) <= (m_ulStartElement + m_ulNumElements)) )
                    {
                        // Get an ITN
                        SPITNSHOWSTATE  *pITNShowState;

                        m_rgITNShowState.Append(1);

                        pITNShowState = m_rgITNShowState.GetPtr(ulNumOfITN);

                        if ( pITNShowState) 
                        {

                            // If this ITN is inside the selection range, it show state will be set as TRUE. ITN.
                            // Other it will keep the same show state as orgITNShowState.

                            if ( (ulITNStart >= ulParentStart) &&
                                 ((ulITNStart+ulITNNumElem) <= (ulParentStart + cElements)) )
                            {
                                // This ITN is inside the selection range.
                                 fITNShown = TRUE;
                            }
                            else
                            {
                                // Get the original show state from orgITNShowState
                                for ( ULONG j=0; j<m_ulNumOfITN; j ++ )
                                {
                                    if ( (pOrgITNShowState[j].ulITNStart == ulITNStart) && 
                                         (pOrgITNShowState[j].ulITNNumElem == ulITNNumElem ) )
                                    {
                                         fITNShown = pOrgITNShowState[j].fITNShown;
                                         break;
                                    }
                                }
                            }

                            pITNShowState->ulITNNumElem = ulITNNumElem;
                            pITNShowState->ulITNStart = ulITNStart;
                            pITNShowState->fITNShown = fITNShown; 
                        }

                        ulNumOfITN ++;
                    }

                    pRep ++;
                }

                m_ulNumOfITN = ulNumOfITN;

                TraceMsg(TF_GENERAL, "New Num of ITNs =%d", m_ulNumOfITN);

                ::CoTaskMemFree(pPhrase);

            }
        }

        if ( pOrgITNShowState )
            cicMemFree(pOrgITNShowState);
    }

    return hr;
}

//------------------------------------------------------------------------------------------//
//
//  CRecoResultWrap::_GetElementDispAttribute
//
//  Return the display attribute for the given element, if it is inside of an ITN, and the ITN
//  is showing, return the replacement text's attribute.
//  
//------------------------------------------------------------------------------------------//
BYTE    CRecoResultWrap::_GetElementDispAttribute(ULONG  ulElement)
{
    SPPHRASE                *pPhrase = NULL;
    BYTE                    bAttr = 0;
    CComPtr<ISpRecoResult>  cpResult;
    HRESULT                 hr;

    hr = GetResult(&cpResult);
    if (hr == S_OK)
        hr = cpResult->GetPhrase(&pPhrase);

    if ( hr == S_OK && pPhrase)
    {
        BOOL        fInsideITN;
        ULONG       ulITNStart, ulITNNumElem;

        fInsideITN = _CheckITNForElement(NULL, ulElement, &ulITNStart, &ulITNNumElem, NULL);

        if ( !fInsideITN )
            bAttr = pPhrase->pElements[ulElement].bDisplayAttributes;
        else
        {
            const SPPHRASEREPLACEMENT  *pPhrReplace;
            pPhrReplace = pPhrase->pReplacements;

            if ( pPhrReplace )
            {
                for ( ULONG i=0; i<pPhrase->cReplacements; i++)
                {
                    if ( (ulITNStart == pPhrReplace[i].ulFirstElement) 
                         && (ulITNNumElem == pPhrReplace[i].ulCountOfElements) )
                    {
                        bAttr = pPhrReplace[i].bDisplayAttributes;
                        break;
                    }
                }
            }
        }
    }

    if ( pPhrase )
        ::CoTaskMemFree(pPhrase);

    return bAttr;
}


//------------------------------------------------------------------------------------------//
//
//  CRecoResultWrap::_CheckITNForElement
//
//  Determine if the specifed element is inside of an ITN range in the phrase. 
//  If it is, the return value would be TRUE, and pulStartElement, pulEndElement will be 
//  set as the real start element and num of elements of the ITN range, dstrReplace will hold 
//  the replace text string.
//
//  If the element is not inside an ITN range, return value would be FALSE, all other out 
//  parameters will not be set.
//  
//------------------------------------------------------------------------------------------//

BOOL  CRecoResultWrap::_CheckITNForElement(SPPHRASE *pPhrase, ULONG ulElement, ULONG *pulITNStart, ULONG *pulITNNumElem, CSpDynamicString *pdstrReplace)
{
    BOOL        fInsideITN = FALSE;
    SPPHRASE   *pMyPhrase;

    pMyPhrase = pPhrase;

    if ( pMyPhrase == NULL )
    {
        CComPtr<ISpRecoResult> cpResult;

        HRESULT hr = GetResult(&cpResult);

        if (S_OK == hr)
        {
            hr = cpResult->GetPhrase(&pMyPhrase);
        }

        if (S_OK != hr)
            return fInsideITN;
    }

    if ( m_ulNumOfITN )
    {
        // Check to see if this element is inside an ITN range.
        ULONG  ulITNStart;
        ULONG  ulITNNumElem;

        for ( ULONG iIndex=0; iIndex<m_ulNumOfITN; iIndex++ )
        {
            SPITNSHOWSTATE  *pITNShowState;
            if ( pITNShowState = m_rgITNShowState.GetPtr(iIndex))
            {
                ulITNStart = pITNShowState->ulITNStart;
                ulITNNumElem = pITNShowState->ulITNNumElem;

                if ( (ulElement >= ulITNStart) && ( ulElement < ulITNStart + ulITNNumElem) )
                {
                    // found this ITN in our internal ITN show state list.
                     fInsideITN = pITNShowState->fITNShown; 
                    break;
                }
            }
        }

        if ( fInsideITN )
        {
            if ( pulITNStart )
                *pulITNStart = ulITNStart;

            if ( pulITNNumElem )
                *pulITNNumElem = ulITNNumElem;

            if ( pdstrReplace )
            {
                const SPPHRASEREPLACEMENT  *pPhrReplace;
                pPhrReplace = pMyPhrase->pReplacements;

                for ( ULONG j=0; j<pMyPhrase->cReplacements; j++)
                {
            
                    if ( (ulITNStart == pPhrReplace[j].ulFirstElement) 
                         && (ulITNNumElem == pPhrReplace[j].ulCountOfElements) )
                    {

                        pdstrReplace->Clear( );
                        pdstrReplace->Append(pPhrReplace[j].pszReplacementText);

                        if (pPhrReplace[j].bDisplayAttributes & SPAF_ONE_TRAILING_SPACE)
                            pdstrReplace->Append(L" ");
                        else if (pPhrReplace[j].bDisplayAttributes & SPAF_TWO_TRAILING_SPACES)
                            pdstrReplace->Append(L"  ");

                        break;
                    }
                }
                
            }
        }
    }

    if ( !pPhrase && pMyPhrase )
        ::CoTaskMemFree(pMyPhrase);

    return fInsideITN;
}


//
// CPropStoreRecoResultObject implementation
//

// ctor

CPropStoreRecoResultObject::CPropStoreRecoResultObject(CSapiIMX *pimx, ITfRange *pRange)
{
    m_cpResultWrap   = NULL;

    if ( pRange )
       pRange->Clone(&m_cpRange);  //  Use a clone range to keep the original Range.
                                   //  It would be useful to handle property shrink and divide.
    else
       m_cpRange = pRange;
    
    m_pimx = pimx;

    m_cRef  = 1;
}

// dtor
CPropStoreRecoResultObject::~CPropStoreRecoResultObject()
{
}


// IUnknown
STDMETHODIMP CPropStoreRecoResultObject::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;

    Assert(ppvObj);

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = this;
        hr = S_OK;

        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CPropStoreRecoResultObject::AddRef(void)
{
    this->m_cRef++;

    return this->m_cRef;
}

STDMETHODIMP_(ULONG) CPropStoreRecoResultObject::Release(void)
{
    this->m_cRef--;

    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;

    return 0;
}

// ITfPropertyStore

STDMETHODIMP CPropStoreRecoResultObject::GetType(GUID *pguid)
{
    HRESULT hr = E_INVALIDARG;
    if (pguid)
    {
        *pguid = GUID_PROP_SAPIRESULTOBJECT;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::GetDataType(DWORD *pdwReserved)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwReserved)
    {
        *pdwReserved = 0;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::GetData(VARIANT *pvarValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pvarValue)
    {
        QuickVariantInit(pvarValue);

        if (m_cpResultWrap)
        {
            IUnknown *pUnk;

            hr = m_cpResultWrap->QueryInterface(IID_IUnknown, (void**)&pUnk);
            if (SUCCEEDED(hr))
            {
                pvarValue->vt = VT_UNKNOWN;
                pvarValue->punkVal = pUnk;
                hr = S_OK;
            }
        }
    }

    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    HRESULT hr = S_OK;
    *pfAccept = FALSE;

    Assert(pRange);

    if (m_pimx->_AcceptRecoResultTextUpdates())
    {
        *pfAccept = TRUE;
    }
    else
    {
        CComPtr<ITfContext> cpic;
        hr = pRange->GetContext(&cpic);

        if (SUCCEEDED(hr) && cpic)
        {
            CPSRecoEditSession *pes;
            if (pes = new CPSRecoEditSession(this, pRange, cpic))
            {
                pes->_SetEditSessionData(ESCB_PROP_TEXTUPDATE, NULL, 0, (LONG_PTR)dwFlags);
                cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

                if ( SUCCEEDED(hr) )
                    *pfAccept = (BOOL)pes->_GetRetData( );

                pes->Release();
            }
        }
    
    }
    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::Shrink(ITfRange *pRange, BOOL *pfFree)
{

    HRESULT     hr = S_OK;

    if (m_pimx->_MasterLMEnabled())
    {
        return S_FALSE; // temporary solution to avoid nested editsessions
    }
    else
    {
        // Shrink this property store to reflect to the new doc Range  (pRange).

        // If the new range contains more than one element of recognized phrase,
        // we just update the property store and keep this property store.  
        //  *pfFree is set FALSE on exit.

        // If the new range cannot contain even one complete element of recognized phrase,
        // we just want to discard this property store, let Cicero engine to release this
        // property store.
        // *pfFree is set TRUE on exit.

        Assert(pRange);
        Assert(pfFree);

        if ( !pRange || !pfFree )
        {
            return E_INVALIDARG;
        }

        CComPtr<ITfContext> cpic;
        hr = pRange->GetContext(&cpic);

        if (SUCCEEDED(hr) && cpic)
        {
            CPSRecoEditSession *pes;
            if (pes = new CPSRecoEditSession(this, pRange, cpic))
            {
                pes->_SetEditSessionData(ESCB_PROP_SHRINK, NULL, 0);
                cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

                if ( SUCCEEDED(hr) )
                    *pfFree = (BOOL)pes->_GetRetData( );

                pes->Release();
            }
        }
        return hr;
    }
}

STDMETHODIMP CPropStoreRecoResultObject::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{

    if (m_pimx->_MasterLMEnabled())
    {
        return S_FALSE; // temporary solution to avoid nested editsessions
    }
    else
    {
        // 12/17/1999
        // [dividing a range implementation strategy]
        //
        // - pRangeThis contains the text range *before* the dividing point
        // - pRangeNew contrains the range *after* the dividing point
        // - First, adjust this property store to correctly hold a start element and #of element
        //   for pRangeThis
        // - then create a new property store for pRangeNew, which will share the same 
        //   result blob. 
        //
    
        // just an experiment to see if cutting the range works.
        // *ppPropStore = NULL;
        Assert(ppPropStore);
        Assert(pRangeThis);
        Assert(pRangeNew);

        CComPtr<ITfContext> cpic;
        HRESULT hr = pRangeThis->GetContext(&cpic);

        if (SUCCEEDED(hr) && cpic)
        {
            CPSRecoEditSession *pes;
            if (pes = new CPSRecoEditSession(this, pRangeThis, cpic))
            {
                pes->_SetUnk((IUnknown *)pRangeNew);
                pes->_SetEditSessionData(ESCB_PROP_DIVIDE, NULL, 0);
                cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

                if ( SUCCEEDED(hr) )
                    *ppPropStore = (ITfPropertyStore *)pes->_GetRetUnknown( );

                pes->Release();
            }
        }
        return hr;
    }
}

//
// CPropStoreRecoResultObject::_OnTextUpdated
//
// the text has been modified in the document, this function just wants to determine
// if the property needs to change also.
// if pfAccept returns TRUE, means the property keep unchanged. ( propbaly it is capitalizing).
// if pfAccept returns FALSE, means the property needs to be changed to map to the new text ranges.
//
// consequently, property dividing or shrinking will be taken by cicero engine.
//
HRESULT CPropStoreRecoResultObject::_OnTextUpdated(TfEditCookie ec, DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    // if the change is only about capitalizing we'll ignore the changes

    Assert(pRange);
    Assert(pfAccept);

    long cch;
    ULONG ichUpdate = 0;
    TF_HALTCOND hc;
    CComPtr<ITfRange> cpRangeTemp;
    CComPtr<ITfRange> cpPropRangeTemp;
    CRecoResultWrap   *pResultWrap;

    BOOL *pfKeepProp = pfAccept;
    BOOL fCorrection = (dwFlags & TF_TU_CORRECTION);

    *pfKeepProp = FALSE;

    HRESULT hr = S_OK;

    pResultWrap = (CRecoResultWrap *)(void *)m_cpResultWrap;

    // if there's no current text don't try to save the prop
    if (pResultWrap->m_bstrCurrentText == NULL)
        return hr;

    // did the run change size?  we won't accept the change if
    // the run changed size
    if (m_cpRange->Clone(&cpPropRangeTemp) != S_OK)
    {
        hr = E_FAIL;
        return hr;
    }

    hc.pHaltRange = cpPropRangeTemp;
    hc.aHaltPos = TF_ANCHOR_END;
    hc.dwFlags = 0;

    if (cpPropRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc) != S_OK)
    {
        hr = E_FAIL;
        return hr;
    }

    if ((ULONG)cch != wcslen(pResultWrap->m_bstrCurrentText))
        return hr;

    // text has not changed size

    // correction?
    if (fCorrection)
    {
        *pfKeepProp = TRUE;
        return hr;
    }

    // everything from here below is about
    // checking for a case change only

    // calculate the offset of update
    cpPropRangeTemp.Release( );
    hr = m_cpRange->Clone(&cpPropRangeTemp);
    if (S_OK == hr)
    {
        hc.pHaltRange = pRange;
        hc.aHaltPos = TF_ANCHOR_START;
        hc.dwFlags = 0;
        hr = cpPropRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc);
        ichUpdate = cch;
    }

    // calculate cch of the update 
    if (S_OK == hr)
    {
        hr = pRange->Clone(&cpRangeTemp);
    }
    
    if (S_OK == hr)
    {
        WCHAR *psz;

        hc.pHaltRange = pRange;
        hc.aHaltPos = TF_ANCHOR_END;
        hc.dwFlags = 0;
        cpRangeTemp->ShiftStart(ec, LONG_MAX, &cch, &hc);
        psz = new WCHAR[cch+1];

        if (psz)
        {
            if ( S_OK == pRange->GetText(ec, 0, psz, cch, (ULONG *)&cch))
            {
                *pfKeepProp = pResultWrap->_CanIgnoreChange(ichUpdate, psz, cch);
            }
            delete[] psz;
        }
    } 

    return hr;
}

//
// CPropStoreRecoResultObject::_Divide
//
// synopsis : receives edit cookie from edit session
//            so that we can manipulate with ranges
//            to set starting elements/# of elements
//
//
HRESULT CPropStoreRecoResultObject::_Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs) 
{
    HRESULT                     hr = S_OK;
    CRecoResultWrap            *cpResultWrap;

    long                        cchFirst = 0;   // the number of characters in the first range.
    long                        cchSecond = 0;  // the number of characters in the Second range.
    long                        cchSecondStart; // Offset of first char in the second range.
                                                // it starts from the original range's start-point.
    long                        cchOrgLen;      // Number of characters in original text string.

    int                         iElementOffsetChanged = 0;  // If the end point of the first range
                                                            // is exactly in the last space char of 
                                                            // one element, the new offset range for
                                                            // this element in the first range needs 
                                                            // to be updated.

    WCHAR                       *psz=NULL;
    ULONG                       iElement;
    ULONG                       ulStartElement, ulNumElement;
    ULONG                       ulFirstEndElement, ulNextStartElement;
    ULONG                       ulFirstStartOffset;
    DIVIDECASE                  dcDivideCase;
    CComPtr<ITfRange>           cpRangeTemp;
    ULONG                       ulFirstDelta, ulSecondDelta;
    ULONG                       ulFirstTrail, ulSecondTrail;
    ULONG                       ulFirstTSpaceRemoved, ulSecondTSpaceRemoved;
    CStructArray<SPITNSHOWSTATE> rgOrgITNShowState;

    CSpDynamicString            dstrOrg, dstrFirst, dstrSecond;

    TraceMsg(TF_GENERAL, "CPropStoreRecoResultObject::_Divide is called, this=0x%x", (INT_PTR)this);

    if ( !pR1 || !pR2 )
        return E_INVALIDARG;

    // Update this property store to keep pR1 instead of the original whole range.
    CComPtr<ITfRange> cpRange;
    hr = pR1->Clone(&cpRange);
    if (S_OK == hr)
    {
        m_cpRange = cpRange;
    }
    else
        return hr;

    Assert(m_cpRange);

    // Update m_cpResultWrap for Range1.  especially for data member m_bstrCurrentText, m_ulStartElement, m_ulNumElements, ulNumOfITN,
    // and m_pulElementOffsets

    cpResultWrap = (CRecoResultWrap *)(void *)m_cpResultWrap;

    if ( cpResultWrap == NULL)
        return E_FAIL;

    if ( cpResultWrap->m_bstrCurrentText == NULL)
         cpResultWrap->_SetElementOffsetCch(NULL);  // To update internal text also.

    if ( cpResultWrap->m_bstrCurrentText == NULL)
        return E_FAIL;

    // Initialize the text for the first range and second range.
    dstrOrg.Append(cpResultWrap->m_bstrCurrentText);
    cchOrgLen = wcslen(cpResultWrap->m_bstrCurrentText);

    if ( cpResultWrap->IsElementOffsetIntialized( ) == FALSE )
    {
        cpResultWrap->_SetElementOffsetCch(NULL);
    }

    // Calculate how many elements will be in the first Range.

    hr = pR1->Clone(&cpRangeTemp);

    if ( hr == S_OK )
    {
        TF_HALTCOND        hc;
        
        hc.pHaltRange = pR1;
        hc.aHaltPos = TF_ANCHOR_END;
        hc.dwFlags = 0;
        cpRangeTemp->ShiftStart(ec, LONG_MAX, &cchFirst, &hc);

        if ( cchFirst == 0 )
            return E_FAIL;
    }
    else
        return E_FAIL;

    // Calculate how many chars are in the second range.
    cpRangeTemp.Release( );
    hr = pR2->Clone(&cpRangeTemp);

    if ( hr == S_OK )
    {
        TF_HALTCOND        hc;
        
        hc.pHaltRange = pR2;
        hc.aHaltPos = TF_ANCHOR_END;
        hc.dwFlags = 0;
        cpRangeTemp->ShiftStart(ec, LONG_MAX, &cchSecond, &hc);
    }

    if ( cchSecond == 0 )
        return E_FAIL;

    cchSecondStart = cchOrgLen - cchSecond;

    if ( cchSecondStart < cchFirst )
    {
        // Normally, it is not possible case, but for safety reason, just check it here.
        cchSecondStart = cchFirst;
    }

    TraceMsg(TF_GENERAL, "cchFirst=%d, cchSecondStart=%d", cchFirst, cchSecondStart);

    ulStartElement = cpResultWrap->GetStart( );
    ulNumElement = cpResultWrap->GetNumElements( );

    ulFirstEndElement = ulStartElement + ulNumElement - 1;
    ulNextStartElement = ulStartElement + ulNumElement;

    ulFirstStartOffset = cpResultWrap->_GetElementOffsetCch(ulStartElement);

    ulFirstDelta = cpResultWrap->_GetOffsetDelta( );
    ulSecondDelta = 0;

    ulFirstTrail= 0;
    ulSecondTrail = cpResultWrap->GetCharsInTrail( );

    ulFirstTSpaceRemoved = 0;
    ulSecondTSpaceRemoved = cpResultWrap->GetTrailSpaceRemoved( );

    dcDivideCase = DivideNormal;

    if ( (cchFirst >= cchOrgLen) || (cchSecondStart >= cchOrgLen) )
    {
        // Something is wrong here already.
        // It is better to stop here and return error 
        // to avoid any possible crash in the below code!
        return E_FAIL;
    }

    psz = (WCHAR *)dstrOrg;
    psz += cchSecondStart; // need to account for deleted text as well
    dstrSecond.Append(psz);


    psz = (WCHAR *)dstrOrg;
    dstrFirst.Append(psz);
    psz = (WCHAR *)dstrFirst;
    psz[cchFirst] = L'\0';

    if ( ulNumElement == 0 )
    {
        // There is no any valid element in this range.
        //
        // we just update the m_bstrCurrentText, don't generate a property store 
        // for second range.
        dcDivideCase = CurRangeNoElement;
    }
    else
    {
        // At least one element in this property range.
        BOOL     fFoundFirstEnd = FALSE;
        BOOL     fFoundSecondStart = FALSE;

        for ( iElement=ulStartElement; iElement < ulStartElement + ulNumElement; iElement++)
        {
            ULONG   cchAfterElem_i;  // length of text range from StartElement to this element ( include this element).
            ULONG   cchToElem_i;     // Length of text range from startElement to start of this element. ( exclude this elem).

            cchAfterElem_i =  cpResultWrap->_GetElementOffsetCch(iElement+1) - ulFirstStartOffset + ulFirstDelta;
            cchToElem_i = cpResultWrap->_GetElementOffsetCch(iElement) - ulFirstStartOffset + ulFirstDelta;

            if ( !fFoundFirstEnd )
            {
                // Try to find First End element and ulFirstTrail for the first range
                if ( cchFirst <= (long)ulFirstDelta )
                {
                    // Divide at the point which is not belong to any element of the phrase

                    ulFirstTrail = 0;
                    ulFirstDelta = cchFirst;
                    dcDivideCase = DivideInDelta;
                    fFoundFirstEnd = TRUE;

                    TraceMsg(TF_GENERAL, "The first range is divided inside Delta part");
                }
                else
                {
                    if ( cchAfterElem_i == (ULONG)cchFirst )
                    {
                        // This is the end element for the first range.
                        ulFirstEndElement = iElement;
                        ulFirstTrail = 0;

                        fFoundFirstEnd = TRUE;
                    }
                    else if ( cchAfterElem_i > (ULONG)cchFirst )
                    {
                        if ( ((WCHAR *)dstrOrg)[cchFirst] == L' ')
                        {
                            // This is also the end elemenet.
                            // just divide in at a space char.
                            ulFirstEndElement = iElement;

                            ulFirstTrail = 0;

                            // The trailing space is now removed from the original element.
                            // we need to update the length for this element. ( update the offset 
                            // for next element).

                            iElementOffsetChanged = cchAfterElem_i - cchFirst;
                            ulFirstTSpaceRemoved = iElementOffsetChanged;
                        }
                        else
                        {
                            // check to see if current element is inside an ITN.

                            BOOL  fInsideITN;
                            ULONG ulITNStart, ulITNNumElem;
                            ULONG ulCurElement;

                            fInsideITN = cpResultWrap->_CheckITNForElement(NULL, iElement, &ulITNStart, &ulITNNumElem, NULL);
    
                            if ( fInsideITN )
                                ulCurElement = ulITNStart;
                            else
                                ulCurElement = iElement;

                            ulFirstEndElement = ulCurElement - 1;                   

                            // The previous one is EndElement if there is a previous element
                            // Discard this element.
                            // Divide at a valid element

                            // If divide in the first element, specially handle it.
                            if ( ulCurElement == ulStartElement)
                            {
                                dcDivideCase = DivideInsideFirstElement;
                                TraceMsg(TF_GENERAL, "The first range is divided inside the first element");
                            }

                            // The first part of this element would become
                            // the trail part of the first range.
                            ulFirstTrail = (ULONG)cchFirst - cchToElem_i;
                                
                        }

                        fFoundFirstEnd = TRUE;
                    }
                }
            }

            if ( fFoundFirstEnd )
            {
                // Now the data for the first range is completed.
                // we want to find data for the second range.

                // We want to find the start element and ulSecondDelta for the second range.

                if ( (long)cchToElem_i >= cchSecondStart )
                {
                    // Find the element which is the first element after the start point of second
                    // range.

                    ulNextStartElement = iElement;
                    ulSecondDelta = cchToElem_i - cchSecondStart;

                    fFoundSecondStart = TRUE;
                    break;
                }
            }

        }  // for

        if ( !fFoundFirstEnd )
        {
            // Cannot find the first end element from the above code.
            // it must be divided in the trailing part.

            // we just want to change the ulCharsInTrail for the first range.
            ULONG  ulValidLenInFirstRange;

            // ulValidLenInFirstRange is the number of Delta chars and valid elements' chars.

            ulValidLenInFirstRange = cpResultWrap->_GetElementOffsetCch(ulStartElement + ulNumElement) - ulFirstStartOffset + ulFirstDelta;

            ulFirstTrail = cchFirst - ulValidLenInFirstRange;

        }

        if ( !fFoundSecondStart )
        {
            // The second start point must be in Last element or in the Trailing part in the original range.
            // The second range will not contain any valid element.

            ulSecondTrail = 0;
            ulSecondDelta = cchOrgLen - cchSecondStart;

            ulNextStartElement = ulStartElement + ulNumElement; // This is not a valid element number in the original
                                                                // range. using this value means there is no valid element
                                                                // in the second range. 
        }
    }

    
    TraceMsg(TF_GENERAL, "ulStartElement = %d ulNumElement=%d", ulStartElement, ulNumElement);
    TraceMsg(TF_GENERAL, "ulFirstEndElement = %d ulNextStartElement=%d", ulFirstEndElement, ulNextStartElement);
    TraceMsg(TF_GENERAL, "The First Range text =\"%S\", delta=%d, Trail=%d, TSRemoved=%d", (WCHAR *)dstrFirst, ulFirstDelta, ulFirstTrail, ulFirstTSpaceRemoved); 
    TraceMsg(TF_GENERAL, "The second range text =\"%S\", delta=%d, Trail=%d, TSRemoved=%d", (WCHAR *)dstrSecond, ulSecondDelta, ulSecondTrail, ulSecondTSpaceRemoved); 

    if (cpResultWrap->m_bstrCurrentText)
        SysFreeString(cpResultWrap->m_bstrCurrentText);

    cpResultWrap->m_bstrCurrentText = SysAllocString((WCHAR *)dstrFirst); 
    
    // Keep the ITN show-state for the second reco wrap use.
    if ( cpResultWrap->m_ulNumOfITN )
    {
        rgOrgITNShowState.Append(cpResultWrap->m_ulNumOfITN);

        for (ULONG  i=0; i<cpResultWrap->m_ulNumOfITN; i++)
        {
            SPITNSHOWSTATE  *pITNShowState;
            if ( pITNShowState = rgOrgITNShowState.GetPtr(i))
            {
                SPITNSHOWSTATE *pITNShowStateSource;
                
                pITNShowStateSource = cpResultWrap->m_rgITNShowState.GetPtr(i);

                pITNShowState->ulITNStart = pITNShowStateSource->ulITNStart;
                pITNShowState->ulITNNumElem = pITNShowStateSource->ulITNNumElem;
                pITNShowState->fITNShown = pITNShowStateSource->fITNShown;
            }
        }
    }

    // Keep the Offset list for second range

    ULONG     *pulOffsetForSecond = NULL;

    if ( (ulStartElement + ulNumElement - ulNextStartElement) > 0 )
    {
        ULONG   ulNextNumOffset;

        ulNextNumOffset =  ulStartElement + ulNumElement - ulNextStartElement + 1;

        pulOffsetForSecond = new ULONG[ulNextNumOffset];

        if ( pulOffsetForSecond )
        {
            ULONG  i;
            ULONG  ulOffset;

            for ( i=0; i < ulNextNumOffset;  i++ )
            {
                ulOffset = cpResultWrap->_GetElementOffsetCch(ulNextStartElement + i );
                pulOffsetForSecond[i] = ulOffset;
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    switch ( dcDivideCase )
    {
    case DivideNormal :

        ULONG   ulNumOfITN;
        ULONG   ulFirstNumElement;

        ulFirstNumElement = ulFirstEndElement - ulStartElement + 1;
        cpResultWrap->SetNumElements(ulFirstNumElement);

        // update the ITN show-state list.
        if (cpResultWrap->m_ulNumOfITN > 0)
        {
            ulNumOfITN = cpResultWrap->_RangeHasITN(ulStartElement, ulFirstNumElement);
            if ( cpResultWrap->m_ulNumOfITN > ulNumOfITN )
            {
                // There is ITN number change
                // need to remove the ITNs which are not in this range.
               cpResultWrap->m_rgITNShowState.Remove(ulNumOfITN, cpResultWrap->m_ulNumOfITN - ulNumOfITN);
               cpResultWrap->m_ulNumOfITN = ulNumOfITN;
            }

        }

        if ( iElementOffsetChanged > 0 )
        {
            // Some trailing spaces are removed from end element of the first range.
            ULONG  ulNewOffset;

            ulNewOffset = cpResultWrap->_GetElementOffsetCch(ulFirstEndElement + 1);
            cpResultWrap->_SetElementNewOffset(ulFirstEndElement + 1, ulNewOffset - iElementOffsetChanged);
        }

        cpResultWrap->SetCharsInTrail(ulFirstTrail);
        cpResultWrap->SetTrailSpaceRemoved( ulFirstTSpaceRemoved );

        break;

    case DivideInsideFirstElement :
    case DivideInDelta :

        cpResultWrap->SetNumElements(0);
        cpResultWrap->m_ulNumOfITN = 0;
        cpResultWrap->SetOffsetDelta(ulFirstDelta);
        cpResultWrap->SetCharsInTrail(ulFirstTrail);
        cpResultWrap->SetTrailSpaceRemoved( ulFirstTSpaceRemoved );

        break;

    case CurRangeNoElement :
      
        TraceMsg(TF_GENERAL, "There is no element in original range");
        cpResultWrap->SetNumElements(0);
        cpResultWrap->m_ulNumOfITN = 0;
        break;
    }

    // Now generate a new properstore for the new range pR2.
    // if the new property store is required.

    if ( ppPs == NULL )
        return hr;

    if (dcDivideCase == CurRangeNoElement )
    {
        // there is no any element in the original property range.
        *ppPs = NULL;
        return hr;
    }

    CPropStoreRecoResultObject *prps = NULL;
    if (S_OK == hr)
        prps = new CPropStoreRecoResultObject(m_pimx, pR2);

    if (prps)
    {
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)ppPs);

        if (SUCCEEDED(hr))
        {
            CRecoResultWrap *prw;
            ULONG            ulNextNum;
            ULONG            ulNumOfITN;
            CComPtr<ISpRecoResult> cpResult;

            if ( ulNextStartElement >= ulStartElement + ulNumElement)
            {
                // It is divided at the last element of the original range. 
                // We will just generate a property store for this Cicero ver 1.0
                // to avoid the original property store be removed by Cicero engine.

                // FutureConsider: if Cicero changes the logic in the future, we need to change
                // this code as well so that we don't need to generate a property store
                // for this second range.

                ulNextNum = 0;
                ulNumOfITN = 0;
                ulSecondTSpaceRemoved = 0;

            }
            else
            {
                ulNextNum = ulStartElement + ulNumElement - ulNextStartElement;
                ulNumOfITN = cpResultWrap->_RangeHasITN(ulNextStartElement, ulNextNum);
            }
            
            prw = new CRecoResultWrap(m_pimx, ulNextStartElement, ulNextNum, ulNumOfITN);
            if ( prw != NULL )
            {
                hr = cpResultWrap->GetResult(&cpResult);
            }
            else
            {
                // Check interface pointer ref  leak problem.
                return E_OUTOFMEMORY;
            }

            if (S_OK == hr)
            {
                hr = prw->Init(cpResult);
            }

            if (S_OK == hr)
            {
                prw->SetOffsetDelta(ulSecondDelta);
                prw->SetCharsInTrail(ulSecondTrail);
                prw->SetTrailSpaceRemoved( ulSecondTSpaceRemoved );
                prw->m_bstrCurrentText = SysAllocString((WCHAR *)dstrSecond);

                // Update ITN show-state list .

                if ( ulNumOfITN > 0 )
                {
                    SPITNSHOWSTATE  *pITNShowState;
                    ULONG           ulOrgNumOfITN;

                    ulOrgNumOfITN = rgOrgITNShowState.Count( );
                
                    for ( ULONG  iIndex=0; iIndex<ulOrgNumOfITN; iIndex ++ )
                    {
                        pITNShowState = rgOrgITNShowState.GetPtr(iIndex);

                        if ( pITNShowState)
                        {
                            if ( (pITNShowState->ulITNStart 
                                  >= ulNextStartElement) &&
                                 (pITNShowState->ulITNStart + 
                                  pITNShowState->ulITNNumElem) 
                                  <= (ulNextStartElement + ulNextNum) )
                            {
                                prw->_InitITNShowState(
                                         pITNShowState->fITNShown, 
                                         pITNShowState->ulITNStart, 
                                         pITNShowState->ulITNNumElem);
                            }
                        }
                    } // for
                } // if

                // Update the Offset list for the second range.

                if ( (ulNextNum > 0) && pulOffsetForSecond )
                {
                    ULONG  i;
                    ULONG  ulOffset;

                    for ( i=0; i <= ulNextNum; i ++ )
                    {
                        ulOffset = pulOffsetForSecond[i];
                        prw->_SetElementNewOffset(ulNextStartElement + i, ulOffset);
                    }
                }

                hr = prps->_InitFromResultWrap(prw);
            }
            prw->Release( );
        }
        prps->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( rgOrgITNShowState.Count( ) )
        rgOrgITNShowState.Clear( );

    if ( pulOffsetForSecond )
        delete[] pulOffsetForSecond;

    return hr;
}

//
//   CPropStoreRecoResultObject::_Shrink
//
//    receive EditCookie from edit session.
//    try to determine the new range's attribute to update the property store or notify 
//    the ctf engine to discard it.
//

HRESULT CPropStoreRecoResultObject::_Shrink(TfEditCookie ec, ITfRange *pRange,BOOL *pfFree)
{
    HRESULT                 hr = S_OK;
    WCHAR                  *pwszNewText = NULL;
    long                    cchNew = 0;
    WCHAR                  *pwszOrgText = NULL; 
    CSpDynamicString        dstrOrg;
    long                    cchOrg = 0;
    CComPtr<ITfRange>       cpRangeTemp;
    CRecoResultWrap        *cpResultWrap;
    long                    iStartOffset;  // the offset from start of the new range to the 
                                            // original range start point.
    long                    iLastOffset;   // The offset from the last character of new range 
                                            // to the original range start point.
    ULONG                   ulNewStartElement, ulNewNumElements, ulNewDelta, ulNewTrail, ulNewTSRemoved;
    ULONG                   ulOrgStartElement, ulOrgNumElements, ulOrgDelta, ulOrgTrail, ulOrgTSRemoved;

    BOOL                    fShrinkToWrongPos = FALSE;

    int                     iElementOffsetChanged = 0;  // If the new range just remove the 
                                                        // trailing space of original text,
                                                        // the new valid start and end element
                                                        // will keep unchanged, but the length of
                                                        // new end element is changed.

    TraceMsg(TF_GENERAL, "CPropStoreRecoResultObject::_Shrink is called, this=0x%x", (INT_PTR)this);

    if ( !pRange || !pfFree )  return E_INVALIDARG;

    // Set *pfFree as TRUE intially in case there is an error occuring.
    *pfFree = TRUE;

    cpResultWrap = (CRecoResultWrap *)(void *)m_cpResultWrap;

    if ( cpResultWrap == NULL )  return E_FAIL;

    if ( (WCHAR *)cpResultWrap->m_bstrCurrentText == NULL )
        cpResultWrap->_SetElementOffsetCch(NULL);  // To update internal text based.

    dstrOrg.Append((WCHAR *)cpResultWrap->m_bstrCurrentText);
    pwszOrgText = (WCHAR *)dstrOrg;

    ulOrgNumElements = cpResultWrap->GetNumElements( );
    ulOrgStartElement = cpResultWrap->GetStart( );
    ulOrgDelta = cpResultWrap->_GetOffsetDelta(  );
    ulOrgTrail = cpResultWrap->GetCharsInTrail( );
    ulOrgTSRemoved = cpResultWrap->GetTrailSpaceRemoved( );
    if ( pwszOrgText )
        cchOrg = wcslen(pwszOrgText);
    
    if ( (ulOrgNumElements ==0) || (pwszOrgText == NULL) || (cchOrg == 0) )
    {
        // This property store doesn't have resultwrap or doesn't have valid element.
        // let cicero engine free this property store.
        return hr;
    }

    pwszNewText = new WCHAR[cchOrg+1];

    // try to get the new text pointed by pRange and character number this text.
    if ( pwszNewText )
    {
        hr = pRange->Clone( &cpRangeTemp );
        if ( hr == S_OK) 
        {
            hr = cpRangeTemp->GetText(ec, 0, pwszNewText, cchOrg, (ULONG *)&cchNew);
        }

        // Get the new range's StartOffset and LastOffset in the original property range.

        iStartOffset = 0;
        iLastOffset = cchOrg;

        if ( hr == S_OK && cchNew > 0 )
        {
            long    i;
            BOOL    fFoundNewString=FALSE;

            for (i=0; i<=(cchOrg-cchNew); i++)
            {
                WCHAR   *pwszOrg;

                pwszOrg = pwszOrgText + i;

                if ( wcsncmp(pwszOrg, pwszNewText, cchNew) == 0 )
                {
                    // Found the match

                    iStartOffset = i;
                    iLastOffset = i + cchNew;
                    fFoundNewString = TRUE;
                    break;
                }
            }

            // If we cannot find the new text as the substring in the original property text.
            // It must be shrinked to a wrong place.

            fShrinkToWrongPos = !fFoundNewString;

        }

    }
    else
        hr = E_OUTOFMEMORY;
  
    if ( hr != S_OK  || fShrinkToWrongPos) 
        goto CleanUp;

    TraceMsg(TF_GENERAL, "Shrink: NewText: cchNew=%d :\"%S\"", cchNew, pwszNewText);
    TraceMsg(TF_GENERAL, "Shrink: OrgText: cchOrg=%d :\"%S\"", cchOrg, pwszOrgText);
    TraceMsg(TF_GENERAL, "Shrink: Org: StartElem=%d NumElem=%d Delta=%d, Trail=%d, TSRemoved=%d", ulOrgStartElement, ulOrgNumElements, ulOrgDelta, ulOrgTrail, ulOrgTSRemoved);
    TraceMsg(TF_GENERAL, "Shrink: iStartOffset=%d, iLastOffset=%d", iStartOffset, iLastOffset);

    if ( cpResultWrap->IsElementOffsetIntialized( ) == FALSE )
        cpResultWrap->_SetElementOffsetCch(NULL);

    ulNewStartElement = ulOrgStartElement;
    ulNewDelta = ulOrgDelta;
    ulNewTrail = ulOrgTrail;

    // Calculate ulNewStartElement and ulNewDelta.
    if ( (ULONG)iStartOffset <= ulOrgDelta )
    {
        ulNewDelta = ulOrgDelta - iStartOffset;
        ulNewStartElement = ulOrgStartElement;
    }
    else
    {
        ULONG     iElement;
        ULONG     ulOrgStartOffset;

        ulOrgStartOffset = cpResultWrap->_GetElementOffsetCch(ulOrgStartElement);

        for ( iElement=ulOrgStartElement; iElement < ulOrgStartElement + ulOrgNumElements; iElement++)
        {
            ULONG   ulToElement;
            ULONG   ulAfterElement;

            ulToElement = cpResultWrap->_GetElementOffsetCch(iElement) - ulOrgStartOffset + ulOrgDelta;
            ulAfterElement = cpResultWrap->_GetElementOffsetCch(iElement+1) - ulOrgStartOffset + ulOrgDelta;

            if ( ulToElement == (ULONG)iStartOffset )
            {
                ulNewStartElement = iElement;
                ulNewDelta = 0;
                break;
            }
            else  
            {
                if ( (ulToElement < (ULONG)iStartOffset) && (ulAfterElement > (ULONG)iStartOffset)) 
                {
                    ulNewStartElement = iElement + 1;
                    ulNewDelta = ulAfterElement - iStartOffset;
                    break;
                }
            }
        }
    }

    // Calculate new ulNewNumElements.

    ulNewNumElements = 0;

    if ( iLastOffset == cchOrg )
    {
        // 
         ULONG  ulNewEndElement;

        // New End is the same as org End.
        ulNewEndElement = ulOrgStartElement + ulOrgNumElements - 1;

        ulNewNumElements = 1 + ulNewEndElement - ulNewStartElement;
 
    }
    else
    {
        long      iElement;
        ULONG     ulOrgStartOffset;
        ULONG     ulOrgEndElement;
        ULONG     ulNewEndElement;
        BOOL      fFound;

        ulOrgEndElement = ulOrgStartElement + ulOrgNumElements - 1;
        ulOrgStartOffset = cpResultWrap->_GetElementOffsetCch(ulOrgStartElement);
       
        fFound = FALSE;
        for ( iElement=(long)ulOrgEndElement; iElement >= (long)ulOrgStartElement; iElement--)
        {
            ULONG   ulToElement;
            ULONG   ulAfterElement;
            BOOL    fInsideITN;
            ULONG   ulITNStart, ulITNNumElem;
            ULONG   ulCurElement;

            ulToElement = cpResultWrap->_GetElementOffsetCch(iElement) - ulOrgStartOffset + ulOrgDelta;
            ulAfterElement = cpResultWrap->_GetElementOffsetCch(iElement+1) - ulOrgStartOffset + ulOrgDelta;

            if ( iElement == (long)ulOrgEndElement  && ( ulAfterElement <= (ULONG)iLastOffset ) )
            {
                // This org last element would be the new last element
                ulNewEndElement = iElement;
                ulNewTrail = (ULONG)iLastOffset - ulAfterElement;
                fFound = TRUE;
                break;
            }

            fInsideITN = cpResultWrap->_CheckITNForElement(NULL, iElement, &ulITNStart, &ulITNNumElem, NULL);
            
            if ( fInsideITN )
                ulCurElement = ulITNStart;
            else
                ulCurElement = iElement;

            if ( ulToElement == (ULONG)iLastOffset )
            {
                ulNewEndElement = ulCurElement - 1;
                ulNewTrail = 0;
               
                fFound = TRUE;
                break;
            }

            if ( (ulToElement < (ULONG)iLastOffset) && (ulAfterElement > (ULONG)iLastOffset)) 
            {
                if ( pwszOrgText[iLastOffset] == L' ')
                {
                    // The trailing space is now removed from the original element.
                    // we need to update the length for this element. ( update the offset 
                    // for next element).

                    iElementOffsetChanged = ulAfterElement - iLastOffset;

                    if ( fInsideITN )
                        ulNewEndElement = ulITNStart + ulITNNumElem - 1;
                    else
                        ulNewEndElement = iElement;

                    ulNewTrail = 0;
                }
                else
                {
                    ulNewEndElement = ulCurElement - 1;
                    ulNewTrail = (ULONG)iLastOffset - ulToElement;
                }

                fFound = TRUE;
                break;
            }

        }

        if ( fFound )
            ulNewNumElements = 1 + ulNewEndElement - ulNewStartElement;
    }

    ulNewTSRemoved = ulOrgTSRemoved + iElementOffsetChanged;

    TraceMsg(TF_GENERAL, "Shrink: New: StartElem=%d NumElem=%d Delta=%d, Trail=%d, TSRemoved=%d", ulNewStartElement, ulNewNumElements, ulNewDelta, ulNewTrail, ulNewTSRemoved);

    // If there is no valid element in the new range, discard this property store
    // otherwise, keep it and update the related data members.

    if ( ulNewNumElements > 0 )
    {
        ULONG  ulNumOfITN;

        *pfFree = FALSE;
        
        CComPtr<ITfRange> cpRange;
        hr = pRange->Clone(&cpRange);

        if (S_OK == hr)
        {
            m_cpRange = cpRange;

            cpResultWrap->SetStart(ulNewStartElement);
            cpResultWrap->SetNumElements(ulNewNumElements);
            cpResultWrap->SetOffsetDelta(ulNewDelta);
            cpResultWrap->SetCharsInTrail(ulNewTrail);
            cpResultWrap->SetTrailSpaceRemoved( ulNewTSRemoved );

            ulNumOfITN = cpResultWrap->_RangeHasITN(ulNewStartElement, ulNewNumElements);

            cpResultWrap->m_ulNumOfITN = ulNumOfITN;

            // Update ITN show-state list

            if ( ulNumOfITN > 0 )
            {
                SPITNSHOWSTATE  *pITNShowState;
                ULONG           ulOrgNumOfITN;

                ulOrgNumOfITN = cpResultWrap->m_rgITNShowState.Count( );
                
                for ( ULONG iIndex=ulOrgNumOfITN; iIndex>0; iIndex -- )
                {
                    pITNShowState = cpResultWrap->m_rgITNShowState.GetPtr(iIndex-1);

                    if ( pITNShowState)
                    {
                        if ( (pITNShowState->ulITNStart < ulNewStartElement) ||
                             (pITNShowState->ulITNStart + pITNShowState->ulITNNumElem) > (ulNewStartElement + ulNewNumElements) )
                        {
                            // This ITN is not in the new Range
                            cpResultWrap->m_rgITNShowState.Remove(iIndex-1, 1);
                        }
                    }
                }
            }
            else
                if ( cpResultWrap->m_rgITNShowState.Count( ) )
                    cpResultWrap->m_rgITNShowState.Clear( );
                
            if ( cpResultWrap->m_bstrCurrentText )
                SysFreeString(cpResultWrap->m_bstrCurrentText);

            cpResultWrap->m_bstrCurrentText = SysAllocString(pwszNewText);

            if ( iElementOffsetChanged != 0 )
            {
                ULONG  ulNewOffset;
                ULONG  ulElemAfterEnd;

                ulElemAfterEnd = ulNewStartElement + ulNewNumElements;
                ulNewOffset = cpResultWrap->_GetElementOffsetCch(ulElemAfterEnd);
                cpResultWrap->_SetElementNewOffset(ulElemAfterEnd, ulNewOffset - iElementOffsetChanged);
            }
        }
    }

CleanUp:
    if ( pwszNewText )  delete[] pwszNewText;
    return hr;
}

//
// CPropStoreRecoResultObject::Clone
//
// synopsis : make a new cloned propstore which shares the same SAPI result
//            object as the current class instance
//
//
STDMETHODIMP CPropStoreRecoResultObject::Clone(ITfPropertyStore **ppPropStore)
{
    HRESULT hr;
    CPropStoreRecoResultObject *prps = new CPropStoreRecoResultObject(m_pimx, m_cpRange);
    if (prps)
    {
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)ppPropStore);

        if (SUCCEEDED(hr))
        {
            CRecoResultWrap *prw = NULL;
            CRecoResultWrap *pRecoWrapOrg = NULL;

            if ( m_cpResultWrap )
            {
                hr = m_cpResultWrap->QueryInterface(IID_PRIV_RESULTWRAP, (void **)&pRecoWrapOrg);

                if ( hr == S_OK )
                {
                    hr = pRecoWrapOrg->Clone(&prw);
                }

                SafeRelease(pRecoWrapOrg);

                if ( hr == S_OK )
                   hr = prps->_InitFromResultWrap(prw);

                SafeRelease(prw);
            }
        }
        prps->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CPropStoreRecoResultObject::GetPropertyRangeCreator(CLSID *pclsid)
{
    HRESULT hr = E_INVALIDARG;

    if (pclsid)
    {
        *pclsid = CLSID_SapiLayr;
        hr = S_OK;
    }

    return hr;
}

//
// CPropStoreRecoResultObject::Serialize
//
// synopsis: takes a pointer to an IStream and get the current
//           SAPI result object serialized
//
// changes from CResultPropertyStore:
//           Uses SAPI's result object to get the blob
//           serialized. ISpResultObject has to be cloned
//           in order to keep the object alive after
//           'detaching' it.
//
//
STDMETHODIMP CPropStoreRecoResultObject::Serialize(IStream *pStream, ULONG *pcb)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_GENERAL, "Serialize is called, this = 0x%x", (INT_PTR)this);
    
    if (m_cpResultWrap && pStream)
    {
        CComPtr<IServiceProvider> cpServicePrv;
        CComPtr<ISpRecoResult> cpRecoResult;
        SPSERIALIZEDRESULT *pResBlock;
        ULONG ulrw1 = 0;
        ULONG ulrw2 = 0;

        CRecoResultWrap     *cpRecoWrap;
        ULONG               ulSizeRecoWrap, ulTextNum, ulITNSize;
        ULONG               ulOffsetSize, ulOffsetNum;
        RECOWRAPDATA       *pRecoWrapData;

        cpRecoWrap = (CRecoResultWrap *)(void *)m_cpResultWrap; 

        // We want to save m_ulStartElement, m_ulNumElements, m_OffsetDelta, ulNumOfITN, m_bstrCurrentText 
        // and a list of ITN show state structure in the RecoResultWrap to the serialized stream.

        ulTextNum = 0;
        if (cpRecoWrap->m_bstrCurrentText) 
        {
            ulTextNum = wcslen(cpRecoWrap->m_bstrCurrentText) + 1; // plus NULL terminator
        }

        ulITNSize = cpRecoWrap->m_ulNumOfITN * sizeof(SPITNSHOWSTATE);

        if ( cpRecoWrap->IsElementOffsetIntialized( ) )
            ulOffsetNum = cpRecoWrap->GetNumElements( ) + 1;
        else 
            ulOffsetNum = 0;

        ulOffsetSize = ulOffsetNum * sizeof(ULONG);

        // Serialiezed data will contain RECOWRAPDATA struct, ITN show-state list, Offset list and m_bstrCurrentText.

        ulSizeRecoWrap = sizeof(RECOWRAPDATA) + ulITNSize + ulOffsetSize + sizeof(WCHAR) * ulTextNum;

        pRecoWrapData = (RECOWRAPDATA  *)cicMemAllocClear(ulSizeRecoWrap);

        if (pRecoWrapData)
        {
            WCHAR   *pwszText;

            pRecoWrapData->ulSize = ulSizeRecoWrap;
            pRecoWrapData->ulStartElement = cpRecoWrap->GetStart( );
            pRecoWrapData->ulNumElements = cpRecoWrap->GetNumElements( );
            pRecoWrapData->ulOffsetDelta = cpRecoWrap->_GetOffsetDelta( );
            pRecoWrapData->ulCharsInTrail = cpRecoWrap->GetCharsInTrail( );
            pRecoWrapData->ulTrailSpaceRemoved = cpRecoWrap->GetTrailSpaceRemoved( );
            pRecoWrapData->ulNumOfITN = cpRecoWrap->m_ulNumOfITN;
            pRecoWrapData->ulOffsetNum = ulOffsetNum;

            // Save the ITN show-state list

            if ( cpRecoWrap->m_ulNumOfITN > 0 )
            {
                SPITNSHOWSTATE *pITNShowState;

                pITNShowState = (SPITNSHOWSTATE *)((BYTE *)pRecoWrapData + sizeof(RECOWRAPDATA));

                for ( ULONG i=0; i<cpRecoWrap->m_ulNumOfITN; i++)
                {
                    SPITNSHOWSTATE *pITNShowStateSource;

                    pITNShowStateSource = cpRecoWrap->m_rgITNShowState.GetPtr(i);

                    if ( pITNShowStateSource )
                    {
                        pITNShowState->fITNShown = pITNShowStateSource->fITNShown;
                        pITNShowState->ulITNNumElem = pITNShowStateSource->ulITNNumElem;
                        pITNShowState->ulITNStart = pITNShowStateSource->ulITNStart;

                        pITNShowState ++;
                    }
                }
            }

            // Save the offset list

            if ( ulOffsetSize > 0 )
            {
                ULONG   *pulOffset;

                pulOffset = (ULONG *)((BYTE *)pRecoWrapData + sizeof(RECOWRAPDATA) + ulITNSize);

                for (ULONG i=0; i<ulOffsetNum; i++)
                {
                    pulOffset[i] = cpRecoWrap->_GetElementOffsetCch(pRecoWrapData->ulStartElement + i );
                }
            }

            if (cpRecoWrap->m_bstrCurrentText) 
            {
                pwszText = (WCHAR *)((BYTE *)pRecoWrapData + sizeof(RECOWRAPDATA) + ulITNSize + ulOffsetSize);
                StringCchCopyW(pwszText, ulTextNum, cpRecoWrap->m_bstrCurrentText);
            }

            hr = pStream->Write(
                               pRecoWrapData,       
                               ulSizeRecoWrap,   // the number of bytes to copy
                               &ulrw1 
                               );

            if ( SUCCEEDED(hr) && (ulrw1 == ulSizeRecoWrap))
            {

                //  QI the service provider first then get to the sapi interface
                //
                hr = m_cpResultWrap->QueryInterface(IID_IServiceProvider, (void **)&cpServicePrv);
                if (SUCCEEDED(hr))
                {
                    hr = cpServicePrv->QueryService(GUID_NULL, IID_ISpRecoResult, (void **)&cpRecoResult);
                }

                // 'detach' the result to a mem chunk
                //
                if (SUCCEEDED(hr))
                {
                    hr = cpRecoResult->Serialize(&pResBlock);
                }
        
                // serialize the chunk to the stream
                //
                if (SUCCEEDED(hr) && pResBlock)
                {
                    hr = pStream->Write(
                            pResBlock,       
                            (ULONG)pResBlock->ulSerializedSize,   // the number of bytes to copy
                            &ulrw2 
                        );
    
                    if (pcb)
                        *pcb = ulrw1 + ulrw2;
                
                    // no need for the detached mem chunk
                    CoTaskMemFree(pResBlock);
                }
            }

            cicMemFree(pRecoWrapData);
        }
        else
            hr = E_OUTOFMEMORY;
    } 

    return hr;
}

//
// CPropStoreRecoResultObject::_InitFromIStream
//
// stores IStream copied from param
//
HRESULT CPropStoreRecoResultObject::_InitFromIStream(IStream *pStream, int iSize, ISpRecoContext *pRecoCtxt)
{
    HRESULT hr = S_OK;
    ULONG   ulSize = (ULONG)iSize;

    if (!pStream) return E_INVALIDARG;

    // alloc the mem chunk for the reco
    // blob
    if ( ulSize == 0 )
    {
        STATSTG stg;
        hr = pStream->Stat(&stg, STATFLAG_NONAME);
        
        if (SUCCEEDED(hr))
            ulSize = (int)stg.cbSize.LowPart;
    }
    
    // got size from given stream or param
    
    if (SUCCEEDED(hr))
    {

        // First We want to get RECOWRAPDATA at the begining of the stream.
        RECOWRAPDATA  rwData;

        hr = pStream->Read(
                        &rwData,                  // the destination buf
                        sizeof(RECOWRAPDATA),    // the number of bytes to read
                        NULL
                        );

        if ( SUCCEEDED(hr) )
        {
            
            ULONG  ulITNSize;
            SPITNSHOWSTATE *pITNShowState = NULL;

            ulITNSize = rwData.ulNumOfITN * sizeof(SPITNSHOWSTATE);

            if ( ulITNSize > 0 )
            {
                
                pITNShowState = (SPITNSHOWSTATE *)cicMemAllocClear(ulITNSize);
                rwData.pITNShowState = pITNShowState;

                if ( pITNShowState )
                {
                    hr = pStream->Read(
                                    pITNShowState,       // the destination buf
                                    ulITNSize,           // the number of bytes to read
                                    NULL
                                    );
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            ULONG   *pulOffsetElement = NULL;
            ULONG   ulOffsetSize, ulOffsetNum;

            ulOffsetNum = rwData.ulOffsetNum;
            ulOffsetSize = ulOffsetNum * sizeof(ULONG);

            if ( SUCCEEDED(hr) && ulOffsetSize > 0 )
            {
                pulOffsetElement = (ULONG *) cicMemAllocClear(ulOffsetSize);
                rwData.pulOffset = pulOffsetElement;

                if ( pulOffsetElement )
                {
                    hr = pStream->Read(
                                    pulOffsetElement,    // the destination buf
                                    ulOffsetSize,        // the number of bytes to read
                                    NULL
                                    );
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            
            if ( SUCCEEDED(hr))
            {
             
                ULONG  ulTextSize;
                WCHAR  *pwszText;

                ulTextSize = rwData.ulSize - sizeof(RECOWRAPDATA) - ulITNSize - ulOffsetSize;
                pwszText = (WCHAR *) cicMemAllocClear(ulTextSize);

                rwData.pwszText = pwszText; 

                if ( pwszText )
                {
                    hr = pStream->Read(
                                    pwszText,       // the destination buf
                                    ulTextSize,     // the number of bytes to read
                                    NULL
                                    );

                    if ( SUCCEEDED(hr) )
                    {
                        // prepare cotaskmem chunk
                        SPSERIALIZEDRESULT *pResBlock = (SPSERIALIZEDRESULT *)CoTaskMemAlloc(ulSize - rwData.ulSize + sizeof(ULONG)*4);
                        if (pResBlock)
                        {
                            CComPtr<ISpRecoResult> cpResult;

                            hr = pStream->Read(
                                            pResBlock,               // the destination buf
                                            ulSize - rwData.ulSize,  // the number of bytes to read
                                            NULL
                                        );

                            if (S_OK == hr)
                            {
                                // now create a reco result from the blob data
                                hr = pRecoCtxt->DeserializeResult(pResBlock, &cpResult);
                            }
        
                            CoTaskMemFree(pResBlock);
            
                            if (S_OK == hr)
                            {
                                _InitFromRecoResult(cpResult, &rwData);
                            }
                        }
                    }
                    cicMemFree(pwszText);
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            if ( (hr == S_OK) && (pITNShowState != NULL) )
                cicMemFree(pITNShowState);

            if ( pulOffsetElement != NULL )
                cicMemFree(pulOffsetElement);

        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

     return hr;
}

HRESULT CPropStoreRecoResultObject::_InitFromRecoResult(ISpRecoResult *pResult, RECOWRAPDATA *pRecoWrapData)
{
    HRESULT hr = S_OK;
    ULONG ulStartElement = 0;
    ULONG ulNumElements = 0;
    ULONG ulNumOfITN = 0;
    ULONG ulOffsetNum = 0;
    
    m_cpResultWrap.Release();

    if ( pRecoWrapData == NULL )
        return E_INVALIDARG;
    
    // get start/num of elements
    ulStartElement = pRecoWrapData->ulStartElement;
    ulNumElements = pRecoWrapData->ulNumElements;
    ulNumOfITN = pRecoWrapData->ulNumOfITN;
    ulOffsetNum = pRecoWrapData->ulOffsetNum;

    CRecoResultWrap *prw = new CRecoResultWrap(m_pimx, ulStartElement, ulNumElements, ulNumOfITN);

    if (prw)
    {
        hr = prw->Init(pResult);
    }    
    else
        hr = E_OUTOFMEMORY;

    if (S_OK == hr)
    {
        m_cpResultWrap = SAFECAST(prw, IUnknown *);

        prw->SetOffsetDelta(pRecoWrapData->ulOffsetDelta);
        prw->SetCharsInTrail(pRecoWrapData->ulCharsInTrail);
        prw->SetTrailSpaceRemoved(pRecoWrapData->ulTrailSpaceRemoved);
        prw->m_bstrCurrentText = SysAllocString(pRecoWrapData->pwszText);

        // Update ITN show-state list

        if ( (ulNumOfITN > 0) && pRecoWrapData->pITNShowState )
        {
            SPITNSHOWSTATE *pITNShowState;

            pITNShowState = pRecoWrapData->pITNShowState;

            for ( ULONG i=0; i<ulNumOfITN; i++)
            {
                prw->_InitITNShowState(pITNShowState->fITNShown, pITNShowState->ulITNStart, pITNShowState->ulITNNumElem);
                pITNShowState ++;
            }
        }

        // Update the element Offset list.

        if ( (ulOffsetNum > 0)  &&  (pRecoWrapData->pulOffset ))
        {

            ULONG   *pulOffset;
            
            pulOffset = pRecoWrapData->pulOffset;

            for (ULONG i=0; i< ulOffsetNum; i++)
            {
                prw->_SetElementNewOffset(i + ulStartElement, pulOffset[i] );
            }
        }

        prw->Release();
    }
    
    return hr;
}

HRESULT CPropStoreRecoResultObject::_InitFromResultWrap(IUnknown *pResWrap)
{
    m_cpResultWrap.Release();

    m_cpResultWrap = pResWrap;
    
    if (m_cpResultWrap)
    {
        return S_OK;
    }
    else
        return E_INVALIDARG;
}        


// end of CPropStoreRecoResultObject implementation


//
// CPropStoreLMLattice implementation
//

// ctor
CPropStoreLMLattice::CPropStoreLMLattice(CSapiIMX *pimx)
{
    // init a shared recognition context
    m_cpResultWrap   = NULL;
    
    m_pimx = pimx;

    m_cRef  = 1;
}

// dtor
CPropStoreLMLattice::~CPropStoreLMLattice()
{
}


// IUnknown
STDMETHODIMP CPropStoreLMLattice::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;

    Assert(ppvObj);

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = this;
        hr = S_OK;

        this->m_cRef++;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CPropStoreLMLattice::AddRef(void)
{
    this->m_cRef++;

    return this->m_cRef;
}

STDMETHODIMP_(ULONG) CPropStoreLMLattice::Release(void)
{
    this->m_cRef--;

    if (this->m_cRef > 0)
    {
        return this->m_cRef;
    }
    delete this;

    return 0;
}

// ITfPropertyStore

STDMETHODIMP CPropStoreLMLattice::GetType(GUID *pguid)
{
    HRESULT hr = E_INVALIDARG;
    if (pguid)
    {
        *pguid = GUID_PROP_LMLATTICE;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CPropStoreLMLattice::GetDataType(DWORD *pdwReserved)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwReserved)
    {
        *pdwReserved = 0;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropStoreLMLattice::GetData(VARIANT *pvarValue)
{
    HRESULT hr = E_INVALIDARG;

    if (pvarValue)
    {
        QuickVariantInit(pvarValue);

        if (m_cpResultWrap)
        {
            // return ITfLMLattice object
            // we defer the creation of LMlattice object until
            // the time master LM TIP actually access it
            //
            if (!m_cpLMLattice)
            {
                CLMLattice *pLattice = new CLMLattice(m_pimx, m_cpResultWrap);
                if (pLattice)
                {
                    m_cpLMLattice = pLattice;
                    pLattice->Release();
                }

            }
            
            if (m_cpLMLattice)
            {
                IUnknown *pUnk = NULL;
                pvarValue->vt = VT_UNKNOWN;
                hr = m_cpLMLattice->QueryInterface(IID_IUnknown, (void**)&pUnk);
                if (S_OK == hr)
                {
                    pvarValue->punkVal = pUnk;
                }

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP CPropStoreLMLattice::OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept)
{
    *pfAccept = FALSE;
    if (dwFlags & TF_TU_CORRECTION)
    {
        *pfAccept = TRUE;
    }
    
    return S_OK;
}

STDMETHODIMP CPropStoreLMLattice::Shrink(ITfRange *pRange, BOOL *pfFree)
{
    // could we have something done here?
    *pfFree = TRUE;
    return S_OK;
}

STDMETHODIMP CPropStoreLMLattice::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore)
{
    // 12/17/1999
    // [dividing a range implementation strategy]
    //
    // - pRangeThis contains the text range *before* the dividing point
    // - pRangeNew contrains the range *after* the dividing point
    // - First, adjust this property store to correctly hold a start element and #of element
    //   for pRangeThis
    // - then create a new property store for pRangeNew, which will share the same 
    //   result blob. 
    //
    
    // just an experiment to see if cutting the range works.
    // *ppPropStore = NULL;
    Assert(ppPropStore);
    Assert(pRangeThis);
    Assert(pRangeNew);

    CComPtr<ITfContext> cpic;
    HRESULT hr = pRangeThis->GetContext(&cpic);

    if (SUCCEEDED(hr) && cpic)
    {
        CPSLMEditSession *pes;
        if (pes = new CPSLMEditSession(this, pRangeThis, cpic))
        {
            pes->_SetEditSessionData(ESCB_PROP_DIVIDE, NULL, 0); 
            pes->_SetUnk((IUnknown *)pRangeNew);
            cpic->RequestEditSession(m_pimx->_GetId(), pes, TF_ES_READ | TF_ES_SYNC, &hr);

            if ( SUCCEEDED(hr) )
                *ppPropStore = (ITfPropertyStore *)pes->_GetRetUnknown( );

            pes->Release();
        }
    }
    return hr;
}

//
// CPropStoreLMLattice::_Divide
//
// synopsis : receives edit cookie from edit session
//            so that we can manipulate with ranges
//            to set starting elements/# of elements
//
//
HRESULT CPropStoreLMLattice::_Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs) 
{
    // TODO: based on the given ranges, we calculate the offsets of elements and return a new propstore with
    //       later half of elements 
    
    // some clarifications: in case the lattice object has never been accessed, our result wrap object processes
    // ITfPropertyStore::Divide and Shrink for us. 
    //
    
    return Clone(ppPs);
}

//
// CPropStoreLMLattice::Clone
//
// synopsis : make a new cloned propstore which shares the same SAPI result
//            object as the current class instance
//
//
STDMETHODIMP CPropStoreLMLattice::Clone(ITfPropertyStore **ppPropStore)
{
    HRESULT hr;
    CPropStoreLMLattice *prps = new CPropStoreLMLattice(m_pimx);
    if (prps)
    {
        hr = prps->QueryInterface(IID_ITfPropertyStore, (void **)ppPropStore);

        if (SUCCEEDED(hr))
        {
            hr = prps->_InitFromResultWrap(m_cpResultWrap);
        }
        prps->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CPropStoreLMLattice::GetPropertyRangeCreator(CLSID *pclsid)
{
    HRESULT hr = E_INVALIDARG;

    if (pclsid)
    {
        *pclsid = CLSID_SapiLayr;
        hr = S_OK;
    }

    return hr;
}

//
// CPropStoreLMLattice::Serialize
//
// synopsis: I don't believe it is very useful to get lattice data
//           persisted to doc file. We can always generate it on the fly
//           from device native blob data
//          
//
STDMETHODIMP CPropStoreLMLattice::Serialize(IStream *pStream, ULONG *pcb)
{
    return E_NOTIMPL; 
}


HRESULT CPropStoreLMLattice::_InitFromResultWrap(IUnknown *pResWrap)
{
    m_cpResultWrap.Release();

    m_cpResultWrap = pResWrap;
    
    if (m_cpResultWrap)
    {
        return S_OK;
    }
    else
        return E_INVALIDARG;
}        


// private IID for reco result wrapper
//
//   IID_PRIV_RESULTWRAP 
//   b3407713-50d7-4465-97f9-87ad1e752dc5
//
const IID IID_PRIV_RESULTWRAP =  {
    0xb3407713,
    0x50d7,
    0x4465,
    {0x97, 0xf9, 0x87, 0xad, 0x1e, 0x75, 0x2d, 0xc5}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\propstor.h ===
//
// property store class implementation
//

#ifndef PROPSTOR_H
#define PROPSTOR_H

#include "strary.h"

extern const IID IID_PRIV_RESULTWRAP;

typedef enum 
{
    DivideNormal = 1,
    DivideInsideFirstElement=2 ,
    DivideInDelta = 3,
    CurRangeNoElement = 4,

}  DIVIDECASE;


// A Data structure to keep the ITN position and showstate.

typedef struct _tagSPITNSHOWSTATE
{
    ULONG     ulITNStart;
    ULONG     ulITNNumElem;
    BOOL      fITNShown;
} SPITNSHOWSTATE;

// A Data Structure to keep the data in Reco Wrapper which will be saved during serialization.

typedef struct _tagRecoWrapData
{

    ULONG  ulSize;  // size of this structure + plus the size of text string in bytes.
    ULONG  ulStartElement;
    ULONG  ulNumElements;
    ULONG  ulOffsetDelta;
    ULONG  ulCharsInTrail;
    ULONG  ulTrailSpaceRemoved;
    ULONG  ulNumOfITN;
    ULONG  ulOffsetNum;
    SPITNSHOWSTATE *pITNShowState;
    ULONG  *pulOffset;
    WCHAR  *pwszText;

}  RECOWRAPDATA;

class CSapiIMX;

//
// A wrapper object for ISpRecoResult used to 
// track what portion of a phrase object is being
// used for the range
//
class CRecoResultWrap : public IServiceProvider
{
public:
    CRecoResultWrap(CSapiIMX *pimx, ULONG ulStartElement, ULONG ulNumElements, ULONG ulNumOfITN) ;

    ~CRecoResultWrap();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IServiceProvider
    STDMETHODIMP QueryService( REFGUID guidService,  REFIID riid,  void** ppv );


    // Clone this object.
    HRESULT Clone(CRecoResultWrap **ppRw);
    
    // APIs
    HRESULT Init(ISpRecoResult *pRecoResult);

    ULONG   GetStart(void)       {return m_ulStartElement;}
    ULONG   GetNumElements(void) {return m_ulNumElements;}

    HRESULT GetResult(ISpRecoResult **ppRecoResult );

    BOOL   IsElementOffsetIntialized( ) {  return m_pulElementOffsets == NULL ? FALSE : TRUE; }

    void    SetStart(ULONG ulStartElement )  {  m_ulStartElement = ulStartElement; return; }
    void    SetNumElements(ULONG ulNumElements ) { m_ulNumElements = ulNumElements; return; }
    void    SetOffsetDelta( ULONG  delta ) { m_OffsetDelta = delta; return; }

    ULONG   _GetOffsetDelta( ) { return m_OffsetDelta; }

    void    SetCharsInTrail( ULONG  ulCharsInTrail ) { m_ulCharsInTrail = ulCharsInTrail; }
    ULONG   GetCharsInTrail( ) { return m_ulCharsInTrail; }

    ULONG   GetTrailSpaceRemoved( ) {  return m_ulTrailSpaceRemoved; }
    void    SetTrailSpaceRemoved( ULONG ulTrailSpaceRemoved ) { m_ulTrailSpaceRemoved = ulTrailSpaceRemoved; return; }
    
    HRESULT _SpeakAudio(ULONG ulStart, ULONG ulcElem);
    
    ULONG   _GetElementOffsetCch(ULONG ulElement);
    void    _SetElementOffsetCch(ISpPhraseAlt *pAlt);

    HRESULT _SetElementNewOffset(ULONG  ulElement, ULONG ulNewOffset);

    ULONG   _RangeHasITN(ULONG  ulStartElement, ULONG  ulNumElements);
    
    BOOL    _CheckITNForElement(SPPHRASE *pPhrase, ULONG ulElement, ULONG *pulITNStart, ULONG *pulITNNumElem, CSpDynamicString *pdstrReplace); 

    BYTE    _GetElementDispAttribute(ULONG  ulElement);

    HRESULT  _InitITNShowState(BOOL  fITNShown, ULONG ulITNStart, ULONG ulITNNumElements);
    HRESULT  _InvertITNShowStateForRange( ULONG  ulStartElement,  ULONG ulNumElements );

    HRESULT  _UpdateStateWithAltPhrase( ISpPhraseAlt  *pSpPhraseAlt );

    void  _UpdateInternalText(ISpPhrase *pPhrase);
    BOOL  _CanIgnoreChange(ULONG ich, WCHAR *pszChange, int cch);

    ULONG m_ulNumOfITN;         // the number of ITN in this range ( from start element to end element in this recowrap.

    CStructArray<SPITNSHOWSTATE> m_rgITNShowState;  

    BSTR  m_bstrCurrentText;     // the current text for the parent pharse
    
private:

    CSapiIMX *m_pimx;

    ULONG m_ulStartElement;
    ULONG m_ulNumElements;
    
    ULONG *m_pulElementOffsets;

    ULONG  m_OffsetDelta;         // This is for Divide use,  if prop is divided at a middle of an element,
                                  // this element would be discarded, but we need to keep the char number of the rest in this element,
                                  // so that the next range would keep correct offsets for every element.

    ULONG  m_ulCharsInTrail;      // This will keep the number of trailing part which is at the end part of the 
                                  // current parent text, and is not in any valid phrase element.
                                  // By default this value is 0.

    //
    //  Now a whole parent text would be composed of following three parts:
    //           Delta part   +  valid elements  + Trailing Part.
    //
    //  For example:   the original parent text is "This is a good example for testing ".
    //  After divided many times, it could become to the new string like:
    //
    //                  "s is a good example for tes"
    //
    //  Here "s " is Delta part.
    //       "a good example for " is composed of valid elements. ( and can be change by correction later)
    //       "tes"  is trailing part.
    //
    //  m_OffsetDelta will keep the number of characters in Delta part.
    //  m_ulCharsInTrail will keep the number of characters in Trailing part.
    //

    ULONG   m_ulTrailSpaceRemoved;  // Keep the number of trailing spaces which were
                                    // removed from the original phrase text.

                                    // The Initialize value for this data member is 0,
                                    // But after Property Divided or Shrinked, the new 
                                    // property range could have some trailing spaces
                                    // removed, and this data memeber needs to update.

    SPSERIALIZEDRESULT *m_pSerializedRecoResult;

    int m_cRef;

#ifdef DEBUG
    DWORD m_dbg_dwId;
#endif // DEBUG
};

//
// [12/21/99 - implementing propstore for non-serialized SAPI result object]
//
//
class CPropStoreRecoResultObject: public ITfPropertyStore
{
public:
    CPropStoreRecoResultObject(CSapiIMX *pimx, ITfRange *pRange);
    ~CPropStoreRecoResultObject();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfPropertyStore
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

    // public APIs
    HRESULT _InitFromRecoResult(ISpRecoResult *pResult, RECOWRAPDATA *pRecoWrapData);
    HRESULT _InitFromIStream(IStream *pStream, int iSize, ISpRecoContext *pRecoCtxt);
    HRESULT _InitFromResultWrap(IUnknown  *pResWrap);

    HRESULT _Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs);
    HRESULT _Shrink(TfEditCookie ec, ITfRange *pRange,BOOL *pfFree);
    HRESULT _OnTextUpdated(TfEditCookie ec, DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);

private:

    CComPtr<IUnknown>           m_cpResultWrap;
    CComPtr<ITfRange>           m_cpRange;
    
    CSapiIMX                   *m_pimx;

    int m_cRef;
};

class CPropStoreLMLattice: public ITfPropertyStore
{
public:
    CPropStoreLMLattice(CSapiIMX *pimx);
    ~CPropStoreLMLattice();

    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfPropertyStore
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRange, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRange, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppPropStore);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

    // public APIs
    HRESULT _InitFromResultWrap(IUnknown  *pResWrap);

    HRESULT _Divide(TfEditCookie ec, ITfRange *pR1, ITfRange *pR2, ITfPropertyStore **ppPs);
private:

    CComPtr<IUnknown>           m_cpResultWrap;
    CComPtr<ITfLMLattice>       m_cpLMLattice;
    
    CSapiIMX                   *m_pimx;
    int m_cRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\recosleep.cpp ===
// RecoSleep.cpp : implement "Go to Sleep" and "Wakeup" commands.

#include "private.h"
#include "globals.h"
#include "RecoSleep.h"
#include "mui.h"
#include "ids.h"
#include "cicspres.h"

CRecoSleepClass::CRecoSleepClass(CSpTask *pSpTask) 
{
    Assert(pSpTask);

    m_pSpTask = pSpTask;
    m_pSpTask->AddRef( );

    StringCchCopyW(m_wszRule, ARRAYSIZE(m_wszRule), L"SleepRule");
    m_wszSleep[0] = L'\0';
    m_wszWakeup[0] = L'\0';
    m_fSleeping = FALSE;
    m_Initialized = FALSE;
}

CRecoSleepClass::~CRecoSleepClass( )
{
    if ( m_cpRecoContext )
        m_cpRecoContext->SetNotifySink(NULL);

    SafeRelease(m_pSpTask);
}

HRESULT CRecoSleepClass::InitRecoSleepClass( )
{
    HRESULT  hr = S_OK;

    if ( m_Initialized )
        return hr;

    Assert(m_pSpTask);

    // Get the same Recognizer instance from CSpTask.

    hr = m_pSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&m_cpRecoEngine);

    if ( SUCCEEDED(hr) )
        hr = m_cpRecoEngine->CreateRecoContext(&m_cpRecoContext);

    // set recognition notification
    CComPtr<ISpNotifyTranslator> cpNotify;
    hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);

    // set this class instance to notify control object
    if (SUCCEEDED(hr))
        hr = cpNotify->InitCallback( NotifyCallback, 0, (LPARAM)this );

    if (SUCCEEDED(hr))
        hr = m_cpRecoContext->SetNotifySink(cpNotify);

    // set the events we're interested in
    if( SUCCEEDED( hr ) )
    {
        const ULONGLONG ulInterest = SPFEI(SPEI_RECOGNITION); 
        hr = m_cpRecoContext->SetInterest(ulInterest, ulInterest);
    }

    m_fSleeping = FALSE;

    CicLoadStringWrapW(g_hInst, IDS_GO_TO_SLEEP,   m_wszSleep,  ARRAYSIZE(m_wszSleep));
    CicLoadStringWrapW(g_hInst, IDS_WAKE_UP,       m_wszWakeup, ARRAYSIZE(m_wszWakeup));

    hr = m_cpRecoContext->CreateGrammar(GRAM_ID_SLEEP, &m_cpSleepGrammar);

    //Create the sleep dynamic rule
    if (SUCCEEDED(hr))
       hr = m_cpSleepGrammar->GetRule(m_wszRule, 0, SPRAF_TopLevel | SPRAF_Active, TRUE, &m_hSleepRule);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->SetRuleState(NULL, NULL, SPRS_INACTIVE);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->ClearRule(m_hSleepRule);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->AddWordTransition(m_hSleepRule, NULL, m_wszSleep, L" ", SPWT_LEXICAL, 1.0, NULL);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->AddWordTransition(m_hSleepRule, NULL, m_wszWakeup, L" ", SPWT_LEXICAL, 1.0, NULL);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->Commit(NULL);

    if (SUCCEEDED(hr))
        hr = m_cpSleepGrammar->SetRuleState(NULL, NULL, SPRS_ACTIVE);

    if ( SUCCEEDED(hr) )
        m_Initialized = TRUE;

    return hr;
}

void CRecoSleepClass::NotifyCallback(WPARAM wParam, LPARAM lParam )
{
    CRecoSleepClass *_this = (CRecoSleepClass *)lParam;
    CSpEvent event;

    if ( !_this->m_cpRecoContext)
        return;

    while (event.GetFrom(_this->m_cpRecoContext) == S_OK)
    {
        // We just care about SPEI_RECOGNITION event.
        if (event.eEventId == SPEI_RECOGNITION)
        {
            CComPtr<ISpRecoResult> cpRecoResult = event.RecoResult();
            if (cpRecoResult)
            {
                SPPHRASE *pPhrase = NULL;
                if (S_OK == cpRecoResult->GetPhrase(&pPhrase) )
                {
                    _this->ProcessSleepGrammar(pPhrase);
                    CoTaskMemFree(pPhrase);
                }
            }
        }
    }

    return;
}

HRESULT CRecoSleepClass::ProcessSleepGrammar( SPPHRASE *pPhrase )
{
    HRESULT hr = S_OK;

    Assert(pPhrase);
    ULONGLONG   ullGramId = pPhrase->ullGrammarID;

    if ( ullGramId != GRAM_ID_SLEEP )
        return hr;

    // Check the rule name 
    if (0 == wcscmp(pPhrase->Rule.pszName, m_wszRule) )
    {
        ULONG   ulStartElem, ulNumElems;
        CSpDynamicString dstrCommand;
               
        ulStartElem = pPhrase->Rule.ulFirstElement;
        ulNumElems = pPhrase->Rule.ulCountOfElements;

        for (ULONG i = ulStartElem; i < ulStartElem + ulNumElems; i++ )
        {
            if ( pPhrase->pElements[i].pszDisplayText)
            {
                BYTE bAttr = pPhrase->pElements[i].bDisplayAttributes;

                dstrCommand.Append(pPhrase->pElements[i].pszDisplayText);

                if ( i < ulStartElem + ulNumElems-1 )
                {
                    if (bAttr & SPAF_ONE_TRAILING_SPACE)
                        dstrCommand.Append(L" ");
                    else if (bAttr & SPAF_TWO_TRAILING_SPACES)
                        dstrCommand.Append(L"  ");
                }
            }
        }

        if ( dstrCommand )
        {
            BOOL   fProcessed = FALSE;

            if ((!wcscmp(dstrCommand, m_wszSleep)) && (!m_fSleeping))
            {
                hr = m_cpSleepGrammar->SetGrammarState(SPGS_EXCLUSIVE);
                m_fSleeping = TRUE;
                TraceMsg(TF_ALWAYS, "SetGrammarState to SPGS_EXCLUSIVE, hr=%x", hr);
                fProcessed = TRUE;
            }
            else if ((!wcscmp(dstrCommand, m_wszWakeup)) && (m_fSleeping))
            {
                hr = m_cpSleepGrammar->SetGrammarState(SPGS_ENABLED);
                m_fSleeping = FALSE;
                TraceMsg(TF_ALWAYS, "SetGrammarState to SPGS_ENABLED, hr=%x", hr);
                fProcessed = TRUE;
            }

            if ( fProcessed )
                m_pSpTask->_ShowCommandOnBalloon(pPhrase);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\sapilayr.cpp ===
//
//  sapilayr.cpp
//
//  implementation of CSapiIMX class body 
//

#include "private.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "globals.h"
#include "propstor.h"
#include "timsink.h"
#include "kes.h"
#include "nui.h"
#include "dispattr.h"
#include "lbarsink.h"
#include "miscfunc.h"
#include "nuibase.h"
#include "xstring.h"
#include "dictctxt.h"
#include "mui.h"
#include "cregkey.h"
#include "oleacc.h"

// {9597CB34-CF6A-11d3-8D69-00500486C135}
static const GUID GUID_OfficeSpeechMode = {
    0x9597cb34,
    0xcf6a,
    0x11d3,
    { 0x8d, 0x69, 0x0, 0x50, 0x4, 0x86, 0xc1, 0x35}
};

STDAPI CICPriv::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CICPriv::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CICPriv::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

CICPriv *GetInputContextPriv(TfClientId tid, ITfContext *pic)
{
    CICPriv *picp;
    IUnknown *punk;
    GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);

    if (!punk)
    {
        // need to init priv data
        if (picp = new CICPriv(pic))
        {
            SetCompartmentUnknown(tid, pic, GUID_IC_PRIVATE, picp);
        }
    }
    else
    {
        picp = (CICPriv *)punk;
    }

    return picp;
}

CICPriv *EnsureInputContextPriv(CSapiIMX *pimx, ITfContext *pic)
{
    CICPriv *picp = GetInputContextPriv(pimx->_GetId(), pic);
    
    return picp;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSapiIMX::CSapiIMX() : CFnConfigure(this),  CLearnFromDoc(this), CAddDeleteWord(this), CSelectWord(this),
                       CTextToSpeech(this), CCorrectionHandler(this)
{
    m_pCSpTask  = NULL;
    
    m_hwndWorker = NULL;

    _fDeactivated = TRUE;
    _fEditing = FALSE;
    _tid          = TF_CLIENTID_NULL;
    _cRef = 1;

    //
    // Init DisplayAttribute Provider
    //

    // default 
    COLORREF crBk = GetNewLookColor();
    COLORREF crText = GetTextColor();
    
    // add feedback UI colors
    TF_DISPLAYATTRIBUTE da;
    StringCchCopyW(szProviderName, ARRAYSIZE(szProviderName), L"SAPI Layer");

    SetAttributeColor(&da.crText, crText);
    SetAttributeColor(&da.crBk,   crBk);
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_SAPI_GREENBAR, L"SAPI Feedback Bar", &da);

    // color for level 2 application (for CUAS)
    crBk = GetNewLookColor(DA_COLOR_UNAWARE);

    SetAttributeColor(&da.crText, crText);
    SetAttributeColor(&da.crBk,   crBk);
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_SAPI_GREENBAR2, L"SAPI Feedback Bar for Unaware app", &da);
    
    SetAttributeColor(&da.crText, crText);
    SetAttributeColor(&da.crBk,   RGB(255, 0, 0));
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_SAPI_REDBAR, L"SAPI Red bar", &da);

    // create another dap for simulate 'inverted text' for selection
    SetAttributeColor(&da.crBk, GetSysColor( COLOR_HIGHLIGHT ));
    SetAttributeColor(&da.crText,   GetSysColor( COLOR_HIGHLIGHTTEXT ));
    da.lsStyle = TF_LS_NONE;
    da.fBoldLine = FALSE;
    ClearAttributeColor(&da.crLine);
    da.bAttr = TF_ATTR_TARGET_CONVERTED;
    Add(GUID_ATTR_SAPI_SELECTION, L"SPTIP selection ", &da);

    m_fSharedReco = TRUE;
    m_fShowBalloon = FALSE;

    m_pLanguageChangeNotifySink = NULL;

    m_pSpeechUIServer = NULL;
    m_szCplPath[0]    = _T('\0');
    m_pCapCmdHandler = NULL;
    m_fIPIsUpdated = FALSE;
    m_dwNumCharTyped = 0;
    m_ulSimulatedKey = 0;
    m_pSpButtonControl = NULL;
    m_fModeKeyRegistered = FALSE;

    m_fStartingComposition = FALSE;

    m_fStageTip = FALSE;
    m_fStageVisible = FALSE;
    m_hwndStage = NULL;

    m_ulHypothesisLen = 0;
    m_ulHypothesisNum = 0;

    m_IsInHypoProcessing = FALSE;

    _pCandUIEx = NULL;

    m_pMouseSink = NULL;
    m_fMouseDown = FALSE;
    m_ichMouseSel = 0;

    m_uLastEdge    = 0;
    m_lTimeLastClk = 0;

#ifdef SUPPORT_INTERNAL_WIDGET
    m_fNoCorrectionUI = FALSE;
#endif
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSapiIMX::~CSapiIMX()
{
    if (m_pSpeechUIServer)
    {
        m_pSpeechUIServer->SetIMX(NULL);
        m_pSpeechUIServer->Release();
        m_pSpeechUIServer = NULL;
    }
   
    ClearCandUI( );

    if (m_hwndWorker)
    {
        DestroyWindow(m_hwndWorker);
    }

    if ( m_pCapCmdHandler )
       delete m_pCapCmdHandler;
}


//+---------------------------------------------------------------------------
//
// PrivateAPI for profile stuff
//
//
//----------------------------------------------------------------------------
extern "C" 
HRESULT WINAPI TF_CreateLangProfileUtil(ITfFnLangProfileUtil **ppFnLangUtil)
{
    return CSapiIMX::CreateInstance(NULL, IID_ITfFnLangProfileUtil, (void **)ppFnLangUtil);
}

//+---------------------------------------------------------------------------
//
// OnSetThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::OnSetThreadFocus()
{
    TraceMsg(TF_SAPI_PERF, "OnSetThreadFocus is called");

    BOOL  fOn = GetOnOff( );

    // When Microphone is OFF, don't set any speech status to the local compartment.
    // this will cause Office App initialize their SAPI objects if the mode is C&C 
    // even if Microphone OFF.

    // Later when the Microphone is ON, this mode data will be updated correctly
    // inside the MICROPHONE_OPENCLOSE handling.
    //
    if ( fOn )
    {
        // TABLETPC
        // We switch states to match the global state whenever we get focus.
        // This may or may not trigger changes depending on the the stage visibility and dictation state.
        DWORD dwLocal, dwGlobal;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
        dwGlobal = dwGlobal & (TF_DICTATION_ON | TF_COMMANDING_ON);
        if ( (dwLocal & (TF_DICTATION_ON | TF_COMMANDING_ON)) != dwGlobal)
        {
            dwLocal = (dwLocal & ~(TF_DICTATION_ON | TF_COMMANDING_ON)) + dwGlobal;
            SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwLocal, FALSE);
            // Now we are guaranteed the local dictation state matches the global one.
        }
    }

#ifdef SYSTEM_GLOBAL_MIC_STATUS
    // 
    // The microphone UI status compartment is updated whenever the reco state 
    // changes. What we need to do here is to reset the dictation status
    // and others things that we skip doing when the thread doesn't have 
    // a focus
    //
    //
    MIC_STATUS ms = MICSTAT_NA;

    if (m_pCSpTask)
    {
         ms = m_pCSpTask->_GetInputOnOffState() ? MICSTAT_ON : MICSTAT_OFF;
    }
    _HandleOpenCloseEvent(ms);
#else
    _HandleOpenCloseEvent();
#endif

#ifdef SUPPORT_INTERNAL_WIDGET
    // create widget instance here
    if (!m_fNoCorrectionUI && !m_cpCorrectionUI)
    { 
        if (S_OK == m_cpCorrectionUI.CoCreateInstance(CLSID_CorrectionIMX))
        {
            // the real widget is installed
            m_cpCorrectionUI.Release();
            m_fNoCorrectionUI  = TRUE;
        }
        else if (SUCCEEDED(CCorrectionIMX::CreateInstance(NULL,  IID_ITfTextInputProcessor,  (void **)&m_cpCorrectionUI)))
        {
            m_cpCorrectionUI->Activate(_tim, _tid);
        }
    }
#endif
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKillThreadFocus
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::OnKillThreadFocus()
{
    // When the Application gets focus again, it will rely on the 
    // current status from compartment, and then decides which RecoContext
    // needs to be activated.
    //
    TraceMsg(TF_SAPI_PERF, "CSapiIMX::OnKillThreadFocus is called");

    // TABLETPC
    if (m_pCSpTask && S_OK != IsActiveThread())
    {
        m_pCSpTask->_SetDictRecoCtxtState(FALSE);
        m_pCSpTask->_SetCmdRecoCtxtState(FALSE);
    }

    // close candidate UI forcefully when focus shifts
    CloseCandUI( );

    return S_OK;
}

BOOL CSapiIMX::InitializeSpeechButtons()
{
    BOOL fSREnabled = _DictationEnabled();

    SetDICTATIONSTAT_DictEnabled(fSREnabled);
    
    // We need to see if the app has commanding if it is, then it 
    // needs the mic even when dictation is disabled
    //
    if (m_pSpeechUIServer)
    {
        BOOL fShow = (fSREnabled || IsDICTATIONSTAT_CommandingEnable());

        m_pSpeechUIServer->ShowUI(fShow);
    }

    return fSREnabled;
}
//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    ITfLangBarItemMgr *plbim = NULL;
    ITfKeystrokeMgr_P *pksm = NULL;
    ITfSourceSingle *sourceSingle;
    ITfSource *source;
    ITfContext *pic = NULL;
    BOOL fSREnabledForLanguage = FALSE;
    TfClientId tidLast = _tid;
    
    _tid = tid;

    // Load spgrmr.dll module for speech grammar.
    LoadSpgrmrModule();

    // register notify UI stuff
    HRESULT hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim);

    if (SUCCEEDED(hr))
    {
        plbim->GetItem(GUID_TFCAT_TIP_SPEECH, &m_cpMicButton);
        SafeRelease(plbim);
    }

    // regular stuff for activate
    Assert(_tim == NULL);
    _tim = ptim;
    _tim->AddRef();


    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &_dwThreadFocusCookie);
        source->AdviseSink(IID_ITfKeyTraceEventSink, (ITfKeyTraceEventSink *)this, &_dwKeyTraceCookie);
        source->Release();
    }

    // force data options to get set
    SetAudioOnOff(TRUE);

    // Register compartment sink for TIP status
    if (!(m_pCes = new CCompartmentEventSink(_CompEventSinkCallback, this)))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SAPI_AUDIO, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, TRUE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_LEARNDOC, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_CFGMENU, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE, TRUE);
#ifdef TF_DISABLE_SPEECH
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, FALSE);
#endif
    //TABLETPC
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGE, FALSE);
    m_pCes->_Advise(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, TRUE);
    // Get initial stage visibility. Note - keep after above _Advise for stage change event.
    DWORD  dw = 0;
    GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
    m_fStageVisible = dw ? TRUE : FALSE;
    // ENDTABLETPC
   
    //  profile activation sink 
    if (!m_pActiveLanguageProfileNotifySink)
    {
        if (!(m_pActiveLanguageProfileNotifySink = 
              new CActiveLanguageProfileNotifySink(_ActiveTipNotifySinkCallback, this)))
        {
            hr = E_OUTOFMEMORY;
            goto Exit; 
        }
        m_pActiveLanguageProfileNotifySink->_Advise(_tim);
    }
        
    if (!m_pSpeechUIServer &&
        FAILED(CSpeechUIServer::CreateInstance(NULL, 
                                               IID_PRIV_CSPEECHUISERVER, 
                                               (void **)&m_pSpeechUIServer)))
    {
        hr = E_OUTOFMEMORY;
        goto Exit; 
    }

    SetCompartmentDWORD(_tid,_tim,GUID_COMPARTMENT_SPEECH_LEARNDOC,_LMASupportEnabled(),FALSE);

    if (m_pSpeechUIServer)
    {
        m_pSpeechUIServer->SetIMX(this);
        m_pSpeechUIServer->Initialize();
        m_pSpeechUIServer->ShowUI(TRUE);
    }

    
    fSREnabledForLanguage = InitializeSpeechButtons();
    SetDICTATIONSTAT_DictEnabled(fSREnabledForLanguage);

    // language change notification sink 
    // this call better be after calling InitializeSpeechButtons because we
    // want to skip calling _EnsureProfiles to get ITfLanguageProfileNotifySink
    //
    if (!m_pLanguageChangeNotifySink)
    {
        if (!(m_pLanguageChangeNotifySink = 
              new CLanguageProfileNotifySink(_LangChangeNotifySinkCallback, this)))
        {
            hr = E_OUTOFMEMORY;
            goto Exit; 
        }
        m_pLanguageChangeNotifySink->_Advise(m_cpProfileMgr);
    }

    // now we inherit what is previously set as a mic status
    // 
#ifdef SYSTEM_GLOBAL_MIC_STATUS
    if (m_pCSpTask)
    {
        SetOnOff(m_pCSpTask->_GetInputOnOffState());
    }
#else
    // see if microphone is 'ON' and if so, check if we're indeed running
    // we check tidLast because it is normal we get activated again with
    // same client id, and it means we've kept our life across sessions
    // we don't want to reject global mic status in this case, otherwise
    // we'll see bugs like cicero#3386
    //
    if (GetOnOff() && tidLast != tid)
    {
        // this code has to stay before the first call to _EnsureWorkerWnd()
        HWND hwnd = FindWindow(c_szWorkerWndClass, NULL);
        if (!IsWindow(hwnd))
        {
           // no one is running us but we somehow persisted the state
           // let's just kill the 'on' state here
           // SetOnOff(FALSE);
        }
    }
#endif

    // show / hide balloon following global compartment
    m_fShowBalloon = GetBalloonStatus();
    
    // thread event sink init
    if ((m_timEventSink = new CThreadMgrEventSink(_DIMCallback, _ICCallback, this)) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    else
    {
        m_timEventSink->_Advise(_tim);
        m_timEventSink->_InitDIMs(TRUE);
    }
    
    if (SUCCEEDED(GetService(_tim, IID_ITfKeystrokeMgr_P, (IUnknown **)&pksm)))
    {
        if (_pkes = new CSptipKeyEventSink(_KeyEventCallback, _PreKeyEventCallback, this))
        {    
            pksm->AdviseKeyEventSink(_tid, _pkes, FALSE);

            _pkes->_Register(_tim, _tid, g_prekeyList);

            // register mode button hotkeys if they are enabled.
            HandleModeKeySettingChange(TRUE);

        }
        pksm->Release();
    }
    

    // func provider registeration
    IUnknown *punk;
    if (SUCCEEDED(QueryInterface(IID_IUnknown, (void **)&punk)))
    {
        if (SUCCEEDED(_tim->QueryInterface(IID_ITfSourceSingle, (void **)&sourceSingle)))
        {
            sourceSingle->AdviseSingleSink(_tid, IID_ITfFunctionProvider, punk);
            sourceSingle->Release();
        }
        punk->Release();
    }

    Assert(_fDeactivated);
    _fDeactivated = FALSE;

    // TABLETPC
    if (S_OK == IsActiveThread())
    {
        // init any UI
        OnSetThreadFocus();
    }
    
    hr = S_OK;

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CSapiIMX::Deactivate()
{
    ITfKeystrokeMgr *pksm = NULL;
    ITfSourceSingle *sourceSingle;    
    ITfSource *source;

    // this ensures no context feed activity is taken place
    SetDICTATIONSTAT_DictOnOff(FALSE);

    // finalize any pending compositions, this may be async
    CleanupAllContexts(_tim, _tid, this);

    // Free the system reconvertion function if it is set.

    _ReleaseSystemReconvFunc( );

    // delete SpButtonControl object

    if ( m_pSpButtonControl )
    {
        delete m_pSpButtonControl;
        m_pSpButtonControl = NULL;
    }

    // TABLETPC
    if (S_OK != IsActiveThread())
    {
        // shutdown any UI
        OnKillThreadFocus();
    }

    if (_tim->QueryInterface(IID_ITfSource, (void **)&source) == S_OK)
    {
        source->UnadviseSink(_dwThreadFocusCookie);
        source->UnadviseSink(_dwKeyTraceCookie);
        source->Release();
    }

    // unregister notify UI stuff
    if (m_pSpeechUIServer && !IsDICTATIONSTAT_CommandingEnable())
    {
        m_pSpeechUIServer->SetIMX(NULL);
        m_pSpeechUIServer->Release();
        m_pSpeechUIServer = NULL;
    }

#ifdef SUPPORT_INTERNAL_WIDGET
    // deactivate the widget correction
    if (m_cpCorrectionUI)
    {
        m_cpCorrectionUI->Deactivate();
        m_cpCorrectionUI.Release();
    }
#endif

    // regular stuff for activate
    ClearCandUI( );

    if (SUCCEEDED(_tim->QueryInterface(IID_ITfSourceSingle, (void **)&sourceSingle)))
    {
        sourceSingle->UnadviseSingleSink(_tid, IID_ITfFunctionProvider);
        sourceSingle->Release();
    }

    // thread event sink deinit
    if (m_timEventSink)
    {
        m_timEventSink->_InitDIMs(FALSE);
        m_timEventSink->_Unadvise();
        SafeReleaseClear(m_timEventSink);
    }

    if (_pkes != NULL)
    {
        _pkes->_Unregister(_tim, _tid, g_prekeyList);

        if ( m_fModeKeyRegistered )
        {
            _pkes->_Unregister(_tim, _tid, (const KESPRESERVEDKEY *)g_prekeyList_Mode);
            m_fModeKeyRegistered = FALSE;
        }
        
        SafeReleaseClear(_pkes);
    }

    if (SUCCEEDED(GetService(_tim, IID_ITfKeystrokeMgr, (IUnknown **)&pksm)))
    {
        pksm->UnadviseKeyEventSink(_tid);
        pksm->Release();
    }
    if (m_pCes)
    {
        m_pCes->_Unadvise();
        SafeReleaseClear(m_pCes);
    }

    if (m_pLBarItemSink)
    {
        m_pLBarItemSink->_Unadvise();
        SafeReleaseClear(m_pLBarItemSink);
    }

    if (m_pMouseSink)
    {
        m_pMouseSink->_Unadvise();
        SafeReleaseClear(m_pMouseSink);
    }
    
    // clean up active notify sink
    if (m_pActiveLanguageProfileNotifySink)
    {
        m_pActiveLanguageProfileNotifySink->_Unadvise();
        SafeReleaseClear(m_pActiveLanguageProfileNotifySink);
    }

    if (m_pLanguageChangeNotifySink)
    {
        m_pLanguageChangeNotifySink->_Unadvise();
        SafeReleaseClear(m_pLanguageChangeNotifySink);
    }

    if (m_hwndWorker)
    {
        DestroyWindow(m_hwndWorker);
        m_hwndWorker = NULL;
    }
    DeinitializeSAPI();

    SafeReleaseClear(_tim);

    TFUninitLib_Thread(&_libTLS);

    Assert(!_fDeactivated);
    _fDeactivated  = TRUE;

    return S_OK;
}

HRESULT CSapiIMX::InitializeSAPI(BOOL fLangOverride)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_SAPI_PERF, "CSapiIMX::InitializeSAPI is called");

    if (m_pCSpTask)
    {
        if (!m_pCSpTask->_IsCallbackInitialized())
        {
            hr = m_pCSpTask->InitializeCallback();
        }
        TraceMsg(TF_SAPI_PERF, "CSapiIMX::InitializeSAPI is initialized, hr=%x\n", hr);
        return hr;
    }


    HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // create CSpTask instance
        m_pCSpTask = new CSpTask(this);
    if (m_pCSpTask)
    {
//        LANGID m_langid;

        // check to see if profile lang matches with SR lang
        m_fDictationEnabled = _DictationEnabled(&m_langid);
    
        hr = m_pCSpTask->InitializeSAPIObjects(m_langid);

        if (S_OK == hr && !_fDeactivated &&
           (m_fDictationEnabled || IsDICTATIONSTAT_CommandingEnable()))
        {
            // set callback
            hr = m_pCSpTask->InitializeCallback();
        }

        if (S_OK == hr)
        {
            hr = m_pCSpTask->_LoadGrammars();
        }

        if (S_OK == hr)
        {
            // toolbar command
            m_pCSpTask->_InitToolbarCommand(fLangOverride);
        }
    }
    if (hCur)
        SetCursor(hCur);

    TraceMsg(TF_SAPI_PERF, "CSapiIMX::InitializeSAPI is done!!!!!  hr=%x\n", hr);
    return hr;
}


HRESULT CSapiIMX::DeinitializeSAPI()
{
    TraceMsg(TF_SAPI_PERF, "DeinitializeSAPI is called");
    if (m_pCSpTask)
    {
         // toolbar command 
        m_pCSpTask->_UnInitToolbarCommand();

        // set dication status
        SetDICTATIONSTAT_DictOnOff(FALSE);

        // - deinitialize SAPI
        m_pCSpTask->_ReleaseSAPI();

        delete m_pCSpTask;
        m_pCSpTask = NULL;
    }
    
    return S_OK;
}

HRESULT CSapiIMX::_ActiveTipNotifySinkCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv)
{
    if (IsEqualGUID(clsid, CLSID_SapiLayr))
    {
        CSapiIMX *pimx = (CSapiIMX *)pv;
        if (fActivated)
        {
            BOOL fSREnabledForLanguage = pimx->InitializeSpeechButtons();
        
            pimx->SetDICTATIONSTAT_DictEnabled(fSREnabledForLanguage);
        }
        else
        {
            // finalize any pending compositions, this may be async
            CleanupAllContexts(pimx->_tim, pimx->_tid, pimx);

            // when deactivating, we have to deinitialize SAPI so that 
            // we can re-initialize SAPI after getting a new assembly
            pimx->DeinitializeSAPI();
        }
    }
    return S_OK;
}


HRESULT CSapiIMX::_LangChangeNotifySinkCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv)
{
    CSapiIMX *pimx = (CSapiIMX *)pv;

     
    if (fChanged)
    {
        pimx->m_fDictationEnabled = pimx->InitializeSpeechButtons();
        
        pimx->SetDICTATIONSTAT_DictEnabled(pimx->m_fDictationEnabled);

        if (!pimx->m_fDictationEnabled)
        {
            // finalize any pending compositions, this may be async
            CleanupAllContexts(pimx->_tim, pimx->_tid, pimx);

            if (!pimx->IsDICTATIONSTAT_CommandingEnable())
                pimx->DeinitializeSAPI();

        }
/*   With the Global Mode state supporting, we don't want this message for languag switch handling.
        else
        {
            if (pimx->_GetWorkerWnd())
            {
                TraceMsg(TF_SAPI_PERF, "Send WM_PRIV_ONSETTHREADFOCUS message");
                PostMessage(pimx->_GetWorkerWnd(), WM_PRIV_ONSETTHREADFOCUS, 0, 0);
            }
        }
*/

    }
    
    return S_OK;
}

//
//
// ITfCreatePropertyStore implementation
//
//
STDMETHODIMP
CSapiIMX::CreatePropertyStore(
        REFGUID guidProp, 
        ITfRange *pRange,  
        ULONG cb, 
        IStream *pStream, 
        ITfPropertyStore **ppStore
)
{
    HRESULT hr = E_FAIL;
    //
    // 
    //
    if (IsEqualGUID(guidProp, GUID_PROP_SAPIRESULTOBJECT))
    {
        CPropStoreRecoResultObject *pPropStore;
        CComPtr<ISpRecoContext> cpRecoCtxt;
        
        // ensure SAPI is initialized
        InitializeSAPI(TRUE);
        
        hr = m_pCSpTask->GetSAPIInterface(IID_ISpRecoContext, (void **)&cpRecoCtxt);
        
        pPropStore = new CPropStoreRecoResultObject(this, pRange);
        if (pPropStore)
        {
            hr = pPropStore->_InitFromIStream(pStream, cb, cpRecoCtxt);
            
            if (SUCCEEDED(hr))
                hr = pPropStore->QueryInterface(IID_ITfPropertyStore, (void **)ppStore);

            pPropStore->Release();
        }
    }
    
    return hr;
}

STDAPI CSapiIMX::IsStoreSerializable(REFGUID guidProp, ITfRange *pRange, ITfPropertyStore *pPropStore, BOOL *pfSerializable)
{
    *pfSerializable = FALSE;
    if (IsEqualGUID(guidProp, GUID_PROP_SAPIRESULTOBJECT))
    {
        *pfSerializable = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CSapiIMX::GetType(GUID *pguid)
{
    HRESULT hr = E_INVALIDARG;
    if (pguid)
    {
        *pguid = CLSID_SapiLayr;
        hr = S_OK;
    }
    
    return hr;
}

STDMETHODIMP CSapiIMX::GetDescription(BSTR *pbstrDesc)
{
    const WCHAR c_wszNameSapiLayer[] = L"Cicero Sapi function Layer";
    HRESULT hr = S_OK;
    BSTR pbstr;
    if (!(pbstr = SysAllocString(c_wszNameSapiLayer)))
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSapiIMX::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    if (!ppunk)
        return E_INVALIDARG;

    *ppunk = NULL;

    HRESULT hr = E_NOTIMPL;

    if (!IsEqualGUID(rguid, GUID_NULL))
        return hr;

    if (IsEqualIID(riid, IID_ITfFnGetSAPIObject))
    {
        *ppunk = new CGetSAPIObject(this);
    }
    else
    {

        if (IsEqualGUID(riid, IID_ITfFnPlayBack))
        {
            *ppunk = new CSapiPlayBack(this);
        }
        else if (IsEqualGUID(riid, IID_ITfFnReconversion))
        {
            *ppunk = new CFnReconversion(this);
        }
        else if (IsEqualIID(riid, IID_ITfFnAbort))
        {
            *ppunk = new CFnAbort(this);
        }
        else if (IsEqualIID(riid, IID_ITfFnBalloon))
        {
            *ppunk = new CFnBalloon(this);
        }
        else if (IsEqualIID(riid, IID_ITfFnPropertyUIStatus))
        {
            *ppunk = new CFnPropertyUIStatus(this);
        }
        else
        {
            // This class decides if it's necessary to initialize
            // SAPI to retrieve the requested interface
            //
            CComPtr<CGetSAPIObject> cpGetSapi;
            cpGetSapi.Attach(new CGetSAPIObject(this));

            //
            //
            //
            if (cpGetSapi)
            {
                TfSapiObject tfSapiObj;

                // this returns S_FALSE if the iid does not match
                hr = cpGetSapi->IsSupported(riid, &tfSapiObj);

                if (S_OK == hr)
                {
                    // *ppunk is initialized w/ NULL in GetSAPIInterface()
                    // ppunk should get addref'd
                    hr = cpGetSapi->Get(tfSapiObj, ppunk);
                }
                else
                    hr = E_NOTIMPL;


                if (hr == E_NOTIMPL)
                {
                    // should we care?
                    // this indicates that the caller has requested an interface
                    // that we are not dealing with.
                    // The caller could just detect this failure and do their own stuff. 
                    TraceMsg(TF_GENERAL, "Caller requested SAPI interface Cicero doesn't handle");
                }
            }
        }
    }
    if (*ppunk)
    {
        hr = S_OK;
    }

    return hr;   
}

//+---------------------------------------------------------------------------
//
// _TextEventSinkCallback
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::_TextEventSinkCallback(UINT uCode, void *pv, void *pvData)
{
    TESENDEDIT *pee = (TESENDEDIT *)pvData;
    HRESULT hr = E_FAIL;

    Assert(uCode == ICF_TEXTDELTA); // the only one we asked for

    CSapiIMX *pimx = (CSapiIMX *)pv;

    if (pimx->_fEditing)
        return S_OK;

    pimx->HandleTextEvent(pee->pic, pee);

    hr = S_OK;

    return hr;
}

void CSapiIMX::HandleTextEvent(ITfContext *pic, TESENDEDIT *pee)
{
    ITfRange *pRange = NULL;
    
    Assert(pic);
    Assert(pee);

	if (!m_pCSpTask)
	{
		return;
	}

	// Get the selection/IP if it's updated
    BOOL fUpdated = FALSE;
	if (S_OK == _GetSelectionAndStatus(pic, pee, &pRange, &fUpdated))
	{
		// Handle context feed
        if (fUpdated)
        {
            _FeedIPContextToSR(pee->ecReadOnly, pic, pRange);

            BOOL   fEmpty = FALSE;
            BOOL   fSelection;

            // Get current selection status.
            if  ( pRange != NULL )
                pRange->IsEmpty(pee->ecReadOnly, &fEmpty);

            fSelection = !fEmpty;

            if ( fSelection != m_pCSpTask->_GetSelectionStatus( ) )
            {
                m_pCSpTask->_SetSelectionStatus(fSelection);
                m_pCSpTask->_SetSpellingGrammarStatus(GetDICTATIONSTAT_DictOnOff());
            }
        } 

		// Handle mode bias property data
		SyncWithCurrentModeBias(pee->ecReadOnly, pRange, pic);

		SafeRelease(pRange);
	}

    // m_fIPIsUpdated just keeps if there is IP change by other tips or keyboard typing
    // since last dictation. It doesn't care about the ip change caused by speech tip itself,
    // those ip changes would include feedback ui inject and final text inject.
    // 
    // Every time when a dictation or spelling phrase is recognized, this value should be
    // reset to FALSE.
    //
    // Here m_fIPIsUpdated should not just keep the last value returned by _GetSelectionAndStatus,
    // There is a scenario like, user move the ip to other place and then speak a command ( with some
    // some hypothesis feedback before the command is recognized).
    // In this case we should treat it as ip changed since last dictation, but the last value returned
    // from _GetSelectionAndStatus could be FALSE, because _GetSelectionAndStatus treats Sptip-injected 
    // feedback tex as non-ipchanged.
    //
    // So only when m_fIPIsUpdated is FALSE, we get new value from _GetSelectionAndStatus, 
    // otherwise, keep it till the next dictation.

    if ( m_fIPIsUpdated == FALSE )
       m_fIPIsUpdated = fUpdated;

}

void CSapiIMX::_FeedIPContextToSR(TfEditCookie ecReadOnly, ITfContext *pic, ITfRange *pRange)
{
    if (GetOnOff() == TRUE && _ContextFeedEnabled())
    {
        CDictContext *pdc = new CDictContext(pic, pRange);
        if (pdc)
        {
            if (GetDICTATIONSTAT_DictOnOff() == TRUE &&
                S_OK == pdc->InitializeContext(ecReadOnly))
            {
                Assert(m_pCSpTask);
                m_pCSpTask->FeedDictContext(pdc);
            }
            else
               delete pdc;
       
        }
    }
}

void CSapiIMX::_SetCurrentIPtoSR(void)
{
    _RequestEditSession(ESCB_FEEDCURRENTIP, TF_ES_READ);
}

HRESULT CSapiIMX::_InternalFeedCurrentIPtoSR(TfEditCookie ecReadOnly, ITfContext *pic)
{
    CComPtr<ITfRange> cpRange;
    HRESULT hr = GetSelectionSimple(ecReadOnly, pic, &cpRange);

    if (S_OK == hr)
    {
        _FeedIPContextToSR(ecReadOnly, pic, cpRange);
    }
    return hr;
}


BOOL CSapiIMX::HandleKey(WCHAR ch)
{
    m_ulSimulatedKey = 1;
    keybd_event((BYTE)ch, 0, 0, 0);
    keybd_event((BYTE)ch, 0, KEYEVENTF_KEYUP, 0);
    return TRUE;
}

const TCHAR c_szcplsKey[]    = TEXT("software\\microsoft\\windows\\currentversion\\control panel\\cpls");
void CSapiIMX::GetSapiCplPath(TCHAR *szCplPath, int cchSizePath)
{
    if (!m_szCplPath[0])
    {
        CMyRegKey regkey;
        if (S_OK == regkey.Open(HKEY_LOCAL_MACHINE, c_szcplsKey, KEY_READ))
        {
            LONG lret = regkey.QueryValueCch(m_szCplPath, TEXT("SapiCpl"), ARRAYSIZE(m_szCplPath));

            if (lret != ERROR_SUCCESS)
               lret = regkey.QueryValueCch(m_szCplPath, TEXT("Speech"), ARRAYSIZE(m_szCplPath));

            if (lret != ERROR_SUCCESS)
                m_szCplPath[0] = _T('\0'); // maybe we get lucky next time
        }
    }
    StringCchCopy(szCplPath, cchSizePath, m_szCplPath);
}



HRESULT CSapiIMX::_GetSelectionAndStatus(ITfContext *pic, TESENDEDIT *pee, ITfRange **ppRange, BOOL *pfUpdated)
{
    
    BOOL    fWriteSession;
    HRESULT hr = pic->InWriteSession(_tid, &fWriteSession);

    Assert(pfUpdated);
    *pfUpdated = FALSE;

    if (S_OK == hr)
    {
        // we don't want to pick up changes done by ourselves
        if (!fWriteSession)
        {
            hr = pee->pEditRecord->GetSelectionStatus(pfUpdated);
        }
        else
        {
            // returns S_FALSE when in write session
            hr = S_FALSE;
        }
    }

    if (S_OK == hr )
    {
        Assert(ppRange);
        hr = GetSelectionSimple(pee->ecReadOnly, pic, ppRange);
    }

    return hr;
}

void CSapiIMX::SyncWithCurrentModeBias(TfEditCookie ec, ITfRange *pRange, ITfContext *pic)
{
    ITfReadOnlyProperty *pProp = NULL;
    VARIANT var;
    QuickVariantInit(&var);

    if (pic->GetAppProperty(GUID_PROP_MODEBIAS, &pProp) != S_OK)
    {
        pProp = NULL;
        goto Exit;
    }

    pProp->GetValue(ec, pRange, &var);

    if (_gaModebias != (TfGuidAtom)var.lVal)
    {
        GUID guid;
        _gaModebias = (TfGuidAtom)var.lVal;
        GetGUIDFromGUIDATOM(&_libTLS, _gaModebias, &guid);
 
        BOOL fActive;
        if (!IsEqualGUID(guid, GUID_MODEBIAS_NONE))
        {
            fActive = TRUE;
        }
        else
        {
            fActive = FALSE;
        }
        // mode bias has to be remembered
        if (m_pCSpTask)
            m_pCSpTask->_SetModeBias(fActive, guid);
    }
Exit:
    VariantClear(&var);
    SafeRelease(pProp);
}



HRESULT CSapiIMX::_HandleTrainingWiz()
{
    WCHAR sz[64];
    sz[0] = '\0';
    CicLoadStringWrapW(g_hInst, IDS_UI_TRAINING, sz, ARRAYSIZE(sz));

    CComPtr<ISpRecognizer>    cpRecoEngine;
    HRESULT hr = m_pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpRecoEngine);
    if (S_OK == hr && cpRecoEngine)
    {
        DWORD dwDictStatBackup = GetDictationStatBackup();

        DWORD dwBefore;

        if (S_OK != GetCompartmentDWORD(_tim, 
                                        GUID_COMPARTMENT_SPEECH_DISABLED, 
                                        &dwBefore, 
                                        FALSE) )
        {
            dwBefore = 0;
        }

        SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_DISABLED, TF_DISABLE_DICTATION, FALSE);

        cpRecoEngine->DisplayUI(_GetAppMainWnd(), sz, SPDUI_UserTraining, NULL, 0);

        SetCompartmentDWORD(0, _tim, GUID_COMPARTMENT_SPEECH_DISABLED, dwBefore, FALSE);
        SetDictationStatAll(dwDictStatBackup);
    }

    return hr;
}

HRESULT CSapiIMX::_RequestEditSession(UINT idEditSession, DWORD dwFlag, ESDATA *pesData, ITfContext *picCaller, LONG_PTR *pRetData, IUnknown **ppRetUnk)
{
    CSapiEditSession    *pes;
    CComPtr<ITfContext> cpic;
    HRESULT             hr = E_FAIL;

    // callers can intentionally give us a NULL pic
    if (picCaller == NULL)
    {
        GetFocusIC(&cpic);
    }
    else
	{
        cpic = picCaller;
	}

    if (cpic)
    {
        if (pes = new CSapiEditSession(this, cpic))
        {
            if ( pesData )
            {
                pes->_SetRange(pesData->pRange);
                pes->_SetUnk(pesData->pUnk);
                pes->_SetEditSessionData(idEditSession, pesData->pData, pesData->uByte, pesData->lData1, pesData->lData2, pesData->fBool);
            }
            else
                pes->_SetEditSessionData(idEditSession, NULL, 0);

            cpic->RequestEditSession(_tid, pes, dwFlag, &hr);

            // if caller wants to get the return value from the edit session, it has to set SYNC edit session.
            if ( pRetData )
                *pRetData = pes->_GetRetData( );

            if ( ppRetUnk )
                *ppRetUnk = pes->_GetRetUnknown( );

            pes->Release();
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// _DIMCallback
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::_DIMCallback(UINT uCode, ITfDocumentMgr *dim, ITfDocumentMgr * pdimPrevFocus, void *pv)
{
    CSapiIMX *_this = (CSapiIMX *)pv;

    switch (uCode)
    {
        case TIM_CODE_INITDIM:
            //
            // Add this dim to the LearnFromDoc internal dim list with fFeed as FALSE.
            TraceMsg(TF_GENERAL, "TIM_CODE_INITDIM callback is called, DIM is %x", (INT_PTR)dim);
            _this->_AddDimToList(dim, FALSE);

            break;
            // clean up any reference to ranges
        case TIM_CODE_UNINITDIM:

            TraceMsg(TF_GENERAL, "TIM_CODE_UNINITDIM callback is called, DIM is %x", (INT_PTR)dim);
            _this->_RemoveDimFromList(dim);

            if (_this->m_pCSpTask)
                _this->m_pCSpTask->CleanupDictContext();

            //DIM is to destroyed, we want to stop speaking if TTS is playing
            if ( _this->_IsInPlay( ) )
            {
                _this->_HandleEventOnPlayButton( );
            }

            break;

        case TIM_CODE_SETFOCUS:
            TraceMsg(TF_GENERAL, "TIM_CODE_SETFOCUS callback is called, DIM is %x", (INT_PTR)dim);

            if ( !_this->m_fStageTip )
            {
                // The stage tip is a special instance of a RichEdit control that wants to stay active (i.e. enabled)
                // regardless of focus elsewhere in the hosting application. This way dictaion always goes to the stage.
                // This relies on a written-in-stone contract that only one Cicero enabled text input control exists in
                // said application.
                _this->SetDICTATIONSTAT_DictEnabled(dim ? _this->m_fDictationEnabled : FALSE);
            }

            // When TIM_CODE_SETFOCUS is called means there is a document focus change.
            // No matter what DIM is getting focus now, we just need to close the existing 
            // candidate list menu.
            // NOTE - for the TabletTip stage instance, do we want to close the candidate UI. This means when the user clicks in
            // the area surrounding the stage RichEdit or on the titlebar, the correction menu (and widget) get dismissed.
            // This means when TabletTip is dragged around with either of these visible, the correction widget or menu gets dismissed
            // since the first step of the drag is a click in the titlebar. NOTE - if we disable this code here it still gets dismissed
            // so there is another handler somewhere triggering that.

            _this->CloseCandUI( );

            if ( dim )
            {
                // A DIM is getting focus, when LearnFromDoc is set, we need to feed 
                // the existing document to the Dictation grammar.

                // And we need to check if we already feed the document for this dim to the SREngine.
                // if we did, we don't feed it again for the same document.

                if ( _this->GetLearnFromDoc( ) == TRUE )
                {
                    HRESULT  hr = S_OK;

                    hr = _this->HandleLearnFromDoc( dim );
                }
                else
                    TraceMsg(TF_GENERAL, "Learn From DOC is set to FALSE");

                // We want to check if this new DIM is AIMM aware or pure Cicero aware,
                // so that we can determine if we want to disble TTS buttons.
                ITfContext  *pic;

                dim->GetTop(&pic);

                if ( pic )
                {
                    _this->_SetTTSButtonStatus( pic );


                    // for the top ic, we hook the modebias change
                    // notification so that we can set up the corresponding
                    // grammar for the bias
                    //
                    if (_this->GetDICTATIONSTAT_DictOnOff())
                        _this->_SyncModeBiasWithSelection(pic);

                    SafeRelease(pic);
                }

            }

            break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _ICCallback
//
//----------------------------------------------------------------------------

/* static */
HRESULT CSapiIMX::_ICCallback(UINT uCode, ITfContext *pic, void *pv)
{
    HRESULT hr = E_FAIL;
    CSapiIMX *_this = (CSapiIMX *)pv;
    CICPriv *priv;
    ITfContext *picTest;

    switch (uCode)
    {
        case TIM_CODE_INITIC:
            if ((priv = EnsureInputContextPriv(_this, pic)) != NULL)
            {
                _this->_InitICPriv(priv, pic);
                priv->Release();

                // We want to check if this IC is under a foucs DIM, and if it is AIMM aware or pure Cicero aware,
                // so that we can determine if we want to disble TTS buttons.
                ITfDocumentMgr  *pFocusDIM = NULL, *pThisDIM = NULL;

                _this->GetFocusDIM(&pFocusDIM);

                pic->GetDocumentMgr(&pThisDIM);

                if ( pFocusDIM == pThisDIM )
                {
                    _this->_SetTTSButtonStatus( pic );
                }

                SafeRelease(pFocusDIM);
                SafeRelease(pThisDIM);

                hr = S_OK;
            }
            break;

        case TIM_CODE_UNINITIC:
            // start setfocus code
            if ((priv = GetInputContextPriv(_this->_tid, pic)) != NULL)
            {
                _this->_DeleteICPriv(priv, pic);
                priv->Release();
                hr = S_OK;
            }

            if (_this->m_cpRangeCurIP != NULL) // should m_cpRangeCurIP be per-ic and stored in icpriv?
            {
                // free up m_cpRangeCurIP if it belongs to this context
                if (_this->m_cpRangeCurIP->GetContext(&picTest) == S_OK)
                {
                    if (pic == picTest)
                    {
                        _this->m_cpRangeCurIP.Release();
                    }
                    picTest->Release();
                }
            }

            // IC is getting popped. We need to reset cicero awareness
            // status based on the bottom IC. This assumes IC stack to
            // be 2 at maximum.
            //
            if (pic)
            {
                CComPtr<ITfContext>  cpicTop;
                CComPtr<ITfDocumentMgr> cpdim;

                hr = pic->GetDocumentMgr(&cpdim);

                if (S_OK == hr)
                {
                    cpdim->GetBase(&cpicTop);
                }

                if ( cpicTop )
                {
                    _this->_SetTTSButtonStatus( cpicTop );
                }
            }
            break;

    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _DeleteICPriv
//
//----------------------------------------------------------------------------

void CSapiIMX::_DeleteICPriv(CICPriv *priv, ITfContext *pic)
{

    if (!priv)
        return;

    if (priv->m_pTextEvent)
    {
        priv->m_pTextEvent->_Unadvise();
        SafeReleaseClear(priv->m_pTextEvent); 
    }

    // we MUST clear out the private data before cicero is free to release the ic
    ClearCompartment(_tid, pic, GUID_IC_PRIVATE, FALSE);

    // this is it, we won't need the private data any longer
}

//+---------------------------------------------------------------------------
//
// _InitICPriv
//
//----------------------------------------------------------------------------

void CSapiIMX::_InitICPriv(CICPriv *priv, ITfContext *pic)
{

    if (!priv->m_pTextEvent)
    {
        if ((priv->m_pTextEvent = new CTextEventSink(CSapiIMX::_TextEventSinkCallback, this)) != NULL)
        {
            priv->m_pTextEvent->_Advise(pic, ICF_TEXTDELTA);
        }
    }
}


//+---------------------------------------------------------------------------
//
// _KillFocusRange
//
// get rid of the focusrange within the given range
//
//---------------------------------------------------------------------------+

HRESULT CSapiIMX::_KillFocusRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid)
{
    HRESULT hr = E_FAIL;
    IEnumITfCompositionView *pEnumComp = NULL;
    ITfContextComposition *picc = NULL;
    ITfCompositionView *pCompositionView;
    ITfComposition *pComposition;
    CLSID clsid;
    CICPriv *picp;

    //
    // clear any sptip compositions over the range
    //

    if (pic->QueryInterface(IID_ITfContextComposition, (void **)&picc) != S_OK)
        goto Exit;

    if (picc->FindComposition(ec, pRange, &pEnumComp) != S_OK)
        goto Exit;

    // tid will be TF_CLIENTID_NULL when we're deactivated, in which case we
    // don't want to mess with the composition count
    picp = (tid == TF_CLIENTID_NULL) ? NULL : GetInputContextPriv(tid, pic);

    while (pEnumComp->Next(1, &pCompositionView, NULL) == S_OK)
    {
        if (pCompositionView->GetOwnerClsid(&clsid) != S_OK)
            goto NextComp;

        // make sure we ignore other TIPs' compositions!
        if (!IsEqualCLSID(clsid, CLSID_SapiLayr))
            goto NextComp;

        if (pCompositionView->QueryInterface(IID_ITfComposition, (void **)&pComposition) != S_OK)
            goto NextComp;

        // found a composition, terminate it
        pComposition->EndComposition(ec);
        pComposition->Release();

        if (picp != NULL)
        {
            picp->_ReleaseComposition();
        }

NextComp:
        pCompositionView->Release();
    }

    SafeRelease(picp);

    hr = S_OK;

Exit:
    SafeRelease(picc);
    SafeRelease(pEnumComp);

    return hr;
}


//+---------------------------------------------------------------------------
//
// _SetFocusToStageIfStage
//
// Many voice commands (particularly selection and correction) do not make
// sense unless the focus is in the stage. This adjusts focus so the commands
// work as the user will expect.
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_SetFocusToStageIfStage(void)
{
    HRESULT hr = S_OK;

    if (m_fStageTip)
    {
        ASSERT(m_hwndStage && L"Have null HWND for stage.");
        if (m_hwndStage)
        {
            CComPtr<IAccessible> cpAccessible;
            hr = AccessibleObjectFromWindow(m_hwndStage, OBJID_WINDOW, IID_IAccessible, (void **)&cpAccessible);
            if (SUCCEEDED(hr) && cpAccessible)
            {
                CComVariant cpVar = CHILDID_SELF;
                hr = cpAccessible->accSelect(SELFLAG_TAKEFOCUS, cpVar);
            }

        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _SetFilteringString
//
// When non-matching event is notified, this function is called to inject 
// previous filtering string to the parent document.
//
//---------------------------------------------------------------------------+
HRESULT CSapiIMX::_SetFilteringString(TfEditCookie ec, ITfCandidateUI *pCandUI, ITfContext *pic)
{
    HRESULT hr = E_FAIL;

    ITfRange *pRange;

    BSTR bstr;

    CDocStatus ds(pic);
    if (ds.IsReadOnly())
       return S_OK;

    if (SUCCEEDED(GetSelectionSimple(ec, pic, &pRange )))
    {
        CComPtr<ITfProperty> cpProp;
        LANGID langid = 0x0409;

        // get langid from the given range
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &cpProp)))
        {
            GetLangIdPropertyData(ec, cpProp, pRange, &langid);
        }
        
        CComPtr<ITfCandUIFnAutoFilter> cpFnFilter;
        hr = _pCandUIEx->GetFunction(IID_ITfCandUIFnAutoFilter, (IUnknown **)&cpFnFilter);

 
        if (S_OK == hr && SUCCEEDED(cpFnFilter->GetFilteringString( CANDUIFST_DETERMINED, &bstr )))
        {
            hr = SetTextAndProperty(&_libTLS, ec, pic, pRange, bstr, SysStringLen(bstr), langid, NULL);
            SysFreeString( bstr );
        }

        pRange->Collapse( ec, TF_ANCHOR_END );
        SetSelectionSimple(ec, pic, pRange);

        // we don't want to inject undetermined string to the document anymore. 
        // Cicero will inject the non-matching keyboard char
        // to the document right after the determined filter string.

        pRange->Release();
    }
    return hr;
}


//----------------------------------------------------------------------------
//
// _CompEventSinkCallback (static)
//
//----------------------------------------------------------------------------
HRESULT CSapiIMX::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CSapiIMX *_this = (CSapiIMX *)pv;
    BOOL fOn;

    if (IsEqualGUID(rguid, GUID_COMPARTMENT_SAPI_AUDIO))
    {
        fOn = _this->GetAudioOnOff();

        if (_this->m_pCSpTask)
            _this->m_pCSpTask->_SetAudioRetainStatus(fOn);
        return S_OK;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_OPENCLOSE))
    {
        HRESULT hr = S_OK;

#ifdef SAPI_PERF_DEBUG
        DWORD dw;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw, TRUE);
        TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_OPENCLOSE event : %i. \n", dw);
#endif        
        // TABLETPC
        if ( S_OK != _this->IsActiveThread() )
        {
            TraceMsg(TF_GENERAL, "SPEECH_OPENCLOSE, App doesn't get Focus!");
            return hr;
        }

        TraceMsg(TF_GENERAL, "SPEECH_OPENCLOSE, App GETs Focus!");

        DWORD dwLocal, dwGlobal;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dwLocal, FALSE);
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGlobal, TRUE);
        dwGlobal = dwGlobal & (TF_DICTATION_ON + TF_COMMANDING_ON);

        if ( (dwLocal & (TF_DICTATION_ON + TF_COMMANDING_ON)) != dwGlobal)
        {
            dwLocal = (dwLocal & ~(TF_DICTATION_ON + TF_COMMANDING_ON)) + dwGlobal;
            SetCompartmentDWORD(_this->_tid, _this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dwLocal, FALSE);
        }


        // first time...
        if (!_this->m_pCSpTask)
        {
            //
            // put "Starting Speech..." in the balloon
            //
            if (_this->GetOnOff() && _this->GetBalloonStatus())
            {
       
               _this->SetBalloonStatus(TRUE, TRUE); // force update

               // make sure balloon is shown
               _this->GetSpeechUIServer()->ShowUI(TRUE);

               // Ask the speech ui server to set the SAPI initializing 
               // flag to the balloon so it'll do it at the first callback
               //
               hr = _this->GetSpeechUIServer()->SetBalloonSAPIInitFlag(TRUE);

               WCHAR sz[128];
               sz[0] = '\0';
               CicLoadStringWrapW(g_hInst, IDS_NUI_STARTINGSPEECH, sz, ARRAYSIZE(sz));
               _this->GetSpeechUIServer()->UpdateBalloon(TF_LB_BALLOON_RECO, sz, -1);
               TraceMsg(TF_SAPI_PERF, "Show Starting speech ...");
            }

            // TABLETPC
            // BUGBUG - Do we need this now I have fixed the _HandleOpenCloseEvent to work in whichever sptip actually has focus?
            if (_this->m_fStageTip)
            {
                // Since the stage may not have focus, the delayed mechanism above will not result
                // in dictation activating in the stage since the delayed activation will happen in the
                // cicero app with focus - except that the stage is visible hence the app with focus
                // will simply ignore it. Not what we want when the stage is activating.

                // Ignore above hresult in case of failure - this is the more important call.
                hr =  _this->_HandleOpenCloseEvent();
            }
        }
        else 
        {
            hr =  _this->_HandleOpenCloseEvent();
        }


        // Office App uses its own global compartment GUID_OfficeSpeechMode to keep the current mode,
        // so that next time the application starts, it checks this value to initalize SAPI objects 
        // even if Microphone is OFF.

        // Since we have already used our own global compartment GUID_COMPARTMENT_SPEECH_GLOBALSTATE to 
        // keep the speech mode system wide, there is no need for Office to use that global compartment 
        // for its own usage that way.
        //
        // So when Microphone is OFF, we just reset the global compartment GUID_OfficeSpeechMode.
        if ( !_this->GetOnOff( ) )
        {
            SetCompartmentDWORD(_this->_tid, _this->_tim, GUID_OfficeSpeechMode, 0, TRUE);
        }
        
        // when we have a temporary composistion such as
        // CUAS level2 or AIMM level3, we don't want to
        // finalize on going composition each time mic turns off
        // because it also shutdown chance for correction
        //
        if (S_OK == hr && _this->IsFocusFullAware(_this->_tim))
        {
            hr = _this->_FinalizeComposition();
        }
        return hr;
    }
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGE))
    {
        DWORD  dw = 0;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_STAGE, &dw, FALSE);
        Assert(dw && L"NULL HWND passed in GUID_COMPARTMENT_SPEECH_STAGE");
        if (dw != 0)
        {
            _this->m_hwndStage = (HWND) dw;
            _this->m_fStageTip = TRUE;
        }
    }
    // TABLETPC
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_STAGECHANGE))
    {
        HRESULT hr = S_OK;
        DWORD dw;

        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_STAGECHANGE, &dw, TRUE);
		_this->m_fStageVisible = dw ? TRUE:FALSE;
        if (S_OK == _this->IsActiveThread())
        {
            _this->OnSetThreadFocus();
        }
        else
        {
            _this->OnKillThreadFocus();
        }
    }
    // TABLETPC
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT))
    {
        _this->m_fDictationEnabled = _this->GetDICTATIONSTAT_DictEnabled();

#ifdef SAPI_PERF_DEBUG
        DWORD   dw;
        GetCompartmentDWORD(_this->_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_DICTATIONSTAT is set in SAPIIMX, dw=%x", dw);
#endif

        HRESULT hr;

        // TABLETPC
        hr = _this->IsActiveThread();

        if ( hr == S_OK )
        {
            BOOL    fDictOn, fCmdOn;
            BOOL    fDisable;

            fOn = _this->GetOnOff();
            fDisable = _this->Get_SPEECH_DISABLED_Disabled();

            fDictOn = fOn && _this->GetDICTATIONSTAT_DictOnOff() && _this->GetDICTATIONSTAT_DictEnabled( ) && !fDisable && !_this->Get_SPEECH_DISABLED_DictationDisabled();
            fCmdOn = fOn  && _this->GetDICTATIONSTAT_CommandingOnOff( ) && !fDisable && !_this->Get_SPEECH_DISABLED_CommandingDisabled(); 

            if ( _this->m_pCSpTask )
            {
                hr = _this->m_pCSpTask->_SetDictRecoCtxtState(fDictOn);
                if ( hr == S_OK )
                    hr = _this->m_pCSpTask->_SetCmdRecoCtxtState(fCmdOn);

                if ((fDictOn || fCmdOn ) && _this->m_pSpeechUIServer)
                {
                    WCHAR sz[128];
                    sz[0] = '\0';

                    if (fDictOn)
                    {
                        CicLoadStringWrapW(g_hInst, IDS_NUI_DICTATION_TEXT, sz, ARRAYSIZE(sz));
                    
                        hr = _this->m_pSpeechUIServer->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                        TraceMsg(TF_SAPI_PERF, "Show \"Dictation\"");
                    }
                    else if ( fCmdOn )
                    {
                        CicLoadStringWrapW(g_hInst, IDS_NUI_COMMANDING_TEXT, sz, ARRAYSIZE(sz));
                    
                        hr = _this->m_pSpeechUIServer->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                        TraceMsg(TF_SAPI_PERF, "Show \"Voice command\"");
                    }
                }

                if (fDictOn)
                {
                    hr = _this->HandleLearnFromDoc( );
                    if ( S_OK == hr )
                        _this->_SetCurrentIPtoSR();

                }
            }

            if (S_OK == hr)
            {
                hr = _this->EraseFeedbackUI();

                if (S_OK == hr)
                    hr = _this->_FinalizeComposition();
            }
            TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_DICTATIONSTAT exit normally");
        }
        else
            TraceMsg(TF_SAPI_PERF, "GUID_COMPARTMENT_SPEECH_DICTATIONSTAT exits when the app doesn't get focus!");

        return hr;
    }
    else  if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_LEARNDOC))
    {
         _this->UpdateLearnDocState( );
         return S_OK;
    }
    else if (IsEqualGUID(rguid,GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE) )
    {
        TraceMsg(TF_GENERAL, "GUID_COMPARTMENT_SPEECH_PROPERTY_CHANGE is set!");

        // Renew all the property values from the registry.
        _this->_RenewAllPropDataFromReg(  );

        // Specially handle some of property changes.

        if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Support_LMA) )
            SetCompartmentDWORD(_this->_GetId( ), _this->_tim, GUID_COMPARTMENT_SPEECH_LEARNDOC, _this->_LMASupportEnabled( ), FALSE);

        // Specially handle mode button setting changes

        BOOL   fModeButtonChanged;

        fModeButtonChanged = _this->_IsPropItemChangedSinceLastRenew(PropId_Mode_Button) ||
                             _this->_IsPropItemChangedSinceLastRenew(PropId_Dictation_Key) ||
                             _this->_IsPropItemChangedSinceLastRenew(PropId_Command_Key);
                             
        _this->HandleModeKeySettingChange( fModeButtonChanged );

        // For command category items, it will update grammars's status.
        // Update the grammar's status.

        CSpTask           *psp;
        _this->GetSpeechTask(&psp);

        if ( psp )
        {
            DWORD  dwActiveMode = ACTIVE_IN_BOTH_MODES;  // indicates which mode will change the grammar status.
            BOOL   bDictCmdChanged = _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_DictMode);

            if ( _this->_AllDictCmdsDisabled( ) )
            {
                // All the commands are disabled in dication mode.
                psp->_ActivateCmdInDictMode(FALSE);

                //Needs to activate spelling grammar in dictation mode.
                psp->_ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);

                // Needs to activate "Force Num" grammar in dication strong mode.
                psp->_ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);

                // Needs to activate language bar grammar in dictation strong mode for mode switching commands.
                psp->_ActiveCategoryCmds(DC_CC_LangBar, _this->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );

                // Only need to change grammar status in command mode.
                dwActiveMode = ACTIVE_IN_COMMAND_MODE;
            }
            else
            {
                // if this was changed since latst renew.
                if ( bDictCmdChanged )
                {
                    psp->_ActiveCategoryCmds(DC_CC_SelectCorrect, _this->_SelectCorrectCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);
                    psp-> _ActiveCategoryCmds(DC_CC_Navigation, _this->_NavigationCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Casing, _this->_CasingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Editing, _this->_EditingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Keyboard, _this->_KeyboardCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_TTS, _this->_TTSCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_LangBar, _this->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE );
                    psp->_ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);
                    psp->_ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);

                    if ( _this->_SelectCorrectCmdEnabled( ) || _this->_NavigationCmdEnabled( ) )
                    {
                        psp->_UpdateSelectGramTextBufWhenStatusChanged( );
                    }

                    dwActiveMode = ACTIVE_IN_COMMAND_MODE;
                }
            }

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Select_Correct) )
                psp->_ActiveCategoryCmds(DC_CC_SelectCorrect, _this->_SelectCorrectCmdEnabled( ), dwActiveMode);

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Navigation) )
                psp-> _ActiveCategoryCmds(DC_CC_Navigation, _this->_NavigationCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Casing) )
                psp->_ActiveCategoryCmds(DC_CC_Casing, _this->_CasingCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Editing) )
                psp->_ActiveCategoryCmds(DC_CC_Editing, _this->_EditingCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Keyboard) )
                psp->_ActiveCategoryCmds(DC_CC_Keyboard, _this->_KeyboardCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_TTS) )
                psp->_ActiveCategoryCmds(DC_CC_TTS, _this->_TTSCmdEnabled( ), dwActiveMode );

            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Language_Bar) )
                psp->_ActiveCategoryCmds(DC_CC_LangBar, _this->_LanguageBarCmdEnabled( ), dwActiveMode );

            // Check to see if we need to fill text to selection grammar.
            if ( _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Select_Correct)  ||
                 _this->_IsPropItemChangedSinceLastRenew(PropId_Cmd_Navigation) )
            {
                BOOL  bUpdateText;

                bUpdateText = _this->_SelectCorrectCmdEnabled( ) || _this->_NavigationCmdEnabled( );

                if ( bUpdateText )
                {
                    psp->_UpdateSelectGramTextBufWhenStatusChanged( );
                }
            }

            psp->Release( );
        }

        return S_OK;
    }
#ifdef TF_DISABLE_SPEECH
    else if (IsEqualGUID(rguid, GUID_COMPARTMENT_SPEECH_DISABLED))
    {
        BOOL fDictationDisabled = _this->Get_SPEECH_DISABLED_DictationDisabled() ? TRUE : FALSE;
        BOOL fCommandingDisabled = _this->Get_SPEECH_DISABLED_CommandingDisabled() ? TRUE : FALSE;

        if (fDictationDisabled)
            _this->SetDICTATIONSTAT_DictOnOff(FALSE);

        if (fCommandingDisabled)
            _this->SetDICTATIONSTAT_CommandingOnOff(FALSE);

        return S_OK; 
    }
#endif
    

    return S_FALSE;
}


HRESULT CSapiIMX::_HandleOpenCloseEvent(MIC_STATUS ms)
{
    HRESULT hr = S_OK;

    BOOL fOn;

    TraceMsg(TF_SAPI_PERF, "_HandleOpenCloseEvent is called, ms=%d", (int)ms);

    if (ms == MICSTAT_NA)
    {
        fOn = GetOnOff();
    }
    else
    {
        fOn = (ms == MICSTAT_ON) ? TRUE : FALSE;
    }

    if (fOn)
    {
        // if no one so far set dictation status, we assume
        // there's no C&C button so we can synchronize dictation
        // status with mic
        //
        InitializeSAPI(TRUE);

        if (m_fDictationEnabled == TRUE)
        {
            //
            // if the caller wants to set the mic status (!= NA)
            // we also want to make sure dictation status follow that
            //
            _SetCurrentIPtoSR();

            // whenever dictation is turned on, we need to sync
            // with the current modebias
            //
            CComPtr<ITfContext> cpic;
            if (GetFocusIC(&cpic))
            {
                _gaModebias = 0;
                _SyncModeBiasWithSelection(cpic);
            }
        }
    }

    if (m_pCSpTask)
    {
        m_pCSpTask->_SetInputOnOffState(fOn);
    }
        
    return hr;
}


//+---------------------------------------------------------------------------
//
// _SysLBarCallback
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::_SysLBarCallback(UINT uCode, void *pv, ITfMenu *pMenu, UINT wID)
{
    CSapiIMX *pew = (CSapiIMX *)pv;
    HRESULT hr = S_OK;

    if (uCode == IDSLB_INITMENU)
    {
        WCHAR sz[128];

        BOOL fOn = pew->GetOnOff();

        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_OPTIONS, sz, ARRAYSIZE(sz));
        LangBarInsertMenu(pMenu, IDM_MIC_OPTIONS, sz);
#ifdef TEST_SHARED_ENGINE
        LangBarInsertMenu(pMenu, IDM_MIC_SHAREDENGINE, L"Use shared engine", pew->m_fSharedReco);
        LangBarInsertMenu(pMenu, IDM_MIC_INPROCENGINE, L"Use inproc engine", !pew->m_fSharedReco);
#endif

        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_TRAINING, sz, ARRAYSIZE(sz));
        LangBarInsertMenu(pMenu, IDM_MIC_TRAINING, sz);

        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_ADDDELETE, sz, ARRAYSIZE(sz));
        LangBarInsertMenu(pMenu, IDM_MIC_ADDDELETE, sz);

        // insert sub menu for user profile stuff
        ITfMenu *pSubMenu = NULL;
        
        sz[0] = '\0';
        CicLoadStringWrapW(g_hInst, IDS_MIC_CURRENTUSER, sz, ARRAYSIZE(sz));
        hr = LangBarInsertSubMenu(pMenu, sz, &pSubMenu);
        if (S_OK == hr)
        {
            CComPtr<IEnumSpObjectTokens> cpEnum;
            CComPtr<ISpRecognizer>       cpEngine;
            ISpObjectToken *pUserProfile = NULL;
            CSpDynamicString dstrDefaultUser;
            
            // ensure SAPI is initialized
            hr = pew->InitializeSAPI(TRUE);
            if (S_OK == hr)
            {
                // get the current default user
                hr = pew->m_pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpEngine);
            }
            if (S_OK == hr)
            {
                hr = cpEngine->GetRecoProfile(&pUserProfile);
            }
            
            if (S_OK == hr)
            {
                hr = SpGetDescription(pUserProfile, &dstrDefaultUser);
                SafeRelease(pUserProfile);
            }

            if (S_OK == hr)
            {
                hr = SpEnumTokens (SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);
            }
            if (S_OK == hr)
            {
                int idUser = 0;
                while (cpEnum->Next(1, &pUserProfile, NULL) == S_OK)
                {
                    // dstr frees itself
                    CSpDynamicString dstrUser;
                    hr = SpGetDescription(pUserProfile, &dstrUser);
                    if (S_OK == hr)
                    {
                        BOOL fDefaultUser = (wcscmp(dstrUser, dstrDefaultUser) == 0);
                        Assert(idUser < IDM_MIC_USEREND);
                        LangBarInsertMenu(pSubMenu, IDM_MIC_USERSTART + idUser++, dstrUser, fDefaultUser);
                    }
                    SafeRelease(pUserProfile);
                }
            }
            pSubMenu->Release();
        }

    }
    else if (uCode == IDSLB_ONMENUSELECT)
    {
        if ( wID == IDM_MIC_ONOFF )
        {
            // toggle mic
            pew->SetOnOff(!pew->GetOnOff());
        }
        // Invoke SAPI UI stuff...
        else if (wID ==  IDM_MIC_TRAINING)
        {
            hr = pew->_HandleTrainingWiz();
        } 
        else if (wID == IDM_MIC_ADDDELETE)
        {
            // A editsession callback will handle this requirement first
            // if the edit session fails, we will just display the UI
            // without any initial words.

            hr = pew->_RequestEditSession(ESCB_HANDLE_ADDDELETE_WORD, TF_ES_READ);

            if ( FAILED(hr) )
                hr = pew->DisplayAddDeleteUI( NULL, 0 );

        }
        else if (wID == IDM_MIC_OPTIONS)
        {
            PostMessage(pew->_GetWorkerWnd(), WM_PRIV_OPTIONS, 0, 0);
        }
        else if (wID >= IDM_MIC_USERSTART && wID < IDM_MIC_USEREND)
        {
            CComPtr<IEnumSpObjectTokens> cpEnum;
            CComPtr<ISpObjectToken>      cpProfile;
            // change the current user
            // 
            // this is still a hack, until we get an OnEndMenu event for LangBarItemSink
            // for now I just assume SAPI enumerates profiles in same order always
            //
            // what we should really do is to set up an arry to associate IDs with
            // user profiles and clean them up when OnEndMenu comes to us
            //

            if (S_OK == hr)
            {
                hr = SpEnumTokens (SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);
            }
            
            if (S_OK == hr)
            {
                ULONG ulidUser = wID - IDM_MIC_USERSTART;
                ULONG ulFetched;

                CPtrArray<ISpObjectToken> rgpProfile;
                rgpProfile.Append(ulidUser+1);

                // trasform 0 base index to num of profile
                 hr = cpEnum->Next(ulidUser+1, rgpProfile.GetPtr(0), &ulFetched);
                 if (S_OK == hr && ulFetched == ulidUser+1)
                 {
                     // get the profile which is selected
                     cpProfile = rgpProfile.Get(ulidUser);
                     
                     // clean up
                     for(ULONG i = 0; i <= ulidUser ; i++)
                     {
                         rgpProfile.Get(i)->Release();
                     }
                 }
            }

            if (S_OK == hr && cpProfile)
            {
                hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOPROFILES, cpProfile);

                if ( S_OK == hr )
                {
                    CComPtr<ISpRecognizer>     cpEngine;
                    hr = pew->m_pCSpTask->GetSAPIInterface(IID_ISpRecognizer, (void **)&cpEngine);
                    if (S_OK == hr)
                    {
                        SPRECOSTATE State;

                        if (S_OK == cpEngine->GetRecoState(&State))
                        {
                            cpEngine->SetRecoState(SPRST_INACTIVE);
                            hr = cpEngine->SetRecoProfile(cpProfile);
                            cpEngine->SetRecoState(State);
                        }
                    }
                }
            }
        }
#ifdef TEST_SHARED_ENGINE
        else if (wID == IDM_MIC_SHAREDENGINE || wID ==  IDM_MIC_INPROCENGINE)
        {
            pew->m_fSharedReco = wID == IDM_MIC_SHAREDENGINE ? TRUE : FALSE;
            pew->_ReinitializeSAPI();
        }
#endif
    }
    return hr;
}

void CSapiIMX::_ReinitializeSAPI(void)
{
   TraceMsg(TF_SAPI_PERF, "_ReinitializeSAPI is called");

   DeinitializeSAPI();
   InitializeSAPI(TRUE);
}

//+---------------------------------------------------------------------------
//
// OnCompositionTerminated
//
// Cicero calls this method when one of our compositions is terminated.
//----------------------------------------------------------------------------

STDAPI CSapiIMX::OnCompositionTerminated(TfEditCookie ec, ITfComposition *pComposition)
{
    ITfRange *pRange = NULL;
    ITfContext *pic = NULL;
    ITfContext *picTest;
    CICPriv *picp;
    HRESULT hr;

    TraceMsg(TF_GENERAL, "OnCompositionTerminated is Called");

    hr = E_FAIL;

    if (pComposition->GetRange(&pRange) != S_OK)
        goto Exit;
    if (pRange->GetContext(&pic) != S_OK)
        goto Exit;

    if (_fDeactivated)
    {
        // CleanupConsider: benwest: I don't think this can happen anymore...
        hr = MakeResultString(ec, pic, pRange, TF_CLIENTID_NULL, NULL);
    }
    else
    {
        // Close candidate ui if it is up.
        CloseCandUI( );

        // take note we're done composing
        if (picp = GetInputContextPriv(_tid, pic))
        {
            picp->_ReleaseComposition();
            picp->Release();
        }
        if (!m_fStartingComposition)
        {
            hr = MakeResultString(ec, pic, pRange, _tid, m_pCSpTask);
        }
        else
        {
            // just avoid terminating recognition when we are just about
            // to start composition.
            hr = S_OK; 
        }
    }

    // free up m_cpRangeCurIP if it belongs to this context
    if (m_cpRangeCurIP != NULL &&
        m_cpRangeCurIP->GetContext(&picTest) == S_OK)
    {
        if (pic == picTest)
        {
            m_cpRangeCurIP.Release();
        }
        picTest->Release();
    }

    // unadvise mouse sink
    if (m_pMouseSink)
    {
        m_pMouseSink->_Unadvise();
        SafeReleaseClear(m_pMouseSink);
    }

Exit:
    SafeRelease(pRange);
    SafeRelease(pic);

    return hr;
}

//+---------------------------------------------------------------------------
//
// _FindComposition
//
//----------------------------------------------------------------------------

/* static */
BOOL CSapiIMX::_FindComposition(TfEditCookie ec, ITfContextComposition *picc, ITfRange *pRange, ITfCompositionView **ppCompositionView)
{
    ITfCompositionView *pCompositionView;
    IEnumITfCompositionView *pEnum;
    ITfRange *pRangeView = NULL;
    BOOL fFoundComposition;
    LONG l;
    CLSID clsid;
    HRESULT hr;

    if (picc->FindComposition(ec, pRange, &pEnum) != S_OK)
    {
        Assert(0);
        return FALSE;
    }

    fFoundComposition = FALSE;

    while (!fFoundComposition && pEnum->Next(1, &pCompositionView, NULL) == S_OK)
    {
        hr = pCompositionView->GetOwnerClsid(&clsid);
        Assert(hr == S_OK);

        // make sure we ignore other TIPs' compositions!
        if (!IsEqualCLSID(clsid, CLSID_SapiLayr))
            goto NextRange;

        hr = pCompositionView->GetRange(&pRangeView);
        Assert(hr == S_OK);

        if (pRange->CompareStart(ec, pRangeView, TF_ANCHOR_START, &l) == S_OK &&
            l >= 0 &&
            pRange->CompareEnd(ec, pRangeView, TF_ANCHOR_END, &l) == S_OK &&
            l <= 0)
        {
            // our test range is within this composition range
            fFoundComposition = TRUE;
        }

NextRange:
        SafeRelease(pRangeView);
        if (fFoundComposition && ppCompositionView != NULL)
        {
            *ppCompositionView = pCompositionView;
        }
        else
        {
            pCompositionView->Release();
        }
    }

    pEnum->Release();

    return fFoundComposition;
}

//+---------------------------------------------------------------------------
//
// _CheckStartComposition
//
//----------------------------------------------------------------------------

void CSapiIMX::_CheckStartComposition(TfEditCookie ec, ITfRange *pRange)
{
    ITfContext *pic;
    ITfContextComposition *picc;
    ITfComposition *pComposition;
    CICPriv *picp;
    HRESULT hr;

    if (pRange->GetContext(&pic) != S_OK)
        return;

    hr = pic->QueryInterface(IID_ITfContextComposition, (void **)&picc);
    Assert(hr == S_OK);

    // is pRange already included in a composition range?
    if (_FindComposition(ec, picc, pRange, NULL))
        goto Exit; // there's already a composition, we're golden

    // need to create a new composition, or at least try

    m_fStartingComposition = TRUE;
    if (picc->StartComposition(ec, pRange, this, &pComposition) == S_OK)
    {
        if (pComposition != NULL) // NULL if the app rejects the composition
        {
            // take note we're composing
            if (picp = GetInputContextPriv(_tid, pic))
            {
                picp->_AddRefComposition();
                picp->Release();
            }
            // create mouse sink here for unfinalized composition buffer
            if (!IsFocusFullAware(_tim) && !m_pMouseSink)
            {
                m_pMouseSink = new CMouseSink(_MouseSinkCallback, this);
                if (m_pMouseSink)
                {
                    CComPtr<ITfRange> cpRange;
                    hr = pComposition->GetRange(&cpRange);
                    if (S_OK == hr)
                    {
                        hr = m_pMouseSink->_Advise(cpRange, pic);
                    }
                    // mouse not pressed, no selection first
                    m_fMouseDown = FALSE;
                    m_ichMouseSel = 0;
                }
            }

            // we already set up the sink, so we'll use ITfContextComposition::FindComposition
            // to get this guy back when we want to terminate it
            // Cicero will hold a ref to the object until someone terminates it
            pComposition->Release();
        }
    }

    m_fStartingComposition = FALSE;

Exit:
    pic->Release();
    picc->Release();       
}


//+---------------------------------------------------------------------------
//
// IsInterestedInContext
//
//----------------------------------------------------------------------------

HRESULT CSapiIMX::IsInterestedInContext(ITfContext *pic, BOOL *pfInterested)
{
    CICPriv *picp;

    *pfInterested = FALSE;

    if (picp = GetInputContextPriv(_tid, pic))
    {
        // we only need access to ic's with active compositions
        *pfInterested = (picp->_GetCompositionCount() > 0);
        picp->Release();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CleanupContext
//
// This method is a callback for the library helper CleanupAllContexts.
// We have to be very careful here because we may be called _after_ this tip
// has been deactivated, if the app couldn't grant a lock right away.
//----------------------------------------------------------------------------

HRESULT CSapiIMX::CleanupContext(TfEditCookie ecWrite, ITfContext *pic)
{
    // all sptip cares about is finalizing compositions
    CleanupAllCompositions(ecWrite, pic, CLSID_SapiLayr, _CleanupCompositionsCallback, this);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CleanupCompositionsCallback
//
//----------------------------------------------------------------------------

/* static */
void CSapiIMX::_CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate)
{
    ITfContext *pic;
    CICPriv *picp;
    CSapiIMX *_this = (CSapiIMX *)pvPrivate;

    if (rangeComposition->GetContext(&pic) != S_OK)
        return;

    if (_this->_fDeactivated)
    {
        // this is a cleanup callback.  _tid, m_pCSpTask should already have been cleaned up
        _this->MakeResultString(ecWrite, pic, rangeComposition, TF_CLIENTID_NULL, NULL);
    }
    else
    {
        // during a profile switch we will still be active and need to clear the composition count on this ic
        if (picp = GetInputContextPriv(_this->_tid, pic))
        {
            // clear the composition count for this ic
            picp->_ReleaseComposition();
            picp->Release();
        }

        _this->MakeResultString(ecWrite, pic, rangeComposition, _this->_tid, _this->m_pCSpTask);
    }

    pic->Release();
}

//+---------------------------------------------------------------------------
//
//  _IsDoubleClick
//
//  returns TRUE only if the last position is same and lbutton down happens
//  within the time defined for double click
//
//----------------------------------------------------------------------------
BOOL CSapiIMX::_IsDoubleClick(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus)
{
    if (dwBtnStatus & MK_LBUTTON)
    {
        LONG   lTime=GetMessageTime();
        if (!m_fMouseDown && m_uLastEdge == uEdge && m_uLastQuadrant == uQuadrant)
        {
            if (lTime > m_lTimeLastClk && lTime < m_lTimeLastClk + 500) // use 500 ms for now
            {
                return TRUE;
            }
        }
        m_uLastEdge = uEdge;
        m_uLastQuadrant = uQuadrant;
        m_lTimeLastClk = lTime;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//    _MouseSinkCallback
//
//    synopsis: set the current IP on the composition range based on
//              uEdge parameter. We don't probably care too much about
//              eQuadrant for speech composition
//
//----------------------------------------------------------------------------
  
/* static */
HRESULT CSapiIMX::_MouseSinkCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv)
{
    CSapiIMX *_this = (CSapiIMX *)pv;

    Assert(pv);

    BOOL fDoubleClick = _this->_IsDoubleClick(uEdge, uQuadrant, dwBtnStatus);

    ESDATA  esData = {0};

    esData.lData1 = (LONG_PTR)uEdge;
    esData.lData2 = (LONG_PTR)dwBtnStatus;
    esData.fBool  = fDoubleClick;

    if (pfEaten)
        *pfEaten = TRUE;
    
    return _this->_RequestEditSession(ESCB_HANDLE_MOUSESINK, TF_ES_READWRITE, &esData);
}

HRESULT CSapiIMX::_HandleMouseSink(TfEditCookie ec, ULONG uEdge, ULONG uBtnStatus, BOOL fDblClick)
{
    CComPtr<ITfDocumentMgr> cpDim;
    CComPtr<ITfContext>     cpic;
    CComPtr<ITfContextComposition> cpicc;
    CComPtr<IEnumITfCompositionView> cpEnumComp;
    CComPtr<ITfCompositionView> cpCompositionView;
    CComPtr<ITfRange>           cpRangeComp;
    CComPtr<ITfRange>           cpRangeSel;

    // if the btn up comes, the next time we'll destroy the selection
    // nothing we need to do in this turn
    BOOL fLeftBtn = (uBtnStatus & MK_LBUTTON) > 0 ? TRUE : FALSE;

    if (!fLeftBtn)
    {
        m_ichMouseSel = 0;
        m_fMouseDown = FALSE;
        return S_OK;
    }

    // Close candidate ui if it is up.
    CloseCandUI( );


    HRESULT hr = GetFocusDIM(&cpDim);

    if(S_OK == hr)
    {
        hr= cpDim->GetBase(&cpic);
    }

    if (S_OK == hr)
    {
        hr = cpic->QueryInterface(IID_ITfContextComposition, (void **)&cpicc);
    }


    if (S_OK == hr)
    {
        hr = cpicc->EnumCompositions(&cpEnumComp);
    }

    if (S_OK == hr)
    {
        while ((hr = cpEnumComp->Next(1, &cpCompositionView, NULL)) == S_OK)
        {
            hr = cpCompositionView->GetRange(&cpRangeComp);
            if (S_OK == hr)
                break;

            // prepare for the next turn
            cpCompositionView.Release();
        }
    }
    
    if (S_OK == hr)
    {
        if (fDblClick)
        {
           WCHAR wsz[256] = {0}; // the buffer is 256 chars max
           ULONG  cch = 0;

           CComPtr<ITfRange> cpRangeWord;

           // obtain the text within the entire composition
           hr = cpRangeComp->Clone(&cpRangeWord);
           if (S_OK == hr)
           {
               hr = cpRangeWord->GetText(ec, 0, wsz, 255, &cch);
           }

           // get the left side edge char position, looking at delimiters
           if (S_OK == hr)
           {
               WCHAR *psz = &wsz[uEdge];
 
               while (psz > wsz)
               {
                   if (!iswalpha(*psz))
                   {
                       psz++;
                       break;
                   }
                   psz--;
               }
               // re-posisition ich
               m_ichMouseSel = psz - wsz;

               // get the right side word boundary, also based on delimiters 
               psz = &wsz[uEdge];

               while( psz < &wsz[cch] )
               {
                   if (!iswalpha(*psz))
                   {
                       break;
                   }

                   psz++;
               }
               // reposition uEdge
               uEdge = psz - wsz;
           }
           
           // pretend lbutton was previously down to get the same effect of
           // dragging selection
           //
           m_fMouseDown = TRUE;
           
        }
    }

    if (S_OK == hr)
    {
        hr = cpRangeComp->Clone(&cpRangeSel);
    }

    if (S_OK == hr)
    {
        if(m_fMouseDown)
        {
            // if the mouse is down the last time and still down this time
            // it means it was dragged like this _v_>>>>_v_ or _v_<<<<_v_
            // we'll have to make a selection accordingly
        
            // 1) place the IP to the previous position
            long cch;
            hr = cpRangeSel->ShiftStart(ec,  m_ichMouseSel, &cch, NULL);
            if (S_OK == hr)
            {
            // 2) prepare for extension
         
                hr = cpRangeSel->Collapse( ec, TF_ANCHOR_START);
            }
        }
    }

    if (S_OK == hr)
    {
        long ich = (long) (uEdge);
        long cch;
        

        // 3) see if there's a prev selection and if there is,
        // calculate the dir and width of selection
        // note that we've already had ich set to the pos at above 1) & 2)

        long iich = 0;
        if (m_fMouseDown)
        {
            iich = ich - m_ichMouseSel;
        }

        if (iich > 0) // sel towards the end
        {
            hr = cpRangeSel->ShiftEnd(ec, iich, &cch, NULL);
        }
        else if (iich < 0) // sel towards the start
        {
            hr = cpRangeSel->ShiftStart(ec, iich, &cch, NULL);
        }
        else // no width sel == an IP
        {
            hr = cpRangeSel->ShiftStart(ec, ich, &cch, NULL);

            if (S_OK == hr) // collapse it only when there's no selection
            {
                hr = cpRangeSel->Collapse( ec, TF_ANCHOR_START);
            }
        }

        // preserve the ip position so we can make a selection later
        // a tricky thing is you have to remember the pos where you
        // have started to "drag" not the pos you just updated
        // so we need this only for the first time we started selection

        if (!m_fMouseDown)
            m_ichMouseSel = ich;
    }


    if (S_OK == hr)
    {
        BOOL fSetSelection = TRUE;
        CComPtr<ITfRange> cpRangeCur;
        HRESULT tmpHr = S_OK;
        
        tmpHr = GetSelectionSimple(ec, cpic, &cpRangeCur);
        if (SUCCEEDED(tmpHr) && cpRangeCur)
        {
            LONG l = 0;
            if (cpRangeCur->CompareStart(ec, cpRangeSel, TF_ANCHOR_START, &l) == S_OK && l == 0 &&
                cpRangeCur->CompareEnd(ec, cpRangeSel, TF_ANCHOR_END, &l) == S_OK && l == 0)
            {
                fSetSelection = FALSE;
            }
        }

        if (fSetSelection)
        {
            CComPtr<ITfProperty> cpProp;

            hr = cpic->GetProperty(GUID_PROP_ATTRIBUTE, &cpProp);

            if (S_OK == hr)
            {
                SetGUIDPropertyData(&_libTLS, ec, cpProp, cpRangeCur, GUID_NULL);
                SetGUIDPropertyData(&_libTLS, ec, cpProp, cpRangeSel, GUID_ATTR_SAPI_SELECTION);
            }

            hr = SetSelectionSimple(ec, cpic, cpRangeSel);
        }
    }

    m_fMouseDown = fLeftBtn;
  
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\selword.h ===
#ifndef _SELWORD_H
#define _SELWORD_H

#include "sapilayr.h"

typedef struct  _SearchRun 
{
    ULONG   ulStart;
    ULONG   ulEnd;
    BOOL    fStartToEnd;
}  SEARCHRUN;

typedef enum
{
    SearchRun_Selection         = 0,
    SearchRun_LargeSelection    = 1,
    SearchRun_BeforeSelection   = 2,
    SearchRun_AfterSelection    = 3,
    SearchRun_MaxRuns           = 4
} Search_Run_Id;

class CSearchString
{
public: 
    CSearchString( );
    ~CSearchString( );

    HRESULT  Initialize(WCHAR *SrchStr, WCHAR *SrchFromStr, LANGID langid, ULONG ulSelStartOff, ULONG ulSelLen);
    BOOL     Search(ULONG  *pulOffset, ULONG  *pulSelSize=NULL);
private:
    BOOL     _SearchOneRun(Search_Run_Id  idSearchRun);
    BOOL     _InitSearchRun(ULONG ulSelStartOff, ULONG ulSelLen);

    void     _SetRun(Search_Run_Id  idSearchRun, ULONG ulStart, ULONG ulEnd, BOOL fStartToEnd);

    CSpDynamicString    m_dstrTextToSrch;
    LANGID              m_langid;
    WCHAR              *m_pwszTextSrchFrom;
    ULONG               m_ulSrchLen;
    ULONG               m_ulSrchFromLen;
    SEARCHRUN           m_pSearchRun[SearchRun_MaxRuns];
    BOOL                m_fInitialized;
    ULONG               m_ulFoundOffset;  // Offset in m_pwszTextSrchFrom that matches SearchStr.
};

class CSapiIMX;
class CSpTask;

typedef enum
{
    SELECTWORD_NONE         =  0,
    SELECTWORD_SELECT       =  1,
    SELECTWORD_DELETE       =  2,
    SELECTWORD_INSERTBEFORE =  3,
    SELECTWORD_INSERTAFTER  =  4,
    SELECTWORD_CORRECT      =  5,
    SELECTWORD_SELTHROUGH   =  6,    // Select xxx through yyy
    SELECTWORD_DELTHROUGH   =  7,    // Delete xxx through yyy
    SELECTWORD_MAXTEXTBUFF  = 11,
    SELECTWORD_UNSELECT     = 11,
    SELECTWORD_SELECTPREV   = 12,    // Select previous phrase.
    SELECTWORD_SELECTNEXT   = 13,    // Select next phrase.
    SELECTWORD_CORRECTPREV  = 14,    // Correct previous phrase.
    SELECTWORD_CORRECTNEXT  = 15,    // Correct next phrase.
    SELECTWORD_GOTOBOTTOM   = 16,    // Go To Bottom
    SELECTWORD_GOTOTOP      = 17,    // Go To Top
    SELECTWORD_SELSENTENCE  = 18,    // Select Sentence
    SELECTWORD_SELPARAGRAPH = 19,    // Select Paragraph
    SELECTWORD_SELWORD      = 20,    // Select Word
    SELECTWORD_SELTHAT      = 21,    // Select That
    SELECTWORD_MAXCMDID     = 100
} SELECTWORD_OPERATION;

class __declspec(novtable) CSelectWord
{
public:
    CSelectWord(CSapiIMX *psi);
    virtual ~CSelectWord( );

    HRESULT  ProcessSelectWord(WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION m_sw_type, ULONG ulLenXXX = 0);
    HRESULT  _HandleSelectWord(TfEditCookie ec,ITfContext *pic,WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION m_sw_type, ULONG ulLenXXX = 0);

    HRESULT  UpdateTextBuffer(ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar);
    HRESULT  _UpdateTextBuffer(TfEditCookie ec,ITfContext *pic, ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar);

    HRESULT  _GetPrevOrNextPhrase(TfEditCookie ec,ITfContext *pic, BOOL fPrev, ITfRange **ppRangeOut);

    HRESULT  _ShiftComplete(TfEditCookie ec, ITfRange *pRange, LONG cchLenToShift, BOOL fStart);

    HRESULT  _GetActiveViewRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView);

private:

    HRESULT  _SelectWord(TfEditCookie ec,ITfContext *pic);
    HRESULT  _DeleteWord(TfEditCookie ec,ITfContext *pic);
    HRESULT  _InsertAfterWord(TfEditCookie ec,ITfContext *pic);
    HRESULT  _InsertBeforeWord(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX);
    HRESULT  _DeleteThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX);

    HRESULT  _GetThroughRange(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX, ITfRange **ppRange);

    HRESULT  _GetTextAndSelectInCurrentView(TfEditCookie ec,ITfContext *pic, ULONG *pulOffSelStart=NULL, ULONG  *pulSelLen=NULL);
    HRESULT  _FindSelect(TfEditCookie ec, ITfContext *pic, BOOL  *fFound);

    HRESULT  _GetCUASCompositionRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView);

    HRESULT  _GetTextFromRange(TfEditCookie ec, ITfRange *pRange, CSpDynamicString &dstr);

    HRESULT  _Unselect(TfEditCookie ec,ITfContext *pic);

    HRESULT  _CorrectWord(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectPrevOrNextPhrase(TfEditCookie ec, ITfContext *pic, BOOL  fPrev);
    HRESULT  _SelectPreviousPhrase(TfEditCookie ec,ITfContext *pic);
    HRESULT  _SelectNextPhrase(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectThat(TfEditCookie ec,ITfContext *pic);

    HRESULT  _CorrectPrevOrNextPhrase(TfEditCookie ec,ITfContext *pic, BOOL fPrev);
    HRESULT  _CorrectNextPhrase(TfEditCookie ec,ITfContext *pic);
    HRESULT  _CorrectPreviousPhrase(TfEditCookie ec,ITfContext *pic);
    HRESULT  _GoToBottom(TfEditCookie ec,ITfContext *pic);
    HRESULT  _GoToTop(TfEditCookie ec,ITfContext *pic);

    HRESULT  _SelectSpecialText(TfEditCookie ec,ITfContext *pic, SELECTWORD_OPERATION sw_Type);

    BOOL     _IsSentenceDelimiter(WCHAR  wch);
    BOOL     _IsParagraphDelimiter(WCHAR wch);
    BOOL     _IsWordDelimiter(WCHAR wch);

    CSapiIMX     *m_psi;
    WCHAR        *m_pwszSelectedWord;
    ULONG        m_ulLenSelected;

    CComPtr<ITfRange>   m_cpActiveRange;
    CComPtr<ITfRange>   m_cpSelectRange;
    CSpDynamicString    m_dstrActiveText;

};

#endif  // _SELWORD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "regsvr.h"
#include "regimx.h"
#include "status.h"
#include "catutil.h"
#include "cregkey.h"
#include "nui.h"
#include "mui.h"
#include "proppage.h"
#include "immxutil.h"

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SapiLayr, CSapiIMX, TEXT("Cicero SAPI Layer IMX"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SpeechUIServer, CSpeechUIServer, TEXT("Cicero SAPI Layer Speech UI Server"))
END_COCLASSFACTORY_TABLE

extern CComModule _Module;

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    CcshellGetDebugFlags();
    Dbg_MemInit(TEXT("SPTIP"), NULL);
   
    g_hInst = hInstance;
    g_dwTlsIndex = TlsAlloc();
    
    if (!g_cs.Init())
        return FALSE;

    CSapiIMX::RegisterWorkerClass(hInstance);

    MuiLoadResource(hInstance, TEXT("sptip.dll"));

    _Module.Init(NULL, hInstance);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
    _Module.Term();

    MuiClearResource();

    UninitProcess();

    g_cs.Delete();
    TlsFree(g_dwTlsIndex);

    Dbg_MemUninit();
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    BOOL bRet = TRUE;
#ifdef DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDettach(hInstance);
                bRet = FALSE;
            }
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;

        case DLL_THREAD_DETACH:
            FreeSPTIPTHREAD();
            break;
    }

#ifdef DEBUG
    g_dwThreadDllMain = 0;
#endif

    return bRet;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    return COMBase_DllGetClassObject(rclsid, riid, ppvObj);
}

STDAPI DllCanUnloadNow(void)
{
    return COMBase_DllCanUnloadNow();
}

const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_TIP_SPEECH,       &CLSID_SapiLayr},
    {&GUID_TFCAT_PROPSTYLE_STATIC, &GUID_PROP_SAPI_DISPATTR},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM, &GUID_PROP_SAPIRESULTOBJECT},
    {&GUID_TFCAT_PROP_AUDIODATA,   &GUID_PROP_SAPIRESULTOBJECT},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM, &GUID_PROP_LMLATTICE},
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER,     &CLSID_SapiLayr},
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY,     &GUID_PROP_SAPI_DISPATTR},
    {NULL, NULL}
};

REGTIPLANGPROFILE rgNulProf[] = {
    {0x0FFFF, &c_guidProfileBogus, L"Speech Recognition",  L"sptip.dll",  0, IDS_DEFAULT_PROFILE},
    {0, NULL, L"",  L"",  0, 0},
};


STDAPI DllRegisterServer(void)
{
    WCHAR szDAP[]    = L"SAPI Layer Display Attribute Provider";
    WCHAR szDAProp[] = L"SAPI Layer Display Attribute Property";
    WCHAR szDefaultProf[128];
    HRESULT hr = E_FAIL;
    CComPtr<ITfInputProcessorProfiles> cpProfileMgr;

    TFInitLib();

    if (COMBase_DllRegisterServer() != S_OK)
        goto Exit;

    if (CicLoadStringWrapW(g_hInst, IDS_DEFAULT_PROFILE, szDefaultProf, ARRAYSIZE(szDefaultProf)))
        StringCchCopyW(rgNulProf->szProfile,ARRAYSIZE(rgNulProf->szProfile), szDefaultProf);

    if (!RegisterTIP(g_hInst, CLSID_SapiLayr, L"SapiLayer TIP", rgNulProf))
        goto Exit;

    if (FAILED(RegisterCategories(CLSID_SapiLayr, c_rgRegCat)))
        goto Exit;

    if (FAILED(TF_CreateInputProcessorProfiles(&cpProfileMgr)))
        goto Exit;
        
    cpProfileMgr->EnableLanguageProfileByDefault( CLSID_SapiLayr,
                                                  0xffff,
                                                  c_guidProfileBogus,
                                                  FALSE);
    // Save the default property values to HKLM

    CSpPropItemsServer   *pSpPropServer;

    pSpPropServer = (CSpPropItemsServer   *) new CSpPropItemsServer;

    if ( pSpPropServer )
    {
        pSpPropServer->_SaveDefaultData( );
        delete pSpPropServer;
    }

    hr = S_OK;

Exit:
    TFUninitLib( );
    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = E_FAIL;

    TFInitLib();

    if (COMBase_DllUnregisterServer() != S_OK)
        goto Exit;

    if (FAILED(UnregisterCategories(CLSID_SapiLayr, c_rgRegCat)))
        goto Exit;

    if (!UnregisterTIP(CLSID_SapiLayr))
        goto Exit;

    hr = S_OK;

Exit:
    TFUninitLib( );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\sapilayr.h ===
//
// sapilayr.h
//
#ifndef SAPILAYR_H
#define SAPILAYR_H

#include "private.h"
#include "globals.h"
#include "tes.h"
#include "mes.h"
#include "ids.h"
#include "cicspres.h"
#include "playback.h"
#include "fnrecon.h"
#include "dap.h"
#include "mscandui.h"
#include "strary.h"
#include "sink.h"
#include "computil.h"
#include "mscandui.h"
#include "syslbar.h"
#include "lbarsink.h"
#include "ats.h"
#include "cleanup.h"
#include "cutil.h"
#include "miscfunc.h"
#include "learndoc.h"
#include "adddelete.h"
#include "selword.h"
#include "tts.h"
#include "correct.h"
#include "capital.h"
#include "immxutil.h"
#include "citn.h"
#include "lpns.h"
#include "editsess.h"
#ifdef RECOSLEEP
#include "RecoSleep.h"
#endif
#include "nui.h"

#include "keyevent.h"
#include "SpBtnCtrl.h"
#include "PropItem.h"
#include "icpriv.h"
#include "correctionimx.h"
#include "urlhist.h"


#ifdef DEBUG
#define TEST_SHARED_ENGINE
#endif

// SAPI5.0 speech notification interface
//
//     this class must be derived from ISpClass defined in sapi.h
//     ISpNotifyControl object takes this class object to callback 
//
class CSptipKeyEventSink;
class CThreadMgrEventSink;
class CSapiIMX;
class CICPriv;
class CRecoResultWrap;
class CDictContext;
class CLangProfileUtil;
class CFnConfigure;
class CLearnFromDoc;
class CAddDeleteWord;
class CSelectWord;
class CTextToSpeech;
class CCorrectionHandler;
class CCapCmdHandler;
class CSapiEditSession;
#ifdef RECOSLEEP
class CRecoSleepClass;
#endif
class SpButtonControl;

class CSpPropItemsServerWrap;
class CCandUIExtBtnHandler;

typedef enum 
{
    DC_Dictation        =  0,
    DC_Dict_Spell       =  1,
    DC_CC_SelectCorrect =  2,
    DC_CC_Navigation    =  3,
    DC_CC_Casing        =  4,
    DC_CC_Editing       =  5,
    DC_CC_Keyboard      =  6,
    DC_CC_TTS           =  7,
    DC_CC_LangBar       =  8,
    DC_CC_Num_Mode      =  9,
    DC_CC_Spelling      = 10,
    DC_CC_UrlHistory    = 11,
    DC_Max              = 12
} DICT_CATCMD_ID;

//
//  used by CSpTask::_ActiveCategoryCmds to indicate which mode's grammars status to be changed
//
#define    ACTIVE_IN_DICTATION_MODE    0x0001
#define    ACTIVE_IN_COMMAND_MODE      0x0002
#define    ACTIVE_IN_BOTH_MODES        0x0003

class CSpTask // : public IUnknown
{
public:
    CSpTask(CSapiIMX *pime);
    ~CSpTask(void);


    // ISpNotifyCallback
    static void NotifyCallback( WPARAM wParam, LPARAM lParam );
    static void NotifyCallbackForCmd(WPARAM wParam, LPARAM lParam );
    static void SpeakNotifyCallback( WPARAM wParam, LPARAM lParam );

    void   SharedRecoNotify(ISpRecoContext *pRecoCtxt);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    HRESULT InitializeSAPIObjects(LANGID langid);
    HRESULT InitializeCallback();

    HRESULT CSpTask::InitializeSAPIForCmd( );
    
    HRESULT GetSAPIInterface(REFIID riid, void ** ppobj);
    HRESULT GetRecoContextForCommand(ISpRecoContext **ppRecoCtxt);

    void _ReleaseSAPI(void);

    HRESULT _SetAudioRetainStatus(BOOL fRetain);
    HRESULT _ActivateCmdInDictMode(BOOL fActive);
    HRESULT _ActiveDictOrSpell(DICT_CATCMD_ID  drId, BOOL fActive);
    HRESULT _ActiveCategoryCmds(DICT_CATCMD_ID  drId, BOOL fActive, DWORD   dwMode);

    HRESULT _SpeakText(WCHAR  *pwsz);
    HRESULT _SpeakAudio(ISpStreamFormat *pStream);
    HRESULT _LoadGrammars(void);
    HRESULT _GetLocaleInfo(LANGID *plangid);
    HRESULT GetResultObjectFromStream(IStream *pStream, ISpRecoResult **ppResult);
    HRESULT GetAlternates(CRecoResultWrap *pResultWrap, ULONG ulStartElem, ULONG ulcElem, ISpPhraseAlt **ppAlt, ULONG *pcAlt, ISpRecoResult **ppResult);
    
    HRESULT ParseSRElementByLocale(WCHAR *szDst, int cchDst, const WCHAR * szSrc, LANGID langid, BYTE bAttr);
    
    HRESULT _OnSpEventRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec);
    HRESULT _DoCommand(ULONGLONG ullGramId, SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleDictCmdGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleShardCmdGrammar(SPPHRASE *pPhrase, LANGID langid);
//    HRESULT _HandleNumModeGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleToolBarGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleNumITNGrammar(SPPHRASE *pPhrase, LANGID langid);
    HRESULT _HandleSpellGrammar(SPPHRASE *pPhrase, LANGID langid);

    HRESULT _HandleCasingCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleNavigationCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleSelwordCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleSelectThroughCmds(SPPHRASE *pPhrase, LANGID langid, ULONG idCmd);
    HRESULT _HandleSelectSimpleCmds(ULONG idCmd);
    HRESULT _HandleKeyboardCmds(LANGID langid, ULONG idCmd);

    HRESULT _HandleModeBiasCmd(SPPHRASE *pPhrase, LANGID langid);


    void    _ShowCommandOnBalloon(SPPHRASE *pPhrase);

    WCHAR *_GetCmdFileName(LANGID langid);
    void _GetCmdFileName(LANGID langid, WCHAR *sz, int cch, DWORD dwId);
    
    // method to sync to SAPI's own mic status
    void   _SetInputOnOffState(BOOL fOn);
    BOOL   _GetInputOnOffState(void);

    HRESULT _StopInput(void);
    void    _ClearQueuedRecoEvent(void);
    LANGID  _GetPreferredEngineLanguage(LANGID langid);
    HRESULT _SetVoice(LANGID langid);
    HRESULT _AddUrlPartsToGrammar(STATURL *pStat);
    BOOL    _EnsureModeBiasGrammar();
    HRESULT _SetModeBias(BOOL fActive, REFGUID refGuid);
    HRESULT _SetRecognizerInterest(ULONGLONG ulInterest);
    
    // toolbar command functions
    void _InitToolbarCommand(BOOL fLangOverride)
    {
        TraceMsg(TF_SAPI_PERF, "_InitToolbarCommand is called, fLangOverride=%d", fLangOverride);

        // initialize langbar sink for C&C
        if (!m_pLangBarSink)
        {
            if (CLangBarSink *plbs = new CLangBarSink(this))
            {
                if (S_OK == plbs->Init())
                {
                    if (fLangOverride)
                    {
//                        plbs->OnSetFocus(0);
                    }
                    m_pLangBarSink = plbs;
                }
                else
                   plbs->Release();
            }
        }
    }

    void _UnInitToolbarCommand()
    {
        TraceMsg(TF_SAPI_PERF, "_UnInitToolbarCommand is called");

        if (m_pLangBarSink)
        {
            m_pLangBarSink->Uninit();
        }
        SafeReleaseClear(m_pLangBarSink);
    }

    void _UnloadGrammars()
    {
        m_cpDictGrammar.Release();
        m_cpSpellingGrammar.Release();
        if ( m_cpDictCmdGrammar )
            m_cpDictCmdGrammar->ClearRule(m_hRuleUrlHist);
        m_cpDictCmdGrammar.Release();
        m_cpNumModeGrammar.Release();
        m_cpSharedGrammarInDict.Release();
        m_cpSharedGrammarInVoiceCmd.Release();
    }
    
    HRESULT _GetTextFromResult(ISpRecoResult *pResult, LANGID langid, CSpDynamicString &dstr);
    BOOL _DoesSelectionHaveMatchingText(WCHAR *psz, TfEditCookie ec);
    BOOL _IsSelectionInMiddleOfWord(TfEditCookie ec);
    BOOL _GetNextBestHypothesis(ISpRecoResult *pResult, ULONG ntheHypothesis, ULONG *pulNumElements,  
                                LANGID langid,  WCHAR *pszBest,  CSpDynamicString & dsNext, TfEditCookie ec);
                                
    BOOL _IsRangeEmpty(TfEditCookie ec, ITfRange *prange)
    {
        BOOL fEmpty;
        Assert(prange);
        if (S_OK != prange->IsEmpty(ec, &fEmpty))
        {
            fEmpty = FALSE;
        }
        return fEmpty;
    }

    HRESULT _EnsureSimpleITN(void)
    {
        if (m_pITNFunc)
            return S_OK;

        m_pITNFunc = new CSimpleITN(m_langid);

        return m_pITNFunc == NULL ? E_OUTOFMEMORY: S_OK;
    }

    HRESULT   _SetDictRecoCtxtState( BOOL  fEnable );
    HRESULT   _SetCmdRecoCtxtState( BOOL fEnable );
    
    void FeedDictContext(CDictContext *pdc);
    void CleanupDictContext(void);

    void _HandleInterference(ULONG lparam);
    void _ShowDictatingToBalloon(BOOL fShow);
    void _UpdateBalloon(ULONG  uidBalloon,  ULONG  uidBalloonTooltip);

    HRESULT _GetLocSRErrorString ( SPINTERFERENCE sif,  WCHAR *psz, ULONG cch, WCHAR *pszTooltip, ULONG cchTooltip );
    
    LANGID  _GetCurrentLangID(void) { return m_langid; }
    CSapiIMX *GetTip(void)          { return m_pime; }


    BOOL   _GetSelectionStatus( ) { return m_fSelectStatus; }
    void   _SetSelectionStatus( BOOL  fSelection)  {  m_fSelectStatus = fSelection; }

    HRESULT _SetSpellingGrammarStatus(BOOL fActive, BOOL fForce = FALSE);

    BOOL   _IsCallbackInitialized(void) { return m_fCallbackInitialized;}

    HRESULT  _UpdateTextBuffer(ISpRecoContext *pRecoCtxt);
    BOOL     _IsSelectionEnabled( )  { return m_fSelectionEnabled; }

    HRESULT  _UpdateSelectGramTextBufWhenStatusChanged(  );

    ISpVoice *_GetSpVoice( )  { return m_cpVoice; }

    BOOL     _GotReco(void) { return m_bGotReco; }

#ifdef RECOSLEEP
    void     InitSleepClass( );
    BOOL     IsInSleep( );
#endif

    HCURSOR m_hOrgCur;

    // langbar event sink class instance
    CLangBarSink               *m_pLangBarSink;

    // used for context feed
    CDictContext               *m_pdc;

    CComPtr<ISpRecoGrammar>     m_cpDictGrammar;
    CComPtr<ISpRecoGrammar>     m_cpSpellingGrammar;
    CComPtr<ISpRecoGrammar>     m_cpUrlSpellingGrammar;
private:
    // SAPI 50 object pointers
    CComPtr<ISpResourceManager> m_cpResMgr;
    CComPtr<ISpRecoContext>     m_cpRecoCtxt;
    CComPtr<ISpRecoContext>     m_cpRecoCtxtForCmd;
    CComPtr<ISpRecognizer>      m_cpRecoEngine;
    CComPtr<ISpVoice>           m_cpVoice;
    CComPtr<ISpRecoGrammar>     m_cpDictCmdGrammar;
    CComPtr<ISpRecoGrammar>     m_cpSharedGrammarInDict;
    CComPtr<ISpRecoGrammar>     m_cpSharedGrammarInVoiceCmd;
    CComPtr<ISpRecoGrammar>     m_cpNumModeGrammar;

#ifdef RECOSLEEP
    CRecoSleepClass            *m_pSleepClass;
#endif
    
    // TRUE if sapi is initialized
    BOOL m_fSapiInitialized;
    BOOL m_fCallbackInitialized;

    // this is TRUE once dictation grammar is activated
    BOOL m_fDictationReady;
    BOOL m_fInputState;
    
    // other data members
    BOOL m_bInSound;
    BOOL m_bGotReco; 

    // M2 SAPI workaround
    BOOL m_fIn_Activate;
    BOOL m_fIn_SetModeBias;
    BOOL m_fIn_GetAlternates;
    BOOL m_fIn_SetInputOnOffState;

    // modebias stuff
    BOOL m_fUrlHistoryMode;
    SPSTATEHANDLE                  m_hRuleUrlHist;

    // save the current user langid for the fallback case
    LANGID m_langid;

    // Sapi TFX object
    CSapiIMX *m_pime;
    
    WCHAR m_szCmdFile[MAX_PATH];
    WCHAR m_szNumModeCmdFile[MAX_PATH];
    WCHAR m_szShrdCmdFile[MAX_PATH];

    CSimpleITN   *m_pITNFunc;
    BOOL         m_fSelectStatus;      // FALSE means empty  (IP).
                                       // TRUE means selected. ( real Selection )
    BOOL          m_fDictationDeactivated;
    BOOL          m_fSpellingModeEnabled;

    BOOL          m_fSelectionEnabled;
    BOOL          m_fDictationInitialized;

    // Status (Enable or Disable) of RecoContexts.
    BOOL          m_fDictCtxtEnabled;
    BOOL          m_fCmdCtxtEnabled;

    BOOL          m_fTestedForOldMicrosoftEngine;
    BOOL          m_fOldMicrosoftEngine;

    DWORD  m_cRef;
};
const DWORD LANGSTAT_OVERRIDDEN = 0x1;

#define MAX_CHARS_FOR_BEYONDSPACE  20

//
// TIP object definition for SAPI layer
//

class CSapiIMX :        public ITfTextInputProcessor,
                        public ITfCreatePropertyStore,
                        public ITfThreadFocusSink,
                        public ITfFunctionProvider,
                        public ITfCompositionSink,
                        public ITfKeyTraceEventSink,
                        public CDisplayAttributeProvider,
                        public ICleanupContextsClient,
                        public CComObjectRoot_CreateInstance<CSapiIMX>,
                        public CLangProfileUtil,
                        public CFnConfigure,
                        public CLearnFromDoc,
                        public CAddDeleteWord,
                        public CSelectWord,
                        public CTextToSpeech,
                        public CCorrectionHandler,
                        public CColorUtil,
                        public CSpPropItemsServerWrap
{
public:
    CSapiIMX();
    ~CSapiIMX();

    BEGIN_COM_MAP_IMMX(CSapiIMX)
        COM_INTERFACE_ENTRY(ITfTextInputProcessor)
        COM_INTERFACE_ENTRY(ITfCreatePropertyStore)
        COM_INTERFACE_ENTRY(ITfDisplayAttributeProvider)
        COM_INTERFACE_ENTRY(ITfFunctionProvider)
        COM_INTERFACE_ENTRY(ITfThreadFocusSink)
        COM_INTERFACE_ENTRY(ITfCompositionSink)
        COM_INTERFACE_ENTRY(ITfKeyTraceEventSink)
        COM_INTERFACE_ENTRY(ITfFnLangProfileUtil)
        COM_INTERFACE_ENTRY(ITfFnConfigure)
    END_COM_MAP_IMMX()

    ITfThreadMgr *_tim;

    // ITfTextInputProcessor methods
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    // ITfCreatePropertyStore methods
    STDMETHODIMP IsStoreSerializable(REFGUID guidProp, 
                                    ITfRange *pRange, 
                                    ITfPropertyStore *pPropStore, 
                                    BOOL *pfSerializable);
    STDMETHODIMP CreatePropertyStore(REFGUID guidProp, 
                                     ITfRange *pRange, 
                                     ULONG cb, 
                                     IStream *pStream, 
                                     ITfPropertyStore **ppStore);
    
    // ITfFunctionProvider methods
    STDMETHODIMP GetType(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    // ITfCompositionSink
    STDMETHODIMP OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition);

    // ITfKeyTraceEventSink
    STDMETHODIMP OnKeyTraceDown(WPARAM wParam,LPARAM lParam);
    STDMETHODIMP OnKeyTraceUp(WPARAM wParam,LPARAM lParam);

    // ICleanupContextsClient
    HRESULT IsInterestedInContext(ITfContext *pic, BOOL *pfInterested);
    HRESULT CleanupContext(TfEditCookie ecWrite, ITfContext *pic);

    // a public method called from ISpTask
    HRESULT InjectSpelledText(WCHAR *pwszText, LANGID langid, BOOL fOwnerId = FALSE);
    HRESULT InjectText(const WCHAR *pwszRecognized, LANGID langid, ITfContext *pic = NULL);
    HRESULT InjectTextWithoutOwnerID(const WCHAR *pwszRecognized, LANGID langid);
    HRESULT InjectModebiasText(const WCHAR *pwszRecognized, LANGID langid);
    HRESULT InjectFeedbackUI(const GUID attr, LONG cch);
    HRESULT EraseFeedbackUI();
    HRESULT AttachResult(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements);
    HRESULT HandleSpaces(ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements, ITfRange *pTextRange, LANGID langid);
    
    HRESULT EraseLastPhrase(void);
    HRESULT ProcessControlKeys(WCHAR *pwszKeys, ULONG ulLen, LANGID langid);
    HRESULT ProcessEditCommands(LONG  idSharedCmd);
    HRESULT ProcessSpellThat( );
    HRESULT ProcessSpellIt(WCHAR *pwszText, LANGID langid);

    BOOL  HandleModeKeyEvent(DWORD   dwModeKey,  BOOL fDown);
    void  HandleModeKeySettingChange(BOOL  fSetttingChanged );

    BOOL fDeactivated(void) { return _fDeactivated; }

    // called from CAudioPlayBack
    HRESULT GetSpeechTask(CSpTask **ppSpTask, BOOL fInit = TRUE) 
    {
        if (fInit == TRUE)
            InitializeSAPI(TRUE);

        if (ppSpTask && (*ppSpTask = m_pCSpTask))
        {
            (*ppSpTask)->AddRef();

            return  S_OK;
        }

        return E_FAIL;
    }
    
    //
    // IsFocusFullAware
    //
    // a global function to detect the current focus is on 
    // Cicero full aware document
    //
    BOOL IsFocusFullAware(ITfThreadMgr *ptim)
    {
        if (m_fStageTip)
        {
            return TRUE;
        }

        DWORD dw = 0;
        // the name the compartment is inappropriate now because this is 
        // maily used for disabling TTS buttons
        if (ptim)
        {
            GetCompartmentDWORD(ptim, GUID_COMPARTMENT_TTS_STATUS, &dw, FALSE);
        }
        return (dw & TF_TTS_BUTTON_ENABLE ?  TRUE : FALSE );
    }

    HRESULT GetFocusDIM(ITfDocumentMgr **ppdim)
    {
        Assert(ppdim);
        *ppdim = NULL;
        if (_tim != NULL)
        {
            _tim->GetFocus(ppdim);
        }
        return *ppdim ? S_OK : E_FAIL;
    }

    BOOL  GetFocusIC(ITfContext **ppic)
    {
        ITfDocumentMgr *pdim = NULL;
        DWORD dwCandOpen = 0;
        HRESULT hr = S_OK;
        Assert(ppic != NULL);
        *ppic = NULL;

        if ( !m_fStageTip )
        {
            // This is not Stage Tip. Handle it as normal.
            hr = GetFocusDIM(&pdim);
        }
        else
        {
            // TABLET PC
            // Special case for Stage TIP

            // No focus DIM - send input to stage instead.
            // NOTE - We are GUARANTEED there is only one document manager for the stage.
            // We can therefore simply grab the first one and it will be the correct one.
            // SIMILARLY, the document manager has only ONE context, so we can simply grab
            // the top one and it will be the correct one.

            if (!m_cpStageDim)
            {
                // m_cpStageDim has not been initialized yet.
                IEnumTfDocumentMgrs *docenum;
                hr = _tim->EnumDocumentMgrs(&docenum);
                if (docenum)
                {
                    ULONG fetched;
                    hr = docenum->Next(1, &m_cpStageDim, &fetched);
                    docenum->Release();
                }
            }
            if (m_cpStageDim)
            {
                pdim = (ITfDocumentMgr *)m_cpStageDim;
                pdim->AddRef();
            }
        }

        if (pdim)
        {
            pdim->GetTop(ppic);

            if (*ppic)
            {
                // If candidate UI context, switch to GetBase() for document IC.
                GetCompartmentDWORD((IUnknown *)(*ppic), GUID_COMPARTMENT_MSCANDIDATEUI_CONTEXT, &dwCandOpen, FALSE);
                if (dwCandOpen)
                {
                    (*ppic)->Release();
                    *ppic = NULL;

                    if ( _AllowDictationWhileCandOpen( ) )
                        pdim->GetBase(ppic);
                }
            }

            pdim->Release();
        }

        return *ppic ? TRUE : FALSE;
    }

    HRESULT _SetFocusToStageIfStage(void);

    ITfCandidateUI *_pCandUIEx;

    void CloseCandUI( )
    {
        if ( _pCandUIEx )
            _pCandUIEx->CloseCandidateUI();
    }

    void ClearCandUI( )
    {
        if (_pCandUIEx)
        {
            // Close the UI if it is open.
            _pCandUIEx->CloseCandidateUI( );

            // And then release the object.
            _pCandUIEx->Release();
            _pCandUIEx = NULL;
        }
    }

    BOOL GetOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, &dw, TRUE);
        return dw ? TRUE : FALSE;
    }

    void SetOnOff(BOOL fOn, BOOL fForce = FALSE)
    {
        if (!fForce && fOn == GetOnOff())
            return;

        DWORD dw = fOn ? 1 : 0;
       
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_OPENCLOSE, dw, TRUE);
    }
    
    BOOL GetBalloonStatus()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw, TRUE);
        
        return (dw & TF_DISABLE_BALLOON) ? FALSE : TRUE;
        
    }
    void SetBalloonStatus(BOOL fShow, BOOL fForce = FALSE)
    {
        if (!fForce && fShow == GetBalloonStatus())
            return;

        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, &dw, TRUE);
        dw &= ~TF_DISABLE_BALLOON;
        dw |= fShow ? 0: TF_DISABLE_BALLOON;
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_UI_STATUS, dw, TRUE);
    }

    BOOL GetAudioOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SAPI_AUDIO, &dw, FALSE);
        return dw ? TRUE : FALSE;
    }

    void SetAudioOnOff(BOOL fOn)
    {
        if (fOn == GetAudioOnOff())
            return;

        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SAPI_AUDIO, fOn ? 0x01 : 0x00, FALSE);
    }

    BOOL GetDICTATIONSTAT_DictEnabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_DICTATION_ENABLED) ? TRUE : FALSE;
        
    }
    void SetDICTATIONSTAT_DictEnabled(BOOL fEnable)
    {
        Assert(!m_fStageTip || fEnable); // Stage tip instance should never disable dictation.
        if (fEnable == GetDICTATIONSTAT_DictEnabled())
            return;

        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        dw &= ~TF_DICTATION_ENABLED;
        dw |= fEnable ? TF_DICTATION_ENABLED : 0;
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
    }
    
    BOOL   GetDICTATIONSTAT_DictOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_DICTATION_ON) ? TRUE : FALSE;
    }

    void   SetDICTATIONSTAT_DictOnOff(BOOL fOn, BOOL fForce = FALSE)
    {
        if (!fForce && fOn == GetDICTATIONSTAT_DictOnOff())
            return;

        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        dw &= ~TF_DICTATION_ON;
        dw |= fOn ? TF_DICTATION_ON : 0;
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
    }

    BOOL   IsDICTATIONSTAT_CommandingEnable() 
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_COMMANDING_ENABLED) ? TRUE : FALSE;
    }

    void   SetDICTATIONSTAT_CommandingOnOff(BOOL fOn) 
    {
        DWORD dw;
        HRESULT hr = GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        if (S_OK != hr)
            return;

        BOOL fCurrentState = (dw & TF_COMMANDING_ON) ? TRUE : FALSE;

        if (fOn != fCurrentState)
        {
            dw &= ~TF_COMMANDING_ON;
            dw |= fOn ? TF_COMMANDING_ON : 0;
            SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
        }
    }

    BOOL   GetDICTATIONSTAT_CommandingOnOff()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return (dw & TF_COMMANDING_ON) ? TRUE : FALSE;
    }
    
#ifdef TF_DISABLE_SPEECH
    BOOL Get_SPEECH_DISABLED_Disabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_SPEECH) ? TRUE : FALSE;
    }

    BOOL Get_SPEECH_DISABLED_DictationDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_DICTATION) ? TRUE : FALSE;
    }

    BOOL Get_SPEECH_DISABLED_CommandingDisabled()
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DISABLED, &dw, FALSE);
        return (dw & TF_DISABLE_COMMANDING) ? TRUE : FALSE;
    }

    DWORD GetDictationStatBackup(void)
    {
        DWORD dw;
        GetCompartmentDWORD(_tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, &dw, FALSE);
        return dw;
    }

    void SetDictationStatAll(DWORD dw)
    {
        SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SPEECH_DICTATIONSTAT, dw, FALSE);
    }
#endif
    
    BOOL IsSharedReco() {return m_fSharedReco;  }

    LANGID GetLangID()  {return m_langid;}
    
    // worker window stuff
    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static void RegisterWorkerClass(HINSTANCE hInstance);
    void     _EnsureWorkerWnd(void);
    HWND    _GetWorkerWnd(void)     { return m_hwndWorker; }
    HWND    _GetAppMainWnd(void);

    HRESULT _ProcessText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *pic);
    HRESULT _RequestEditSession(UINT idEditSession, DWORD dwFlag, ESDATA *pesData=NULL, ITfContext *picCaller=NULL, LONG_PTR *pRetData=NULL, IUnknown **ppRetUnk = NULL);

    TfClientId _GetId() { return _tid; }
    
    ITfRange *GetSavedIP(void) {return m_cpRangeCurIP;}
    
    void SaveIPRange(ITfRange *pRange) 
    {
        m_cpRangeCurIP.Release();
        m_cpRangeCurIP = pRange; // comptr addrefs
    }
    void SaveCurrentIP (TfEditCookie ec, ITfContext *pic);

    HRESULT  _GetCmdThatRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRange);
    
    HRESULT InitializeSAPI(BOOL fLangOverride);
    HRESULT DeinitializeSAPI();
    void    _ReinitializeSAPI(void);

    HRESULT _FinalizeComposition();
    HRESULT FinalizeAllCompositions( );

    LIBTHREAD *_GetLibTLS()
    {
        return &_libTLS;
    }
    
    HRESULT _GetRangeText(ITfRange *pRange, DWORD dwFlgs, WCHAR *psz, ULONG *pulcch);
    BOOL    _IsRangeEmpty(ITfRange *pRange);
    HRESULT _HandleHypothesis(CSpEvent &event);
    void    _HandleHypothesis(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec);
    HRESULT _HandleFalseRecognition(void);
    HRESULT _HandleRecognition(CSpEvent &event, ULONGLONG *pullGramID);
    void    _HandleRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec);
    void    _FeedIPContextToSR(TfEditCookie ecReadOnly, ITfContext *pic, ITfRange *pRange);
    void     _SetCurrentIPtoSR(void);
    HRESULT  _InternalFeedCurrentIPtoSR(TfEditCookie ecReadOnly, ITfContext *pic);

    BOOL    HandleKey(WCHAR ch);

    void _InvokeSpeakerOptions( BOOL  fLaunchFromInputCpl = FALSE);

    BOOL   _GetIPChangeStatus( )  { return m_fIPIsUpdated; }
    void   _SetIPChangeStatus(BOOL fUpdated )  { m_fIPIsUpdated = fUpdated; }

    void   _SetCharTypeTimer(  )  
    { 
        //  if m_dwNumCharTyped is 0, means this is the first time to set this timer, or 
		//  the previous timer has been killed, we need to start another timer.
		//
		//  if m_dwNumCharTyped is larger than 0, means the timer has already been started,
		//  but not yet been killed. we don't need to set the timer again, just increase the
		//  m_dwNumCharTyped.
		//
		//  m_dwNumCharTyped wants to keep the number of key strokes during this timer period.
		//

        if ( m_dwNumCharTyped == 0)
        {
            SetTimer(m_hwndWorker, TIMER_ID_CHARTYPED, 400, NULL);
        }

		m_dwNumCharTyped++;
    }

    void _KillCharTypeTimer( )
    {
        if ( m_dwNumCharTyped )
        {
            KillTimer(m_hwndWorker, TIMER_ID_CHARTYPED);
            m_dwNumCharTyped = 0;
        }
    }

    DWORD  _GetNumCharTyped( )   { return m_dwNumCharTyped; }

    BOOL _AcceptRecoResultTextUpdates()
    {
        return m_fAcceptRecoResultTextUpdates;
    }

    HRESULT _AddFeedbackUI(TfEditCookie ec, ColorType ct, LONG cch);
    void _CheckStartComposition(TfEditCookie ec, ITfRange *pRange);
    HRESULT _FinalizePrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);

    CCapCmdHandler  *GetCapCmdHandler( ) {
        if ( !m_pCapCmdHandler )
        {
            m_pCapCmdHandler = new CCapCmdHandler(this);
        }

        return m_pCapCmdHandler;
    }

    // TABLETPC
    HRESULT IsActiveThread()
    {
        if (m_fStageTip)
        {
            // To avoid a race condition with no immediately available solution, we are now active only when the stage is visible.
            if (m_fStageVisible)
            {
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }
        else if (m_fStageVisible)
        {
            // Stage is visible. We are always inactive since we are not the stage.
            return S_FALSE;
        }
        else
        {
            // Stage is not visible. We're active if we have focus as normal Cicero.
            BOOL fThreadFocus = FALSE;
            HRESULT hr = S_OK;
            hr = _tim->IsThreadFocus(&fThreadFocus);
            hr = (S_OK == hr) ? ( (fThreadFocus) ? S_OK : S_FALSE ) : hr;
            return hr;
        }
    }

    // TABLETPC
    BOOL IsStageTip(void)
    {
        return m_fStageTip;
    }

    friend CCorrectionHandler;
    friend CCapCmdHandler;
    friend CSapiEditSession;

private:
    HRESULT _ProcessTextInternal(TfEditCookie ec, WCHAR *pwszText, GUID input_attr, LANGID langid, ITfContext *pic, BOOL fPreserveResult, BOOL fSpelling = FALSE);
    HRESULT _ProcessSpelledText(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid, BOOL fOwnerId = FALSE);
    HRESULT _ProcessModebiasText(TfEditCookie ec, WCHAR *pwszText, LANGID langid, ITfContext *pic);
    HRESULT _ProcessSpelledTextWithOwner(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid)
            {
                return _ProcessSpelledText(ec, pic, pwszText, langid, TRUE);
            }
    HRESULT _ProcessRecoObject(TfEditCookie ec, ISpRecoResult *pResult, ULONG ulStartElement, ULONG ulNumElements);
    HRESULT _PreserveResult(TfEditCookie ec, ITfRange *pRange, ITfProperty *pProp, CRecoResultWrap **ppRecoWrap, ITfRange **ppPropRange);
    HRESULT _RestoreResult(TfEditCookie ec, ITfRange *pPropRange, ITfProperty *pProp, CRecoResultWrap *pRecoWrap);
    HRESULT _SetFilteringString(TfEditCookie ec, ITfCandidateUI *pCandUI, ITfContext *pic);
    HRESULT _HandleTrainingWiz(void);
    HRESULT _ProcessSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, ULONG ulNumTrailSpace, LANGID langid, BOOL fStartInMidWord=FALSE, BOOL fEndInMidWord=FALSE);
    HRESULT _ProcessLeadingSpaces(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, BOOL  fConsumeLeadSpaces, LANGID langid, BOOL fStartInMidWord=FALSE);

    HRESULT _GetSpaceRangeBeyondText(TfEditCookie ec, ITfRange *pTextRange, BOOL fBefore, ITfRange  **ppSpaceRange, BOOL *pfRealTextBeyond = NULL);
    HRESULT _ProcessTrailingSpace(TfEditCookie ec, ITfContext *pic, ITfRange *pTextRange, ULONG ulNumTrailSpace);

    // private utility routines
    HRESULT _FindPropRange(TfEditCookie ec, ITfProperty *pProp, ITfRange *pRange, ITfRange **ppAttrRange, GUID input_attr, BOOL fExtend = FALSE);
    HRESULT _SetLangID(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LANGID langid);
    HRESULT _KillFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    HRESULT _KillOrDetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL * pfDetection);
    HRESULT _DetectFeedbackUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    HRESULT _KillFocusRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid);
    HRESULT _KillLastPhrase(TfEditCookie ec, ITfContext *pic);
    HRESULT _ProcessControlKeys(TfEditCookie ec, ITfContext *pic, WCHAR *pwszKey, ULONG ulLen, LANGID langid);
    HRESULT _ProcessEditCommands(TfEditCookie ec, ITfContext *pic, LONG  idSharedCmd);
    HRESULT _ProcessSpellThat(TfEditCookie ec, ITfContext *pic);
    HRESULT _ProcessSpellIt(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, LANGID langid); 

    HRESULT _FinalizeAllCompositions(TfEditCookie ec, ITfContext *pic);

    static BOOL _FindComposition(TfEditCookie ec, ITfContextComposition *picc, ITfRange *pRange, ITfCompositionView **ppCompositionView);
    static void _CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate);


    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);
    
    int _FindPrevComp(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppRangeOut, GUID input_attr);
    
    // hack up for Office as of  8/20
    HRESULT MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, TfClientId tid, CSpTask *pCSpTask);
    HRESULT AbortString(TfEditCookie ec, ITfContext *pic, CSpTask *pCSpTask);

    // hacks for SAPI objects
    void _ShutDown(BOOL bMode);

    // callback entry point for CTextEventSink
    static HRESULT _TextEventSinkCallback(UINT uCode, void *pv, void *pvData);
    
    static HRESULT _ICCallback(UINT uCode, ITfContext *pic, void *pv);
    static HRESULT _DIMCallback(UINT uCode, ITfDocumentMgr *dim, ITfDocumentMgr * pdimPrevFocus, void *pv);
    static HRESULT _PreKeyCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);
    static HRESULT _KeyEventCallback(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv);
    static HRESULT _PreKeyEventCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);

    BOOL _IsDoubleClick(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus);
    static HRESULT _MouseSinkCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv);
    HRESULT _HandleMouseSink(TfEditCookie ec, ULONG uEdge, ULONG uBtnStatus, BOOL fDblClick);
    void _DeleteICPriv(CICPriv *priv, ITfContext *pic);
    void _InitICPriv(CICPriv *priv, ITfContext *pic);
    HRESULT _GetSelectionAndStatus(ITfContext *pic, TESENDEDIT *pee, ITfRange **ppRange, BOOL *pfUpdated);
    void HandleTextEvent(ITfContext *pic, TESENDEDIT *pee);
    void SyncWithCurrentModeBias(TfEditCookie ec, ITfRange *pRange, ITfContext *pic);
    HRESULT _SyncModeBiasWithSelection(ITfContext *pic);
    HRESULT _SyncModeBiasWithSelectionCallback(TfEditCookie ec, ITfContext *pic);



    typedef enum 
    {
        MICSTAT_NA  = 0x0,
        MICSTAT_OFF = 0x1,
        MICSTAT_ON  = 0x2
    
    } MIC_STATUS;
    HRESULT _HandleOpenCloseEvent(MIC_STATUS ms = MICSTAT_NA);
    

    // our cicero client id
    TfClientId _tid;

    // set FALSE if we're between Activate/Deactivate calls
    BOOL _fDeactivated;

    // 'in editing' flag
    BOOL _fEditing;

    // current mode bias
    TfGuidAtom _gaModebias;

    CSpTask *m_pCSpTask;

    // Cicero object pointers
    CThreadMgrEventSink *m_timEventSink;
    
    HWND m_hwndWorker;
    
    // compartment (storage) event sink
    CCompartmentEventSink *m_pCes;

public:
    // System lang bar item event sink
    CSystemLBarSink *m_pLBarItemSink;
    static HRESULT _SysLBarCallback(UINT uCode, void *pv, ITfMenu *pMenu, UINT wID);
    CSpeechUIServer *GetSpeechUIServer() {return m_pSpeechUIServer;}
private:
    static HRESULT _ActiveTipNotifySinkCallback(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated, void *pv);
    static HRESULT _LangChangeNotifySinkCallback(BOOL fChanged, LANGID langid, BOOL *pfAccept, void *pv);
    
    BOOL InitializeSpeechButtons();

    void GetSapiCplPath(TCHAR *szCplPath, int cchSizePath);

    // Notify UI
    CSpeechUIServer *m_pSpeechUIServer;
    BOOL  m_fShowBalloon;
    
    CComPtr<ITfLangBarItem>  m_cpMicButton;

#ifdef SUPPORT_INTERNAL_WIDGET
    // widget instance
    CComPtr<ITfTextInputProcessor> m_cpCorrectionUI;
    BOOL                           m_fNoCorrectionUI;
#endif

    // Hotkey event sink
    CSptipKeyEventSink *_pkes;
    DWORD _dwHotKeyCookie[3];

    DWORD _dwThreadFocusCookie;
    DWORD _dwKeyTraceCookie;
    
    // the current saved IP
    CComPtr<ITfRange> m_cpRangeCurIP;
    
    LANGID                                 m_langid;
    
    BOOL               m_fIPIsUpdated;  
                       // Check to see if IP is updated after dictation.

    DWORD              m_dwNumCharTyped;  // Keep the Number of Char typed during the timer period.

                                          // Every time user types a char,we want to temporally disable
                                          // dictation if current dictation mode is on.
                                          //
                                          // After we temporally disable the dication, we need to 
                                          // monitor a period of time to see if the typing or
                                          // editing is finished, and then we can enable dication
                                          // again.

    ULONG              m_ulSimulatedKey;  // Indicates if the key event is simulated by speech tip
                                          // dictation command, such as "Next Line", "Tab", 
                                          // "Next Cell", "Backspace", Space, SpaceBar. etc.
                                          // "Ctrl+C", "Ctrl+V" may contain more keystrokes.
                                          // This member would keep the number of simulated keys.
                                          // If the key is not simulated, this value is 0.

    SpButtonControl    *m_pSpButtonControl;
    BOOL                m_fModeKeyRegistered;
    
    // active input processor notify sink
    // PerfConsider: have this object expose the iface directly instead of allocating a heap object
    CActiveLanguageProfileNotifySink *m_pActiveLanguageProfileNotifySink;
    CLanguageProfileNotifySink       *m_pLanguageChangeNotifySink;

    // mouse stuff
    CMouseSink                       *m_pMouseSink;
    BOOL                              m_fMouseDown;
    ULONG                             m_ichMouseSel;

    ULONG                             m_uLastEdge;
    ULONG                             m_uLastQuadrant;
    LONG                              m_lTimeLastClk;

   
    CCapCmdHandler    *m_pCapCmdHandler; 

    BOOL m_fSharedReco;
    BOOL m_fDictationEnabled;

    BOOL m_fAcceptRecoResultTextUpdates : 1; // set true to preserve reco property data during SetText
    BOOL m_fStartingComposition : 1; // set true when blocked by StartComposition() call

    LIBTHREAD   _libTLS; // tls for the helper library. Since this object is apt threaded,
                         // all members are accessed in a single thread
                         // also, cicero will only create a single instance of this obj per thread
    TCHAR  m_szCplPath[MAX_PATH];

    // TABLETPC
    BOOL m_fStageTip;
    BOOL m_fStageVisible;
    HWND m_hwndStage;
    CComPtr<ITfDocumentMgr>    m_cpStageDim;
    ULONG                      m_ulHypothesisLen;
    ULONG                      m_ulHypothesisNum;

    BOOL                       m_IsInHypoProcessing;


    long _cRef;
};
// defines maximum # of alternates to get for candidate
#define MAX_NUM_ALTERNATES                48

#define LATER_FOR_BUG1001

#endif // SAPILAYR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\selword.cpp ===
//
//
// Sapilayr TIP CSelectWord implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "selword.h"

// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CSearchString
//
// -----------------------------------------------------------------------------------------------------------

CSearchString::CSearchString( )
{
    m_pwszTextSrchFrom = NULL;
    m_langid = 0;
    m_fInitialized = FALSE;
}

CSearchString::~CSearchString( )
{
}

//
//  Initialize
//  
//  Initialize searched string and string to search from, calculate the length for 
//  these two strings.
//
//  Also initialze the search runs based on current selection offsets.
//
HRESULT  CSearchString::Initialize(WCHAR *SrchStr, WCHAR *SrchFromStr, LANGID langid, ULONG ulSelStartOff, ULONG ulSelLen)
{
    HRESULT  hr = S_OK;

    if ( m_fInitialized )
    {
        // Clean up the previous Initialization data.
        m_dstrTextToSrch.Clear( );

        m_fInitialized = FALSE;
    }

    if ( !SrchStr || !SrchFromStr )
        return E_INVALIDARG;

    m_langid = langid;

    m_pwszTextSrchFrom = SrchFromStr;
    m_dstrTextToSrch.Append(SrchStr);

    m_ulSrchFromLen = wcslen(SrchFromStr);
    m_ulSrchLen = wcslen(SrchStr);

    if ( _InitSearchRun(ulSelStartOff, ulSelLen) )
    {
        m_fInitialized = TRUE;
    }
    else
    {
        // Something wrong when Initialize Search Run
        // cleanup the string

        m_dstrTextToSrch.Clear( );
        m_pwszTextSrchFrom = NULL;
        m_ulSrchFromLen = m_ulSrchLen = 0;
        
        m_fInitialized = FALSE;
        hr = E_FAIL;
    }

    return hr;
}

//
//  Set data for each Search Run
//
//
void   CSearchString::_SetRun(Search_Run_Id  idSearchRun, ULONG ulStart, ULONG ulEnd, BOOL fStartToEnd)
{
    if ( idSearchRun >= SearchRun_MaxRuns )  return;
    m_pSearchRun[idSearchRun].ulStart = ulStart;
    m_pSearchRun[idSearchRun].ulEnd = ulEnd;
    m_pSearchRun[idSearchRun].fStartToEnd = fStartToEnd;
    return;
}

//
//  CSearchString::_InitSearchRun
//  
//  Initialize all possible search runs based on 
//  Current selection.
//
//
BOOL    CSearchString::_InitSearchRun(ULONG ulSelStartOff, ULONG ulSelLen)
{
    ULONG  ulDeltaForExpand = 20;
    ULONG  ulStart, ulEnd;
    
    if (!m_pwszTextSrchFrom || !m_ulSrchFromLen )
        return FALSE;

    // Initialize all the search run.
    for (int  id=SearchRun_Selection; id < SearchRun_MaxRuns; id++)
    {
        _SetRun((Search_Run_Id)id, 0, 0, FALSE);
    }

    // Initialize the Selection search run.

    ulStart = ulSelStartOff;
    ulEnd = ulStart + ulSelLen;

    if ( ulStart >= m_ulSrchFromLen )
        ulStart = m_ulSrchFromLen - 1;

    if ( ulEnd >= m_ulSrchFromLen )
        ulEnd = m_ulSrchFromLen - 1;

    if ( m_langid == 0x0409 )
    {
        // Find the word around the current IP or selection
        WCHAR   wch;

        // Find the first character which is not an alpha letter.
        while ( ulStart > 0 )
        {
            wch = m_pwszTextSrchFrom[ulStart-1];
            if ( !iswalpha(wch) )
            {
              // Found first non-alpha character before IP
              // the previous character must be the first char of a word.
                break;
            }
            ulStart --;
        }

        // Find the first character which is not an alpha letter
        while ( ulEnd < m_ulSrchFromLen-1)
        {
            wch = m_pwszTextSrchFrom[ulEnd+1];
            if ( !iswalpha(wch) )
            {
               // Found the first non-alpha character after IP
               break;
            }
            ulEnd ++;
        }
    }

    _SetRun(SearchRun_Selection, ulStart, ulEnd, TRUE);

    // Initialize the enlarged selection run

    if ( ulStart < ulDeltaForExpand)
         ulStart = 0;
    else
         ulStart = ulStart - ulDeltaForExpand;

    if ( ulEnd + ulDeltaForExpand > (m_ulSrchFromLen-1) )
         ulEnd = m_ulSrchFromLen-1;
    else
         ulEnd = ulEnd + ulDeltaForExpand;

    _SetRun(SearchRun_LargeSelection, ulStart, ulEnd, TRUE );

    // Initialize SearchRun_BeforeSelection run
    if ( ulStart > 0 )
    {
        ULONG  ulEndTmp;

        if ( ulSelStartOff >= m_ulSrchFromLen )
            ulEndTmp = m_ulSrchFromLen-1;
        else
            ulEndTmp = ulSelStartOff;

        _SetRun(SearchRun_BeforeSelection, 0, ulEndTmp , FALSE);
    }

    // Initialize SearchRun_AfterSelection if it exists.

    if ( ulEnd < (m_ulSrchFromLen-1) )
    {
        ulStart = ulSelStartOff+ ulSelLen;
        ulEnd = m_ulSrchFromLen-1;

        _SetRun(SearchRun_AfterSelection, ulStart, ulEnd, TRUE);
    }

    return TRUE;
}

//
//  Search m_dstrTextToSrch from m_pwszTextSrchFrom in one search run.
//
//  return TRUE if this run of m_pwszTextSrchFrom contains m_dstrTextToSrch
//  and update the data member m_ulFoundOffset.
//
BOOL     CSearchString::_SearchOneRun(Search_Run_Id  idSearchRun)
{
    BOOL     fFound = FALSE;
    ULONG    ulStart, ulEnd;
    BOOL     fStartToEnd;

    if ( !m_fInitialized || idSearchRun >= SearchRun_MaxRuns )
        return fFound;

    m_ulFoundOffset = 0;

    ulStart = m_pSearchRun[idSearchRun].ulStart;
    ulEnd   = m_pSearchRun[idSearchRun].ulEnd;
    fStartToEnd = m_pSearchRun[idSearchRun].fStartToEnd;

    if (ulStart >= m_ulSrchFromLen || ulEnd >= m_ulSrchFromLen)
        return fFound;

    if ( ulStart > ulEnd )
    {
        // swap the anchors
        ULONG  ulTemp;

        ulTemp  = ulEnd;
        ulEnd   = ulStart;
        ulStart = ulTemp;
    }

    if ( (ulEnd - ulStart + 1) >= m_ulSrchLen )
    {
        BOOL    bSearchDone = FALSE;
        ULONG   iStart;

        if ( fStartToEnd )
            iStart = ulStart;
        else
            iStart = ulEnd-m_ulSrchLen + 1;

        while ( !bSearchDone )
        {
            WCHAR   *pwszTmp;
                
            pwszTmp = m_pwszTextSrchFrom + iStart;
            if ( _wcsnicmp(m_dstrTextToSrch, pwszTmp, m_ulSrchLen) == 0 )
            {
                // if the string is in middle of a word in the FromStr
                // ignore it, find again.
                BOOL   fInMiddleWord = FALSE;

                if ( m_langid == 0x0409 )
                {
                    WCHAR szSurrounding[3] = L"  ";

                    if (iStart > 0)
                        szSurrounding[0] = m_pwszTextSrchFrom[iStart - 1];

                    if (iStart + m_ulSrchLen < m_ulSrchFromLen)
                        szSurrounding[1] = m_pwszTextSrchFrom[iStart + m_ulSrchLen];

                    if (iswalpha(szSurrounding[0]) || iswalpha(szSurrounding[1]) )
                        fInMiddleWord = TRUE;
                }
                
                if ( !fInMiddleWord )
                {
                    fFound = TRUE;
                    m_ulFoundOffset = iStart;
                    bSearchDone = TRUE;
                    break;
                }
            }

            if ( fStartToEnd )
            {
                if ( iStart >= ulEnd-m_ulSrchLen + 1 )
                    bSearchDone = TRUE;
                else
                    iStart ++;
            }
            else
            {
                if ( (long)iStart <= (long)ulStart )
                    bSearchDone = TRUE;
                else
                    iStart --;
            }
        }
    }

    return fFound;
}

//
//  Search all the search runs 
//
//  returns TRUE or FALSE and the offset of the matched substring.
//
BOOL     CSearchString::Search(ULONG  *pulOffset, ULONG  *pulSelSize)
{
    BOOL  fFound = FALSE;
    
    if ( !m_fInitialized ) return FALSE;

    for (int idRun=SearchRun_Selection; idRun < SearchRun_MaxRuns; idRun++ )
    {
        fFound = _SearchOneRun((Search_Run_Id)idRun);

        if ( fFound )
            break;
    }

    if ( fFound && pulOffset)
    {
        *pulOffset = m_ulFoundOffset;

        if ( pulSelSize ) 
        {
            ULONG         ulWordLen = m_ulSrchLen;

            // check if there are some trail spaces after the word.
            // include those trail spaces in the selection.

            for ( ULONG  i= m_ulFoundOffset + m_ulSrchLen; i<m_ulSrchFromLen; i++ )
            {
                if ( m_pwszTextSrchFrom[i] == L' ')
                    ulWordLen ++;
                else
                    break;
            }

            *pulSelSize = ulWordLen;
        }
    }

    return fFound;
}

// ----------------------------------------------------------------------------------------------------------
//
//  Implementation for CSelectWord
//
// -----------------------------------------------------------------------------------------------------------

CSelectWord::CSelectWord(CSapiIMX *psi) 
{
    m_psi = psi;
    m_pwszSelectedWord = NULL;
    m_ulLenSelected = 0;
}

CSelectWord::~CSelectWord( ) 
{

};

/*  --------------------------------------------------------
//    Function Name: UpdateTextBuffer
//
//    Description: Get current active text, fill them to the
//                 selword grammar's text buffer.
//
//                 After every recognition, we want to update 
//                 text buffer again based on new text.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::UpdateTextBuffer(ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar)
{
    HRESULT               hr = E_FAIL;
    CComPtr<ITfContext>   cpic = NULL;
    CSelWordEditSession   *pes;

    if ( !pCmdGrammar  || !pRecoCtxt)
        return E_INVALIDARG;

    if ( !m_psi )
        return E_FAIL;

    // Start an edit session, get current active text, fill to the selword grammar, active it
    // and then resume the grammar state.

    if (m_psi->GetFocusIC(&cpic) && cpic )
    {
        if (pes = new CSelWordEditSession(m_psi, this, cpic))
        {
            pes->_SetEditSessionData(ESCB_UPDATE_TEXT_BUFFER, NULL, 0);
            pes->_SetUnk((IUnknown *)pRecoCtxt);
            pes->_SetUnk2((IUnknown *)pCmdGrammar);

            cpic->RequestEditSession(m_psi->_GetId( ), pes, TF_ES_READ, &hr);
            pes->Release();
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _UpdateTextBuffer
//
//    Description:  Edit session callback function for 
//                  UpdateTextBuffer.
//
//                  It will do the real work about extracting
//                  text and updating grammar buffer.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_UpdateTextBuffer(TfEditCookie ec,ITfContext *pic, ISpRecoContext *pRecoCtxt, ISpRecoGrammar *pCmdGrammar)
{
    HRESULT   hr = S_OK;
    BOOL      fPaused = FALSE;

    // Get current active text, fill to the selword grammar.

    hr = _GetTextAndSelectInCurrentView(ec, pic, NULL, NULL);

    if ( hr == S_OK )
    {
        pRecoCtxt->Pause(0);
        fPaused = TRUE;
    }

    if ((hr == S_OK) && m_dstrActiveText)
    {
        // AddWordSequenceData to the grammar.

        SPTEXTSELECTIONINFO tsi = {0};
        ULONG     ulLen;

        ulLen = wcslen(m_dstrActiveText);

        tsi.ulStartActiveOffset = 0;
        tsi.cchActiveChars = ulLen;
        tsi.ulStartSelection = 0;
        tsi.cchSelection     = ulLen;

        WCHAR *pMemText = (WCHAR *)cicMemAlloc((ulLen+2)*sizeof(WCHAR));

        if (pMemText)
        {
            memcpy(pMemText, m_dstrActiveText, sizeof(WCHAR) * ulLen);
            pMemText[ulLen] = L'\0';
            pMemText[ulLen + 1] = L'\0';

            hr = pCmdGrammar->SetWordSequenceData(pMemText, ulLen + 2, &tsi);

            cicMemFree(pMemText);
        }
    }

    // Resume the recoContext.

    if ( fPaused )
    {
        pRecoCtxt->Resume(0);

    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GetTextAndSelectInCurrentView
//
//    Description:  Get text from currect active view.
//                  ( visible area )
//
//                  it is a common function called by other
//                  edit session callback functions
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GetTextAndSelectInCurrentView(TfEditCookie ec,ITfContext *pic, ULONG *pulOffSelStart, ULONG  *pulSelLen) 
{
    HRESULT  hr = S_OK;

    TraceMsg(TF_GENERAL, "CSelectWord::_GetTextAndSelectInCurrentView is called");

    if ( !pic ) return E_FAIL;

    CComPtr<ITfRange>   cpRangeView;

    // Get the Active View Range
    hr = _GetActiveViewRange(ec, pic, &cpRangeView);

    if( hr == S_OK )
    {
        CComPtr<ITfRange>   cpRangeCloned;
        BOOL                fCareSelection = FALSE;
        CComPtr<ITfRange>   cpCurSelection;
        ULONG               ulSelStartOffset = 0;
        ULONG               ulSelLen = 0;
        BOOL                fIPInsideActiveView = FALSE;
        BOOL                fIPIsEmpty = TRUE;

        m_cpActiveRange = cpRangeView;

        // Clean all the text filled previously.
        m_dstrActiveText.Clear( );

        if ( pulOffSelStart && pulSelLen )
        {
            fCareSelection = TRUE;
        }

        if ( fCareSelection )
        {
            //
            // Get the current selection and try to get the offset 
            // for this selection's start anchor and length.
            //

            if ( hr == S_OK )
                hr = GetSelectionSimple(ec, pic, &cpCurSelection);

            if ( hr == S_OK )
            {
                long                l1=0, l2=0;
                CComPtr<ITfRange>   cpRangeTemp;
            
                hr = m_cpActiveRange->Clone(&cpRangeTemp);

                if ( hr == S_OK )
                {
                    hr = cpCurSelection->CompareStart(ec, m_cpActiveRange,  TF_ANCHOR_START, &l1);
                    if ( hr == S_OK )
                        hr = cpCurSelection->CompareEnd(ec, m_cpActiveRange,  TF_ANCHOR_END, &l2);
                }

                if ( hr == S_OK && (l1>=0  && l2<=0) )
                {
                    // the IP is inside this active view.

                    fIPInsideActiveView = TRUE;
                    hr = cpCurSelection->IsEmpty(ec, &fIPIsEmpty);
                }
            }
        }

        if ( hr == S_OK )
        {
            // Get the text from the current active window view
            if ( !fIPInsideActiveView || !fCareSelection )
            {
                hr = m_cpActiveRange->Clone(&cpRangeCloned);
                if ( hr == S_OK )
                    hr = _GetTextFromRange(ec, cpRangeCloned, m_dstrActiveText);
            }
            else
            {
                // Ip is inside active view
                // Get the text from Start anchor of active view to start anchor of 
                // selection first to get the offset of the select start anchor.
                hr = m_cpActiveRange->Clone(&cpRangeCloned);

                if ( hr == S_OK )
                    hr = cpRangeCloned->ShiftEndToRange(ec, cpCurSelection, TF_ANCHOR_START);

                if ( hr == S_OK)
                    hr = _GetTextFromRange(ec, cpRangeCloned, m_dstrActiveText);

                if ( hr == S_OK )
                    ulSelStartOffset = m_dstrActiveText.Length( );

                // Get the length of selection if it is not empty.
                if ( hr == S_OK && !fIPIsEmpty)
                {
                    ULONG   ulLenOrg;

                    ulLenOrg = m_dstrActiveText.Length( );

                    hr = _GetTextFromRange(ec, cpCurSelection, m_dstrActiveText);

                    if ( hr == S_OK )
                       ulSelLen = m_dstrActiveText.Length( ) - ulLenOrg;
                }

                if ( hr == S_OK )
                    hr = cpRangeCloned->ShiftStartToRange(ec, cpCurSelection, TF_ANCHOR_END);

                if ( hr == S_OK )
                    hr = cpRangeCloned->ShiftEndToRange(ec, m_cpActiveRange, TF_ANCHOR_END);

                if ( hr == S_OK)
                    hr = _GetTextFromRange(ec, cpRangeCloned, m_dstrActiveText);
            }
        }

        if ( hr == S_OK  && pulOffSelStart && pulSelLen)
        {
            *pulOffSelStart = ulSelStartOffset;
            *pulSelLen = ulSelLen;
        }
    }

#ifdef DEBUG
    if ( m_dstrActiveText )
    {
        TraceMsg(TF_GENERAL, "dstrText is : =================================");
        TraceMsg(TF_GENERAL, "%S",(WCHAR *)m_dstrActiveText);
        TraceMsg(TF_GENERAL, "================================================");
    }
#endif

    return hr;
}

//
// GetText from a given range.
//
HRESULT  CSelectWord::_GetTextFromRange(TfEditCookie ec, ITfRange *pRange, CSpDynamicString &dstr)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeCloned;
    BOOL                fEmpty = TRUE;

    if ( !pRange ) return E_FAIL;

    hr = pRange->Clone(&cpRangeCloned);

    // Get the text from the given range
    while(S_OK == hr && (S_OK == cpRangeCloned->IsEmpty(ec, &fEmpty)) && !fEmpty)
    {
        WCHAR            sz[128];
        ULONG            ucch;
        hr = cpRangeCloned->GetText(ec, TF_TF_MOVESTART, sz, ARRAYSIZE(sz)-1, &ucch);

        if ( ucch == 0 )
        {
            TraceMsg(TF_GENERAL, "cch is 0 after GetText call in _GetTextFromRange");
            break;
        }

        if (S_OK == hr)
        {
            sz[ucch] = L'\0';
            dstr.Append(sz);
        }
    }

    return hr;
}

/* ------------------------------------------------------------
//    Function Name : _GetCUASCompositionRange
//
//    Description:  Get the range to cover all the text in 
//                  Non-Cicero aware application's composition
//                  window. (include AIMM app and CUAS app). 
// ------------------------------------------------------------*/
HRESULT  CSelectWord::_GetCUASCompositionRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView)
{
    HRESULT                     hr = S_OK;
    CComPtr<ITfRange>           cpRangeStart, cpRangeEnd;

    Assert(ppRangeView);
    Assert(pic);

    hr = pic->GetStart(ec, &cpRangeStart);

    if ( hr == S_OK )
        hr = pic->GetEnd(ec, &cpRangeEnd);

    if (hr == S_OK && cpRangeStart && cpRangeEnd)
    {
        hr = cpRangeStart->ShiftEndToRange(ec, cpRangeEnd, TF_ANCHOR_END);

        if (hr == S_OK && ppRangeView)
            hr = cpRangeStart->Clone(ppRangeView);
    }

    return hr;
}


/* --------------------------------------------------------
//    Function Name : _GetActiveViewRange
//
//    Description:  Get the range to cover current active
//                  view ( visible area ), no matter if the
//                  text is in horizontal or vertical or 
//                  even bidi. 
//
//                  It is a common function called by other
//                  edit session callback functions
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GetActiveViewRange(TfEditCookie ec, ITfContext *pic, ITfRange **ppRangeView)
{
    HRESULT                     hr = S_OK;
    CComPtr<ITfContextView>     pContextView;
    RECT                        rcTextWindow;
    CComPtr<ITfRange>           cpRangeStart, cpRangeEnd;
    CComPtr<ITfRange>           cpRangeView;

    BOOL                        fPureCicero = TRUE;

    Assert(ppRangeView);
    Assert(pic);

    fPureCicero = m_psi->_IsPureCiceroIC( pic );

    if ( !fPureCicero )
    {
        hr = _GetCUASCompositionRange(ec, pic, ppRangeView);
        return hr;
    }

    hr = pic->GetActiveView(&pContextView);

    // Get the text view window rectangle.
    if ( hr == S_OK )
        hr = pContextView->GetScreenExt(&rcTextWindow);

    if ( hr == S_OK )
    {
        POINT               CornerPoint[4];
        CComPtr<ITfRange>   cpRangeCorner[4];
        LONG                i;

        // Get ranges for four corners.
        // Upper Left point
        CornerPoint[0].x = rcTextWindow.left;
        CornerPoint[0].y = rcTextWindow.top;

        // Upper Right Point
        CornerPoint[1].x = rcTextWindow.right;
        CornerPoint[1].y = rcTextWindow.top;

        // Lower Left point
        CornerPoint[2].x = rcTextWindow.left;
        CornerPoint[2].y = rcTextWindow.bottom;

        // Lower Right point
        CornerPoint[3].x = rcTextWindow.right;
        CornerPoint[3].y = rcTextWindow.bottom;

        i = 0;
        do 
        {
            hr = pContextView->GetRangeFromPoint(ec, &(CornerPoint[i]),GXFPF_NEAREST,&(cpRangeCorner[i]));
            i++;
        } while (hr == S_OK && i<ARRAYSIZE(cpRangeCorner));

        // Now try to get the start range and end range.

        if (hr == S_OK)
        {
            cpRangeStart = cpRangeCorner[0];
            cpRangeEnd = cpRangeCorner[0];

            i = 1;
            do 
            {
                long l;

                hr = cpRangeStart->CompareStart(ec, cpRangeCorner[i], TF_ANCHOR_START, &l);

                if ( hr == S_OK  && l > 0)
                {
                    // this range is in front of the current Start range.
                    cpRangeStart = cpRangeCorner[i];
                }

                if ( hr == S_OK )
                    hr = cpRangeEnd->CompareStart(ec, cpRangeCorner[i], TF_ANCHOR_START, &l);

                if ( hr == S_OK && l < 0 )
                {
                    // This range is behind of current end range.
                    cpRangeEnd = cpRangeCorner[i];
                }

                i++;
            } while ( hr == S_OK && i<ARRAYSIZE(cpRangeCorner));
        }
    }

    // Now generate the new active view range.

    if (hr == S_OK && cpRangeStart && cpRangeEnd)
    {
        cpRangeView = cpRangeStart;
        hr = cpRangeView->ShiftEndToRange(ec, cpRangeEnd, TF_ANCHOR_END);

        if (hr == S_OK && ppRangeView)
            hr = cpRangeView->Clone(ppRangeView);
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: ProcessSelectWord
//
//    Description: public functions used by command handler
//                 to handle any selecton related dictation
//                 commands.
//
// ----------------------------------------------------------*/
HRESULT   CSelectWord::ProcessSelectWord(WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION sw_type, ULONG ulLenXXX)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITfContext> cpic = NULL;

    if ( !m_psi )
        return E_FAIL;

    if ( (sw_type < SELECTWORD_MAXTEXTBUFF ) && (pwszSelectedWord == NULL ||  ulLen == 0) )
        return E_INVALIDARG;

    if ( m_psi->GetFocusIC(&cpic) && cpic )
    {
		CSelWordEditSession *pes;

        if (pes = new CSelWordEditSession(m_psi, this, cpic))
        {
            pes->_SetEditSessionData(ESCB_PROCESSSELECTWORD, 
                                     (void *)pwszSelectedWord, 
                                     (ulLen+1) * sizeof(WCHAR), 
                                     (LONG_PTR)ulLen, 
                                     (LONG_PTR)sw_type);

            pes->_SetLenXXX( (LONG_PTR)ulLenXXX );
            cpic->RequestEditSession(m_psi->_GetId( ), pes, TF_ES_READWRITE, &hr);
        }
        pes->Release();
    }
    return hr;
}


/*  --------------------------------------------------------
//    Function Name: _HandleSelectWord
//
//    Description:   Edit session call back funtion for 
//                   ProcessSelectionWord.
//
//                   it does real work for selection handling
// ----------------------------------------------------------*/
HRESULT CSelectWord::_HandleSelectWord(TfEditCookie ec,ITfContext *pic, WCHAR *pwszSelectedWord, ULONG  ulLen, SELECTWORD_OPERATION sw_type, ULONG ulLenXXX)
{
    HRESULT   hr = S_OK;

    // Get the Dictation Grammar

    TraceMsg(TF_GENERAL, "_HandleSelectWord() is called");

    if ( m_psi == NULL)
        return E_FAIL;

    m_pwszSelectedWord = pwszSelectedWord;
    m_ulLenSelected = ulLen;

    // Deliberately ignore return code.
    (void)m_psi->_SetFocusToStageIfStage();

    switch ( sw_type )
    {
    case  SELECTWORD_SELECT :
        hr = _SelectWord(ec, pic);
        break;

    case  SELECTWORD_DELETE :
        hr = _DeleteWord(ec, pic);
        break;

    case  SELECTWORD_INSERTBEFORE :
        hr = _InsertBeforeWord(ec, pic);
        break;

    case  SELECTWORD_INSERTAFTER  :
        hr = _InsertAfterWord(ec, pic);
        break;

    case SELECTWORD_CORRECT :
        hr = _CorrectWord(ec, pic);
        break;

    case SELECTWORD_UNSELECT :
        hr = _Unselect(ec, pic);
        break;

    case SELECTWORD_SELECTPREV :
        hr = _SelectPreviousPhrase(ec, pic);
        break;

    case SELECTWORD_SELECTNEXT :
        hr = _SelectNextPhrase(ec, pic);
        break;

    case SELECTWORD_CORRECTPREV :
        hr = _CorrectPreviousPhrase(ec, pic);
        break;

    case SELECTWORD_CORRECTNEXT :
        hr = _CorrectNextPhrase(ec, pic);
        break;

    case SELECTWORD_SELTHROUGH :
        hr = _SelectThrough(ec, pic, pwszSelectedWord, ulLen, ulLenXXX);
        break;

    case SELECTWORD_DELTHROUGH :
        hr = _DeleteThrough(ec, pic, pwszSelectedWord, ulLen, ulLenXXX);
        break;

    case SELECTWORD_GOTOBOTTOM :
        hr = _GoToBottom(ec, pic);
        break;
    case SELECTWORD_GOTOTOP :
        hr = _GoToTop(ec, pic);
        break;

    case SELECTWORD_SELSENTENCE :
    case SELECTWORD_SELPARAGRAPH :
    case SELECTWORD_SELWORD :
        hr = _SelectSpecialText(ec, pic, sw_type);
        break;

    case SELECTWORD_SELTHAT :
        hr = _SelectThat(ec, pic);
        break;
  
    default :
        break;
    }

    // update the saved ip so that next time the hypothesis will 
    // start from this new selection.
    m_psi->SaveLastUsedIPRange( );
    m_psi->SaveIPRange(NULL);

    return hr;
}

//
// This function will shift the exact number of characters as required.
// it will shift over any regions.
//
// Now it supports only FORWARD shifting.
//
// For StartAnchor shift, it will shift required number of characters until it reaches to 
// a non-region character.
//
HRESULT CSelectWord::_ShiftComplete(TfEditCookie ec, ITfRange *pRange, LONG cchLenToShift, BOOL fStart)
{
    HRESULT hr = S_OK;
    long    cchTotal = 0;
    BOOL    fNoRegion;
    LONG    cch;

    Assert(pRange);                    
    do
    {
        // Assume there is no region.
        fNoRegion = TRUE;
        if ( fStart )
            hr = pRange->ShiftStart(ec, cchLenToShift - cchTotal, &cch, NULL);
        else
            hr = pRange->ShiftEnd(ec, cchLenToShift - cchTotal, &cch, NULL);
                
        cchTotal += cch;
        if ( (hr == S_OK) && (cchTotal < cchLenToShift))
        {
            // region?
            hr = pRange->ShiftStartRegion(ec, TF_SD_FORWARD, &fNoRegion);
        }
    }
    while (hr == S_OK && cchTotal < cchLenToShift && !fNoRegion);

    if (hr == S_OK && !fNoRegion && fStart)
    {
        // We want to shift all the possible regions until it reaches a non-region character
        do 
        {
            hr = pRange->ShiftStartRegion(ec, TF_SD_FORWARD, &fNoRegion);
        } while ( hr == S_OK && !fNoRegion );
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _FindSelect
//
//    Description:  search the active view text to find the 
//                  the first matched string after the current
//                  selection or IP.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_FindSelect(TfEditCookie ec, ITfContext *pic, BOOL  *fFound)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeSelected;
    ULONG               ulSelStartOff;
    ULONG               ulSelLen;

    TraceMsg(TF_GENERAL, "CSelectWord::_FindSelect is called");

    if ( !fFound ) return E_INVALIDARG;

    *fFound = FALSE;

    hr = _GetTextAndSelectInCurrentView(ec, pic, &ulSelStartOff, &ulSelLen);

    // Search the required string from the document text.

    if ( hr == S_OK )
        hr = m_cpActiveRange->Clone(&cpRangeSelected);

    if ( hr == S_OK && m_dstrActiveText)
    {
        ULONG   ulLen;
        
        ulLen = wcslen(m_dstrActiveText);

        if ( ulLen >= m_ulLenSelected )
        {
            BOOL   bFound = FALSE;
            ULONG  iStartOffset = 0;
            ULONG  iWordLen = m_ulLenSelected;
            CSearchString  *pSearchStr = new CSearchString( );
                
            if ( pSearchStr )
            {
                hr = pSearchStr->Initialize(m_pwszSelectedWord,
                                            (WCHAR *)m_dstrActiveText,
                                            m_psi->GetLangID( ),
                                            ulSelStartOff,
                                            ulSelLen);

                if ( hr == S_OK )
                {
                    bFound = pSearchStr->Search( &iStartOffset, &iWordLen );
                }

                delete pSearchStr;

                if ( bFound )
                {
                    hr = _ShiftComplete(ec, cpRangeSelected, (LONG)iStartOffset, TRUE);

                    if ( hr == S_OK )
                    {
                        hr = cpRangeSelected->Collapse(ec, TF_ANCHOR_START);
                    }

                    if ( hr == S_OK )
                         hr = _ShiftComplete(ec, cpRangeSelected, (LONG)iWordLen, FALSE);

                    if ( hr == S_OK )
                    {
                        m_cpSelectRange.Release( );
                        hr = cpRangeSelected->Clone(&m_cpSelectRange);
                    }

                    *fFound = bFound;
                }
            }
        }
    }

    return hr;

}
/*  --------------------------------------------------------
//    Function Name: _SelectWord
//
//    Description:  Handle Select <Phrase> command.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_SelectWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _DeleteWord
//
//    Description:  Handle Delete <Phrase> command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_DeleteWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_DeleteWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        if ( hr == S_OK )
        {
            // start a composition here if we haven't already
            m_psi->_CheckStartComposition(ec, m_cpSelectRange);
            // set the text
            hr = m_cpSelectRange->SetText(ec,0, NULL, 0);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _InsertAfterWord
//
//    Description:  Handle Delete <Phrase> command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_InsertAfterWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_InsertAfterWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr =  m_cpSelectRange->Collapse(ec, TF_ANCHOR_END);

        // If there is a space right after the selected word, we just need to move
        // the insertion point to a next non-space character.

        if ( hr == S_OK )
        {
            CComPtr<ITfRange>  cpRangeTmp;
            long               cch=0;
            WCHAR              wszTempText[2];

            hr = m_cpSelectRange->Clone(&cpRangeTmp);

            while ( hr == S_OK && cpRangeTmp ) 
            {
                hr = cpRangeTmp->ShiftEnd(ec, 1, &cch, NULL);

                if ( hr == S_OK && cch == 1 )
                {
                    hr = cpRangeTmp->GetText(ec, 0, wszTempText, 1, (ULONG *)&cch);

                    if ( hr == S_OK  && wszTempText[0] == L' ')
                    {
                        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_END);
                    }
                    else
                    {
                        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_START);
                        break;
                    }
                    
                }
                else
                    break;
            } 
            
            if ( hr == S_OK )
            {
                hr = SetSelectionSimple(ec, pic, cpRangeTmp);
            }
        }
    }

    return hr;
}


/*  --------------------------------------------------------
//    Function Name: _InsertBeforeWord
//
//    Description:  Handle "Insert Before <Phrase>" command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_InsertBeforeWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    TraceMsg(TF_GENERAL, "CSelectWord::_InsertBeforeWord is called");

    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        // Set the new selection.
        hr =  m_cpSelectRange->Collapse(ec, TF_ANCHOR_START);

        if ( hr == S_OK )
        {
           hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _Unselect
//
//    Description: Handle "Unselect that" command
//                 Unselect current selection.
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_Unselect(TfEditCookie ec,ITfContext *pic)
{
    HRESULT            hr;
    CComPtr<ITfRange>  cpInsertionPoint;

    hr = GetSelectionSimple(ec, pic, &cpInsertionPoint);

    if ( hr == S_OK && cpInsertionPoint)
    {
        // Set the new selection.
        hr =  cpInsertionPoint->Collapse(ec, TF_ANCHOR_END);

        if ( hr == S_OK )
        {
           hr = SetSelectionSimple(ec, pic, cpInsertionPoint);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _CorrectWord
//
//    Description:  Handle "Correct <Phrase>" command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectWord(TfEditCookie ec,ITfContext *pic)
{
    HRESULT   hr = S_OK;
    BOOL      fFound = FALSE;

    // Find the required phrase
    hr = _FindSelect(ec, pic, &fFound);

    if ( hr == S_OK  && fFound )
    {
        //
        // Try to open the correction window based on current found range.
        //
        // After the candidate UI window is closed, IP needs to be restored
        // to the original one.
        BOOL   fConvertable = FALSE;

        m_psi->_SetRestoreIPFlag(TRUE);
        hr = m_psi->_ReconvertOnRange(m_cpSelectRange, &fConvertable);

        if (hr == S_OK && !fConvertable )
        {
            // No alternate assoicated with this range, 
            // just simply select the text so that user can reconvert it in other ways.
            hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GetPrevOrNextPhrase
//
//    Description: Get the real range for "Previous Phrase" or
//                 "Next Phrase", based on current ip.
//                 It could be called by _SelectPreviousPhrase,
//                 _SelectNextPhrase, _CorrectPreviousPhrase,
//                 or _CorrectNextPhrase.
// ----------------------------------------------------------*/

HRESULT CSelectWord::_GetPrevOrNextPhrase(TfEditCookie ec, ITfContext *pic, BOOL  fPrev, ITfRange **ppRangeOut)
{
    HRESULT              hr = S_OK;
    CComPtr<ITfRange>    cpIP;
    CComPtr<ITfRange>    cpFoundRange;
    CComPtr<ITfRange>    cpRangeTmp;
    CComPtr<ITfProperty> cpProp = NULL;
    LONG                 l;
    BOOL                 fEmpty = TRUE;

    if ( !ppRangeOut ) 
        return E_INVALIDARG;

    *ppRangeOut = NULL;

    ASSERT(m_psi);
    cpIP = m_psi->GetSavedIP();

    if ( cpIP == NULL )
    {
        // Get the current IP.
        hr = GetSelectionSimple(ec, pic, &cpIP);
    }

    if ( hr == S_OK && cpIP )
    { 
        hr = cpIP->Clone(&cpRangeTmp);
    }

    if ( hr != S_OK || !cpIP )
        return hr;

    if ( fPrev )
    {
        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_START);

        if ( hr == S_OK )
        {
            // shift to the previous position
            hr = cpRangeTmp->ShiftStart(ec, -1, &l, NULL);
        }
    }
    else
    {
        hr = cpRangeTmp->Collapse(ec, TF_ANCHOR_END);
        if ( hr == S_OK )
        {
            hr = cpRangeTmp->ShiftEnd(ec, 1, &l, NULL);
        }

        if ( hr == S_OK )
        {
            // shift to the next position
            hr = cpRangeTmp->ShiftStart(ec, 1, &l, NULL);
        }
    }

    if ( hr == S_OK )
        hr = pic->GetProperty(GUID_PROP_SAPI_DISPATTR, &cpProp);

    if ( hr == S_OK && cpProp)
    {
        TfGuidAtom guidAttr = TF_INVALID_GUIDATOM;

        hr = cpProp->FindRange(ec, cpRangeTmp, &cpFoundRange, TF_ANCHOR_START);

        if (S_OK == hr && cpFoundRange)
        {
            hr = GetGUIDPropertyData(ec, cpProp, cpFoundRange, &guidAttr);
     
            if (hr == S_OK)
            {
                TfGuidAtom  guidSapiInput;

                GetGUIDATOMFromGUID(m_psi->_GetLibTLS( ), GUID_ATTR_SAPI_INPUT, &guidSapiInput);

                if ( guidSapiInput == guidAttr )
                {
                    // Found the dictated phrase.
                    // is it empty?

                    cpFoundRange->IsEmpty(ec, &fEmpty);
                }
            }
        }
        else
        {
            // With Office Auto-Correction, the static GUID_PROP_SAPI_DISPATTR property 
            // on the auto-corrected range could be destroyed.
            // In this case, we may want to rely on our custom property GUID_PROP_SAPIRESULTOBJECT
            // to find the real previous dictated phrase.

            cpProp.Release( );  // to avoid memory leak.

            if ( cpFoundRange )
                cpFoundRange.Release( );

            hr = pic->GetProperty(GUID_PROP_SAPIRESULTOBJECT, &cpProp);

            if ( hr == S_OK && cpProp)
                hr = cpProp->FindRange(ec, cpRangeTmp, &cpFoundRange, TF_ANCHOR_START);

            if (hr == S_OK && cpFoundRange)
                hr = cpFoundRange->IsEmpty(ec, &fEmpty);
        }
    }

    // Set new selection if the found range is not empty.
    if ( (hr == S_OK) && cpFoundRange  && !fEmpty )
    {
        cpFoundRange->Clone(ppRangeOut);
    }

    return hr;
}


HRESULT  CSelectWord::_SelectPrevOrNextPhrase(TfEditCookie ec, ITfContext *pic, BOOL  fPrev)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    hr = _GetPrevOrNextPhrase(ec, pic, fPrev, &cpRange);

    if ( hr == S_OK  && cpRange )
    {
        hr = SetSelectionSimple(ec, pic, cpRange);
    }
     
    return hr;

}
/*  --------------------------------------------------------
//    Function Name: _SelectPreviousPhrase
//
//    Description: Handle "Select Previous Phrase" command
//                 select previous phrase.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectPreviousPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _SelectPrevOrNextPhrase(ec, pic, TRUE);
}

/*  --------------------------------------------------------
//    Function Name: _SelectNextPhrase
//
//    Description: Handle "Select Next Phrase" command
//                 select next phrase.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectNextPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _SelectPrevOrNextPhrase(ec, pic, FALSE);
}


/*  --------------------------------------------------------
//    Function Name: _CorrectPrevOrNextPhrase
//
//    Description: Handle "Correct Previous/Next Phrase" command,
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectPrevOrNextPhrase(TfEditCookie ec,ITfContext *pic, BOOL fPrev)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    // Get the previous phrase range.
    hr = _GetPrevOrNextPhrase(ec, pic, fPrev, &cpRange);

    if ( hr == S_OK  && cpRange )
    {
        //
        // Try to open the correction window based on current found range.
        //
        // After the candidate UI window is closed, IP needs to be restored
        // to the original one.
        BOOL   fConvertable = FALSE;

        m_psi->_SetRestoreIPFlag(TRUE);
        hr = m_psi->_ReconvertOnRange(cpRange, &fConvertable);

        if (hr == S_OK && !fConvertable )
        {
            // No alternate assoicated with this range, 
            // just simply select the text so that user can reconvert it in other ways.
            hr = SetSelectionSimple(ec, pic, m_cpSelectRange);
        }

    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _CorrectPreviousPhrase
//
//    Description: Handle "Correct Previous Phrase" command
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectPreviousPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _CorrectPrevOrNextPhrase(ec, pic, TRUE);
}

/*  --------------------------------------------------------
//    Function Name: _CorrectNextPhrase
//
//    Description: Handle "Correct Next Phrase" command
//                 correct next phrase.
//
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_CorrectNextPhrase(TfEditCookie ec,ITfContext *pic)
{
    return _CorrectPrevOrNextPhrase(ec, pic, FALSE);
}


/*  --------------------------------------------------------
//    Function Name: _GetThroughRange
//
//    Description: Get the range for commands "command XXX through YYY"
//                 
//    pwszText: contains text "XXX + YYY"
//    ulLen   : length of pwszText
//    ulLenXXX: length of "XXX"
//
// ----------------------------------------------------------*/

HRESULT  CSelectWord::_GetThroughRange(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX, ITfRange **ppRange)
{
    HRESULT             hr = S_OK;
    WCHAR               *pwszXXX = NULL, *pwszYYY = NULL;

    TraceMsg(TF_GENERAL, "CSelectWord::_GetThroughRange is called");

    Assert(ulLen);
    Assert(ulLenXXX);
    Assert(pwszText);
        
    if ( !ppRange || ulLen < ulLenXXX ) return E_INVALIDARG;

    *ppRange = NULL;

    pwszXXX = (WCHAR *)cicMemAlloc( (ulLenXXX+1) * sizeof(WCHAR) );
    if ( pwszXXX )
    {
        wcsncpy(pwszXXX, pwszText, ulLenXXX);
        pwszXXX[ulLenXXX] = L'\0';

        pwszYYY = (WCHAR *)cicMemAlloc( (ulLen - ulLenXXX + 1) * sizeof(WCHAR));

        if ( pwszYYY )
        {
            wcsncpy(pwszYYY, pwszText+ulLenXXX, ulLen-ulLenXXX);
            pwszYYY[ulLen-ulLenXXX] = L'\0';

            BOOL                fFoundXXX = FALSE;
            BOOL                fFoundYYY = FALSE;
            CComPtr<ITfRange>   cpRangeXXX;

            // Found XXX.
            m_pwszSelectedWord = pwszXXX;
            m_ulLenSelected = ulLenXXX;
            hr = _FindSelect(ec, pic, &fFoundXXX);

            if ( hr == S_OK && fFoundXXX && m_cpSelectRange)
            {
                m_cpSelectRange->Clone(&cpRangeXXX);
                // Found YYY
                SetSelectionSimple(ec, pic, m_cpSelectRange);
                m_pwszSelectedWord = pwszYYY;
                m_ulLenSelected = ulLen - ulLenXXX;
                hr = _FindSelect(ec, pic, &fFoundYYY); 
            }

            if ( hr == S_OK  && fFoundYYY )
            {
                long l;
                CComPtr<ITfRange>  cpSelRange;

                // m_cpSelectRange now points to the YYY range.
                hr = cpRangeXXX->CompareStart(ec, m_cpSelectRange,  TF_ANCHOR_START, &l);

                if ( hr == S_OK )
                {
                    if ( l < 0 )
                    {
                        // XXX is prior to YYY, normal case
                        cpSelRange = cpRangeXXX;
                        hr = cpSelRange->ShiftEndToRange(ec, m_cpSelectRange, TF_ANCHOR_END);
                    }
                    else if ( l > 0 )
                    {
                        // XXX is after YYY.
                        //
                        // such as document has text like:  ... YYY ...... XXX...
                        // and you say "Select XXX through YYY
                        //
                        cpSelRange = m_cpSelectRange;
                        hr = cpSelRange->ShiftEndToRange(ec, cpRangeXXX, TF_ANCHOR_END);
                    }
                    else
                    {
                        // Select XXX through XXX.  here YYY is XXX.
                        cpSelRange = m_cpSelectRange;
                    }
                }

                // Set the new selection.

                if ( hr == S_OK )
                {
                    cpSelRange->Clone(ppRange);
                }
            }

            cicMemFree(pwszYYY);
        }

        cicMemFree(pwszXXX);
    }

    return hr;

}

/*  --------------------------------------------------------
//    Function Name: _SelectThrough
//
//    Description: Handle command "Select XXX through YYY"
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    TraceMsg(TF_GENERAL, "CSelectWord::_SelectThrough is called");
  
    if ( ulLen < ulLenXXX ) return E_INVALIDARG;

    hr = _GetThroughRange(ec, pic, pwszText, ulLen, ulLenXXX, &cpRange);

    if ( hr == S_OK && cpRange )
        hr = SetSelectionSimple(ec, pic, cpRange);

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _DeleteThrough
//
//    Description: Handle command "Delete XXX through YYY"
//                 
// ----------------------------------------------------------*/

HRESULT  CSelectWord::_DeleteThrough(TfEditCookie ec, ITfContext *pic, WCHAR *pwszText, ULONG ulLen, ULONG ulLenXXX)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRange;

    TraceMsg(TF_GENERAL, "CSelectWord::_DeleteThrough is called");
  
    if ( ulLen < ulLenXXX ) return E_INVALIDARG;

    hr = _GetThroughRange(ec, pic, pwszText, ulLen, ulLenXXX, &cpRange);

    if ( hr == S_OK && cpRange )
    {
        BOOL fEmpty = TRUE;
        
        cpRange->IsEmpty(ec, &fEmpty);
        
        if ( !fEmpty )
        {
            // Set the new selection.
            hr = SetSelectionSimple(ec, pic, cpRange);
            if ( hr == S_OK )
            {
                // start a composition here if we haven't already
                m_psi->_CheckStartComposition(ec, cpRange);
                // set the text
                hr = cpRange->SetText(ec,0, NULL, 0);
            }       
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GoToBottom
//
//    Description: Handle command "Go to Bottom"
//                 move the IP to the end anchor of the 
//                 current active view range.
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GoToBottom(TfEditCookie ec,ITfContext *pic)
{
    HRESULT hr = S_OK;

    CComPtr<ITfRange>   cpRangeView;

    // Get the Active View Range
    hr = _GetActiveViewRange(ec, pic, &cpRangeView);

    // Collapse to the end anchor of the active view
    if ( hr == S_OK )
        hr = cpRangeView->Collapse(ec, TF_ANCHOR_END);

    // Set selection to the end of active view.
    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeView);
 
    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _GoToTop
//
//    Description: Handle command "Go To Top"
//                 Move the IP to the start anchor of the
//                 current active view range.
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_GoToTop(TfEditCookie ec,ITfContext *pic)
{
    HRESULT hr = S_OK;

    CComPtr<ITfRange>   cpRangeView;

    // Get the Active View Range
    hr = _GetActiveViewRange(ec, pic, &cpRangeView);

    // Collapse to the start anchor of the active view
    if ( hr == S_OK )
        hr = cpRangeView->Collapse(ec, TF_ANCHOR_START);

    // Set selection to the start of active view.
    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeView);
 
    return hr;
}

#define MAX_PARA_SIZE       512
#define VK_NEWLINE          0x0A
#define MAX_WORD_SIZE       30
#define MAX_SENTENCE_SIZE   256

/*  --------------------------------------------------------
//    Function Name: _SelectSpecialText
//
//    Description: This is a common function for 
//                 "Select Sentence"
//                 "Select Paragraph"
//                 "Select Word"
//                 
//    sw_type indicates which command would be handled
//                 
// ----------------------------------------------------------*/
HRESULT  CSelectWord::_SelectSpecialText(TfEditCookie ec,ITfContext *pic, SELECTWORD_OPERATION sw_Type)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeSelect;
    CComPtr<ITfRange>   cpRangeRightClone;
    LONG                cch = 0;
    ULONG               cchText = 0;
    int                 i = 0;
    int                 cchLeftEnd = 0;
    ULONG               ulBufSize = 0;
    WCHAR               *pwszTextBuf;

    if ( sw_Type != SELECTWORD_SELSENTENCE    && 
         sw_Type != SELECTWORD_SELPARAGRAPH   && 
         sw_Type != SELECTWORD_SELWORD )
    {
        return E_INVALIDARG;
    }

    // 
    // "Select Word" only works for English Now.
    //
    if ( sw_Type == SELECTWORD_SELWORD && m_psi->GetLangID( ) != 0x0409 )
        return E_NOTIMPL;

    switch (sw_Type)
    {
    case SELECTWORD_SELSENTENCE :
        ulBufSize = MAX_SENTENCE_SIZE;
        break;

    case SELECTWORD_SELPARAGRAPH :
        ulBufSize = MAX_PARA_SIZE;
        break;

    case SELECTWORD_SELWORD :
        ulBufSize = MAX_WORD_SIZE;
        break;
    }

    pwszTextBuf = (WCHAR *)cicMemAlloc( (ulBufSize+1) * sizeof(WCHAR) );

    if ( !pwszTextBuf )
        return E_OUTOFMEMORY;

    hr = GetSelectionSimple(ec, pic, &cpRangeSelect);

    if ( hr == S_OK )
        hr = cpRangeSelect->Collapse(ec, TF_ANCHOR_START);

    //
    // Find the start anchor of the special pattern text.
    //
    
    if ( hr == S_OK )
        hr = cpRangeSelect->ShiftStart(ec, (-1 * ulBufSize), &cch, NULL);

    if  ( hr == S_OK && cch != 0)
    {
        hr = cpRangeSelect->GetText(ec, 0,pwszTextBuf, (-1 * cch), &cchText);
     
        // Find the nearest delimiter left to the IP
        if ( hr == S_OK )
        {
            Assert(cchText == (-1 *cch) );
    
            for(i = ((LONG)cchText-1); i>=0; i--)
            {
                BOOL fDelimiter = FALSE;

                switch (sw_Type)
                {
                case SELECTWORD_SELSENTENCE :
                    fDelimiter = _IsSentenceDelimiter(pwszTextBuf[i]);
                    break;

                case SELECTWORD_SELPARAGRAPH :
                    fDelimiter = _IsParagraphDelimiter(pwszTextBuf[i]);
                    break;

                case SELECTWORD_SELWORD :
                    fDelimiter = _IsWordDelimiter(pwszTextBuf[i]);
                    break;

                }
    
                if(fDelimiter)    
                {
                    break;
                }
            }
    
            i++; // positioning the first character in the searched range.
    
            hr = cpRangeSelect->ShiftStart(ec, i, &cch, NULL);

            cchLeftEnd = (LONG)cchText - i;// total characters to the beginning of range
        }
    }

    //
    // Find the End Anchor of the special text range
    //
    
    if ( hr == S_OK )
        hr = cpRangeSelect->Clone(&cpRangeRightClone);

    if ( hr == S_OK )
        hr = cpRangeRightClone->Collapse(ec, TF_ANCHOR_END);

    // make sure this right band range not skip over to the next region.
    cchText = cch = 0;

    if ( hr == S_OK )
        hr = cpRangeRightClone->ShiftEnd(ec, ulBufSize, &cch, NULL);

    if ( hr == S_OK && cch != 0 )
        hr = cpRangeRightClone->GetText(ec, TF_TF_MOVESTART, pwszTextBuf, ulBufSize, &cchText); 

    if ( hr == S_OK )
    {
        for(i = 0; i< (LONG)cchText; i++)
        {
            BOOL fDelimiter = FALSE;

            switch (sw_Type)
            {
            case SELECTWORD_SELSENTENCE :
                fDelimiter = _IsSentenceDelimiter(pwszTextBuf[i]);
                break;

            case SELECTWORD_SELPARAGRAPH :
                fDelimiter = _IsParagraphDelimiter(pwszTextBuf[i]);
                break;

            case SELECTWORD_SELWORD :
                fDelimiter = _IsWordDelimiter(pwszTextBuf[i]);
                break;

            }
    
            if(fDelimiter)    
            {
                break;
            }        
        }

        if ( (int)cchText > i )
        {
            if ( sw_Type == SELECTWORD_SELSENTENCE )
            {
                // For select sentence, the right sentence delimiter such as ".', '?', '!' is also 
                // selected.  to be compatible with Office behavior.
                if ( (int)cchText > (i+1) )
                    hr = cpRangeRightClone->ShiftStart(ec, -((LONG)cchText - i - 1), &cch, NULL);
            }
            else
                hr = cpRangeRightClone->ShiftStart(ec, -((LONG)cchText - i), &cch, NULL);
        }
    }

    if ( hr == S_OK )
        hr = cpRangeSelect->ShiftEndToRange(ec, cpRangeRightClone, TF_ANCHOR_START);

    // Set selection 

    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeSelect);

    cicMemFree(pwszTextBuf);

    return hr;
}

//
// Check if the current char is a delimiter of Sentence
//
BOOL  CSelectWord::_IsSentenceDelimiter(WCHAR  wch)
{
    BOOL  fDelimiter = FALSE;

    BOOL  fIsQuest = ( (wch == '?') || 
                       (wch == 0xFF1F) );               // Full width Question Mark

    BOOL  fIsPeriod = ((wch == '.')    || 
                       (wch == 0x00B7) ||               // Middle Dot
                       (wch == 0x3002) ||               // Ideographic period
                       (wch == 0xFF0E) ||               // Full width period
                       (wch == 0x2026) );               // Horizontal Ellipsis

    BOOL  fIsExclamMark = ( (wch == '!')   ||
                            (wch == 0xFF01) );          // Full width Exclamation Mark

    BOOL  fIsReturn = ( (wch == VK_RETURN)  ||  (wch == VK_NEWLINE) );

    fDelimiter = (fIsQuest || fIsPeriod || fIsExclamMark || fIsReturn);

    return fDelimiter;
}

//
// Check if the current char is a delimiter of Paragraph
//
BOOL  CSelectWord::_IsParagraphDelimiter(WCHAR wch)
{
    BOOL  fDelimiter = FALSE;

    if( (wch == VK_RETURN) || (wch == VK_NEWLINE) ) 
        fDelimiter = TRUE;

    return fDelimiter;
}

// 
// Check if the current char is a word delimiter
//
BOOL  CSelectWord::_IsWordDelimiter(WCHAR wch)
{
    return (iswalpha(wch) == FALSE);
}

//
// Handle "Select That" command
//
HRESULT  CSelectWord::_SelectThat(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpRangeThat;

    hr = m_psi->_GetCmdThatRange(ec, pic, &cpRangeThat);

    if ( hr == S_OK )
        hr = SetSelectionSimple(ec, pic, cpRangeThat);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\spbtnctrl.cpp ===
// SpBtnCtrl.cpp : Implement SpButtonControl which is to control the speech mode and status.
//
#include "private.h"
#include "SpBtnCtrl.h"

/////////////////////////////////////////////////////////////////////////////
//
HRESULT SpButtonControl::SetDictationButton(BOOL fButtonDown, UINT uTimePressed)
{
    return _SetButtonDown(DICTATION_BUTTON, fButtonDown, uTimePressed);
}

HRESULT SpButtonControl::SetCommandingButton(BOOL fButtonDown, UINT uTimePressed)
{
    return _SetButtonDown(COMMANDING_BUTTON, fButtonDown, uTimePressed);
}

HRESULT SpButtonControl::_SetButtonDown(DWORD dwButton, BOOL fButtonDown, UINT uTimePressed)
{
    BOOL fDictationOn = FALSE;
    BOOL fCommandingOn = FALSE;
    BOOL fMicrophoneOn = FALSE;

    DWORD dwMyState		= dwButton ? TF_COMMANDING_ON : TF_DICTATION_ON;
    DWORD dwOtherState	= dwButton ? TF_DICTATION_ON : TF_COMMANDING_ON;

    if (uTimePressed == 0)
        uTimePressed = GetTickCount();

    if (m_ulButtonDownTime[1 - dwButton])
    {
        // Other button pressed but not released.
        // In this scenario we ignore the second press since there is no perfect answer to what we could do instead.
        return S_OK;
    }

    fMicrophoneOn = GetMicrophoneOn( );
    fDictationOn  = GetDictationOn( );
    fCommandingOn = GetCommandingOn( );

    BOOL fMyStateOn     = dwButton ? fCommandingOn : fDictationOn;
    BOOL fOtherStateOn  = dwButton ? fDictationOn : fCommandingOn;

    TraceMsg(TF_SPBUTTON, "uTimePressed=%d MicrophoneOnOff=%d", uTimePressed, fMicrophoneOn);
    TraceMsg(TF_SPBUTTON, "fDictationOn=%d,fCommandingOn=%d", fDictationOn,fCommandingOn);
    TraceMsg(TF_SPBUTTON, "fMyStateOn=%d, OtherStateOn=%d", fMyStateOn, fOtherStateOn);

    if (fButtonDown)
    {
        // Button has been pressed.
        if ( m_ulButtonDownTime[dwButton] )
        {
            TraceMsg(TF_SPBUTTON, "Double down event on speech button");
            return S_OK;
        }

        // Now we store the time to detect a press-and-hold.
        m_ulButtonDownTime[dwButton] = uTimePressed;

        if (fMicrophoneOn)
        {
            // Microphone is ON
            if (fCommandingOn && fDictationOn)
            {
                // Both dictation and commanding are on.
                // Switch microphone off, disable other state.
                m_fMicrophoneOnAtDown[dwButton] = TRUE;
                SetState(dwMyState);
            }
            if (fOtherStateOn)
            {
                // Leave microphone on, switch state.
                // Need to store other state to reset if it's a press-and-hold.
                m_fPreviouslyOtherStateOn[dwButton] = TRUE;
                SetState(dwMyState);
            }
            else if (fMyStateOn)
            {
                // Switch microphone off.
                m_fMicrophoneOnAtDown[dwButton] = TRUE;
            }
            else
            {
                // Microphone on but no state defined.
                // Switch microphone off, enable dictation.
                m_fMicrophoneOnAtDown[dwButton] = TRUE;
                SetState(dwMyState);
            }
        }
        else
        {
            // Microphone is OFF
            if (fCommandingOn && fDictationOn)
            {
                // Both dictation and commanding are on.
                // Switch microphone on, disable my state.
                SetState(dwMyState);
                SetMicrophoneOn(TRUE);
            }
            if (fOtherStateOn)
            {
                // Switch microphone on, switch state.
                SetState(dwMyState);
                SetMicrophoneOn(TRUE);
            }
            else if (fMyStateOn)
            {
                // Switch microphone on.
                SetMicrophoneOn(TRUE);
            }
            else
            {
                // Microphone off and no state defined.
                // Switch microphone on, enable my state.
                SetState(dwMyState);
                SetMicrophoneOn(TRUE);
            }
        }
    }
    else
    {
        // Button released.
#ifdef DEBUG
        if ( m_ulButtonDownTime[dwButton] == 0 )
		    TraceMsg(TF_SPBUTTON, "Speech button released without being pressed.");

		// Since the button has previously been pressed, the other state should not be enabled.
        if ( fOtherStateOn )
		    TraceMsg(TF_SPBUTTON, "Other speech state incorrectly enabled on button release.");
#endif

        // Will wrap after 49.7 days of continuous use.
        DWORD dwTimeElapsed = uTimePressed - m_ulButtonDownTime[dwButton];
        m_ulButtonDownTime[dwButton] = 0;

        // Is this a quick press or a press-and-hold action?
        if (dwTimeElapsed < PRESS_AND_HOLD)
        {
            // This is a quick release.
            if (m_fMicrophoneOnAtDown[dwButton])
            {
                // Microphone was on at button down. Need to switch microphone off.
                SetMicrophoneOn(FALSE);
            }

            m_fPreviouslyOtherStateOn[dwButton] = FALSE;
            m_fMicrophoneOnAtDown[dwButton] = FALSE;
        }
        else
        {
            // This is a press-and-hold.
            // We must either stop the microphone or return to other state.

            TraceMsg(TF_SPBUTTON, "press-and-hold button!");

            if (m_fPreviouslyOtherStateOn[dwButton])
            {
                // Other state was previously on. Leave microphone on, switch state.
                TraceMsg(TF_SPBUTTON, "Other state was previously on, leave Microphone On, switch state");

                SetState(dwOtherState);
                m_fPreviouslyOtherStateOn[dwButton] = FALSE;
            }
            else
            {
                // Other state was not previously on. Switch microphone off.
                TraceMsg(TF_SPBUTTON, "Other state was not previous on, switch microphone off");

                SetMicrophoneOn(FALSE);
                m_fMicrophoneOnAtDown[dwButton] = FALSE;
            }
        }
    }

    return S_OK;
}

BOOL SpButtonControl::GetDictationOn( )
{
    DWORD   dwGLobal;
    GetCompartmentDWORD(m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGLobal, TRUE);

    return (dwGLobal & TF_DICTATION_ON ) ? TRUE : FALSE;
}

BOOL SpButtonControl::GetCommandingOn( )
{
    DWORD   dwGLobal;
    GetCompartmentDWORD(m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, &dwGLobal, TRUE);

    return (dwGLobal & TF_COMMANDING_ON ) ? TRUE : FALSE;
}

HRESULT SpButtonControl::SetCommandingOn(void)
{
    HRESULT  hr;

    DWORD dw = TF_COMMANDING_ON;
    hr = SetCompartmentDWORD(m_pimx->_GetId( ), m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, dw, TRUE);
    return hr;
}

HRESULT SpButtonControl::SetDictationOn(void)
{
    HRESULT  hr;

    DWORD dw = TF_DICTATION_ON;
    hr = SetCompartmentDWORD(m_pimx->_GetId( ), m_pimx->_tim, GUID_COMPARTMENT_SPEECH_GLOBALSTATE, dw, TRUE);
    return hr;
}

HRESULT SpButtonControl::SetState(DWORD dwState)
{
    HRESULT hr = S_OK;
	
    if (dwState == TF_DICTATION_ON)
    {
        hr = SetDictationOn();
    }
    else if (dwState == TF_COMMANDING_ON)
    {
        hr = SetCommandingOn();
    }
    else
    {
        TraceMsg(TF_SPBUTTON, "Unknown speech state requested.");
        Assert(0);
        hr = E_INVALIDARG;
    }

    return hr;
}

BOOL SpButtonControl::GetMicrophoneOn( )
{
    Assert(m_pimx);
    return m_pimx->GetOnOff( );
}

void SpButtonControl::SetMicrophoneOn(BOOL fOn)
{
    Assert(m_pimx);
    m_pimx->SetOnOff(fOn, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\spbtnctrl.h ===
//
// SpBtnCtrl.h
//

#ifndef SPBTNCTRL_H
#define SPBTNCTRL_H

#include "private.h"
#include "globals.h"
#include "sapilayr.h"

#define PRESS_AND_HOLD      600
#define DICTATION_BUTTON    0
#define COMMANDING_BUTTON   1

// class CSapiIMX;

/////////////////////////////////////////////////////////////////////////////
// SpButtonControl

class SpButtonControl 
{
public:
	SpButtonControl(CSapiIMX *pImx) 
	{
        m_pimx = pImx;
		m_fPreviouslyOtherStateOn[0] = FALSE;
		m_fPreviouslyOtherStateOn[1] = FALSE;
		m_fMicrophoneOnAtDown[0] = FALSE;
		m_fMicrophoneOnAtDown[1] = FALSE;
		m_ulButtonDownTime[0] = 0;
		m_ulButtonDownTime[1] = 0;
	}

    ~SpButtonControl() 
    {
    }

public:
	HRESULT SetCommandingButton(BOOL fButtonDown, UINT uTimePressed);
	HRESULT SetDictationButton(BOOL fButtonDown, UINT uTimePressed);

private:
	HRESULT _SetButtonDown(DWORD dwButton, BOOL fButtonDown, UINT uTimePressed);
	BOOL    GetCommandingOn( );
	BOOL    GetDictationOn( );
	HRESULT SetCommandingOn(void);
	HRESULT SetDictationOn(void);
	HRESULT SetState(DWORD dwState);
	BOOL    GetMicrophoneOn( );
	void    SetMicrophoneOn(BOOL fOn);

    CSapiIMX                   *m_pimx;

	BOOL m_fPreviouslyOtherStateOn[2];
	BOOL m_fMicrophoneOnAtDown[2];
	ULONG m_ulButtonDownTime[2];
};

#endif // SPBTNCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\sptiphlp.h ===
//
//  Header Files for speech tip context help ids.
//

#ifndef SPTIPHLP_H
#define SPTIPHLP_H

// Id starts from 4000

// Speech tip property page

#define IDH_PP_ASSIGN_BUTTON                              4000
#define IDH_PP_BUTTON_MB_SETTING                          4001
#define IDH_PP_SHOW_BALLOON                               4002
#define IDH_PP_LMA                                        4003
#define IDH_PP_HIGH_CONFIDENCE                            4004
#define IDH_PP_SAVE_SPDATA                                4005
#define IDH_PP_REMOVE_SPACE                               4006
#define IDH_PP_DIS_DICT_TYPING                            4007
#define IDH_PP_PLAYBACK                                   4008
#define IDH_PP_DICT_CANDUI_OPEN                           4009
#define IDH_PP_BUTTON_ADVANCE                             4010
#define IDH_PP_BUTTON_SPCPL                               4011
#define IDH_PP_BUTTON_LANGBAR                             4012


// Voice command settings Dialog 
#define IDH_PP_SELECTION_CMD                              4020
#define IDH_PP_NAVIGATION_CMD                             4021
#define IDH_PP_CASING_CMD                                 4022
#define IDH_PP_EDITING_CMD                                4023
#define IDH_PP_KEYBOARD_CMD                               4024
#define IDH_PP_TTS_CMD                                    4025
#define IDH_PP_LANGBAR_CMD                                4026
#define IDH_PP_DICTCMDS                                   4027

// Mode button configuration
#define IDH_PP_DICTATION_CMB                              4030
#define IDH_PP_COMMAND_CMB                                4031

#endif // SPTIPHLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\case.h ===
//
// case.h
//
// CCaseTextService declaration.
//

#ifndef CASE_H
#define CASE_H

class CLangBarItemButton;
class CSnoopWnd;

class CCaseTextService : public ITfTextInputProcessor,
                         public ITfThreadMgrEventSink,
                         public ITfTextEditSink,
                         public ITfThreadFocusSink,
                         public ITfKeyEventSink
{
public:
    CCaseTextService();
    ~CCaseTextService();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfTextInputProcessor
    STDMETHODIMP Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId);
    STDMETHODIMP Deactivate();

    // ITfThreadMgrEventSink
    STDMETHODIMP OnInitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus);
    STDMETHODIMP OnPushContext(ITfContext *pContext);
    STDMETHODIMP OnPopContext(ITfContext *pContext);

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfKeyEventSink
    STDMETHODIMP OnSetFocus(BOOL fForeground);
    STDMETHODIMP OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten);

    // CClassFactory factory callback
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    // server registration
    static BOOL RegisterProfiles();
    static void UnregisterProfiles();
    static BOOL RegisterCategories(BOOL fRegister);
    static BOOL RegisterServer();
    static void UnregisterServer();

    // language bar menu handlers
    static void _Menu_HelloWord(CCaseTextService *_this);
    static void _Menu_FlipSel(CCaseTextService *_this);
    static void _Menu_FlipDoc(CCaseTextService *_this);
    static void _Menu_ShowSnoopWnd(CCaseTextService *_this);
    static void _Menu_FlipKeys(CCaseTextService *_this);

    ITfThreadMgr *_GetThreadMgr() { return _pThreadMgr; }
    TfClientId _GetClientId() { return _tfClientId; }
    BOOL _IsSnoopWndVisible() { return _fShowSnoop; }
    BOOL _IsKeyFlipping() { return _fFlipKeys; }

private:
    // init methods
    BOOL _InitLanguageBar();
    BOOL _InitThreadMgrSink();
    BOOL _InitSnoopWnd();
    BOOL _InitTextEditSink(ITfDocumentMgr *pDocMgr);
    BOOL _InitKeystrokeSink();
    BOOL _InitPreservedKey();

    // uninit methods
    void _UninitLanguageBar();
    void _UninitThreadMgrSink();
    void _UninitSnoopWnd();
    void _UninitKeystrokeSink();
    void _UninitPreservedKey();

    //
    // state
    //

    ITfThreadMgr *_pThreadMgr;
    TfClientId _tfClientId;

    BOOL _fShowSnoop; // hide/show the snoop window popup
    CSnoopWnd *_pSnoopWnd;

    BOOL _fFlipKeys;

    CLangBarItemButton *_pLangBarItem;

    DWORD _dwThreadMgrEventSinkCookie;
    DWORD _dwThreadFocusSinkCookie;
    DWORD _dwTextEditSinkCookie;
    ITfContext *_pTextEditSinkContext;

    LONG _cRef;     // COM ref count
};


#endif // CASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\sptask.cpp ===
//
// sptask.cpp
// 
// implements a notification callback ISpTask
//
// created: 4/30/99
//
//

#include "private.h"
#include "globals.h"
#include "sapilayr.h"
#include "propstor.h"
#include "dictctxt.h"
#include "nui.h"
#include "mui.h"
#include "shlguid.h"
#include "spgrmr.h"


//
//
// CSpTask class impl
//
//
STDMETHODIMP CSpTask::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) 
  /*  ||  IsEqualIID(riid, IID_ISpNotifyCallback) */
    )
    {
        *ppvObj = SAFECAST(this, CSpTask *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSpTask::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSpTask::Release(void)
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
// ctor
//
//
CSpTask::CSpTask(CSapiIMX *pime)
{
    //  CSpTask is initialized with an TFX instance
    //  so store the pointer to the TFX   

    TraceMsg(TF_SAPI_PERF, "CSpTask is generated");

    m_pime = pime;
    
    // addref so it doesn't go away during session
    m_pime->AddRef();
    
    // init data members here
    m_cpResMgr = NULL;
    m_cpRecoCtxt = NULL;
    m_cpRecoCtxtForCmd = NULL;
    m_cpRecoEngine = NULL;
    m_cpVoice = NULL;
    m_bInSound = NULL;
    m_bGotReco = NULL; 

    m_fSapiInitialized  = FALSE;
    m_fDictationReady   = FALSE;
    
    m_fInputState = FALSE;
    m_pLangBarSink   = NULL;

    // M2 SAPI workaround
    m_fIn_Activate = FALSE;
    m_fIn_SetModeBias = FALSE;
    m_fIn_GetAlternates = FALSE;
    m_fIn_SetInputOnOffState = FALSE;

    m_fSelectStatus = FALSE;  // By default, current selection is empty.
    m_fDictationDeactivated =  FALSE;
    m_fSpellingModeEnabled  =  FALSE;
    m_fCallbackInitialized = FALSE;

    m_fSelectionEnabled = FALSE;
    m_fDictationInitialized = FALSE;

    m_fDictCtxtEnabled = FALSE;
    m_fCmdCtxtEnabled = FALSE;

    m_fTestedForOldMicrosoftEngine = FALSE;
    m_fOldMicrosoftEngine = FALSE;

#ifdef RECOSLEEP
    m_pSleepClass = NULL;
#endif

    m_cRef = 1;
}

CSpTask::~CSpTask()
{
    TraceMsg(TF_SAPI_PERF, "CSpTask is destroyed");
    
    if (m_pdc)
        delete m_pdc;

    if (m_pITNFunc)
        delete m_pITNFunc;

    m_pime->Release();
}
//
// CSpTask::_InitializeSAPIObjects
//
// initialize SAPI objects for SR
// later we'll get other objects initialized here
// (TTS, audio etc)
//
HRESULT CSpTask::InitializeSAPIObjects(LANGID langid)
{

    TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeSAPIObjects is called");

    if (m_fSapiInitialized == TRUE)
    {
        TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeSAPIObjects is intialized already\n");
        return S_OK;
    }


    // m_xxx are CComPtrs from ATL
    //
    HRESULT hr = m_cpResMgr.CoCreateInstance( CLSID_SpResourceManager );

    TraceMsg(TF_SAPI_PERF, "CLSID_SpResourceManager is created, hr=%x", hr);


    if (!m_pime->IsSharedReco())
    {
        // create a recognition engine

        TraceMsg(TF_SAPI_PERF,"Inproc engine is generated");
        if( SUCCEEDED( hr ) )
        {
    
            hr = m_cpRecoEngine.CoCreateInstance( CLSID_SpInprocRecognizer );
        }
    
        if (SUCCEEDED(hr))
        {
            CComPtr<ISpObjectToken> cpAudioToken;
            SpGetDefaultTokenFromCategoryId(SPCAT_AUDIOIN, &cpAudioToken);
            if (SUCCEEDED(hr))
            {
                m_cpRecoEngine->SetInput(cpAudioToken, TRUE);
            }
        }
    }
    else
    {
        hr = m_cpRecoEngine.CoCreateInstance( CLSID_SpSharedRecognizer );
        TraceMsg(TF_SAPI_PERF, "Shared Engine is generated! hr=%x", hr);
    }

    // create the recognition context
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpRecoEngine->CreateRecoContext( &m_cpRecoCtxt );

        TraceMsg(TF_SAPI_PERF, "RecoContext is generated, hr=%x", hr);
    }
    
    GUID guidFormatId = GUID_NULL;
    WAVEFORMATEX *pWaveFormatEx = NULL;
    if (SUCCEEDED(hr))
    {
        hr = SpConvertStreamFormatEnum(SPSF_8kHz8BitMono, &guidFormatId, &pWaveFormatEx);

        TraceMsg(TF_SAPI_PERF, "SpConvertStreamFormatEnum is done, hr=%x", hr);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoCtxt->SetAudioOptions(SPAO_RETAIN_AUDIO, &guidFormatId, pWaveFormatEx);

        TraceMsg(TF_SAPI_PERF, "RecoContext SetAudioOptions, RETAIN AUDIO, hr=%x", hr);

        if (pWaveFormatEx)
            ::CoTaskMemFree(pWaveFormatEx);
    }

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpVoice.CoCreateInstance( CLSID_SpVoice );

        TraceMsg(TF_SAPI_PERF, "SpVoice is generated, hr=%x", hr);
    }

    if ( SUCCEEDED(hr) )
    {
        // this has to be extended so that
        // we choose default voice as far as lang matches
        // and pick the best match if not
        // 
        // hr = _SetVoice(langid);
    }

    //
    if ( SUCCEEDED(hr) )
    {
        m_langid = _GetPreferredEngineLanguage(langid);

        TraceMsg(TF_SAPI_PERF, "_GetPreferredEngineLanguage is Done, m_langid=%x", m_langid);
    }

#ifdef RECOSLEEP
    InitSleepClass( );
#endif
    
    if (SUCCEEDED(hr))
        m_fSapiInitialized = TRUE;

    TraceMsg(TF_SAPI_PERF, "InitializeSAPIObjects  is Done!!!!!, hr=%x\n", hr);

    return hr;
}


//
// CSpTask::_InitializeSAPIForCmd
//
// initialize SAPI RecoContext for Voice Command mode
//
// this function should be called after _InitializeSAPIObject.
//
HRESULT CSpTask::InitializeSAPIForCmd( )
{

    TraceMsg(TF_SAPI_PERF, "InitializeSAPIForCmd is called");
    HRESULT hr = S_OK;

    if (!m_cpRecoCtxtForCmd && m_cpRecoEngine && m_langid)
    {
        hr = m_cpRecoEngine->CreateRecoContext( &m_cpRecoCtxtForCmd );
        TraceMsg(TF_SAPI_PERF, "m_cpRecoCtxtForCmd is generated, hr=%x", hr);
    
        // Set the RecoContextState as DISABLE by default to improve SAPI Perf.
        //
        // After initializing, caller must set the context state explicitly.

        if ( SUCCEEDED(hr) )
        {
            hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_DISABLED);
            m_fCmdCtxtEnabled = FALSE;
        }

        TraceMsg(TF_SAPI_PERF, "Initialize Callback for RecoCtxtForCmd");

        // set recognition notification
        CComPtr<ISpNotifyTranslator> cpNotify;

        if ( SUCCEEDED(hr) )
            hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);

        TraceMsg(TF_SAPI_PERF, "SpNotifyTranslator for RecoCtxtForCmd is generated, hr=%x", hr);

        // set this class instance to notify control object
        if (SUCCEEDED(hr))
        {
            m_pime->_EnsureWorkerWnd();

            hr = cpNotify->InitCallback( NotifyCallbackForCmd, 0, (LPARAM)this );
        }
        if (SUCCEEDED(hr))
        {
            hr = m_cpRecoCtxtForCmd->SetNotifySink(cpNotify);
            TraceMsg(TF_SAPI_PERF, "SetNotifySink for RecoCtxtForCmd is Done, hr=%x", hr);
        }

        // set the events we're interested in
        if( SUCCEEDED( hr ) )
        {
            const ULONGLONG ulInterest = SPFEI(SPEI_RECOGNITION) |
                                         SPFEI(SPEI_FALSE_RECOGNITION) |
                                         SPFEI(SPEI_RECO_OTHER_CONTEXT);

            hr = m_cpRecoCtxtForCmd->SetInterest(ulInterest, ulInterest);
            TraceMsg(TF_SAPI_PERF, "SetInterest for m_cpRecoCtxtForCmd is Done, hr=%x", hr);
        }

        TraceMsg(TF_SAPI_PERF, "InitializeCallback for m_cpRecoCtxtForCmd is done!!! hr=%x", hr);

        // Load the shard command grammars and activate them by default.

        if (SUCCEEDED(hr) )
        {
            hr = m_cpRecoCtxtForCmd->CreateGrammar(GRAM_ID_CMDSHARED, &m_cpSharedGrammarInVoiceCmd);
            TraceMsg(TF_SAPI_PERF, "Create SharedCmdGrammar In Voice cmd, hr=%x", hr);
        }    

        if (S_OK == hr)
        {
           hr = S_FALSE;

           // try resource first because loading cmd from file takes
           // quite long time
           //
           if (m_langid == 0x409 ||    // English
               m_langid == 0x411 ||    // Japanese
               m_langid == 0x804 )     // Simplified Chinese
           {
               hr = m_cpSharedGrammarInVoiceCmd->LoadCmdFromResource(
                                                         g_hInstSpgrmr,
                                                         (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_SHAREDCMD_CFG),
                                                         L"SRGRAMMAR", 
                                                         m_langid, 
                                                         SPLO_DYNAMIC);

               TraceMsg(TF_SAPI_PERF, "Load shared cmd.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have built-in grammar
               // it provides a way for customer to localize their grammars in different languages
               _GetCmdFileName(m_langid);
               if (m_szShrdCmdFile[0])
               {
                   hr = m_cpSharedGrammarInVoiceCmd->LoadCmdFromFile(m_szShrdCmdFile, SPLO_DYNAMIC);
               } 
           }

           // Activate the grammar by default

           if ( hr == S_OK )
           {
               if (m_pime->_AllCmdsEnabled( ))
               {
                    hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(NULL,  NULL, SPRS_ACTIVE);
                    TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpSharedGrammarInVoiceCmd");
               }
               else
               {
                    // Some category commands are disabled.
                    // active them individually.

                    hr = _ActiveCategoryCmds(DC_CC_SelectCorrect, m_pime->_SelectCorrectCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Navigation, m_pime->_NavigationCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Casing, m_pime->_CasingCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Editing, m_pime->_EditingCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_Keyboard, m_pime->_KeyboardCmdEnabled( ), ACTIVE_IN_COMMAND_MODE );

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_TTS, m_pime->_TTSCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);

                    if ( hr == S_OK )
                        hr = _ActiveCategoryCmds(DC_CC_LangBar, m_pime->_LanguageBarCmdEnabled( ), ACTIVE_IN_COMMAND_MODE);
                }
           }

           if (S_OK != hr)
           {
               m_cpSharedGrammarInVoiceCmd.Release();
           }
           else if ( PRIMARYLANGID(m_langid) == LANG_ENGLISH  || 
                     PRIMARYLANGID(m_langid) == LANG_JAPANESE ||
                     PRIMARYLANGID(m_langid) == LANG_CHINESE )
           {
              // means this language's grammar support Textbuffer commands.
              m_fSelectionEnabled = TRUE;
           }

#ifdef RECOSLEEP
           InitSleepClass( );
#endif
        }
        TraceMsg(TF_SAPI_PERF, "Finish the initalization for RecoCtxtForCmd");
    }
     
    TraceMsg(TF_SAPI_PERF, "InitializeSAPIForCmd exits!");

    return hr;
}

#ifdef RECOSLEEP
void  CSpTask::InitSleepClass( )
{
   // Load the Sleep/Wakeup grammar.
   if ( !m_pSleepClass )
   {
       m_pSleepClass = new CRecoSleepClass(this);
       if ( m_pSleepClass )
          m_pSleepClass->InitRecoSleepClass( );
   }
}

BOOL  CSpTask::IsInSleep( )
{
    BOOL  fSleep = FALSE;

    if ( m_pSleepClass )
        fSleep = m_pSleepClass->IsInSleep( );

    return fSleep;
}
#endif

HRESULT   CSpTask::_SetDictRecoCtxtState( BOOL  fEnable )
{
    HRESULT hr = S_OK;

    TraceMsg(TF_SAPI_PERF, "_SetDictRecoCtxtState is called, fEnable=%d", fEnable);

    if ( m_cpRecoCtxt && (fEnable != m_fDictCtxtEnabled))
    {
        if (fEnable )
        {
            // if Voice command reco Context is enabled, just disable it.
            if (m_cpRecoCtxtForCmd && m_fCmdCtxtEnabled)
            {
                hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_DISABLED);
                m_fCmdCtxtEnabled = FALSE;
                TraceMsg(TF_SAPI_PERF, "Disable Voice command Reco Context");
            }

            // Build toolbar grammar if it is not built out yet.
            if (m_pLangBarSink && !m_pLangBarSink->_IsTBGrammarBuiltOut( ))
                m_pLangBarSink->_OnSetFocus( );

            // Enable Dictation Reco Context.
            if ( hr == S_OK )
            {
                hr = m_cpRecoCtxt->SetContextState(SPCS_ENABLED);
                TraceMsg(TF_SAPI_PERF, "Enable Dictation Reco Context");

                if ( hr == S_OK && !m_fDictationReady )
                {
                    WCHAR sz[128];
                    sz[0] = '\0';
                    CicLoadStringWrapW(g_hInst, IDS_NUI_BEGINDICTATION, sz, ARRAYSIZE(sz));

                    m_pime->GetSpeechUIServer()->UpdateBalloon(TF_LB_BALLOON_RECO, sz , -1);
                    m_fDictationReady   = TRUE;
                    TraceMsg(TF_SAPI_PERF, "Show Begin Dictation!");
                }
            }
        }
        else
        {
           hr = m_cpRecoCtxt->SetContextState(SPCS_DISABLED);
           TraceMsg(TF_SAPI_PERF, "Disable Dictation Reco Context");
        }

        if ( hr == S_OK )
        {
            m_fDictCtxtEnabled = fEnable;
        }
    }

    TraceMsg(TF_SAPI_PERF, "_SetDictRecoCtxtState exit");

    return hr;
}

HRESULT   CSpTask::_SetCmdRecoCtxtState( BOOL fEnable )
{
    TraceMsg(TF_SAPI_PERF, "_SetCmdRecoCtxtState is called, fEnable=%d", fEnable);
    HRESULT hr = S_OK;

    if ( fEnable != m_fCmdCtxtEnabled )
    {
        if ( fEnable )
        {
            if ( !m_cpRecoCtxtForCmd )
                hr = InitializeSAPIForCmd( );

            if ( hr == S_OK && m_cpRecoCtxtForCmd )
            {
                // Disable Dictation Context if it is enabled now.
                if (m_cpRecoCtxt && m_fDictCtxtEnabled)
                {
                    hr = m_cpRecoCtxt->SetContextState(SPCS_DISABLED);
                    m_fDictCtxtEnabled = FALSE;
                    TraceMsg(TF_SAPI_PERF, "DISABLE Dictation RecoContext");
                }

                if ( hr == S_OK && m_pime && !m_pime->_AllCmdsDisabled( ) )
                {
                    // Build toolbar grammar if it is not built out yet.
                    if (m_pLangBarSink && !m_pLangBarSink->_IsTBGrammarBuiltOut( ))
                        m_pLangBarSink->_OnSetFocus( );

                    // Fill text to selection grammar's buffer.

                     _UpdateTextBuffer(m_cpRecoCtxtForCmd);

                    hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_ENABLED);
                    m_fCmdCtxtEnabled = fEnable;
                    TraceMsg(TF_SAPI_PERF, "Enable Voice command Reco Context");
                }
            }
        }
        else if ( m_cpRecoCtxtForCmd ) // fEnable is FALSE
        {
            hr = m_cpRecoCtxtForCmd->SetContextState(SPCS_DISABLED);
            m_fCmdCtxtEnabled = FALSE;
            TraceMsg(TF_SAPI_PERF, "Disable Voice Command Reco Context");
        }
    }

    TraceMsg(TF_SAPI_PERF, "_SetCmdRecoCtxtState exits");
    return hr;
}



LANGID CSpTask::_GetPreferredEngineLanguage(LANGID langid)
{
    SPRECOGNIZERSTATUS   stat;
    LANGID               langidRet = 0;

    // (possible TODO) After M3 SPG may come up with GetAttrRank API that 
    //       would give us the info about whether a token has a particular 
    //       attrib supported. Then we could use that for checking langid
    //       a recognizer supports without using the real engine instance.
    //       We could also consolidate a method to check if SR is enabled
    //       for the current language once we have that.
    // 
    Assert(m_cpRecoEngine);
    if (S_OK == m_cpRecoEngine->GetStatus(&stat))
    {
        for (ULONG ulId = 0; ulId < stat.cLangIDs; ulId++)
        {
            if (langid == stat.aLangID[ulId])
            {
                langidRet =  langid;
                break;
            }
        }
        if (!langidRet)
        {
            // if there's no match, just return the most prefered one
            langidRet = stat.aLangID[0];
        }
    }
    return langidRet;
}

HRESULT CSpTask::_SetVoice(LANGID langid)
{
    CComPtr<ISpObjectToken> cpToken;

    char  szLang[MAX_PATH];
    WCHAR wsz[MAX_PATH];

    StringCchPrintfA(szLang,ARRAYSIZE(szLang), "Language=%x", langid);
    MultiByteToWideChar(CP_ACP, NULL, szLang, -1, wsz, ARRAYSIZE(wsz));

    HRESULT hr = SpFindBestToken( SPCAT_VOICES, wsz, NULL, &cpToken);

    if (S_OK == hr)
    {
        hr = m_cpVoice->SetVoice(cpToken);
    }
    return hr;
}

//
// GetSAPIInterface(riid, (void **)ppunk)
// 
// here, try pass through the given IID
//       to SAPI5 interface
// 
// CComPtr<ISpResourceManager> m_cpResMgr;
// CComPtr<ISpRecoContext>     m_cpRecoCtxt;
// CComPtr<ISpRecognizer>      m_cpRecoEngine;
// CComPtr<ISpVoice>           m_cpVoice;
// 
// the above 5 interfaces are currently used by
// Cicero/Sapi Layer 
//
// if a client calls ITfFunctionProvider::GetFunction()
// for a SAPI interface, we return what we've already 
// instantiated so the caller can setup options
// for the currently used SAPI objects (reco ctxt for ex)
//
HRESULT CSpTask::GetSAPIInterface(REFIID riid, void **ppunk)
{
    Assert(ppunk);
    
    *ppunk = NULL;

    
    if (IsEqualGUID(riid, IID_ISpResourceManager))
    {
        *ppunk = m_cpResMgr;
    }
    else if (IsEqualGUID(riid,IID_ISpRecoContext))
    {
        *ppunk = m_cpRecoCtxt;
    }
    else if (IsEqualGUID(riid,IID_ISpRecognizer))
    {
        *ppunk = m_cpRecoEngine;
    }
    else if (IsEqualGUID(riid,IID_ISpVoice))
    {
        *ppunk = m_cpVoice;
    }
    else if (IsEqualGUID(riid,IID_ISpRecoGrammar))
    {
        *ppunk = m_cpDictGrammar;
    }
    if(*ppunk)
    {
        ((IUnknown *)(*ppunk))->AddRef();
    }
    
    return *ppunk ? S_OK : E_NOTIMPL;
}


// 
// Get RecoContext for Voice Command mode.
//
HRESULT CSpTask::GetRecoContextForCommand(ISpRecoContext **ppRecoCtxt)
{
    HRESULT hr = E_FAIL;

    Assert(ppRecoCtxt);

    if ( m_cpRecoCtxtForCmd )
    {
        *ppRecoCtxt = m_cpRecoCtxtForCmd;
        (*ppRecoCtxt)->AddRef( );
        hr = S_OK;
    }

    return hr; 
}

// test: use Message callback
LRESULT CALLBACK CSapiIMX::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSapiIMX *_this = (CSapiIMX *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    CSpTask  *_sptask = _this ? _this->m_pCSpTask : NULL;

    switch(uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
            if (pcs)
            {
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)(pcs->lpCreateParams));
            }
            break; 
        }
        case WM_TIMER:

        if ( wParam != TIMER_ID_CHARTYPED )
            KillTimer( hWnd, wParam );

        if (wParam == TIMER_ID_OPENCLOSE)
        {
            // i've seen this null case once but is it possible?
            TraceMsg(TF_SAPI_PERF, "TIMER_ID_OPENCLOSE is fired off ...");
            if (_this->_tim)
                _this->_HandleOpenCloseEvent(MICSTAT_ON);
        }
        else if ( wParam == TIMER_ID_CHARTYPED )
        {
            DWORD   dwNumCharTyped;
            BOOL    fDictOn;

            fDictOn = _this->GetOnOff( ) && _this->GetDICTATIONSTAT_DictOnOff( );
            dwNumCharTyped = _this->_GetNumCharTyped( );

            TraceMsg(TF_GENERAL, "dwNumCharTyped=%d", dwNumCharTyped);

            _this->_KillCharTypeTimer( );

            Assert(S_OK == _this->IsActiveThread());
            // We should never try to reactivate dictation on a thread that shouldn't be active.

            if ( fDictOn && _sptask && (S_OK == _this->IsActiveThread()) )
            {
                if ( dwNumCharTyped <= 1 )
                {
                    // There is no more typing during this period
                    // possible, user finished typing.
                    // 
                    // we need to resume dication again if the Dictation mode is ON.
                    ULONGLONG ulInterest = SPFEI(SPEI_SOUND_START) |
                             SPFEI(SPEI_SOUND_END) |
                             SPFEI(SPEI_PHRASE_START) |
                             SPFEI(SPEI_RECOGNITION) |
                             SPFEI(SPEI_FALSE_RECOGNITION) |
                             SPFEI(SPEI_RECO_OTHER_CONTEXT) |
                             SPFEI(SPEI_HYPOTHESIS) |
                             SPFEI(SPEI_INTERFERENCE) |
                             SPFEI(SPEI_ADAPTATION);

                    _sptask->_SetDictRecoCtxtState(TRUE);
                    _sptask->_SetRecognizerInterest(ulInterest);
                    _sptask->_UpdateBalloon(IDS_LISTENING, IDS_LISTENING_TOOLTIP);
                }
                else
                {
                    // There are more typing during this period,
                    // we want to set another timer to watch the end of the typing.
                    //
                    _this->_SetCharTypeTimer( );
                }
            }
        }

        break;
        case WM_PRIV_FEEDCONTEXT:
        if (_sptask && lParam != NULL && _sptask->m_pdc)
        {
            _sptask->m_pdc->FeedContextToGrammar(_sptask->m_cpDictGrammar);
            delete _sptask->m_pdc;
            _sptask->m_pdc = NULL;
        }
        break;
        case WM_PRIV_LBARSETFOCUS:
            if (_sptask)
                _sptask->m_pLangBarSink->_OnSetFocus();
            break;
        case WM_PRIV_SPEECHOPTION:
            {
                _this->_ResetDefaultLang();
                BOOL fSREnabledForLanguage = _this->InitializeSpeechButtons();
        
                _this->SetDICTATIONSTAT_DictEnabled(fSREnabledForLanguage);
            }
            break;
        case WM_PRIV_ADDDELETE:
            _this->_DisplayAddDeleteUI();
            break;

        case WM_PRIV_SPEECHOPENCLOSE:
            TraceMsg(TF_SAPI_PERF, "WM_PRIV_SPEECHOPENCLOSE is handled");
            _this->_HandleOpenCloseEvent();
            break;
        
        case WM_PRIV_OPTIONS:
            _this->_InvokeSpeakerOptions();
            break;

        case WM_PRIV_DORECONVERT :
            _this->_DoReconvertOnRange( );
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return 0;
}

void CSpTask::NotifyCallbackForCmd(WPARAM wParam, LPARAM lParam )
{
    CSpTask *_this = (CSpTask *)lParam;

    // SAPI M2 work around which is to be removed when M3 comes up. 
    // See comments in  CSpTask::_SetInputOnOffState for more detail
    //
    // TABLETPC - NEEDED TO ALLOW FINAL RECOGNITIONS TO BE RECEIVED AFTER AUDIO STOPPED.
/*    if (_this->m_fInputState == FALSE)
    {
        return;
    }*/

    if (_this->m_pime->fDeactivated())
        return;

    if (!_this->m_cpRecoCtxtForCmd)
    {
        return;
    }

    _this->SharedRecoNotify(_this->m_cpRecoCtxtForCmd);

    return;
}


void CSpTask::NotifyCallback( WPARAM wParam, LPARAM lParam )
{
    CSpTask *_this = (CSpTask *)lParam;

    // SAPI M2 work around which is to be removed when M3 comes up. 
    // See comments in  CSpTask::_SetInputOnOffState for more detail
    //

    // TABLETPC - NEEDED TO ALLOW FINAL RECOGNITIONS TO BE RECEIVED AFTER AUDIO STOPPED.
/*    if (_this->m_fInputState == FALSE)
    {
        return;
    }*/

    if (_this->m_pime->fDeactivated())
        return;

    if (!_this->m_cpRecoCtxt)
    {
        return;
    }

    _this->SharedRecoNotify(_this->m_cpRecoCtxt);

    return;
}

// This is real handler for the recognition notification.
//
// it could be shared by two RecoContexts.
//
void  CSpTask::SharedRecoNotify(ISpRecoContext *pRecoCtxt)
{
    CSpEvent event;
#ifdef SAPI_PERF_DEBUG
   static  int  iCount = 0;

   if ( iCount == 0 )
   {
      TraceMsg(TF_SAPI_PERF, "The first time Get Notification from Engine!!!");
      iCount ++;
   }
#endif

    Assert (pRecoCtxt);

    while ( event.GetFrom(pRecoCtxt) == S_OK )
    {
        switch (event.eEventId)
        {
            case SPEI_SOUND_START:
                ATLASSERT(!m_bInSound);
                m_bInSound = TRUE;
                break;

            case SPEI_INTERFERENCE:
                //
                // we do not need interference when not in dictation
                // mode
                //
                if (m_pime->GetDICTATIONSTAT_DictOnOff() &&
                    S_OK == m_pime->IsActiveThread())
                {
                    _HandleInterference((ULONG)(event.lParam)); 
                }
                break;

            case SPEI_PHRASE_START:
                ATLASSERT(m_bInSound);
                m_bGotReco = FALSE;

                if (m_pime->GetDICTATIONSTAT_DictOnOff() &&
                    S_OK == m_pime->IsActiveThread())
                {
                    // Before inject feedback UI, we need to save the current IP
                    // and check if we want to pop up the Add/Remove SR dialog UI.

                    // And then inject FeedbackUI as usual

                    m_pime->SaveCurIPAndHandleAddDelete_InjectFeedbackUI( );

                    // show "dictating..." to the balloon
                    _ShowDictatingToBalloon(TRUE);
                }

                break;

            case SPEI_HYPOTHESIS:
                ATLASSERT(!m_bGotReco);


                // if current microphone status is OFF
                // we do not want to show any hypothesis
                // at least
                //

                // DO NOT HAVE DEBUG CODE TO SHOW ENGINE STATE. CAN BLOCK CICERO AND CHANGE BEHAVIOR.
                if (!GetSystemMetrics(SM_TABLETPC))
                    _ShowDictatingToBalloon(TRUE);

                //
                // we do not need the feedback UI when not in dictation
                // mode
                //
                if (m_pime->GetDICTATIONSTAT_DictOnOff() &&
                    S_OK == m_pime->IsActiveThread())
                {
                    m_pime->_HandleHypothesis(event);
                }
                
                break;

            case SPEI_RECO_OTHER_CONTEXT:
            case SPEI_FALSE_RECOGNITION:
            {
                HRESULT hr = S_OK;

                if ( event.eEventId == SPEI_FALSE_RECOGNITION )
                {
                    // Set 'What was that?' feedback text.
                    _UpdateBalloon(IDS_INT_NOISE, IDS_INTTOOLTIP_NOISE);
                }

                // set this flag anyways
                //
                ATLASSERT(!m_bGotReco);
                m_bGotReco = TRUE;

                // Reset hypothesis counters.
                m_pime->_HandleFalseRecognition();

                hr = m_pime->EraseFeedbackUI();
                ATLASSERT("Failed to erase potential feedback on a false recognition." && SUCCEEDED(hr));

                break;
            }

            case SPEI_RECOGNITION:

                // Set 'Listening...' feedback text. Can be overwritten by command feedback.
                _UpdateBalloon(IDS_LISTENING, IDS_LISTENING_TOOLTIP);

                // set this flag anyways
                //
                ATLASSERT(!m_bGotReco);
                m_bGotReco = TRUE;

                ULONGLONG ullGramID;

                if ( S_OK == m_pime->IsActiveThread() )
                {
                    m_pime->_HandleRecognition(event, &ullGramID);
                }

                // if ( _GetSelectionStatus( ) )
                if (ullGramID == GRAM_ID_SPELLING)
                {
                    _SetSelectionStatus(FALSE);
                    _SetSpellingGrammarStatus(FALSE);
                }

                _UpdateTextBuffer(pRecoCtxt);

                if ( (ullGramID == GRAM_ID_DICT) || (ullGramID == GRAM_ID_SPELLING) )
                {
                    // Update Balloon.
                    if (!GetSystemMetrics(SM_TABLETPC))
                        _UpdateBalloon(IDS_LISTENING, IDS_LISTENING_TOOLTIP);

                    // every time dictated text is injected, we want to watch 
                    // again if there is IP change after that. 
                    // so clear the flag now.
                    m_pime->_SetIPChangeStatus( FALSE );
                }

                break;

            case SPEI_SOUND_END:
                m_bInSound = FALSE;

                break;
                
            case SPEI_ADAPTATION:
                TraceMsg(TF_GENERAL, "Get SPEI_ADAPTATION notification");

                if ( m_pime->_HasMoreContent( ) )
                {
                     m_pime->_GetNextRangeEditSession( );
                }
                else
                    // There is no more content for this doc.
                    // set the interesting event value to avoid this notification.
                    m_pime->_UpdateRecoContextInterestSet(FALSE);

                break;
#ifdef SYSTEM_GLOBAL_MIC_STATUS
            case SPEI_RECO_STATE_CHANGE:
                m_pime->SetOnOff(_GetInputOnOffState());
                break;
#endif

            default:
                break;
        }
    }
    return;
}

HRESULT CSpTask::_UpdateTextBuffer(ISpRecoContext *pRecoCtxt)
{
    HRESULT  hr = S_OK;

    if ( !_IsSelectionEnabled( ) )
       return S_OK;

    if ( !pRecoCtxt || !m_pime)
        return E_FAIL;

    if ( m_pime->_SelectCorrectCmdEnabled( ) || m_pime->_NavigationCmdEnabled( ) )
    {
        BOOL  fDictOn, fCmdOn;

        fDictOn = m_pime->GetOnOff( ) && m_pime->GetDICTATIONSTAT_DictOnOff( );
        fCmdOn = m_pime->GetOnOff( ) && m_pime->GetDICTATIONSTAT_CommandingOnOff( );


        if ( fDictOn && m_cpSharedGrammarInDict && !m_pime->_AllDictCmdsDisabled( ))
            hr = m_pime->UpdateTextBuffer(pRecoCtxt, m_cpSharedGrammarInDict);
        else if (fCmdOn && m_cpSharedGrammarInVoiceCmd )
            hr = m_pime->UpdateTextBuffer(pRecoCtxt, m_cpSharedGrammarInVoiceCmd);
    }

    return hr;
}

// When selection grammar status is changed from inactive to active
// this function will be called to fill text to the grammar buffer.
//
HRESULT  CSpTask::_UpdateSelectGramTextBufWhenStatusChanged(  )
{
    BOOL  fDictOn, fCmdOn;
    HRESULT  hr = S_OK;

    // Check current mode status.

    fDictOn = m_pime->GetDICTATIONSTAT_DictOnOff( );
    fCmdOn =  m_pime->GetDICTATIONSTAT_CommandingOnOff( );

    if ( fDictOn )
        hr = _UpdateTextBuffer(m_cpRecoCtxt);
    else if ( fCmdOn )
        hr = _UpdateTextBuffer(m_cpRecoCtxtForCmd);

    return hr;
}


HRESULT CSpTask::_OnSpEventRecognition(ISpRecoResult *pResult, ITfContext *pic, TfEditCookie ec)
{
    HRESULT hr = S_OK;
    BOOL fDiscard = FALSE;
    BOOL fCtrlSymChar = FALSE;  // Control or Punctuation character

   
    if (pResult)
    {
        static const WCHAR szUnrecognized[] = L"<Unrecognized>";
        LANGID langid;
        
        SPPHRASE *pPhrase;

        hr = pResult->GetPhrase(&pPhrase);
        if (SUCCEEDED(hr) && pPhrase)
        {
            // AJG - ADDED FILTERING CODE.
            switch (pPhrase->Rule.ulCountOfElements)
            {
                case 0:
                {
                    ASSERT(pPhrase->Rule.ulCountOfElements != 0);
                    // SHOULD NEVER OCCUR.
                    break;
                }
                case 1:
                {
                    const SPPHRASEELEMENT *pElement;

                    pElement = pPhrase->pElements;

                    if (!m_fTestedForOldMicrosoftEngine)
                    {
                        // Test token name to see if it contains MSASREnglish.
                        CComPtr<ISpObjectToken> cpRecoToken;
                        WCHAR *pwszCoMemTokenId;
                        m_cpRecoEngine->GetRecognizer(&cpRecoToken);
                        if (cpRecoToken)
                        {
                            if (SUCCEEDED(cpRecoToken->GetId(&pwszCoMemTokenId)))
                            {
                                if (wcsstr(pwszCoMemTokenId, L"MSASREnglish") != NULL)
                                {
                                    // It is an old Microsoft engine. Check for registry key that tells us to disable the heuristic anyway.
                                    BOOL fDisableHeuristicAnyway = FALSE;
                                    if (FAILED(cpRecoToken->MatchesAttributes(L"DisableCiceroConfidence", &fDisableHeuristicAnyway)) || fDisableHeuristicAnyway == FALSE)
                                    {
                                        m_fOldMicrosoftEngine = TRUE;
                                        // Means we *will* apply single word confidence heuristic to improve performance.
                                    }
                                }
                                CoTaskMemFree(pwszCoMemTokenId);
                            }
                        }

                        // One of lazy initialization. Do not do this again.
                        m_fTestedForOldMicrosoftEngine = TRUE;
                    }
                    if (m_fOldMicrosoftEngine && m_pime->_RequireHighConfidenceForShorWord( ) )
                    {
                        // Only apply this heuristic to 5.x Microsoft engines (Token name contains MSASREnglish).
                        if (pElement && pElement->ActualConfidence != 1 &&
                            (!pElement->pszLexicalForm || wcslen(pElement->pszLexicalForm) <= 5) &&
                            (!pElement->pszDisplayText || wcslen(pElement->pszDisplayText) <= 5) )
                        {
                            TraceMsg(TF_GENERAL, "Discarded Result : Single Word, Low Confidence!");
                            _UpdateBalloon(IDS_INT_NOISE, IDS_INTTOOLTIP_NOISE );
                            fDiscard = TRUE;
                        }
                    }


                    if (pPhrase->pElements[0].pszDisplayText )
                    {
                        WCHAR  wch;

                        wch = pPhrase->pElements[0].pszDisplayText[0];

                        if ( iswcntrl(wch) || iswpunct(wch) )
                            fCtrlSymChar = TRUE;
                    }

                }
                case 2:
                {
                    // Do something here?
                }
                default:
                {
                    // Do no filtering of the result.
                }
            }
            // AJG - CHECK WE AREN'T IN THE MIDDLE OF A WORD. NOT GENERALLY A DESIRED 'FEATURE'. CAUSES ANNOYING ERRORS.
            // if this is spelled text, don't check if it is inside of a word.
            if ((pPhrase->ullGrammarID != GRAM_ID_SPELLING) && _IsSelectionInMiddleOfWord(ec) && !fCtrlSymChar)
            {
                TraceMsg(TF_GENERAL, "Discarded Result : IP is in middle of a word!");
                _UpdateBalloon(IDS_BALLOON_DICTAT_PAUSED, IDS_BALLOON_TOOLTIP_IP_INSIDE_WORD);
                fDiscard = TRUE;
            }
        }

        if ( SUCCEEDED(hr) && fDiscard )
        {
          
           // This phrase will not be injected to the document.
           // the code needs to feed context to the SR engine so that
           // SR engine will not base on wrong assumption.

           if ( m_pime  && m_pime->GetDICTATIONSTAT_DictOnOff() )
              m_pime->_SetCurrentIPtoSR();

        }

        if (SUCCEEDED(hr) && pPhrase && !fDiscard)
        {
            // retrieve LANGID from phrase
            langid = pPhrase->LangID;

            // SPPHRASE includes non-serialized text
            CSpDynamicString dstr;
            ULONG ulNumElements = pPhrase->Rule.ulCountOfElements;

            hr = _GetTextFromResult(pResult, langid, dstr);

            if ( hr == S_OK )
            {
                // check the current IP to see if it was a selection,
                // then see if the best hypothesis already matches the current
                // selection. 

                int lCommitHypothesis = 0;
                for (int nthHypothesis = 1;_DoesSelectionHaveMatchingText(dstr, ec); nthHypothesis++)
                {
                    CSpDynamicString dsNext;

                    TraceMsg(TF_GENERAL, "Switched to alternate result as main result exactly matched selection!");

                    // We could add one to request hypothesis since 1 = the main phrase and we already know that matched.
                    // However I don't believe this is guaranteed to be the case by SAPI - it just happens to be the case
                    // with the Microsoft engine.
                    if (_GetNextBestHypothesis(pResult, nthHypothesis, &ulNumElements, langid, dstr, dsNext, ec))
                    {
                        dstr.Clear();
                        dstr.Append(dsNext);
                        // Need to commit phrase to prevent stored result object being out of sync with count of
                        // elements in wrapping object.
                        lCommitHypothesis = nthHypothesis;
                        // Note - at this point, we don't know if we can use it. We have to loop once more to determine this.
                    }
                    else
                    {
                        TraceMsg(TF_SAPI_PERF, "No alternate found that differed from the user selection.\n");
                        // No more alternate phrase
                        // There is no any alt phrase which has different text from current selection.
                        // should stop here, otherwise, infinite loop.
                        lCommitHypothesis = 0;
                        // Reset element count to match primary phrase.
                        ulNumElements = pPhrase->Rule.ulCountOfElements;
                        // Reset text:
                        dstr.Clear();
                        hr = _GetTextFromResult(pResult, langid, dstr);
                        break;
                    }
                }

                if (0 != lCommitHypothesis)
                {
                    ULONG cAlt = lCommitHypothesis;
                    ISpPhraseAlt **ppAlt = (ISpPhraseAlt **)cicMemAlloc(cAlt*sizeof(ISpPhraseAlt *));
                    if (ppAlt)
                    {
                        memset(ppAlt, 0, cAlt * sizeof(ISpPhraseAlt *)); 
                        hr = pResult->GetAlternates( 0, ulNumElements, cAlt,  ppAlt,  &cAlt );

                        Assert( cAlt == lCommitHypothesis );

                        if ((S_OK == hr) && (cAlt == lCommitHypothesis))
                        {
                            ((ppAlt)[lCommitHypothesis-1])->Commit();
                        }

                        // Release references to alternate phrases.
                        for (UINT i = 0; i < cAlt; i++)
                        {
                            if (NULL != (ppAlt)[i])
                            {
                                ((ppAlt)[i])->Release();
                            }
                        }
            
                        cicMemFree(ppAlt);
                    }
                }

                CComPtr<ITfRange>  cpTextRange;
                ITfRange *pSavedIP;

                pSavedIP = m_pime->GetSavedIP( );

                if (pSavedIP)
                    pSavedIP->Clone(&cpTextRange);

                // this call will have to be per element. see my comment below.
                if (pPhrase->ullGrammarID == GRAM_ID_SPELLING)
                {
                    hr = m_pime->InjectSpelledText(dstr, langid);
                }
                else 
                {
                    hr = m_pime->InjectText(dstr, langid);

                    if ( hr == S_OK )
                    {
                        // now we use the result object directly to attach
                        // to a docuement.
                        // the result object gets addref'd in the Attach() 
                        // call.
                        //
                        hr = m_pime->AttachResult(pResult, 0, ulNumElements);
                    }

                    // Handle spaces carefully and specially.
                    if ( hr == S_OK  && cpTextRange )
                    {
                        hr = m_pime->HandleSpaces(pResult, 0, ulNumElements, cpTextRange, langid);
                    }
                }
            }
        }

        if ( pPhrase)
            ::CoTaskMemFree( pPhrase );
    }

    return hr;
}

//
// _GetTextFromResult
//
// synopsis: get text from phrase considering space control
//           based on locale
//
HRESULT CSpTask::_GetTextFromResult(ISpRecoResult *pResult, LANGID langid, CSpDynamicString &dstr)
{
    BYTE bAttr;
    HRESULT  hr = S_OK;
    
    Assert(pResult);

    if ( !pResult )
        return E_INVALIDARG;

    hr = pResult->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstr, &bAttr);

    if ( hr == S_OK )
    {
        if (bAttr & SPAF_ONE_TRAILING_SPACE)
        {
            dstr.Append(L" ");
        }
        else if (bAttr & SPAF_TWO_TRAILING_SPACES)
        {
            dstr.Append(L"  ");
        }

        if (bAttr & SPAF_CONSUME_LEADING_SPACES)
        {
            // we need to figure out the correct behavior based on LANGID
        }
    }

    return hr;
}

//
// _IsSelectionInMiddleOfWord
//
// synopsis: check if the current IP is empty and inside of a word
//          
BOOL CSpTask::_IsSelectionInMiddleOfWord(TfEditCookie ec)
{
    BOOL fInsideWord = FALSE;

    if ( m_langid == 0x0409 )
    {
        if (CComPtr<ITfRange> cpInsertionPoint =  m_pime->GetSavedIP())
        {
            WCHAR szSurrounding[3] = L"  ";

            // clone the IP range since we want to move the anchor
            //
            CComPtr<ITfRange> cpClonedRange;
            cpInsertionPoint->Clone(&cpClonedRange);

            BOOL fEmpty;
            cpClonedRange->IsEmpty(ec, &fEmpty);
            if (fEmpty)
            {
                LONG    l1, l2;
                ULONG   ul;
                HRESULT hr;

                cpClonedRange->Collapse(ec, TF_ANCHOR_START);
                cpClonedRange->ShiftStart(ec, -1, &l1, NULL);
                cpClonedRange->ShiftEnd(ec, 1, &l2, NULL);
                if (l1 != 0) // Not at start of document.
                {
                    hr = cpClonedRange->GetText(ec, TF_TF_MOVESTART, szSurrounding, (l2!=0)?(2):(1), &ul);
                    if (SUCCEEDED(hr) && iswalpha(szSurrounding[0]) && iswalpha(szSurrounding[1]) )
                    {
                        fInsideWord = TRUE;
                    }
                }
                // if l1 == 0, means the ip is at the start of document.
                // fInsideWord is set to FALSE already by default.
            }
        }
    }
    return fInsideWord;
}

//
// DoesSelectionHaveMatchingText
//
// synopsis: check if the current saved IP has a selection that matches the text
//           passed in
//
#define SPACEBUFFER 4
// 2 characters either side of a word or phrase.

BOOL CSpTask::_DoesSelectionHaveMatchingText(WCHAR *psz, TfEditCookie ec)
{
    BOOL fMatch = FALSE;
    Assert(psz);

    if ( !psz )
    {
        return FALSE;
    }

    WCHAR *pszStripped = psz;
    ULONG ulCch = wcslen(psz);

    // Remove trailing space.
    while (ulCch > 0 && psz[ulCch-1] == L' ')
    {
        // Do not set null terminating character as this is a passed in string.
        ulCch --;
    }
    // Skip leading space in input text.
    while (pszStripped[0] == L' ')
    {
        pszStripped ++;
        ulCch --;
    }
    // Now have space-stripped word pointed to by pszTmp and with length ulCch

    if (CComPtr<ITfRange> cpInsertionPoint =  m_pime->GetSavedIP())
    {
        WCHAR *szRange = new WCHAR[ulCch+SPACEBUFFER+1];
        WCHAR *szRangeStripped = szRange;
       
        if (szRange)
        {
            // clone the IP range since we want to move the anchor
            //
            CComPtr<ITfRange> cpClonedRange;
            cpInsertionPoint->Clone(&cpClonedRange);
 
            ULONG cchRange; // max is the reco result
            
            HRESULT hr = cpClonedRange->GetText(ec, TF_TF_MOVESTART, szRange, ulCch+SPACEBUFFER, &cchRange);
            // Remove trailing space.
            while (cchRange > 0 && szRange[cchRange-1] == L' ')
            {
                // Can set null terminating character as this is our string.
                szRange[cchRange-1] = 0;
                cchRange --;
            }
            // Skip leading space in input text.
            while (szRangeStripped[0] == L' ')
            {
                szRangeStripped ++;
                cchRange --;
            }
            // Now have space-stripped word pointed to by pszTmp and with length ulCch
            if (S_OK == hr && cchRange > 0 && cchRange == ulCch)
            {
                if (wcsnicmp(pszStripped, szRangeStripped, ulCch) == 0) // Case insensitive compare.
                {
                    fMatch = TRUE;
                }
            }
            delete [] szRange;
        }
    }
    return fMatch;
}

//
// GetNextBestHypothesis
//
// synopsis: this actually gets the nth alternative from the given reco result
//           then adjusts the length accordingly based on the current selection
//          
//
BOOL CSpTask::_GetNextBestHypothesis
(
    ISpRecoResult *pResult, 
    ULONG nthHypothesis,
    ULONG *pulNumElements, 
    LANGID langid, 
    WCHAR *pszBest, 
    CSpDynamicString & dsNext,
    TfEditCookie ec
)
{
    if ( pulNumElements )
       *pulNumElements = 0;

    // get the entire text & length from the saved IP
    if (CComPtr<ITfRange> cpInsertionPoint =  m_pime->GetSavedIP())
    {
        CSpDynamicString dstr;
        CComPtr<ITfRange> cpClonedRange;
        CComPtr<ISpRecoResult> cpRecoResult;
        
        // clone the range since we move the anchor
        HRESULT hr = cpInsertionPoint->Clone(&cpClonedRange);
        
        ULONG cchRangeBuf = wcslen(pszBest);
        
        cchRangeBuf *= 2; // guess the possible # of char

        WCHAR *szRangeBuf = new WCHAR[cchRangeBuf+1];

        if ( !szRangeBuf )
        {
            // Error: Out of Memory 
            // Return here as FALSE.
            return FALSE;
        }

        while(S_OK == hr && !_IsRangeEmpty(ec, cpClonedRange))
        {
            hr = m_pime->_GetRangeText(cpClonedRange, TF_TF_MOVESTART, szRangeBuf, &cchRangeBuf);
            if (S_OK == hr)
            {
                szRangeBuf[cchRangeBuf] = L'\0';
                dstr.Append(szRangeBuf);
            }
        }
        delete [] szRangeBuf;

        // then get a best matching length of next best hypothesis

        // the current recognition should at least have a good guess for # of elements
        // since it turned out to be longer than the IP range.
        //
        Assert(pulNumElements);
        
        ISpPhraseAlt **ppAlt = (ISpPhraseAlt **)cicMemAlloc(nthHypothesis*sizeof(ISpPhraseAlt *));
        ULONG         cAlt = 0;
        if (!ppAlt)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memset(ppAlt, 0, nthHypothesis * sizeof(ISpPhraseAlt *));
            hr = pResult->GetAlternates( 0, *pulNumElements, nthHypothesis,  ppAlt,  &cAlt );
        }
        
        if (S_OK == hr)
        {
            UINT  i;
            SPPHRASE *pPhrase;
            
            if (nthHypothesis > cAlt)
            {
                *pulNumElements = 0;
                goto no_more_alt;
            }
            
            Assert(nthHypothesis); // 1 based, can't be 0

            hr = ((ppAlt)[nthHypothesis-1])->GetPhrase(&pPhrase);
            if (S_OK == hr)
            {
                for (i = 0; i < pPhrase->Rule.ulCountOfElements; i++ )
                {
                    int cchElement = wcslen(pPhrase->pElements[i].pszDisplayText) + 1;

                    WCHAR *szElement = new WCHAR[cchElement + 2];

                    if ( szElement )
                    {
                        // add +2 for trailing spaces
                        ParseSRElementByLocale(szElement, cchElement+2, pPhrase->pElements[i].pszDisplayText, 
                                                         langid, pPhrase->pElements[i].bDisplayAttributes );

                        dsNext.Append(szElement);

                        delete [] szElement;
                    }
                    else
                    {
                        // Out of Memory.
                        // stop here.
                        break;
                    }
                }
                // now i holds the number of elements that we want to use in the result
                // object
                *pulNumElements = i; 

                ::CoTaskMemFree(pPhrase);
            } // if S_OK == GetPhrase
        } // if S_OK == GetAlternates

no_more_alt:
        // Release phrase alternates objects.
        for (UINT i = 0; i < cAlt; i++)
        {
            if (NULL != ((ppAlt)[i]))
            {
                ((ppAlt)[i])->Release();
            }
        }
        // Free memory for array holding references to alternates objects.
        if (ppAlt)
        {
            ::cicMemFree(ppAlt);
        }

    }
    
    return *pulNumElements > 0;
}





void CSapiIMX::_EnsureWorkerWnd(void)
{
    if (!m_hwndWorker)
    {
        m_hwndWorker = CreateWindow(c_szWorkerWndClass, "", WS_POPUP,
                       0,0,0,0,
                       NULL, 0, g_hInst, this); 
    }

}

//
//  CSapiIMX::_GetAppMainWnd
//
//  This function gets the real main window of current application.
//  This main window would be used as the parent window of Add/Delete dialog
//  and Training wizard.
//
HWND    CSapiIMX::_GetAppMainWnd(void)
{

    HWND   hParentWnd = NULL;
    HWND   hMainWnd = NULL;

    hMainWnd = GetFocus( );

    if ( hMainWnd != NULL )
    {
        hParentWnd = GetParent(hMainWnd);

        while ( hParentWnd != NULL )
        {
            hMainWnd = hParentWnd;
            hParentWnd = GetParent(hMainWnd);
        }
    }

    return hMainWnd;
}
//
//    CSpTask::InitializeCallback
//
//
HRESULT CSpTask::InitializeCallback()
{
    TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeCallback is called");

    if (m_fCallbackInitialized)
    {
        TraceMsg(TF_SAPI_PERF, "m_fCallbackInitialized is true");
        return S_OK;
    }

    if (!m_fSapiInitialized)
        return S_FALSE; // can't do this without SAPI

    // set recognition notification
    CComPtr<ISpNotifyTranslator> cpNotify;
    HRESULT hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);
    TraceMsg(TF_SAPI_PERF, "SpNotifyTranslator for Reco is generated, hr=%x", hr);


    // set this class instance to notify control object
    if (SUCCEEDED(hr))
    {
        m_pime->_EnsureWorkerWnd();

        hr = cpNotify->InitCallback( NotifyCallback, 0, (LPARAM)this );
        TraceMsg(TF_SAPI_PERF, "InitCallback is Done, hr=%x", hr);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoCtxt->SetNotifySink(cpNotify);
        TraceMsg(TF_SAPI_PERF, "SetNotifySink is Done, hr=%x", hr);
    }

    // set the events we're interested in
    if( SUCCEEDED( hr ) )
    {
        const ULONGLONG ulInterest = SPFEI(SPEI_SOUND_START) | 
                                     SPFEI(SPEI_SOUND_END) | 
                                     SPFEI(SPEI_PHRASE_START) |
                                     SPFEI(SPEI_RECOGNITION) | 
                                     SPFEI(SPEI_RECO_OTHER_CONTEXT) |
                                     SPFEI(SPEI_FALSE_RECOGNITION) | 
                                     SPFEI(SPEI_HYPOTHESIS) | 
                                     SPFEI(SPEI_RECO_STATE_CHANGE) | 
                                     SPFEI(SPEI_INTERFERENCE); 

        hr = m_cpRecoCtxt->SetInterest(ulInterest, ulInterest);
        TraceMsg(TF_SAPI_PERF, "SetInterest is Done, hr=%x", hr);
    }

    if ( SUCCEEDED(hr) && m_cpVoice)
    {
        // set recognition notification
        CComPtr<ISpNotifyTranslator> cpNotify;
        hr = cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);

        TraceMsg(TF_SAPI_PERF, "Create SpNotifyTranslator for spVoice, hr=%x", hr);

        // set this class instance to notify control object
        if (SUCCEEDED(hr))
        {
            m_pime->_EnsureWorkerWnd();

            hr = cpNotify->InitCallback( SpeakNotifyCallback, 0, (LPARAM)this );
            TraceMsg(TF_SAPI_PERF, "InitCallback for SpVoice, hr=%x", hr);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_cpVoice->SetNotifySink(cpNotify);
            TraceMsg(TF_SAPI_PERF, "SetNotifySink for SpVoice, hr=%x", hr);
        }

        if ( hr == S_OK )
        {
            const ULONGLONG  ulInterestSpeak = SPFEI(SPEI_WORD_BOUNDARY) | 
                                               SPFEI(SPEI_START_INPUT_STREAM) |
                                               SPFEI(SPEI_END_INPUT_STREAM);
            
          hr = m_cpVoice->SetInterest(ulInterestSpeak, ulInterestSpeak);
          TraceMsg(TF_SAPI_PERF, "SetInterest for spVoice, hr=%x", hr);
        }
    }

    m_fCallbackInitialized = TRUE;

    TraceMsg(TF_SAPI_PERF, "CSpTask::InitializeCallback is called is done!!!  hr=%x", hr);

    return hr;
}

//
// _LoadGrammars
//
// synopsis - load CFG for dictation and commands available during dictation
//

HRESULT CSpTask::_LoadGrammars()
{
   HRESULT hr = E_FAIL;

   TraceMsg(TF_SAPI_PERF, "CSpTask::_LoadGrammars is called");
   
   if (m_cpRecoCtxt)
   {
       
       hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_DICT, &m_cpDictGrammar);

       TraceMsg(TF_SAPI_PERF, "Create Dict Grammar, hr=%x", hr);
       
       if (SUCCEEDED(hr))
       {
           hr = m_cpDictGrammar->LoadDictation(NULL, SPLO_STATIC);
           TraceMsg(TF_SAPI_PERF, "Load Dictation, hr = %x", hr);
       }

       if ( S_OK == hr && m_langid != 0x0804)  // Chinese Engine doesn't support SPTOPIC_SPELLING, 
                                 // This is the temporal workaround.
       {
            // we keep going regardless of availabillity of spelling topic
            // in the SR engine for the language so we use internal HRESULT
            // for this block of code
            //
            HRESULT hrInternal;

            // Load Spelling topic
            hrInternal = m_cpRecoCtxt->CreateGrammar(GRAM_ID_SPELLING, &m_cpSpellingGrammar);

            TraceMsg(TF_SAPI_PERF, "Create Spelling grammar, hrInternal=%x", hrInternal);

            if (SUCCEEDED(hrInternal))
            {
                hrInternal = m_cpSpellingGrammar->LoadDictation(SPTOPIC_SPELLING, SPLO_STATIC);
                TraceMsg(TF_SAPI_PERF, "Load Spelling dictation grammar, hrInternal=%x", hrInternal);
            }

             
            // this is now an experiment for English/Japanese only
            //
            if (SUCCEEDED(hrInternal))
            {
                hrInternal = m_cpSpellingGrammar->LoadCmdFromResource(
                                             g_hInstSpgrmr,
                                             (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_SPELLING_TOPIC_CFG),
                                             L"SRGRAMMAR", 
                                             m_langid, 
                                             SPLO_STATIC);

                TraceMsg(TF_SAPI_PERF, "Load CFG grammar spell.cfg, hr=%x", hrInternal);

            }

            if (S_OK == hrInternal)
            {
                m_fSpellingModeEnabled = TRUE;
            }
            else
                m_fSpellingModeEnabled = FALSE;

            TraceMsg(TF_SAPI_PERF, "m_fSpellingModeEnabled=%d", m_fSpellingModeEnabled);
       }
       
       //
       // load the dictation mode commands
       //
       if (SUCCEEDED(hr) )
       {
           hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_CCDICT, &m_cpDictCmdGrammar);
           TraceMsg(TF_SAPI_PERF, "Create DictCmdGrammar, hr=%x", hr);
       }    
       if (S_OK == hr)
       {
           hr = S_FALSE;


           // try resource first because loading cmd from file takes
           // quite long time
           //
           if (m_langid == 0x409 ||    // English
               m_langid == 0x411 ||    // Japanese
               m_langid == 0x804 )     // Simplified Chinese
           {
               hr = m_cpDictCmdGrammar->LoadCmdFromResource(
                                                         g_hInstSpgrmr,
                                                         (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_DICTATION_COMMAND_CFG),
                                                         L"SRGRAMMAR", 
                                                         m_langid, 
                                                         SPLO_DYNAMIC);

               TraceMsg(TF_SAPI_PERF, "Load dictcmd.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have built-in grammar
               _GetCmdFileName(m_langid);
               if (m_szCmdFile[0])
               {
                   hr = m_cpDictCmdGrammar->LoadCmdFromFile(m_szCmdFile, SPLO_DYNAMIC);
               } 
           }
               
           if (S_OK != hr)
           {
               m_cpDictCmdGrammar.Release();
           }
       } 

       // load shared command grammars

       if (SUCCEEDED(hr) )
       {
           hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_CMDSHARED, &m_cpSharedGrammarInDict);
           TraceMsg(TF_SAPI_PERF, "Create SharedCmdGrammarInDict, hr=%x", hr);
       }    

       if (S_OK == hr)
       {
           hr = S_FALSE;

           if (m_langid == 0x409 ||    // English
               m_langid == 0x411 ||    // Japanese
               m_langid == 0x804 )     // Simplified Chinese
           {
               hr = m_cpSharedGrammarInDict->LoadCmdFromResource(
                                                         g_hInstSpgrmr,
                                                         (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_SHAREDCMD_CFG),
                                                         L"SRGRAMMAR", 
                                                         m_langid, 
                                                         SPLO_DYNAMIC);

               TraceMsg(TF_SAPI_PERF, "Load Shrdcmd.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have built-in grammar
               // it provides a way for customer to localize their grammars in different languages
               _GetCmdFileName(m_langid);
               if (m_szShrdCmdFile[0])
               {
                   hr = m_cpSharedGrammarInDict->LoadCmdFromFile(m_szShrdCmdFile, SPLO_DYNAMIC);
               } 
           }

           if (S_OK != hr)
           {
               m_cpSharedGrammarInDict.Release();
           }
           else if ( PRIMARYLANGID(m_langid) == LANG_ENGLISH  ||
                     PRIMARYLANGID(m_langid) == LANG_JAPANESE ||
                     PRIMARYLANGID(m_langid) == LANG_CHINESE)
           { 
              // means this language's grammar support Textbuffer commands.
              m_fSelectionEnabled = TRUE;   
           }

       } 
       
       //
       //  load mode bias grammars
       //
       if (S_OK == hr)
       {
           hr = m_cpRecoCtxt->CreateGrammar(GRID_INTEGER_STANDALONE, &m_cpNumModeGrammar);
           TraceMsg(TF_SAPI_PERF, "Create NumModeGrammar, hr=%x", hr);
       }
       if (S_OK == hr)
       {
           hr = S_FALSE;

           
           // try resource first because loading cmd from file takes
           // quite long time
           //
           if ( m_langid == 0x409        // English
                || m_langid == 0x411     // Japanese
                || m_langid == 0x804     // Simplified Chinese
              )    
           {
                hr = m_cpNumModeGrammar->LoadCmdFromResource(
                                            g_hInstSpgrmr,
                                            (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_NUMMODE_COMMAND_CFG),
                                            L"SRGRAMMAR", 
                                            m_langid,  
                                            SPLO_DYNAMIC);

                TraceMsg(TF_SAPI_PERF, "Load dictnum.cfg, hr=%x", hr);
           }

           if (S_OK != hr)
           {
               // in case if we don't have buit-in grammar
               //
               if (m_szNumModeCmdFile[0])
               {
                   hr = m_cpNumModeGrammar->LoadCmdFromFile(m_szNumModeCmdFile, SPLO_DYNAMIC);
               }
           }

           if (S_OK != hr)
           {
               m_cpNumModeGrammar.Release();
           }
       }
   }

   // By default, Activate all the grammars and Disable the context for Perfomance.

    if ( SUCCEEDED(hr) )
    {
        hr = m_cpRecoCtxt->SetContextState(SPCS_DISABLED);
        m_fDictCtxtEnabled = FALSE;
    }

    // Activate Dictation and spell.

    if ( SUCCEEDED(hr) )
    {
        hr = _ActiveDictOrSpell(DC_Dictation, TRUE);

        if ( hr == S_OK )
            hr = _ActiveDictOrSpell(DC_Dict_Spell, TRUE);
    }

    // Automatically active all rules in C&C grammars.

    if ( SUCCEEDED(hr) )
    {
        if ( m_pime->_AllDictCmdsDisabled( ) )
        {
           hr = _ActivateCmdInDictMode(FALSE);

           // Still needs to activate spelling grammar if it exists.
           if ( hr == S_OK )
               hr = _ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);

           // Needs to activate "Force Num" grammar in dication strong mode.
           if ( hr == S_OK )
               hr = _ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);

            if ( hr == S_OK )
                hr = _ActiveCategoryCmds(DC_CC_LangBar, m_pime->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);
        }
        else
        {
            if ( m_pime->_AllCmdsEnabled( ) )
                hr = _ActivateCmdInDictMode(TRUE);
            else
            {
                // Some category commands are disabled.
                // active them individually.

                hr = _ActiveCategoryCmds(DC_CC_SelectCorrect, m_pime->_SelectCorrectCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Navigation, m_pime->_NavigationCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Casing, m_pime->_CasingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Editing, m_pime->_EditingCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Keyboard, m_pime->_KeyboardCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_TTS, m_pime->_TTSCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_LangBar, m_pime->_LanguageBarCmdEnabled( ), ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Num_Mode, TRUE, ACTIVE_IN_DICTATION_MODE);

                if ( hr == S_OK )
                    hr = _ActiveCategoryCmds(DC_CC_Spelling, TRUE, ACTIVE_IN_DICTATION_MODE);
            }
        }
    }

    // we don't fail even if C&C grammars are not available

    TraceMsg(TF_SAPI_PERF, "CSpTask::_LoadGrammars is done!!!!");
    return S_OK;
}

WCHAR * CSpTask::_GetCmdFileName(LANGID langid)
{

    if (!m_szCmdFile[0])
    {
        _GetCmdFileName(langid, m_szCmdFile, ARRAYSIZE(m_szCmdFile), IDS_CMD_FILE);
    }

    // load the name of shared commands grammar
    if (!m_szShrdCmdFile[0])
    {
        _GetCmdFileName(langid, m_szShrdCmdFile, ARRAYSIZE(m_szShrdCmdFile), IDS_SHARDCMD_FILE);
    }

    // load the name of optional grammar
    if (!m_szNumModeCmdFile[0])
    {
        _GetCmdFileName(langid, m_szNumModeCmdFile, ARRAYSIZE(m_szNumModeCmdFile), IDS_NUMMODE_CMD_FILE );
    }
    
    return m_szCmdFile;
}

void CSpTask::_GetCmdFileName(LANGID langid, WCHAR *sz, int cch, DWORD dwId)
{
/*
    // now we only have a command file for English/Japanese
    // when cfgs are available, we'll get the name of cmd file
    // and the rule names from resources using findresourceex
    //
    if ((PRIMARYLANGID(langid) == LANG_ENGLISH)
        || (PRIMARYLANGID(langid) == LANG_JAPANESE)
        || (PRIMARYLANGID(langid) == LANG_CHINESE))
    {

// To supply customers a way to localize their grammars in different languages,
// we don't want the above condition check.
*/
        char szFilePath[MAX_PATH];
        char *pszFileName;
        char szCp[MAX_PATH];
        int  ilen;

        if (!GetModuleFileName(g_hInst, szFilePath, ARRAYSIZE(szFilePath)))
            return;
        
        // is this dbcs safe?
        pszFileName = strrchr(szFilePath, (int)'\\');
        
        if (pszFileName)
        {
            pszFileName++;
            *pszFileName = '\0';
        }
        else
        {
            szFilePath[0] = '\\';
            szFilePath[1] = '\0';
            pszFileName = &szFilePath[1];
        }

        ilen = lstrlen(szFilePath);
        
        CicLoadStringA(g_hInst, dwId, pszFileName, ARRAYSIZE(szFilePath)-ilen);
                
        if (GetLocaleInfo(langid, LOCALE_IDEFAULTANSICODEPAGE, szCp, ARRAYSIZE(szCp))>0)
        {
            int iACP = atoi(szCp); 
        
            MultiByteToWideChar(iACP, NULL, szFilePath, -1, sz, cch);
        }
//    }
}

void CSpTask::_ReleaseSAPI(void)
{
    // - release data or memory from recognition context
    // - release interfaces if they are not defined as CComPtr
    _UnloadGrammars();

    m_cpResMgr.Release();

    if ( m_cpVoice)
        m_cpVoice->SetNotifySink(NULL);

    m_cpVoice.Release();

    if (m_cpRecoCtxt)
        m_cpRecoCtxt->SetNotifySink(NULL);

    if ( m_cpRecoCtxtForCmd )
        m_cpRecoCtxtForCmd->SetNotifySink(NULL);

#ifdef RECOSLEEP
    if ( m_pSleepClass )
    {
        delete m_pSleepClass;
        m_pSleepClass = NULL;
    }
#endif

    m_cpRecoCtxt.Release();
    m_cpRecoCtxtForCmd.Release();
    m_cpRecoEngine.Release();
    m_fSapiInitialized  = FALSE;
}

HRESULT CSpTask::_SetAudioRetainStatus(BOOL fRetain)
{
    HRESULT hr = E_FAIL;
    // FutureConsider: support the data format
    if (m_cpRecoCtxt)
        hr = m_cpRecoCtxt->SetAudioOptions(fRetain?SPAO_RETAIN_AUDIO: SPAO_NONE, NULL, NULL);

    if (m_cpRecoCtxtForCmd)
       hr = m_cpRecoCtxtForCmd->SetAudioOptions(fRetain?SPAO_RETAIN_AUDIO: SPAO_NONE, NULL, NULL);
   
    return hr;
}

HRESULT CSpTask::_SetRecognizerInterest(ULONGLONG ulInterest)
{
    HRESULT  hr = S_OK;

    if ( m_cpRecoCtxt )
    {
        hr = m_cpRecoCtxt->SetInterest(ulInterest, ulInterest);
    }

    return hr;
}
//
//
// Activate all the command grammas in Dictation mode. 
//
// By default we want to set SPRS_ACTIVE to all the command grammar rules
// in dictation mode unless user disables some of commands through dictation 
// property page. 
// 
// Please note:  Only when all the commands are enabled, this function is called.
//
// otherwise,
//
// When some of the commands are disabled, we should active individual cateogry commands by
// calling _ActiveCategoryCmds( ).
// 
HRESULT CSpTask::_ActivateCmdInDictMode(BOOL fActive)
{
    HRESULT hr = E_FAIL;
    BOOL    fRealActive = fActive;

    TraceMsg(TF_SAPI_PERF, "CSpTask::_ActivateCmdInDictMode is called, fActive=%d", fActive);

    if (m_cpRecoCtxt)
    { 
        // Automatically active or inactive all rules in grammar.

        // Rules in Dictcmd.cfg

        if ( m_cpDictCmdGrammar )
        {
            hr = m_cpDictCmdGrammar->SetRuleState(c_szDictTBRule,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in DictCmdGrammar, fRealActive=%d", fRealActive);
        }

        // Rules in Sharedcmd.cfg

        if ( m_cpSharedGrammarInDict )
        {
            hr = m_cpSharedGrammarInDict->SetRuleState(NULL,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in SharedCmdGrammar In Dictation Mode, fRealActive=%d", fRealActive);
        }

        // Rules in ITN grammar

        if ( hr == S_OK && m_cpNumModeGrammar )
        {
            hr = m_cpNumModeGrammar->SetRuleState(NULL,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpNumModeGrammar, fRealActive=%d", fRealActive);
        }

        // Rules in Spell grammar

        if ( m_cpSpellingGrammar )
        {
            hr = m_cpSpellingGrammar->SetRuleState(NULL,  NULL, fRealActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpSpellingGrammar, fRealActive=%d", fRealActive);
        }
    }
    
    TraceMsg(TF_SAPI_PERF, "Exit from CSpTask::_ActivateCmdInDictMode");

    return hr;
}

//
// Active commands by category.
//
// Some commands are dictation mode only such as "spell that" and Number mode commands.
// some others are available in both modes, 
//
// When some category commands are disabled, caller must call this function instead of
// _ActivateCmdInDictMode to set individual category commands.
//
HRESULT CSpTask::_ActiveCategoryCmds(DICT_CATCMD_ID  dcId, BOOL fActive, DWORD   dwMode)
{
    HRESULT  hr = S_OK;
    BOOL     fActiveDictMode, fActiveCommandMode;

    if ( dcId >= DC_Max )  return E_INVALIDARG;

    if (m_fIn_Activate)
        return hr;

    fActiveDictMode = (m_cpRecoCtxt && (dwMode & ACTIVE_IN_DICTATION_MODE) ) ? TRUE : FALSE;

    if ( m_cpRecoCtxtForCmd  && m_cpSharedGrammarInVoiceCmd && ( dwMode & ACTIVE_IN_COMMAND_MODE) )
        fActiveCommandMode = TRUE;
    else
        fActiveCommandMode = FALSE;

    m_fIn_Activate = TRUE;

    switch (dcId)
    {
    case DC_CC_SelectCorrect :

        // This category includes below rules in different grammars.
        //
        // shrdcmd.xml:
        //      selword, SelectThrough, SelectSimpleCmds,
        //
        // dictcmd.xml:
        //      commands
        //

        TraceMsg(TF_SAPI_PERF, "DC_CC_SelectCorrect status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode)
        {
            // for dictation mode
            if ( m_cpSharedGrammarInDict )
            {
                hr = m_cpSharedGrammarInDict->SetRuleState(c_szSelword,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

                if ( hr == S_OK )
                    hr = m_cpSharedGrammarInDict->SetRuleState(c_szSelThrough,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

                if ( hr == S_OK )
                    hr = m_cpSharedGrammarInDict->SetRuleState(c_szSelectSimple,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
            }
        }

        if ( (hr == S_OK) && fActiveCommandMode ) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szSelword,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

            if ( hr == S_OK )
                hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szSelThrough,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);

            if ( hr == S_OK )
                hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szSelectSimple,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_Navigation :

        // This category includes rule NavigationCmds in shrdcmd.xml
        // 

        TraceMsg(TF_SAPI_PERF, "DC_CC_Navigation status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict)
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szNavigationCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode ) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szNavigationCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }
        
        break;

    case DC_CC_Casing :

        // This category includes rule CasingCmds in shrdcmd.xml
        TraceMsg(TF_SAPI_PERF, "DC_CC_Casing status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict )
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szCasingCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szCasingCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_Editing :

        // This category includes rule EditCmds in shrdcmd.xml
        TraceMsg(TF_SAPI_PERF, "DC_CC_Editing status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict)
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szEditCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szEditCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_Keyboard :

        // This category includes rule KeyboardCmds in shrdcmd.xml
        TraceMsg(TF_SAPI_PERF, "DC_CC_Keyboard status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpSharedGrammarInDict)
        {
            // for dictation mode
            hr = m_cpSharedGrammarInDict->SetRuleState(c_szKeyboardCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode) 
        {
            // for voice command mode
            hr = m_cpSharedGrammarInVoiceCmd->SetRuleState(c_szKeyboardCmds,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        break;

    case DC_CC_TTS :

        // The rule for this category is not implemented yet!!!

        break;

    case DC_CC_LangBar :

        // This category includes rule ToolbarCmd in dictcmd.xml for dictation mode.
        // for voice command mode, it is a dynamical rule.
        //

        TraceMsg(TF_SAPI_PERF, "DC_CC_LangBar status: %d, mode=%d", fActive, dwMode);

        if ( fActiveDictMode && m_cpDictCmdGrammar)
        {
            // for dictation mode
            hr = m_cpDictCmdGrammar->SetRuleState(c_szDictTBRule,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
        }

        if ( (hr == S_OK) && fActiveCommandMode ) 
        {
            // for voice command mode
            // Change toolbar grammar status if it has already been built.
            if (m_pLangBarSink && m_pLangBarSink->_IsTBGrammarBuiltOut( ))
                m_pLangBarSink->_ActivateGrammar(fActive);
        }

        break;

    case DC_CC_Num_Mode        :
        
        if (fActiveDictMode && m_cpNumModeGrammar)
        {
            hr = m_cpNumModeGrammar->SetRuleState(NULL,  NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "CC Number rule status changed to %d", fActive);
        }
        break;

    case DC_CC_UrlHistory :
        
        if (fActiveDictMode && m_cpDictCmdGrammar)
        {
            hr = m_cpDictCmdGrammar->SetRuleState(c_szStaticUrlHist,  NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);
            if (S_OK == hr)
                hr = m_cpDictCmdGrammar->SetRuleState(c_szDynUrlHist,  NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);
            
            if (S_OK == hr && m_cpUrlSpellingGrammar)
            {
                 hr = m_cpUrlSpellingGrammar->SetRuleState(c_szStaticUrlSpell, NULL, fActive ? SPRS_ACTIVE: SPRS_INACTIVE);

            }
        }
        break;

    case DC_CC_Spelling :

        if ( fActiveDictMode && m_cpSpellingGrammar )
        {
            hr = m_cpSpellingGrammar->SetRuleState(NULL,  NULL, fActive? SPRS_ACTIVE: SPRS_INACTIVE);
            TraceMsg(TF_SAPI_PERF, "Set rules status in m_cpSpellingGrammar, fActive=%d", fActive);
        }
        break;
    }

    m_fIn_Activate = FALSE;

    return hr;
}


// Set the status for Dictation grammar or spelling grammar In Dictation mode only.
HRESULT CSpTask::_ActiveDictOrSpell(DICT_CATCMD_ID  dcId, BOOL fActive)
{
    HRESULT  hr = S_OK;

    if ( dcId >= DC_Max )  return E_INVALIDARG;

    if (m_fIn_Activate)
        return hr;

    m_fIn_Activate = TRUE;

    switch (dcId)
    {
        case DC_Dictation       :   
            if (m_cpDictGrammar) 
            {
                hr = m_cpDictGrammar->SetDictationState(fActive ? SPRS_ACTIVE : SPRS_INACTIVE);
                TraceMsg(TF_SAPI_PERF, "Dictation status changed to %d", fActive);
            }
            break;
        case DC_Dict_Spell      :
            if (m_cpSpellingGrammar)
            {
                hr = _SetSpellingGrammarStatus(fActive);
                TraceMsg(TF_SAPI_PERF, "Dict Spell status changed to %d", fActive);
            }
            break;
    }

    m_fIn_Activate = FALSE;

    return hr;
}

HRESULT CSpTask::_SetSpellingGrammarStatus( BOOL fActive, BOOL fForce)
{
    HRESULT  hr = S_OK;

    TraceMsg(TF_GENERAL, "_SetSpellingGrammarStatus is called, fActive=%d, m_fSelectStatus=%d",fActive, m_fSelectStatus);

 
    if ( m_cpSpellingGrammar )
    {
        // if dictation is previously deactivated because of 'force' spelling
        // we need to reactivate the dictation grammar
        if (m_fDictationDeactivated)
        {
             hr = _ActiveDictOrSpell(DC_Dictation, TRUE);
             if (S_OK == hr)
             {
                 m_fDictationDeactivated =  FALSE;
             }
         }

        //  if this is 'force' mode, we deactivate dictation for the moment
        if (fForce)
        {
            hr = _ActiveDictOrSpell(DC_Dictation, FALSE);
            if (S_OK == hr)
            {
               m_fDictationDeactivated =  TRUE;
            }
        }

        if ( (m_fSelectStatus || fForce) && fActive) // It is not empty 
            hr = m_cpSpellingGrammar->SetDictationState(SPRS_ACTIVE);
        else
            hr = m_cpSpellingGrammar->SetDictationState(SPRS_INACTIVE);
        
    }

    return hr;
}

HRESULT CSpTask::_AddUrlPartsToGrammar(STATURL *pStat)
{
    Assert(pStat);

    // get a url broken down to pieces
    if (!pStat->pwcsUrl)
        return S_FALSE;

    WCHAR *pch = pStat->pwcsUrl;
    
    const WCHAR c_szHttpSlash2[] = L"http://";

    // skip the prefixed http: stuff because we've already added it by now
    if (_wcsnicmp(pch, c_szHttpSlash2, ARRAYSIZE(c_szHttpSlash2)-1) == 0)
        pch += ARRAYSIZE(c_szHttpSlash2)-1;

    WCHAR *pchWord = pch;
    HRESULT hr = S_OK;

    // an assumption 1) people speak the first portion of URL www.microsoft.com 
    // as a sentence

    WCHAR *pchUrl = pch;      // points either biggining of url or 
                              // right after 'http://' add the first part 
    BOOL  fUrlAdded = FALSE;  // of url that is between after this and '/'

    while(S_OK == hr && *pch)
    {
        if (*pch == L'/')
        {
            if (!fUrlAdded)
            {
                if( pch - pchUrl > 1)
                {
                    WCHAR ch = *pch;
                    *pch = L'\0'; 

                    SPPROPERTYINFO pi = {0};
                    pi.pszValue = pchUrl;
                    hr = m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchUrl, L".", SPWT_LEXICAL, (float)1, &pi);
                    *pch = ch;
                }
                fUrlAdded = TRUE;
            }
            else
            {
                *pch = L'\0'; 

                break;
            }
        }

        if (*pch == L'.' || *pch == L'/' || *pch == L'?' || *pch == '=' || *pch =='&')
        {
            WCHAR ch = *pch;

            *pch = L'\0';

            // reject 1 character parts
            if (pch - pchWord > 1)
            {
                SPPROPERTYINFO pi = {0};
                pi.pszValue = pchWord; 

                if (wcscmp(c_szWWW, pchWord) != 0 && wcscmp(c_szCom, pchWord) != 0)
                {
                    // a few words can possibly return 'ambiguity' errors
                    // we need to ignore it and continue. so we're not checking
                    // the return here.
                    //
                    m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchWord, L" ", SPWT_LEXICAL, (float)1, &pi);
                }
            }
            *pch = ch;

            pchWord = pch + 1;
        }
        pch++;
    }

    // add the last part of URL
    if (S_OK == hr && *pchWord && pch - pchWord > 1)
    {
        SPPROPERTYINFO pi = {0};
        pi.pszValue = pchWord; 
        hr = m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchWord, L" ", SPWT_LEXICAL, (float)1, &pi);
    }
    // add the first part of url if we haven't yet
    if (S_OK == hr && !fUrlAdded && pch - pchUrl > 1)
    {
       SPPROPERTYINFO pi = {0};
       pi.pszValue = pchUrl;
       hr = m_cpDictCmdGrammar->AddWordTransition(m_hRuleUrlHist, NULL, pchUrl, L".", SPWT_LEXICAL, (float)1, &pi);
    }

    return hr;
}

BOOL CSpTask::_EnsureModeBiasGrammar()
{
    HRESULT hr = S_OK;

    if ( m_cpDictCmdGrammar )
    {
        // Check if the grammar has a static rule UrlSpelling
        SPSTATEHANDLE hRuleUrlSpell = 0;
        hr = m_cpDictCmdGrammar->GetRule(c_szStaticUrlSpell, 0, SPRAF_TopLevel|SPRAF_Active, FALSE, &hRuleUrlSpell);

        if ( !hRuleUrlSpell )
            return FALSE;
    }

    // ensure spelling LM
    if (!m_cpUrlSpellingGrammar)
    {
        CComPtr<ISpRecoGrammar> cpUrlSpelling;
        hr = m_cpRecoCtxt->CreateGrammar(GRAM_ID_URLSPELL, &cpUrlSpelling);

        // load dictation with spelling topic
        if (S_OK == hr)
        {
            hr = cpUrlSpelling->LoadDictation(SPTOPIC_SPELLING, SPLO_STATIC);
        }

        // load the 'rule' for the free form dictation
        if (S_OK == hr)
        {
            // i'm sharing the command cfg here for spelling with dictation
            // command for simplicity
            //
            hr = cpUrlSpelling->LoadCmdFromResource( g_hInstSpgrmr,
                                    (const WCHAR*)MAKEINTRESOURCE(ID_SPTIP_DICTATION_COMMAND_CFG),
                                    L"SRGRAMMAR", 
                                    m_langid, 
                                    SPLO_STATIC);
        }

        if (S_OK == hr)
        {
            m_cpUrlSpellingGrammar = cpUrlSpelling; // add the ref count
        }
    }

    if (m_hRuleUrlHist)
    {
        hr = m_cpDictCmdGrammar->ClearRule(m_hRuleUrlHist);
        m_hRuleUrlHist = 0;
    }

    if (S_OK == hr)
        hr = m_cpDictCmdGrammar->GetRule(c_szDynUrlHist, 0, SPRAF_TopLevel|SPRAF_Active|SPRAF_Dynamic, TRUE, &m_hRuleUrlHist);
    

    // first add basic parts for URL
    CComPtr<IUrlHistoryStg> cpUrlHistStg;
    if (S_OK == hr)
    {   
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUrlHistoryStg, (void **)&cpUrlHistStg);
    }

    CComPtr<IEnumSTATURL> cpEnumUrl;
    if (S_OK == hr)
    {
        hr = cpUrlHistStg->EnumUrls(&cpEnumUrl);
    }

    if (S_OK == hr)
    {
        int i = 0;
        STATURL stat;
        stat.cbSize = SIZEOF(stat.cbSize);
        while(i < 10 && S_OK == hr && cpEnumUrl->Next(1, &stat, NULL)==S_OK && stat.pwcsUrl)
        { 
            hr = _AddUrlPartsToGrammar(&stat);
            i++;
        }
    }

    if (S_OK == hr)
    {   
        hr = m_cpDictCmdGrammar->Commit(0);
    }

    return (S_OK == hr) ? TRUE : FALSE;
}

HRESULT CSpTask::_SetModeBias(BOOL fActive, REFGUID rGuid)
{
    HRESULT hr = S_OK;
    BOOL    fKillDictation = FALSE;

    if (m_fIn_SetModeBias)
        return E_FAIL;

    m_fIn_SetModeBias = TRUE;
    if (m_cpDictGrammar)
    {
        fKillDictation = !m_pime->_IsModeBiasDictationEnabled();
        if (fActive)
        {
            BOOL fUrlHistory = FALSE;

            if (IsEqualGUID(GUID_MODEBIAS_URLHISTORY, rGuid)
                || IsEqualGUID(GUID_MODEBIAS_FILENAME, rGuid))
                fUrlHistory = TRUE;


            // first deactivate rules when we are not setting them
            if (!fUrlHistory && m_fUrlHistoryMode)
            {
                hr = _ActiveCategoryCmds(DC_CC_UrlHistory, FALSE, ACTIVE_IN_DICTATION_MODE);
            }

            // this check with m_fUrlHistoryMode is preventing us from updating url dynamic grammar
            // when mic is re-opened. we think removing this won't cause much perf degredation.
            //
            if (fUrlHistory /* && !m_fUrlHistoryMode */)
            {
                if (m_cpDictCmdGrammar && m_pime->GetDICTATIONSTAT_DictOnOff() && _EnsureModeBiasGrammar())
                {
                    hr = _ActiveCategoryCmds(DC_CC_UrlHistory, TRUE, ACTIVE_IN_DICTATION_MODE);                    
                }
                else
                    fUrlHistory = FALSE;

                if (fUrlHistory)
                {
                    fKillDictation = TRUE;
                }
            }

            // sync the global status
            m_fUrlHistoryMode = fUrlHistory;
        }
        else
        {
            // reset all modebias
            if (m_fUrlHistoryMode)
                _ActiveCategoryCmds(DC_CC_UrlHistory, FALSE, ACTIVE_IN_DICTATION_MODE);
        }
    

        // kill dictation grammar when mode requires it
        // we should activate dictation only when deactivating
        // the modebias grammar *and* when we are the focus
        // thread because we've already deactivated dictation
        // when focus switched away
        //
        if (/* !fActive && */
            m_cpDictGrammar && 
            m_pime->GetDICTATIONSTAT_DictOnOff() && 
            S_OK == m_pime->IsActiveThread())
        {
#ifdef _DEBUG_
            TCHAR szModule[MAX_PATH];
            GetModuleFileName(NULL, szModule, ARRAYSIZE(szModule));

            TraceMsg(TF_GENERAL, "%s : CSpTask::_SetModeBias() - Turning Dictation grammar %s", szModule, fKillDictation ? "Off" : "On");
#endif
            if (!fActive && fKillDictation)
            {
                fKillDictation = FALSE;
            } 

            hr = _ActiveDictOrSpell(DC_Dictation, fKillDictation ? SPRS_INACTIVE : SPRS_ACTIVE);
        }
    }    
    m_fIn_SetModeBias = FALSE;
    return hr;
}

void CSpTask::_SetInputOnOffState(BOOL fOn)
{
    TraceMsg(TF_GENERAL, "_SetInputOnOffState is called, fOn=%d", fOn);

    if (m_fIn_SetInputOnOffState)
        return;

    m_fIn_SetInputOnOffState = TRUE;

    // here we make sure we erase feedback UI 

    // We only adjust these if we are the active thread. Otherwise leave in current state since we either do
    // not have focus or the stage is visible. This maintains our previous behavior where we would not get here
    // if we were not the active thread.
    if (S_OK == m_pime->IsActiveThread())
    {
        if (fOn)
        {
            if (!m_pime->Get_SPEECH_DISABLED_DictationDisabled() && m_pime->GetDICTATIONSTAT_DictOnOff())
                _SetDictRecoCtxtState(TRUE);

            if ( !m_pime->Get_SPEECH_DISABLED_CommandingDisabled( ) && m_pime->GetDICTATIONSTAT_CommandingOnOff( ) )
                _SetCmdRecoCtxtState(TRUE);
        }
        else
        {
            _SetDictRecoCtxtState(FALSE);
            _SetCmdRecoCtxtState(FALSE);
            _StopInput();
        }
    }

    // Regardless of focus / stage visibility, we need to turn on the engine if necessary here since there
    // may be *no* speech tip with focus to do this. This means we may have multiple tips turning the reco
    // state on / off simultaneously.
    if(m_cpRecoEngine)
    {
        m_fInputState = fOn;

        if ( _GetInputOnOffState( ) != fOn )
        {
            TraceMsg(TF_GENERAL, "Call SetRecoState, %s", fOn ? "SPRST_ACTIVE" : "SPRST_INACTIVE");

            m_cpRecoEngine->SetRecoState(fOn ? SPRST_ACTIVE : SPRST_INACTIVE);
        }

        // DO NOT ADD DEBUGGING CODE HERE TO PRINT OUT STATE - CAN BLOCK CICERO RESULTING
        // IN DIFFERENT BEHAVIOR TO THE RELEASE VERSION.
    }

    m_fIn_SetInputOnOffState = FALSE;
}

BOOL CSpTask::_GetInputOnOffState(void)
{
    BOOL fRet = FALSE;

    if(m_cpRecoEngine)
    {
        SPRECOSTATE srs;
        
        m_cpRecoEngine->GetRecoState(&srs);

        if (srs == SPRST_ACTIVE)
        {
            fRet = TRUE;  // on
        }
        else if (srs == SPRST_INACTIVE)
        {
            fRet = FALSE;  // off
        }
        // anything else is 'off'
    }
    return fRet;
}

HRESULT CSpTask::_StopInput(void)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_SAPI_PERF, "_StopInput is called");

    if (!m_bInSound && m_pime->GetDICTATIONSTAT_DictOnOff()) 
    {
        TraceMsg(TF_SAPI_PERF, "m_bInSound is FALSE, GetDICTATIONSTAT_DictOnOff returns TRUE");

        return S_OK;
    }

    m_pime->EraseFeedbackUI();

    _ShowDictatingToBalloon(FALSE);

	return S_OK;
}

//    _ClearQueuedRecoEvent(void)
//
//    synopsis: get rid of remaining events from reco context's 
//              event queue. This is only called from _StopInput()
//              when TerminateComposition() is called, or Mic is
//              turned off
//
//
void  CSpTask::_ClearQueuedRecoEvent(void)
{
    if (m_cpRecoCtxt)
    {
        SPEVENTSOURCEINFO esi;

        if (S_OK == m_cpRecoCtxt->GetInfo(&esi))
        {
            ULONG ulcount = esi.ulCount;
            CSpEvent event;
            while(ulcount > 0)
            {
                if (S_OK == event.GetFrom(m_cpRecoCtxt))
                {
                    event.Clear();
                }
                ulcount--;
            }
        }
    }
}

// CSpTask::GetResltObjectFromStream()
//
// synopsis - a wrapper function that takes a stream ptr to a SAPI result blob
//            and gets alternates out of the object
//
HRESULT CSpTask::GetResultObjectFromStream(IStream *pStream, ISpRecoResult **ppResult)
{
    LARGE_INTEGER li0 = {0, 0};
    HRESULT hr = E_INVALIDARG;
    SPSERIALIZEDRESULT *pPhraseBlob = 0;
    
    if (pStream)
    {
        hr = pStream->Seek(li0, STREAM_SEEK_SET, NULL);

        STATSTG stg;
        if (hr == S_OK)
        {
            hr = pStream->Stat(&stg, STATFLAG_NONAME);
        }
        if (SUCCEEDED(hr))
            pPhraseBlob = (SPSERIALIZEDRESULT *)CoTaskMemAlloc(stg.cbSize.LowPart+sizeof(ULONG)*4);

        if (pPhraseBlob)
            hr = pStream->Read(pPhraseBlob, stg.cbSize.LowPart, NULL);
        else
            hr = E_OUTOFMEMORY;

        if (SUCCEEDED(hr))
        {
            ISpRecoResult *pResult;

            if (SUCCEEDED(m_cpRecoCtxt->DeserializeResult(pPhraseBlob, &pResult)) && pResult)
            {
                if (ppResult)
                {
                    pResult->AddRef();
                    *ppResult = pResult;
                }
                pResult->Release();
            }
        }
    }
    
    return hr;
}

//
// GetAlternates
//
HRESULT CSpTask::GetAlternates(CRecoResultWrap *pResultWrap, ULONG ulStartElem, ULONG ulcElem, ISpPhraseAlt **ppAlt, ULONG *pcAlt, ISpRecoResult **ppRecoResult)
{
    HRESULT hr = E_INVALIDARG;

    if (m_fIn_GetAlternates)
        return E_FAIL;
    
    m_fIn_GetAlternates = TRUE;

    Assert(pResultWrap);
    Assert(ppAlt);
    Assert(pcAlt);
    
    hr = pResultWrap->GetResult(ppRecoResult);
    
    if (S_OK == hr && *ppRecoResult)
    {
    
        hr = (*ppRecoResult)->GetAlternates(
                    ulStartElem, 
                    ulcElem, 
                    *pcAlt, 
                    ppAlt, /* [out] ISpPhraseAlt **ppPhrases, */
                    pcAlt /* [out] ULONG *pcPhrasesReturned */
                    );
    }
    
    m_fIn_GetAlternates = FALSE;
    return hr;
}


HRESULT CSpTask::_SpeakText(WCHAR *pwsz)
{
    HRESULT hr = E_FAIL;

    if (m_cpVoice)
       hr = m_cpVoice->Speak( pwsz, /* SPF_DEFAULT */ SPF_ASYNC /* | SPF_PURGEBEFORESPEAK*/, NULL );

    return hr;
}

HRESULT CSpTask::_SpeakAudio( ISpStreamFormat *pStream )
{
    HRESULT hr = E_FAIL;

    if ( !pStream )
       return E_INVALIDARG;

    if (m_cpVoice)
       hr = m_cpVoice->SpeakStream(pStream, SPF_ASYNC, NULL); 

    return hr;
}

void CSapiIMX::RegisterWorkerClass(HINSTANCE hInstance)
{
    WNDCLASSEX  wndclass;

    memset(&wndclass, 0, sizeof(wndclass));
    wndclass.cbSize        = sizeof(wndclass);
    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.hInstance     = hInstance;
    wndclass.lpfnWndProc   = CSapiIMX::_WndProc;
    wndclass.lpszClassName = c_szWorkerWndClass;
    wndclass.cbWndExtra    = 8;
    RegisterClassEx(&wndclass);
}

//
// ParseSRElementByLocale
//
// Parse SR result elements in locale specific mannar
//
// dependency caution: this function has to be rewritten when SAPI5 changes
//                     SR element format, which is very likely
//
// 12/15/99          : As of SAPI1214, an element now includes display text,
//                     lexical form, pronunciation separately. this function
//                     takes the display text at szSrc.
//                     langid parameter is not used at this moment
//
HRESULT CSpTask::ParseSRElementByLocale(WCHAR *szDst, int cchDst, const WCHAR * szSrc, LANGID langid, BYTE bAttr)
{
    if (!szDst || !szSrc || !cchDst)
    {
        return E_INVALIDARG;
    }

    // handle leading space.
    if (bAttr & SPAF_CONSUME_LEADING_SPACES)
    {
        const WCHAR *psz = szSrc;
        while(*psz && *psz == L' ')
        {
            psz++;
        }
        szSrc = psz;
    }
    
    wcsncpy(szDst, szSrc, cchDst - 2); // -2 for possible sp

    // handle trailing space
    if (bAttr & SPAF_ONE_TRAILING_SPACE)
    {
        StringCchCatW(szDst, cchDst,  L" ");
    }
    else if (bAttr & SPAF_TWO_TRAILING_SPACES)
    {
        StringCchCatW(szDst,cchDst, L"  ");
    }

    return S_OK;
}


//
// FeedDictContext
//
// synopsis: feed the text surrounding the current IP to SR engine
//
void CSpTask::FeedDictContext(CDictContext *pdc)
{
    Assert(pdc);
    if (!m_pime->_GetWorkerWnd())
    {
        delete pdc;
        return ;
    }
    
    // wait until the current feeding is done
    // it's not efficient to feed IP everytime user
    // click around
    if (m_pdc)
    {
        delete pdc;
        return;
    }

    if (!m_cpDictGrammar)
    {
        delete pdc;
        return;
    }

    // remove unprocessed messages from the queue
    // FutureConsider: this could be moved to wndproc so that
    //         we can remove this private msg at the
    //         moment we process it. It depends on 
    //         profiling we'll do.
    //
    MSG msg;
    while(PeekMessage(&msg, m_pime->_GetWorkerWnd(), WM_PRIV_FEEDCONTEXT, WM_PRIV_FEEDCONTEXT, TRUE))
        ;
   
   // queue up the context
   m_pdc = pdc;
   PostMessage(m_pime->_GetWorkerWnd(), WM_PRIV_FEEDCONTEXT, 0, (LPARAM)TRUE);
}

void CSpTask::CleanupDictContext(void)
{
    if (m_pdc)
        delete m_pdc;

    m_pdc = NULL;
}

// _UpdateBalloon(  )

void CSpTask::_UpdateBalloon(ULONG  uidBalloon,  ULONG  uidBalloonTooltip)
{
    WCHAR wszBalloonText[MAX_PATH] = {0};
    WCHAR wszBalloonTooltip[MAX_PATH] = {0};

#ifndef RECOSLEEP
    if (!m_pime->GetSpeechUIServer())
#else
    if (!m_pime->GetSpeechUIServer() || IsInSleep( ))
#endif
        return;

    CicLoadStringWrapW(g_hInst, uidBalloon, wszBalloonText, ARRAYSIZE(wszBalloonText));
    CicLoadStringWrapW(g_hInst, uidBalloonTooltip, wszBalloonTooltip, ARRAYSIZE(wszBalloonTooltip));

    if (wszBalloonText[0] && wszBalloonTooltip[0])
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, 
                                                             wszBalloonText, -1, 
                                                             wszBalloonTooltip, -1 );
    }

    return;
}

//
// ShowDictatingToBalloon
//
//
void CSpTask::_ShowDictatingToBalloon(BOOL fShow)
{
#ifndef RECOSLEEP
    if (!m_pime->GetSpeechUIServer())
#else
    if (!m_pime->GetSpeechUIServer() || IsInSleep( ))
#endif
        return;

    static WCHAR s_szDictating[MAX_PATH] = {0};
    static WCHAR s_szDictatingTooltip[MAX_PATH] = {0};

    if (!s_szDictating[0])
    {
        CicLoadStringWrapW(g_hInst, IDS_DICTATING,
                                    s_szDictating,
                                    ARRAYSIZE(s_szDictating));
    }
    if (!s_szDictatingTooltip[0])
    {
         CicLoadStringWrapW(g_hInst,  IDS_DICTATING_TOOLTIP,
                                      s_szDictatingTooltip,
                                      ARRAYSIZE(s_szDictatingTooltip));
    }

    if (fShow && s_szDictating[0] && s_szDictatingTooltip[0])
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, s_szDictating, -1, s_szDictatingTooltip, -1 );
    }
    else if (!fShow)
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, L" ", -1, L" ", -1 );
    }
}
//
// _HandleInterference
//
// synopsis: bubble up reco errors to the balloon UI
//
//
void CSpTask::_HandleInterference(ULONG lParam)
{
    if (!m_pime->GetSpeechUIServer())
        return;

    WCHAR sz[MAX_PATH];
    WCHAR szTooltip[MAX_PATH];
    
    if (S_OK == 
       _GetLocSRErrorString((SPINTERFERENCE)lParam, 
                            sz, ARRAYSIZE(sz),
                            szTooltip, ARRAYSIZE(szTooltip)))
    {
        m_pime->GetSpeechUIServer()->UpdateBalloonAndTooltip(TF_LB_BALLOON_RECO, sz, -1, szTooltip, -1 );
    }
}

HRESULT CSpTask::_GetLocSRErrorString
(
    SPINTERFERENCE sif, 
    WCHAR *psz, ULONG cch,
    WCHAR *pszTooltip, ULONG cchTooltip
)
{
    HRESULT hr = E_FAIL;

    static struct
    {
        ULONG uidRes;
        WCHAR szErr[MAX_PATH];
        ULONG uidResTooltip;
        WCHAR szTooltip[MAX_PATH];
    } rgIntStr[] =
    {
        {IDS_INT_NONE, {0}, IDS_INTTOOLTIP_NONE, {0}},
        {IDS_INT_NOISE, {0}, IDS_INTTOOLTIP_NOISE, {0}},
        {IDS_INT_NOSIGNAL, {0}, IDS_INTTOOLTIP_NOSIGNAL, {0}},
        {IDS_INT_TOOLOUD, {0}, IDS_INTTOOLTIP_TOOLOUD, {0}},
        {IDS_INT_TOOQUIET, {0}, IDS_INTTOOLTIP_TOOQUIET, {0}},
        {IDS_INT_TOOFAST, {0}, IDS_INTTOOLTIP_TOOFAST, {0}},
        {IDS_INT_TOOSLOW, {0}, IDS_INTTOOLTIP_TOOSLOW, {0}}
    };
    
    if ((ULONG)sif < ARRAYSIZE(rgIntStr)-1)
    {
        if (!rgIntStr[sif].szErr[0])
        {
            hr = CicLoadStringWrapW(g_hInst,
                                    rgIntStr[sif].uidRes,
                                    rgIntStr[sif].szErr,
                                    ARRAYSIZE(rgIntStr[0].szErr)) > 0 ? S_OK : E_FAIL;
            if (S_OK == hr)
            {
                hr = CicLoadStringWrapW(g_hInst,
                                        rgIntStr[sif].uidResTooltip,
                                        rgIntStr[sif].szTooltip,
                                        ARRAYSIZE(rgIntStr[0].szTooltip)) > 0 ? S_OK : E_FAIL;
            }
        }
        else
            hr = S_OK; // the value is cached
    }
    if (S_OK == hr)
    {
        Assert(psz);
        wcsncpy(psz, rgIntStr[sif].szErr, cch);

        Assert(pszTooltip);
        wcsncpy(pszTooltip, rgIntStr[sif].szTooltip, cchTooltip);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\sysbtn.cpp ===
//
// sysbtn.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "sapilayr.h"
#include "xstring.h"
#include "sysbtn.h"
#include "nui.h"

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemSystemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
    }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = SAFECAST(this, ITfSource *);
    }
    else if (IsEqualIID(riid, IID_ITfSystemLangBarItem))
    {
        *ppvObj = SAFECAST(this, ITfSystemLangBarItem *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::AddRef()
{
    return CLBarItemButtonBase::AddRef();
}

STDAPI_(ULONG) CLBarItemSystemButtonBase::Release()
{
    return CLBarItemButtonBase::Release();
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::CLBarItemSystemButtonBase()
{
}

//----------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLBarItemSystemButtonBase::~CLBarItemSystemButtonBase()
{
    if (_pMenuMap)
        delete _pMenuMap;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr;

    hr = CLBarItemButtonBase::AdviseSink(riid, punk, pdwCookie);
    if( S_OK != hr)
    {

        const IID *rgiid = &IID_ITfSystemLangBarItemSink;
        hr = GenericAdviseSink(riid, punk, &rgiid, &_rgEventSinks, 1, pdwCookie);
        if (hr == S_OK)
        {
            // adjust the cookie so we don't overlap with idle detector sinks
            *pdwCookie = GenericChainToCookie(*pdwCookie, 1);
        }
    }

    

    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::UnadviseSink(DWORD dwCookie)
{
    HRESULT hr =  CLBarItemButtonBase::UnadviseSink(dwCookie);
    if (hr == S_OK)
       return hr;

    dwCookie = GenericUnchainToCookie(dwCookie, 1);
    return GenericUnadviseSink(&_rgEventSinks, 1, dwCookie);
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    return CLBarItemButtonBase::GetInfo(pInfo);
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::Show(BOOL fShow)
{
    return CLBarItemButtonBase::Show(fShow);
}

//----------------------------------------------------------------------------
//
// SetIcon
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetIcon(HICON hIcon)
{
    CLBarItemButtonBase::SetIcon(hIcon);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// SetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLBarItemSystemButtonBase::SetTooltipString(WCHAR *pchToolTip, ULONG cch)
{
    SetToolTip(pchToolTip);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InsertCustomMenus
//
//----------------------------------------------------------------------------

BOOL CLBarItemSystemButtonBase::_InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID)
{
    int nCntEventSink;
    int i;
    BOOL bRet = FALSE;

    //
    // Insert Custom item to menu
    //
    ClearMenuMap();

    nCntEventSink = _rgEventSinks.Count();
    for (i = 0; i < nCntEventSink; i++)
    {
         CCicLibMenu *pMenuTmp;
         GENERICSINK *pSink;
         ITfSystemLangBarItemSink *plbSink;

         
         if (!_pMenuMap)
             _pMenuMap = new CStructArray<TIPMENUITEMMAP>;

         if (!_pMenuMap)
         {
             Assert(0);
             goto Exit;
         }


         pMenuTmp = new CCicLibMenu;
         if (!pMenuTmp)
         {
             goto Exit;
         }

         pSink = _rgEventSinks.GetPtr(i);

         if (SUCCEEDED(pSink->pSink->QueryInterface(
                                      IID_ITfSystemLangBarItemSink,
                                      (void **)&plbSink)))
         {
             if (SUCCEEDED(plbSink->InitMenu(pMenuTmp)))
             {
                 if (*pnTipCurMenuID > IDM_CUSTOM_MENU_START)
                     LangBarInsertSeparator(pMenu);

                 *pnTipCurMenuID = _MergeMenu(pMenu, 
                                            pMenuTmp, 
                                            plbSink, 
                                            _pMenuMap, 
                                            *pnTipCurMenuID);
             }
             plbSink->Release();
         }
         else
         {
             Assert(0);
         }

         pMenuTmp->Release();
    }

    bRet = TRUE;
Exit:
    return bRet;
}

//+---------------------------------------------------------------------------
//
// _MergeMenu
//
//----------------------------------------------------------------------------
#define MIIM_ALL  ( MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_STRING | MIIM_BITMAP | MIIM_FTYPE )

UINT CLBarItemSystemButtonBase::_MergeMenu(ITfMenu *pMenu, 
                                     CCicLibMenu *pMenuTip, 
                                     ITfSystemLangBarItemSink *plbSink, 
                                     CStructArray<TIPMENUITEMMAP> *pMenuMap, 
                                     UINT &nCurID)
{
    int i;
    int nMenuCnt = pMenuTip->GetItemCount();

    if (nMenuCnt <= 0)
        return nCurID;

    for (i = 0; i < nMenuCnt; i++)
    {
        CCicLibMenuItem *pItem = pMenuTip->GetItem(i);
        TIPMENUITEMMAP *ptmm;
        int nCnt;

        nCnt = pMenuMap->Count();
        if (!pMenuMap->Insert(nCnt, 1))
            return nCurID;

        ptmm = pMenuMap->GetPtr(nCnt);
        ptmm->plbSink = plbSink;
        ptmm->nOrgID = pItem->GetId();
        ptmm->nTmpID = nCurID++;

        if (pItem->GetSubMenu())
        {
            ITfMenu *pSubMenu = NULL;
            if (SUCCEEDED(pMenu->AddMenuItem((UINT)-1,
                                             pItem->GetFlags(),
                                             pItem->GetBitmap(),
                                             pItem->GetBitmapMask(),
                                             pItem->GetText(),
                                             wcslen(pItem->GetText()),
                                             &pSubMenu)))
            {
                _MergeMenu(pSubMenu, 
                           pItem->GetSubMenu(), 
                           plbSink, 
                           pMenuMap, 
                           nCurID);

                pSubMenu->Release();
            }
        }
        else
        {
            pMenu->AddMenuItem(ptmm->nTmpID,
                               pItem->GetFlags(),
                               pItem->GetBitmap(),
                               pItem->GetBitmapMask(),
                               pItem->GetText(),
                               wcslen(pItem->GetText()),
                               NULL);
        }
    }

    return nCurID;
}

STDAPI CLBarItemSystemButtonBase::OnMenuSelect(UINT wID)
{
   HRESULT hr = S_OK;
   int nMenuMapoCnt = _pMenuMap->Count();
   for (int i = 0; i < nMenuMapoCnt; i++)
   {
       TIPMENUITEMMAP *ptmm;
       ptmm = _pMenuMap->GetPtr(i);
       if (ptmm->nTmpID == (UINT)wID)
       {
           hr = ptmm->plbSink->OnMenuSelect(ptmm->nOrgID);
           break;
       }
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\tts.h ===
#ifndef _TTS_H
#define _TTS_H

#include "sapilayr.h"
#include "kes.h"

class CSapiIMX;
class CSpTask;

class __declspec(novtable) CTextToSpeech
{
public:
    CTextToSpeech(CSapiIMX *psi);
    virtual ~CTextToSpeech( );

    HRESULT  TtsPlay( );
    HRESULT  TtsStop( );
    HRESULT  TtsPause( );
    HRESULT  TtsResume( );

    HRESULT  _TtsPlay(TfEditCookie ec,ITfContext *pic);
    HRESULT  _SetTTSButtonStatus(ITfContext  *pic);
    BOOL     _IsPureCiceroIC(ITfContext  *pic);

    HRESULT  _HandleEventOnPlayButton( );
    HRESULT  _HandleEventOnPauseButton( );

    BOOL     _IsInPlay( ) { return m_fIsInPlay; }
    BOOL     _IsInPause( ) { return m_fIsInPause; }
    void     _SetPlayMode(BOOL  fIsInPlay )
    { 
        m_fIsInPlay = fIsInPlay; 
        // Temporally enable or disable dictation if dictation is ON

        // if it Is In Play, Disable Dictation.
        // if it Is Not In Play, Enable Dicatation.
        _SetDictation(!fIsInPlay);
    };

    void     _SetPauseMode(BOOL fIsInPause )  
    { 
        m_fIsInPause = fIsInPause;
        // Temporally enable or disable dictation if dictation is ON
        //
        // if it is In pause, Enable dictation.
        // if it is not In pause, Disable Dication.
        _SetDictation(fIsInPause);
    };

private:

    void     _SetDictation( BOOL fEnable );

    CSapiIMX               *m_psi;
    CComPtr<ITfFnPlayBack>  m_cpPlayBack;
    BOOL                    m_fPlaybackInitialized;
    BOOL                    m_fIsInPlay;
    BOOL                    m_fIsInPause;
};

#endif  // _TTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\sysbtn.h ===
//
// sysbtn.h
//

#ifndef SYSBTN_H
#define SYSBTN_H

#include "private.h"
#include "nuibase.h"
#include "lbmenu.h"
#include "ids.h"
#include "cicspres.h"


typedef struct tag_TIPMENUITEMMAP {
    ITfSystemLangBarItemSink *plbSink;
    UINT nOrgID;
    UINT nTmpID;
} TIPMENUITEMMAP;

class __declspec(novtable)  
CLBarItemSystemButtonBase : public CLBarItemButtonBase,
                            public ITfSystemLangBarItem
{
public:
    CLBarItemSystemButtonBase();
    ~CLBarItemSystemButtonBase();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

    //
    // ITfLangBarItem
    //
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP Show(BOOL fShow);

    //
    // ITfSystemLangBarItem
    //
    STDMETHODIMP SetIcon(HICON hIcon);
    STDMETHODIMP SetTooltipString(WCHAR *pchToolTip, ULONG cch);

    //
    STDMETHODIMP OnMenuSelect(UINT wID);

protected:
    BOOL _InsertCustomMenus(ITfMenu *pMenu, UINT *pnTipCurMenuID);
    UINT _MergeMenu(ITfMenu *pMenu, CCicLibMenu *pMenuTip, ITfSystemLangBarItemSink *plbSink, CStructArray<TIPMENUITEMMAP> *pMenuMap, UINT &nCurID);

    CStructArray<TIPMENUITEMMAP> *_pMenuMap;
    void ClearMenuMap()
    {
        if (_pMenuMap)
            _pMenuMap->Clear();
    }


    CStructArray<GENERICSINK> _rgEventSinks; // ITfSystemLangBarItemSink
};

#endif SYSBTN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\dllmain.cpp ===
//
// dllmain.cpp
//
// DllMain module entry point.
//

#include "globals.h"
#include "snoop.h"

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            g_hInst = hInstance;

            InitializeCriticalSection(&g_cs);

            CSnoopWnd::_InitClass();

            break;

        case DLL_PROCESS_DETACH:

            CSnoopWnd::_UninitClass();

            DeleteCriticalSection(&g_cs);

            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\case.cpp ===
//
// case.cpp
//
// IUnknown, ITfTextInputProcessor implementation.
//

#include "globals.h"
#include "case.h"

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
HRESULT CCaseTextService::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CCaseTextService *pCase;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if ((pCase = new CCaseTextService) == NULL)
        return E_OUTOFMEMORY;

    hr = pCase->QueryInterface(riid, ppvObj);

    pCase->Release(); // caller still holds ref if hr == S_OK

    return hr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCaseTextService::CCaseTextService()
{
    DllAddRef();

    _pThreadMgr = NULL;
    _tfClientId = TF_CLIENTID_NULL;

    _fShowSnoop = FALSE;
    _pSnoopWnd = NULL;

    _pLangBarItem = NULL;

    _fFlipKeys = FALSE;

    _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
    _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
    _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    _pTextEditSinkContext = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCaseTextService::~CCaseTextService()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CCaseTextService::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextInputProcessor))
    {
        *ppvObj = (ITfTextInputProcessor *)this;
    }
    else if (IsEqualIID(riid, IID_ITfThreadMgrEventSink))
    {
        *ppvObj = (ITfThreadMgrEventSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfThreadFocusSink))
    {
        *ppvObj = (ITfThreadFocusSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = (ITfTextEditSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfKeyEventSink))
    {
        *ppvObj = (ITfKeyEventSink *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCaseTextService::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCaseTextService::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CCaseTextService::Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId)
{
    _pThreadMgr = pThreadMgr;
    _pThreadMgr->AddRef();

    _tfClientId = tfClientId;

    if (!_InitLanguageBar())
        goto ExitError;

    if (!_InitThreadMgrSink())
        goto ExitError;

    if (!_InitSnoopWnd())
        goto ExitError;

    if (!_InitKeystrokeSink())
        goto ExitError;

    if (!_InitPreservedKey())
        goto ExitError;

    return S_OK;

ExitError:
    Deactivate(); // cleanup any half-finished init
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CCaseTextService::Deactivate()
{
    _UninitSnoopWnd();
    _UninitThreadMgrSink();
    _UninitLanguageBar();
    _UninitKeystrokeSink();
    _UninitPreservedKey();

    // we MUST release all refs to _pThreadMgr in Deactivate
    SafeReleaseClear(_pThreadMgr);

    _tfClientId = TF_CLIENTID_NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sapilayr\tts.cpp ===
//
//
// Sapilayr TIP CTextToSpeech implementation.
//
//
#include "private.h"
#include "sapilayr.h"
#include "nui.h"
#include "tts.h"


// -------------------------------------------------------
//
//  Implementation for CTextToSpeech
//
// -------------------------------------------------------

CTextToSpeech::CTextToSpeech(CSapiIMX *psi) 
{
    m_psi = psi;
    m_fPlaybackInitialized = FALSE;
    m_fIsInPlay = FALSE;
    m_fIsInPause = FALSE;
}

CTextToSpeech::~CTextToSpeech( ) 
{

};

/*  --------------------------------------------------------
//    Function Name: _SetDictation
//
//    Description: Temporally change the dictation status  
//                 while TTS is playing. 
//
//
// ----------------------------------------------------------*/

void     CTextToSpeech::_SetDictation( BOOL fEnable )
{
    BOOL    fDictOn;

    fDictOn = m_psi->GetDICTATIONSTAT_DictOnOff() && m_psi->GetOnOff() &&
         !m_psi->Get_SPEECH_DISABLED_Disabled()  && !m_psi->Get_SPEECH_DISABLED_DictationDisabled();

    // Only when the dictation status now is On, we change the 
    // status based on required value.

    if ( fDictOn )
    {
        // Temporally Enable/disable dictation.
        CSpTask           *psp;
        m_psi->GetSpeechTask(&psp); 

        if (psp)
        {
            if (psp->m_cpDictGrammar)
            {
                (psp->m_cpDictGrammar)->SetDictationState(fEnable ? SPRS_ACTIVE: SPRS_INACTIVE);
            }

            psp->Release();
        }
    }
}


/*  --------------------------------------------------------
//    Function Name: TtsPlay
//
//    Description: Play sound for currect selection or text 
//                 in visible area. 
//
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsPlay( )
{
    HRESULT              hr = E_FAIL;

    if ( !m_psi )
        return E_FAIL;

    if ( !m_fPlaybackInitialized  )
    {
        hr = m_psi->GetFunction(GUID_NULL, IID_ITfFnPlayBack, (IUnknown **)&m_cpPlayBack);

        if ( hr == S_OK )
            m_fPlaybackInitialized = TRUE;
    }

    if ( m_fPlaybackInitialized )
    {
        // Stop the possible previous speaking 
        TtsStop( );

        hr = m_psi->_RequestEditSession(ESCB_TTS_PLAY, TF_ES_READWRITE);
    }

    return hr;
}

/*  --------------------------------------------------------
//   Function Name: _TtsPlay
//
//   Description:   Edit session callback function for
//                  TtsPlay (ESCB_TTS_PLAY) 
//                  It will call ITfFnPlayBack->Play( ). 
//   
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::_TtsPlay(TfEditCookie ec,ITfContext *pic)
{
    HRESULT             hr = S_OK;
    CComPtr<ITfRange>   cpSelRange = NULL;
    BOOL                fEmpty = TRUE;
    BOOL                fPlayed = FALSE;

    hr = GetSelectionSimple(ec, pic, &cpSelRange);

    if ( hr == S_OK )
        cpSelRange->IsEmpty(ec, &fEmpty);

    if ( hr == S_OK && !fEmpty && m_cpPlayBack)
    {
        hr = m_cpPlayBack->Play(cpSelRange);
        fPlayed = TRUE;
    }
    else 
    {
        CComPtr<ITfRange>         cpRangeView;

        // Get the Active View Range
        hr = m_psi->_GetActiveViewRange(ec, pic, &cpRangeView);

        if( hr == S_OK )
        {
            if ( cpSelRange )
            {
                LONG    l;
                hr = cpRangeView->CompareStart(ec, cpSelRange, TF_ANCHOR_START, &l);

                if ( hr == S_OK && l > 0 )
                {
                    // Current selection is not in current active view.
                    // Use Start Anchor in active view as start point.
                    cpSelRange.Release( );
                    hr = cpRangeView->Clone(&cpSelRange);
                }
            }
            else
            {
                cpSelRange.Release( );
                hr = cpRangeView->Clone(&cpSelRange);
            }

            if ( hr == S_OK && cpSelRange )
            {
                hr = cpSelRange->ShiftEndToRange(ec, cpRangeView, TF_ANCHOR_END);

                if ( hr == S_OK )
                {
                    cpSelRange->IsEmpty(ec, &fEmpty);

                    if ( hr == S_OK && !fEmpty)
                    {
                        hr = m_cpPlayBack->Play(cpSelRange);
                        fPlayed = TRUE;
                    }
                }
            }
        }
    }


    if (!fPlayed )
    {
        CSpeechUIServer *pSpeechUIServer;
        pSpeechUIServer = m_psi->GetSpeechUIServer( );

        if ( pSpeechUIServer )
           pSpeechUIServer->SetTtsPlayOnOff( FALSE );
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: TtsStop
//
//    Description:   Stop current TTS playing immediately
//                   
//                   update the TTS session status.
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsStop( )
{
    HRESULT   hr=S_OK;

    if ( _IsInPlay( ) && m_psi )
    {
        CComPtr<ISpVoice>  cpSpVoice;
        CSpTask           *psp;

        hr = m_psi->GetSpeechTask(&psp); 
        if (hr == S_OK)
        {
            cpSpVoice = psp->_GetSpVoice( );
            if ( cpSpVoice )
                hr = cpSpVoice->Speak( NULL, SPF_PURGEBEFORESPEAK, NULL );
            psp->Release();

            _SetPlayMode(FALSE);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: TtsPause
//
//    Description:   Pause current TTS playing immediately
//                   
//                   update the TTS session status.
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsPause( )
{
    HRESULT   hr=S_OK;

    if ( _IsInPlay( ) && m_psi )
    {
        CComPtr<ISpVoice>  cpSpVoice;
        CSpTask           *psp;

        hr = m_psi->GetSpeechTask(&psp); 
        if (hr == S_OK)
        {
            cpSpVoice = psp->_GetSpVoice( );
            if ( cpSpVoice )
                hr = cpSpVoice->Pause( );
            psp->Release();

            _SetPauseMode(TRUE);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: TtsResume
//
//    Description:   Resume previous paused playing                   
//                   update the TTS session status.
//
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::TtsResume( )
{
    HRESULT   hr=S_OK;

    if ( _IsInPause( ) && m_psi )
    {
        CComPtr<ISpVoice>  cpSpVoice;
        CSpTask           *psp;

        hr = m_psi->GetSpeechTask(&psp); 
        if (hr == S_OK)
        {
            cpSpVoice = psp->_GetSpVoice( );
            if ( cpSpVoice )
                hr = cpSpVoice->Resume( );
            psp->Release();

            _SetPauseMode(FALSE);
        }
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _IsPureCiceroIC
//
//    Description:   Check current IC attribute to 
//                   determine it is PureCicero aware
//                   or AIMM aware.
//                  
// ----------------------------------------------------------*/
BOOL  CTextToSpeech::_IsPureCiceroIC(ITfContext  *pic)
{
    BOOL        fCiceroNative = FALSE;
    HRESULT     hr = S_OK;

    if ( pic )
    {
        TF_STATUS   tss;

        hr = pic->GetStatus(&tss);
        if (S_OK == hr)
        {
            //
            // If TS_SS_TRANSITORY is not set, means it is Cicero Aware.
            //
            if (!(tss.dwStaticFlags & TS_SS_TRANSITORY) )
               fCiceroNative = TRUE;
        }
    }

    return fCiceroNative;
}

/*  --------------------------------------------------------
//    Function Name: _SetTTSButtonStatus
//
//    Description:   Based on current IC attribute to 
//                   determine if to active or gray
//                   TTS buttons on toolbar.
//                   
//                   This  function will be called under
//                   TIM_CODE_SETFOCUS and TIM_CODE_INITIC.
// ----------------------------------------------------------*/
HRESULT  CTextToSpeech::_SetTTSButtonStatus(ITfContext  *pic)
{
    BOOL        fCiceroNative;
    HRESULT     hr = S_OK;
    CSpeechUIServer *pSpeechUIServer;

    TraceMsg(TF_GENERAL, "CTextToSpeech::_SetTTSButtonStatus is called");

    if ( !m_psi )
        return E_FAIL;

    fCiceroNative = _IsPureCiceroIC(pic);

    pSpeechUIServer = m_psi->GetSpeechUIServer( );

    if ( pSpeechUIServer )
    {
        pSpeechUIServer->SetTtsButtonStatus( fCiceroNative );
    }

    return hr;
}

/*  --------------------------------------------------------
//    Function Name: _HandleEventOnPlayButton
//
//    Description:   Handle mouse click event on Play button
//                   or Hotkey Windows+S. 
//                   
//                   it would be called by button's OnButtonUp
//                   callback function, and by Hotkey handler.
//
// ----------------------------------------------------------*/

HRESULT  CTextToSpeech::_HandleEventOnPlayButton( )
{
    HRESULT         hr = S_OK;
    BOOL            fTTSPlayOn;
    CSpeechUIServer *pSpeechUIServer;

    if ( !m_psi ) return E_FAIL;

    pSpeechUIServer = m_psi->GetSpeechUIServer( );

    if ( pSpeechUIServer == NULL)  return E_FAIL;

    fTTSPlayOn = pSpeechUIServer->GetTtsPlayOnOff( );

    if ( fTTSPlayOn )
    {
        // It is under Play mode.
        // Click this button to stop playing.

        // If it is under Pause mode, the Speaker needs to be resumed first.
        BOOL  fTTSPauseOn;

        fTTSPauseOn = pSpeechUIServer->GetTtsPauseOnOff( );

        if ( fTTSPauseOn )
        {
            // Under pause mode
            pSpeechUIServer->SetTtsPauseOnOff(FALSE);
            hr = TtsResume( );
        }
    }

    if  ( (hr == S_OK) && fTTSPlayOn )
    {
        // It has already been in Play mode.
        // click this to stop playing.
        hr = TtsStop( );
    }
    else
    {
        // It is not in Playing mode.
        hr = TtsPlay( );
    }

    pSpeechUIServer->SetTtsPlayOnOff( !fTTSPlayOn );

    return hr;

}

/*  --------------------------------------------------------
//    Function Name: _HandleEventOnPauseButton
//
//    Description:   Handle mouse click event on Pause Button.
//                   it would be called by Pause button's 
//                   OnLButtonUp callback function.
//
// ----------------------------------------------------------*/

HRESULT  CTextToSpeech::_HandleEventOnPauseButton( )
{
    HRESULT                 hr = S_OK;
    BOOL                    fTTSPauseOn;
    BOOL                    fTTSPlayOn;
    CSpeechUIServer *pSpeechUIServer;

    if ( !m_psi ) return E_FAIL;

    pSpeechUIServer = m_psi->GetSpeechUIServer( );

    if ( pSpeechUIServer == NULL)  return E_FAIL;

    fTTSPauseOn = pSpeechUIServer->GetTtsPauseOnOff( );
    fTTSPlayOn = pSpeechUIServer->GetTtsPlayOnOff( );

    if  ( fTTSPauseOn )
    {
        // It has already been in Pause mode.
        // click this to resume playing.
        hr = TtsResume( );
    }
    else
    {
        // It is not in Pause mode.

        if ( fTTSPlayOn )
        {
            hr = TtsPause( );
        }
    }

    if ( fTTSPlayOn )
        pSpeechUIServer->SetTtsPauseOnOff( !fTTSPauseOn );
    else
    {
        // If it is not under Play mode, click Pause button should not change the status.
        pSpeechUIServer->SetTtsPauseOnOff( FALSE );
    }
        
    return hr;
}

/*  --------------------------------------------------------
//   Function Name: SpeakNotifyCallback
//
//   Description:  This is callback for m_cpSpVoice in CSptask.
//                 Only SPEI_START_INPUT_STREAM &
//                 SPEI_END_INPUT_STREAM are insterested.
//                 
//                 When the input stream is over, we want
//                 to update the TTS buttons' toggle status
// ----------------------------------------------------------*/
void CSpTask::SpeakNotifyCallback( WPARAM wParam, LPARAM lParam )
{
    USES_CONVERSION;
    CSpEvent          event;
    CSpTask           *_this = (CSpTask *)lParam;
    CSapiIMX          *psi = NULL;
    CSpeechUIServer   *pSpeechUIServer = NULL;
    CComPtr<ISpVoice> cpVoice = NULL;
    
    if ( _this )
       cpVoice = _this->_GetSpVoice( );

    if (!_this || !cpVoice)
    {
        return;
    }

    psi = _this->GetTip( );

    if ( psi )
        pSpeechUIServer = psi->GetSpeechUIServer( );
    else
        return;

    while ( event.GetFrom(cpVoice) == S_OK )
    {
        switch (event.eEventId)
        {
            case SPEI_START_INPUT_STREAM  :
                TraceMsg(TF_GENERAL,"SPEI_START_INPUT_STREAM is notified");
                psi->_SetPlayMode(TRUE);

                // Update the toggle status for Play button.
                if ( pSpeechUIServer )
                    pSpeechUIServer->SetTtsPlayOnOff( TRUE );

                break;

            case SPEI_END_INPUT_STREAM :
                TraceMsg(TF_GENERAL,"SPEI_END_INPUT_STREAM is notified");
                psi->_SetPlayMode(FALSE);

                // Update the toggle status for Play button.
                if ( pSpeechUIServer )
                    pSpeechUIServer->SetTtsPlayOnOff( FALSE );

                break;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\editsink.cpp ===
//
// editsink.cpp
//
// ITfTextEditSink implementation.
//

#include "globals.h"
#include "case.h"
#include "snoop.h"

//+---------------------------------------------------------------------------
//
// OnEndEdit
//
// Called by the system whenever anyone releases a write-access document lock.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    BOOL fSelectionChanged;
    IEnumTfRanges *pEnumTextChanges;
    ITfRange *pRange;

    // we'll use the endedit notification to update the snoop window

    // did the selection change?
    if (pEditRecord->GetSelectionStatus(&fSelectionChanged) == S_OK &&
        fSelectionChanged)
    {
        _pSnoopWnd->_UpdateText(ecReadOnly, pContext, NULL);
        return S_OK;
    }

    // text modification?
    if (pEditRecord->GetTextAndPropertyUpdates(TF_GTP_INCL_TEXT, NULL, 0, &pEnumTextChanges) == S_OK)
    {
        if (pEnumTextChanges->Next(1, &pRange, NULL) == S_OK)
        {
            // arbitrary update the snoop window with the first change
            // there may be more than one in the enumerator, but we don't care here
            _pSnoopWnd->_UpdateText(ecReadOnly, pContext, pRange);
            pRange->Release();
        }

        pEnumTextChanges->Release();
        return S_OK;
    }

    // if we get here, only property values changed

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitTextEditSink
//
// Init a text edit sink on the topmost context of the document.
// Always release any previous sink.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitTextEditSink(ITfDocumentMgr *pDocMgr)
{
    ITfSource *pSource;
    BOOL fRet;

    // clear out any previous sink first

    if (_dwTextEditSinkCookie != TF_INVALID_COOKIE)
    {
        if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
        {
            pSource->UnadviseSink(_dwTextEditSinkCookie);
            pSource->Release();
        }

        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
        _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    }

    if (pDocMgr == NULL)
        return TRUE; // caller just wanted to clear the previous sink

    // setup a new sink advised to the topmost context of the document

    if (pDocMgr->GetTop(&_pTextEditSinkContext) != S_OK)
        return FALSE;

    if (_pTextEditSinkContext == NULL)
        return TRUE; // empty document, no sink possible

    fRet = FALSE;

    if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        if (pSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &_dwTextEditSinkCookie) == S_OK)
        {
            fRet = TRUE;
        }
        else
        {
            _dwTextEditSinkCookie = TF_INVALID_COOKIE;
        }
        pSource->Release();
    }

    if (fRet == FALSE)
    {
        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\editsess.h ===
//
// editsess.h
//
// CEditSessionBase declaration.
//

#ifndef EDITSESS_H
#define EDITSESS_H

class CEditSessionBase : public ITfEditSession
{
public:
    CEditSessionBase(ITfContext *pContext)
    {
        _cRef = 1;
        _pContext = pContext;
        _pContext->AddRef();
    }
    virtual ~CEditSessionBase()
    {
        _pContext->Release();
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
    {
        if (ppvObj == NULL)
            return E_INVALIDARG;

        *ppvObj = NULL;

        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_ITfEditSession))
        {
            *ppvObj = (ITfLangBarItemButton *)this;
        }

        if (*ppvObj)
        {
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        LONG cr = --_cRef;

        assert(_cRef >= 0);

        if (_cRef == 0)
        {
            delete this;
        }

        return cr;
    }

    // ITfEditSession
    virtual STDMETHODIMP DoEditSession(TfEditCookie ec) = 0;

protected:
    ITfContext *_pContext;

private:
    LONG _cRef;     // COM ref count
};

#endif // EDITSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\flipdoc.cpp ===
//
// flipdoc.cpp
//
// "Flip Doc" menu item handler.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CFlipDocEditSession : public CEditSessionBase
{
public:
    CFlipDocEditSession(ITfContext *pContext) : CEditSessionBase(pContext) {}

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);
};

//+---------------------------------------------------------------------------
//
// _Menu_FlipDoc
//
// Toggle the case of the entire document.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_FlipDoc(CCaseTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CFlipDocEditSession *pFlipEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pFlipEditSession = new CFlipDocEditSession(pContext))
    {
        // we need a document write lock to insert text
        // the CHelloEditSession will do all the work when the
        // CHelloEditSession::EditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pFlipEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pFlipEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CFlipDocEditSession::DoEditSession(TfEditCookie ec)
{
    ITfRange *pRangeStart;

    // get the head of the doc
    if (_pContext->GetStart(ec, &pRangeStart) != S_OK)
        return E_FAIL;

    // do the work
    ToggleCase(ec, pRangeStart, TRUE);

    // release the range
    pRangeStart->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\flipsel.cpp ===
//
// flipsel.cpp
//
// "Flip Selection" menu item handler.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CFlipEditSession : public CEditSessionBase
{
public:
    CFlipEditSession(ITfContext *pContext) : CEditSessionBase(pContext) {}

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);
};

//+---------------------------------------------------------------------------
//
// _Menu_FlipSel
//
// Toggle the case of the selected text in the focus context.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_FlipSel(CCaseTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CFlipEditSession *pFlipEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pFlipEditSession = new CFlipEditSession(pContext))
    {
        // we need a document write lock to insert text
        // the CHelloEditSession will do all the work when the
        // CHelloEditSession::EditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pFlipEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pFlipEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CFlipEditSession::DoEditSession(TfEditCookie ec)
{
    TF_SELECTION tfSelection;
    ULONG cFetched;

    // get the selection
    if (_pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched == 0)
    {
        // no selection
        return S_OK;
    }

    // do the work
    ToggleCase(ec, tfSelection.range, FALSE);

    // release the range
    tfSelection.range->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\globals.cpp ===
//
// globals.cpp
//
// Global variables.
//

#include "globals.h"

HINSTANCE g_hInst;

LONG g_cRefDll = -1; // -1 /w no refs, for win95 InterlockedIncrement/Decrement compat

CRITICAL_SECTION g_cs;

/* 6565d455-5030-4c0f-8871-83f6afde514f */
const CLSID c_clsidCaseTextService = { 0x6565d455, 0x5030, 0x4c0f, {0x88, 0x71, 0x83, 0xf6, 0xaf, 0xde, 0x51, 0x4f} };

/* 4d5459db-7543-42c0-9204-9195b91f6fb8 */
const GUID c_guidCaseProfile = { 0x4d5459db, 0x7543, 0x42c0, {0x92, 0x04, 0x91, 0x95, 0xb9, 0x1f, 0x6f, 0xb8} };

/* 01679c88-5141-4ee5-a47f-c8d586ff37e1 */
const GUID c_guidLangBarItemButton = { 0x01679c88, 0x5141, 0x4ee5, {0xa4, 0x7f, 0xc8, 0xd5, 0x86, 0xff, 0x37, 0xe1} };

//+---------------------------------------------------------------------------
//
// ToggleChar
//
// Toggle the case of a single char.
//----------------------------------------------------------------------------

WCHAR ToggleChar(WCHAR ch)
{
    // toggle english ascii
    if ((ch >= 'a' && ch <= 'z') ||
        (ch >= 'A' && ch <= 'Z'))
    {
        return ch ^ 32;
    }
     
    // give up for non-ascii
    return ch;
}

//+---------------------------------------------------------------------------
//
// ToggleCase
//
// Toggle the case of all text covered by the range.  The input range is
// collapsed to its end point on exit.
//
// If fIgnoreRangeEnd == TRUE, all text following the start of range will be
// toggled, and the range will be collapsed at the end-of-doc on exit.
//----------------------------------------------------------------------------

void ToggleCase(TfEditCookie ec, ITfRange *pRange, BOOL fIgnoreRangeEnd)
{
    ITfRange *pRangeToggle;
    ULONG cch;
    ULONG i;
    DWORD dwFlags;
    WCHAR achText[64];

    // backup the current range
    if (pRange->Clone(&pRangeToggle) != S_OK)
        return;

    dwFlags = TF_TF_MOVESTART | (fIgnoreRangeEnd ? TF_TF_IGNOREEND : 0);

    while (TRUE)
    {
        // grab the next block of chars
        if (pRange->GetText(ec, dwFlags, achText, ARRAYSIZE(achText), &cch) != S_OK)
            break;

        // out of text?
        if (cch == 0)
            break;

        // toggle the case
        for (i=0; i<cch; i++)
        {
            achText[i] = ToggleChar(achText[i]);
        }

        // shift pRangeToggle so it covers just the text we read
        if (pRangeToggle->ShiftEndToRange(ec, pRange, TF_ANCHOR_START) != S_OK)
            break;

        // replace the text
        pRangeToggle->SetText(ec, 0, achText, cch);

        // prepare for next iteration
        pRangeToggle->Collapse(ec, TF_ANCHOR_END);
    }
    
    pRangeToggle->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\globals.h ===
//
// globals.h
//
// Global variable declarations.
//

#ifndef GLOBALS_H
#define GLOBALS_H

#include <windows.h>
#include <ole2.h>
#include <olectl.h>
#include <assert.h>
#include "msctf.h"

void DllAddRef();
void DllRelease();

void ToggleCase(TfEditCookie ec, ITfRange *range, BOOL fIgnoreRangeEnd);
void InsertTextAtSelection(TfEditCookie ec, ITfContext *pContext, const WCHAR *pchText, ULONG cchText);

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define CASE_LANGID    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

#define CASE_DESC    L"Case Text Service"
#define CASE_DESC_A   "Case Text Service"
#define CASE_MODEL   TEXT("Apartment")

#define LANGBAR_ITEM_DESC L"Case Menu" // max 32 chars!

#define CASE_ICON_INDEX  0

#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}                   

extern HINSTANCE g_hInst;

extern LONG g_cRefDll;

extern CRITICAL_SECTION g_cs;

extern const CLSID c_clsidCaseTextService;

extern const GUID c_guidCaseProfile;

extern const GUID c_guidLangBarItemButton;

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\resource.h ===
//
// resource.h
//
// Resource declarations.
//

#ifndef RESOURCE_H
#define RESOURCE_H

//#define IDI_CASE        0

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\register.cpp ===
//
// register.cpp
//
// Server registration code.
//

#include <windows.h>
#include <ole2.h>
#include "msctf.h"
#include "globals.h"
#include "case.h"

#define CLSID_STRLEN 38  // strlen("{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}")

const struct
{
    const GUID *pguidCategory;
    const GUID *pguid;
}
c_rgCategories[] =
{
    { &GUID_TFCAT_TIP_KEYBOARD, &c_clsidCaseTextService },
};

static const TCHAR c_szInfoKeyPrefix[] = TEXT("CLSID\\");
static const TCHAR c_szInProcSvr32[] = TEXT("InProcServer32");
static const TCHAR c_szModelName[] = TEXT("ThreadingModel");

//+---------------------------------------------------------------------------
//
//  RegisterProfiles
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::RegisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    WCHAR achIconFile[MAX_PATH];
    char achFileNameA[MAX_PATH];
    DWORD cchA;
    int cchIconFile;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return E_FAIL;

    hr = pInputProcessProfiles->Register(c_clsidCaseTextService);

    if (hr != S_OK)
        goto Exit;

    cchA = GetModuleFileNameA(g_hInst, achFileNameA, ARRAYSIZE(achFileNameA));

    cchIconFile = MultiByteToWideChar(CP_ACP, 0, achFileNameA, cchA, achIconFile, ARRAYSIZE(achIconFile));
    achIconFile[cchIconFile] = '\0';

    hr = pInputProcessProfiles->AddLanguageProfile(c_clsidCaseTextService,
                                  CASE_LANGID, 
                                  c_guidCaseProfile, 
                                  CASE_DESC, 
                                  wcslen(CASE_DESC),
                                  achIconFile,
                                  cchIconFile,
                                  CASE_ICON_INDEX);

Exit:
    pInputProcessProfiles->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
//  UnregisterProfiles
//
//----------------------------------------------------------------------------

void CCaseTextService::UnregisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return;

    pInputProcessProfiles->Unregister(c_clsidCaseTextService);
    pInputProcessProfiles->Release();
}

//+---------------------------------------------------------------------------
//
//  RegisterCategories
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::RegisterCategories(BOOL fRegister)
{
    ITfCategoryMgr *pCategoryMgr;
    int i;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_CategoryMgr, NULL, CLSCTX_INPROC_SERVER, 
                          IID_ITfCategoryMgr, (void**)&pCategoryMgr);

    if (hr != S_OK)
        return E_FAIL;

    for (i=0; i<ARRAYSIZE(c_rgCategories); i++)
    {
        if (fRegister)
        {
            hr = pCategoryMgr->RegisterCategory(c_clsidCaseTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }
        else
        {
            hr = pCategoryMgr->UnregisterCategory(c_clsidCaseTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }

        if (hr != S_OK)
            break;
    }

    pCategoryMgr->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// CLSIDToStringA
//
//----------------------------------------------------------------------------

BOOL CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                   8, 9, '-', 10, 11, 12, 13, 14, 15};

    static const char szDigits[] = "0123456789ABCDEF";

    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// RecurseDeleteKey
//
// RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
// specified key has subkeys
//----------------------------------------------------------------------------
LONG RecurseDeleteKey(HKEY hParentKey, LPCTSTR lpszKey)
{
    HKEY hKey;
    LONG lRes;
    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = sizeof(szBuffer);

    if (RegOpenKey(hParentKey, lpszKey, &hKey) != ERROR_SUCCESS)
        return ERROR_SUCCESS; // let's assume we couldn't open it because it's not there

    lRes = ERROR_SUCCESS;
    while (RegEnumKeyEx(hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time)==ERROR_SUCCESS)
    {
        lRes = RecurseDeleteKey(hKey, szBuffer);
        if (lRes != ERROR_SUCCESS)
            break;
        dwSize = sizeof(szBuffer);
    }
    RegCloseKey(hKey);

    return lRes == ERROR_SUCCESS ? RegDeleteKey(hParentKey, lpszKey) : lRes;
}

//+---------------------------------------------------------------------------
//
//  RegisterServer
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::RegisterServer()
{
    DWORD dw;
    HKEY hKey;
    HKEY hSubKey;
    BOOL fRet;
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];
    TCHAR achFileName[MAX_PATH];

    if (!CLSIDToStringA(c_clsidCaseTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return FALSE;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    if (fRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, achIMEKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw)
            == ERROR_SUCCESS)
    {
        fRet &= RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)CASE_DESC_A, (lstrlen(CASE_DESC_A)+1)*sizeof(TCHAR))
            == ERROR_SUCCESS;

        if (fRet &= RegCreateKeyEx(hKey, c_szInProcSvr32, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSubKey, &dw)
            == ERROR_SUCCESS)
        {
            dw = GetModuleFileNameA(g_hInst, achFileName, ARRAYSIZE(achFileName));

            fRet &= RegSetValueEx(hSubKey, NULL, 0, REG_SZ, (BYTE *)achFileName, (lstrlen(achFileName)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            fRet &= RegSetValueEx(hSubKey, c_szModelName, 0, REG_SZ, (BYTE *)CASE_MODEL, (lstrlen(CASE_MODEL)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  UnregisterServer
//
//----------------------------------------------------------------------------

void CCaseTextService::UnregisterServer()
{
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];

    if (!CLSIDToStringA(c_clsidCaseTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    RecurseDeleteKey(HKEY_CLASSES_ROOT, achIMEKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\precomp.cpp ===
//
// precomp.cpp
//
// Stub for vc precompiled header.
//

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\hello.cpp ===
//
// hello.cpp
//
// "Hello World" menu item handler.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CHelloEditSession : public CEditSessionBase
{
public:
    CHelloEditSession(ITfContext *pContext) : CEditSessionBase(pContext) {}

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);
};

//+---------------------------------------------------------------------------
//
// _Menu_HelloWord
//
// Insert the string "Hello world!" to the focus context.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_HelloWord(CCaseTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CHelloEditSession *pHelloEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pHelloEditSession = new CHelloEditSession(pContext))
    {
        // we need a document write lock to insert text
        // the CHelloEditSession will do all the work when the
        // CHelloEditSession::EditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pHelloEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pHelloEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CHelloEditSession::DoEditSession(TfEditCookie ec)
{
    InsertTextAtSelection(ec, _pContext, L"Hello world!", wcslen(L"Hello world!"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InsertTextAtSelection
//
//----------------------------------------------------------------------------

void InsertTextAtSelection(TfEditCookie ec, ITfContext *pContext, const WCHAR *pchText, ULONG cchText)
{
    ITfInsertAtSelection *pInsertAtSelection;
    ITfRange *pRange;
    TF_SELECTION tfSelection;

    // we need a special interface to insert text at the selection
    if (pContext->QueryInterface(IID_ITfInsertAtSelection, (void **)&pInsertAtSelection) != S_OK)
        return;

    // insert the text
    if (pInsertAtSelection->InsertTextAtSelection(ec, 0, pchText, cchText, &pRange) != S_OK)
        goto Exit;

    // update the selection, we'll make it an insertion point just past
    // the inserted text.
    pRange->Collapse(ec, TF_ANCHOR_END);

    tfSelection.range = pRange;
    tfSelection.style.ase = TF_AE_NONE;
    tfSelection.style.fInterimChar = FALSE;

    pContext->SetSelection(ec, 1, &tfSelection);

    pRange->Release();

Exit:
    pInsertAtSelection->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\server.cpp ===
//
// server.cpp
//
// COM server exports.
//

#include "globals.h"
#include "case.h"

void FreeGlobalObjects(void);

class CClassFactory;
static CClassFactory *g_ObjectInfo[1] = { NULL };

//+---------------------------------------------------------------------------
//
//  DllAddRef
//
//----------------------------------------------------------------------------

void DllAddRef(void)
{
    InterlockedIncrement(&g_cRefDll);
}

//+---------------------------------------------------------------------------
//
//  DllRelease
//
//----------------------------------------------------------------------------

void DllRelease(void)
{
    if (InterlockedDecrement(&g_cRefDll) < 0) // g_cRefDll == -1 with zero refs
    {
        EnterCriticalSection(&g_cs);

        // need to check ref again after grabbing mutex
        if (g_ObjectInfo[0] != NULL)
        {
            FreeGlobalObjects();
        }
        assert(g_cRefDll == -1);

        LeaveCriticalSection(&g_cs);
    }
}

//+---------------------------------------------------------------------------
//
//  CClassFactory declaration with IClassFactory Interface
//
//----------------------------------------------------------------------------

class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory methods
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP LockServer(BOOL fLock);

    // Constructor
    CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj))
        : _rclsid(rclsid)
    {
        _pfnCreateInstance = pfnCreateInstance;
    }

public:
    REFCLSID _rclsid;
    HRESULT (*_pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
};

//+---------------------------------------------------------------------------
//
//  CClassFactory::QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
        DllAddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::CreateInstance
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return _pfnCreateInstance(pUnkOuter, riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::LockServer
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllAddRef();
    }
    else
    {
        DllRelease();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  BuildGlobalObjects
//
//----------------------------------------------------------------------------

void BuildGlobalObjects(void)
{
    // Build CClassFactory Objects

    g_ObjectInfo[0] = new CClassFactory(c_clsidCaseTextService, CCaseTextService::CreateInstance);

    // You can add more object info here.
    // Don't forget to increase number of item for g_ObjectInfo[],
}

//+---------------------------------------------------------------------------
//
//  FreeGlobalObjects
//
//----------------------------------------------------------------------------

void FreeGlobalObjects(void)
{
    // Free CClassFactory Objects
    for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
    {
        if (NULL != g_ObjectInfo[i])
        {
            delete g_ObjectInfo[i];
            g_ObjectInfo[i] = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  DllGetClassObject
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    if (g_ObjectInfo[0] == NULL)
    {
        EnterCriticalSection(&g_cs);

            // need to check ref again after grabbing mutex
            if (g_ObjectInfo[0] == NULL)
            {
                BuildGlobalObjects();
            }

        LeaveCriticalSection(&g_cs);
    }

    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
        {
            if (NULL != g_ObjectInfo[i] &&
                IsEqualGUID(rclsid, g_ObjectInfo[i]->_rclsid))
            {
                *ppvObj = (void *)g_ObjectInfo[i];
                DllAddRef();    // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }

    *ppvObj = NULL;

    return CLASS_E_CLASSNOTAVAILABLE;
}

//+---------------------------------------------------------------------------
//
//  DllCanUnloadNow
//
//----------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    if (g_cRefDll >= 0) // -1 with no refs
        return S_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer(void)
{
    CCaseTextService::RegisterCategories(FALSE);
    CCaseTextService::UnregisterProfiles();
    CCaseTextService::UnregisterServer();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllRegisterServer
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
    // register this service's profile with the tsf
    if (!CCaseTextService::RegisterServer() ||
        !CCaseTextService::RegisterProfiles() ||
        !CCaseTextService::RegisterCategories(TRUE))
    {
        DllUnregisterServer(); // cleanup any loose ends
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\keys.cpp ===
//
// keys.cpp
//
// ITfKeyEventSink implementation.
//

#include "globals.h"
#include "case.h"
#include "editsess.h"

class CKeystrokeEditSession : public CEditSessionBase
{
public:
    CKeystrokeEditSession(ITfContext *pContext, WPARAM wParam) : CEditSessionBase(pContext)
    {
        _wParam = wParam;
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    WPARAM _wParam;
};


/* 5d6d1b1e-64f2-47cd-9fe1-4e032c2dae77 */
static const GUID GUID_PRESERVEDKEY_FLIPCASE = { 0x5d6d1b1e, 0x64f2, 0x47cd, {0x9f, 0xe1, 0x4e, 0x03, 0x2c, 0x2d, 0xae, 0x77} };
// arbitrary hotkey: ctl-f
static const TF_PRESERVEDKEY c_FlipCaseKey = { 'F', TF_MOD_CONTROL };


//+---------------------------------------------------------------------------
//
// IsKeyEaten
//
//----------------------------------------------------------------------------

inline BOOL IsKeyEaten(BOOL fFlipKeys, WPARAM wParam)
{
    // we're only interested in VK_A - VK_Z, when the "Flip Keys" menu option
    // is on
    return fFlipKeys && (wParam >= 'A') && (wParam <= 'Z');
}

//+---------------------------------------------------------------------------
//
// _Menu_FlipKeys
//
// Advise or unadvise a keystroke sink.
//----------------------------------------------------------------------------

/* static */
void CCaseTextService::_Menu_FlipKeys(CCaseTextService *_this)
{
    _this->_fFlipKeys = !_this->_fFlipKeys;
}

//+---------------------------------------------------------------------------
//
// _InitKeystrokeSink
//
// Advise a keystroke sink.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;
    HRESULT hr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return FALSE;

    hr = pKeystrokeMgr->AdviseKeyEventSink(_tfClientId, (ITfKeyEventSink *)this, TRUE);

    pKeystrokeMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitKeystrokeSink
//
// Unadvise a keystroke sink.  Assumes we have advised one already.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return;

    pKeystrokeMgr->UnadviseKeyEventSink(_tfClientId);

    pKeystrokeMgr->Release();
}

//+---------------------------------------------------------------------------
//
// _InitPreservedKey
//
// Register a hot key.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitPreservedKey()
{
    ITfKeystrokeMgr *pKeystrokeMgr;
    HRESULT hr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return FALSE;

    hr = pKeystrokeMgr->PreserveKey(_tfClientId, GUID_PRESERVEDKEY_FLIPCASE,
                                    &c_FlipCaseKey, L"Toggle Case",
                                    wcslen(L"Toggle Case"));

    pKeystrokeMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitPreservedKey
//
// Uninit a hot key.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitPreservedKey()
{
    ITfKeystrokeMgr *pKeystrokeMgr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return;

    pKeystrokeMgr->UnpreserveKey(GUID_PRESERVEDKEY_FLIPCASE, &c_FlipCaseKey);

    pKeystrokeMgr->Release();
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Called by the system whenever this service gets the keystroke device focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnSetFocus(BOOL fForeground)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTestKeyDown
//
// Called by the system to query this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyDown
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    CKeystrokeEditSession *pEditSession;
    HRESULT hr = S_OK;

    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);

    if (*pfEaten)
    {
        // we'll insert a char ourselves in place of this keystroke
        if ((pEditSession = new CKeystrokeEditSession(pContext, wParam)) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // we need a lock to do our work
        // nb: this method is one of the few places where it is legal to use
        // the TF_ES_SYNC flag
        if (pContext->RequestEditSession(_tfClientId, pEditSession, TF_ES_SYNC | TF_ES_READWRITE, &hr) != S_OK)
        {
            hr = E_FAIL;
        }

        pEditSession->Release();
    }

Exit:
    if (hr != S_OK)
    {
        *pfEaten = FALSE;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CKeystrokeEditSession::DoEditSession(TfEditCookie ec)
{
    WCHAR wc;

    // we want to toggle the english case of the keystroke
    // nb: this is quick-and-dirty code, not intended to demonstrate the
    // correct way to flip capitalization!

    if (GetKeyState(VK_SHIFT) & 0x8000)
    {
        // shift-key, make it lowercase
        wc = _wParam | 32;
    }
    else
    {
        // else make it capital
        wc = _wParam;
    }

    InsertTextAtSelection(ec, _pContext, &wc, 1);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTestKeyUp
//
// Called by the system to query this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyUp
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = IsKeyEaten(_fFlipKeys, wParam);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPreservedKey
//
// Called when a hotkey (registered by us, or by the system) is typed.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten)
{
    if (IsEqualGUID(rguid, GUID_PRESERVEDKEY_FLIPCASE))
    {
        _Menu_FlipDoc(this);
        *pfEaten = TRUE;
    }
    else
    {
        *pfEaten = FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\langbar.cpp ===
//
// langbar.cpp
//
// Language bar ui code.
//

#include "globals.h"
#include "case.h"
#include "resource.h"

#define CASE_LANGBARITEMSINK_COOKIE 0x0fab0fab

const struct
{
    const WCHAR *pchDesc;
    void (*pfnHandler)(CCaseTextService *_this);
}
c_rgMenuItems[] =
{
    { L"Show Snoop Wnd", CCaseTextService::_Menu_ShowSnoopWnd }, // must match MENU_SHOWSNOOP_INDEX
    { L"Hello World", CCaseTextService::_Menu_HelloWord },
    { L"Flip Selection", CCaseTextService::_Menu_FlipSel },
    { L"Flip Doc", CCaseTextService::_Menu_FlipDoc },
    { L"Flip Keystrokes", CCaseTextService::_Menu_FlipKeys }, // must match MENU_FLIPKEYS_INDEX
};

#define MENU_SHOWSNOOP_INDEX    0
#define MENU_FLIPKEYS_INDEX     4

class CLangBarItemButton : public ITfLangBarItemButton,
                           public ITfSource
{
public:
    CLangBarItemButton(CCaseTextService *pCase);
    ~CLangBarItemButton();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfLangBarItem
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    // ITfLangBarItemButton
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

private:
    CCaseTextService *_pCase;
    ITfLangBarItemSink *_pLangBarItemSink;
    TF_LANGBARITEMINFO _tfLangBarItemInfo;
    LONG _cRef;
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarItemButton::CLangBarItemButton(CCaseTextService *pCase)
{
    DllAddRef();

    _tfLangBarItemInfo.clsidService = c_clsidCaseTextService;
    _tfLangBarItemInfo.guidItem = c_guidLangBarItemButton;
    _tfLangBarItemInfo.dwStyle = TF_LBI_STYLE_BTN_MENU;
    _tfLangBarItemInfo.ulSort = 0;
    memcpy(_tfLangBarItemInfo.szDescription, LANGBAR_ITEM_DESC, sizeof(LANGBAR_ITEM_DESC));

    _pCase = pCase;
    _pCase->AddRef();
    _pLangBarItemSink = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarItemButton::~CLangBarItemButton()
{
    DllRelease();
    _pCase->Release();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem) ||
        IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = (ITfLangBarItemButton *)this;
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = (ITfSource *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = _tfLangBarItemInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::Show(BOOL fShow)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetTooltipString(BSTR *pbstrToolTip)
{
    *pbstrToolTip = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrToolTip == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::InitMenu(ITfMenu *pMenu)
{
    int i;
    DWORD dwFlags;

    for (i=0; i<ARRAYSIZE(c_rgMenuItems); i++)
    {
        switch (i)
        {
            case MENU_SHOWSNOOP_INDEX:
                dwFlags = _pCase->_IsSnoopWndVisible() ? TF_LBMENUF_CHECKED : 0;
                break;

            case MENU_FLIPKEYS_INDEX:
                dwFlags = _pCase->_IsKeyFlipping() ? TF_LBMENUF_CHECKED : 0;
                break;

            default:
                // all other items are plain
                dwFlags = 0;
                break;
        }

        pMenu->AddMenuItem(i, dwFlags, NULL, NULL, c_rgMenuItems[i].pchDesc, wcslen(c_rgMenuItems[i].pchDesc), NULL);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnMenuSelect(UINT wID)
{
    c_rgMenuItems[wID].pfnHandler(_pCase);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetIcon(HICON *phIcon)
{
    *phIcon = (HICON)LoadImage(g_hInst, TEXT("IDI_CASE"), IMAGE_ICON, 16, 16, 0);
 
    return (*phIcon != NULL) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetText(BSTR *pbstrText)
{
    *pbstrText = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrText == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    if (!IsEqualIID(IID_ITfLangBarItemSink, riid))
        return CONNECT_E_CANNOTCONNECT;

    if (_pLangBarItemSink != NULL)
        return CONNECT_E_ADVISELIMIT;

    if (punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&_pLangBarItemSink) != S_OK)
    {
        _pLangBarItemSink = NULL;
        return E_NOINTERFACE;
    }

    *pdwCookie = CASE_LANGBARITEMSINK_COOKIE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::UnadviseSink(DWORD dwCookie)
{
    if (dwCookie != CASE_LANGBARITEMSINK_COOKIE)
        return CONNECT_E_NOCONNECTION;

    if (_pLangBarItemSink == NULL)
        return CONNECT_E_NOCONNECTION;

    _pLangBarItemSink->Release();
    _pLangBarItemSink = NULL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitLanguageBar
//
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;
    BOOL fRet;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) != S_OK)
        return FALSE;

    fRet = FALSE;

    if ((_pLangBarItem = new CLangBarItemButton(this)) == NULL)
        goto Exit;

    if (pLangBarItemMgr->AddItem(_pLangBarItem) != S_OK)
    {
        _pLangBarItem->Release();
        _pLangBarItem = NULL;
        goto Exit;
    }

    fRet = TRUE;

Exit:
    pLangBarItemMgr->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitLanguageBar
//
//----------------------------------------------------------------------------

void CCaseTextService::_UninitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;

    if (_pLangBarItem == NULL)
        return;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) == S_OK)
    {
        pLangBarItemMgr->RemoveItem(_pLangBarItem);
        pLangBarItemMgr->Release();
    }

    _pLangBarItem->Release();
    _pLangBarItem = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\snoop.h ===
//
// snoop.h
//
// CSnoopWnd declaration.
//

#ifndef SNOOP_H
#define SNOOP_H

#define MAX_SNOOP_TEXT  32

class CCaseTextService;
class CUpdateTextEditSession;

class CSnoopWnd
{
public:
    CSnoopWnd(CCaseTextService *pCase);

    static BOOL _InitClass();
    static void _UninitClass();

    BOOL _Init();
    void _Uninit();

    void _Show();
    void _Hide();

    void _UpdateText(ITfRange *pRange);
    void _UpdateText(TfEditCookie ec, ITfContext *pContext, ITfRange *pRange);

private:

    friend CUpdateTextEditSession;

    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPaint(HWND hWnd, HDC hdc);

    static void _SetThis(HWND hWnd, LPARAM lParam)
    {
        SetWindowLong(hWnd, GWL_USERDATA, 
                      (LONG)((CREATESTRUCT *)lParam)->lpCreateParams);
    }

    static CSnoopWnd *_GetThis(HWND hWnd)
    {
        return (CSnoopWnd *)GetWindowLong(hWnd, GWL_USERDATA);
    }

    CCaseTextService *_pCase;
    HWND _hWnd;
    ULONG _cchText;
    WCHAR _achText[MAX_SNOOP_TEXT];
    static ATOM _atomWndClass;
};

#endif // SNOOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\editsess.h ===
//
// editsess.h
//
// CEditSessionBase declaration.
//

#ifndef EDITSESS_H
#define EDITSESS_H

class CEditSessionBase : public ITfEditSession
{
public:
    CEditSessionBase(ITfContext *pContext)
    {
        _cRef = 1;
        _pContext = pContext;
        _pContext->AddRef();
    }
    virtual ~CEditSessionBase()
    {
        _pContext->Release();
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj)
    {
        if (ppvObj == NULL)
            return E_INVALIDARG;

        *ppvObj = NULL;

        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_ITfEditSession))
        {
            *ppvObj = (ITfLangBarItemButton *)this;
        }

        if (*ppvObj)
        {
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        LONG cr = --_cRef;

        assert(_cRef >= 0);

        if (_cRef == 0)
        {
            delete this;
        }

        return cr;
    }

    // ITfEditSession
    virtual STDMETHODIMP DoEditSession(TfEditCookie ec) = 0;

protected:
    ITfContext *_pContext;

private:
    LONG _cRef;     // COM ref count
};

#endif // EDITSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\snoop.cpp ===
//
// snoop.cpp
//
// CSnoopWnd implementation.
//

#include "globals.h"
#include "snoop.h"
#include "case.h"
#include "editsess.h"

class CUpdateTextEditSession : public CEditSessionBase
{
public:
    CUpdateTextEditSession(ITfContext *pContext, ITfRange *pRange, CSnoopWnd *pSnoopWnd) : CEditSessionBase(pContext)
    {
        _pSnoopWnd = pSnoopWnd;
        _pRange = pRange;
        if (_pRange != NULL)
        {
            _pRange->AddRef();
        }
    }
    ~CUpdateTextEditSession()
    {
        SafeRelease(_pRange);
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    CSnoopWnd *_pSnoopWnd;
    ITfRange *_pRange;
};


#define SNOOP_X_POS     0
#define SNOOP_Y_POS     0

#define SNOOP_WIDTH     300
#define SNOOP_HEIGHT    (SNOOP_WIDTH / 3)

ATOM CSnoopWnd::_atomWndClass = 0;

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSnoopWnd::CSnoopWnd(CCaseTextService *pCase)
{
    _pCase = pCase; // no AddRef because CSnoopWnd is contained in the
                    // pCase lifetime
    _hWnd = NULL;
    _cchText = 0;
}

//+---------------------------------------------------------------------------
//
// _InitClass
//
//----------------------------------------------------------------------------

/* static */
BOOL CSnoopWnd::_InitClass()
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = CSnoopWnd::_WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT("SnoopWndClass");

    _atomWndClass = RegisterClass(&wc);

    return (_atomWndClass != 0);
}

//+---------------------------------------------------------------------------
//
// _UninitClass
//
//----------------------------------------------------------------------------

/* static */
void CSnoopWnd::_UninitClass()
{
    if (_atomWndClass != 0)
    {
        UnregisterClass((LPCTSTR)_atomWndClass, g_hInst);
    }
}


//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

BOOL CSnoopWnd::_Init()
{
    // nb: on windows 2000, you can use WS_EX_NOACTIVATE to prevent windows
    // from taking the foreground.  We don't use that here for compatibility.
    // Instead, we use WS_DISABLED, which can be burdensome for more complex
    // ui.

    _hWnd = CreateWindowEx(WS_EX_TOPMOST | WS_EX_TOOLWINDOW,
                           (LPCTSTR)_atomWndClass,
                           TEXT("Snoop Window"),
                           WS_BORDER | WS_DISABLED | WS_POPUP,
                           SNOOP_X_POS, SNOOP_Y_POS,
                           SNOOP_WIDTH, SNOOP_HEIGHT,
                           NULL,
                           NULL,
                           g_hInst,
                           this);

    return (_hWnd != NULL);
}

//+---------------------------------------------------------------------------
//
// _Uninit
//
//----------------------------------------------------------------------------

void CSnoopWnd::_Uninit()
{
    if (_hWnd != NULL)
    {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// _Show
//
//----------------------------------------------------------------------------

void CSnoopWnd::_Show()
{
    ShowWindow(_hWnd, SW_SHOWNA);
}

//+---------------------------------------------------------------------------
//
// _Hide
//
//----------------------------------------------------------------------------

void CSnoopWnd::_Hide()
{
    ShowWindow(_hWnd, SW_HIDE);
}

//+---------------------------------------------------------------------------
//
// _UpdateText
//
//----------------------------------------------------------------------------

void CSnoopWnd::_UpdateText(ITfRange *pRange)
{
    ITfDocumentMgr *pdmFocus;
    ITfContext *pContext;
    CUpdateTextEditSession *pEditSession;
    HRESULT hr;

    if (pRange == NULL)
    {
        // caller wants us to just use the selection in the focus doc
        if (_pCase->_GetThreadMgr()->GetFocus(&pdmFocus) != S_OK)
            return;

        hr = pdmFocus->GetTop(&pContext);

        pdmFocus->Release();

        if (hr != S_OK)
            return;
    }
    else if (pRange->GetContext(&pContext) != S_OK)
        return;

    if (pEditSession = new CUpdateTextEditSession(pContext, pRange, this))
    {
        // we need a document read lock to scan text
        // the CUpdateTextEditSession will do all the work when the
        // CUpdateTextEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_pCase->_GetClientId(), pEditSession, TF_ES_READ | TF_ES_ASYNCDONTCARE, &hr);

        pEditSession->Release();
    }

    pContext->Release();
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CUpdateTextEditSession::DoEditSession(TfEditCookie ec)
{
    _pSnoopWnd->_UpdateText(ec, _pContext, _pRange);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _UpdateText
//
//----------------------------------------------------------------------------

void CSnoopWnd::_UpdateText(TfEditCookie ec, ITfContext *pContext, ITfRange *pRange)
{
    LONG cchBefore;
    LONG cchAfter;
    TF_SELECTION tfSelection;
    ULONG cFetched;
    BOOL fReleaseRange = FALSE;

    if (pRange == NULL)
    {
        // caller wants us to use the selection
        if (pContext->GetSelection(ec, TS_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
            cFetched != 1)
        {
            return;
        }

        pRange = tfSelection.range; // no AddRef, take ownership of the pointer
        fReleaseRange = TRUE;
    }

    // arbitrarily grab some text before and after the range start anchor

    pRange->Collapse(ec, TF_ANCHOR_START);

    pRange->ShiftStart(ec, -MAX_SNOOP_TEXT / 2, &cchBefore, NULL);

    cchBefore = -cchBefore; // we shifted backwards, so make count a positive number

    pRange->GetText(ec, 0, _achText, cchBefore, (ULONG *)&cchBefore);

    pRange->Collapse(ec, TF_ANCHOR_END);

    pRange->ShiftEnd(ec, MAX_SNOOP_TEXT - cchBefore, &cchAfter, NULL);

    pRange->GetText(ec, 0, _achText + cchBefore, cchAfter, (ULONG *)&cchAfter);

    _cchText = cchBefore + cchAfter;

    // force a repaint

    InvalidateRect(_hWnd, NULL, TRUE);

    if (fReleaseRange)
    {
        pRange->Release();
    }
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
// Snoop window proc.
//----------------------------------------------------------------------------

/* static */
LRESULT CALLBACK CSnoopWnd::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;

    switch (uMsg)
    {
        case WM_CREATE:
            _SetThis(hWnd, lParam);
            return 0;

        case WM_PAINT:
            hdc = BeginPaint(hWnd, &ps);
            _GetThis(hWnd)->_OnPaint(hWnd, hdc);
            EndPaint(hWnd, &ps);
            return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _OnPaint
//
// WM_PAINT handler for CSnoopWnd.
//----------------------------------------------------------------------------

void CSnoopWnd::_OnPaint(HWND hWnd, HDC hdc)
{
    RECT rc;

    // background
    GetClientRect(hWnd, &rc);
    FillRect(hdc, &rc, (HBRUSH)GetStockObject(LTGRAY_BRUSH));

    // text
    TextOutW(hdc, 0, 0, _achText, _cchText);
}

//+---------------------------------------------------------------------------
//
// _InitSnoopWnd
//
// Create and init the snoop window.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitSnoopWnd()
{
    BOOL fThreadfocus;
    ITfSource *pSource = NULL;

    // create a snoop window

    if ((_pSnoopWnd = new CSnoopWnd(this)) == NULL)
        return FALSE;

    if (!_pSnoopWnd->_Init())
        goto ExitError;

    // we also need a thread focus sink

    if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) != S_OK)
    {
        pSource = NULL;
        goto ExitError;
    }

    if (pSource->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &_dwThreadFocusSinkCookie) != S_OK)
    {
        // make sure we don't try to Unadvise _dwThreadFocusSinkCookie later
        _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
        goto ExitError;
    }

    pSource->Release();

    // we may need to display the snoop window right now
    // our thread focus sink won't be called until something changes,
    // so we need to check the current state.

    if (_pThreadMgr->IsThreadFocus(&fThreadfocus) == S_OK && fThreadfocus)
    {
        OnSetThreadFocus();
    }

    return TRUE;

ExitError:
    SafeRelease(pSource);
    _UninitSnoopWnd();
    return FALSE;
}

//+---------------------------------------------------------------------------
//
// _UninitSnoopWnd
//
// Uninit and free the snoop window, unadvise the thread focus sink.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitSnoopWnd()
{
    ITfSource *pSource;

    if (_pSnoopWnd != NULL)
    {
        _pSnoopWnd->_Uninit();
        delete _pSnoopWnd;
    }

    if (_dwThreadFocusSinkCookie != TF_INVALID_COOKIE)
    {
        if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
        {
            pSource->UnadviseSink(_dwThreadFocusSinkCookie);
            pSource->Release();
        }

        _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
    }
}

//+---------------------------------------------------------------------------
//
// _Menu_ShowSnoopWnd
//
// Show or hide the snoop window.
//----------------------------------------------------------------------------

void CCaseTextService::_Menu_ShowSnoopWnd(CCaseTextService *_this)
{
    _this->_fShowSnoop = !_this->_fShowSnoop;

    if (_this->_fShowSnoop)
    {
        _this->_pSnoopWnd->_Show();
    }
    else
    {
        _this->_pSnoopWnd->_Hide();
    }
}

//+---------------------------------------------------------------------------
//
// OnSetThreadFocus
//
// Called by the system when the thread/appartment of this text service gains
// the ui focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnSetThreadFocus()
{
    if (_fShowSnoop)
    {
        _pSnoopWnd->_Show();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKillThreadFocus
//
// Called by the system when the thread/appartment of this text service loses
// the ui focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnKillThreadFocus()
{
    // only show our snoop window when our thread has the focus.
    if (_fShowSnoop)
    {
        _pSnoopWnd->_Hide();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\compose.cpp ===
//
// compose.cpp
//
// Composition code.
//

#include "globals.h"
#include "mark.h"
#include "editsess.h"

class CCompositionEditSession : public CEditSessionBase
{
public:
    CCompositionEditSession(ITfContext *pContext, CMarkTextService *pMark) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
    }
    ~CCompositionEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    CMarkTextService *_pMark;
};

class CTerminateCompositionEditSession : public CEditSessionBase
{
public:
    CTerminateCompositionEditSession(CMarkTextService *pMark, ITfContext *pContext) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
    }
    ~CTerminateCompositionEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec)
    {
        _pMark->_TerminateComposition(ec);
        return S_OK;
    }

private:
    CMarkTextService *_pMark;
};

//+---------------------------------------------------------------------------
//
// _TerminateCompositionInContext
//
//----------------------------------------------------------------------------

void CMarkTextService::_TerminateCompositionInContext(ITfContext *pContext)
{
    CTerminateCompositionEditSession *pEditSession;
    HRESULT hr;

    if (pEditSession = new CTerminateCompositionEditSession(this, pContext))
    {
        pContext->RequestEditSession(_tfClientId, pEditSession, TF_ES_ASYNCDONTCARE | TF_ES_READWRITE, &hr);
        pEditSession->Release();
    }
}

//+---------------------------------------------------------------------------
//
// _Menu_OnComposition
//
// Callback for the "Start/End Composition" menu item.
// If we have a composition, end it.  Otherwise start a new composition over
// the selection of the current focus context.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnComposition(CMarkTextService *_this)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CCompositionEditSession *pCompositionEditSession;
    HRESULT hr;

    // get the focus document
    if (_this->_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pCompositionEditSession = new CCompositionEditSession(pContext, _this))
    {
        // we need a document write lock
        // the CCompositionEditSession will do all the work when the
        // CCompositionEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_this->_tfClientId, pCompositionEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pCompositionEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();    
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CCompositionEditSession::DoEditSession(TfEditCookie ec)
{
    ITfInsertAtSelection *pInsertAtSelection;
    ITfContextComposition *pContextComposition;
    ITfComposition *pComposition;
    ITfRange *pRangeComposition;
    ITfRange *pRangeInsert;
    ITfContext *pCompositionContext;
    HRESULT hr;
    BOOL fEqualContexts;

    // get an interface on the context we can use to deal with compositions
    if (_pContext->QueryInterface(IID_ITfContextComposition, (void **)&pContextComposition) != S_OK)
        return E_FAIL;

    hr = E_FAIL;

    pInsertAtSelection = NULL;

    if (_pMark->_IsComposing())
    {
        // we have a composition, let's terminate it
        
        // it's possible our current composition is in another context...let's find out
        fEqualContexts = TRUE;
        if (_pMark->_GetComposition()->GetRange(&pRangeComposition) == S_OK)
        {
            if (pRangeComposition->GetContext(&pCompositionContext) == S_OK)
            {
                fEqualContexts = IsEqualUnknown(pCompositionContext, _pContext);
                if (!fEqualContexts)
                {
                    // need an edit session in the composition context
                    _pMark->_TerminateCompositionInContext(pCompositionContext);
                }
                pCompositionContext->Release();
            }
            pRangeComposition->Release();
        }

        // if the composition is in pContext, we already have an edit cookie
        if (fEqualContexts)
        {
            _pMark->_TerminateComposition(ec);
        }
    }
    else
    {
        // let's start a new composition over the current selection
        // this is totally contrived, a real text service would have
        // some meaningful logic to trigger this

        // first, test where a keystroke would go in the document if we did an insert
        // we need a special interface to insert text at the selection
        if (_pContext->QueryInterface(IID_ITfInsertAtSelection, (void **)&pInsertAtSelection) != S_OK)
        {
            pInsertAtSelection = NULL;
            goto Exit;
        }

        if (pInsertAtSelection->InsertTextAtSelection(ec, TF_IAS_QUERYONLY, NULL, 0, &pRangeInsert) != S_OK)
            goto Exit;

        // start the composition
        if (pContextComposition->StartComposition(ec, pRangeInsert, _pMark, &pComposition) != S_OK)
        {
            pComposition = NULL;
        }

        pRangeInsert->Release();

        // _pComposition may be NULL even if StartComposition return S_OK, this mean the application
        // rejected the composition

        if (pComposition != NULL)
        {
            _pMark->_SetComposition(pComposition);
            // underline the composition text to give the user some feedback UI
            _pMark->_SetCompositionDisplayAttributes(ec);
        }
    }

    // if we make it here, we've succeeded
    hr = S_OK;

Exit:
    SafeRelease(pInsertAtSelection);
    pContextComposition->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// OnCompositionTerminated
//
// Callback for ITfCompositionSink.  The system calls this method whenever
// someone other than this service ends a composition.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition)
{
    // we already have the composition cached, so we can ignore pComposition...

    // all this service wants to do is clear the display property
    _ClearCompositionDisplayAttributes(ecWrite);

    // releae our cached composition
    SafeReleaseClear(_pComposition);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _ClearCompositionDisplayAttributes
//
//----------------------------------------------------------------------------

void CMarkTextService::_ClearCompositionDisplayAttributes(TfEditCookie ec)
{
    ITfRange *pRangeComposition;
    ITfContext *pContext;
    ITfProperty *pDisplayAttributeProperty;

    // we need a range and the context it lives in
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        return;

    if (pRangeComposition->GetContext(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    // get our the display attribute property
    if (pContext->GetProperty(GUID_PROP_ATTRIBUTE, &pDisplayAttributeProperty) != S_OK)
        goto Exit;

    // clear the value over the range
    pDisplayAttributeProperty->Clear(ec, pRangeComposition);

    pDisplayAttributeProperty->Release();

Exit:
    pRangeComposition->Release();
    SafeRelease(pContext);
}

//+---------------------------------------------------------------------------
//
// _SetCompositionDisplayAttributes
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_SetCompositionDisplayAttributes(TfEditCookie ec)
{
    ITfRange *pRangeComposition;
    ITfContext *pContext;
    ITfProperty *pDisplayAttributeProperty;
    VARIANT var;
    HRESULT hr;

    // we need a range and the context it lives in
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        return FALSE;

    hr = E_FAIL;

    if (pRangeComposition->GetContext(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    // get our the display attribute property
    if (pContext->GetProperty(GUID_PROP_ATTRIBUTE, &pDisplayAttributeProperty) != S_OK)
        goto Exit;

    // set the value over the range
    // the application will use this guid atom to lookup the acutal rendering information
    var.vt = VT_I4; // we're going to set a TfGuidAtom
    var.lVal = _gaDisplayAttribute; // our cached guid atom for c_guidMarkDisplayAttribute

    hr = pDisplayAttributeProperty->SetValue(ec, pRangeComposition, &var);

    pDisplayAttributeProperty->Release();

Exit:
    pRangeComposition->Release();
    SafeRelease(pContext);
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _InitDisplayAttributeGuidAtom
//
// Because it's expensive to map our display attribute GUID to a TSF
// TfGuidAtom, we do it once when Activate is called.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitDisplayAttributeGuidAtom()
{
    ITfCategoryMgr *pCategoryMgr;
    HRESULT hr;

    if (CoCreateInstance(CLSID_TF_CategoryMgr,
                         NULL, 
                         CLSCTX_INPROC_SERVER, 
                         IID_ITfCategoryMgr, 
                         (void**)&pCategoryMgr) != S_OK)
    {
        return FALSE;
    }

    hr = pCategoryMgr->RegisterGUID(c_guidMarkDisplayAttribute, &_gaDisplayAttribute);

    pCategoryMgr->Release();
        
    return (hr == S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\dllmain.cpp ===
//
// dllmain.cpp
//
// DllMain module entry point.
//

#include "globals.h"

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            g_hInst = hInstance;

            InitializeCriticalSection(&g_cs);

            break;

        case DLL_PROCESS_DETACH:

            DeleteCriticalSection(&g_cs);

            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\cleanup.cpp ===
//
// cleanup.cpp
//
// ITfCleanupContextDurationSink, ITfCleanupContextSink implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// ITfCleanupContextDurationSink::OnStartCleanupContext
//
// TSF calls this method before it starts making OnCleanupContext callbacks.
// When this happens, we know we're just about to be shut down, and this will
// be our last chance to modify text in the document.  So we'll set a flag so
// we know not to initialize any contexts that might get created during the
// shutdown.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnStartCleanupContext()
{
    _fCleaningUp = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ITfCleanupContextDurationSink::OnEndCleanupContext
//
// Clear the cleanup flag.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnEndCleanupContext()
{
    _fCleaningUp = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ITfCleanupContextSink::OnCleanupContext
//
// The system calls this method if we're about to be deactivated.  It's our
// last chance to modify text in the context.  This is the time to abort any
// ongoing compositions.
//
// You won't see this callback shutting down the app if the app destroys all
// contexts before deactivating TSF.  Another way to get here is by installing
// a non-english keyboard layout or text service.  If you switch languages
// from english, the mark text service will be shut down before the context,
// and this method will be called.
//
// There's intentionally no way to get an edit cookie when a context is popped.
// In this case, it is assumed the context state is going to be thrown away.
// It's the owner's responsibility to terminate any compositions/text services
// before a Pop if they care about the contents afterwards.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnCleanupContext(TfEditCookie ecWrite, ITfContext *pContext)
{
    // this sample has nothing to do here...a real text service wouldn't bother
    // to advise the sink in the first place if it took no action
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitCleanupContextSink
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitCleanupContextDurationSink()
{
    return AdviseSingleSink(_tfClientId, _pThreadMgr, (ITfCleanupContextDurationSink *)this,
                            IID_ITfCleanupContextDurationSink);
}

//+---------------------------------------------------------------------------
//
// _UninitCleanupContextSink
//
//----------------------------------------------------------------------------

void CMarkTextService::_UninitCleanupContextDurationSink()
{
    UnadviseSingleSink(_tfClientId, _pThreadMgr, IID_ITfCleanupContextDurationSink);
}

//+---------------------------------------------------------------------------
//
// _InitCleanupContextSink
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitCleanupContextSink(ITfContext *pContext)
{
    return AdviseSingleSink(_tfClientId, pContext, (ITfCleanupContextSink *)this,
                            IID_ITfCleanupContextSink);
}

//+---------------------------------------------------------------------------
//
// _UninitCleanupContextSink
//
//----------------------------------------------------------------------------

void CMarkTextService::_UninitCleanupContextSink(ITfContext *pContext)
{
    UnadviseSingleSink(_tfClientId, pContext, IID_ITfCleanupContextSink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\compart.cpp ===
//
// compart.cpp
//
// Compartment example.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// _InitCompartment
//
// Initialize a compartment on a particular context.
//
// The Mark sample doesn't really do any with its context compartment, this
// code is purely for demonstration purposes.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitContextCompartment(ITfContext *pContext)
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;
    VARIANT varValue;
    HRESULT hr;

    // we want the mgr associated with pContext
    if (pContext->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompartmentMgr) != S_OK)
        return FALSE;

    hr = E_FAIL;

    if (pCompartmentMgr->GetCompartment(c_guidMarkContextCompartment, &pCompartment) != S_OK)
        goto Exit;

    // if we don't initialize the value, it will be VT_EMPTY
    // but let's initialize it to 0

    // NB: to keep things simple, we use a VT_I4
    // but you could use VT_UNKNOWN and store a pointer to anything
    varValue.vt = VT_I4;
    varValue.lVal = 0; // arbitrary value

    hr = pCompartment->SetValue(_tfClientId, &varValue);

    pCompartment->Release();

Exit:
    pCompartmentMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitCompartment
//
// Uninitialize a compartment on a particular context.
//
// The Mark sample doesn't really do any with its context compartment, this
// code is purely for demonstration purposes.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitCompartment(ITfContext *pContext)
{
    ITfCompartmentMgr *pCompartmentMgr;

    // we want the mgr associated with pContext
    if (pContext->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompartmentMgr) != S_OK)
        return;

    pCompartmentMgr->ClearCompartment(_tfClientId, c_guidMarkContextCompartment);

    pCompartmentMgr->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnSetGlobalCompartment
//
// Callback for the "Set Global Compartment" menu item.
// Set the value of our global compartment.  This will trigger a callback
// on our compartment change sinks in every thread/instance of this service.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnSetGlobalCompartment(CMarkTextService *_this)
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;
    VARIANT varValue;

    // we want the global mgr
    if (_this->_pThreadMgr->GetGlobalCompartment(&pCompartmentMgr) != S_OK)
        return;

    if (pCompartmentMgr->GetCompartment(c_guidMarkGlobalCompartment, &pCompartment) != S_OK)
    {
        pCompartment = NULL;
        goto Exit;
    }

    // let's toggle the value
    // notice that global compartments are persisted, unlike all others
    if (FAILED(pCompartment->GetValue(&varValue))) // will return S_FALSE if varValue.vt == VT_EMPTY
        goto Exit;

    if (varValue.vt == VT_EMPTY)
    {
        // if we get here, the compartment has never been initialized
        varValue.vt = VT_I4;
        varValue.lVal = 0;
    }

    // toggle value
    varValue.lVal = ~varValue.lVal;

    pCompartment->SetValue(_this->_tfClientId, &varValue);

Exit:
    SafeRelease(pCompartment);
    pCompartmentMgr->Release();
}

//+---------------------------------------------------------------------------
//
// _InitGlobalCompartment
//
// Ininit a change sink on our global compartment.  The system will call us
// back anytime the compartment is modified from any thread in the desktop.
//
// NB: ITfCompartmentEventSink's attached to thread local compartments will
// only get callbacks to changes that occur within a single thread.  Global
// compartments are different.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitGlobalCompartment()
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;
    BOOL fRet;

    // we want the global mgr
    if (_pThreadMgr->GetGlobalCompartment(&pCompartmentMgr) != S_OK)
        return FALSE;

    fRet = FALSE;

    if (pCompartmentMgr->GetCompartment(c_guidMarkGlobalCompartment, &pCompartment) != S_OK)
        goto Exit;

    fRet = AdviseSink(pCompartment, (ITfCompartmentEventSink *)this,
                      IID_ITfCompartmentEventSink, &_dwGlobalCompartmentEventSinkCookie);

    pCompartment->Release();

    if (!fRet)
    {
        // don't try to unadvise a bogus cookie later
        _dwGlobalCompartmentEventSinkCookie = TF_INVALID_COOKIE;
    }

Exit:
    pCompartmentMgr->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitCompartment
//
// Unitialize the global compartment if we have previously accessed it.
// This method only frees resources the system has allocated in this thread.
// Other threads can still access the global compartment, and the value (which
// is persisted across the desktop) does not change.
//
// Also, uninit the change sink we attached to the compartment.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitGlobalCompartment()
{
    ITfCompartmentMgr *pCompartmentMgr;
    ITfCompartment *pCompartment;

    // we want the global mgr
    if (_pThreadMgr->GetGlobalCompartment(&pCompartmentMgr) != S_OK)
        return;

    // unadvise our event sink
    if (pCompartmentMgr->GetCompartment(c_guidMarkGlobalCompartment, &pCompartment) == S_OK)
    {
        UnadviseSink(pCompartment, &_dwGlobalCompartmentEventSinkCookie);
        pCompartment->Release();
    }

    // let the system free resources associated with the compartment on this
    // thread
    pCompartmentMgr->ClearCompartment(_tfClientId, c_guidMarkGlobalCompartment);

    pCompartmentMgr->Release();
}

//+---------------------------------------------------------------------------
//
// ITfCompartmentEventSink::OnChange
//
// TSF calls this method anytime our private global compartment is modified,
// even from other threads/processes.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnChange(REFGUID rguidCompartment)
{
    // nothing to do in this sample
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\case\tmgrsink.cpp ===
//
// tmgrsink.cpp
//
// ITfThreadMgrEventSink implementation.
//

#include "globals.h"
#include "case.h"
#include "snoop.h"

//+---------------------------------------------------------------------------
//
// OnInitDocumentMgr
//
// Sink called by the framework just before the first context is pushed onto
// a document.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnInitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUninitDocumentMgr
//
// Sink called by the framework just after the last context is popped off a
// document.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Sink called by the framework when focus changes from one document to
// another.  Either document may be NULL, meaning previously there was no
// focus document, or now no document holds the input focus.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus)
{
    // track text changes on the focus doc
    // we are guarenteed a final OnSetFocus(NULL, ..) which we use for cleanup
    _InitTextEditSink(pDocMgrFocus);

    // let's update the snoop window with text from the new focus context
    _pSnoopWnd->_UpdateText(NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPushContext
//
// Sink called by the framework when a context is pushed.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnPushContext(ITfContext *pContext)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPopContext
//
// Sink called by the framework when a context is popped.
//----------------------------------------------------------------------------

STDAPI CCaseTextService::OnPopContext(ITfContext *pContext)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitThreadMgrSink
//
// Advise our sink.
//----------------------------------------------------------------------------

BOOL CCaseTextService::_InitThreadMgrSink()
{
    ITfSource *pSource;
    BOOL fRet;

    if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) != S_OK)
        return FALSE;

    fRet = FALSE;

    if (pSource->AdviseSink(IID_ITfThreadMgrEventSink, (ITfThreadMgrEventSink *)this, &_dwThreadMgrEventSinkCookie) != S_OK)
    {
        // make sure we don't try to Unadvise _dwThreadMgrEventSinkCookie later
        _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
        goto Exit;
    }

    fRet = TRUE;

Exit:
    pSource->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitThreadMgrSink
//
// Unadvise our sink.
//----------------------------------------------------------------------------

void CCaseTextService::_UninitThreadMgrSink()
{
    ITfSource *pSource;

    if (_dwThreadMgrEventSinkCookie == TF_INVALID_COOKIE)
        return; // never Advised

    if (_pThreadMgr->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        pSource->UnadviseSink(_dwThreadMgrEventSinkCookie);
        pSource->Release();
    }

    _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\dap.cpp ===
//
// dap.cpp
//
// ITfDisplayAttributeProvider implementation.
//

#include "globals.h"
#include "mark.h"

static const TCHAR c_szAttributeInfoKey[] = TEXT("Software\\Mark Text Service");
static const TCHAR c_szAttributeInfoValueName[] = TEXT("DisplayAttr");

// this text service has only a single display attribute so we'll use
// a single static object.
class CDisplayAttributeInfo : public ITfDisplayAttributeInfo
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return DllAddRef();
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        return DllRelease();
    }

    // ITfDisplayAttributeInfo
    STDMETHODIMP GetGUID(GUID *pguid);
    STDMETHODIMP GetDescription(BSTR *pbstrDesc);
    STDMETHODIMP GetAttributeInfo(TF_DISPLAYATTRIBUTE *ptfDisplayAttr);
    STDMETHODIMP SetAttributeInfo(const TF_DISPLAYATTRIBUTE *ptfDisplayAttr);
    STDMETHODIMP Reset();

private:
    static const TF_DISPLAYATTRIBUTE _c_DefaultDisplayAttribute;
}
g_DisplayAttributeInfo;

const TF_DISPLAYATTRIBUTE CDisplayAttributeInfo::_c_DefaultDisplayAttribute =
{
    { TF_CT_COLORREF, RGB(255, 0, 0) },     // text color
    { TF_CT_NONE, 0 },                      // background color (TF_CT_NONE => app default)
    TF_LS_SOLID,                            // underline style
    FALSE,                                  // underline boldness
    { TF_CT_COLORREF, RGB(255, 0, 0) },     // underline color
    TF_ATTR_INPUT                           // attribute info
};

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfDisplayAttributeInfo))
    {
        *ppvObj = (ITfDisplayAttributeInfo *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// GetGUID
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::GetGUID(GUID *pguid)
{
    if (pguid == NULL)
        return E_INVALIDARG;

    *pguid = c_guidMarkDisplayAttribute;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDescription
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::GetDescription(BSTR *pbstrDesc)
{
    BSTR bstrDesc;

    if (pbstrDesc == NULL)
        return E_INVALIDARG;

    *pbstrDesc = NULL;

    if ((bstrDesc = SysAllocString(L"Mark Display Attribute")) == NULL)
        return E_OUTOFMEMORY;

    *pbstrDesc = bstrDesc;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::GetAttributeInfo(TF_DISPLAYATTRIBUTE *ptfDisplayAttr)
{
    HKEY hKeyAttributeInfo;
    LONG lResult;
    DWORD cbData;

    if (ptfDisplayAttr == NULL)
        return E_INVALIDARG;

    lResult = E_FAIL;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szAttributeInfoKey, 0, KEY_READ, &hKeyAttributeInfo) == ERROR_SUCCESS)
    {
        cbData = sizeof(*ptfDisplayAttr);

        lResult = RegQueryValueEx(hKeyAttributeInfo, c_szAttributeInfoValueName,
                                  NULL, NULL,
                                  (LPBYTE)ptfDisplayAttr, &cbData);

        RegCloseKey(hKeyAttributeInfo);
    }

    if (lResult != ERROR_SUCCESS || cbData != sizeof(*ptfDisplayAttr))
    {
        // go with the defaults
        *ptfDisplayAttr = _c_DefaultDisplayAttribute;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// SetAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::SetAttributeInfo(const TF_DISPLAYATTRIBUTE *ptfDisplayAttr)
{
    HKEY hKeyAttributeInfo;
    LONG lResult;

    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, c_szAttributeInfoKey, 0, TEXT(""),
                             REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                             &hKeyAttributeInfo, NULL);

    if (lResult != ERROR_SUCCESS)
        return E_FAIL;

    lResult = RegSetValueEx(hKeyAttributeInfo, c_szAttributeInfoValueName,
                            0, REG_BINARY, (const BYTE *)ptfDisplayAttr,
                            sizeof(*ptfDisplayAttr));

    RegCloseKey(hKeyAttributeInfo);

    return (lResult == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

STDAPI CDisplayAttributeInfo::Reset()
{
    return SetAttributeInfo(&_c_DefaultDisplayAttribute);
}

class CEnumDisplayAttributeInfo : public IEnumTfDisplayAttributeInfo
{
public:
    CEnumDisplayAttributeInfo();
    ~CEnumDisplayAttributeInfo();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumTfDisplayAttributeInfo
    STDMETHODIMP Clone(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP Next(ULONG ulCount, ITfDisplayAttributeInfo **rgInfo, ULONG *pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    LONG _iIndex; // next display attribute to enum
    LONG _cRef; // COM ref count
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::CEnumDisplayAttributeInfo()
{
    DllAddRef();

    _iIndex = 0;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CEnumDisplayAttributeInfo::~CEnumDisplayAttributeInfo()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumTfDisplayAttributeInfo))
    {
        *ppvObj = (IEnumTfDisplayAttributeInfo *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CEnumDisplayAttributeInfo::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CEnumDisplayAttributeInfo::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Clone
//
// Returns a copy of the object.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Clone(IEnumTfDisplayAttributeInfo **ppEnum)
{
    CEnumDisplayAttributeInfo *pClone;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pClone = new CEnumDisplayAttributeInfo) == NULL)
        return E_OUTOFMEMORY;

    // the clone should match this object's state
    pClone->_iIndex = _iIndex;

    *ppEnum = pClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
// Returns an array of display attribute info objects supported by this service.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Next(ULONG ulCount, ITfDisplayAttributeInfo **rgInfo, ULONG *pcFetched)
{
    ULONG cFetched;

    if (pcFetched == NULL)
    {
        // technically this is only legal if ulCount == 1, but we won't check
        pcFetched = &cFetched;
    }

    *pcFetched = 0;

    if (ulCount == 0)
        return S_OK;

    // we only have a single display attribute to enum, so this is trivial

    if (_iIndex == 0)
    {
        *rgInfo = &g_DisplayAttributeInfo;
        (*rgInfo)->AddRef();
        *pcFetched = 1;
        _iIndex++;
    }

    return (*pcFetched == ulCount) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
// Reset
//
// Resets the enumeration.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Reset()
{
    _iIndex = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
// Skips past objects in the enumeration.
//----------------------------------------------------------------------------

STDAPI CEnumDisplayAttributeInfo::Skip(ULONG ulCount)
{
    // we have only a single item to enum
    // so we can just skip it and avoid any overflow errors
    if (ulCount > 0 && _iIndex == 0)
    {
        _iIndex++;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// EnumDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum)
{
    CEnumDisplayAttributeInfo *pAttributeEnum;

    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    if ((pAttributeEnum = new CEnumDisplayAttributeInfo) == NULL)
        return E_OUTOFMEMORY;

    *ppEnum = pAttributeEnum;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDisplayAttributeInfo
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::GetDisplayAttributeInfo(REFGUID guidInfo, ITfDisplayAttributeInfo **ppInfo)
{
    if (ppInfo == NULL)
        return E_INVALIDARG;

    *ppInfo = NULL;

    // unsupported GUID?
    if (!IsEqualGUID(guidInfo, c_guidMarkDisplayAttribute))
        return E_INVALIDARG;

    *ppInfo = &g_DisplayAttributeInfo;
    (*ppInfo)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\precomp.cpp ===
//
// precomp.cpp
//
// Stub for vc precompiled header.
//

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\globals.cpp ===
//
// globals.cpp
//
// Global variables.
//

#include "globals.h"

HINSTANCE g_hInst;

LONG g_cRefDll = -1; // -1 /w no refs, for win95 InterlockedIncrement/Decrement compat

CRITICAL_SECTION g_cs;

/* 23e97bc9-f2d3-4b25-8ef3-d78391bf2150 */
const CLSID c_clsidMarkTextService = { 0x23e97bc9, 0xf2d3, 0x4b25, {0x8e, 0xf3, 0xd7, 0x83, 0x91, 0xbf, 0x21, 0x50} };

/* a2767f97-e735-461a-84ba-7a7ecad24827 */
const GUID c_guidMarkProfile = { 0xa2767f97, 0xe735, 0x461a, {0x84, 0xba, 0x7a, 0x7e, 0xca, 0xd2, 0x48, 0x27} };

/* c74a88d5-6614-439b-8880-2dd8e6cd91a7 */
const GUID c_guidLangBarItemButton = { 0xc74a88d5, 0x6614, 0x439b, {0x88, 0x80, 0x2d, 0xd8, 0xe6, 0xcd, 0x91, 0xa7} };

/* d81face6-845c-45e7-a2af-1c5fc7adf667 */
const GUID c_guidMarkDisplayAttribute = { 0xd81face6, 0x845c, 0x45e7, {0xa2, 0xaf, 0x1c, 0x5f, 0xc7, 0xad, 0xf6, 0x67} };

/* eadc084c-6130-4222-82e5-c528c1f4abbb */
const GUID c_guidMarkContextCompartment = { 0xeadc084c, 0x6130, 0x4222, {0x82, 0xe5, 0xc5, 0x28, 0xc1, 0xf4, 0xab, 0xbb} };

/* 947d9d1c-7a4c-4392-b37c-34017c6c7fe1 */
const GUID c_guidMarkGlobalCompartment = { 0x947d9d1c, 0x7a4c, 0x4392, {0xb3, 0x7c, 0x34, 0x01, 0x7c, 0x6c, 0x7f, 0xe1} };

/* 3042ae6a-4697-4f7d-acdf-20a972fee027 */
const GUID c_guidCaseProperty = { 0x3042ae6a, 0x4697, 0x4f7d, {0xac, 0xdf, 0x20, 0xa9, 0x72, 0xfe, 0xe0, 0x27} };

/* d05a182a-7782-4e61-a2ea-6a4794ab7aaa */
const GUID c_guidCustomProperty = { 0xd05a182a, 0x7782, 0x4e61, {0xa2, 0xea, 0x6a, 0x47, 0x94, 0xab, 0x7a, 0xaa} };

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

BOOL AdviseSink(IUnknown *pSourceIn, IUnknown *pSink, REFIID riid, DWORD *pdwCookie)
{
    ITfSource *pSource;
    HRESULT hr;

    if (pSourceIn->QueryInterface(IID_ITfSource, (void **)&pSource) != S_OK)
        return FALSE;

    hr = pSource->AdviseSink(riid, pSink, pdwCookie);

    pSource->Release();

    if (hr != S_OK)
    {
        // make sure we don't try to Unadvise pdwCookie later
        *pdwCookie = TF_INVALID_COOKIE;
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

void UnadviseSink(IUnknown *pSourceIn, DWORD *pdwCookie)
{
    ITfSource *pSource;

    if (*pdwCookie == TF_INVALID_COOKIE)
        return; // never Advised

    if (pSourceIn->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        pSource->UnadviseSink(*pdwCookie);
        pSource->Release();
    }

    *pdwCookie = TF_INVALID_COOKIE;
}

//+---------------------------------------------------------------------------
//
// AdviseSingleSink
//
//----------------------------------------------------------------------------

BOOL AdviseSingleSink(TfClientId tfClientId, IUnknown *pSourceIn, IUnknown *pSink, REFIID riid)
{
    ITfSourceSingle *pSource;
    HRESULT hr;

    if (pSourceIn->QueryInterface(IID_ITfSourceSingle, (void **)&pSource) != S_OK)
        return FALSE;

    hr = pSource->AdviseSingleSink(tfClientId, riid, pSink);

    pSource->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// UnadviseSingleSink
//
//----------------------------------------------------------------------------

void UnadviseSingleSink(TfClientId tfClientId, IUnknown *pSourceIn, REFIID riid)
{
    ITfSourceSingle *pSource;

    if (pSourceIn->QueryInterface(IID_ITfSourceSingle, (void **)&pSource) == S_OK)
    {
        pSource->UnadviseSingleSink(tfClientId, riid);
        pSource->Release();
    }
}

//+---------------------------------------------------------------------------
//
// IsRangeCovered
//
// Returns TRUE if pRangeTest is entirely contained within pRangeCover.
//----------------------------------------------------------------------------

BOOL IsRangeCovered(TfEditCookie ec, ITfRange *pRangeTest, ITfRange *pRangeCover)
{
    LONG lResult;

    if (pRangeCover->CompareStart(ec, pRangeTest, TF_ANCHOR_START, &lResult) != S_OK ||
        lResult > 0)
    {
        return FALSE;
    }

    if (pRangeCover->CompareEnd(ec, pRangeTest, TF_ANCHOR_END, &lResult) != S_OK ||
        lResult < 0)
    {
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// IsEqualUnknown
//
// Returns TRUE if punk1 and punk2 refer to the same object.  We must QI for
// IUnknown to be guarenteed a reliable test, per the COM rules.
//----------------------------------------------------------------------------

BOOL IsEqualUnknown(IUnknown *interface1, IUnknown *interface2)
{
    IUnknown *punk1;
    IUnknown *punk2;

    if (interface1->QueryInterface(IID_IUnknown, (void **)&punk1) != S_OK)
        return FALSE;

    punk1->Release(); // we don't actually need to dereference these guys, just want to compare them

    if (interface2->QueryInterface(IID_IUnknown, (void **)&punk2) != S_OK)
        return FALSE;

    punk2->Release();

    return (punk1 == punk2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\editsink.cpp ===
//
// editsink.cpp
//
// ITfTextEditSink implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// OnEndEdit
//
// Called by the system whenever anyone releases a write-access document lock.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    ITfRange *pRangeComposition;
    IEnumTfRanges *pEnumRanges;
    ITfRange *pRange;
    ITfContext *pCompositionContext;
    TF_SELECTION tfSelection;
    BOOL fResult;
    BOOL fCancelComposition;
    ULONG cFetched;

    if (_pComposition == NULL)
        return S_OK;

    // are we responsible for the edit?
    if (pContext->InWriteSession(_tfClientId, &fResult) == S_OK && fResult)
        return S_OK;

    // is this the context our composition lives in?
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        return S_OK;

    if (pRangeComposition->GetContext(&pCompositionContext) != S_OK)
        goto Exit;

    fResult = IsEqualUnknown(pCompositionContext, pContext);

    pCompositionContext->Release();

    if (!fResult)
        goto Exit; // different context

    fCancelComposition = FALSE;

    // we're composing in this context, cancel the composition if anything suspicious happened

    // did the selection move outside the composition?
    if (pEditRecord->GetSelectionStatus(&fResult) == S_OK && fResult)
    {
        if (pContext->GetSelection(ecReadOnly, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) == S_OK &&
            cFetched == 1)
        {
            if (_pComposition->GetRange(&pRangeComposition) == S_OK)
            {
                fResult = IsRangeCovered(ecReadOnly, tfSelection.range, pRangeComposition);

                pRangeComposition->Release();

                if (!fResult)
                {
                    fCancelComposition = TRUE;
                }
            }
            tfSelection.range->Release();
        }
    }

    if (fCancelComposition)
        goto CancelComposition;

    // did someone else edit the document text?
    if (pEditRecord->GetTextAndPropertyUpdates(TF_GTP_INCL_TEXT, NULL, 0, &pEnumRanges) == S_OK)
    {
        // is the enumerator empty?
        if (pEnumRanges->Next(1, &pRange, NULL) == S_OK)
        {
            pRange->Release();
            fCancelComposition = TRUE;
        }
        pEnumRanges->Release();
    }

    if (fCancelComposition)
    {
CancelComposition:
        // we need a write edit session to cancel the composition
        _TerminateCompositionInContext(pContext);
    }

Exit:
    pRangeComposition->Release();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitTextEditSink
//
// Init a text edit sink on the topmost context of the document.
// Always release any previous sink.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitTextEditSink(ITfDocumentMgr *pDocMgr)
{
    ITfSource *pSource;
    BOOL fRet;

    // clear out any previous sink first

    if (_dwTextEditSinkCookie != TF_INVALID_COOKIE)
    {
        if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
        {
            pSource->UnadviseSink(_dwTextEditSinkCookie);
            pSource->Release();
        }

        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
        _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    }

    if (pDocMgr == NULL)
        return TRUE; // caller just wanted to clear the previous sink

    // setup a new sink advised to the topmost context of the document

    if (pDocMgr->GetTop(&_pTextEditSinkContext) != S_OK)
        return FALSE;

    if (_pTextEditSinkContext == NULL)
        return TRUE; // empty document, no sink possible

    fRet = FALSE;

    if (_pTextEditSinkContext->QueryInterface(IID_ITfSource, (void **)&pSource) == S_OK)
    {
        if (pSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &_dwTextEditSinkCookie) == S_OK)
        {
            fRet = TRUE;
        }
        else
        {
            _dwTextEditSinkCookie = TF_INVALID_COOKIE;
        }
        pSource->Release();
    }

    if (fRet == FALSE)
    {
        _pTextEditSinkContext->Release();
        _pTextEditSinkContext = NULL;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\globals.h ===
//
// globals.h
//
// Global variable declarations.
//

#ifndef GLOBALS_H
#define GLOBALS_H

#include <windows.h>
#include <ole2.h>
#include <olectl.h>
#include <assert.h>
#include "msctf.h"

LONG DllAddRef();
LONG DllRelease();

BOOL AdviseSink(IUnknown *pSource, IUnknown *pSink, REFIID riid, DWORD *pdwCookie);
void UnadviseSink(IUnknown *pSource, DWORD *pdwCookie);

BOOL AdviseSingleSink(TfClientId tfClientId, IUnknown *pSource, IUnknown *pSink, REFIID riid);
void UnadviseSingleSink(TfClientId tfClientId, IUnknown *pSource, REFIID riid);

BOOL IsRangeCovered(TfEditCookie ec, ITfRange *pRangeTest, ITfRange *pRangeCover);

BOOL IsEqualUnknown(IUnknown *interface1, IUnknown *interface2);

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define MARK_LANGID    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)

#define MARK_DESC    L"Mark Text Service"
#define MARK_DESC_A   "Mark Text Service"
#define MARK_MODEL   TEXT("Apartment")

#define LANGBAR_ITEM_DESC L"Mark Menu" // max 32 chars!

#define MARK_ICON_INDEX  0

#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}                   

extern HINSTANCE g_hInst;

extern LONG g_cRefDll;

extern CRITICAL_SECTION g_cs;

extern const CLSID c_clsidMarkTextService;
extern const GUID c_guidMarkProfile;
extern const GUID c_guidLangBarItemButton;
extern const GUID c_guidMarkDisplayAttribute;
extern const GUID c_guidMarkContextCompartment;
extern const GUID c_guidMarkGlobalCompartment;
extern const GUID c_guidCaseProperty;
extern const GUID c_guidCustomProperty;

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\langbar.cpp ===
//
// langbar.cpp
//
// Language bar ui code.
//

#include "globals.h"
#include "mark.h"
#include "resource.h"

#define MARK_LANGBARITEMSINK_COOKIE 0x0fab0fab

const struct
{
    const WCHAR *pchDesc;
    void (*pfnHandler)(CMarkTextService *_this);
}
c_rgMenuItems[] =
{
    { L"Start/End Composition", CMarkTextService::_Menu_OnComposition },
    { L"Set Global Compartment", CMarkTextService::_Menu_OnSetGlobalCompartment },
    { L"Set Case Property", CMarkTextService::_Menu_OnSetCaseProperty },
    { L"Set Custom Property", CMarkTextService::_Menu_OnSetCustomProperty },
    { L"View Case Property", CMarkTextService::_Menu_OnViewCaseProperty },
    { L"View Custom Property", CMarkTextService::_Menu_OnViewCustomProperty },
};

class CLangBarItemButton : public ITfLangBarItemButton,
                           public ITfSource
{
public:
    CLangBarItemButton(CMarkTextService *pMark);
    ~CLangBarItemButton();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfLangBarItem
    STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    STDMETHODIMP GetStatus(DWORD *pdwStatus);
    STDMETHODIMP Show(BOOL fShow);
    STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);

    // ITfLangBarItemButton
    STDMETHODIMP OnClick(TfLBIClick click, POINT pt, const RECT *prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP GetIcon(HICON *phIcon);
    STDMETHODIMP GetText(BSTR *pbstrText);

    // ITfSource
    STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    STDMETHODIMP UnadviseSink(DWORD dwCookie);

private:
    CMarkTextService *_pMark;
    ITfLangBarItemSink *_pLangBarItemSink;
    TF_LANGBARITEMINFO _tfLangBarItemInfo;
    LONG _cRef;
};

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLangBarItemButton::CLangBarItemButton(CMarkTextService *pMark)
{
    DllAddRef();

    _tfLangBarItemInfo.clsidService = c_clsidMarkTextService;
    _tfLangBarItemInfo.guidItem = c_guidLangBarItemButton;
    _tfLangBarItemInfo.dwStyle = TF_LBI_STYLE_BTN_MENU;
    _tfLangBarItemInfo.ulSort = 0;
    memcpy(_tfLangBarItemInfo.szDescription, LANGBAR_ITEM_DESC, sizeof(LANGBAR_ITEM_DESC));

    _pMark = pMark;
    _pMark->AddRef();
    _pLangBarItemSink = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLangBarItemButton::~CLangBarItemButton()
{
    DllRelease();
    _pMark->Release();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem) ||
        IsEqualIID(riid, IID_ITfLangBarItemButton))
    {
        *ppvObj = (ITfLangBarItemButton *)this;
    }
    else if (IsEqualIID(riid, IID_ITfSource))
    {
        *ppvObj = (ITfSource *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CLangBarItemButton::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// GetInfo
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = _tfLangBarItemInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::Show(BOOL fShow)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetTooltipString(BSTR *pbstrToolTip)
{
    *pbstrToolTip = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrToolTip == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::InitMenu(ITfMenu *pMenu)
{
    int i;

    for (i=0; i<ARRAYSIZE(c_rgMenuItems); i++)
    {
        pMenu->AddMenuItem(i, 0, NULL, NULL, c_rgMenuItems[i].pchDesc, wcslen(c_rgMenuItems[i].pchDesc), NULL);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::OnMenuSelect(UINT wID)
{
    c_rgMenuItems[wID].pfnHandler(_pMark);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetIcon(HICON *phIcon)
{
    *phIcon = (HICON)LoadImage(g_hInst, TEXT("IDI_MARK"), IMAGE_ICON, 16, 16, 0);

    return (*phIcon != NULL) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::GetText(BSTR *pbstrText)
{
    *pbstrText = SysAllocString(LANGBAR_ITEM_DESC);

    return (*pbstrText == NULL) ? E_OUTOFMEMORY : S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    if (!IsEqualIID(IID_ITfLangBarItemSink, riid))
        return CONNECT_E_CANNOTCONNECT;

    if (_pLangBarItemSink != NULL)
        return CONNECT_E_ADVISELIMIT;

    if (punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&_pLangBarItemSink) != S_OK)
    {
        _pLangBarItemSink = NULL;
        return E_NOINTERFACE;
    }

    *pdwCookie = MARK_LANGBARITEMSINK_COOKIE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

STDAPI CLangBarItemButton::UnadviseSink(DWORD dwCookie)
{
    if (dwCookie != MARK_LANGBARITEMSINK_COOKIE)
        return CONNECT_E_NOCONNECTION;

    if (_pLangBarItemSink == NULL)
        return CONNECT_E_NOCONNECTION;

    _pLangBarItemSink->Release();
    _pLangBarItemSink = NULL;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitLanguageBar
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;
    BOOL fRet;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) != S_OK)
        return FALSE;

    fRet = FALSE;

    if ((_pLangBarItem = new CLangBarItemButton(this)) == NULL)
        goto Exit;

    if (pLangBarItemMgr->AddItem(_pLangBarItem) != S_OK)
    {
        _pLangBarItem->Release();
        _pLangBarItem = NULL;
        goto Exit;
    }

    fRet = TRUE;

Exit:
    pLangBarItemMgr->Release();
    return fRet;
}

//+---------------------------------------------------------------------------
//
// _UninitLanguageBar
//
//----------------------------------------------------------------------------

void CMarkTextService::_UninitLanguageBar()
{
    ITfLangBarItemMgr *pLangBarItemMgr;

    if (_pLangBarItem == NULL)
        return;

    if (_pThreadMgr->QueryInterface(IID_ITfLangBarItemMgr, (void **)&pLangBarItemMgr) == S_OK)
    {
        pLangBarItemMgr->RemoveItem(_pLangBarItem);
        pLangBarItemMgr->Release();
    }

    _pLangBarItem->Release();
    _pLangBarItem = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\mark.cpp ===
//
// mark.cpp
//
// IUnknown, ITfTextInputProcessor implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// CreateInstance
//
//----------------------------------------------------------------------------

/* static */
HRESULT CMarkTextService::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CMarkTextService *pMark;
    HRESULT hr;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if ((pMark = new CMarkTextService) == NULL)
        return E_OUTOFMEMORY;

    hr = pMark->QueryInterface(riid, ppvObj);

    pMark->Release(); // caller still holds ref if hr == S_OK

    return hr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CMarkTextService::CMarkTextService()
{
    DllAddRef();

    _pThreadMgr = NULL;
    _tfClientId = TF_CLIENTID_NULL;

    _pComposition = NULL;

    _fCleaningUp = FALSE;

    _gaDisplayAttribute = TF_INVALID_GUIDATOM;

    _pLangBarItem = NULL;

    _dwThreadMgrEventSinkCookie = TF_INVALID_COOKIE;
    _dwThreadFocusSinkCookie = TF_INVALID_COOKIE;
    _dwTextEditSinkCookie = TF_INVALID_COOKIE;
    _dwGlobalCompartmentEventSinkCookie = TF_INVALID_COOKIE;

    _pTextEditSinkContext = NULL;

    _hWorkerWnd = NULL;

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CMarkTextService::~CMarkTextService()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextInputProcessor))
    {
        *ppvObj = (ITfTextInputProcessor *)this;
    }
    else if (IsEqualIID(riid, IID_ITfDisplayAttributeProvider))
    {
        *ppvObj = (ITfDisplayAttributeProvider *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCreatePropertyStore))
    {
        *ppvObj = (ITfCreatePropertyStore *)this;
    }
    else if (IsEqualIID(riid, IID_ITfThreadMgrEventSink))
    {
        *ppvObj = (ITfThreadMgrEventSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = (ITfTextEditSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        *ppvObj = (ITfCleanupContextSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextDurationSink))
    {
        *ppvObj = (ITfCleanupContextDurationSink *)this;
    }
    else if (IsEqualIID(riid, IID_ITfCompartmentEventSink))
    {
        *ppvObj = (ITfCompartmentEventSink *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CMarkTextService::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CMarkTextService::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId)
{
    _pThreadMgr = pThreadMgr;
    _pThreadMgr->AddRef();

    _tfClientId = tfClientId;

    if (!_InitLanguageBar())
        goto ExitError;

    if (!_InitThreadMgrSink())
        goto ExitError;

    if (!_InitDisplayAttributeGuidAtom())
        goto ExitError;

    if (!_InitCleanupContextDurationSink())
        goto ExitError;

    if (!_InitGlobalCompartment())
        goto ExitError;

    if (!_InitWorkerWnd())
        goto ExitError;

    if (!_InitKeystrokeSink())
        goto ExitError;

    return S_OK;

ExitError:
    Deactivate(); // cleanup any half-finished init
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::Deactivate()
{
    _UninitThreadMgrSink();
    _UninitLanguageBar();
    _UninitCleanupContextDurationSink();
    _UninitGlobalCompartment();
    _UninitWorkerWnd();
    _UninitKeystrokeSink();
    _InitTextEditSink(NULL);

    // we MUST release all refs to _pThreadMgr in Deactivate
    SafeReleaseClear(_pThreadMgr);

    _tfClientId = TF_CLIENTID_NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\keys.cpp ===
//
// keys.cpp
//
// ITfKeyEventSink implementation.
//

#include "globals.h"
#include "mark.h"
#include "editsess.h"

class CKeystrokeEditSession : public CEditSessionBase
{
public:
    CKeystrokeEditSession(CMarkTextService *pMark, ITfContext *pContext, WPARAM wParam) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
        _wParam = wParam;
    }
    ~CKeystrokeEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec);

private:
    CMarkTextService *_pMark;
    WPARAM _wParam;
};

//+---------------------------------------------------------------------------
//
// _HandleArrowKey
//
// Returns S_OK to eat the keystroke, S_FALSE otherwise.
//----------------------------------------------------------------------------

HRESULT CMarkTextService::_HandleReturn(TfEditCookie ec, ITfContext *pContext)
{
    // just terminate the composition
    _TerminateComposition(ec);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _HandleArrowKey
//
// Update the selection within a composition.
// Returns S_OK to eat the keystroke, S_FALSE otherwise.
//----------------------------------------------------------------------------

HRESULT CMarkTextService::_HandleArrowKey(TfEditCookie ec, ITfContext *pContext, WPARAM wParam)
{
    ITfRange *pRangeComposition;
    LONG cch;
    BOOL fEqual;
    TF_SELECTION tfSelection;
    ULONG cFetched;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection?
        return S_OK; // eat the keystroke
    }

    // get the composition range
    if (_pComposition->GetRange(&pRangeComposition) != S_OK)
        goto Exit;

    // adjust the selection, we won't do anything fancy

    if (wParam == VK_LEFT)
    {
        if (tfSelection.range->IsEqualStart(ec, pRangeComposition, TF_ANCHOR_START, &fEqual) == S_OK &&
            !fEqual)
        {
            tfSelection.range->ShiftStart(ec, -1, &cch, NULL);
        }
        tfSelection.range->Collapse(ec, TF_ANCHOR_START);
    }
    else
    {
        // VK_RIGHT
        if (tfSelection.range->IsEqualEnd(ec, pRangeComposition, TF_ANCHOR_END, &fEqual) == S_OK &&
            !fEqual)
        {
            tfSelection.range->ShiftEnd(ec, +1, &cch, NULL);
        }
        tfSelection.range->Collapse(ec, TF_ANCHOR_END);
    }

    pContext->SetSelection(ec, 1, &tfSelection);

    pRangeComposition->Release();

Exit:
    tfSelection.range->Release();
    return S_OK; // eat the keystroke
}

//+---------------------------------------------------------------------------
//
// _HandleKeyDown
//
// If the keystroke happens within a composition, eat the key and return S_OK.
// Otherwise, do nothing and return S_FALSE.
//----------------------------------------------------------------------------

HRESULT CMarkTextService::_HandleKeyDown(TfEditCookie ec, ITfContext *pContext, WPARAM wParam)
{
    ITfRange *pRangeComposition;
    TF_SELECTION tfSelection;
    ULONG cFetched;
    HRESULT hr;
    WCHAR ch;
    BOOL fCovered;

    if (wParam < 'A' || wParam > 'Z')
        return S_OK; // just eat the key if it's not in a range we know how to handle

    hr = S_OK; // return S_FALSE to NOT eat the key

    // convert the wParam to a WCHAR
    if (GetKeyState(VK_SHIFT) & 0x8000)
    {
        // shift-key, leave it uppercase
        ch = wParam;
    }
    else
    {
        // else make it lowercase
        ch = wParam | 32;
    }

    // first, test where a keystroke would go in the document if we did an insert
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK || cFetched != 1)
        return S_FALSE;

    // is the insertion point covered by a composition?
    if (_pComposition->GetRange(&pRangeComposition) == S_OK)
    {
        fCovered = IsRangeCovered(ec, tfSelection.range, pRangeComposition);

        pRangeComposition->Release();

        if (!fCovered)
        {
            hr = S_FALSE; // don't eat the key, it's outside our composition
            goto Exit;
        }
    }

    // insert the text
    // we use SetText here instead of InsertTextAtSelection because we've already started a composition
    // we don't want to the app to adjust the insertion point inside our composition
    if (tfSelection.range->SetText(ec, 0, &ch, 1) != S_OK)
        goto Exit;

    // update the selection, we'll make it an insertion point just past
    // the inserted text.
    tfSelection.range->Collapse(ec, TF_ANCHOR_END);

    pContext->SetSelection(ec, 1, &tfSelection);

    // apply our dislay attribute property to the inserted text
    // we need to apply it to the entire composition, since the
    // display attribute property is static, not static compact
    _SetCompositionDisplayAttributes(ec);

Exit:
    tfSelection.range->Release();
    return hr;
}

//+---------------------------------------------------------------------------
//
// _InitKeystrokeSink
//
// Advise a keystroke sink.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;
    HRESULT hr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return FALSE;

    hr = pKeystrokeMgr->AdviseKeyEventSink(_tfClientId, (ITfKeyEventSink *)this, TRUE);

    pKeystrokeMgr->Release();

    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// _UninitKeystrokeSink
//
// Unadvise a keystroke sink.  Assumes we have advised one already.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitKeystrokeSink()
{
    ITfKeystrokeMgr *pKeystrokeMgr;

    if (_pThreadMgr->QueryInterface(IID_ITfKeystrokeMgr, (void **)&pKeystrokeMgr) != S_OK)
        return;

    pKeystrokeMgr->UnadviseKeyEventSink(_tfClientId);

    pKeystrokeMgr->Release();
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Called by the system whenever this service gets the keystroke device focus.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnSetFocus(BOOL fForeground)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTestKeyDown
//
// Called by the system to query if this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = (_pComposition != NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyDown
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//
// This text service is interested in handling keystrokes to demonstrate the
// use the compositions.  Some apps will cancel compositions if they receive
// keystrokes while a compositions is ongoing.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    CKeystrokeEditSession *pEditSession;
    HRESULT hr;

    hr = E_FAIL;
    *pfEaten = FALSE;

    if (_pComposition != NULL) // only eat keys while composing
    {
        // we'll insert a char ourselves in place of this keystroke
        if ((pEditSession = new CKeystrokeEditSession(this, pContext, wParam)) == NULL)
            goto Exit;

        // we need a lock to do our work
        // nb: this method is one of the few places where it is legal to use
        // the TF_ES_SYNC flag
        if (pContext->RequestEditSession(_tfClientId, pEditSession, TF_ES_SYNC | TF_ES_READWRITE, &hr) != S_OK)
        {
            hr = E_FAIL;
        }

        pEditSession->Release();
    }

Exit:
    // if we made it all the way to the RequestEditSession, then hr is ultimately the
    // return code from CKeystrokeEditSession::DoEditSession.  Our DoEditSession method
    // return S_OK to signal that the keystroke should be eaten, S_FALSE otherwise.
    if (hr == S_OK)
    {
        *pfEaten = TRUE;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// DoEditSession
//
//----------------------------------------------------------------------------

STDAPI CKeystrokeEditSession::DoEditSession(TfEditCookie ec)
{
    switch (_wParam)
    {
        case VK_LEFT:
        case VK_RIGHT:
            return _pMark->_HandleArrowKey(ec, _pContext, _wParam);

        case VK_RETURN:
            return _pMark->_HandleReturn(ec, _pContext);

        case VK_SPACE:
            return S_OK;
    }

    return _pMark->_HandleKeyDown(ec, _pContext, _wParam);
}

//+---------------------------------------------------------------------------
//
// OnTestKeyUp
//
// Called by the system to query this service wants a potential keystroke.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnKeyUp
//
// Called by the system to offer this service a keystroke.  If *pfEaten == TRUE
// on exit, the application will not handle the keystroke.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten)
{
    *pfEaten = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPreservedKey
//
// Called when a hotkey (registered by us, or by the system) is typed.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten)
{
    *pfEaten = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\mark.h ===
//
// mark.h
//
// CMarkTextService declaration.
//

#ifndef MARK_H
#define MARK_H

class CLangBarItemButton;

class CMarkTextService : public ITfTextInputProcessor,
                         public ITfDisplayAttributeProvider,
                         public ITfCreatePropertyStore,
                         public ITfThreadMgrEventSink,
                         public ITfTextEditSink,
                         public ITfCompositionSink,
                         public ITfCleanupContextDurationSink,
                         public ITfCleanupContextSink,
                         public ITfCompartmentEventSink,
                         public ITfKeyEventSink
{
public:
    CMarkTextService();
    ~CMarkTextService();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfTextInputProcessor
    STDMETHODIMP Activate(ITfThreadMgr *pThreadMgr, TfClientId tfClientId);
    STDMETHODIMP Deactivate();

    // ITfDisplayAttributeProvider
    STDMETHODIMP EnumDisplayAttributeInfo(IEnumTfDisplayAttributeInfo **ppEnum);
    STDMETHODIMP GetDisplayAttributeInfo(REFGUID guidInfo, ITfDisplayAttributeInfo **ppInfo);

    // ITfCreatePropertyStore
    STDMETHODIMP IsStoreSerializable(REFGUID guidProperty, ITfRange *pRange, ITfPropertyStore *pPropertyStore, BOOL *pfSerializable);
    STDMETHODIMP CreatePropertyStore(REFGUID guidProperty, ITfRange *pRange, ULONG cb, IStream *pStream, ITfPropertyStore **ppStore);

    // ITfThreadMgrEventSink
    STDMETHODIMP OnInitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr);
    STDMETHODIMP OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus);
    STDMETHODIMP OnPushContext(ITfContext *pContext);
    STDMETHODIMP OnPopContext(ITfContext *pContext);

    // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pContext, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfCompositionSink
    STDMETHODIMP OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition);

    // ITfCleanupContextDurationSink
    STDMETHODIMP OnStartCleanupContext();
    STDMETHODIMP OnEndCleanupContext();

    // ITfCleanupContextSink
    STDMETHODIMP OnCleanupContext(TfEditCookie ecWrite, ITfContext *pContext);

    // ITfCompartmentEventSink
    STDMETHODIMP OnChange(REFGUID rguidCompartment);

    // ITfKeyEventSink
    STDMETHODIMP OnSetFocus(BOOL fForeground);
    STDMETHODIMP OnTestKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyDown(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnTestKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnKeyUp(ITfContext *pContext, WPARAM wParam, LPARAM lParam, BOOL *pfEaten);
    STDMETHODIMP OnPreservedKey(ITfContext *pContext, REFGUID rguid, BOOL *pfEaten);

    // CClassFactory factory callback
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    // server registration
    static BOOL RegisterProfiles();
    static void UnregisterProfiles();
    static BOOL RegisterCategories(BOOL fRegister);
    static BOOL RegisterServer();
    static void UnregisterServer();

    // language bar menu handlers
    static void _Menu_OnComposition(CMarkTextService *_this);
    static void _Menu_OnSetGlobalCompartment(CMarkTextService *_this);
    static void _Menu_OnSetCaseProperty(CMarkTextService *_this);
    static void _Menu_OnViewCaseProperty(CMarkTextService *_this);
    static void _Menu_OnViewCustomProperty(CMarkTextService *_this);
    static void _Menu_OnSetCustomProperty(CMarkTextService *_this);

    // keystroke handlers
    HRESULT _HandleKeyDown(TfEditCookie ec, ITfContext *pContext, WPARAM wParam);
    HRESULT _HandleArrowKey(TfEditCookie ec, ITfContext *pContext, WPARAM wParam);
    HRESULT _HandleReturn(TfEditCookie ec, ITfContext *pContext);

    // callbacks for CCompositionEditSession
    BOOL _IsComposing()
    {
        return _pComposition != NULL;
    }
    ITfComposition *_GetComposition()
    {
        return _pComposition;
    }
    void _SetComposition(ITfComposition *pComposition)
    {
        _pComposition = pComposition;
    }
    void _TerminateComposition(TfEditCookie ec)
    {
        if (_pComposition != NULL)
        {
            _ClearCompositionDisplayAttributes(ec);
            _pComposition->EndComposition(ec);
            SafeReleaseClear(_pComposition);
        }
    }
    void _TerminateCompositionInContext(ITfContext *pContext);
    void _ClearCompositionDisplayAttributes(TfEditCookie ec);
    BOOL _SetCompositionDisplayAttributes(TfEditCookie ec);

    // messages for the worker wnd
    enum { WM_DISPLAY_PROPERTY = WM_USER + 1 };
    // property methods
    void _ViewCaseProperty(TfEditCookie ec, ITfContext *pContext);
    void _SetCaseProperty(TfEditCookie ec, ITfContext *pContext);
    void _ViewCustomProperty(TfEditCookie ec, ITfContext *pContext);
    void _SetCustomProperty(TfEditCookie ec, ITfContext *pContext);

private:
    // init methods
    BOOL _InitLanguageBar();
    BOOL _InitThreadMgrSink();
    BOOL _InitTextEditSink(ITfDocumentMgr *pDocMgr);
    BOOL _InitDisplayAttributeGuidAtom();
    BOOL _InitCleanupContextDurationSink();
    BOOL _InitCleanupContextSink(ITfContext *pContext);
    BOOL _InitContextCompartment(ITfContext *pContext);
    BOOL _InitGlobalCompartment();
    BOOL _InitWorkerWnd();
    BOOL _InitKeystrokeSink();

    // uninit methods
    void _UninitLanguageBar();
    void _UninitThreadMgrSink();
    void _UninitCleanupContextDurationSink();
    void _UninitCleanupContextSink(ITfContext *pContext);
    void _UninitCompartment(ITfContext *pContext);
    void _UninitGlobalCompartment();
    void _UninitWorkerWnd();
    void _UninitKeystrokeSink();

    // property methods
    void _RequestPropertyEditSession(ULONG ulCallback);
    static LRESULT CALLBACK _WorkerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    //
    // state
    //

    ITfThreadMgr *_pThreadMgr;
    TfClientId _tfClientId;
    
    ITfComposition *_pComposition; // pointer to an ongoing composition, or NULL if there is none

    BOOL _fCleaningUp;

    TfGuidAtom _gaDisplayAttribute;

    CLangBarItemButton *_pLangBarItem;

    DWORD _dwThreadMgrEventSinkCookie;
    DWORD _dwThreadFocusSinkCookie;
    DWORD _dwTextEditSinkCookie;
    DWORD _dwGlobalCompartmentEventSinkCookie;

    ITfContext *_pTextEditSinkContext;

    HWND _hWorkerWnd;
    // buffers for the popup property displays
    WCHAR _achDisplayText[64];
    WCHAR _achDisplayPropertyText[64];

    LONG _cRef;     // COM ref count
};


#endif // MARK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\pstore.cpp ===
//
// pstore.cpp
//
// CCustomPropertyStore implementation, ITfPropertyStore example.
//

#include "globals.h"
#include "pstore.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CCustomPropertyStore::CCustomPropertyStore()
{
    // assign some arbitrary state to this object, for demonstration purposes
    _dwState = GetTickCount();

    DllAddRef();
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCustomPropertyStore::~CCustomPropertyStore()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfPropertyStore))
    {
        *ppvObj = (ITfPropertyStore *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCustomPropertyStore::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CCustomPropertyStore::Release()
{
    LONG cr = --_cRef;

    assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// GetType
//
// Returns the GUID of the property this store is assigned to.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetType(GUID *pguidType)
{
    *pguidType = c_guidCustomProperty;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetDataType
//
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetDataType(DWORD *pdwReserved)
{
    // this method is reserved, pdwReserved must be set 0
    *pdwReserved = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetData
//
// Returns the data held by this store.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetData(VARIANT *pvarValue)
{
    pvarValue->vt = VT_I4; // dword value for this store
    pvarValue->lVal = _dwState;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnTextUpdated
//
// Called by TSF when the text covered by this store is modified.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::OnTextUpdated(DWORD dwFlags, ITfRange *pRangeNew, BOOL *pfAccept)
{
    // we will throw away this store (give up) anytime the text is modified.
    // If we did set pfAccept TRUE, the store would be maintained.
    *pfAccept = FALSE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Shrink
//
// Called when the text covered by this store is truncated.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Shrink(ITfRange *pRangeNew, BOOL *pfFree)
{
    // give up and free this store
    *pfFree = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Divide
//
// Called when text covered by the store is deleted, such that the store is
// split in two.  We have the option of freeing the store, or keeping the
// store which moves to cover just pRangeThis (the leftmost text) in which
// case we must provide a new store for the rightmost text as well.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropertyStore)
{
    // just give up
    // a NULL ppPropertyStore tells TSF to release this store
    *ppPropertyStore = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Clone
//
// Return a new store with a copy of this store's state.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Clone(ITfPropertyStore **ppCloneOut)
{
    CCustomPropertyStore *pClone;

    *ppCloneOut = NULL;

    if ((pClone = new CCustomPropertyStore) == NULL)
        return E_OUTOFMEMORY;

    pClone->_dwState = _dwState;

    *ppCloneOut = pClone;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetPropertyRangeCreator
//
// Returns the owning text service.  Used by TSF during Unserialization.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::GetPropertyRangeCreator(CLSID *pclsid)
{
    *pclsid = c_clsidMarkTextService;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Serialize
//
// Copy this store's state to a binary stream.  This stream will later be returned
// to this text service to recreate the store in a later session.
//----------------------------------------------------------------------------

STDAPI CCustomPropertyStore::Serialize(IStream *pStream, ULONG *pcb)
{
    return pStream->Write(&_dwState, sizeof(_dwState), pcb);
}

//+---------------------------------------------------------------------------
//
// IsStoreSerializable
//
//----------------------------------------------------------------------------

STDAPI CMarkTextService::IsStoreSerializable(REFGUID guidProperty, ITfRange *pRange, ITfPropertyStore *pPropertyStore, BOOL *pfSerializable)
{
    // we don't have any complicated logic, we'll let all our custom property values be serialized
    *pfSerializable = IsEqualGUID(guidProperty, c_guidCustomProperty);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CreatePropertyStore
//
// Unserializes a custom property.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::CreatePropertyStore(REFGUID guidProperty, ITfRange *pRange, ULONG cb, IStream *pStream, ITfPropertyStore **ppStore)
{
    CCustomPropertyStore *pStore;
    DWORD dwState;

    *ppStore = NULL;

    if (!IsEqualGUID(guidProperty, c_guidCustomProperty))
        return E_INVALIDARG;

    if (cb != sizeof(DWORD))
        return E_INVALIDARG;

    if ((pStore = new CCustomPropertyStore) == NULL)
        return E_OUTOFMEMORY;

    if (pStream->Read(&dwState, sizeof(DWORD), &cb) != S_OK || cb != sizeof(DWORD))
    {
        pStore->Release();
        return E_FAIL;
    }

    pStore->_SetState(dwState);
    *ppStore = pStore;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\property.cpp ===
//
// property.cpp
//
// Property code.
//

#include "globals.h"
#include "mark.h"
#include "editsess.h"
#include "pstore.h"

// callback code for CPropertyEditSession
#define VIEW_CASE_PROPERTY   0
#define SET_CASE_PROPERTY    1
#define VIEW_CUSTOM_PROPERTY 2
#define SET_CUSTOM_PROPERTY  3

const TCHAR c_szWorkerWndClass[] = TEXT("Mark Worker Wnd Class");

class CPropertyEditSession : public CEditSessionBase
{
public:
    CPropertyEditSession(CMarkTextService *pMark, ITfContext *pContext, ULONG ulCallback) : CEditSessionBase(pContext)
    {
        _pMark = pMark;
        _pMark->AddRef();
        _ulCallback = ulCallback;
    }
    ~CPropertyEditSession()
    {
        _pMark->Release();
    }

    // ITfEditSession
    STDMETHODIMP DoEditSession(TfEditCookie ec)
    {
        switch (_ulCallback)
        {
            case VIEW_CASE_PROPERTY:
                _pMark->_ViewCaseProperty(ec, _pContext);
                break;
            case SET_CASE_PROPERTY:
                _pMark->_SetCaseProperty(ec, _pContext);
                break;
            case VIEW_CUSTOM_PROPERTY:
                _pMark->_ViewCustomProperty(ec, _pContext);
                break;
            case SET_CUSTOM_PROPERTY:
                _pMark->_SetCustomProperty(ec, _pContext);
                break;
        }
        return S_OK;
    }

private:
    CMarkTextService *_pMark;
    ULONG _ulCallback;
};

//+---------------------------------------------------------------------------
//
// _RequestEditSession
//
// Helper function.  Schedules an edit session for a particular property
// related callback.
//----------------------------------------------------------------------------

void CMarkTextService::_RequestPropertyEditSession(ULONG ulCallback)
{
    ITfDocumentMgr *pFocusDoc;
    ITfContext *pContext;
    CPropertyEditSession *pPropertyEditSession;
    HRESULT hr;

    // get the focus document
    if (_pThreadMgr->GetFocus(&pFocusDoc) != S_OK)
        return;

    if (pFocusDoc == NULL)
        return; // no focus

    // we want the topmost context, since the main doc context could be
    // superceded by a modal tip context
    if (pFocusDoc->GetTop(&pContext) != S_OK)
    {
        pContext = NULL;
        goto Exit;
    }

    if (pPropertyEditSession = new CPropertyEditSession(this, pContext, ulCallback))
    {
        // we need a document write lock
        // the CCaseEditSession will do all the work when the
        // CCaseEditSession::DoEditSession method is called by the context
        pContext->RequestEditSession(_tfClientId, pPropertyEditSession, TF_ES_READWRITE | TF_ES_ASYNCDONTCARE, &hr);

        pPropertyEditSession->Release();
    }

Exit:
    SafeRelease(pContext);
    pFocusDoc->Release();
}

//+---------------------------------------------------------------------------
//
// _SetCaseProperty
//
//----------------------------------------------------------------------------

void CMarkTextService::_SetCaseProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCaseProperty;
    ITfRange *pRangeChar;
    WCHAR ch;
    ULONG cchRead;
    ULONG cFetched;
    VARIANT varValue;

    // get the case property
    if (pContext->GetProperty(c_guidCaseProperty, &pCaseProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        tfSelection.range = NULL;
        goto Exit;
    }

    // get a helper range ready for the loop
    if (tfSelection.range->Clone(&pRangeChar) != S_OK)
        goto Exit;

    // set the value char-by-char over the selection
    while (TRUE)
    {
        // read one char, the TF_TF_MOVESTART flag will advance the start anchor
        if (tfSelection.range->GetText(ec, TF_TF_MOVESTART, &ch, 1, &cchRead) != S_OK)
            break;

        // any more text to read?
        if (cchRead != 1)
            break;

        // make pRange cover just the one char we read
        if (pRangeChar->ShiftEndToRange(ec, tfSelection.range, TF_ANCHOR_START) != S_OK)
            break;

        // set the value
        varValue.vt = VT_I4;
        varValue.lVal = (ch >= 'A' && ch <= 'Z');

        if (pCaseProperty->SetValue(ec, pRangeChar, &varValue) != S_OK)
            break;

        // advance pRange for next iteration
        if (pRangeChar->Collapse(ec, TF_ANCHOR_END) != S_OK)
            break;
    }
    
    pRangeChar->Release();

Exit:
    SafeRelease(tfSelection.range);
    pCaseProperty->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnSetCaseProperty
//
// Callback for the "Set Case Property" menu item.
// Set the value for a private "case" property over the text covered by the
// selection.  The case property is private to this text service, which defines
// it as:
//
//      static compact, per character
//      VT_I4, !0 => character is within 'A' - 'Z', 0 => anything else.
//      
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnSetCaseProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(SET_CASE_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _ViewCaseProperty
//
//----------------------------------------------------------------------------

void CMarkTextService::_ViewCaseProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCaseProperty;
    ULONG cchRead;
    LONG cch;
    ULONG cFetched;
    ULONG i;
    VARIANT varValue;

    // get the case property
    if (pContext->GetProperty(c_guidCaseProperty, &pCaseProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        tfSelection.range = NULL;
        goto Exit;
    }

    // grab the text
    if (tfSelection.range->GetText(ec, 0, _achDisplayText, ARRAYSIZE(_achDisplayText)-1, &cchRead) != S_OK)
        goto Exit;

    // prepare for the loop
    if (tfSelection.range->Collapse(ec, TF_ANCHOR_START) != S_OK)
        goto Exit;

    // get the property value char-by-char over the selection
    for (i=0; i < cchRead; i++)
    {
        // advance pRange for next iteration, cover the next char
        if (tfSelection.range->ShiftStartToRange(ec, tfSelection.range, TF_ANCHOR_END) != S_OK)
            break;
        if (tfSelection.range->ShiftEnd(ec, 1, &cch, NULL) != S_OK)
            break;
        if (cch != 1) // hit a region boundary?
            break;

        switch (pCaseProperty->GetValue(ec, tfSelection.range, &varValue))
        {
            case S_OK:
                // the property value has been set, use it
                // 'U' --> uppercase
                // 'L' --> lowercase
                _achDisplayPropertyText[i] = varValue.lVal ? 'U' : 'L';
                break;
            case S_FALSE:
                // no property value set, varValue.vt == VT_EMPTY
                // '?' --> no value
                _achDisplayPropertyText[i] = '?';
                break;
            default:
                // error
                // '!' --> error
                _achDisplayPropertyText[i] = '!';
                break;
        }
    }
    for (; i<cchRead; i++) // error case
    {
        _achDisplayPropertyText[i] = '!';
    }

    _achDisplayPropertyText[cchRead] = '\0';
    _achDisplayText[cchRead] = '\0';

    // we can't change the focus while holding a lock
    // so postpone the UI until we've released our lock
    PostMessage(_hWorkerWnd, CMarkTextService::WM_DISPLAY_PROPERTY, 0, 0);

Exit:
    SafeRelease(tfSelection.range);
    pCaseProperty->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnViewCaseProperty
//
// Menu callback.  Displays a popup with "case" property values over the
// current selection.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnViewCaseProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(VIEW_CASE_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _ViewCustomProperty
//
// Display the value of this text service's custom property over the text
// covered by the selection.
//----------------------------------------------------------------------------

void CMarkTextService::_ViewCustomProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCustomProperty;
    ITfRange *pSelRange;
    ITfRange *pPropertySpanRange;
    ULONG cchRead;
    ULONG cFetched;
    LONG cch;
    VARIANT varValue;
    HRESULT hr;

    // get the case property
    if (pContext->GetProperty(c_guidCustomProperty, &pCustomProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        pSelRange = NULL;
        goto Exit;
    }
    // free up tfSelection so we can re-use it below
    pSelRange = tfSelection.range;

    // the selection may not exactly match a span of text covered by the
    // custom property....so we'll return the value over the start anchor of
    // the selection.

    // we need to collapse the range because GetValue will return VT_EMPTY
    // if the query range is not completely covered by the property span
    if (pSelRange->Collapse(ec, TF_ANCHOR_START) != S_OK)
        goto Exit;
    // the query range must also cover at least one char
    if (pSelRange->ShiftEnd(ec, 1, &cch, NULL) != S_OK)
        goto Exit;

    hr = pCustomProperty->GetValue(ec, pSelRange, &varValue);

    switch (hr)
    {
        case S_OK:
            // there's a value at the selection start anchor
            // let's find out exactly what text is covered
            _achDisplayText[0] = '\0';
            if (pCustomProperty->FindRange(ec, pSelRange, &pPropertySpanRange, TF_ANCHOR_START) == S_OK)
            {
                if (pPropertySpanRange->GetText(ec, 0, _achDisplayText, ARRAYSIZE(_achDisplayText)-1, &cchRead) != S_OK)
                {
                    cchRead = 0;
                }
                _achDisplayText[cchRead] = '\0';
                // let's update the selection to give the user feedback
                tfSelection.range = pPropertySpanRange;
                pContext->SetSelection(ec, 1, &tfSelection);
                pPropertySpanRange->Release();
            }
            // write the value
            wsprintfW(_achDisplayPropertyText, L"%i", varValue.lVal);
            break;

        case S_FALSE:
            // the property has no value, varValue.vt == VT_EMPTY
            _achDisplayText[0] = '\0';
            lstrcpynW(_achDisplayPropertyText, L"- No Value -", ARRAYSIZE(_achDisplayPropertyText));
            break;
        default:
            goto Exit; // error
    }

    // we can't change the focus while holding a lock
    // so postpone the UI until we've released our lock
    PostMessage(_hWorkerWnd, CMarkTextService::WM_DISPLAY_PROPERTY, 0, 0);

Exit:
    SafeRelease(pSelRange);
    pCustomProperty->Release();
}

//+---------------------------------------------------------------------------
//
// _Menu_OnViewCustomProperty
//
// Menu callback for "View Custom Property".
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnViewCustomProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(VIEW_CUSTOM_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _InitWorkerWnd
//
// Called from Activate.  Create a worker window to receive private windows
// messages.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitWorkerWnd()
{
    WNDCLASS wc;

    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = _WorkerWndProc;
    wc.hInstance = g_hInst;
    wc.lpszClassName = c_szWorkerWndClass;

    if (RegisterClass(&wc) == 0)
        return FALSE;

    _hWorkerWnd = CreateWindow(c_szWorkerWndClass, TEXT("Mark Worker Wnd"),
                               0, 0, 0, 0, 0, NULL, NULL, g_hInst, this);

    return (_hWorkerWnd != NULL);
}

//+---------------------------------------------------------------------------
//
// _UninitWorkerWnd
//
// Called from Deactivate.  Destroy the worker window.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitWorkerWnd()
{
    if (_hWorkerWnd != NULL)
    {
        DestroyWindow(_hWorkerWnd);
        _hWorkerWnd = NULL;
    }
    UnregisterClass(c_szWorkerWndClass, g_hInst);
}

//+---------------------------------------------------------------------------
//
// _WorkerWndProc
//
//----------------------------------------------------------------------------

/* static */
LRESULT CALLBACK CMarkTextService::_WorkerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMarkTextService *_this;
    int cch;
    TCHAR achText[128];

    switch (uMsg)
    {
        case WM_CREATE:
            // save the this pointer we originally passed into CreateWindow
            SetWindowLong(hWnd, GWL_USERDATA, 
                         (LONG)((CREATESTRUCT *)lParam)->lpCreateParams);
            return 0;

        case WM_DISPLAY_PROPERTY:
            _this = (CMarkTextService *)GetWindowLong(hWnd, GWL_USERDATA);

            // bring up a message box with the contents of _achDisplayText
            
            // first, convert from unicode
            cch = WideCharToMultiByte(CP_ACP, 0, _this->_achDisplayText, wcslen(_this->_achDisplayText),
                                      achText, ARRAYSIZE(achText), NULL, NULL);

            if (cch < ARRAYSIZE(achText))
            {
                achText[cch++] = '\n';
            }
            if (cch < ARRAYSIZE(achText))
            {
                cch += WideCharToMultiByte(CP_ACP, 0, _this->_achDisplayPropertyText, wcslen(_this->_achDisplayPropertyText),
                                           achText+cch, ARRAYSIZE(achText)-cch, NULL, NULL);
            }
            achText[cch] = '\0';

            // bring up the display
            MessageBox(NULL, achText, TEXT("Property View"), MB_OK);

            return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _Menu_OnSetCustomProperty
//
// Callback for the "Set Custom Property" menu item.
//----------------------------------------------------------------------------

/* static */
void CMarkTextService::_Menu_OnSetCustomProperty(CMarkTextService *_this)
{
    _this->_RequestPropertyEditSession(SET_CUSTOM_PROPERTY);
}

//+---------------------------------------------------------------------------
//
// _SetCustomProperty
//
// Assign a custom property to the text covered by the selection.
//----------------------------------------------------------------------------

void CMarkTextService::_SetCustomProperty(TfEditCookie ec, ITfContext *pContext)
{
    TF_SELECTION tfSelection;
    ITfProperty *pCustomProperty;
    CCustomPropertyStore *pCustomPropertyStore;
    ULONG cFetched;

    // get the case property
    if (pContext->GetProperty(c_guidCustomProperty, &pCustomProperty) != S_OK)
        return;

    // get the selection
    if (pContext->GetSelection(ec, TF_DEFAULT_SELECTION, 1, &tfSelection, &cFetched) != S_OK ||
        cFetched != 1)
    {
        // no selection or something went wrong
        tfSelection.range = NULL;
        goto Exit;
    }

    if ((pCustomPropertyStore = new CCustomPropertyStore) == NULL)
        goto Exit;

    pCustomProperty->SetValueStore(ec, tfSelection.range, pCustomPropertyStore);

    // TSF will hold a reference to pCustomPropertyStore is the SetValueStore succeeded
    // but we need to release ours
    pCustomPropertyStore->Release();

Exit:
    pCustomProperty->Release();
    SafeRelease(tfSelection.range);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\pstore.h ===
//
// pstore.h
//
// CCustomPropertyStore
//

#ifndef PSTORE_H
#define PSTORE_H

class CCustomPropertyStore : public ITfPropertyStore
{
public:
    CCustomPropertyStore();
    ~CCustomPropertyStore();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITfPropertyStore
    STDMETHODIMP GetType(GUID *pguidType);
    STDMETHODIMP GetDataType(DWORD *pdwReserved);
    STDMETHODIMP GetData(VARIANT *pvarValue);
    STDMETHODIMP OnTextUpdated(DWORD dwFlags, ITfRange *pRangeNew, BOOL *pfAccept);
    STDMETHODIMP Shrink(ITfRange *pRangeNew, BOOL *pfFree);
    STDMETHODIMP Divide(ITfRange *pRangeThis, ITfRange *pRangeNew, ITfPropertyStore **ppPropertyStore);
    STDMETHODIMP Clone(ITfPropertyStore **ppClone);
    STDMETHODIMP GetPropertyRangeCreator(CLSID *pclsid);
    STDMETHODIMP Serialize(IStream *pStream, ULONG *pcb);

    void _SetState(DWORD dwState)
    {
        _dwState = dwState;
    }

private:
    DWORD _dwState;
    LONG _cRef;     // COM ref count
};

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\register.cpp ===
//
// register.cpp
//
// Server registration code.
//

#include <windows.h>
#include <ole2.h>
#include "msctf.h"
#include "globals.h"
#include "mark.h"

#define CLSID_STRLEN 38  // strlen("{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}")

const struct
{
    const GUID *pguidCategory;
    const GUID *pguid;
}
c_rgCategories[] =
{
    { &GUID_TFCAT_TIP_KEYBOARD, &c_clsidMarkTextService },
    { &GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER, &c_clsidMarkTextService },
    { &GUID_TFCAT_PROPSTYLE_STATICCOMPACT, &c_guidCaseProperty },
    { &GUID_TFCAT_PROPSTYLE_CUSTOM, &c_guidCustomProperty },    
};

static const TCHAR c_szInfoKeyPrefix[] = TEXT("CLSID\\");
static const TCHAR c_szInProcSvr32[] = TEXT("InProcServer32");
static const TCHAR c_szModelName[] = TEXT("ThreadingModel");

//+---------------------------------------------------------------------------
//
//  RegisterProfiles
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::RegisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    WCHAR achIconFile[MAX_PATH];
    char achFileNameA[MAX_PATH];
    DWORD cchA;
    int cchIconFile;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return E_FAIL;

    hr = pInputProcessProfiles->Register(c_clsidMarkTextService);

    if (hr != S_OK)
        goto Exit;

    cchA = GetModuleFileNameA(g_hInst, achFileNameA, ARRAYSIZE(achFileNameA));

    cchIconFile = MultiByteToWideChar(CP_ACP, 0, achFileNameA, cchA, achIconFile, ARRAYSIZE(achIconFile));
    achIconFile[cchIconFile] = '\0';

    hr = pInputProcessProfiles->AddLanguageProfile(c_clsidMarkTextService,
                                  MARK_LANGID, 
                                  c_guidMarkProfile, 
                                  MARK_DESC, 
                                  wcslen(MARK_DESC),
                                  achIconFile,
                                  cchIconFile,
                                  MARK_ICON_INDEX);

Exit:
    pInputProcessProfiles->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
//  UnregisterProfiles
//
//----------------------------------------------------------------------------

void CMarkTextService::UnregisterProfiles()
{
    ITfInputProcessorProfiles *pInputProcessProfiles;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
                          IID_ITfInputProcessorProfiles, (void**)&pInputProcessProfiles);

    if (hr != S_OK)
        return;

    pInputProcessProfiles->Unregister(c_clsidMarkTextService);
    pInputProcessProfiles->Release();
}

//+---------------------------------------------------------------------------
//
//  RegisterCategories
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::RegisterCategories(BOOL fRegister)
{
    ITfCategoryMgr *pCategoryMgr;
    int i;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_TF_CategoryMgr, NULL, CLSCTX_INPROC_SERVER, 
                          IID_ITfCategoryMgr, (void**)&pCategoryMgr);

    if (hr != S_OK)
        return E_FAIL;

    for (i=0; i<ARRAYSIZE(c_rgCategories); i++)
    {
        if (fRegister)
        {
            hr = pCategoryMgr->RegisterCategory(c_clsidMarkTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }
        else
        {
            hr = pCategoryMgr->UnregisterCategory(c_clsidMarkTextService,
                   *c_rgCategories[i].pguidCategory, *c_rgCategories[i].pguid);
        }

        if (hr != S_OK)
            break;
    }

    pCategoryMgr->Release();
    return (hr == S_OK);
}

//+---------------------------------------------------------------------------
//
// CLSIDToStringA
//
//----------------------------------------------------------------------------

BOOL CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                   8, 9, '-', 10, 11, 12, 13, 14, 15};

    static const char szDigits[] = "0123456789ABCDEF";

    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// RecurseDeleteKey
//
// RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
// specified key has subkeys
//----------------------------------------------------------------------------
LONG RecurseDeleteKey(HKEY hParentKey, LPCTSTR lpszKey)
{
    HKEY hKey;
    LONG lRes;
    FILETIME time;
    TCHAR szBuffer[256];
    DWORD dwSize = sizeof(szBuffer);

    if (RegOpenKey(hParentKey, lpszKey, &hKey) != ERROR_SUCCESS)
        return ERROR_SUCCESS; // let's assume we couldn't open it because it's not there

    lRes = ERROR_SUCCESS;
    while (RegEnumKeyEx(hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time)==ERROR_SUCCESS)
    {
        lRes = RecurseDeleteKey(hKey, szBuffer);
        if (lRes != ERROR_SUCCESS)
            break;
        dwSize = sizeof(szBuffer);
    }
    RegCloseKey(hKey);

    return lRes == ERROR_SUCCESS ? RegDeleteKey(hParentKey, lpszKey) : lRes;
}

//+---------------------------------------------------------------------------
//
//  RegisterServer
//
//----------------------------------------------------------------------------

BOOL CMarkTextService::RegisterServer()
{
    DWORD dw;
    HKEY hKey;
    HKEY hSubKey;
    BOOL fRet;
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];
    TCHAR achFileName[MAX_PATH];

    if (!CLSIDToStringA(c_clsidMarkTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return FALSE;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    if (fRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, achIMEKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw)
            == ERROR_SUCCESS)
    {
        fRet &= RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)MARK_DESC_A, (lstrlen(MARK_DESC_A)+1)*sizeof(TCHAR))
            == ERROR_SUCCESS;

        if (fRet &= RegCreateKeyEx(hKey, c_szInProcSvr32, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSubKey, &dw)
            == ERROR_SUCCESS)
        {
            dw = GetModuleFileNameA(g_hInst, achFileName, ARRAYSIZE(achFileName));

            fRet &= RegSetValueEx(hSubKey, NULL, 0, REG_SZ, (BYTE *)achFileName, (lstrlen(achFileName)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            fRet &= RegSetValueEx(hSubKey, c_szModelName, 0, REG_SZ, (BYTE *)MARK_MODEL, (lstrlen(MARK_MODEL)+1)*sizeof(TCHAR)) == ERROR_SUCCESS;
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  UnregisterServer
//
//----------------------------------------------------------------------------

void CMarkTextService::UnregisterServer()
{
    TCHAR achIMEKey[ARRAYSIZE(c_szInfoKeyPrefix) + CLSID_STRLEN];

    if (!CLSIDToStringA(c_clsidMarkTextService, achIMEKey + ARRAYSIZE(c_szInfoKeyPrefix) - 1))
        return;
    memcpy(achIMEKey, c_szInfoKeyPrefix, sizeof(c_szInfoKeyPrefix)-sizeof(TCHAR));

    RecurseDeleteKey(HKEY_CLASSES_ROOT, achIMEKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\resource.h ===
//
// resource.h
//
// Resource declarations.
//

#ifndef RESOURCE_H
#define RESOURCE_H

//#define IDI_MARK        0

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\tmgrsink.cpp ===
//
// tmgrsink.cpp
//
// ITfThreadMgrEventSink implementation.
//

#include "globals.h"
#include "mark.h"

//+---------------------------------------------------------------------------
//
// OnInitDocumentMgr
//
// Sink called by the framework just before the first context is pushed onto
// a document.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnInitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnUninitDocumentMgr
//
// Sink called by the framework just after the last context is popped off a
// document.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnUninitDocumentMgr(ITfDocumentMgr *pDocMgr)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSetFocus
//
// Sink called by the framework when focus changes from one document to
// another.  Either document may be NULL, meaning previously there was no
// focus document, or now no document holds the input focus.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnSetFocus(ITfDocumentMgr *pDocMgrFocus, ITfDocumentMgr *pDocMgrPrevFocus)
{
    // we'll track edit changes in the focus document, the only place we start compositions
    _InitTextEditSink(pDocMgrFocus);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPushContext
//
// Sink called by the framework when a context is pushed.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnPushContext(ITfContext *pContext)
{
    // ignore new contexts that appear while were uninitializing
    if (!_fCleaningUp)
    {
        _InitCleanupContextSink(pContext);
        _InitContextCompartment(pContext);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnPopContext
//
// Sink called by the framework when a context is popped.
//----------------------------------------------------------------------------

STDAPI CMarkTextService::OnPopContext(ITfContext *pContext)
{
    _UninitCleanupContextSink(pContext);
    _UninitCompartment(pContext);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _InitThreadMgrSink
//
// Advise our sink.
//----------------------------------------------------------------------------

BOOL CMarkTextService::_InitThreadMgrSink()
{
    return AdviseSink(_pThreadMgr, (ITfThreadMgrEventSink *)this,
                      IID_ITfThreadMgrEventSink, &_dwThreadMgrEventSinkCookie);
}

//+---------------------------------------------------------------------------
//
// _UninitThreadMgrSink
//
// Unadvise our sink.
//----------------------------------------------------------------------------

void CMarkTextService::_UninitThreadMgrSink()
{
    UnadviseSink(_pThreadMgr, &_dwThreadMgrEventSinkCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\sdk\mark\server.cpp ===
//
// server.cpp
//
// COM server exports.
//

#include "globals.h"
#include "mark.h"

void FreeGlobalObjects(void);

class CClassFactory;
static CClassFactory *g_ObjectInfo[1] = { NULL };

//+---------------------------------------------------------------------------
//
//  DllAddRef
//
//----------------------------------------------------------------------------

LONG DllAddRef(void)
{
    return InterlockedIncrement(&g_cRefDll) + 1;
}

//+---------------------------------------------------------------------------
//
//  DllRelease
//
//----------------------------------------------------------------------------

LONG DllRelease(void)
{
    if (InterlockedDecrement(&g_cRefDll) < 0) // g_cRefDll == -1 with zero refs
    {
        EnterCriticalSection(&g_cs);

        // need to check ref again after grabbing mutex
        if (g_ObjectInfo[0] != NULL)
        {
            FreeGlobalObjects();
        }
        assert(g_cRefDll == -1);

        LeaveCriticalSection(&g_cs);
    }

    return g_cRefDll+1;
}

//+---------------------------------------------------------------------------
//
//  CClassFactory declaration with IClassFactory Interface
//
//----------------------------------------------------------------------------

class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory methods
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP LockServer(BOOL fLock);

    // Constructor
    CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj))
        : _rclsid(rclsid)
    {
        _pfnCreateInstance = pfnCreateInstance;
    }

public:
    REFCLSID _rclsid;
    HRESULT (*_pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
};

//+---------------------------------------------------------------------------
//
//  CClassFactory::QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
        DllAddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return g_cRefDll+1; // -1 w/ no refs
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::CreateInstance
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return _pfnCreateInstance(pUnkOuter, riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  CClassFactory::LockServer
//
//----------------------------------------------------------------------------

STDAPI CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllAddRef();
    }
    else
    {
        DllRelease();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  BuildGlobalObjects
//
//----------------------------------------------------------------------------

void BuildGlobalObjects(void)
{
    // Build CClassFactory Objects

    g_ObjectInfo[0] = new CClassFactory(c_clsidMarkTextService,
                                        CMarkTextService::CreateInstance);

    // You can add more object info here.
    // Don't forget to increase number of item for g_ObjectInfo[],
}

//+---------------------------------------------------------------------------
//
//  FreeGlobalObjects
//
//----------------------------------------------------------------------------

void FreeGlobalObjects(void)
{
    // Free CClassFactory Objects
    for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
    {
        if (NULL != g_ObjectInfo[i])
        {
            delete g_ObjectInfo[i];
            g_ObjectInfo[i] = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  DllGetClassObject
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    if (g_ObjectInfo[0] == NULL)
    {
        EnterCriticalSection(&g_cs);

            // need to check ref again after grabbing mutex
            if (g_ObjectInfo[0] == NULL)
            {
                BuildGlobalObjects();
            }

        LeaveCriticalSection(&g_cs);
    }

    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
        {
            if (NULL != g_ObjectInfo[i] &&
                IsEqualGUID(rclsid, g_ObjectInfo[i]->_rclsid))
            {
                *ppvObj = (void *)g_ObjectInfo[i];
                DllAddRef();    // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }

    *ppvObj = NULL;

    return CLASS_E_CLASSNOTAVAILABLE;
}

//+---------------------------------------------------------------------------
//
//  DllCanUnloadNow
//
//----------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    if (g_cRefDll >= 0) // -1 with no refs
        return S_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer(void)
{
    CMarkTextService::RegisterCategories(FALSE);
    CMarkTextService::UnregisterProfiles();
    CMarkTextService::UnregisterServer();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  DllRegisterServer
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
    // register this service's profile with the tsf
    if (!CMarkTextService::RegisterServer() ||
        !CMarkTextService::RegisterProfiles() ||
        !CMarkTextService::RegisterCategories(TRUE))
    {
        DllUnregisterServer(); // cleanup any loose ends
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "SOFTKBD"
#define SZ_MODULE       "SOFTKBD"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\fnsoftkbd.cpp ===
/**************************************************************************\
* Module Name: fnsoftkbd.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implementation of SoftKbd function object so that other TIPs can control 
* this SoftKbd IMX behavior.
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "softkbdimx.h"
#include "fnsoftkbd.h"
#include "funcprv.h"
#include "helpers.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFnSoftKbd
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnSoftKbd::QueryInterface(REFIID riid, void **ppvObj)
{

    if ( ppvObj == NULL )
    	return E_FAIL;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnSoftKbd))
    {
        *ppvObj = SAFECAST(this, CFnSoftKbd *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnSoftKbd::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnSoftKbd::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnSoftKbd::CFnSoftKbd(CFunctionProvider *pFuncPrv)
{

    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();

    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnSoftKbd::~CFnSoftKbd()
{

    SafeRelease(_pFuncPrv);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnSoftKbd::GetDisplayName(BSTR *pbstrName)
{

    HRESULT  hr = S_OK;

    if ( pbstrName == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    *pbstrName = SysAllocString(L"FnSoftKbd");

    if ( *pbstrName == NULL )
    {
    	hr = E_OUTOFMEMORY;
    }

    return hr;
}
//+---------------------------------------------------------------------------
//
// IsEnabled
//
//----------------------------------------------------------------------------

STDAPI CFnSoftKbd::IsEnabled(BOOL *pfEnable)
{
    HRESULT  hr = S_OK;

    if ( pfEnable == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    *pfEnable = TRUE;

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetSoftKbdLayoutId
//
//    Get the soft keyboard Id for specified type.
//   
//    Current supported types are:
//             SOFTKBD_TYPE_US_STANDARD
//             SOFTKBD_TYPE_US_SYMBOL
//        
//----------------------------------------------------------------------------


STDAPI  CFnSoftKbd::GetSoftKbdLayoutId(DWORD dwLayoutType, DWORD *lpdwLayoutId)
{

    HRESULT   hr;

    hr = S_OK;

    if ( lpdwLayoutId == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    switch (dwLayoutType) {

    case  SOFTKBD_TYPE_US_STANDARD  :

    	   *lpdwLayoutId = (_pFuncPrv->_pimx->_KbdStandard).dwSoftKbdLayout;

    	   break;

    case SOFTKBD_TYPE_US_SYMBOL :

           *lpdwLayoutId = (_pFuncPrv->_pimx->_KbdSymbol).dwSoftKbdLayout;

    	   break;

    default :

    	   hr = E_FAIL;
    }


CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetActiveLayoutId
//
//    Set Current Active soft keyboard layout. the layout Id is returned from
//    GetSoftKbdLayoutId( ).
//
//----------------------------------------------------------------------------

STDAPI  CFnSoftKbd::SetActiveLayoutId(DWORD  dwLayoutId )
{

    HRESULT   hr;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    _pFuncPrv->_pimx->SetSoftKBDLayout( dwLayoutId );

CleanUp:
    return hr;
}

//+---------------------------------------------------------------------------
//
// SetSoftKbdOnOff
//
//    Set the current soft keyboard window show status. On or Off based on fOn
//
//----------------------------------------------------------------------------


STDAPI  CFnSoftKbd::SetSoftKbdOnOff(BOOL  fOn )
{

    HRESULT   hr;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    _pFuncPrv->_pimx->SetSoftKBDOnOff( fOn );

CleanUp:
    return hr;
}


//+---------------------------------------------------------------------------
//
// GetActiveLayoutId
//
//    Get Current Active soft keyboard layout.
//
//----------------------------------------------------------------------------

STDAPI  CFnSoftKbd::GetActiveLayoutId(DWORD  *lpdwLayoutId )
{
    HRESULT   hr;

    hr = S_OK;

    if ( lpdwLayoutId == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    *lpdwLayoutId = _pFuncPrv->_pimx->GetSoftKBDLayout( );

CleanUp:
    return hr;

}


//+---------------------------------------------------------------------------
//
// GetSoftKbdOnOff
//
//    Get the current soft keyboard window show status. 
//
//----------------------------------------------------------------------------


STDAPI  CFnSoftKbd::GetSoftKbdOnOff(BOOL  *lpfOn )
{

    HRESULT   hr;

    hr = S_OK;

    if ( lpfOn == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    *lpfOn = _pFuncPrv->_pimx->GetSoftKBDOnOff(  );

CleanUp:
    return hr;

}


STDAPI  CFnSoftKbd::SetSoftKbdPosSize(POINT StartPoint, WORD width, WORD height)
{

    HRESULT  hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->SetSoftKeyboardPosSize(StartPoint, width, height );

    SafeRelease(pSoftKbd);

CleanUp:

    return hr;
}


STDAPI  CFnSoftKbd::SetSoftKbdColors(COLORTYPE  colorType, COLORREF Color)
{

    HRESULT   hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->SetSoftKeyboardColors( colorType, Color );

    SafeRelease(pSoftKbd);


CleanUp:

    return hr;

}


STDAPI  CFnSoftKbd::GetSoftKbdPosSize(POINT *lpStartPoint,WORD *lpwidth,WORD *lpheight)
{

    HRESULT   hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (lpStartPoint==NULL) || (lpwidth == NULL) || (lpheight == NULL))
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->GetSoftKeyboardPosSize(lpStartPoint, lpwidth, lpheight );

    SafeRelease(pSoftKbd);


CleanUp:

    return hr;
}


STDAPI  CFnSoftKbd::GetSoftKbdColors(COLORTYPE  colorType, COLORREF *lpColor)
{

    HRESULT   hr;
    ISoftKbd *pSoftKbd;

    hr = S_OK;

    if ( (_pFuncPrv == NULL) || (_pFuncPrv->_pimx == NULL) )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( _pFuncPrv->_pimx->_SoftKbd == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    pSoftKbd = _pFuncPrv->_pimx->_SoftKbd;

    pSoftKbd->AddRef( );

    hr = pSoftKbd->GetSoftKeyboardColors(colorType, lpColor );

    SafeRelease(pSoftKbd);


CleanUp:

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "private.h"
#include "ciccs.h"

extern HINSTANCE g_hInst;

extern CCicCriticalSectionStatic g_cs;

extern const CLSID CLSID_SoftkbdIMX;
// extern const GUID GUID_ATTR_SOFTKBDIMX_INPUT;
extern const GUID GUID_IC_PRIVATE;

const TCHAR c_szIMXOwnerWndClass[] = TEXT("SoftkbdIMXOwnerWndClass");

const TCHAR c_szCTFTIPKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
const TCHAR c_szLanguageProfileKey[] = TEXT("LanguageProfile");

const TCHAR c_szSoftKbdUIWndClassName[] = TEXT("SoftkbdUIWndFrame");

extern const GUID GUID_LBI_SOFTKBDIMX_MODE;
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT;
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION;

extern const GUID c_guidProfile;
extern const GUID c_guidProfileSym;

#define  SafeFreePointer(pv)   if ( (pv) != NULL ) {  \
                                      cicMemFree(pv);  \
                                      (pv) = NULL; }     

#define CHECKHR(x) {hr = x; if (FAILED(hr)) goto CleanUp;}


#define   NUM_PICTURE_KEYS    40

// Type definition for picture keys in standard soft keyboards.

typedef struct  _tagPictureKey {

    UINT      uScanCode;   // same as KeyId in the XML file
    UINT      uVkey;
    LPWSTR    PictBitmap;
}  PICTUREKEY,  FAR  * LPPICTUREKEY;

extern   PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS];
extern   PICTUREKEY  gJpnPictureKeys[NUM_PICTURE_KEYS];


#define  KID_LWINLOGO       0xE05B
#define  KID_RWINLOGO       0xE05C
#define  KID_APPS           0xE05D

#define  KID_LEFT           0xE04B
#define  KID_RIGHT          0xE04D
#define  KID_UP             0xE048
#define  KID_DOWN           0xE050

#define  KID_ESC            0x01
#define  KID_BACK           0x0E
#define  KID_TAB            0x0F
#define  KID_CAPS           0x3A
#define  KID_ENTER          0x1C
#define  KID_LSHFT          0x2A
#define  KID_RSHFT          0x36
#define  KID_CTRL           0x1D
#define  KID_RCTRL          0xE01D
#define  KID_ALT            0x38
#define  KID_RALT           0xE038
#define  KID_SPACE          0x39

#define  KID_DELETE         0xE053

#define  KID_F1             0x3B
#define  KID_F2             0x3C
#define  KID_F3             0x3D
#define  KID_F4             0x3E
#define  KID_F5             0x3F
#define  KID_F6             0x40
#define  KID_F7             0x41
#define  KID_F8             0x42
#define  KID_F9             0x43
#define  KID_F10            0x44
#define  KID_F11            0x57
#define  KID_F12            0x58

#define  KID_CONVERT        0x79
#define  KID_NONCONVERT     0x7B
#define  KID_KANA           0x70
#define  KID_FULLHALF       0x29    // special used by Japan 106 Key

// These defintions are for Transparency of soft keyboard window.
// used by SetLayeredWindowAttributes( )

#if(_WIN32_WINNT < 0x0500)
#define WS_EX_LAYERED           0x00080000
#define LWA_COLORKEY            0x00000001
#define LWA_ALPHA               0x00000002
#define ULW_COLORKEY            0x00000001
#define ULW_ALPHA               0x00000002
#define ULW_OPAQUE              0x00000004
#endif /* _WIN32_WINNT < 0x0500 */


typedef enum { none = 0, CapsLock, Shift, Ctrl, Alt, Kana, AltGr, NumLock}  MODIFYTYPE;

#define      MODIFIER_CAPSLOCK    0x0002
#define      MODIFIER_SHIFT       0x0004
#define      MODIFIER_CTRL        0x0008
#define      MODIFIER_ALT         0x0010
#define      MODIFIER_KANA        0x0020
#define      MODIFIER_ALTGR       0x0040
#define      MODIFIER_NUMLOCK     0x0080

 
#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\globals.cpp ===
/**************************************************************************\
* Module Name: globals.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Global Definition for Soft Keyboard Component.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"

#define CPP_FUNCTIONS
#include "icrtfree.h"

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

/* ca01de3f-1433-4d60-9324-14307fd943df */
/*extern const GUID GUID_ATTR_SOFTKBDIMX_INPUT = { 
    0xca01de3f,
    0x1433,
    0x4d60,
    {0x93, 0x24, 0x14, 0x30, 0x7f, 0xd9, 0x43, 0xdf}
  };
*/

/* 31f4d5e3-c2da-41bc-902c-d62648447daa */
extern const GUID GUID_IC_PRIVATE = { 
    0x31f4d5e3,
    0xc2da,
    0x41bc,
    {0x90, 0x2c, 0xd6, 0x26, 0x48, 0x44, 0x7d, 0xaa}
  };

extern  const GUID GUID_LBI_SOFTKBDIMX_MODE = {/*7883eed0-e859-4357-a348-006e73ea680f */
    0x7883eed0,
    0xe859,
    0x4357,
    {0xa3, 0x48, 0x00, 0x6e, 0x73, 0xea, 0x68, 0x0f}
  };

/* def9364c-ce29-447f-ae02-076714aeaf6f */
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT = {
    0xdef9364c,
    0xce29,
    0x447f,
    {0xae, 0x02, 0x07, 0x67, 0x14, 0xae, 0xaf, 0x6f}

};

/* e9221414-d6c8-4885-834e-b11ba641c4f2 */
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION = {
    0xe9221414,
    0xd6c8,
    0x4885,
    {0x83, 0x4e, 0xb1, 0x1b, 0xa6, 0x41, 0xc4, 0xf2}
};


extern PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS]= {

       // uScanCode,    uVKey,   PictBitmap
       { KID_LWINLOGO,  VK_LWIN,   L"IDB_WINLOGO" },
       { KID_RWINLOGO,  VK_RWIN,   L"IDB_WINLOGO" },
       { KID_APPS,      VK_APPS,   L"IDB_APPS" },

       { KID_LEFT,      VK_LEFT,   L"IDB_LEFT" },
       { KID_RIGHT,     VK_RIGHT,  L"IDB_RIGHT" },
       { KID_UP,        VK_UP,     L"IDB_UP" },
       { KID_DOWN,      VK_DOWN,   L"IDB_DOWN" },

       { KID_ESC,       VK_ESCAPE, L"IDB_ESC" },

       { KID_BACK,      VK_BACK,   L"IDB_BACK" },
       { KID_TAB,       VK_TAB,    L"IDB_TAB" },
       { KID_CAPS,      VK_CAPITAL,L"IDB_CAPITAL" },
       { KID_ENTER,     VK_RETURN, L"IDB_RETURN" },
       { KID_LSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_RSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_CTRL,      VK_CONTROL,L"IDB_CONTROL" },
       { KID_RCTRL,     VK_CONTROL,L"IDB_CONTROL" },
       { KID_ALT,       VK_MENU,   L"IDB_ALT" },
       { KID_RALT,      VK_RMENU,  L"IDB_ALTGR" },
       { KID_DELETE,    VK_DELETE, L"IDB_DELETE" },
     


       { 0,0,NULL}
};
    	

extern  PICTUREKEY  gJpnPictureKeys[NUM_PICTURE_KEYS] = {

       // uScanCode,    uVKey,   PictBitmap
       { KID_LWINLOGO,  VK_LWIN,   L"IDB_WINLOGO" },
       { KID_RWINLOGO,  VK_RWIN,   L"IDB_WINLOGO" },
       { KID_APPS,      VK_APPS,   L"IDB_APPS" },

       { KID_LEFT,      VK_LEFT,   L"IDB_LEFT" },
       { KID_RIGHT,     VK_RIGHT,  L"IDB_RIGHT" },
       { KID_UP,        VK_UP,     L"IDB_UP" },
       { KID_DOWN,      VK_DOWN,   L"IDB_DOWN" },

       { KID_ESC,       VK_ESCAPE, L"IDB_ESC" },

       { KID_BACK,      VK_BACK,   L"IDB_JPNBACK" },
       { KID_TAB,       VK_TAB,    L"IDB_TAB" },
       { KID_CAPS,      VK_CAPITAL,L"IDB_JPNCAPITAL" },
       { KID_ENTER,     VK_RETURN, L"IDB_JPNRETURN" },
       { KID_LSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_RSHFT,     VK_SHIFT,  L"IDB_SHIFT" },
       { KID_CTRL,      VK_CONTROL,L"IDB_CONTROL" },
       { KID_RCTRL,     VK_CONTROL,L"IDB_CONTROL" },
       { KID_ALT,       VK_MENU,   L"IDB_ALT" },
       { KID_RALT,      VK_MENU,   L"IDB_ALT" },
       { KID_DELETE,    VK_DELETE, L"IDB_DELETE" },
       { KID_CONVERT,   VK_CONVERT,L"IDB_CONVERT" },
       { KID_NONCONVERT,VK_NONCONVERT, L"IDB_NONCONVERT" },
       { KID_KANA,      0, L"IDB_KANA" },
       { KID_FULLHALF,  0, L"IDB_FULLHALF" },


       { 0,0,NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\icrtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

#include "mem.h"
#undef new

void *  __cdecl operator new(size_t nSize)
{
    return cicMemAllocClear((UINT)nSize);
}

void  __cdecl operator delete(void *pv)
{
    cicMemFree(pv);
}

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\funcprv.cpp ===
/**************************************************************************\
* Module Name: funcprv.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implementation of function provider. 
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/


#include "private.h"
#include "globals.h"
#include "softkbdimx.h"
#include "funcprv.h"
#include "helpers.h"
#include "immxutil.h"
#include "fnsoftkbd.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////


CFunctionProvider::CFunctionProvider(CSoftkbdIMX *pimx) : CFunctionProviderBase(pimx->_GetId())
{
    Init(CLSID_SoftkbdIMX, L"SoftkbdIMX TFX");
    _pimx = pimx;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_NOINTERFACE;

    if (IsEqualIID(riid, IID_ITfFnSoftKbd))
    {
        *ppunk = new CFnSoftKbd(this);
    }

    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\funcprv.h ===
/**************************************************************************\
* Module Name: funcprv.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of function provider. 
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/

#ifndef FUNCPRV_H
#define FUNCPRV_H

#include "private.h"
#include "fnprbase.h"

class CSoftkbdIMX;

class CFunctionProvider : public CFunctionProviderBase
{
public:
    CFunctionProvider(CSoftkbdIMX *pimx);

    //
    // ITfFunctionProvider
    //
    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    CSoftkbdIMX *_pimx;
};

#endif // FUNCPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\fnsoftkbd.h ===
/**************************************************************************\
* Module Name: fnsoftkbd.h
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Declaration of SoftKbd function object. This Function object could be used
* by other Tips to control Softkbd IMX's behavior.
*
* History:
*         11-April-2000  weibz     Created
\**************************************************************************/


#ifndef FNSOFTKBD_H
#define FNSOFTKBD_H

#include "private.h"

#include "softkbd.h"

class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CFnSoftKbd
//
//////////////////////////////////////////////////////////////////////////////

class CFnSoftKbd : public ITfFnSoftKbd
{
public:
    CFnSoftKbd(CFunctionProvider *pFuncPrv);
    ~CFnSoftKbd();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    //
    // ITfFnSoftKbd
    //

    STDMETHODIMP GetSoftKbdLayoutId(DWORD dwLayoutType, DWORD *lpdwLayoutId);
    STDMETHODIMP SetActiveLayoutId(DWORD  dwLayoutId );
    STDMETHODIMP SetSoftKbdOnOff(BOOL  fOn );
    STDMETHODIMP SetSoftKbdPosSize(POINT StartPoint, WORD width, WORD height);
    STDMETHODIMP SetSoftKbdColors(COLORTYPE  colorType, COLORREF Color);
    STDMETHODIMP GetActiveLayoutId(DWORD  *lpdwLayoutId );
    STDMETHODIMP GetSoftKbdOnOff(BOOL  *lpfOn );
    STDMETHODIMP GetSoftKbdPosSize(POINT *lpStartPoint,WORD *lpwidth,WORD *lpheight);
    STDMETHODIMP GetSoftKbdColors(COLORTYPE  colorType, COLORREF *lpColor);

private:
    friend CSoftkbdIMX;

    CFunctionProvider *_pFuncPrv; 

    long _cRef;
};

#endif // FNSOFTKBD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\maskbmp.h ===
//
// maskbmp.h
//


#ifndef MASKBMP_H
#define MASKBMP_H


#include "cmydc.h"

extern HINSTANCE g_hInst;

class CMaskBitmap
{
public:
    CMaskBitmap(HBITMAP hBmp)
    {
        BITMAP bmp;
        _hbmpOrg = hBmp;
        int nRet = GetObject(hBmp,sizeof(BITMAP), &bmp);
        Assert(nRet);
        _cx = bmp.bmWidth;
        _cy = bmp.bmHeight;
        _hbmp = NULL;
        _hbmpMask = NULL;
    }

    ~CMaskBitmap()
    {
       // Clear();
    }

    void Clear()
    {
        if (_hbmp)
        {
            DeleteObject(_hbmp);
            _hbmp = NULL;
        }

        if (_hbmpMask)
        {
            DeleteObject(_hbmpMask);
            _hbmpMask = NULL;
        }
    }

    BOOL Init(COLORREF rgb)
    {
        Clear();

        CBitmapDC hdcSrc(TRUE);
        CBitmapDC hdcDst(TRUE);
        CBitmapDC hdcMask(TRUE);
        CBitmapDC hdcMask2(TRUE);
        CSolidBrush hbrFore(rgb);

        HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
        HBRUSH hbrWhite = (HBRUSH)GetStockObject(WHITE_BRUSH);
        DWORD     DSPDxax;

        DSPDxax  = 0x00E20746L;

        COLORREF   crBLACK = RGB(0,0,0);
        COLORREF   crWHITE = RGB(255,255,255);
    
        hdcMask.SetBitmap(_cx, _cy, 1, 1);
        hdcDst.SetCompatibleBitmap(_cx, _cy);
        hdcSrc.SetBitmap(_hbmpOrg);
 
        // Generate mask to mask background color of original bitmap. WHITE
        BitBlt(hdcDst, 0, 0, _cx, _cy,hdcSrc, 0, 0, SRCCOPY);
        SetBkColor(hdcDst, crWHITE);
        BitBlt(hdcMask, 0, 0, _cx, _cy, hdcDst, 0, 0, SRCCOPY);
        _hbmpMask = hdcMask.GetBitmapAndKeep();

		// Generate mask to mask the foreground color of original bitmap:  BLACK
        hdcMask2.SetBitmap(_cx, _cy, 1, 1);
        SetBkColor(hdcDst, crBLACK);
        BitBlt(hdcMask2, 0, 0, _cx, _cy, hdcDst, 0, 0, SRCCOPY);

		// Change the original foreground color to specified rgb
        SelectObject(hdcDst, hbrFore);
        SetBkColor(hdcDst, crWHITE);
        BitBlt(hdcDst, 0, 0, _cx, _cy, hdcMask2, 0, 0, DSPDxax);

		// Change the original background WHITE color to BLACK to meet CUILIB's requirement.
        SelectObject(hdcDst, hbrBlack);
        SetBkColor(hdcDst, crWHITE);
        BitBlt(hdcDst, 0, 0, _cx, _cy, hdcMask, 0, 0, DSPDxax);

        _hbmp = hdcDst.GetBitmapAndKeep();
   
        DeleteObject(hbrBlack);
        DeleteObject(hbrWhite);
        return TRUE;
    }

    HBITMAP GetBmp() {return _hbmp;}
    HBITMAP GetBmpMask() {return _hbmpMask;}
    

private:
    int _cx;
    int _cy;
    HBITMAP _hbmpOrg;
    HBITMAP _hbmp;
    HBITMAP _hbmpMask;
};

#endif // MASKBMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\init.cpp ===
/**************************************************************************\
* Module Name: init.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Initialization functions for Soft Keyboard Component.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "osver.h"
#include "commctrl.h"
#include "cuilib.h"
#include "mui.h"

DECLARE_OSVER();


//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 1)
        goto Exit;

    fRet = TFInitLib();
    InitUIFLib();
    InitOSVer();

Exit:
    LeaveCriticalSection(GetServerCritSec());

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process deattach, like
// FreeLibrary calls.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    EnterCriticalSection(GetServerCritSec());

    if (DllRefCount() != 0) 
        goto Exit;

    DoneUIFLib();
    TFUninitLib();
    MuiFlushDlls(g_hInst);

Exit:
    LeaveCriticalSection(GetServerCritSec());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\nui.h ===
//
// nui.h
//

#ifndef NUI_H
#define NUI_H

#include "private.h"
#include "nuibase.h"

class CSoftkbdIMX;

class CLBarItem : public CLBarItemButtonBase
{
public:
    CLBarItem(CSoftkbdIMX *pimx);
    ~CLBarItem();

    STDMETHODIMP GetIcon(HICON *phIcon);
    void UpdateToggle();

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);

    CSoftkbdIMX *_pimx;
};

#endif // NUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for simx project.
//
//----------------------------------------------------------------------------


#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _OLEAUT32_

#include <windows.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <ccstock.h>
#include <debug.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include <initguid.h>
#include "msctf.h"
#include "msctfp.h"
#include "combase.h"
#include "mem.h"
#include "chkobj.h"
#include <atlbase.h>
#include "osver.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\resource.h ===
#define IDS_MENU_ON        200
#define IDS_MENU_OFF       201

#define IDS_SFTKBD_TIP_TEXT  300

#define IDS_SFTKBD_STANDARD_PROFILE  400
#define IDS_SFTKBD_SYMBOL_PROFILE    401

//
// Icon
//
#define ID_ICON_STANDARD   100
#define ID_ICON_SYMBOL     101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbd.cpp ===
/**************************************************************************\
* Module Name: softkbd.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
*  Main functions for Soft Keyboard Component.
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "resource.h"
#include <initguid.h>
#include "SoftKbd.h"

#include "SoftKbdc.h"
#include "SoftkbdIMX.h"

#include "regimx.h"
#include "catutil.h"

#include "mui.h"
#include "immxutil.h"

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

HINSTANCE  g_hInst;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SoftKbd, CSoftKbd, TEXT("SoftKbd Class"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SoftkbdIMX, CSoftkbdIMX, TEXT("SoftKbdIMX Class"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_SoftkbdRegistry, CSoftkbdRegistry, TEXT("SoftKbdRegistry Class"))
END_COCLASSFACTORY_TABLE

const GUID c_guidProfile = { /* 0965500c-82f3-49c2-9f00-01c2feacaa0b */
    0x0965500c,
    0x82f3,
    0x49c2,
    {0x9f, 0x00, 0x01, 0xc2, 0xfe, 0xac, 0xaa, 0x0b}
  };

const GUID c_guidProfileSym = {  // b2a54871-05f6-4bfc-b97d-0fdf0cbfa57d
    0xb2a54871,
    0x05f6,
    0x4bfc,
    {0xb9, 0x7d, 0x0f, 0xdf, 0x0c, 0xbf, 0xa5, 0x7d}
};

extern REGTIPLANGPROFILE c_rgProf[] =
{
    {0,  &GUID_NULL,      L"", L"",   0,  0}
};

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    if (!g_cs.Init())
        return FALSE;

    CcshellGetDebugFlags();
    Dbg_MemInit(TEXT("SOFTKBDIMX"), NULL);

    g_hInst = hInstance;

    MuiLoadResource(hInstance, TEXT("softkbd.dll"));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
    MuiClearResource();

    g_cs.Delete();

    Dbg_MemUninit();
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL bRet = TRUE;
#ifdef DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif

    switch (dwReason)
    {
     case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDettach(hInstance);
                bRet = FALSE;
            }
            break;

     case DLL_THREAD_ATTACH:
            break;

     case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;

     case DLL_THREAD_DETACH:
            break;
   }

#ifdef DEBUG
    g_dwThreadDllMain = 0;
#endif

   return bRet;

}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return COMBase_DllCanUnloadNow();
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return COMBase_DllGetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = E_FAIL;

    TFInitLib();

    // registers object, typelib and all interfaces in typelib
    if (COMBase_DllRegisterServer() != S_OK)
       goto Exit;

    if (!RegisterTIP(g_hInst, CLSID_SoftkbdIMX, L"On-screen keyboard", c_rgProf))
        goto Exit;

    if ( FAILED(RegisterCategory(CLSID_SoftkbdIMX, GUID_TFCAT_TIP_HANDWRITING, CLSID_SoftkbdIMX)))
        goto Exit;

    hr = S_OK;
Exit:
    TFUninitLib( );
    return hr;
    
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr=E_FAIL;

    TFInitLib();

    if (COMBase_DllUnregisterServer() != S_OK) 
       goto Exit;

    if (FAILED(UnregisterCategory(CLSID_SoftkbdIMX, GUID_TFCAT_TIP_HANDWRITING, CLSID_SoftkbdIMX)))
        goto Exit;

    if (!UnregisterTIP(CLSID_SoftkbdIMX))
        goto Exit;

    hr=S_OK;

Exit:
    TFUninitLib( );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\ctf\softkbd\softkbdc.cpp ===
/**************************************************************************\
* Module Name: softkbdc.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implementation of interface ISoftKbd 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "SoftKbdc.h"

#include "softkbdui.h"

#define   MAX_LABEL_LEN  20

/*******************************************************************************
 *
 * WstrToInt(  )                                        
 *
 * A utility function to convert a string to integer.
 *
/********************************************************************************/

WORD  WstrToInt(WCHAR  *wszStr)
{

   int  ret, i;

   if ( wszStr == NULL )
       return 0;

   ret = 0;
   i = 0;

   while ( wszStr[i] != L'\0' ) 
   {

       if ( (wszStr[i] < L'0') || (wszStr[i] > L'9') )
       {
    	   // this is not a legal string.
    	   // just return back 0.

    	   return 0;

       }
   
       ret = ret * 10 + (wszStr[i] - L'0');
       i++;
   }

   return (WORD)ret;
}

/*******************************************************************************
 *
 * Constructor function:                                         
 *
 * Initialize necessary data fields.
 *
/********************************************************************************/

CSoftKbd::CSoftKbd(  )
{

    
     _lpCurKbdLayout = NULL;
    _lpKbdLayoutDesList = NULL;
    _wCurKbdLayoutID = NON_KEYBOARD;

    _pSoftkbdUIWnd = NULL;
    _hOwner = NULL;

    _xReal = _yReal = _widthReal = _heightReal = 0;

    _pDoc = NULL;

    _pskbdwndes = NULL;
    _TitleBar_Type = TITLEBAR_NONE;

    _plfTextFont = NULL;
}

/*******************************************************************************
 *
 * Destructor                                        
 *
 * Free all allocated memories.
 *
/********************************************************************************/

CSoftKbd::~CSoftKbd( )
{
    KBDLAYOUTDES  *lpKbdLayoutDes;
    KBDLAYOUTDES  *lpLayoutDesTmp;
    KEYMAP        *lpKeyMapList;
    int            i, iState;

    SafeRelease(_pDoc);

    //
    //
    // Free Memory for soft keyboard layouts , and Label Text Mapping List
    //
    //

    lpKbdLayoutDes = _lpKbdLayoutDesList;

    while ( lpKbdLayoutDes != NULL ) 
    {

       KEYMAP        *lpKeyMapListTmp;

       lpKeyMapList = lpKbdLayoutDes->lpKeyMapList;

       while ( lpKeyMapList != NULL ) 
       {

          for ( i=0; i<(int)(lpKeyMapList->wNumOfKeys); i++) 
          {

    	     // free lppLabelText string for each state.
    	     for ( iState=0; iState < lpKeyMapList->lpKeyLabels[i].wNumModComb; iState++)
    	     {
                if (lpKeyMapList->lpKeyLabels[i].lppLabelText[iState])
                  SysFreeString(lpKeyMapList->lpKeyLabels[i].lppLabelText[iState]);
    	     }

    	     SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lppLabelText);

    	     SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelType);

             SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelDisp);

          }
   
          lpKeyMapListTmp = lpKeyMapList;

          lpKeyMapList = lpKeyMapList->pNext;

          SafeFreePointer(lpKeyMapListTmp);
       }
 
       lpLayoutDesTmp = lpKbdLayoutDes; 

       lpKbdLayoutDes = lpKbdLayoutDes->pNext;
   
       SafeFreePointer(lpLayoutDesTmp);
       
    }

    if ( _plfTextFont )
        SafeFreePointer(_plfTextFont);

    // Destroy the window if the window is still active.

    if ( _pSoftkbdUIWnd != NULL )
    {

    	DestroySoftKeyboardWindow( );
    	_pSoftkbdUIWnd = NULL;
    }
}


/*******************************************************************************
 *
 * Method function:  _LoadDocumentSync(  )                                        
 *
 * Load an XML Document from the specified file or URL synchronously.
 *
 *
 *   fFileName is TRUE, means pBURL contains XML file path.
 *   fFilename is FALSE, means pBURL contains real XML content 
 *
/********************************************************************************/

HRESULT CSoftKbd::_LoadDocumentSync(BSTR pBURL, BOOL fFileName)
{
    IXMLDOMParseError  *pXMLError = NULL;
    LONG            errorCode = E_FAIL;
    VARIANT         vURL;
    VARIANT_BOOL    vb;
    HRESULT         hr;


    if ( _pDoc == NULL ) {

    	return E_FAIL;
    }


    CHECKHR(_pDoc->put_async(VARIANT_FALSE));

    // Load xml document from the given URL or file path
    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = pBURL;

    if ( fFileName == TRUE )
    {
       CHECKHR(_pDoc->load(vURL, &vb));
    }
    else
    {
       CHECKHR(_pDoc->loadXML(pBURL, &vb) );
    }

    CHECKHR(_pDoc->get_parseError(&pXMLError));
    CHECKHR(pXMLError->get_errorCode(&errorCode));

    if (errorCode != 0)
    {

        hr = E_FAIL;
    }
                    
CleanUp:
    SafeReleaseClear(pXMLError);
   
    return hr;
}

/*******************************************************************************
 *
 * Method function:  Initialize(  )                                        
 *
 * Initialize all necessary field for this class object.
 * Generate Standard soft keyboard layouts.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::Initialize()
{

    // initialize standard layouts

    HRESULT             hr = S_OK;
    COLORTYPE           crType;

    // Initialize the different types of colors.
    // Following types of colors are supported.

    // bkcolor = 0 , for the window's back ground color
    // UnSelForeColor = 1, 
    // UnSelTextColor = 2,
    // SelForeColor =   3,
    // SelTextColor =   4

    crType = bkcolor;
    _color[crType] = GetSysColor(COLOR_MENU);

    crType = UnSelForeColor;
     _color[crType] = GetSysColor(COLOR_MENU);

    crType = UnSelTextColor;
    _color[crType] = GetSysColor(COLOR_WINDOWTEXT);

    crType = SelForeColor;
    _color[crType] = GetSysColor(COLOR_MENU);

    crType = SelTextColor;
    _color[crType] = GetSysColor(COLOR_WINDOWTEXT);

    CHECKHR(_CreateStandardSoftKbdLayout(SOFTKBD_US_STANDARD, L"IDSKD_STDUS101"));
    CHECKHR(_CreateStandardSoftKbdLayout(SOFTKBD_EURO_STANDARD, L"IDSKD_STDEURO102"));
    CHECKHR(_CreateStandardSoftKbdLayout(SOFTKBD_JPN_STANDARD, L"IDSKD_STDJPN106"));

CleanUp:

    return hr;
}


/*******************************************************************************
 *
 * Method function:  _CreateStandardSoftKbdLayout(  )                                        
 *
 * Create standard soft keyboard layout.
 *
 *    dwStdSoftKbdID,  predefined Standard soft keyboard layout ID.
 *
 *    wszStdResStr :   Resource ID string for the created standard soft keyboard.
 *
/********************************************************************************/

HRESULT CSoftKbd::_CreateStandardSoftKbdLayout(DWORD  dwStdSoftKbdID, WCHAR  *wszStdResStr )
{

    KBDLAYOUTDES        *pKbdLayout;
    BYTE                *lpszKeyboardDes;
    WCHAR               wszModuleFile[MAX_PATH];
    CHAR                szModuleFile[MAX_PATH];
    CHAR                szStdResStr[MAX_PATH];  // Ansi name of the Res Str ID
    WCHAR               wszInternalDesFileName[MAX_PATH];
    HRESULT             hr = S_OK;

    HGLOBAL             hResData = NULL;
    HRSRC               hRsRc = NULL;

    DWORD               dwFileLen;
    DWORD               dwResLen;

    dwFileLen = GetModuleFileNameA(g_hInst, szModuleFile, MAX_PATH);

    if ( dwFileLen == 0 )
    {
       hr = E_FAIL;
       return hr;
    } 

    MultiByteToWideChar(CP_ACP, 0, szModuleFile, -1,
    	                wszModuleFile, MAX_PATH);

    WideCharToMultiByte(CP_ACP, 0, wszStdResStr, -1, 
    	                szStdResStr, MAX_PATH, NULL, NULL );

    hRsRc = FindResourceA(g_hInst,szStdResStr, "SKDFILE" );

    if ( hRsRc == NULL )  return E_FAIL;

    dwResLen = SizeofResource(g_hInst, hRsRc);
    hResData =  LoadResource(g_hInst, hRsRc);

    if ( hResData == NULL ) return E_FAIL;

    lpszKeyboardDes = (BYTE  *)LockResource(hResData);

    if ( lpszKeyboardDes == NULL ) return E_FAIL;

    CHECKHR(_GenerateKeyboardLayoutFromSKD(lpszKeyboardDes, dwStdSoftKbdID, &pKbdLayout));

    // Change the internal DesFile name as following format:
    //
    //  SKDFILE: ResFileName : KBDResString to identify this layout's des file.
    //
    StringCchCopyW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L"SKDFILE:");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), wszModuleFile);
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L":");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), wszStdResStr );

    StringCchCopyW(pKbdLayout->KbdLayoutDesFile, ARRAYSIZE(pKbdLayout->KbdLayoutDesFile), wszInternalDesFileName);

    // link this new layout to the list.
    if ( _lpKbdLayoutDesList == NULL ) {

    	_lpKbdLayoutDesList = pKbdLayout;
    	pKbdLayout->pNext = NULL;

    }
    else
    {
    	pKbdLayout->pNext  = _lpKbdLayoutDesList;
    	_lpKbdLayoutDesList = pKbdLayout;
    }

CleanUp:

    return hr;
}

/*******************************************************************************
 *
 * Method function:  EnumSoftKeyBoard(  )                                        
 *
 * Enumerate all possible soft keybaord layouts.
 *
/********************************************************************************/


STDMETHODIMP CSoftKbd::EnumSoftKeyBoard(LANGID langid, DWORD *lpdwKeyboard)
{
    

/*    The return value could be  one of following:

      SOFTKBD_US_STANDARD
      SOFTKBD_US_ENHANCE
      SOFTKBD_EURO_STANDARD
      SOFTKBD_EURO_ENHANCE
      SOFTKBD_JPN_STANDARD
      SOFTKBD_JPN_ENHANCE

      Any customized soft keyboard layout

      SOFTKBD_NO_MORE.

*/


    return S_OK;
}

/*******************************************************************************
 *
 * Method function:  _GetXMLNodeValueWORD(  )                                        
 *
 * Get the WORD value for the specified Node.
 *
 *
/********************************************************************************/

HRESULT  CSoftKbd::_GetXMLNodeValueWORD(IXMLDOMNode *pNode,  WORD  *lpWord)
{

    HRESULT      hr = S_OK;
    IXMLDOMNode  *pValueChild = NULL;
    VARIANT      value;

    if ( (pNode == NULL) || (lpWord == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }


    CHECKHR(pNode->get_firstChild(&pValueChild));
    CHECKHR(pValueChild->get_nodeValue(&value));
    *lpWord = (WORD)WstrToInt(V_BSTR(&value));
    VariantClear(&value);

CleanUp:
    SafeRelease(pValueChild);
    return hr;

}


/*******************************************************************************
 *
 * Method function:  _ParseOneKeyInLayout(  )                                        
 *
 * Parse One Key in Layout Description, fill the data structure for
 * the specified key.
 *
 *
/********************************************************************************/

HRESULT  CSoftKbd::_ParseOneKeyInLayout(IXMLDOMNode *pNode, KEYDES  *lpKeyDes)
{


    HRESULT             hr;
    IXMLDOMNode         *pAttrChild = NULL, *pKey = NULL, *pKeyNext = NULL;
    BSTR                nodeName=NULL;
    IXMLDOMNamedNodeMap *pattrs=NULL;
    BSTR                name=NULL;
    VARIANT             value;
    IXMLDOMNode         *pValueChild=NULL;


    hr = S_OK;

    if ( (lpKeyDes == NULL)  || (pNode == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }

              
    if (SUCCEEDED(pNode->get_attributes(&pattrs)) && pattrs != NULL)
    {
        CHECKHR(pattrs->nextNode(&pAttrChild));

        while (pAttrChild)
    	{

          CHECKHR(pAttrChild->get_nodeName(&name));
          if ( wcscmp(name, xMODIFIER ) == 0 )
    	  {

    		CHECKHR(pAttrChild->get_nodeValue(&value));
            if (value.vt == VT_BSTR)
    		{
               if ( wcscmp(V_BSTR(&value), xNONE) == 0 )
                  lpKeyDes->tModifier = none;
    		   else if ( wcscmp(V_BSTR(&value), xCAPSLOCK) == 0 )
                  lpKeyDes->tModifier = CapsLock;
    		   else if ( wcscmp(V_BSTR(&value), xSHIFT) == 0 )
                  lpKeyDes->tModifier = Shift;
    		   else if ( wcscmp(V_BSTR(&value),xCTRL ) == 0 )
                  lpKeyDes->tModifier = Ctrl;
    		   else if ( wcscmp(V_BSTR(&value), xATL) == 0 )
                  lpKeyDes->tModifier = Alt;
               else if ( wcscmp(V_BSTR(&value), xALTGR) == 0 )
                  lpKeyDes->tModifier = AltGr;
    		   else if ( wcscmp(V_BSTR(&value), xKANA) == 0 )
                  lpKeyDes->tModifier = Kana;
    		   else if ( wcscmp(V_BSTR(&value), xNUMLOCK) == 0 )
                  lpKeyDes->tModifier = NumLock;
    		   else 
    		      lpKeyDes->tModifier = none;

    		}

            VariantClear(&value);
    	  }

    	  if ( name != NULL)
             SysFreeString(name);
          SafeReleaseClear(pAttrChild);
          CHECKHR(pattrs->nextNode(&pAttrChild));
    	}
        SafeReleaseClear(pattrs);
    }

    CHECKHR(pNode->get_firstChild(&pKey));

    while ( pKey ) 
    {
      CHECKHR(pKey->get_nodeName(&nodeName));
      CHECKHR(pKey->get_firstChild(&pValueChild));
      CHECKHR(pValueChild->get_nodeValue(&value));
      if ( wcscmp(nodeName, xKEYID ) == 0 )
      {
         lpKeyDes->keyId = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName,xLEFT ) == 0 )
      {
    	 lpKeyDes->wLeft = (WORD)WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xTOP) == 0 )
      {
         lpKeyDes->wTop = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xWIDTH) == 0 ) 
      {
         lpKeyDes->wWidth = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xHEIGHT) == 0 ) 
      {
         lpKeyDes->wHeight = WstrToInt(V_BSTR(&value));
      }

      VariantClear(&value);
      SafeReleaseClear(pValueChild);
    		
      if ( nodeName != NULL )   
      {
        SysFreeString(nodeName);
    	nodeName = NULL;
      }

      CHECKHR(pKey->get_nextSibling(&pKeyNext));
      SafeReleaseClear(pKey);
      pKey = pKeyNext;
    }


CleanUp:

    if ( FAILED(hr) )
    {
    	if ( nodeName != NULL )
    	{
    		SysFreeString(nodeName);
    		nodeName = NULL;
    	}

    	if ( pValueChild )
    		SafeReleaseClear(pValueChild);

    	if ( pKey )
    		SafeReleaseClear(pKey);
    }

    return hr;

}



/*******************************************************************************
 *
 * Method function:  _ParseLayoutDescription(  )                                        
 *
 * Parse Layout description part in the XML file, and fill the internal
 * Layout data structure.
 *
/********************************************************************************/

HRESULT  CSoftKbd::_ParseLayoutDescription(IXMLDOMNode *pLayoutChild,  KBDLAYOUT *pLayout)
{

    HRESULT   hr = S_OK;

    IXMLDOMNode         *pNode = NULL;
    IXMLDOMNode         *pChild = NULL, *pNext = NULL, *pAttrChild=NULL;

    BSTR                nodeName=NULL;
    IXMLDOMNamedNodeMap *pattrs=NULL;

    BSTR                name=NULL;
    VARIANT             value;
    int                 iKey;
    BSTR                pBURL = NULL;

    if ( (pLayoutChild == NULL) || (pLayout == NULL ) )
    {
    	hr = E_FAIL;
    	return hr;
    }

    iKey = 0;

    // Parse layout part.

    if (SUCCEEDED(pLayoutChild->get_attributes(&pattrs)) && pattrs != NULL)
    {
        //
    	//  Get the softkbe type attribute
    	//
        CHECKHR(pattrs->nextNode(&pAttrChild));
        while (pAttrChild)
    	{

          CHECKHR(pAttrChild->get_nodeName(&name));
          if ( wcscmp(name, xSOFTKBDTYPE)  ) 
    	  {
    		// this is not the right attribute.
    		  if ( name != NULL)
    		  {
                 SysFreeString(name);
    			 name = NULL;
    		  }

              SafeReleaseClear(pAttrChild);
              CHECKHR(pattrs->nextNode(&pAttrChild));
    		  continue;
    	  }

    	  if ( name != NULL)
    	  {
    	     SysFreeString(name);
    		 name = NULL;
    	  }

          CHECKHR(pAttrChild->get_nodeValue(&value));
          if (value.vt == VT_BSTR)
    	  {
             if ( wcscmp(V_BSTR(&value), xTCUSTOMIZED) == 0 )
                 pLayout->fStandard = FALSE;
    		 else
    			 pLayout->fStandard = TRUE;
    	  }

          VariantClear(&value);
    	  break;

    	}
        SafeReleaseClear(pattrs);
    }

    CHECKHR(pLayoutChild->get_firstChild(&pChild));

    pLayout->wLeft = 0;
    pLayout->wTop = 0;

    while ( pChild ) 
    {


       CHECKHR(pChild->get_nodeName(&nodeName));

       if ( wcscmp(nodeName, xWIDTH) == 0 )
       {

    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wWidth) ));

       }
       else if ( wcscmp(nodeName, xHEIGHT) == 0 )
       {
    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wHeight) ));

       }
       else if ( wcscmp(nodeName, xMARGIN_WIDTH) == 0 )
       {
    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wMarginWidth )));
       }
       else if ( wcscmp(nodeName, xMARGIN_HEIGHT) == 0 ) 
       {

    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wMarginHeight) ));

       }
       else if ( wcscmp(nodeName, xKEYNUMBER) == 0 )
       {
    	   CHECKHR(_GetXMLNodeValueWORD(pChild, &(pLayout->wNumberOfKeys) ));

       }
       else if ( wcscmp(nodeName, xKEY) == 0 )
       {
    	   KEYDES   *pKeyDes;

    	   pKeyDes = &(pLayout->lpKeyDes[iKey]);
           CHECKHR(_ParseOneKeyInLayout(pChild, pKeyDes) );
    	   iKey++;
       }

       if (nodeName != NULL)
       {
          SysFreeString(nodeName);
    	  nodeName = NULL;
       }

    	CHECKHR(pChild->get_nextSibling(&pNext));
        SafeReleaseClear(pChild);
        pChild = pNext;
    }


CleanUp:

    if ( FAILED(hr) )
    {
    	if (nodeName != NULL )
    	{
    		SysFreeString(nodeName);
    		nodeName = NULL;
    	}

    	if ( pChild )
    		SafeReleaseClear(pChild);
    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  _ParseOneKeyInLabel(  )                                        
 *
 * Parse One Key in Label Description, fill the data structure for
 * the specified key
 *
 *
/********************************************************************************/

HRESULT  CSoftKbd::_ParseOneKeyInLabel(IXMLDOMNode *pNode, KEYLABELS  *lpKeyLabels)
{

  IXMLDOMNode         *pValueChild = NULL;
  HRESULT             hr = S_OK;
  IXMLDOMNode         *pAttrChild = NULL, *pKey=NULL, *pKeyNext=NULL;
  BSTR                nodeName=NULL;
  IXMLDOMNamedNodeMap *pattrs=NULL;

  BSTR                name=NULL;
  VARIANT             value;
  
  int  iState;
  iState = 0;

  if ( (pNode == NULL) || (lpKeyLabels == NULL) )
  {
      hr = E_FAIL;
      return hr;
  }

  CHECKHR(pNode->get_firstChild(&pKey));

  while ( pKey ) 
  {
      CHECKHR(pKey->get_nodeName(&nodeName));
      CHECKHR(pKey->get_firstChild(&pValueChild));
      CHECKHR(pValueChild->get_nodeValue(&value));

      if ( wcscmp(nodeName, xKEYID) == 0 )
      {
         lpKeyLabels->keyId = WstrToInt(V_BSTR(&value));
      }
      else if ( wcscmp(nodeName, xVALIDSTATES) == 0 )
      {
    	 lpKeyLabels->wNumModComb = WstrToInt(V_BSTR(&value));
     	 lpKeyLabels->lppLabelText = (BSTR *)cicMemAllocClear( 
    		                          lpKeyLabels->wNumModComb * sizeof(BSTR) );


    	 if ( lpKeyLabels->lppLabelText == NULL )
    	 {
    		 // Not enough memory.
             // release all allocated memory.
    		 
    		 hr = E_OUTOFMEMORY;
    		 goto CleanUp;
    	 }
    				 

    	 lpKeyLabels->lpLabelType = (WORD *)cicMemAllocClear(
    		              lpKeyLabels->wNumModComb * sizeof(WORD) );

    	 if ( lpKeyLabels->lpLabelType == NULL )
    	 {
    		 // Not enough memory.
             // release all allocated memory.
     	     
    		 hr = E_OUTOFMEMORY;
    		 goto CleanUp;

    	 }

    	 lpKeyLabels->lpLabelDisp = (WORD *)cicMemAllocClear(
    		              lpKeyLabels->wNumModComb * sizeof(WORD) );

    	 if ( lpKeyLabels->lpLabelDisp == NULL )
    	 {
    		 // Not enough memory.
             // release all allocated memory.
     	     
    		 hr = E_OUTOFMEMORY;
    		 goto CleanUp;

    	 }


      }
      else if ( wcscmp(nodeName, xLABELTEXT) == 0 ) 
      {
    	  if ( iState < lpKeyLabels->wNumModComb )
    	  {
    	     lpKeyLabels->lppLabelText[iState]=SysAllocString(V_BSTR(&value));

             // set the default value for label type and label disp attribute.

             lpKeyLabels->lpLabelType[iState] = LABEL_TEXT;
             lpKeyLabels->lpLabelDisp[iState] = LABEL_DISP_ACTIVE;

    		 // Get the label type:  Text or Picture.
    		 // if it is picture, the above string stands for path of bitmap file.

    		 if (SUCCEEDED(pKey->get_attributes(&pattrs)) && pattrs != NULL)
    		 {
                CHECKHR(pattrs->nextNode(&pAttrChild));
                while (pAttrChild)
    			{

                   CHECKHR(pAttrChild->get_nodeName(&name));
                   if ( wcscmp(name, xLABELTYPE) == 0 ) 
    			   {

                       CHECKHR(pAttrChild->get_nodeValue(&value));
                      if (value.vt == VT_BSTR)
                      {
                         if ( wcscmp(V_BSTR(&value),xTEXT ) == 0 )
                            lpKeyLabels->lpLabelType[iState] = LABEL_TEXT;
                         else
    	                    lpKeyLabels->lpLabelType[iState] = LABEL_PICTURE;
                      }

    			      VariantClear(&value);
    	              
                   }
                   else if ( wcscmp(name, xLABELDISP) == 0 ) 
    			   {

                      CHECKHR(pAttrChild->get_nodeValue(&value));
                      if (value.vt == VT_BSTR)
                      {
                         if ( wcscmp(V_BSTR(&value),xGRAY ) == 0 )
                            lpKeyLabels->lpLabelDisp[iState] = LABEL_DISP_GRAY;
                         else
    	                    lpKeyLabels->lpLabelDisp[iState] = LABEL_DISP_ACTIVE;
                      }

    			      VariantClear(&value);
    	              
                   }

                   if ( name != NULL)
    			   {
                      SysFreeString(name);
    			      name = NULL;
    			   }

                   SafeReleaseClear(pAttrChild);
                   CHECKHR(pattrs->nextNode(&pAttrChild));

    			}
                SafeReleaseClear(pattrs);
    		}

    	  }

    	  iState++;

    	
      }

      VariantClear(&value);
      SafeReleaseClear(pValueChild);
    			             
      if ( nodeName != NULL)
      {
         SysFreeString(nodeName);
    	 nodeName = NULL;
      }

      CHECKHR(pKey->get_nextSibling(&pKeyNext));
      SafeRelease(pKey);
      pKey = pKeyNext;
  }

CleanUp:

  if ( FAILED(hr) )
  {

      if ( pKey )
    	  SafeReleaseClear(pKey);

      if ( name != NULL)
      {
         SysFreeString(name);
    	 name = NULL;
      }

      if ( pAttrChild )
    	  SafeReleaseClear(pAttrChild);

      if ( pValueChild )
    	  SafeReleaseClear(pValueChild);

      if ( lpKeyLabels->lppLabelText != NULL )
      {

          while ( iState >= 0 )
    	  {

    		  if ( lpKeyLabels->lppLabelText[iState] )
    		  {
    			  SysFreeString(lpKeyLabels->lppLabelText[iState]);
                  lpKeyLabels->lppLabelText[iState] = NULL;
    		  }

    		  iState --;

    	  }

    	  SafeFreePointer(lpKeyLabels->lppLabelText);
      }


      if ( lpKeyLabels->lpLabelType != NULL )
      {
    	  SafeFreePointer(lpKeyLabels->lpLabelType);
      }

      if ( lpKeyLabels->lpLabelDisp != NULL )
      {
    	  SafeFreePointer(lpKeyLabels->lpLabelDisp);
      }


  }

  return hr;

}


/*******************************************************************************
 *
 * Method function:  _ParseMappingDescription(  )                                        
 *
 * Parse Mapping description part in the XML file, and fill the internal
 * Mapping Table structure.
 *
/********************************************************************************/

HRESULT CSoftKbd::_ParseMappingDescription( IXMLDOMNode *pLabelChild, KEYMAP *lpKeyMapList )
{

    HRESULT             hr = S_OK;
    IXMLDOMNode         *pChild=NULL, *pNext=NULL;
    BSTR                nodeName=NULL;
    int                 iKey;
    BSTR                pBURL = NULL;


    // Parse for customized layout

    if ( (pLabelChild == NULL) || (lpKeyMapList == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }
    	
    iKey = 0;

    CHECKHR(pLabelChild->get_firstChild(&pChild));

    while ( pChild ) 
    {

      CHECKHR(pChild->get_nodeName(&nodeName));

      if ( wcscmp(nodeName, xVALIDSTATES) == 0 )
      {
         CHECKHR(_GetXMLNodeValueWORD(pChild, &(lpKeyMapList->wNumModComb) ));
      }
      else if ( wcscmp(nodeName, xKEYNUMBER) == 0 )
      {

          CHECKHR(_GetXMLNodeValueWORD(pChild, &(lpKeyMapList->wNumOfKeys) ));

      }
      else if ( wcscmp(nodeName, xRESOURCEFILE) == 0 )
      {

            IXMLDOMNode  *pValueChild;
          VARIANT      value;

          CHECKHR(pChild->get_firstChild(&pValueChild));
          if ( FAILED((pValueChild->get_nodeValue(&value))))
    	  {
    		  SafeRelease(pValueChild);
    		  goto CleanUp;
    	  }

          StringCchCopyW(lpKeyMapList->wszResource, ARRAYSIZE(lpKeyMapList->wszResource), V_BSTR(&value) );
          VariantClear(&value);

          SafeRelease(pValueChild);

      }
      else if ( wcscmp(nodeName, xKEYLABEL) == 0 )
      {

    	  KEYLABELS  *lpKeyLabels;

    	  lpKeyLabels = &(lpKeyMapList->lpKeyLabels[iKey]);

    	  CHECKHR(_ParseOneKeyInLabel(pChild, lpKeyLabels));

    	  iKey++;
      }

      if ( nodeName != NULL)
      {
         SysFreeString(nodeName);
    	 nodeName = NULL;
      }

      pChild->get_nextSibling(&pNext);
      SafeReleaseClear(pChild);
      pChild = pNext;
    }



CleanUp:

    if ( FAILED(hr) )
    {

      if ( nodeName != NULL)
      {
         SysFreeString(nodeName);
    	 nodeName = NULL;
      }
      
      if ( pChild != NULL )
    	  SafeReleaseClear(pChild);

      if ( lpKeyMapList ) {

    	  int i, iState;

          for ( i=0; i<(int)(lpKeyMapList->wNumOfKeys); i++) 
    	  {

    	    // free lppLabelText string for each state.
    	    for ( iState=0; iState < lpKeyMapList->lpKeyLabels[i].wNumModComb; iState++)
    		{
               if (lpKeyMapList->lpKeyLabels[i].lppLabelText[iState])
                  SysFreeString(lpKeyMapList->lpKeyLabels[i].lppLabelText[iState]);
    		}

    	    SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lppLabelText);

    	    SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelType);

    	    SafeFreePointer(lpKeyMapList->lpKeyLabels[i].lpLabelDisp);

    	  }

      }


    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  _GenerateMapDesFromSKD(  )                                        
 *
 * Generate Mapping description part in the KBD file, and fill the internal
 * Mapping Table structure.
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateMapDesFromSKD(BYTE *pMapTable, KEYMAP *lpKeyMapList)
{
    HRESULT    hr = S_OK;
    int        iKey;
	WORD       wNumModComb;
	WORD       wNumOfKeys;
	WORD       *pMapPtr;


    // Parse for customized layout
	// Customized layout doesn't care about HKL, so there will be only one KeyMapList per layout.

    if ( (pMapTable == NULL) || (lpKeyMapList == NULL) )  return E_FAIL;

	pMapPtr = (WORD *)pMapTable;

	wNumModComb = pMapPtr[0];
	wNumOfKeys =  pMapPtr[1];

	pMapPtr += 2;
	lpKeyMapList->wNumModComb = wNumModComb;
	lpKeyMapList->wNumOfKeys = wNumOfKeys;

	StringCchCopyW(lpKeyMapList->wszResource, ARRAYSIZE(lpKeyMapList->wszResource), (WCHAR *)pMapPtr);

	pMapPtr += wcslen((WCHAR *)pMapPtr) + 1;  // Plus NULL terminator

	// Now strat to fill every Keylabel.

	for ( iKey=0; iKey<wNumOfKeys; iKey++)
	{

		KEYLABELS  *lpKeyLabel;
		WORD        wNumModInKey;
		int         jMod;

		lpKeyLabel = &(lpKeyMapList->lpKeyLabels[iKey]);

		lpKeyLabel->keyId = *pMapPtr;
		pMapPtr += sizeof(KEYID)/sizeof(WORD);

		wNumModInKey = *pMapPtr;
		pMapPtr++;
		lpKeyLabel->wNumModComb = wNumModInKey;

     	lpKeyLabel->lppLabelText=(BSTR *)cicMemAllocClear(lpKeyLabel->wNumModComb * sizeof(BSTR) );
    	if ( lpKeyLabel->lppLabelText == NULL )
    	{
   			// Not enough memory.
            // release all allocated memory.
    	
	   		 hr = E_OUTOFMEMORY;
			 goto CleanUp;
    	}
    				 
    	lpKeyLabel->lpLabelType = (WORD *)cicMemAllocClear(lpKeyLabel->wNumModComb * sizeof(WORD) );
	  	if ( lpKeyLabel->lpLabelType == NULL )
    	{
    		// Not enough memory.
            // release all allocated memory.
     	    
    		hr = E_OUTOFMEMORY;
    		goto CleanUp;
    	}
    	lpKeyLabel->lpLabelDisp = (WORD *)cicMemAllocClear(lpKeyLabel->wNumModComb * sizeof(WORD));
  		if ( lpKeyLabel->lpLabelDisp == NULL )
    	{
    		// Not enough memory.
            // release all allocated memory.
     	    
    		hr = E_OUTOFMEMORY;
    		goto CleanUp;
    	}

		for ( jMod=0; jMod < wNumModInKey; jMod++)
		{
			lpKeyLabel->lppLabelText[jMod] = SysAllocString( pMapPtr );
			pMapPtr += wcslen(pMapPtr) + 1;
		}

		CopyMemory(lpKeyLabel->lpLabelType, pMapPtr, wNumModInKey * sizeof(WORD) );
		pMapPtr += wNumModInKey;

		CopyMemory(lpKeyLabel->lpLabelDisp, pMapPtr, wNumModInKey * sizeof(WORD) );
		pMapPtr += wNumModInKey;
	}

CleanUp:
    if ( FAILED(hr) )
    {
	  // Release all allocated memory in this function.

   	  int i;

      for (i=0; i<=iKey; i++) 
  	  {
		KEYLABELS  *lpKeyLabel;
		int         jMod;

		if (lpKeyLabel = &(lpKeyMapList->lpKeyLabels[i]))
        {

   	       // free lppLabelText string for each state.
   	       for ( jMod=0; jMod<lpKeyLabel->wNumModComb; jMod++)
   		   {
              if (lpKeyLabel->lppLabelText && lpKeyLabel->lppLabelText[jMod])
                 SysFreeString(lpKeyLabel->lppLabelText[jMod]);
   		   }

   	       SafeFreePointer(lpKeyLabel->lppLabelText);
   	       SafeFreePointer(lpKeyLabel->lpLabelType);
 	       SafeFreePointer(lpKeyLabel->lpLabelDisp);
        }
   	  }
    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  ParseKeyboardLayout(  )                                        
 *
 * Parse Keyboard Layout description XML file, and fill the internal
 * Layout and Mapping Table structure.
 *
 *   if fFileName is TRUE, means lpszKeyboardDesFile stands for a file name
 *   if it is FALSE, lpszKeyboardDesFile points to the real memory block which 
 *                   contains XML content.
/********************************************************************************/

HRESULT CSoftKbd::_ParseKeyboardLayout(BOOL   fFileName, WCHAR  *lpszKeyboardDesFile, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout )
{

    KBDLAYOUTDES        *pKbdLayout = NULL;
    KBDLAYOUT           *pLayout = NULL;
    IXMLDOMNode         *pNode = NULL;
    IXMLDOMNode         *pLayoutChild =NULL, *pLabelChild = NULL, *pNext = NULL, *pRoot=NULL ;
    BSTR                nodeName=NULL;
    KEYMAP              *lpKeyMapList = NULL;
    BSTR                pBURL = NULL;
    HRESULT             hr = S_OK;



    if ( (lpszKeyboardDesFile == NULL) || ( lppKbdLayout == NULL) )
    {
    	// 
    	// this is not appropriate parameter.
    	//

    	hr = E_FAIL;
    	return hr;
    }

    if ( _pDoc == NULL )
    {
    	// the first time this method is called.
       hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                        IID_IXMLDOMDocument, (void**)&_pDoc);

       if ( FAILED(hr) )
    	   return hr;
    }

    pKbdLayout = (KBDLAYOUTDES *)cicMemAllocClear(sizeof(KBDLAYOUTDES) );

    if ( pKbdLayout == NULL )
    {
    	hr = E_OUTOFMEMORY;
    	return hr;
    }

    pKbdLayout->wKbdLayoutID = dwKbdLayoutID;
    pKbdLayout->ModifierStatus = 0;
    pKbdLayout->CurModiState = 0;
    pKbdLayout->lpKeyMapList = NULL;
    if ( fFileName == TRUE )
       StringCchCopyW(pKbdLayout->KbdLayoutDesFile, ARRAYSIZE(pKbdLayout->KbdLayoutDesFile), lpszKeyboardDesFile );
    else
    {
    	//
    	// we just set "_string" at this moment,
    	// after this function returns, the caller needs to set the real 
    	// file path + resource ID as its new desfilepath.
    	//
       wcscpy(pKbdLayout->KbdLayoutDesFile, L"_String");
    }

    pLayout = &(pKbdLayout->kbdLayout);

    if ( fFileName == TRUE )
        pBURL = SysAllocString(lpszKeyboardDesFile);
    else
    	pBURL = lpszKeyboardDesFile;

    CHECKHR(_LoadDocumentSync(pBURL, fFileName));

    CHECKHR(_pDoc->QueryInterface(IID_IXMLDOMNode,(void**)&pNode));

    CHECKHR(pNode->get_firstChild(&pRoot));

    CHECKHR(pRoot->get_nodeName(&nodeName));

    // Get the Root node

    while ( wcscmp(nodeName, xSOFTKBDDES) ) {

         pRoot->get_nextSibling(&pNext);
         pRoot->Release();
         pRoot = pNext;
    	 if ( nodeName != NULL )
            SysFreeString(nodeName);
         pRoot->get_nodeName(&nodeName);

    }

    if ( nodeName != NULL )
       SysFreeString(nodeName);

    // Get the layout child and label child,

    pLayoutChild = pLabelChild = NULL;

    pRoot->get_firstChild(&pLayoutChild);

    if ( pLayoutChild != NULL )
       pLayoutChild->get_nextSibling(&pLabelChild);

    CHECKHR(_ParseLayoutDescription(pLayoutChild, pLayout) );

    // Handle Label part.

    if ( pLayout->fStandard == TRUE )
    {
    	// 
    	// Generate mapping table for standard layout
    	//

    	// Mapping table is generated by SetKeyboardLabelText( ) method.
 
    
    	goto  CleanUp;
    }

    if ( pLabelChild == NULL )
    {
    	// the XML file is not complete.

    	hr = E_FAIL;
    	goto CleanUp;
    }

    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );

    if ( lpKeyMapList == NULL )
    {
    	SafeFreePointer(pKbdLayout);
    	hr = E_OUTOFMEMORY;

    	goto CleanUp;
    }

    CHECKHR(_ParseMappingDescription(pLabelChild, lpKeyMapList));

    pKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    SafeReleaseClear(pLayoutChild);

    if ( pLabelChild != NULL )
       pLabelChild->Release( );

    SafeReleaseClear(pRoot);

    SafeReleaseClear(pNode);

    if ( fFileName == TRUE )
       SysFreeString(pBURL);

    if ( FAILED(hr) )
    {
    	if  ( pKbdLayout != NULL )
    		SafeFreePointer(pKbdLayout);

    	if ( lpKeyMapList != NULL )
    		SafeFreePointer( lpKeyMapList );

    }
    else
    {
       if ( lppKbdLayout != NULL )
            *lppKbdLayout = pKbdLayout;
       
    }

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateKeyboardLayoutFromSKD(  )                                        
 *
 * KBD file is a precompiled xml file, it is binary format, This KBD has been put 
 * into the resource section of DLL, the resource type is SKDFILE.
 *
 * This method function will read the resource content and try to fill the internal
 * Layout and Mapping Table structure.
 *
 ********************************************************************************/

HRESULT CSoftKbd::_GenerateKeyboardLayoutFromSKD(BYTE  *lpszKeyboardDes, DWORD dwKbdLayoutID, KBDLAYOUTDES **lppKbdLayout)
{

    KBDLAYOUTDES        *pKbdLayout = NULL;
    KBDLAYOUT           *pLayout = NULL;
	BYTE                *pMapTable = NULL;
    KEYMAP              *lpKeyMapList = NULL;
    WORD                wNumberOfKeys, wLenLayout;
    HRESULT             hr = S_OK;

    if ( (lpszKeyboardDes == NULL) || ( lppKbdLayout == NULL) )
    {
    	// 
    	// this is not appropriate parameter.
    	//
		return E_FAIL;
    }

    pKbdLayout = (KBDLAYOUTDES *)cicMemAllocClear(sizeof(KBDLAYOUTDES) );

    if ( pKbdLayout == NULL )
    {
    	hr = E_OUTOFMEMORY;
    	return hr;
    }

    pKbdLayout->wKbdLayoutID = dwKbdLayoutID;
    pKbdLayout->ModifierStatus = 0;
    pKbdLayout->CurModiState = 0;
    pKbdLayout->lpKeyMapList = NULL;
  	//
   	// we just set "_string" at this moment,
   	// after this function returns, the caller needs to set the real 
   	// file path + resource ID as its new desfilepath.
   	//
    wcscpy(pKbdLayout->KbdLayoutDesFile, L"_String");

    pLayout = &(pKbdLayout->kbdLayout);

    // Fill the layout internal structure from lpszKeyboardDes.

    wNumberOfKeys = *(lpszKeyboardDes + sizeof(WORD) * 6 + sizeof(BOOL));
    wLenLayout = sizeof(WORD) * 7 + sizeof(BOOL) + wNumberOfKeys * sizeof(KEYDES);
	CopyMemory(pLayout, lpszKeyboardDes, wLenLayout);
    
    // Handle Label part.
    if ( pLayout->fStandard == TRUE )
    {
    	// Mapping table is generated later by SetKeyboardLabelText( ) method.
 	   	goto  CleanUp;
    }

    lpKeyMapList=(KEYMAP *)cicMemAllocClear(sizeof(KEYMAP));

    if ( lpKeyMapList == NULL )
    {
    	SafeFreePointer(pKbdLayout);
    	hr = E_OUTOFMEMORY;
    	goto CleanUp;
    }

	//Get the start position of Mapping Table content.

	pMapTable = lpszKeyboardDes + wLenLayout;

    CHECKHR(_GenerateMapDesFromSKD(pMapTable, lpKeyMapList));

    pKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    if ( FAILED(hr) )
    {
    	if  ( pKbdLayout != NULL )
    		SafeFreePointer(pKbdLayout);

    	if ( lpKeyMapList != NULL )
    		SafeFreePointer( lpKeyMapList );
    }
    else
    {
       if ( lppKbdLayout != NULL )
            *lppKbdLayout = pKbdLayout;
       
    }
    return hr;
}


/*******************************************************************************
 *
 * Method function:  CreateSoftKeyboardLayoutFromXMLFile(  )                                        
 *
 * Create the real Soft Keyboard layout based on specified description XML file.
 *
/********************************************************************************/


STDMETHODIMP CSoftKbd::CreateSoftKeyboardLayoutFromXMLFile(WCHAR  *lpszKeyboardDesFile,INT  szFileStrLen, DWORD *pdwLayoutCookie)
{

    DWORD               dwCurKbdLayoutID;
    KBDLAYOUTDES        *pKbdLayout=NULL;
    HRESULT             hr = S_OK;


    dwCurKbdLayoutID = SOFTKBD_CUSTOMIZE_BEGIN;

    if ( _lpKbdLayoutDesList != NULL ) 
    {

       // check if this des file is alreay parsed.

    	pKbdLayout = _lpKbdLayoutDesList;

    	while ( pKbdLayout != NULL ) {

    		if ( pKbdLayout->wKbdLayoutID > dwCurKbdLayoutID )
    			dwCurKbdLayoutID = pKbdLayout->wKbdLayoutID;

    		if ( wcscmp(pKbdLayout->KbdLayoutDesFile, lpszKeyboardDesFile) == 0 )
    		{

    			// find it.

    			*pdwLayoutCookie = pKbdLayout->wKbdLayoutID;

    			hr = S_OK;

    			return hr;
    		}


    		pKbdLayout = pKbdLayout->pNext;

    	}

    }


    // this is a new des file

    dwCurKbdLayoutID ++;

    CHECKHR(_ParseKeyboardLayout(TRUE, lpszKeyboardDesFile, dwCurKbdLayoutID, &pKbdLayout));

    // link this new layout to the list.

    pKbdLayout->CurModiState = 0;  // use state 0 as initialization

    if ( _lpKbdLayoutDesList == NULL ) {

    	_lpKbdLayoutDesList = pKbdLayout;
    	pKbdLayout->pNext = NULL;

    }
    else
    {
    	pKbdLayout->pNext  = _lpKbdLayoutDesList;
    	_lpKbdLayoutDesList = pKbdLayout;
    }

    *pdwLayoutCookie = pKbdLayout->wKbdLayoutID;

CleanUp:

    return hr;
}


/*******************************************************************************
 *
 * Method function:  CreateSoftKeyboardLayoutFromResource(  )                                        
 *
 * Create the real Soft Keyboard layout based on XML content in resource section
 * There will be two kinds of resouces, XMLFILE, and SKDFILE,  SKDFILE is a 
 * Precomipled XML binary file.
 *
 *  lpszResFile :   path of file which contains XML content in its resource.
 *  lpszResString : resource string identifier for the XML or KBD resource.
 *
 *    the resource Type could be either "XMLFILE" or "SKDFILE"
 *
 *  lpdwLayoutCookie: receive the returned layout id.
 *
/********************************************************************************/


HRESULT CSoftKbd::CreateSoftKeyboardLayoutFromResource(WCHAR *lpszResFile, WCHAR  *lpszResType, WCHAR *lpszResString, DWORD *lpdwLayoutCookie)
{
    DWORD               dwCurKbdLayoutID;
    KBDLAYOUTDES        *pKbdLayout=NULL;
    WCHAR               *lpszKeyboardDesFile=NULL;
    WCHAR               wszInternalDesFileName[MAX_PATH];
    CHAR                lpszAnsiResString[MAX_PATH];
    CHAR                lpszAnsiResFile[MAX_PATH];
    CHAR                lpszAnsiResType[MAX_PATH];
    HMODULE             hResFile = NULL;
    HRSRC               hRsRc = NULL;
    HGLOBAL             hResData = NULL;
    HRESULT             hr = S_OK;
    BOOL                fXMLUnicode=TRUE;
    DWORD               dwResLen;


    if ( (lpszResFile == NULL) || (lpszResString == NULL) || (lpszResType == NULL) || ( lpdwLayoutCookie == NULL) )
    {
    	hr = E_FAIL;
    	return hr;
    }

    //
    // Generate internal DesFile Name
    //
    StringCchCopyW(wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), lpszResType);
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L":");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), lpszResFile );
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), L":");
    StringCchCatW( wszInternalDesFileName, ARRAYSIZE(wszInternalDesFileName), lpszResString );


    dwCurKbdLayoutID = SOFTKBD_CUSTOMIZE_BEGIN;

    if ( _lpKbdLayoutDesList != NULL ) 
    {

       // check if this des file is alreay parsed.

    	pKbdLayout = _lpKbdLayoutDesList;

    	while ( pKbdLayout != NULL ) {

    		if ( pKbdLayout->wKbdLayoutID > dwCurKbdLayoutID )
    			dwCurKbdLayoutID = pKbdLayout->wKbdLayoutID;

    		if ( wcscmp(pKbdLayout->KbdLayoutDesFile, wszInternalDesFileName) == 0 )
    		{
    			// find it.
    			*lpdwLayoutCookie = pKbdLayout->wKbdLayoutID;

    			hr = S_OK;
    			return hr;
    		}
    		pKbdLayout = pKbdLayout->pNext;
    	}

    }

    // this is a new des file
    dwCurKbdLayoutID ++;
    WideCharToMultiByte(CP_ACP, 0, lpszResFile, -1, 
    	                lpszAnsiResFile, MAX_PATH, NULL, NULL );

    hResFile = LoadLibraryA(lpszAnsiResFile);
    if ( hResFile == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    WideCharToMultiByte(CP_ACP, 0, lpszResString, -1, 
    	                lpszAnsiResString, MAX_PATH, NULL, NULL );

    WideCharToMultiByte(CP_ACP, 0, lpszResType, -1, 
    	                lpszAnsiResType, MAX_PATH, NULL, NULL );

    hRsRc = FindResourceA(hResFile, lpszAnsiResString, lpszAnsiResType );

    if ( hRsRc == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    dwResLen = SizeofResource(hResFile, hRsRc);

    hResData =  LoadResource(hResFile, hRsRc );

    if ( hResData == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    lpszKeyboardDesFile = (WCHAR  *)LockResource(hResData);

    if ( lpszKeyboardDesFile == NULL )
    {
    	hr = E_FAIL;
    	goto CleanUp;
    }

    if ( wcscmp(lpszResType, L"SKDFILE") == 0 )
    {
        CHECKHR(_GenerateKeyboardLayoutFromSKD((BYTE *)lpszKeyboardDesFile, dwCurKbdLayoutID, &pKbdLayout));
    }
    else if ( wcscmp(lpszResType, L"XMLFILE") == 0 )
    {
        // This is XMLFILE resource
        //
        // we assume the XML content in resource is in Unicode format.
        //

        if ( lpszKeyboardDesFile[0] == 0xFEFF )
        {
    	    fXMLUnicode = TRUE;
            lpszKeyboardDesFile = lpszKeyboardDesFile + 1;
        }
        else
        {
    	    // if the content is  UTF-8, we need to translate the string to Unicode
    	    //

    	    char      *lpszXMLContentUtf8;
    	    int       iSize;

    	    lpszXMLContentUtf8 = (char *)lpszKeyboardDesFile;
    	    lpszKeyboardDesFile = NULL;

    	    iSize = _Utf8ToUnicode(lpszXMLContentUtf8, dwResLen ,NULL, 0 );

    	    if ( iSize == 0 )
        	{
        		hr = E_FAIL;
    	    	goto CleanUp;
    	    }

    	    fXMLUnicode = FALSE;

            lpszKeyboardDesFile = (WCHAR *) cicMemAllocClear( (iSize+1) * sizeof(WCHAR) );

    	    if ( lpszKeyboardDesFile == NULL )
    	    {
    		    hr = E_FAIL;
    		    goto CleanUp;
    	    }

    	    iSize = _Utf8ToUnicode(lpszXMLContentUtf8, dwResLen,lpszKeyboardDesFile, iSize+1 );

    	    if ( iSize == 0 )
        	{
        		hr = E_FAIL;
    	    	goto CleanUp;
    	    }

    	    lpszKeyboardDesFile[iSize] = L'\0';
        }

        CHECKHR(_ParseKeyboardLayout(FALSE, lpszKeyboardDesFile, dwCurKbdLayoutID, &pKbdLayout));
    }
    else
    {
        // This resource type is not supported.
        hr = E_FAIL;
        goto CleanUp;
    }

    // Change the internal DesFile name as following format:
    //
    //  XMLRES: ResFileName : XMLResString  to identify this layout's des file.
    // Or 
    //  KBDRES: ResFileName : KBDResString  
    //

    wcscpy(pKbdLayout->KbdLayoutDesFile, wszInternalDesFileName);

    // link this new layout to the list.

    pKbdLayout->CurModiState = 0;  // use state 0 as initialization

    if ( _lpKbdLayoutDesList == NULL ) {

    	_lpKbdLayoutDesList = pKbdLayout;
    	pKbdLayout->pNext = NULL;

    }
    else
    {
    	pKbdLayout->pNext  = _lpKbdLayoutDesList;
    	_lpKbdLayoutDesList = pKbdLayout;
    }

    *lpdwLayoutCookie = pKbdLayout->wKbdLayoutID;

CleanUp:

    if ( hResFile != NULL )
    	FreeLibrary(hResFile);

    if ( (fXMLUnicode == FALSE) && ( lpszKeyboardDesFile != NULL ) )
    	SafeFreePointer(lpszKeyboardDesFile);

    return hr;
}


HRESULT  CSoftKbd::_GenerateRealKbdLayout(  ) 
{
    float         fWidRat, fHigRat;
    INT           i;
    KBDLAYOUT     *realKbdLayout;
    HRESULT       hr;

    WORD          skbd_x, skbd_y, skbd_width, skbd_height;
    BOOL          fNewTitleSize = FALSE;


    hr = S_OK;

    if ( (_xReal == 0) &&
    	 (_yReal == 0 ) &&
    	 (_widthReal == 0) &&
    	 (_heightReal == 0) )
    {
    	// 
    	// means CreateSoftKeyboardWindow( ) has not been called yet
    	// we don't do more things.
    	//

    	return hr;
    }


    //
    // The soft keyboard window has already been created, and the window size is set,
    // generate realKbdLayout by extending or shrinking the key size from the size 
    // specified in the des file.
    //

    // check if there is SoftKeyboard Layout is set.
    //

    if ( _wCurKbdLayoutID == NON_KEYBOARD || _lpCurKbdLayout == NULL )
    {
    	//
    	// No layout is selected.
    	//

    	return hr;
    }

    // Generate the titlebar rect size, and button panel rectangle size.

    // Keep the relative postion. ( window client coordinate )

    switch ( _TitleBar_Type )
    {
    case TITLEBAR_NONE :

        _TitleBarRect.left = 0;
        _TitleBarRect.top =  0;
        _TitleBarRect.right = 0;
        _TitleBarRect.bottom = 0;

        break;

    case TITLEBAR_GRIPPER_HORIZ_ONLY :

        _TitleBarRect.left = 0;
        _TitleBarRect.top  = 0;
        _TitleBarRect.right = _TitleBarRect.left + _widthReal - 1;
        _TitleBarRect.bottom = _TitleBarRect.top + 6;
        break;

    case TITLEBAR_GRIPPER_VERTI_ONLY :

        _TitleBarRect.left = 0;
        _TitleBarRect.top  = 0;
        _TitleBarRect.right = _TitleBarRect.left + 6;
        _TitleBarRect.bottom = _TitleBarRect.top + _heightReal - 1;

        break;

    case TITLEBAR_GRIPPER_BUTTON :
        // assume to use horizontal title bar.
        _TitleBarRect.left = 0;
        _TitleBarRect.top  = 0;
        _TitleBarRect.right = _TitleBarRect.left + _widthReal - 1;
        _TitleBarRect.bottom = _TitleBarRect.top + 16;

        fNewTitleSize = TRUE;

        break;
    }

    if ( (_TitleBarRect.right - _TitleBarRect.left + 1) == _widthReal )
    {
        // This is a horizontal titlebar

        skbd_x = 0;
        skbd_y = (WORD)_TitleBarRect.bottom + 1;
        skbd_width = (WORD)_widthReal;
        skbd_height = (WORD)_heightReal - (WORD)(_TitleBarRect.bottom - _TitleBarRect.top + 1 );

    }
    else if ((_TitleBarRect.bottom - _TitleBarRect.top + 1) == _heightReal )
    {

        // This is a vertical titlebar.

        skbd_y = 0;
        skbd_x = (WORD)_TitleBarRect.right + 1;
        skbd_height = (WORD)_heightReal;
        skbd_width = (WORD)_widthReal - (WORD)(_TitleBarRect.right - _TitleBarRect.left + 1 );

    }
    else
    {
        // there is no titlebar
        skbd_x = 0;
        skbd_y = 0;
        skbd_height = (WORD)_heightReal;
        skbd_width = (WORD) _widthReal;
    }

    realKbdLayout = &( _lpCurKbdLayout->kbdLayout );

    if ( (realKbdLayout->wWidth == skbd_width) && (realKbdLayout->wHeight == skbd_height) )
    {
    	// this keyboard layout has been already adjusted.
    	//
    	hr = S_OK;
    	return hr;
    }

    if ( (realKbdLayout->wWidth == 0) || ( realKbdLayout->wHeight==0) )
    {
    	Assert(0);
    	hr = E_FAIL;
    	return hr;
    }

    fWidRat = (float)skbd_width / (float)realKbdLayout->wWidth;

    fHigRat = (float)(skbd_height) / (float) realKbdLayout->wHeight;


    // Adjust every key's size

    realKbdLayout->wMarginWidth = (WORD)((float)realKbdLayout->wMarginWidth * fWidRat);
    realKbdLayout->wMarginHeight = (WORD)((float)realKbdLayout->wMarginHeight * fHigRat);

    for ( i=0; i< realKbdLayout->wNumberOfKeys; i++ )
    {

       WORD     wLeft;  
       WORD     wTop;
       WORD     wWidth;
       WORD     wHeight;

       wLeft = (WORD)((float)(realKbdLayout->lpKeyDes[i].wLeft - realKbdLayout->wLeft ) * fWidRat);
       wTop  = (WORD)((float)(realKbdLayout->lpKeyDes[i].wTop - realKbdLayout->wTop) * fHigRat);
       wWidth = (WORD)((float)realKbdLayout->lpKeyDes[i].wWidth * fWidRat);
       wHeight = (WORD)((float)realKbdLayout->lpKeyDes[i].wHeight * fHigRat);

       realKbdLayout->lpKeyDes[i].wLeft = wLeft + skbd_x;
       realKbdLayout->lpKeyDes[i].wTop = wTop + skbd_y;
       realKbdLayout->lpKeyDes[i].wWidth = wWidth;
       realKbdLayout->lpKeyDes[i].wHeight = wHeight;
    }

    realKbdLayout->wLeft = (WORD)skbd_x;
    realKbdLayout->wTop = (WORD)skbd_y;
    realKbdLayout->wWidth = (WORD)skbd_width;
    realKbdLayout->wHeight = (WORD)skbd_height;

    if ( fNewTitleSize )
    {
        _TitleBarRect.left = realKbdLayout->lpKeyDes[0].wLeft;
        _TitleBarRect.right = realKbdLayout->lpKeyDes[realKbdLayout->wNumberOfKeys-1].wLeft + 
                              realKbdLayout->lpKeyDes[realKbdLayout->wNumberOfKeys-1].wWidth - 1;
    }

    return hr;
}

/*******************************************************************************
 *
 * Method function:  SelectSoftKeyboard(  )                                        
 *
 * Select current Active soft keyboard layout.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::SelectSoftKeyboard(DWORD dwKeyboardId)
{

    HRESULT       hr;
    KBDLAYOUTDES  *pKbdLayout;

    hr = S_OK;

     if ( _wCurKbdLayoutID == dwKeyboardId )
    	return hr;

    pKbdLayout = _lpKbdLayoutDesList;

    while ( pKbdLayout != NULL ) {

    	if ( pKbdLayout->wKbdLayoutID == dwKeyboardId )
    		break;

    	pKbdLayout = pKbdLayout->pNext;

    }

    
    if ( pKbdLayout == NULL ) 
    {
    	// 
    	// Cannot find this keyboard layout
    	//
    	hr = E_FAIL;
    	return hr;
    }


    _lpCurKbdLayout = pKbdLayout;

    _wCurKbdLayoutID = dwKeyboardId;

    // initialize realKbdLayout

    hr = _GenerateRealKbdLayout( );

    if ( _pSoftkbdUIWnd )
    {
       hr=_pSoftkbdUIWnd->_GenerateWindowLayout( );
    }

    return hr;
}

/*******************************************************************************
 *
 * Method function:  _SetStandardLabelText(  )                                        
 *
 * Generate mapping table in a certain modifier status for a standard soft
 * keyboard.
 *
/********************************************************************************/

HRESULT CSoftKbd::_SetStandardLabelText(LPBYTE  pKeyState, KBDLAYOUT *realKbdLayout,
    									KEYMAP  *lpKeyMapList, int  iState)
{
    UINT      i, j, nKeyNum;
    UINT      uVirtkey, uScanCode;
    HRESULT   hr;


    hr = S_OK;

    nKeyNum = (UINT)(realKbdLayout->wNumberOfKeys);

    // fill _CurLabel

    for ( i=0; i<nKeyNum; i++) {

    	// Assume the KEYID is scancode.

        WCHAR    szLabel[MAX_LABEL_LEN];
    	int      iRet, jIndex;
    	KEYID    keyId;

    	BOOL     fPitcureKey;
        PICTUREKEY  *pPictureKeys;

    	switch ( _wCurKbdLayoutID ) {

    	case SOFTKBD_JPN_STANDARD :
    	case SOFTKBD_JPN_ENHANCE  :
           	   pPictureKeys = gJpnPictureKeys;
    		   break;

    	case SOFTKBD_US_STANDARD   :
    	case SOFTKBD_US_ENHANCE    :
    	case SOFTKBD_EURO_STANDARD :
    	case SOFTKBD_EURO_ENHANCE  : 

                pPictureKeys = gPictureKeys;
    		   break;
    	}

        keyId = lpKeyMapList->lpKeyLabels[i].keyId = realKbdLayout->lpKeyDes[i].keyId;

    	fPitcureKey = FALSE;

    	for ( j=0; j<NUM_PICTURE_KEYS; j++)
    	{

    		if ( pPictureKeys[j].uScanCode == keyId )
    		{
    			// this is a picture key.
    			fPitcureKey = TRUE;
    			jIndex = j;

    			break;
    		}

    		if ( pPictureKeys[j].uScanCode == 0 )
    		{
    			// This is the last item in pPictureKeys.
    			break;
    		}

    	}


    	if ( fPitcureKey )
    	{

    	    lpKeyMapList->lpKeyLabels[i].lpLabelType[iState]  = LABEL_PICTURE;
            lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState]  = LABEL_DISP_ACTIVE;
            lpKeyMapList->lpKeyLabels[i].lppLabelText[iState] = SysAllocString(pPictureKeys[jIndex].PictBitmap);


    	}
    	else
    	{

    
            // All others are text labels. and have different strings for 
    		// different modifier combination statets.
    		//

            UINT   uScanSpace = 0x39;
            int    iLabelSize;
            BOOL   fFunctKey;

    	    uScanCode = realKbdLayout->lpKeyDes[i].keyId;
    	    uVirtkey = MapVirtualKeyEx(uScanCode, 1, _lpCurKbdLayout->CurhKl);

            fFunctKey = FALSE;

    	    // For the Function keys, we just use the hard code string to set
    	    // them as F1, F2, F3, ..... F12.

    	    WCHAR  wszFuncKey[MAX_LABEL_LEN];

    	    wszFuncKey[0] = L'F';

    	    switch (uScanCode) {

    	    case KID_F1  :
    	    case KID_F2  :
    	    case KID_F3  :
    	    case KID_F4  :
    	    case KID_F5  :
    	    case KID_F6  :
    	    case KID_F7  :
    	    case KID_F8  :
     	    case KID_F9  :
    		                wszFuncKey[1] = L'0' + uScanCode - KID_F1 + 1;
    				    	wszFuncKey[2] = L'\0';
    			    		wcscpy(szLabel, wszFuncKey);
                            fFunctKey = TRUE;
    		    			break;
    	    case KID_F10 :
    		                wcscpy(szLabel, L"F10");
                            fFunctKey = TRUE;
    		    			break;
    	    case KID_F11 :
    	                    wcscpy(szLabel, L"F11");
                            fFunctKey = TRUE;
    		    			break;
    	    case KID_F12 :					            
    			    		wcscpy(szLabel, L"F12");
                            fFunctKey = TRUE;
    		    			break;
    	    default :
    				            
    				        break;
    	    }

            if ( fFunctKey == TRUE )
            {

   	            lpKeyMapList->lpKeyLabels[i].lppLabelText[iState] = SysAllocString(szLabel);
   	            lpKeyMapList->lpKeyLabels[i].lpLabelType[iState]  = LABEL_TEXT;
                lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState]  = LABEL_DISP_ACTIVE;
                continue;
            }

    		if ( IsOnNT( ) )
            {

    	       iRet = ToUnicodeEx(uVirtkey, uScanCode | 0x80, pKeyState, szLabel, (int)(sizeof(szLabel)/sizeof(WCHAR)), 0, _lpCurKbdLayout->CurhKl);
               if ( iRet == 2 )
               {
                   // it is possible to have previous dead key, flush again.
                   iRet = ToUnicodeEx(uVirtkey, uScanCode | 0x80, pKeyState, szLabel, (int)(sizeof(szLabel)/sizeof(WCHAR)), 0, _lpCurKbdLayout->CurhKl);
               }

               iLabelSize = iRet;
            }
    		else
    		{
    			// Win9x doesn't support ToUnicodeEx, we just use alternative ToAsciiEx.

    			char  szLabelAnsi[MAX_LABEL_LEN];

    			iRet = ToAsciiEx(uVirtkey, uScanCode | 0x80, pKeyState, (LPWORD)szLabelAnsi, 0, _lpCurKbdLayout->CurhKl);

                if ( iRet == 2 )
                {
                    // it is possible to have previous dead key, flush again.
                    iRet = ToAsciiEx(uVirtkey, uScanCode | 0x80, pKeyState, (LPWORD)szLabelAnsi, 0, _lpCurKbdLayout->CurhKl);
                }

    			if ( iRet != 0 )
    			{
    				//
    				// Translate the ANSI label to Unicode based on ACP ... or other? 
    				//
                    if ( iRet == -1 )   // dead key, one character is written to szLabelAnsi buffer.
                        szLabelAnsi[1] = '\0';
                    else
        				szLabelAnsi[iRet] = '\0';

    				iLabelSize = MultiByteToWideChar(CP_ACP, 0, szLabelAnsi, -1, szLabel, MAX_LABEL_LEN );
    			}
    		}

            if ( iRet <= 0 )
            {
                iLabelSize = 1;
                if ( iRet == 0 )
                {
                    // Means no translation for this key at this shift state.
                    // We will display empty label, or space on the button.

                    szLabel[0] = 0x20;
                }
            }
          
            szLabel[iLabelSize] = L'\0';

    	    lpKeyMapList->lpKeyLabels[i].lppLabelText[iState] = SysAllocString(szLabel);
    	    lpKeyMapList->lpKeyLabels[i].lpLabelType[iState]  = LABEL_TEXT;
            lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState]  = LABEL_DISP_ACTIVE;

    	}

    }

    return hr;

}


/*******************************************************************************
 *
 * Method function:  _GenerateUSStandardLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for US standard
 * soft keyboard.
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateUSStandardLabel(  )
{

    //
    //  there are 4 different states for keyboard labels.
    //
    //    state  0  :   no any modifier key pressed
    //    state  1  :   Caps On.
    //    state  2  :   Shift pressed. Caps Off
    //    state  3  :   Shift Pressed, Caps On
    //

    // check to see if this soft keyboard support specified HKL.
    //
    //  ???
    //
    
    KEYMAP    *lpKeyMapList;
    HRESULT   hr;
    WORD      wNumModComb, wNumOfKeys;
    int       i, j;
    int       iState;
    BYTE      lpKeyState[256], lpCurKeyState[256];
    KBDLAYOUT *realKbdLayut;
    

    hr = S_OK;

    if ( _lpCurKbdLayout->lpKeyMapList != NULL ) 
    {

    	// If the mapping table for the specified HKL has already been created,
    	// Just return it.

    	HKL   CurhKl;

    	CurhKl = _lpCurKbdLayout->CurhKl;

    	lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    	while ( lpKeyMapList != NULL )
    	{

    		if ( lpKeyMapList->hKl ==  CurhKl )
    		{
    			// The mapping table is already created,

    			return hr;
    		}

    		lpKeyMapList = lpKeyMapList->pNext;
    	}

    }

    realKbdLayut = &(_lpCurKbdLayout->kbdLayout);

    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );

    if ( lpKeyMapList == NULL )
    {
    	// there is not enough memory.
    	hr = E_OUTOFMEMORY;
    	return hr;
    }


    // we have four different states.

    wNumModComb = 4;
    wNumOfKeys = _lpCurKbdLayout->kbdLayout.wNumberOfKeys;

    lpKeyMapList->wNumModComb = wNumModComb;
    lpKeyMapList->wNumOfKeys = wNumOfKeys;
    lpKeyMapList->hKl = _lpCurKbdLayout->CurhKl;

    for ( i=0; i<wNumOfKeys; i++ )
    {
       BSTR      *lppLabelText;
       WORD      *lpLabelType;
       WORD      *lpLabelDisp;


       lppLabelText = (BSTR *)cicMemAllocClear(wNumModComb * sizeof(BSTR) );

       if ( lppLabelText == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return

    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;

    	   return hr;
       }

       lpLabelType = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelType == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
 
       lpLabelDisp = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelDisp == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

           SafeFreePointer(lpLabelType);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
       
       lpKeyMapList->lpKeyLabels[i].lppLabelText = lppLabelText;
       lpKeyMapList->lpKeyLabels[i].lpLabelType = lpLabelType;
       lpKeyMapList->lpKeyLabels[i].lpLabelDisp = lpLabelDisp;
       lpKeyMapList->lpKeyLabels[i].wNumModComb = wNumModComb;
       
    }


    // Keep the current keyboard states on Win9x

    if ( !IsOnNT( ) )
    {
       if ( 0 == GetKeyboardState(lpCurKeyState) )
          return E_FAIL;
    }

    iState = 0;

    memset(lpKeyState, 0, 256);

    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    iState = 1;  // Caps On

    memset(lpKeyState, 0, 256);

    lpKeyState[VK_CAPITAL] = 0x01;

    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    iState = 2;  // Shift Down, Caps Off.

    memset(lpKeyState, 0, 256);

    lpKeyState[VK_SHIFT]   = 0x80;

    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    
    iState = 3;  // Shift Down, Caps On

    memset(lpKeyState, 0, 256);
    lpKeyState[VK_CAPITAL] = 0x01;
    lpKeyState[VK_SHIFT]   = 0x80;
    CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    // Add the newly created KeyMapList to the head of the mapping table link.

    lpKeyMapList->pNext = _lpCurKbdLayout->lpKeyMapList;
  
    _lpCurKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    // Restore the current keyboard states on Win9x

    if ( !IsOnNT( ) )
        SetKeyboardState(lpCurKeyState);

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateUSEnhanceLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for US enhanced
 * soft keyboard.
 *
/********************************************************************************/


HRESULT CSoftKbd::_GenerateUSEnhanceLabel(  )
{

    HRESULT hr;

    hr = E_NOTIMPL;

    // not yet implemented.

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateEuroStandardLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for Euro standard
 * soft keyboard. ( 102-key keyboard)
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateEuroStandardLabel(  )
{

    //
    //  there are 8 different states for keyboard labels.
    //
    //          AltGr  Shift  Caps.
    //  Bit       2     1      0
    //
    //    state  0  :   no any modifier key pressed
    //    state  1  :   Caps On.
    //    state  2  :   Shift pressed. Caps Off
    //    state  3  :   Shift Pressed, Caps On
    //
    //     .........

   
    KEYMAP    *lpKeyMapList;
    HRESULT   hr;
    WORD      wNumModComb, wNumOfKeys;
    int       i, j;
    int       iState;
    BYTE      lpKeyState[256], lpCurKeyState[256];
    KBDLAYOUT *realKbdLayut;
    WORD      BCaps, BShift, BAltGr;
    
    BCaps    = 1;
    BShift   = 2;
    BAltGr   = 4;

    hr = S_OK;
    if ( _lpCurKbdLayout->lpKeyMapList != NULL ) 
    {
    	// If the mapping table for the specified HKL has already been created,
    	// Just return it.

    	HKL   CurhKl;

    	CurhKl = _lpCurKbdLayout->CurhKl;

    	lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    	while ( lpKeyMapList != NULL )
    	{

    		if ( lpKeyMapList->hKl ==  CurhKl )
    		{
    			// The mapping table is already created,

    			return hr;
    		}

    		lpKeyMapList = lpKeyMapList->pNext;
    	}

    }
    
    realKbdLayut = &(_lpCurKbdLayout->kbdLayout);
    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );
    if ( lpKeyMapList == NULL )
    {
    	// there is not enough memory.
    	hr = E_OUTOFMEMORY;
    	return hr;
    }

    // we have 8 different states.
    wNumModComb = 8;
    wNumOfKeys = _lpCurKbdLayout->kbdLayout.wNumberOfKeys;

    lpKeyMapList->wNumModComb = wNumModComb;
    lpKeyMapList->wNumOfKeys = wNumOfKeys;
    lpKeyMapList->pNext = NULL;
    lpKeyMapList->hKl = _lpCurKbdLayout->CurhKl;

    for ( i=0; i<wNumOfKeys; i++ )
    {
       BSTR      *lppLabelText=NULL;
       WORD      *lpLabelType=NULL;
       WORD      *lpLabelDisp=NULL;

       lppLabelText = (BSTR *)cicMemAllocClear(wNumModComb * sizeof(BSTR) );
       lpLabelType = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );
       lpLabelDisp = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );
       
       if ( (lpLabelDisp == NULL) || (lpLabelType== NULL) || (lppLabelText == NULL) ) {
    	   // 
    	   // there is not enough memory.
    	   //
    	   // release allocated memory and return
    	   for ( j=0; j<i; j++ )
    	   {
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);
           SafeFreePointer(lpLabelType);
    	   SafeFreePointer(lpKeyMapList);
    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
              
       lpKeyMapList->lpKeyLabels[i].lppLabelText = lppLabelText;
       lpKeyMapList->lpKeyLabels[i].lpLabelType = lpLabelType;
       lpKeyMapList->lpKeyLabels[i].lpLabelDisp = lpLabelDisp;
       lpKeyMapList->lpKeyLabels[i].wNumModComb = wNumModComb;
       
    }

    // Keep the current keyboard states on Win9x.
    if ( !IsOnNT( ) )
    {
        if ( 0 == GetKeyboardState(lpCurKeyState) )
           return E_FAIL;
    }

    for (iState = 0; iState < wNumModComb; iState ++ )
    {
        memset(lpKeyState, 0, 256);
    	if ( iState & BCaps )
    		 lpKeyState[VK_CAPITAL]=0x01;

        if ( iState & BShift )
             lpKeyState[VK_SHIFT] = 0x80;

        if ( iState & BAltGr )
        {
    	    lpKeyState[VK_MENU] = 0x80;
            lpKeyState[VK_CONTROL] = 0x80;
        }
        CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));
    }
  
    _lpCurKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    // Restore the current keyboard states on Win9x.

    if ( ! IsOnNT( ) )
        SetKeyboardState(lpCurKeyState);

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateEuroEnhanceLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for Euro Enhanced
 * soft keyboard. ( 102-key +  NumPad )
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateEuroEnhanceLabel(  )
{

    HRESULT hr;

    hr = E_NOTIMPL;

    // not yet implemented.

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateJpnStandardLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for JPN standard
 * soft keyboard. ( 106-key)
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateJpnStandardLabel(  )
{

    //
    //  there are 16 different states for keyboard labels.
    //
    //       Kana   Alt  Shift  Caps.
    //  Bit    3     2     1      0
    //
    //    state  0  :   no any modifier key pressed
    //    state  1  :   Caps On.
    //    state  2  :   Shift pressed. Caps Off
    //    state  3  :   Shift Pressed, Caps On
    //

   
    KEYMAP    *lpKeyMapList;
    HRESULT   hr;
    WORD      wNumModComb, wNumOfKeys;
    int       i, j;
    int       iState;
    BYTE      lpKeyState[256], lpCurKeyState[256];
    KBDLAYOUT *realKbdLayut;


    WORD      BCaps, BShift, BAlt, BKana;
    
    BCaps    = 1;
    BShift   = 2;
    BAlt     = 4;
    BKana    = 8;

    hr = S_OK;

    if ( _lpCurKbdLayout->lpKeyMapList != NULL ) 
    {

        return hr;

    }


    realKbdLayut = &(_lpCurKbdLayout->kbdLayout);

    lpKeyMapList = (KEYMAP  *)cicMemAllocClear(sizeof(KEYMAP) );

    if ( lpKeyMapList == NULL )
    {
    	// there is not enough memory.
    	hr = E_OUTOFMEMORY;
    	return hr;
    }


    // we have four different states.

    wNumModComb = 16;
    wNumOfKeys = _lpCurKbdLayout->kbdLayout.wNumberOfKeys;

    lpKeyMapList->wNumModComb = wNumModComb;
    lpKeyMapList->wNumOfKeys = wNumOfKeys;
    lpKeyMapList->pNext = NULL;
    lpKeyMapList->hKl = _lpCurKbdLayout->CurhKl;

    for ( i=0; i<wNumOfKeys; i++ )
    {
       BSTR      *lppLabelText;
       WORD      *lpLabelType;
       WORD      *lpLabelDisp;


       lppLabelText = (BSTR *)cicMemAllocClear(wNumModComb * sizeof(BSTR) );

       if ( lppLabelText == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return

    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;

    	   return hr;
       }

       lpLabelType = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelType == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
 
       lpLabelDisp = (WORD *)cicMemAllocClear(wNumModComb * sizeof(WORD) );

       if ( lpLabelDisp == NULL ) {
    	   // 
    	   // there is not enough memory.
    	   //

    	   // release allocated memory and return


    	   for ( j=0; j<i; j++ )
    	   {

    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lppLabelText);
    		   SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelType);
               SafeFreePointer(lpKeyMapList->lpKeyLabels[j].lpLabelDisp);
    	   }

    	   SafeFreePointer(lppLabelText);

           SafeFreePointer(lpLabelType);

    	   SafeFreePointer(lpKeyMapList);

    	   hr = E_OUTOFMEMORY;
    	   return hr;
       }
              
       lpKeyMapList->lpKeyLabels[i].lppLabelText = lppLabelText;
       lpKeyMapList->lpKeyLabels[i].lpLabelType = lpLabelType;
       lpKeyMapList->lpKeyLabels[i].lpLabelDisp = lpLabelDisp;
       lpKeyMapList->lpKeyLabels[i].wNumModComb = wNumModComb;
       
    }

    // Keep the current keyboard states on Win9x.

    if ( !IsOnNT( ) )
    {
        if ( 0 == GetKeyboardState(lpCurKeyState) )
            return E_FAIL;
    }

    for (iState = 0; iState < wNumModComb; iState ++ )
    {

         memset(lpKeyState, 0, 256);

    	if ( iState & BCaps )
    			lpKeyState[VK_CAPITAL] = 0x01;
       
    	if ( iState & BShift )
           lpKeyState[VK_SHIFT] = 0x80;

    	if ( iState & BAlt )
    	    lpKeyState[VK_MENU] = 0x80;

    	if ( iState & BKana )
    		lpKeyState[VK_KANA] = 0x01;

        CHECKHR(_SetStandardLabelText(lpKeyState, realKbdLayut,lpKeyMapList,iState));

    }
  
    _lpCurKbdLayout->lpKeyMapList = lpKeyMapList;

CleanUp:

    // Restore the current keyboard states on Win9x.

    if ( ! IsOnNT( ) )
        SetKeyboardState(lpCurKeyState);

    return hr;

}

/*******************************************************************************
 *
 * Method function:  _GenerateJpnEnhanceLabel(  )                                        
 *
 * Generate all mapping labels in different modifier status for JPN enhanced
 * soft keyboard. (106-key + NumPad )
 *
/********************************************************************************/

HRESULT CSoftKbd::_GenerateJpnEnhanceLabel(  )
{

    HRESULT hr;

    hr = E_NOTIMPL;

    // not yet implemented.

    return hr;
}

/*******************************************************************************
 *
 * Method function:  SetKeyboardLabelText(  )                                        
 *
 * Set the mapping label texts based on specified HKL.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::SetKeyboardLabelText(HKL hKl)
{

    KBDLAYOUT   *realKbdLayout;
    HRESULT     hr;
    DWORD       iModiCombState;
    WORD        iModifierStatus;

    realKbdLayout = &(_lpCurKbdLayout->kbdLayout);

    hr = S_OK;

    if ( realKbdLayout->fStandard == FALSE ) {
    	//
    	// customized layout cannot accept HKL to change its keys' labels.
    	//
    	_lpCurKbdLayout->CurhKl = 0;
    	hr = E_FAIL;
    	return hr;
    }



    if ( ! IsOnNT( ) )
    {

    	// We have to handle IME hkl specially on Win9x.
    	// For some reason, Win9x cannot receive IME HKL as parameter in MapVirtualKeyEx and ToAsciiEx.

        INT_PTR iHkl;

    	iHkl = (INT_PTR)hKl;

    	if ( (iHkl & 0xF0000000) == 0xE0000000 )
    	{
    		// this is FE IME HKL.

    		iHkl = iHkl & 0x0000ffff;

    		hKl = (HKL) iHkl;
    	}

    }


    _lpCurKbdLayout->CurhKl = (HKL)hKl;


    //
    // check to see if current standard keyboard supports this HKL
    //

    switch ( _wCurKbdLayoutID ) {

       case  SOFTKBD_US_STANDARD :
    	     
    	      CHECKHR(_GenerateUSStandardLabel( ));

    		  break;

       case SOFTKBD_US_ENHANCE :

    	      CHECKHR(_GenerateUSEnhanceLabel( ));
    		  break;

       case SOFTKBD_EURO_STANDARD :

    	      CHECKHR(_GenerateEuroStandardLabel(  ));
    		  break;

       case SOFTKBD_EURO_ENHANCE :

    	      CHECKHR(_GenerateEuroEnhanceLabel( ));
    		  break;

       case SOFTKBD_JPN_STANDARD :

    	      CHECKHR(_GenerateJpnStandardLabel( ));
    		  break;

       case SOFTKBD_JPN_ENHANCE :

    	      CHECKHR(_GenerateJpnEnhanceLabel( ));
    		  break;
    }

    // set current Active mapping labels.

    // Generate CurModiState based on current keyboard state
    
     _GenerateCurModiState(&iModifierStatus, &iModiCombState);
     _lpCurKbdLayout->ModifierStatus = iModifierStatus;
     hr = SetKeyboardLabelTextCombination(iModiCombState);

CleanUp:
    return hr;
}

/*******************************************************************************
 *
 * Method function:  _SetKeyboardLabelTextCombination(  )                                        
 *
 * Set current effective modifier combination status, so that the correct
 * mapping labels will be shown up.
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::SetKeyboardLabelTextCombination(DWORD iModiCombState)
{

    WORD      wNumberOfKeys, i;
    KEYMAP    *lpKeyMapList;
    HRESULT    hr;

    
    hr = S_OK;
    if ( _lpCurKbdLayout == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( _lpCurKbdLayout->lpKeyMapList == NULL )
    {
    	hr = E_FAIL;
    	return hr;
    }

    if ( (_lpCurKbdLayout->kbdLayout).fStandard )
    {
    	// This is a standard keyboard layout, we need to
    	// find out the correct mapping table for the current
    	// specified HKL.

    	// Every mapping table is associated with a HKL.
    	// the current specified HKL is stored in _lpCurKbdLayout->CurhKl.

    	HKL   CurhKl;

    	CurhKl = _lpCurKbdLayout->CurhKl;

    	lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    	while ( lpKeyMapList->hKl !=  CurhKl )
    	{
    		lpKeyMapList = lpKeyMapList->pNext;

    		if ( lpKeyMapList == NULL )
    		{
    			// No mapping table is associated with the specified HKL.
    			// return error.

    			hr = E_FAIL;
    			return hr;
    		}
    	}

    }
    else
        lpKeyMapList = _lpCurKbdLayout->lpKeyMapList;

    if ( iModiCombState >= lpKeyMapList->wNumModComb)
    {
    	hr = E_FAIL;
    	return hr;
    }

    _lpCurKbdLayout->CurModiState = iModiCombState;

    // Now fill _CurLabel,  Current Active label for every key.

    wNumberOfKeys = (_lpCurKbdLayout->kbdLayout).wNumberOfKeys;

    for ( i=0; i<wNumberOfKeys; i++)
    {
      int  iState;

      _CurLabel[i].keyId = lpKeyMapList->lpKeyLabels[i].keyId;

      iState = iModiCombState;

      
      if ( iModiCombState >= lpKeyMapList->lpKeyLabels[i].wNumModComb )
      {
    	  // there is not enough different states for this key
    	  // just use state 0.
    	  iState = 0;
      }

      _CurLabel[i].lpLabelText = lpKeyMapList->lpKeyLabels[i].lppLabelText[iState];
      _CurLabel[i].LabelType   = lpKeyMapList->lpKeyLabels[i].lpLabelType[iState];
      _CurLabel[i].LabelDisp   = lpKeyMapList->lpKeyLabels[i].lpLabelDisp[iState];

    }

    if ( _pSoftkbdUIWnd )
    {
        _pSoftkbdUIWnd->_SetKeyLabel( );
    }
    
    return hr;
}

/*******************************************************************************
 *
 * Method function:  _GenerateCurModiState(  )                                        
 *
 * Generate Softkbd recognized ModifierStatus and CurModiState based on 
 * current keyboard states.
 * 
 /********************************************************************************/
HRESULT  CSoftKbd::_GenerateCurModiState(WORD *ModifierStatus, DWORD *CurModiState )
{
   DWORD    iModiCombState;
   WORD     iModifierStatus;
   DWORD    iTmp;
   HRESULT  hr = S_OK;

   if ( !ModifierStatus  || !CurModiState )
       return E_FAIL;

   if ( (_lpCurKbdLayout->kbdLayout).fStandard == FALSE )
       return E_FAIL;

   iModifierStatus = 0;
   if ( GetKeyState(VK_CAPITAL) & 0x01 )
   {
       // Caps key is Toggled.
        iModifierStatus |= MODIFIER_CAPSLOCK ;
   }

   if ( GetKeyState(VK_SHIFT) & 0x80 )
   {
       // Shift key is pressed.
        iModifierStatus |= MODIFIER_SHIFT;
   }

   if ( GetKeyState(VK_CONTROL) & 0x80 )
   {
       // Ctrl key is pressed.
        iModifierStatus |= MODIFIER_CTRL;
   }

   if ( GetKeyState(VK_LMENU) & 0x80 )
   {
       // Left Alt key is pressed.
        iModifierStatus |= MODIFIER_ALT;
   }

   if ( GetKeyState(VK_RMENU) & 0x80 )
   {
       // Right Alt key is pressed.
        iModifierStatus |= MODIFIER_ALTGR;
   }

   if ( GetKeyState(VK_KANA) & 0x01 )
   {
       // KANA key is Toggled.
        iModifierStatus |= MODIFIER_KANA;
   }


   *ModifierStatus = iModifierStatus;

   switch ( _wCurKbdLayoutID )  {

   case SOFTKBD_US_STANDARD   :
   case SOFTKBD_US_ENHANCE    :
        // this is for US Standard keyboard.
        // others may need to handle separately.

        iModiCombState = (iModifierStatus) & (MODIFIER_CAPSLOCK | MODIFIER_SHIFT);
        iModiCombState = iModiCombState >> 1;

        // bit1 for Caps.
        // bit2 for Shift
        break;

   case SOFTKBD_EURO_STANDARD :
   case SOFTKBD_EURO_ENHANCE  :
        // this is for Euro 102 standard keyboard.
	    // How to map ModifierStatus -> CurModiState.
        
        // bit 1 for Caps, bit2 for Shift, bit3 for AltGr.

        iModiCombState = (iModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
        iModiCombState = iModiCombState >> 1;

	    iTmp = (iModifierStatus) & MODIFIER_ALTGR;
	    iTmp = iTmp >> 4;

	    iModiCombState += iTmp;

	    break;
 
   case SOFTKBD_JPN_STANDARD  :
   case SOFTKBD_JPN_ENHANCE   :

	   // How to map ModifierStatus -> CurModiState.

       iModiCombState = (iModifierStatus) & ( MODIFIER_CAPSLOCK | MODIFIER_SHIFT );
       iModiCombState = iModiCombState >> 1;

	   iTmp = (iModifierStatus) & (MODIFIER_ALT | MODIFIER_KANA);
	   iTmp = iTmp >> 2;

	   iModiCombState += iTmp;

	   break;
   }

   *CurModiState = iModiCombState;

   return hr;
 
}

/*******************************************************************************
 *
 * Method function:  ShowSoftKeyboard(  )                                        
 *
 * Show or Hide the soft keyboard window based on the specified parameter.
 * 
 *
/********************************************************************************/

STDMETHODIMP CSoftKbd::ShowSoftKeyboard(INT iShow)
{

    HRESULT  hr;

    hr = S_OK;

    if (!_pSoftkbdUIWnd) {
    	 
        hr = E_FAIL;
    	return hr;
    }

    // if client doesn't specify which layout is selected,
    // we just select a default standard soft keyboard layout
    // based on current thread keyboard layout.

    // if current thread keyboard layout is JPN, use 106 key.
    // others, use 101key.

    // run SelectSoftKeyboard( SelectedID );
    //

    if ( _wCurKbdLayoutID == NON_KEYBOARD )
    {
       HKL     hKl;
       DWORD   dwLayoutId;
       LANGID  langId;

       hKl = GetKeyboardLayout(0);

       langId = LOWORD( (DWORD)(UINT_PTR)hKl);

       if ( langId == 0x0411 )  // Japanese keyboard
       {
            dwLayoutId = SOFTKBD_JPN_STANDARD;
       }
       else
            dwLayoutId = SOFTKBD_US_STANDARD; 
           
       CHECKHR(SelectSoftKeyboard(dwLayoutId) );
       CHECKHR(SetKeyboardLabelText(hKl));

    }

    _pSoftkbdUIWnd->Show(iShow);

    _iShow = iShow;

CleanUp:

    return hr;
}


/*******************************************************************************
 *
 * Method function:  CreateSoftKeyboardWindow(  )                                        
 *
 * Create a real soft keyboard popup window.
 *
/********************************************************************************/


STDMETHODIMP CSoftKbd::CreateSoftKeyboardWindow(HWND hOwner, TITLEBAR_TYPE Titlebar_type, INT xPos, INT yPos, INT width, INT height)
{
    // TODO: Add your implementation code here

    HRESULT  hr;

    hr = S_OK;
    _hOwner = hOwner;

    _xReal = xPos;
    _yReal = yPos;
    _widthReal = width;
    _heightReal= height;

    _TitleBar_Type = Titlebar_type;  // temporal solution.
    //
    // generate realKbdLayout
    //
    CHECKHR(_GenerateRealKbdLayout( ));


    if ( _pSoftkbdUIWnd != NULL )
        de